#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RallyHereStart

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "RallyHereStart_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "CommonUI_classes.hpp"
#include "RallyHereIntegration_structs.hpp"
#include "SlateCore_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "RallyHereAPI_structs.hpp"


namespace SDK
{

// Class RallyHereStart.IconInfo
// 0x0000 (0x0028 - 0x0028)
class UIconInfo : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IconInfo">();
	}
	static class UIconInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIconInfo>();
	}
};
static_assert(alignof(UIconInfo) == 0x000008, "Wrong alignment on UIconInfo");
static_assert(sizeof(UIconInfo) == 0x000028, "Wrong size on UIconInfo");

// Class RallyHereStart.ImageIconInfo
// 0x0030 (0x0058 - 0x0028)
class UImageIconInfo final : public UIconInfo
{
public:
	struct FSoftObjectPath                        IconImage;                                         // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconTint;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageIconInfo">();
	}
	static class UImageIconInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageIconInfo>();
	}
};
static_assert(alignof(UImageIconInfo) == 0x000008, "Wrong alignment on UImageIconInfo");
static_assert(sizeof(UImageIconInfo) == 0x000058, "Wrong size on UImageIconInfo");
static_assert(offsetof(UImageIconInfo, IconImage) == 0x000028, "Member 'UImageIconInfo::IconImage' has a wrong offset!");
static_assert(offsetof(UImageIconInfo, IconTint) == 0x000048, "Member 'UImageIconInfo::IconTint' has a wrong offset!");

// Class RallyHereStart.ItemCollection
// 0x0068 (0x0098 - 0x0030)
class UItemCollection final : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetRules                     Rules;                                             // 0x0030(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      CollectionQuery;                                   // 0x0040(0x0048)(Edit, NativeAccessSpecifierPublic)
	class FName                                   PrimaryAssetType;                                  // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCollection">();
	}
	static class UItemCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCollection>();
	}
};
static_assert(alignof(UItemCollection) == 0x000008, "Wrong alignment on UItemCollection");
static_assert(sizeof(UItemCollection) == 0x000098, "Wrong size on UItemCollection");
static_assert(offsetof(UItemCollection, Rules) == 0x000030, "Member 'UItemCollection::Rules' has a wrong offset!");
static_assert(offsetof(UItemCollection, CollectionQuery) == 0x000040, "Member 'UItemCollection::CollectionQuery' has a wrong offset!");
static_assert(offsetof(UItemCollection, PrimaryAssetType) == 0x000088, "Member 'UItemCollection::PrimaryAssetType' has a wrong offset!");

// Class RallyHereStart.PInv_AssetManager
// 0x0300 (0x07D0 - 0x04D0)
class UPInv_AssetManager : public UAssetManager
{
public:
	uint8                                         Pad_4D0[0xA0];                                     // 0x04D0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasCompletedInitialAssetScan;                     // 0x0570(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_571[0x1EF];                                    // 0x0571(0x01EF)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsQuickCook;                                      // 0x0760(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_761[0x7];                                      // 0x0761(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AdditionalQuickCookPrimaryAssets;                  // 0x0768(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   CookProfile;                                       // 0x0778(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_780[0x50];                                     // 0x0780(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PInv_AssetManager">();
	}
	static class UPInv_AssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPInv_AssetManager>();
	}
};
static_assert(alignof(UPInv_AssetManager) == 0x000008, "Wrong alignment on UPInv_AssetManager");
static_assert(sizeof(UPInv_AssetManager) == 0x0007D0, "Wrong size on UPInv_AssetManager");
static_assert(offsetof(UPInv_AssetManager, bHasCompletedInitialAssetScan) == 0x000570, "Member 'UPInv_AssetManager::bHasCompletedInitialAssetScan' has a wrong offset!");
static_assert(offsetof(UPInv_AssetManager, bIsQuickCook) == 0x000760, "Member 'UPInv_AssetManager::bIsQuickCook' has a wrong offset!");
static_assert(offsetof(UPInv_AssetManager, AdditionalQuickCookPrimaryAssets) == 0x000768, "Member 'UPInv_AssetManager::AdditionalQuickCookPrimaryAssets' has a wrong offset!");
static_assert(offsetof(UPInv_AssetManager, CookProfile) == 0x000778, "Member 'UPInv_AssetManager::CookProfile' has a wrong offset!");

// Class RallyHereStart.PInv_AssetManagerSettings
// 0x0130 (0x0168 - 0x0038)
class UPInv_AssetManagerSettings final : public UDeveloperSettings
{
public:
	bool                                          bQuickCook;                                        // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PrimaryTypesToIgnoreQuickCook;                     // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSet<class FName>                             QuickCookTypeIgnoreSet;                            // 0x0050(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<class FString>                         PrimaryAssetsToIgnoreQuickCook;                    // 0x00A0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSet<struct FPrimaryAssetId>                  QuickCookAssetIgnoreSet;                           // 0x00B0(0x0050)(Transient, NativeAccessSpecifierPublic)
	TSet<struct FPrimaryAssetType>                QuickCookAssetIngoreSetTypes;                      // 0x0100(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<class FString>                         PrimaryAssetsToIncludeQuickCook;                   // 0x0150(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FName                                   CookProfile;                                       // 0x0160(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PInv_AssetManagerSettings">();
	}
	static class UPInv_AssetManagerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPInv_AssetManagerSettings>();
	}
};
static_assert(alignof(UPInv_AssetManagerSettings) == 0x000008, "Wrong alignment on UPInv_AssetManagerSettings");
static_assert(sizeof(UPInv_AssetManagerSettings) == 0x000168, "Wrong size on UPInv_AssetManagerSettings");
static_assert(offsetof(UPInv_AssetManagerSettings, bQuickCook) == 0x000038, "Member 'UPInv_AssetManagerSettings::bQuickCook' has a wrong offset!");
static_assert(offsetof(UPInv_AssetManagerSettings, PrimaryTypesToIgnoreQuickCook) == 0x000040, "Member 'UPInv_AssetManagerSettings::PrimaryTypesToIgnoreQuickCook' has a wrong offset!");
static_assert(offsetof(UPInv_AssetManagerSettings, QuickCookTypeIgnoreSet) == 0x000050, "Member 'UPInv_AssetManagerSettings::QuickCookTypeIgnoreSet' has a wrong offset!");
static_assert(offsetof(UPInv_AssetManagerSettings, PrimaryAssetsToIgnoreQuickCook) == 0x0000A0, "Member 'UPInv_AssetManagerSettings::PrimaryAssetsToIgnoreQuickCook' has a wrong offset!");
static_assert(offsetof(UPInv_AssetManagerSettings, QuickCookAssetIgnoreSet) == 0x0000B0, "Member 'UPInv_AssetManagerSettings::QuickCookAssetIgnoreSet' has a wrong offset!");
static_assert(offsetof(UPInv_AssetManagerSettings, QuickCookAssetIngoreSetTypes) == 0x000100, "Member 'UPInv_AssetManagerSettings::QuickCookAssetIngoreSetTypes' has a wrong offset!");
static_assert(offsetof(UPInv_AssetManagerSettings, PrimaryAssetsToIncludeQuickCook) == 0x000150, "Member 'UPInv_AssetManagerSettings::PrimaryAssetsToIncludeQuickCook' has a wrong offset!");
static_assert(offsetof(UPInv_AssetManagerSettings, CookProfile) == 0x000160, "Member 'UPInv_AssetManagerSettings::CookProfile' has a wrong offset!");

// Class RallyHereStart.PlatformInventoryItem
// 0x0148 (0x0178 - 0x0030)
class UPlatformInventoryItem : public UPrimaryDataAsset
{
public:
	class FText                                   ItemDisplayName;                                   // 0x0030(0x0018)(Edit, DisableEditOnInstance, DuplicateTransient, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x0048(0x0018)(Edit, DisableEditOnInstance, DuplicateTransient, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class FString                                 FriendlySearchName;                                // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, DuplicateTransient, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyDisplayAcqusitionIfWhitelisted;                // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CollectionContainer;                               // 0x0078(0x0020)(Edit, Config, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	bool                                          CanOwnMultiple;                                    // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_ItemId                             ItemId;                                            // 0x009C(0x0014)(Edit, DisableEditOnInstance, DuplicateTransient, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_LootId                             PurchaseLootId;                                    // 0x00B0(0x0014)(Edit, DisableEditOnInstance, DuplicateTransient, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanSelectPurchaseQuantity;                        // 0x00C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOwnableInventoryItem;                            // 0x00C5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRH_LootId>                     DisplayableLootIds;                                // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UIconInfo*                              ItemIconInfo;                                      // 0x00D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FIconReference>                 Icons;                                             // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<EExternalSkuSource, class FString>       ExternalProductSkus;                               // 0x00F0(0x0050)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRH_LootId>                     BlacklistedLootIds;                                // 0x0140(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x28];                                     // 0x0150(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TSoftObjectPtr<class UPlatformInventoryItem> GetItemByFriendlyName(const class FString& InFriendlyName);

	void BLUEPRINT_CanOwnMore(const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(bool IsValid)>& Delegate);
	void BLUEPRINT_GetQuantityOwned(const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(int32 InstanceCount)>& Delegate);
	void BLUEPRINT_IsOwned(const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(bool IsValid)>& Delegate);
	void BLUEPRINT_IsRented(const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(bool IsValid)>& Delegate);
	void GetTextureAsync(TSoftObjectPtr<class UTexture2D>* Texture, const TDelegate<void(class UTexture2D* ItemIcon)>& IconLoadedEvent);
	void SetCollectionContainer(const struct FGameplayTagContainer& InContainer);
	void SetFriendlySearchName(const class FString& InFriendlyName);
	void SetItemDescription(const class FText& NewItemDescription);
	void SetItemName(const class FText& NewItemDisplayName);

	bool CanSelectPurchaseQuantity() const;
	void GetAllIconTexturesForTag(const struct FGameplayTag& IconTag, TMap<struct FGameplayTag, TSoftObjectPtr<class UTexture2D>>* OutTextures) const;
	const struct FGameplayTagContainer GetCollectionContainer() const;
	class FString GetFriendlySearchName() const;
	bool GetIconInfoByName(class FName IconType, class UIconInfo** Icon) const;
	bool GetIconInfoByTag(const struct FGameplayTag& IconTag, class UIconInfo** OutIcon, bool bExactMatch) const;
	TSoftObjectPtr<class UMaterialInterface> GetIconMaterialByTag(const struct FGameplayTag& IconTag, bool bExactMatch) const;
	TSoftObjectPtr<class UTexture2D> GetIconTextureByTag(const struct FGameplayTag& IconTag, bool bExactMatch) const;
	class FText GetItemDescription() const;
	class FString GetItemDescriptionAsString() const;
	class UIconInfo* GetItemIconInfo() const;
	TSoftObjectPtr<class UTexture2D> GetItemIconTexture() const;
	const struct FRH_ItemId GetItemId() const;
	class FText GetItemName() const;
	class FString GetItemNameAsString() const;
	const struct FRH_LootId GetLootId() const;
	bool IsItemDisabled(bool bIncludeTempDisabled) const;
	bool IsItemTempDisabled() const;
	bool ShouldDisplayToUser(const struct FRH_LootId& LootId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformInventoryItem">();
	}
	static class UPlatformInventoryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformInventoryItem>();
	}
};
static_assert(alignof(UPlatformInventoryItem) == 0x000008, "Wrong alignment on UPlatformInventoryItem");
static_assert(sizeof(UPlatformInventoryItem) == 0x000178, "Wrong size on UPlatformInventoryItem");
static_assert(offsetof(UPlatformInventoryItem, ItemDisplayName) == 0x000030, "Member 'UPlatformInventoryItem::ItemDisplayName' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, ItemDescription) == 0x000048, "Member 'UPlatformInventoryItem::ItemDescription' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, FriendlySearchName) == 0x000060, "Member 'UPlatformInventoryItem::FriendlySearchName' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, OnlyDisplayAcqusitionIfWhitelisted) == 0x000070, "Member 'UPlatformInventoryItem::OnlyDisplayAcqusitionIfWhitelisted' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, CollectionContainer) == 0x000078, "Member 'UPlatformInventoryItem::CollectionContainer' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, CanOwnMultiple) == 0x000098, "Member 'UPlatformInventoryItem::CanOwnMultiple' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, ItemId) == 0x00009C, "Member 'UPlatformInventoryItem::ItemId' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, PurchaseLootId) == 0x0000B0, "Member 'UPlatformInventoryItem::PurchaseLootId' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, bCanSelectPurchaseQuantity) == 0x0000C4, "Member 'UPlatformInventoryItem::bCanSelectPurchaseQuantity' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, IsOwnableInventoryItem) == 0x0000C5, "Member 'UPlatformInventoryItem::IsOwnableInventoryItem' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, DisplayableLootIds) == 0x0000C8, "Member 'UPlatformInventoryItem::DisplayableLootIds' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, ItemIconInfo) == 0x0000D8, "Member 'UPlatformInventoryItem::ItemIconInfo' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, Icons) == 0x0000E0, "Member 'UPlatformInventoryItem::Icons' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, ExternalProductSkus) == 0x0000F0, "Member 'UPlatformInventoryItem::ExternalProductSkus' has a wrong offset!");
static_assert(offsetof(UPlatformInventoryItem, BlacklistedLootIds) == 0x000140, "Member 'UPlatformInventoryItem::BlacklistedLootIds' has a wrong offset!");

// Class RallyHereStart.RH_PlatformStoreAssetOwnershipHelper
// 0x0058 (0x0080 - 0x0028)
class URH_PlatformStoreAssetOwnershipHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_PlatformStoreAssetOwnershipHelper">();
	}
	static class URH_PlatformStoreAssetOwnershipHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_PlatformStoreAssetOwnershipHelper>();
	}
};
static_assert(alignof(URH_PlatformStoreAssetOwnershipHelper) == 0x000008, "Wrong alignment on URH_PlatformStoreAssetOwnershipHelper");
static_assert(sizeof(URH_PlatformStoreAssetOwnershipHelper) == 0x000080, "Wrong size on URH_PlatformStoreAssetOwnershipHelper");
static_assert(offsetof(URH_PlatformStoreAssetOwnershipHelper, PlayerInfo) == 0x000078, "Member 'URH_PlatformStoreAssetOwnershipHelper::PlayerInfo' has a wrong offset!");

// Class RallyHereStart.PlatformStoreAsset
// 0x0010 (0x0188 - 0x0178)
class UPlatformStoreAsset final : public UPlatformInventoryItem
{
public:
	TArray<class URH_PlatformStoreAssetOwnershipHelper*> PendingOwnershipRequests;                   // 0x0178(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreAsset">();
	}
	static class UPlatformStoreAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreAsset>();
	}
};
static_assert(alignof(UPlatformStoreAsset) == 0x000008, "Wrong alignment on UPlatformStoreAsset");
static_assert(sizeof(UPlatformStoreAsset) == 0x000188, "Wrong size on UPlatformStoreAsset");
static_assert(offsetof(UPlatformStoreAsset, PendingOwnershipRequests) == 0x000178, "Member 'UPlatformStoreAsset::PendingOwnershipRequests' has a wrong offset!");

// Class RallyHereStart.PlayerExperienceGlobals
// 0x0078 (0x00A0 - 0x0028)
class UPlayerExperienceGlobals final : public UObject
{
public:
	bool                                          Enabled;                                           // 0x0028(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         PlayerExperienceGlobalsClassName;                  // 0x0030(0x0020)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MatchTrackerClassName;                             // 0x0050(0x0020)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerExp_MatchTracker*                ActiveMatchTracker;                                // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MatchReportSenderClassName;                        // 0x0078(0x0020)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerExp_MatchReportSender*           MatchReportSender;                                 // 0x0098(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerExperienceGlobals">();
	}
	static class UPlayerExperienceGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerExperienceGlobals>();
	}
};
static_assert(alignof(UPlayerExperienceGlobals) == 0x000008, "Wrong alignment on UPlayerExperienceGlobals");
static_assert(sizeof(UPlayerExperienceGlobals) == 0x0000A0, "Wrong size on UPlayerExperienceGlobals");
static_assert(offsetof(UPlayerExperienceGlobals, Enabled) == 0x000028, "Member 'UPlayerExperienceGlobals::Enabled' has a wrong offset!");
static_assert(offsetof(UPlayerExperienceGlobals, PlayerExperienceGlobalsClassName) == 0x000030, "Member 'UPlayerExperienceGlobals::PlayerExperienceGlobalsClassName' has a wrong offset!");
static_assert(offsetof(UPlayerExperienceGlobals, MatchTrackerClassName) == 0x000050, "Member 'UPlayerExperienceGlobals::MatchTrackerClassName' has a wrong offset!");
static_assert(offsetof(UPlayerExperienceGlobals, ActiveMatchTracker) == 0x000070, "Member 'UPlayerExperienceGlobals::ActiveMatchTracker' has a wrong offset!");
static_assert(offsetof(UPlayerExperienceGlobals, MatchReportSenderClassName) == 0x000078, "Member 'UPlayerExperienceGlobals::MatchReportSenderClassName' has a wrong offset!");
static_assert(offsetof(UPlayerExperienceGlobals, MatchReportSender) == 0x000098, "Member 'UPlayerExperienceGlobals::MatchReportSender' has a wrong offset!");

// Class RallyHereStart.PlayerExp_MatchReportSender
// 0x0008 (0x0030 - 0x0028)
class UPlayerExp_MatchReportSender final : public UObject
{
public:
	bool                                          bInitialized;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerExp_MatchReportSender">();
	}
	static class UPlayerExp_MatchReportSender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerExp_MatchReportSender>();
	}
};
static_assert(alignof(UPlayerExp_MatchReportSender) == 0x000008, "Wrong alignment on UPlayerExp_MatchReportSender");
static_assert(sizeof(UPlayerExp_MatchReportSender) == 0x000030, "Wrong size on UPlayerExp_MatchReportSender");
static_assert(offsetof(UPlayerExp_MatchReportSender, bInitialized) == 0x000028, "Member 'UPlayerExp_MatchReportSender::bInitialized' has a wrong offset!");

// Class RallyHereStart.PlayerExp_MatchTracker
// 0x0278 (0x02A0 - 0x0028)
class UPlayerExp_MatchTracker final : public UObject
{
public:
	TSubclassOf<class UPlayerExp_PlayerTracker>   PlayerTrackerClass;                                // 0x0028(0x0008)(ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HostName;                                          // 0x0030(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SessionId;                                         // 0x0040(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InstanceId;                                        // 0x0050(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AllocationId;                                      // 0x0060(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Region;                                            // 0x0070(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UGameInstance>           OwningGameInstance;                                // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPlayerExp_PlayerTracker*>       Players;                                           // 0x0088(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInitialized;                                      // 0x00E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 LoadedPlayerTrackerClass;                          // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMatchInProgress;                                  // 0x00F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MatchStartTimeSeconds;                             // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MatchEndTime;                                      // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MatchDuration;                                     // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              MatchStartTime;                                    // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoStartMatch;                                   // 0x0120(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoSendReportOnMatchEnded;                       // 0x0121(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MatchIsFubar;                                      // 0x0122(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_123[0x5];                                      // 0x0123(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FubarReason;                                       // 0x0128(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerExp_StatAccumulator             FrameTimeStats;                                    // 0x0138(0x00C8)(Protected, NativeAccessSpecifierProtected)
	double                                        LastTime;                                          // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x10];                                     // 0x0208(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerExp_MatchReportSender*           MatchReportSender;                                 // 0x0218(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220[0x50];                                     // 0x0220(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AGameModeBase>           ActiveGameMode;                                    // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x28];                                     // 0x0278(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerExp_MatchTracker">();
	}
	static class UPlayerExp_MatchTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerExp_MatchTracker>();
	}
};
static_assert(alignof(UPlayerExp_MatchTracker) == 0x000008, "Wrong alignment on UPlayerExp_MatchTracker");
static_assert(sizeof(UPlayerExp_MatchTracker) == 0x0002A0, "Wrong size on UPlayerExp_MatchTracker");
static_assert(offsetof(UPlayerExp_MatchTracker, PlayerTrackerClass) == 0x000028, "Member 'UPlayerExp_MatchTracker::PlayerTrackerClass' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, HostName) == 0x000030, "Member 'UPlayerExp_MatchTracker::HostName' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, SessionId) == 0x000040, "Member 'UPlayerExp_MatchTracker::SessionId' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, InstanceId) == 0x000050, "Member 'UPlayerExp_MatchTracker::InstanceId' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, AllocationId) == 0x000060, "Member 'UPlayerExp_MatchTracker::AllocationId' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, Region) == 0x000070, "Member 'UPlayerExp_MatchTracker::Region' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, OwningGameInstance) == 0x000080, "Member 'UPlayerExp_MatchTracker::OwningGameInstance' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, Players) == 0x000088, "Member 'UPlayerExp_MatchTracker::Players' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, bInitialized) == 0x0000E8, "Member 'UPlayerExp_MatchTracker::bInitialized' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, LoadedPlayerTrackerClass) == 0x0000F0, "Member 'UPlayerExp_MatchTracker::LoadedPlayerTrackerClass' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, bMatchInProgress) == 0x0000F8, "Member 'UPlayerExp_MatchTracker::bMatchInProgress' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, MatchStartTimeSeconds) == 0x000100, "Member 'UPlayerExp_MatchTracker::MatchStartTimeSeconds' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, MatchEndTime) == 0x000108, "Member 'UPlayerExp_MatchTracker::MatchEndTime' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, MatchDuration) == 0x000110, "Member 'UPlayerExp_MatchTracker::MatchDuration' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, MatchStartTime) == 0x000118, "Member 'UPlayerExp_MatchTracker::MatchStartTime' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, bAutoStartMatch) == 0x000120, "Member 'UPlayerExp_MatchTracker::bAutoStartMatch' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, bAutoSendReportOnMatchEnded) == 0x000121, "Member 'UPlayerExp_MatchTracker::bAutoSendReportOnMatchEnded' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, MatchIsFubar) == 0x000122, "Member 'UPlayerExp_MatchTracker::MatchIsFubar' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, FubarReason) == 0x000128, "Member 'UPlayerExp_MatchTracker::FubarReason' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, FrameTimeStats) == 0x000138, "Member 'UPlayerExp_MatchTracker::FrameTimeStats' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, LastTime) == 0x000200, "Member 'UPlayerExp_MatchTracker::LastTime' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, MatchReportSender) == 0x000218, "Member 'UPlayerExp_MatchTracker::MatchReportSender' has a wrong offset!");
static_assert(offsetof(UPlayerExp_MatchTracker, ActiveGameMode) == 0x000270, "Member 'UPlayerExp_MatchTracker::ActiveGameMode' has a wrong offset!");

// Class RallyHereStart.PlayerExp_PlayerComponent
// 0x02B0 (0x0350 - 0x00A0)
class UPlayerExp_PlayerComponent final : public UActorComponent
{
public:
	struct FPlayerExp_StatAccumulator             FrameTimeStats;                                    // 0x00A0(0x00C8)(Transient, NativeAccessSpecifierPublic)
	double                                        StatUpdateTime;                                    // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerExp_StatAccumulator             PingStats;                                         // 0x0170(0x00C8)(Transient, NativeAccessSpecifierPublic)
	int32                                         NumHitchesDetected;                                // 0x0238(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumServerCorrections;                              // 0x023C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InTotalPackets;                                    // 0x0240(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InTotalPacketsLost;                                // 0x0244(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutTotalPackets;                                   // 0x0248(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutTotalPacketsLost;                               // 0x024C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPlayerExp_PlayerTracker> OwningPlayerTracker;                              // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        LastTime;                                          // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerExp_StatAccumulator             FrameTimeStats_Period;                             // 0x0260(0x00C8)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         NumHitchesDetected_Period;                         // 0x0328(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateToServerPeriod;                              // 0x032C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeUntilNextAccumulation;                         // 0x0330(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRecordNetCorrections;                             // 0x0334(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_335[0x3];                                      // 0x0335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastNetCorrectionTimeStamp;                        // 0x0338(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RequiredNumSamplesForHitchDetection;               // 0x033C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        HitchDetectionThreshold;                           // 0x0340(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      CachedPCOwner;                                     // 0x0348(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ServerFrameTimeUpdate(const struct FPlayerExp_StatAccumulator& InFrameTimeStats, int32 InHitchesDetected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerExp_PlayerComponent">();
	}
	static class UPlayerExp_PlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerExp_PlayerComponent>();
	}
};
static_assert(alignof(UPlayerExp_PlayerComponent) == 0x000008, "Wrong alignment on UPlayerExp_PlayerComponent");
static_assert(sizeof(UPlayerExp_PlayerComponent) == 0x000350, "Wrong size on UPlayerExp_PlayerComponent");
static_assert(offsetof(UPlayerExp_PlayerComponent, FrameTimeStats) == 0x0000A0, "Member 'UPlayerExp_PlayerComponent::FrameTimeStats' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, StatUpdateTime) == 0x000168, "Member 'UPlayerExp_PlayerComponent::StatUpdateTime' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, PingStats) == 0x000170, "Member 'UPlayerExp_PlayerComponent::PingStats' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, NumHitchesDetected) == 0x000238, "Member 'UPlayerExp_PlayerComponent::NumHitchesDetected' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, NumServerCorrections) == 0x00023C, "Member 'UPlayerExp_PlayerComponent::NumServerCorrections' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, InTotalPackets) == 0x000240, "Member 'UPlayerExp_PlayerComponent::InTotalPackets' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, InTotalPacketsLost) == 0x000244, "Member 'UPlayerExp_PlayerComponent::InTotalPacketsLost' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, OutTotalPackets) == 0x000248, "Member 'UPlayerExp_PlayerComponent::OutTotalPackets' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, OutTotalPacketsLost) == 0x00024C, "Member 'UPlayerExp_PlayerComponent::OutTotalPacketsLost' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, OwningPlayerTracker) == 0x000250, "Member 'UPlayerExp_PlayerComponent::OwningPlayerTracker' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, LastTime) == 0x000258, "Member 'UPlayerExp_PlayerComponent::LastTime' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, FrameTimeStats_Period) == 0x000260, "Member 'UPlayerExp_PlayerComponent::FrameTimeStats_Period' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, NumHitchesDetected_Period) == 0x000328, "Member 'UPlayerExp_PlayerComponent::NumHitchesDetected_Period' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, UpdateToServerPeriod) == 0x00032C, "Member 'UPlayerExp_PlayerComponent::UpdateToServerPeriod' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, TimeUntilNextAccumulation) == 0x000330, "Member 'UPlayerExp_PlayerComponent::TimeUntilNextAccumulation' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, bRecordNetCorrections) == 0x000334, "Member 'UPlayerExp_PlayerComponent::bRecordNetCorrections' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, LastNetCorrectionTimeStamp) == 0x000338, "Member 'UPlayerExp_PlayerComponent::LastNetCorrectionTimeStamp' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, RequiredNumSamplesForHitchDetection) == 0x00033C, "Member 'UPlayerExp_PlayerComponent::RequiredNumSamplesForHitchDetection' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, HitchDetectionThreshold) == 0x000340, "Member 'UPlayerExp_PlayerComponent::HitchDetectionThreshold' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerComponent, CachedPCOwner) == 0x000348, "Member 'UPlayerExp_PlayerComponent::CachedPCOwner' has a wrong offset!");

// Class RallyHereStart.PlayerExp_PlayerTracker
// 0x0218 (0x0240 - 0x0028)
class UPlayerExp_PlayerTracker final : public UObject
{
public:
	TWeakObjectPtr<class APlayerController>       PlayerController;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        TimeConnected;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        LastConnectedTimestamp;                            // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ipv4_address;                                      // 0x0040(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ipv6_address;                                      // 0x0050(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OnlinePlatformName;                                // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Connections;                                       // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Disconnections;                                    // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ConnectionTimeouts;                                // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InTotalPackets;                                    // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InTotalPacketsLost;                                // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OutTotalPackets;                                   // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OutTotalPacketsLost;                               // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerExp_StatAccumulator             PingStats;                                         // 0x0088(0x00C8)(Protected, NativeAccessSpecifierProtected)
	struct FPlayerExp_StatAccumulator             FrameTimeStats;                                    // 0x0150(0x00C8)(Protected, NativeAccessSpecifierProtected)
	int32                                         NumHitchesDetected;                                // 0x0218(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumServerCorrections;                              // 0x021C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlayerExp_PlayerComponent> PlayerComponentClass;                              // 0x0220(0x0008)(ZeroConstructor, Config, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UPlayerExp_PlayerComponent> ActivePlayerComponent;                          // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  PlayerUuid;                                        // 0x0230(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerExp_PlayerTracker">();
	}
	static class UPlayerExp_PlayerTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerExp_PlayerTracker>();
	}
};
static_assert(alignof(UPlayerExp_PlayerTracker) == 0x000008, "Wrong alignment on UPlayerExp_PlayerTracker");
static_assert(sizeof(UPlayerExp_PlayerTracker) == 0x000240, "Wrong size on UPlayerExp_PlayerTracker");
static_assert(offsetof(UPlayerExp_PlayerTracker, PlayerController) == 0x000028, "Member 'UPlayerExp_PlayerTracker::PlayerController' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, TimeConnected) == 0x000030, "Member 'UPlayerExp_PlayerTracker::TimeConnected' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, LastConnectedTimestamp) == 0x000038, "Member 'UPlayerExp_PlayerTracker::LastConnectedTimestamp' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, ipv4_address) == 0x000040, "Member 'UPlayerExp_PlayerTracker::ipv4_address' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, ipv6_address) == 0x000050, "Member 'UPlayerExp_PlayerTracker::ipv6_address' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, OnlinePlatformName) == 0x000060, "Member 'UPlayerExp_PlayerTracker::OnlinePlatformName' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, Connections) == 0x000068, "Member 'UPlayerExp_PlayerTracker::Connections' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, Disconnections) == 0x00006C, "Member 'UPlayerExp_PlayerTracker::Disconnections' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, ConnectionTimeouts) == 0x000070, "Member 'UPlayerExp_PlayerTracker::ConnectionTimeouts' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, InTotalPackets) == 0x000074, "Member 'UPlayerExp_PlayerTracker::InTotalPackets' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, InTotalPacketsLost) == 0x000078, "Member 'UPlayerExp_PlayerTracker::InTotalPacketsLost' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, OutTotalPackets) == 0x00007C, "Member 'UPlayerExp_PlayerTracker::OutTotalPackets' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, OutTotalPacketsLost) == 0x000080, "Member 'UPlayerExp_PlayerTracker::OutTotalPacketsLost' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, PingStats) == 0x000088, "Member 'UPlayerExp_PlayerTracker::PingStats' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, FrameTimeStats) == 0x000150, "Member 'UPlayerExp_PlayerTracker::FrameTimeStats' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, NumHitchesDetected) == 0x000218, "Member 'UPlayerExp_PlayerTracker::NumHitchesDetected' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, NumServerCorrections) == 0x00021C, "Member 'UPlayerExp_PlayerTracker::NumServerCorrections' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, PlayerComponentClass) == 0x000220, "Member 'UPlayerExp_PlayerTracker::PlayerComponentClass' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, ActivePlayerComponent) == 0x000228, "Member 'UPlayerExp_PlayerTracker::ActivePlayerComponent' has a wrong offset!");
static_assert(offsetof(UPlayerExp_PlayerTracker, PlayerUuid) == 0x000230, "Member 'UPlayerExp_PlayerTracker::PlayerUuid' has a wrong offset!");

// Class RallyHereStart.RHActivity
// 0x0050 (0x01C8 - 0x0178)
class URHActivity final : public UPlatformInventoryItem
{
public:
	struct FRH_ItemId                             RequiredItemId;                                    // 0x0178(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_LootId                             ProgressLootId;                                    // 0x018C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ActivityInstanceClass;                             // 0x01A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHActivity">();
	}
	static class URHActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHActivity>();
	}
};
static_assert(alignof(URHActivity) == 0x000008, "Wrong alignment on URHActivity");
static_assert(sizeof(URHActivity) == 0x0001C8, "Wrong size on URHActivity");
static_assert(offsetof(URHActivity, RequiredItemId) == 0x000178, "Member 'URHActivity::RequiredItemId' has a wrong offset!");
static_assert(offsetof(URHActivity, ProgressLootId) == 0x00018C, "Member 'URHActivity::ProgressLootId' has a wrong offset!");
static_assert(offsetof(URHActivity, ActivityInstanceClass) == 0x0001A0, "Member 'URHActivity::ActivityInstanceClass' has a wrong offset!");

// Class RallyHereStart.RHActivityInstance
// 0x0018 (0x0040 - 0x0028)
class URHActivityInstance final : public UObject
{
public:
	TWeakObjectPtr<class ARHPlayerController>     OwningController;                                  // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHActivity*                            Activity;                                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHActivityInstance">();
	}
	static class URHActivityInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHActivityInstance>();
	}
};
static_assert(alignof(URHActivityInstance) == 0x000008, "Wrong alignment on URHActivityInstance");
static_assert(sizeof(URHActivityInstance) == 0x000040, "Wrong size on URHActivityInstance");
static_assert(offsetof(URHActivityInstance, OwningController) == 0x000028, "Member 'URHActivityInstance::OwningController' has a wrong offset!");
static_assert(offsetof(URHActivityInstance, Activity) == 0x000030, "Member 'URHActivityInstance::Activity' has a wrong offset!");

// Class RallyHereStart.RHAnalogStickFilter
// 0x0010 (0x0038 - 0x0028)
class URHAnalogStickFilter : public UObject
{
public:
	EAnalogStickType                              StickType;                                         // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URHPlayerInput*                         PlayerInput;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHAnalogStickFilter">();
	}
	static class URHAnalogStickFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHAnalogStickFilter>();
	}
};
static_assert(alignof(URHAnalogStickFilter) == 0x000008, "Wrong alignment on URHAnalogStickFilter");
static_assert(sizeof(URHAnalogStickFilter) == 0x000038, "Wrong size on URHAnalogStickFilter");
static_assert(offsetof(URHAnalogStickFilter, StickType) == 0x000028, "Member 'URHAnalogStickFilter::StickType' has a wrong offset!");
static_assert(offsetof(URHAnalogStickFilter, PlayerInput) == 0x000030, "Member 'URHAnalogStickFilter::PlayerInput' has a wrong offset!");

// Class RallyHereStart.RHAsyncImage
// 0x0050 (0x0330 - 0x02E0)
class URHAsyncImage final : public UImage
{
public:
	class UWidget*                                WaitingWidget;                                     // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class URHAsyncImage* Image)> OnAsyncImageLoadStarted;              // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHAsyncImage* Image)> OnAsyncImageLoadComplete;             // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHAsyncImage* Image)> OnAsyncImageLoadCanceled;             // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHAsyncImage* Image)> OnAsyncImageBrushChanged;             // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MaterialToUse;                                     // 0x0320(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialParameter;                                 // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HideWaitingWidget();
	void SetBrushFromIconInfo(class UIconInfo* IconInfo, bool bMatchSize);
	void SetBrushFromItemIcon(const class UPlatformInventoryItem* Item, bool bMatchSize);
	void SetBrushFromPathOnItem(const class UPlatformInventoryItem* Item, const struct FSoftObjectPath& Path, bool bMatchSize);
	void SetBrushFromSoftPath(const struct FSoftObjectPath& SoftPath, bool bMatchSize);
	void SetBrushFromTextureOnItem(const class UPlatformInventoryItem* Item, TSoftObjectPtr<class UTexture2D> Texture, bool bMatchSize);
	void SetMaterialToUse(class UMaterialInstanceDynamic* InMID);
	void SetWaitingWidget(class UWidget* InWaitingWidget);
	void ShowWaitingWidget();

	bool IsCurrentlyAsyncLoading() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHAsyncImage">();
	}
	static class URHAsyncImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHAsyncImage>();
	}
};
static_assert(alignof(URHAsyncImage) == 0x000010, "Wrong alignment on URHAsyncImage");
static_assert(sizeof(URHAsyncImage) == 0x000330, "Wrong size on URHAsyncImage");
static_assert(offsetof(URHAsyncImage, WaitingWidget) == 0x0002D8, "Member 'URHAsyncImage::WaitingWidget' has a wrong offset!");
static_assert(offsetof(URHAsyncImage, OnAsyncImageLoadStarted) == 0x0002E0, "Member 'URHAsyncImage::OnAsyncImageLoadStarted' has a wrong offset!");
static_assert(offsetof(URHAsyncImage, OnAsyncImageLoadComplete) == 0x0002F0, "Member 'URHAsyncImage::OnAsyncImageLoadComplete' has a wrong offset!");
static_assert(offsetof(URHAsyncImage, OnAsyncImageLoadCanceled) == 0x000300, "Member 'URHAsyncImage::OnAsyncImageLoadCanceled' has a wrong offset!");
static_assert(offsetof(URHAsyncImage, OnAsyncImageBrushChanged) == 0x000310, "Member 'URHAsyncImage::OnAsyncImageBrushChanged' has a wrong offset!");
static_assert(offsetof(URHAsyncImage, MaterialToUse) == 0x000320, "Member 'URHAsyncImage::MaterialToUse' has a wrong offset!");
static_assert(offsetof(URHAsyncImage, MaterialParameter) == 0x000328, "Member 'URHAsyncImage::MaterialParameter' has a wrong offset!");

// Class RallyHereStart.RHAvatar
// 0x0008 (0x0180 - 0x0178)
class URHAvatar final : public UPlatformInventoryItem
{
public:
	class UIconInfo*                              LargeAvatarIconInfo;                               // 0x0178(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UIconInfo* GetLargeAvatarInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHAvatar">();
	}
	static class URHAvatar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHAvatar>();
	}
};
static_assert(alignof(URHAvatar) == 0x000008, "Wrong alignment on URHAvatar");
static_assert(sizeof(URHAvatar) == 0x000180, "Wrong size on URHAvatar");
static_assert(offsetof(URHAvatar, LargeAvatarIconInfo) == 0x000178, "Member 'URHAvatar::LargeAvatarIconInfo' has a wrong offset!");

// Class RallyHereStart.RHBanner
// 0x0010 (0x0188 - 0x0178)
class URHBanner final : public UPlatformInventoryItem
{
public:
	class UIconInfo*                              SmallBannerIconInfo;                               // 0x0178(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIconInfo*                              LargeBannerIconInfo;                               // 0x0180(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UIconInfo* GetLargeBannerInfo() const;
	class UIconInfo* GetSmallBannerInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHBanner">();
	}
	static class URHBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHBanner>();
	}
};
static_assert(alignof(URHBanner) == 0x000008, "Wrong alignment on URHBanner");
static_assert(sizeof(URHBanner) == 0x000188, "Wrong size on URHBanner");
static_assert(offsetof(URHBanner, SmallBannerIconInfo) == 0x000178, "Member 'URHBanner::SmallBannerIconInfo' has a wrong offset!");
static_assert(offsetof(URHBanner, LargeBannerIconInfo) == 0x000180, "Member 'URHBanner::LargeBannerIconInfo' has a wrong offset!");

// Class RallyHereStart.RHBattlepassRewardItem
// 0x0010 (0x0038 - 0x0028)
class URHBattlepassRewardItem final : public UObject
{
public:
	class URHStoreItem*                           Item;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattlepassTrackType                          Track;                                             // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetRewardLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHBattlepassRewardItem">();
	}
	static class URHBattlepassRewardItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHBattlepassRewardItem>();
	}
};
static_assert(alignof(URHBattlepassRewardItem) == 0x000008, "Wrong alignment on URHBattlepassRewardItem");
static_assert(sizeof(URHBattlepassRewardItem) == 0x000038, "Wrong size on URHBattlepassRewardItem");
static_assert(offsetof(URHBattlepassRewardItem, Item) == 0x000028, "Member 'URHBattlepassRewardItem::Item' has a wrong offset!");
static_assert(offsetof(URHBattlepassRewardItem, Track) == 0x000030, "Member 'URHBattlepassRewardItem::Track' has a wrong offset!");

// Class RallyHereStart.RHBattlepassLevel
// 0x0020 (0x0048 - 0x0028)
class URHBattlepassLevel final : public UObject
{
public:
	int32                                         LevelNumber;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartXp;                                           // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndXp;                                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URHBattlepassRewardItem*>        RewardItems;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	int32 GetXPSpan() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHBattlepassLevel">();
	}
	static class URHBattlepassLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHBattlepassLevel>();
	}
};
static_assert(alignof(URHBattlepassLevel) == 0x000008, "Wrong alignment on URHBattlepassLevel");
static_assert(sizeof(URHBattlepassLevel) == 0x000048, "Wrong size on URHBattlepassLevel");
static_assert(offsetof(URHBattlepassLevel, LevelNumber) == 0x000028, "Member 'URHBattlepassLevel::LevelNumber' has a wrong offset!");
static_assert(offsetof(URHBattlepassLevel, StartXp) == 0x00002C, "Member 'URHBattlepassLevel::StartXp' has a wrong offset!");
static_assert(offsetof(URHBattlepassLevel, EndXp) == 0x000030, "Member 'URHBattlepassLevel::EndXp' has a wrong offset!");
static_assert(offsetof(URHBattlepassLevel, RewardItems) == 0x000038, "Member 'URHBattlepassLevel::RewardItems' has a wrong offset!");

// Class RallyHereStart.RHEvent
// 0x0008 (0x0180 - 0x0178)
class URHEvent : public UPlatformInventoryItem
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetRemainingSeconds(const class UObject* WorldContextObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHEvent">();
	}
	static class URHEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHEvent>();
	}
};
static_assert(alignof(URHEvent) == 0x000008, "Wrong alignment on URHEvent");
static_assert(sizeof(URHEvent) == 0x000180, "Wrong size on URHEvent");

// Class RallyHereStart.RHBattlepass
// 0x00A0 (0x0220 - 0x0180)
class URHBattlepass final : public URHEvent
{
public:
	struct FRH_ItemId                             ProgressItemId;                                    // 0x0180(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstantUnlockRewardVendorId;                       // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FreeRewardVendorId;                                // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PremiumRewardVendorId;                             // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PurchaseVendorId;                                  // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             PassPurchaseLootId;                                // 0x01A4(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             LevelPurchaseLootId;                               // 0x01B8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             MatchProgressLootId;                               // 0x01CC(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpTableId;                                         // 0x01E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UIconInfo*                              FreeIconInfo;                                      // 0x01E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIconInfo*                              PremiumIconInfo;                                   // 0x01F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URHBattlepassLevel*>             CachedBattlepassLevels;                            // 0x01F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class URHBattlepassRewardItem*>        CachedInstantUnlocks;                              // 0x0208(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          RewardsFullyLoaded;                                // 0x0218(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InstantUnlocksFullyLoaded;                         // 0x0219(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A[0x6];                                      // 0x021A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BLUEPRINT_GetCurrentLevel(class URH_PlayerInfo* PlayerInfo, const TDelegate<void(int32 InstanceCount)>& Delegate);
	void BLUEPRINT_GetTotalXpProgress(class URH_PlayerInfo* PlayerInfo, const TDelegate<void(int32 InstanceCount)>& Delegate);
	TArray<class URHBattlepassRewardItem*> GetInstantUnlockRewards(const class UObject* WorldContextObject);
	TArray<class URHBattlepassLevel*> GetLevels(const class UObject* WorldContextObject);

	class URHBattlepassLevel* GetBattlepassLevel(int32 LevelNumber) const;
	class UIconInfo* GetFreeIconInfo() const;
	int32 GetLevelCount(const class UObject* WorldContextObject) const;
	class UIconInfo* GetPremiumIconInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHBattlepass">();
	}
	static class URHBattlepass* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHBattlepass>();
	}
};
static_assert(alignof(URHBattlepass) == 0x000008, "Wrong alignment on URHBattlepass");
static_assert(sizeof(URHBattlepass) == 0x000220, "Wrong size on URHBattlepass");
static_assert(offsetof(URHBattlepass, ProgressItemId) == 0x000180, "Member 'URHBattlepass::ProgressItemId' has a wrong offset!");
static_assert(offsetof(URHBattlepass, InstantUnlockRewardVendorId) == 0x000194, "Member 'URHBattlepass::InstantUnlockRewardVendorId' has a wrong offset!");
static_assert(offsetof(URHBattlepass, FreeRewardVendorId) == 0x000198, "Member 'URHBattlepass::FreeRewardVendorId' has a wrong offset!");
static_assert(offsetof(URHBattlepass, PremiumRewardVendorId) == 0x00019C, "Member 'URHBattlepass::PremiumRewardVendorId' has a wrong offset!");
static_assert(offsetof(URHBattlepass, PurchaseVendorId) == 0x0001A0, "Member 'URHBattlepass::PurchaseVendorId' has a wrong offset!");
static_assert(offsetof(URHBattlepass, PassPurchaseLootId) == 0x0001A4, "Member 'URHBattlepass::PassPurchaseLootId' has a wrong offset!");
static_assert(offsetof(URHBattlepass, LevelPurchaseLootId) == 0x0001B8, "Member 'URHBattlepass::LevelPurchaseLootId' has a wrong offset!");
static_assert(offsetof(URHBattlepass, MatchProgressLootId) == 0x0001CC, "Member 'URHBattlepass::MatchProgressLootId' has a wrong offset!");
static_assert(offsetof(URHBattlepass, XpTableId) == 0x0001E0, "Member 'URHBattlepass::XpTableId' has a wrong offset!");
static_assert(offsetof(URHBattlepass, FreeIconInfo) == 0x0001E8, "Member 'URHBattlepass::FreeIconInfo' has a wrong offset!");
static_assert(offsetof(URHBattlepass, PremiumIconInfo) == 0x0001F0, "Member 'URHBattlepass::PremiumIconInfo' has a wrong offset!");
static_assert(offsetof(URHBattlepass, CachedBattlepassLevels) == 0x0001F8, "Member 'URHBattlepass::CachedBattlepassLevels' has a wrong offset!");
static_assert(offsetof(URHBattlepass, CachedInstantUnlocks) == 0x000208, "Member 'URHBattlepass::CachedInstantUnlocks' has a wrong offset!");
static_assert(offsetof(URHBattlepass, RewardsFullyLoaded) == 0x000218, "Member 'URHBattlepass::RewardsFullyLoaded' has a wrong offset!");
static_assert(offsetof(URHBattlepass, InstantUnlocksFullyLoaded) == 0x000219, "Member 'URHBattlepass::InstantUnlocksFullyLoaded' has a wrong offset!");

// Class RallyHereStart.RHActivatableWidget
// 0x0008 (0x0418 - 0x0410)
class URHActivatableWidget : public UCommonActivatableWidget
{
public:
	ERHWidgetInputMode                            InputConfig;                                       // 0x0410(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMouseCaptureMode                             GameMouseCaptureMode;                              // 0x0411(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_412[0x6];                                      // 0x0412(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UWidget*> GetEnableWidgets() const;
	TArray<class UWidget*> GetInteractableWidgets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHActivatableWidget">();
	}
	static class URHActivatableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHActivatableWidget>();
	}
};
static_assert(alignof(URHActivatableWidget) == 0x000008, "Wrong alignment on URHActivatableWidget");
static_assert(sizeof(URHActivatableWidget) == 0x000418, "Wrong size on URHActivatableWidget");
static_assert(offsetof(URHActivatableWidget, InputConfig) == 0x000410, "Member 'URHActivatableWidget::InputConfig' has a wrong offset!");
static_assert(offsetof(URHActivatableWidget, GameMouseCaptureMode) == 0x000411, "Member 'URHActivatableWidget::GameMouseCaptureMode' has a wrong offset!");

// Class RallyHereStart.RHWidget
// 0x01A0 (0x05B8 - 0x0418)
class URHWidget : public URHActivatableWidget
{
public:
	bool                                          bIsUIOnlyWidget;                                   // 0x0418(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExclusiveMenuWidget;                            // 0x0419(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41A[0x6];                                      // 0x041A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTickAnimationManager*                  TickAnimations;                                    // 0x0420(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void(const struct FIntPoint& ViewportSize)> ViewportEvent;                             // 0x0428(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnNavigateBack;                                    // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTexture2D* Texture)> OnTextureLoadComplete;                 // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHWidget* Widget)> OnNavigateUpFailed;                      // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHWidget* Widget)> OnNavigateDownFailed;                    // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHWidget* Widget)> OnNavigateLeftFailed;                    // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHWidget* Widget)> OnNavigateRightFailed;                   // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 FocusGroup, class URHWidget* Widget)> OnFocusGroupNavigateUpFailed; // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 FocusGroup, class URHWidget* Widget)> OnFocusGroupNavigateDownFailed; // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 FocusGroup, class URHWidget* Widget)> OnFocusGroupNavigateLeftFailed; // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 FocusGroup, class URHWidget* Widget)> OnFocusGroupNavigateRightFailed; // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHWidget* Widget)> OnHideSequenceFinished;                  // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHWidget* Widget)> OnShowSequenceFinished;                  // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHWidget* Widget, bool bHovered)> OnGamepadHovered;         // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHWidget* Widget, bool bEntered)> OnMouseEntered;           // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0518(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_519[0x3];                                      // 0x0519(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ARHHUDCommon>            MyHud;                                             // 0x051C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MyRouteTag;                                        // 0x0524(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CloseOnLogout;                                     // 0x052C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsComponent;                                       // 0x052D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          StartsHidden;                                      // 0x052E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InputComponentUsesWidgetPriority;                  // 0x052F(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UsesBlocker;                                       // 0x0530(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BlockerClickToClose;                               // 0x0531(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableGameStateSetNotify;                          // 0x0532(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_533[0x5];                                      // 0x0533(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              LoadedTexture;                                     // 0x0538(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_560[0x40];                                     // 0x0560(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class URHMobileLayoutSequencePlayer*          MobileLayoutSequencePlayer;                        // 0x05A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       MobileLayoutAnim;                                  // 0x05A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMobileLayoutActive;                               // 0x05B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddContextAction(class FName ContextName, const class FText& FormatAdditive);
	void AddContextActions(const TArray<class FName>& ContextNames);
	void AddTickAnimation(class FName AnimName, float Duration, const TDelegate<void(float ElapsedTime, float ElapsedAlpha)>& UpdateEvent, const TDelegate<void()>& FinishedEvent);
	bool AddViewRoute(const struct FGameplayTag& RouteTag, bool ClearRouteStack, bool ForceTransition, class UObject* Data);
	void AsyncLoadTexture2D(TSoftObjectPtr<class UTexture2D> Texture2DRef);
	void BindToInputManager(int32 DefaultFocusGroup);
	void BindToViewportSizeChange(const TDelegate<void(const struct FIntPoint& ViewportSize)>& InViewportEvent);
	void CallOnHideSequenceFinished();
	void CallOnShowSequenceFinished();
	bool CanCloseOnLogout();
	void ClearAllContextActions();
	void ClearContextAction(class FName ContextName);
	void ClearNavigationInputThrottle();
	void DisplayGenericError(const class FString& sDesc);
	void DisplayGenericPopup(const class FString& sTitle, const class FString& sDesc);
	bool ExplicitNavigateDown();
	bool ExplicitNavigateLeft();
	bool ExplicitNavigateRight();
	bool ExplicitNavigateUp();
	void FocusGroupNavigateDownFailure(int32 FocusGroup);
	void FocusGroupNavigateLeftFailure(int32 FocusGroup);
	void FocusGroupNavigateRightFailure(int32 FocusGroup);
	void FocusGroupNavigateUpFailure(int32 FocusGroup);
	struct FEventReply GamepadButtonDown(const struct FKey& Button);
	struct FEventReply GamepadButtonUp(const struct FKey& Button);
	void GamepadHover();
	void GamepadUnhover();
	void GameStateSet(class AGameStateBase* GameState);
	bool GetBlockerClickToClose();
	class UWidget* GetCurrentFocusForGroup(int32 FocusGroup);
	bool GetCurrentFocusGroup(int32* OutFocusGroup);
	struct FGeometry GetGeometryFromLastTick();
	bool GetIsComponent();
	bool GetTickAnimationInfo(class FName AnimName, struct FTickAnimationParams* OutAnimParams);
	bool GetUsesBlocker();
	void HideWidget(ESlateVisibility InVisibility);
	void InheritFocusGroupFromWidget(int32 TargetFocusGroupNum, class URHWidget* SourceWidget, int32 SourceFocusGroupNum);
	void InitializeTickAnimations();
	void InitializeWidget();
	void InitializeWidgetButtonListeners();
	void InitializeWidgetNavigation();
	bool IsFocusEnabled();
	bool IsTopViewRoute();
	void NativeFocusGroupNavigateDownFailure(int32 FocusGroup, class URHWidget* Widget);
	void NativeFocusGroupNavigateLeftFailure(int32 FocusGroup, class URHWidget* Widget);
	void NativeFocusGroupNavigateRightFailure(int32 FocusGroup, class URHWidget* Widget);
	void NativeFocusGroupNavigateUpFailure(int32 FocusGroup, class URHWidget* Widget);
	bool NavigateBack();
	void NavigateBackCancelled();
	bool NavigateBackPressed();
	bool NavigateConfirm();
	void NavigateConfirmCancelled();
	bool NavigateConfirmPressed();
	void NavigateDownFailure();
	void NavigateLeftFailure();
	void NavigateRightFailure();
	void NavigateUpFailure();
	void OnEnterMobileLayout();
	void OnExitMobileLayout();
	void OnGamepadHover();
	void OnGamepadUnhover();
	void OnHide();
	void OnShown();
	void PauseTickAnimation(class FName AnimName);
	void PlayTickAnimation(class FName AnimName);
	void RegisterWidgetToInputManager(class UWidget* Widget, int32 FocusGroup, class UWidget* Up, class UWidget* Down, class UWidget* Left, class UWidget* Right);
	void RemoveTickAnimation(class FName AnimName);
	bool RemoveTopViewRoute(bool ForceTransition);
	bool RemoveViewRoute(const struct FGameplayTag& RouteTag, bool ForceTransition);
	void ResumeTickAnimation(class FName AnimName);
	void SetAllAnimationsPlaybackSpeed(float PlaybackSpeed);
	void SetContextAction(class FName ContextName, const TDelegate<void()>& EventCallback);
	void SetContextCycleAction(class FName ContextName, const TDelegate<void(bool bNext)>& EventCallback);
	void SetContextHoldReleaseAction(class FName ContextName, const TDelegate<void(float fPercentage)>& UpdateCallback, const TDelegate<void(EContextActionHoldReleaseState Status)>& EventCallback);
	void SetDefaultFocusForGroup(class UWidget* Widget, int32 FocusGroup);
	void SetFocusToGroup(int32 FocusGroup, bool KeepLastFocus);
	class UWidget* SetFocusToThis();
	void SetFocusToWidgetOfGroup(int32 FocusGroup, class URHWidget* Widget);
	void SetPendingRouteData(const struct FGameplayTag& RouteTag, class UObject* Data);
	void SetRouteTag(const struct FGameplayTag& RouteTag);
	void ShowWidget(ESlateVisibility InVisibility);
	void SkipToEndTickAnimation(class FName AnimName);
	void StartHideSequence(const struct FGameplayTag& FromRoute, const struct FGameplayTag& ToRoute);
	void StartShowSequence(const struct FGameplayTag& FromRoute, const struct FGameplayTag& ToRoute);
	void StopTickAnimation(class FName AnimName);
	bool SwapViewRoute(const struct FGameplayTag& RouteTag, const struct FGameplayTag& SwapTargetRouteTag, bool ForceTransition);
	void ToggleMobileLayout(ERH_INPUT_STATE InputState);
	void TriggerGlobalInvalidate();
	void UnbindFromViewportSizeChange();
	void UninitializeWidget();
	void UnregisterFocusGroup(int32 FocusGroup);
	void UnregisterWidgetFromInputManager(class UWidget* Widget);
	void UpdateRegistrationToInputManager(class UWidget* Widget, int32 FocusGroup, class UWidget* Up, class UWidget* Down, class UWidget* Left, class UWidget* Right);

	class APlayerController* GetActivePlayerController() const;
	class APlayerController* GetNormalOwningPlayer() const;
	bool GetPendingRouteData(const struct FGameplayTag& RouteTag, class UObject** Data) const;
	struct FGameplayTag GetRouteTag() const;
	class URHViewManager* GetViewManager() const;
	bool ShouldUseMobileLayout() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHWidget">();
	}
	static class URHWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHWidget>();
	}
};
static_assert(alignof(URHWidget) == 0x000008, "Wrong alignment on URHWidget");
static_assert(sizeof(URHWidget) == 0x0005B8, "Wrong size on URHWidget");
static_assert(offsetof(URHWidget, bIsUIOnlyWidget) == 0x000418, "Member 'URHWidget::bIsUIOnlyWidget' has a wrong offset!");
static_assert(offsetof(URHWidget, bIsExclusiveMenuWidget) == 0x000419, "Member 'URHWidget::bIsExclusiveMenuWidget' has a wrong offset!");
static_assert(offsetof(URHWidget, TickAnimations) == 0x000420, "Member 'URHWidget::TickAnimations' has a wrong offset!");
static_assert(offsetof(URHWidget, ViewportEvent) == 0x000428, "Member 'URHWidget::ViewportEvent' has a wrong offset!");
static_assert(offsetof(URHWidget, OnNavigateBack) == 0x000438, "Member 'URHWidget::OnNavigateBack' has a wrong offset!");
static_assert(offsetof(URHWidget, OnTextureLoadComplete) == 0x000448, "Member 'URHWidget::OnTextureLoadComplete' has a wrong offset!");
static_assert(offsetof(URHWidget, OnNavigateUpFailed) == 0x000458, "Member 'URHWidget::OnNavigateUpFailed' has a wrong offset!");
static_assert(offsetof(URHWidget, OnNavigateDownFailed) == 0x000468, "Member 'URHWidget::OnNavigateDownFailed' has a wrong offset!");
static_assert(offsetof(URHWidget, OnNavigateLeftFailed) == 0x000478, "Member 'URHWidget::OnNavigateLeftFailed' has a wrong offset!");
static_assert(offsetof(URHWidget, OnNavigateRightFailed) == 0x000488, "Member 'URHWidget::OnNavigateRightFailed' has a wrong offset!");
static_assert(offsetof(URHWidget, OnFocusGroupNavigateUpFailed) == 0x000498, "Member 'URHWidget::OnFocusGroupNavigateUpFailed' has a wrong offset!");
static_assert(offsetof(URHWidget, OnFocusGroupNavigateDownFailed) == 0x0004A8, "Member 'URHWidget::OnFocusGroupNavigateDownFailed' has a wrong offset!");
static_assert(offsetof(URHWidget, OnFocusGroupNavigateLeftFailed) == 0x0004B8, "Member 'URHWidget::OnFocusGroupNavigateLeftFailed' has a wrong offset!");
static_assert(offsetof(URHWidget, OnFocusGroupNavigateRightFailed) == 0x0004C8, "Member 'URHWidget::OnFocusGroupNavigateRightFailed' has a wrong offset!");
static_assert(offsetof(URHWidget, OnHideSequenceFinished) == 0x0004D8, "Member 'URHWidget::OnHideSequenceFinished' has a wrong offset!");
static_assert(offsetof(URHWidget, OnShowSequenceFinished) == 0x0004E8, "Member 'URHWidget::OnShowSequenceFinished' has a wrong offset!");
static_assert(offsetof(URHWidget, OnGamepadHovered) == 0x0004F8, "Member 'URHWidget::OnGamepadHovered' has a wrong offset!");
static_assert(offsetof(URHWidget, OnMouseEntered) == 0x000508, "Member 'URHWidget::OnMouseEntered' has a wrong offset!");
static_assert(offsetof(URHWidget, bEnabled) == 0x000518, "Member 'URHWidget::bEnabled' has a wrong offset!");
static_assert(offsetof(URHWidget, MyHud) == 0x00051C, "Member 'URHWidget::MyHud' has a wrong offset!");
static_assert(offsetof(URHWidget, MyRouteTag) == 0x000524, "Member 'URHWidget::MyRouteTag' has a wrong offset!");
static_assert(offsetof(URHWidget, CloseOnLogout) == 0x00052C, "Member 'URHWidget::CloseOnLogout' has a wrong offset!");
static_assert(offsetof(URHWidget, IsComponent) == 0x00052D, "Member 'URHWidget::IsComponent' has a wrong offset!");
static_assert(offsetof(URHWidget, StartsHidden) == 0x00052E, "Member 'URHWidget::StartsHidden' has a wrong offset!");
static_assert(offsetof(URHWidget, InputComponentUsesWidgetPriority) == 0x00052F, "Member 'URHWidget::InputComponentUsesWidgetPriority' has a wrong offset!");
static_assert(offsetof(URHWidget, UsesBlocker) == 0x000530, "Member 'URHWidget::UsesBlocker' has a wrong offset!");
static_assert(offsetof(URHWidget, BlockerClickToClose) == 0x000531, "Member 'URHWidget::BlockerClickToClose' has a wrong offset!");
static_assert(offsetof(URHWidget, EnableGameStateSetNotify) == 0x000532, "Member 'URHWidget::EnableGameStateSetNotify' has a wrong offset!");
static_assert(offsetof(URHWidget, LoadedTexture) == 0x000538, "Member 'URHWidget::LoadedTexture' has a wrong offset!");
static_assert(offsetof(URHWidget, MobileLayoutSequencePlayer) == 0x0005A0, "Member 'URHWidget::MobileLayoutSequencePlayer' has a wrong offset!");
static_assert(offsetof(URHWidget, MobileLayoutAnim) == 0x0005A8, "Member 'URHWidget::MobileLayoutAnim' has a wrong offset!");
static_assert(offsetof(URHWidget, bMobileLayoutActive) == 0x0005B0, "Member 'URHWidget::bMobileLayoutActive' has a wrong offset!");

// Class RallyHereStart.RHProgressMeterWidgetBase
// 0x0020 (0x05D8 - 0x05B8)
class URHProgressMeterWidgetBase : public URHWidget
{
public:
	uint8                                         Pad_5B8[0x20];                                     // 0x05B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyMeterPercentages(float BasePercent, float DeltaPercent);
	void ApplyMeterPercentages_Raw(float BasePercent, float DeltaPercent);
	void EnableDeltaAnimation();
	bool IsPlayingDeltaAnimation();
	void OnDeltaAnimationFinished(bool bLevelChange);
	void OnDeltaAnimationStarted();
	void OnDeltaAnimationTicked();
	void PlayDeltaAnimation(float StartDelay);
	void SetDeltaAnimationParams(float BasePercent, float DeltaPercent, float AnimTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHProgressMeterWidgetBase">();
	}
	static class URHProgressMeterWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHProgressMeterWidgetBase>();
	}
};
static_assert(alignof(URHProgressMeterWidgetBase) == 0x000008, "Wrong alignment on URHProgressMeterWidgetBase");
static_assert(sizeof(URHProgressMeterWidgetBase) == 0x0005D8, "Wrong size on URHProgressMeterWidgetBase");

// Class RallyHereStart.RHBattlepassRewardsTrackSegment
// 0x0000 (0x05D8 - 0x05D8)
class URHBattlepassRewardsTrackSegment final : public URHProgressMeterWidgetBase
{
public:
	void ApplySegmentBackgroundColor(const struct FLinearColor& BackgroundColor);
	void ApplySegmentLabel(const class FText& LabelText);
	void ApplySegmentMeterColor(const struct FLinearColor& MeterColor);
	void ApplySegmentProgress(float ProgressPercent);
	struct FLinearColor GetBattlePassFreeColor();
	struct FLinearColor GetBattlePassPremiumColor();
	struct FLinearColor GetPremiumBackgroundColor();
	struct FLinearColor GetStandardBackgroundColor();
	void UpdateFromRewardItem(class URHBattlepass* Battlepass, class URHBattlepassRewardItem* BattlepassRewardItem, class URH_PlayerInfo* PlayerInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHBattlepassRewardsTrackSegment">();
	}
	static class URHBattlepassRewardsTrackSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHBattlepassRewardsTrackSegment>();
	}
};
static_assert(alignof(URHBattlepassRewardsTrackSegment) == 0x000008, "Wrong alignment on URHBattlepassRewardsTrackSegment");
static_assert(sizeof(URHBattlepassRewardsTrackSegment) == 0x0005D8, "Wrong size on URHBattlepassRewardsTrackSegment");

// Class RallyHereStart.RHBattlepassTrackWidget
// 0x0030 (0x05E8 - 0x05B8)
class URHBattlepassTrackWidget final : public URHWidget
{
public:
	int32                                         CurrentPage;                                       // 0x05B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumPages;                                          // 0x05BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URHWidget*>                      ItemButtons;                                       // 0x05C0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class URHBattlepass*                          Battlepass;                                        // 0x05D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URHBattlepassRewardItem*>        RewardItems;                                       // 0x05D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void SetBattlepass(class URHBattlepass* Battlepass_0);

	void GetRewardItemsForPage(int32 Index_0, TArray<class URHBattlepassRewardItem*>* RewardItems_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHBattlepassTrackWidget">();
	}
	static class URHBattlepassTrackWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHBattlepassTrackWidget>();
	}
};
static_assert(alignof(URHBattlepassTrackWidget) == 0x000008, "Wrong alignment on URHBattlepassTrackWidget");
static_assert(sizeof(URHBattlepassTrackWidget) == 0x0005E8, "Wrong size on URHBattlepassTrackWidget");
static_assert(offsetof(URHBattlepassTrackWidget, CurrentPage) == 0x0005B8, "Member 'URHBattlepassTrackWidget::CurrentPage' has a wrong offset!");
static_assert(offsetof(URHBattlepassTrackWidget, NumPages) == 0x0005BC, "Member 'URHBattlepassTrackWidget::NumPages' has a wrong offset!");
static_assert(offsetof(URHBattlepassTrackWidget, ItemButtons) == 0x0005C0, "Member 'URHBattlepassTrackWidget::ItemButtons' has a wrong offset!");
static_assert(offsetof(URHBattlepassTrackWidget, Battlepass) == 0x0005D0, "Member 'URHBattlepassTrackWidget::Battlepass' has a wrong offset!");
static_assert(offsetof(URHBattlepassTrackWidget, RewardItems) == 0x0005D8, "Member 'URHBattlepassTrackWidget::RewardItems' has a wrong offset!");

// Class RallyHereStart.RHBattlepassWidget
// 0x0018 (0x05D0 - 0x05B8)
class URHBattlepassWidget final : public URHWidget
{
public:
	class URHBattlepass*                          DisplayedBattlepass;                               // 0x05B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HomeViewTag;                                       // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PurchaseConfirmationViewTag;                       // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ShowPurchaseBattlepass();
	void ShowPurchaseBattlepassTiers(int32 TierCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHBattlepassWidget">();
	}
	static class URHBattlepassWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHBattlepassWidget>();
	}
};
static_assert(alignof(URHBattlepassWidget) == 0x000008, "Wrong alignment on URHBattlepassWidget");
static_assert(sizeof(URHBattlepassWidget) == 0x0005D0, "Wrong size on URHBattlepassWidget");
static_assert(offsetof(URHBattlepassWidget, DisplayedBattlepass) == 0x0005B8, "Member 'URHBattlepassWidget::DisplayedBattlepass' has a wrong offset!");
static_assert(offsetof(URHBattlepassWidget, HomeViewTag) == 0x0005C0, "Member 'URHBattlepassWidget::HomeViewTag' has a wrong offset!");
static_assert(offsetof(URHBattlepassWidget, PurchaseConfirmationViewTag) == 0x0005C8, "Member 'URHBattlepassWidget::PurchaseConfirmationViewTag' has a wrong offset!");

// Class RallyHereStart.RHBorder
// 0x0010 (0x0188 - 0x0178)
class URHBorder final : public UPlatformInventoryItem
{
public:
	class UIconInfo*                              SmallBorderIconInfo;                               // 0x0178(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIconInfo*                              LargeBorderIconInfo;                               // 0x0180(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UIconInfo* GetLargeBorderInfo() const;
	class UIconInfo* GetSmallBorderInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHBorder">();
	}
	static class URHBorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHBorder>();
	}
};
static_assert(alignof(URHBorder) == 0x000008, "Wrong alignment on URHBorder");
static_assert(sizeof(URHBorder) == 0x000188, "Wrong size on URHBorder");
static_assert(offsetof(URHBorder, SmallBorderIconInfo) == 0x000178, "Member 'URHBorder::SmallBorderIconInfo' has a wrong offset!");
static_assert(offsetof(URHBorder, LargeBorderIconInfo) == 0x000180, "Member 'URHBorder::LargeBorderIconInfo' has a wrong offset!");

// Class RallyHereStart.RHBoxDeadZoneFilter
// 0x0020 (0x0058 - 0x0038)
class URHBoxDeadZoneFilter final : public URHAnalogStickFilter
{
public:
	struct FVector2D                              InnerDeadZone;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OuterDeadZone;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHBoxDeadZoneFilter">();
	}
	static class URHBoxDeadZoneFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHBoxDeadZoneFilter>();
	}
};
static_assert(alignof(URHBoxDeadZoneFilter) == 0x000008, "Wrong alignment on URHBoxDeadZoneFilter");
static_assert(sizeof(URHBoxDeadZoneFilter) == 0x000058, "Wrong size on URHBoxDeadZoneFilter");
static_assert(offsetof(URHBoxDeadZoneFilter, InnerDeadZone) == 0x000038, "Member 'URHBoxDeadZoneFilter::InnerDeadZone' has a wrong offset!");
static_assert(offsetof(URHBoxDeadZoneFilter, OuterDeadZone) == 0x000048, "Member 'URHBoxDeadZoneFilter::OuterDeadZone' has a wrong offset!");

// Class RallyHereStart.RHCanvasPanel
// 0x0000 (0x01A8 - 0x01A8)
class URHCanvasPanel : public UCanvasPanel
{
public:
	void PlaceWidgetUnder(class UUserWidget* BottomWidget, class UUserWidget* TopWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHCanvasPanel">();
	}
	static class URHCanvasPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHCanvasPanel>();
	}
};
static_assert(alignof(URHCanvasPanel) == 0x000008, "Wrong alignment on URHCanvasPanel");
static_assert(sizeof(URHCanvasPanel) == 0x0001A8, "Wrong size on URHCanvasPanel");

// Class RallyHereStart.RHCircleDeadZoneFilter
// 0x0008 (0x0040 - 0x0038)
class URHCircleDeadZoneFilter final : public URHAnalogStickFilter
{
public:
	float                                         DeadZoneRadius;                                    // 0x0038(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CardinalDeadZoneHalfWidth;                         // 0x003C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHCircleDeadZoneFilter">();
	}
	static class URHCircleDeadZoneFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHCircleDeadZoneFilter>();
	}
};
static_assert(alignof(URHCircleDeadZoneFilter) == 0x000008, "Wrong alignment on URHCircleDeadZoneFilter");
static_assert(sizeof(URHCircleDeadZoneFilter) == 0x000040, "Wrong size on URHCircleDeadZoneFilter");
static_assert(offsetof(URHCircleDeadZoneFilter, DeadZoneRadius) == 0x000038, "Member 'URHCircleDeadZoneFilter::DeadZoneRadius' has a wrong offset!");
static_assert(offsetof(URHCircleDeadZoneFilter, CardinalDeadZoneHalfWidth) == 0x00003C, "Member 'URHCircleDeadZoneFilter::CardinalDeadZoneHalfWidth' has a wrong offset!");

// Class RallyHereStart.RHContextBar
// 0x0060 (0x0618 - 0x05B8)
class URHContextBar : public URHWidget
{
public:
	TSubclassOf<class URHContextBarPrompt>        PromptWidgetClass;                                 // 0x05B8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                LeftPromptMargin;                                  // 0x05C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                CenterPromptMargin;                                // 0x05D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                RightPromptMargin;                                 // 0x05E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         LeftContainer;                                     // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         CenterContainer;                                   // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         RightContainer;                                    // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URHContextBarPrompt*>            PromptPool;                                        // 0x0608(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void RefreshContextBar();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHContextBar">();
	}
	static class URHContextBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHContextBar>();
	}
};
static_assert(alignof(URHContextBar) == 0x000008, "Wrong alignment on URHContextBar");
static_assert(sizeof(URHContextBar) == 0x000618, "Wrong size on URHContextBar");
static_assert(offsetof(URHContextBar, PromptWidgetClass) == 0x0005B8, "Member 'URHContextBar::PromptWidgetClass' has a wrong offset!");
static_assert(offsetof(URHContextBar, LeftPromptMargin) == 0x0005C0, "Member 'URHContextBar::LeftPromptMargin' has a wrong offset!");
static_assert(offsetof(URHContextBar, CenterPromptMargin) == 0x0005D0, "Member 'URHContextBar::CenterPromptMargin' has a wrong offset!");
static_assert(offsetof(URHContextBar, RightPromptMargin) == 0x0005E0, "Member 'URHContextBar::RightPromptMargin' has a wrong offset!");
static_assert(offsetof(URHContextBar, LeftContainer) == 0x0005F0, "Member 'URHContextBar::LeftContainer' has a wrong offset!");
static_assert(offsetof(URHContextBar, CenterContainer) == 0x0005F8, "Member 'URHContextBar::CenterContainer' has a wrong offset!");
static_assert(offsetof(URHContextBar, RightContainer) == 0x000600, "Member 'URHContextBar::RightContainer' has a wrong offset!");
static_assert(offsetof(URHContextBar, PromptPool) == 0x000608, "Member 'URHContextBar::PromptPool' has a wrong offset!");

// Class RallyHereStart.RHContextBarPrompt
// 0x0010 (0x05C8 - 0x05B8)
class URHContextBarPrompt : public URHWidget
{
public:
	class UContextActionData*                     ContextActionData;                                 // 0x05B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPoolable;                                        // 0x05C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C1[0x7];                                      // 0x05C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleInputStateChanged(ERH_INPUT_STATE InputState);
	void OnContextActionUpdated(class UContextActionData* InData);
	void OnInputStateChanged(ERH_INPUT_STATE InputState);

	class UContextActionData* GetContextActionData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHContextBarPrompt">();
	}
	static class URHContextBarPrompt* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHContextBarPrompt>();
	}
};
static_assert(alignof(URHContextBarPrompt) == 0x000008, "Wrong alignment on URHContextBarPrompt");
static_assert(sizeof(URHContextBarPrompt) == 0x0005C8, "Wrong size on URHContextBarPrompt");
static_assert(offsetof(URHContextBarPrompt, ContextActionData) == 0x0005B8, "Member 'URHContextBarPrompt::ContextActionData' has a wrong offset!");
static_assert(offsetof(URHContextBarPrompt, IsPoolable) == 0x0005C0, "Member 'URHContextBarPrompt::IsPoolable' has a wrong offset!");

// Class RallyHereStart.RHContextMenu
// 0x0060 (0x0618 - 0x05B8)
class URHContextMenu : public URHWidget
{
public:
	TMulticastInlineDelegate<void()>              OnContextOptionsUpdated;                           // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class URH_RHFriendAndPlatformFriend* ReportedPlayerTarget)> OnReportPlayer; // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(bool Succeeded)> OnContextOptionCompleted;                         // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	EPlayerContextMenuContext                     MenuContext;                                       // 0x05E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowReportPlayer;                                // 0x05E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EA[0x6];                                      // 0x05EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_RHFriendAndPlatformFriend*          CurrentFriend;                                     // 0x05F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URHContextMenuButton*>           ContextMenuButtons;                                // 0x05F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EViewSide                                     MenuViewSide;                                      // 0x0608(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CachedQueuedOrInMatch;                             // 0x060C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCachedReportedPlayer;                             // 0x0610(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x7];                                      // 0x0611(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddContextMenuButton(class URHContextMenuButton* ContextButton);
	void ClearAllContextMenuButton();
	class URHContextMenuButton* GetContextButtonByEnum(EPlayerContextOptions ContextOption);
	void HandleOnQueueStatusChange(ERH_MatchStatus QueueStatus);
	bool OnOptionSelected(EPlayerContextOptions ContextOption);
	void RemoveContextMenuButton(class URHContextMenuButton* ContextButton);
	void RemoveRHFriend();
	void SetCurrentFriend(class URH_RHFriendAndPlatformFriend* Friend);
	struct FVector2D SetMenuPosition(class URHWidget* WidgetToMove, const struct FMargin& WidgetPadding, EViewSide side, float menuWidth, float menuHeight);
	void SetOptionsVisibility();

	class URHPartyManager* GetPartyManager() const;
	class URHQueueDataFactory* GetQueueDataFactory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHContextMenu">();
	}
	static class URHContextMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHContextMenu>();
	}
};
static_assert(alignof(URHContextMenu) == 0x000008, "Wrong alignment on URHContextMenu");
static_assert(sizeof(URHContextMenu) == 0x000618, "Wrong size on URHContextMenu");
static_assert(offsetof(URHContextMenu, OnContextOptionsUpdated) == 0x0005B8, "Member 'URHContextMenu::OnContextOptionsUpdated' has a wrong offset!");
static_assert(offsetof(URHContextMenu, OnReportPlayer) == 0x0005C8, "Member 'URHContextMenu::OnReportPlayer' has a wrong offset!");
static_assert(offsetof(URHContextMenu, OnContextOptionCompleted) == 0x0005D8, "Member 'URHContextMenu::OnContextOptionCompleted' has a wrong offset!");
static_assert(offsetof(URHContextMenu, MenuContext) == 0x0005E8, "Member 'URHContextMenu::MenuContext' has a wrong offset!");
static_assert(offsetof(URHContextMenu, bAllowReportPlayer) == 0x0005E9, "Member 'URHContextMenu::bAllowReportPlayer' has a wrong offset!");
static_assert(offsetof(URHContextMenu, CurrentFriend) == 0x0005F0, "Member 'URHContextMenu::CurrentFriend' has a wrong offset!");
static_assert(offsetof(URHContextMenu, ContextMenuButtons) == 0x0005F8, "Member 'URHContextMenu::ContextMenuButtons' has a wrong offset!");
static_assert(offsetof(URHContextMenu, MenuViewSide) == 0x000608, "Member 'URHContextMenu::MenuViewSide' has a wrong offset!");
static_assert(offsetof(URHContextMenu, CachedQueuedOrInMatch) == 0x00060C, "Member 'URHContextMenu::CachedQueuedOrInMatch' has a wrong offset!");
static_assert(offsetof(URHContextMenu, bCachedReportedPlayer) == 0x000610, "Member 'URHContextMenu::bCachedReportedPlayer' has a wrong offset!");

// Class RallyHereStart.RHContextMenuButton
// 0x0008 (0x05C0 - 0x05B8)
class URHContextMenuButton : public URHWidget
{
public:
	EPlayerContextOptions                         ContextOption;                                     // 0x05B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleActive(bool IsActive);
	void HandleVisibility(bool isVisibility);
	void SetContextOption(EPlayerContextOptions Context);

	EPlayerContextOptions GetContextOption() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHContextMenuButton">();
	}
	static class URHContextMenuButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHContextMenuButton>();
	}
};
static_assert(alignof(URHContextMenuButton) == 0x000008, "Wrong alignment on URHContextMenuButton");
static_assert(sizeof(URHContextMenuButton) == 0x0005C0, "Wrong size on URHContextMenuButton");
static_assert(offsetof(URHContextMenuButton, ContextOption) == 0x0005B8, "Member 'URHContextMenuButton::ContextOption' has a wrong offset!");

// Class RallyHereStart.RHCurrency
// 0x00A0 (0x0218 - 0x0178)
class URHCurrency final : public UPlatformInventoryItem
{
public:
	bool                                          IsDLCVoucher;                                      // 0x0178(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PriceGroupTag;                                     // 0x017C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnforcePrice;                               // 0x0184(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EnforcePriority;                                   // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CurrencyTags;                                      // 0x0190(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              CurrencyDataByQtyTable;                            // 0x01B8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIconInfo*                              FullSplashIconInfo;                                // 0x01E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIconInfo*                              SmallIconIconInfo;                                 // 0x01E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UPlatformInventoryItem>  CurrencyWrapperItem;                               // 0x01F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetCurrencyDataForQuantity(int32 Quantity, struct FCurrencyImageRow* Data) const;
	class UIconInfo* GetFullSplash() const;
	class UIconInfo* GetSmallIcon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHCurrency">();
	}
	static class URHCurrency* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHCurrency>();
	}
};
static_assert(alignof(URHCurrency) == 0x000008, "Wrong alignment on URHCurrency");
static_assert(sizeof(URHCurrency) == 0x000218, "Wrong size on URHCurrency");
static_assert(offsetof(URHCurrency, IsDLCVoucher) == 0x000178, "Member 'URHCurrency::IsDLCVoucher' has a wrong offset!");
static_assert(offsetof(URHCurrency, PriceGroupTag) == 0x00017C, "Member 'URHCurrency::PriceGroupTag' has a wrong offset!");
static_assert(offsetof(URHCurrency, bShouldEnforcePrice) == 0x000184, "Member 'URHCurrency::bShouldEnforcePrice' has a wrong offset!");
static_assert(offsetof(URHCurrency, EnforcePriority) == 0x000188, "Member 'URHCurrency::EnforcePriority' has a wrong offset!");
static_assert(offsetof(URHCurrency, CurrencyTags) == 0x000190, "Member 'URHCurrency::CurrencyTags' has a wrong offset!");
static_assert(offsetof(URHCurrency, SortOrder) == 0x0001B0, "Member 'URHCurrency::SortOrder' has a wrong offset!");
static_assert(offsetof(URHCurrency, CurrencyDataByQtyTable) == 0x0001B8, "Member 'URHCurrency::CurrencyDataByQtyTable' has a wrong offset!");
static_assert(offsetof(URHCurrency, FullSplashIconInfo) == 0x0001E0, "Member 'URHCurrency::FullSplashIconInfo' has a wrong offset!");
static_assert(offsetof(URHCurrency, SmallIconIconInfo) == 0x0001E8, "Member 'URHCurrency::SmallIconIconInfo' has a wrong offset!");
static_assert(offsetof(URHCurrency, CurrencyWrapperItem) == 0x0001F0, "Member 'URHCurrency::CurrencyWrapperItem' has a wrong offset!");

// Class RallyHereStart.RHCurrencyDisplay
// 0x0000 (0x05B8 - 0x05B8)
class URHCurrencyDisplay final : public URHWidget
{
public:
	void SetCurrentDisplayByItem(class URHStoreItem* StoreItem);
	void SetInventoryCountOnText(const struct FRH_ItemId& ItemId, class UTextBlock* TextBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHCurrencyDisplay">();
	}
	static class URHCurrencyDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHCurrencyDisplay>();
	}
};
static_assert(alignof(URHCurrencyDisplay) == 0x000008, "Wrong alignment on URHCurrencyDisplay");
static_assert(sizeof(URHCurrencyDisplay) == 0x0005B8, "Wrong size on URHCurrencyDisplay");

// Class RallyHereStart.RHCustomBrowser
// 0x0058 (0x0610 - 0x05B8)
class URHCustomBrowser : public URHWidget
{
public:
	TMulticastInlineDelegate<void()>              OnBrowserResultsUpdated;                           // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class URHCustomBrowserEntry>      BrowserEntryWidgetClass;                           // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URHWidget*>                      JoinCustomButtons;                                 // 0x05D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class URH_SessionView*>                SessionSearchResults;                              // 0x05E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x18];                                     // 0x05F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EntriesPerPage;                                    // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentPage;                                       // 0x060C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GoToNextPage();
	void GoToPreviousPage();
	void HandleSearchResultReceived(const TArray<class URH_SessionView*>& CustomSessions);
	void OnBrowserEntryAdded(class URHCustomBrowserEntry* BrowserEntry);
	void UpdateNameFilterText(const class FText& InText);
	void UpdatePaginationDisplay();
	void UpdateResultDisplay();

	class UPanelWidget* GetBrowserEntriesContainer() const;
	TArray<class URH_SessionView*> GetFilteredSessionSearchResults() const;
	TArray<class URHWidget*> GetJoinCustomButtons() const;
	class URHQueueDataFactory* GetQueueDataFactory() const;
	int32 GetTotalPages() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHCustomBrowser">();
	}
	static class URHCustomBrowser* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHCustomBrowser>();
	}
};
static_assert(alignof(URHCustomBrowser) == 0x000008, "Wrong alignment on URHCustomBrowser");
static_assert(sizeof(URHCustomBrowser) == 0x000610, "Wrong size on URHCustomBrowser");
static_assert(offsetof(URHCustomBrowser, OnBrowserResultsUpdated) == 0x0005B8, "Member 'URHCustomBrowser::OnBrowserResultsUpdated' has a wrong offset!");
static_assert(offsetof(URHCustomBrowser, BrowserEntryWidgetClass) == 0x0005C8, "Member 'URHCustomBrowser::BrowserEntryWidgetClass' has a wrong offset!");
static_assert(offsetof(URHCustomBrowser, JoinCustomButtons) == 0x0005D0, "Member 'URHCustomBrowser::JoinCustomButtons' has a wrong offset!");
static_assert(offsetof(URHCustomBrowser, SessionSearchResults) == 0x0005E0, "Member 'URHCustomBrowser::SessionSearchResults' has a wrong offset!");
static_assert(offsetof(URHCustomBrowser, EntriesPerPage) == 0x000608, "Member 'URHCustomBrowser::EntriesPerPage' has a wrong offset!");
static_assert(offsetof(URHCustomBrowser, CurrentPage) == 0x00060C, "Member 'URHCustomBrowser::CurrentPage' has a wrong offset!");

// Class RallyHereStart.RHCustomBrowserEntry
// 0x0008 (0x05C0 - 0x05B8)
class URHCustomBrowserEntry : public URHWidget
{
public:
	class URH_SessionView*                        CorrespondingSession;                              // 0x05B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class URHWidget* GetJoinButton();
	void JoinGame();
	void OnCustomLobbyNameSanitized(bool bSuccess, const class FString& SanitizedName);
	void OnCustomMatchSessionJoinResult(bool bSuccess, const class URH_SessionView* SessionToJoin);
	void SetCustomGameInfo(class URH_SessionView* InSession);
	void SetGameLeaderNameDisplay(const class FString& LeaderName);
	void SetGameLobbyNameDisplay(const class FString& LobbyName);
	void SetGamePlayerCountDisplay(const int32 PlayerCount, const int32 MaxPlayerCount);
	void SetGameStarted(const bool bGameStarted);
	void SetMapInfo(const class FName MapRowName, const struct FRHMapDetails& MapDetails);
	void SetRegionDisplay(const class FText& RegionAsText);

	class FString GetGameLeaderName() const;
	bool GetIsGameStarted() const;
	class URHQueueDataFactory* GetQueueDataFactory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHCustomBrowserEntry">();
	}
	static class URHCustomBrowserEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHCustomBrowserEntry>();
	}
};
static_assert(alignof(URHCustomBrowserEntry) == 0x000008, "Wrong alignment on URHCustomBrowserEntry");
static_assert(sizeof(URHCustomBrowserEntry) == 0x0005C0, "Wrong size on URHCustomBrowserEntry");
static_assert(offsetof(URHCustomBrowserEntry, CorrespondingSession) == 0x0005B8, "Member 'URHCustomBrowserEntry::CorrespondingSession' has a wrong offset!");

// Class RallyHereStart.RHCustomGameLobby
// 0x00D8 (0x0690 - 0x05B8)
class URHCustomGameLobby : public URHWidget
{
public:
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URHCustomLobbyPlayer>       LobbyPlayerWidgetClass;                            // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UPanelWidget*>              TeamNumToTeamPanelMap;                             // 0x05D0(0x0050)(BlueprintVisible, ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FCustomLobbyTeam>          TeamNumToTeamStructMap;                            // 0x0620(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_670[0x10];                                     // 0x0670(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           MassInviteRouteTag;                                // 0x0680(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URHWidget* GetLeaveLobbyButton();
	class URHCustomLobbyPlayer* GetPlayerWidgetForUuid(const struct FGuid& PlayerUuid);
	class URHWidget* GetSpectatorButton();
	class URHWidget* GetStartGameButton();
	class URHWidget* GetTeam1AddBotButton();
	class URHWidget* GetTeam2AddBotButton();
	void HandleBackContextAction();
	void HandleMapChanged();
	void HandleNameChanged();
	void HandleOnCustomMatchJoined();
	void HandlePlayerClicked(const struct FRH_CustomMatchMember& MatchMember, class URHCustomLobbyPlayer* PlayerWidget);
	void HandlePlayerInputTypeChanged(ERH_INPUT_STATE NewState);
	void HandlePlayerSwapTeam(const struct FGuid& PlayerUuid, int32 CurrentTeam);
	void HandlePrivacyChanged(EHWCustomMatchPrivacy MatchPrivacy);
	void HandleRegionChanged(const class FString& RegionId);
	void MassInvite_Close();
	bool MassInvite_IsSelected(class URH_RHFriendAndPlatformFriend* PlayerInfo);
	ERHInviteSelectResult MassInvite_Select(class URH_RHFriendAndPlatformFriend* PlayerInfo);
	bool MassInvite_ShouldShowPlayer(class URH_RHFriendAndPlatformFriend* PlayerInfo);
	void OnCustomLobbyNameSanitized(bool bSuccess, const class FString& SanitizedName);
	void OpenMassInviteView(int32 InTeamToInviteTo);
	void PlayerInputTypeChanged(bool bIsGamepad);
	void PopulateLobbyWithSessionData();
	void SetUpTeamPlayerWidgets();
	void ToggleLocalPlayerSpectate();
	void UpdateLobbyName(const class FString& NewName);
	void UpdateLobbyPrivacy(const EHWCustomMatchPrivacy& NewMatchPrivacy);
	void UpdateRegionDisplay(const class FString& RegionId);

	class URH_JoinedSession* GetCustomMatchSession() const;
	class URHWidget* GetPlayerWidget(int32 TeamIndex, int32 PlayerIndex) const;
	class URHQueueDataFactory* GetQueueDataFactory() const;
	bool IsCustomBotEnabled() const;
	bool IsLocalPlayerSpectator() const;
	bool IsSpectatingEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHCustomGameLobby">();
	}
	static class URHCustomGameLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHCustomGameLobby>();
	}
};
static_assert(alignof(URHCustomGameLobby) == 0x000008, "Wrong alignment on URHCustomGameLobby");
static_assert(sizeof(URHCustomGameLobby) == 0x000690, "Wrong size on URHCustomGameLobby");
static_assert(offsetof(URHCustomGameLobby, LobbyPlayerWidgetClass) == 0x0005C8, "Member 'URHCustomGameLobby::LobbyPlayerWidgetClass' has a wrong offset!");
static_assert(offsetof(URHCustomGameLobby, TeamNumToTeamPanelMap) == 0x0005D0, "Member 'URHCustomGameLobby::TeamNumToTeamPanelMap' has a wrong offset!");
static_assert(offsetof(URHCustomGameLobby, TeamNumToTeamStructMap) == 0x000620, "Member 'URHCustomGameLobby::TeamNumToTeamStructMap' has a wrong offset!");
static_assert(offsetof(URHCustomGameLobby, MassInviteRouteTag) == 0x000680, "Member 'URHCustomGameLobby::MassInviteRouteTag' has a wrong offset!");

// Class RallyHereStart.RHCustomLobbyPlayer
// 0x0058 (0x0610 - 0x05B8)
class URHCustomLobbyPlayer : public URHWidget
{
public:
	bool                                          bHiddenWhenEmpty;                                  // 0x05B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x3];                                      // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AssociatedTeam;                                    // 0x05BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C0[0x30];                                     // 0x05C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_CustomMatchMember                  MatchMemberInfo;                                   // 0x05F0(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void EmptyClicked();
	void PlayerClicked();
	void SetEmpty();
	void SetMatchMember(const struct FRH_CustomMatchMember& InMatchMember);
	void SwapTeam();

	bool GetCanLocalPlayerControl() const;
	bool GetCanLocalPlayerKick() const;
	class URHQueueDataFactory* GetQueueDataFactory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHCustomLobbyPlayer">();
	}
	static class URHCustomLobbyPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHCustomLobbyPlayer>();
	}
};
static_assert(alignof(URHCustomLobbyPlayer) == 0x000008, "Wrong alignment on URHCustomLobbyPlayer");
static_assert(sizeof(URHCustomLobbyPlayer) == 0x000610, "Wrong size on URHCustomLobbyPlayer");
static_assert(offsetof(URHCustomLobbyPlayer, bHiddenWhenEmpty) == 0x0005B8, "Member 'URHCustomLobbyPlayer::bHiddenWhenEmpty' has a wrong offset!");
static_assert(offsetof(URHCustomLobbyPlayer, AssociatedTeam) == 0x0005BC, "Member 'URHCustomLobbyPlayer::AssociatedTeam' has a wrong offset!");
static_assert(offsetof(URHCustomLobbyPlayer, MatchMemberInfo) == 0x0005F0, "Member 'URHCustomLobbyPlayer::MatchMemberInfo' has a wrong offset!");

// Class RallyHereStart.RHCustomMapSelect
// 0x0010 (0x05C8 - 0x05B8)
class URHCustomMapSelect final : public URHWidget
{
public:
	TSubclassOf<class URHMapButton>               MapButtonClass;                                    // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxColumn;                                         // 0x05C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUniformGridPanel* GetMapGrid();
	void HandleOnMapButtonSelected(class FName MapName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHCustomMapSelect">();
	}
	static class URHCustomMapSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHCustomMapSelect>();
	}
};
static_assert(alignof(URHCustomMapSelect) == 0x000008, "Wrong alignment on URHCustomMapSelect");
static_assert(sizeof(URHCustomMapSelect) == 0x0005C8, "Wrong size on URHCustomMapSelect");
static_assert(offsetof(URHCustomMapSelect, MapButtonClass) == 0x0005B8, "Member 'URHCustomMapSelect::MapButtonClass' has a wrong offset!");
static_assert(offsetof(URHCustomMapSelect, MaxColumn) == 0x0005C0, "Member 'URHCustomMapSelect::MaxColumn' has a wrong offset!");

// Class RallyHereStart.RHDataFactory
// 0x0010 (0x0038 - 0x0028)
class URHDataFactory : public UObject
{
public:
	class ARHHUDCommon*                           MyHud;                                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsLoggedIn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHDataFactory">();
	}
	static class URHDataFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHDataFactory>();
	}
};
static_assert(alignof(URHDataFactory) == 0x000008, "Wrong alignment on URHDataFactory");
static_assert(sizeof(URHDataFactory) == 0x000038, "Wrong size on URHDataFactory");
static_assert(offsetof(URHDataFactory, MyHud) == 0x000028, "Member 'URHDataFactory::MyHud' has a wrong offset!");

// Class RallyHereStart.RHDataSocialCategory
// 0x00D8 (0x0100 - 0x0028)
class alignas(0x10) URHDataSocialCategory final : public UObject
{
public:
	TMulticastInlineDelegate<void(class URHDataSocialCategory* Category, const TArray<class URHDataSocialPlayer*>& Players)> OnPlayersUpdated; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHDataSocialCategory* Category, class FText Header)> OnHeaderUpdated; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHDataSocialCategory* Category, bool Processing, class FText Header)> OnMessageUpdated; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x98];                                      // 0x0058(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URHDataSocialPlayer*>            SortedPlayerList;                                  // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	TArray<class URHDataSocialPlayer*> GetPlayerList();
	void SetHeaderText(const class FText& Header);
	void SetMessageText(bool bProcessing, const class FText& MessageText);
	void SetOpenOnUpdate(bool Value);
	bool TryConsumeOpenOnUpdate();

	uint8 BP_GetSectionValue() const;
	class FText GetHeaderText() const;
	class FText GetMessageText() const;
	class FString GetSectionSubtype() const;
	bool IsProcessing() const;
	int32 Num() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHDataSocialCategory">();
	}
	static class URHDataSocialCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHDataSocialCategory>();
	}
};
static_assert(alignof(URHDataSocialCategory) == 0x000010, "Wrong alignment on URHDataSocialCategory");
static_assert(sizeof(URHDataSocialCategory) == 0x000100, "Wrong size on URHDataSocialCategory");
static_assert(offsetof(URHDataSocialCategory, OnPlayersUpdated) == 0x000028, "Member 'URHDataSocialCategory::OnPlayersUpdated' has a wrong offset!");
static_assert(offsetof(URHDataSocialCategory, OnHeaderUpdated) == 0x000038, "Member 'URHDataSocialCategory::OnHeaderUpdated' has a wrong offset!");
static_assert(offsetof(URHDataSocialCategory, OnMessageUpdated) == 0x000048, "Member 'URHDataSocialCategory::OnMessageUpdated' has a wrong offset!");
static_assert(offsetof(URHDataSocialCategory, SortedPlayerList) == 0x0000F0, "Member 'URHDataSocialCategory::SortedPlayerList' has a wrong offset!");

// Class RallyHereStart.RHDataSocialPlayer
// 0x0018 (0x0040 - 0x0028)
class URHDataSocialPlayer final : public UObject
{
public:
	TMulticastInlineDelegate<void(class URH_RHFriendAndPlatformFriend* Friend)> OnRhDataUpdate;      // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class URH_RHFriendAndPlatformFriend*          Friend;                                            // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class URH_RHFriendAndPlatformFriend* GetFriend() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHDataSocialPlayer">();
	}
	static class URHDataSocialPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHDataSocialPlayer>();
	}
};
static_assert(alignof(URHDataSocialPlayer) == 0x000008, "Wrong alignment on URHDataSocialPlayer");
static_assert(sizeof(URHDataSocialPlayer) == 0x000040, "Wrong size on URHDataSocialPlayer");
static_assert(offsetof(URHDataSocialPlayer, OnRhDataUpdate) == 0x000028, "Member 'URHDataSocialPlayer::OnRhDataUpdate' has a wrong offset!");
static_assert(offsetof(URHDataSocialPlayer, Friend) == 0x000038, "Member 'URHDataSocialPlayer::Friend' has a wrong offset!");

// Class RallyHereStart.RHEditableTextBox
// 0x0010 (0x10B0 - 0x10A0)
class URHEditableTextBox : public UEditableTextBox
{
public:
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)> OnKeyDown; // 0x10A0(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHEditableTextBox">();
	}
	static class URHEditableTextBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHEditableTextBox>();
	}
};
static_assert(alignof(URHEditableTextBox) == 0x000010, "Wrong alignment on URHEditableTextBox");
static_assert(sizeof(URHEditableTextBox) == 0x0010B0, "Wrong size on URHEditableTextBox");
static_assert(offsetof(URHEditableTextBox, OnKeyDown) == 0x0010A0, "Member 'URHEditableTextBox::OnKeyDown' has a wrong offset!");

// Class RallyHereStart.RHEventSubsystem
// 0x0030 (0x0060 - 0x0030)
class URHEventSubsystem final : public UGameInstanceSubsystem
{
public:
	struct FSoftObjectPath                        EventSubsystemDataTableClassName;                  // 0x0030(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             EventsDataDT;                                      // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URHEvent* GetEventByTag(class FName EventTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHEventSubsystem">();
	}
	static class URHEventSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHEventSubsystem>();
	}
};
static_assert(alignof(URHEventSubsystem) == 0x000008, "Wrong alignment on URHEventSubsystem");
static_assert(sizeof(URHEventSubsystem) == 0x000060, "Wrong size on URHEventSubsystem");
static_assert(offsetof(URHEventSubsystem, EventSubsystemDataTableClassName) == 0x000030, "Member 'URHEventSubsystem::EventSubsystemDataTableClassName' has a wrong offset!");
static_assert(offsetof(URHEventSubsystem, EventsDataDT) == 0x000050, "Member 'URHEventSubsystem::EventsDataDT' has a wrong offset!");

// Class RallyHereStart.RHFloatTickLerpWidgetBase
// 0x0028 (0x02E8 - 0x02C0)
class URHFloatTickLerpWidgetBase final : public UUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnLerpComplete;                                    // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         LerpTime;                                          // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LerpPower;                                         // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisplayForValue(float Value);
	void ForceCurrentValue(float Value);
	float GetCurrentValue();
	bool IsLerping();
	void SetLerpPower(float Power);
	void SetLerpTime(float Time);
	void SetTargetValue(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHFloatTickLerpWidgetBase">();
	}
	static class URHFloatTickLerpWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHFloatTickLerpWidgetBase>();
	}
};
static_assert(alignof(URHFloatTickLerpWidgetBase) == 0x000008, "Wrong alignment on URHFloatTickLerpWidgetBase");
static_assert(sizeof(URHFloatTickLerpWidgetBase) == 0x0002E8, "Wrong size on URHFloatTickLerpWidgetBase");
static_assert(offsetof(URHFloatTickLerpWidgetBase, OnLerpComplete) == 0x0002C0, "Member 'URHFloatTickLerpWidgetBase::OnLerpComplete' has a wrong offset!");
static_assert(offsetof(URHFloatTickLerpWidgetBase, LerpTime) == 0x0002D0, "Member 'URHFloatTickLerpWidgetBase::LerpTime' has a wrong offset!");
static_assert(offsetof(URHFloatTickLerpWidgetBase, LerpPower) == 0x0002D4, "Member 'URHFloatTickLerpWidgetBase::LerpPower' has a wrong offset!");

// Class RallyHereStart.RHGameEngine
// 0x0010 (0x1108 - 0x10F8)
class URHGameEngine final : public UGameEngine
{
public:
	uint8                                         Pad_10F8[0x10];                                    // 0x10F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGameEngine">();
	}
	static class URHGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHGameEngine>();
	}
};
static_assert(alignof(URHGameEngine) == 0x000008, "Wrong alignment on URHGameEngine");
static_assert(sizeof(URHGameEngine) == 0x001108, "Wrong size on URHGameEngine");

// Class RallyHereStart.RHHUDCommon
// 0x0178 (0x0500 - 0x0388)
class ARHHUDCommon : public AHUD
{
public:
	TMulticastInlineDelegate<void()>              OnPreferredRegionUpdated;                          // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ERH_INPUT_STATE InputState)> OnInputStateChanged;                  // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class URHLoginDataFactory*                    LoginDataFactory;                                  // 0x03C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHSettingsDataFactory*                 SettingsFactory;                                   // 0x03C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHPartyManager*                        PartyManager;                                      // 0x03D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHInputManager*                        InputManager;                                      // 0x03D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHViewManager*                         ViewManager;                                       // 0x03E0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URHInputManager>            InputManagerClass;                                 // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRHNavigation;                                  // 0x03F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F1[0xF];                                      // 0x03F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ColorPaletteDT;                                    // 0x0400(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             FontPaletteDT;                                     // 0x0408(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHUISoundTheme*                        SoundTheme;                                        // 0x0410(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x20];                                     // 0x0418(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           AcceptPressedAction;                               // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           AcceptReleasedAction;                              // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           CancelPressedAction;                               // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           CancelReleasedAction;                              // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           HoldToConfirmAction;                               // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           HoldToCancelAction;                                // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           NavigateUpAction;                                  // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           NavigateDownAction;                                // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           NavigateRightAction;                               // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           NavigateLeftAction;                                // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputMappingContext*                   HUDMappingContext;                                 // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputMappingContext*                   MutableMappingContext;                             // 0x0490(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x18];                                     // 0x0498(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         QueueDataFactorySoftClass;                         // 0x04B0(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftClassPath                         PartyManagerSoftClass;                             // 0x04D0(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URHQueueDataFactory*                    QueueDataFactory;                                  // 0x04F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ApplySafeFrameScale(float SafeFrameScale);
	void ConfirmReportServer();
	void DisplayGenericError(const class FString& sDesc);
	void DisplayGenericPopup(const class FString& sTitle, const class FString& sDesc);
	void EvaluateFocus();
	class UInputAction* GetAcceptPressedAction();
	class UInputAction* GetAcceptReleasedAction();
	class UInputAction* GetCancelPressedAction();
	class UInputAction* GetCancelReleasedAction();
	TArray<class UPanelWidget*> GetFocusableWidgetContainers();
	class UInputAction* GetHoldToCancelAction();
	class UInputAction* GetHoldToConfirmAction();
	class UInputMappingContext* GetHUDMappingContext();
	class URHInputManager* GetInputManager();
	class UInputAction* GetNavigateDownAction();
	class UInputAction* GetNavigateLeftAction();
	class UInputAction* GetNavigateRightAction();
	class UInputAction* GetNavigateUpAction();
	class URH_PlayerInfo* GetOrCreatePlayerInfo(const struct FGuid& PlayerUuid);
	class APlayerController* GetPlayerControllerOwner();
	class URH_PlayerInfo* GetPlayerInfo(const struct FGuid& PlayerUuid);
	class URHPopupManager* GetPopupManager();
	void HandleCommunicationSettingChanged();
	void HandleControllerDisconnect();
	void HandleControllerReconnected();
	void HandleLoginStateChange(ERHLoginState LoginState);
	void HandleMatchStatusUpdated(ERH_MatchStatus MatchStatus);
	void InputStateChangePassthrough(ERH_INPUT_STATE InputState);
	void LogErrorMessage(const class FText& ErrorMsg);
	void OnConfirmLogout();
	void OnConfirmQuit();
	void OnInvalidVoucherOrder(class URHStoreItem* StoreItem);
	void OnLogout();
	bool OnNavigateBack();
	void OnQuit();
	void OnRegionsUpdated(class URH_MatchmakingBrowserCache* MatchingBrowserCache);
	void PrintToLog(const class FText& InText);
	void SetNavigationEnabled(bool Enabled);
	void SetPreferredRegionId(const class FString& RegionId);
	void SetUIFocus();
	void SetUseNewUIFeatures(bool UseNewFeatures);
	void SetViewManager(class URHViewManager* InViewManager);
	void ShowErrorPopup(const class FText& ErrorMsg);
	void UIX_ReportServer();

	bool GetColor(class FName ColorName, struct FLinearColor* ReturnColor) const;
	ERH_INPUT_STATE GetCurrentInputState() const;
	bool GetFont(class FName FontName, struct FSlateFontInfo* ReturnFont) const;
	class URH_GameInstanceSubsystem* GetGameInstanceSubsystem() const;
	class URHLocalDataSubsystem* GetLocalDataSubsystem() const;
	class URH_LocalPlayerSubsystem* GetLocalPlayerSubsystem() const;
	class URHLoginDataFactory* GetLoginDataFactory() const;
	class URHOrderSubsystem* GetOrderSubsystem() const;
	struct FUniqueNetIdWrapper GetOSSUniqueId() const;
	class URHPartyManager* GetPartyManager() const;
	struct FPlatformUserId GetPlatformUserId() const;
	class URH_PlayerInfoSubsystem* GetPlayerInfoSubsystem() const;
	bool GetPreferredRegionId(class FString* OutRegionId) const;
	class URHQueueDataFactory* GetQueueDataFactory() const;
	void GetRegionList(TMap<class FString, class FText>* OutRegionIdToNameMap, bool bIncludeCustomOnlyRegions) const;
	class URHSettingsDataFactory* GetSettingsDataFactory() const;
	class URHViewManager* GetViewManager() const;
	bool IsCrossplayEnabled() const;
	bool IsLobbyHUD() const;
	bool IsSamePlatformAsLocalPlayer(const struct FGuid& PlayerId) const;
	bool ShouldShowCrossplayIconForPlayer(const struct FGuid& PlayerId) const;
	bool ShouldShowCrossplayIconForPlayerState(class ARHPlayerState* PlayerState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHHUDCommon">();
	}
	static class ARHHUDCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARHHUDCommon>();
	}
};
static_assert(alignof(ARHHUDCommon) == 0x000008, "Wrong alignment on ARHHUDCommon");
static_assert(sizeof(ARHHUDCommon) == 0x000500, "Wrong size on ARHHUDCommon");
static_assert(offsetof(ARHHUDCommon, OnPreferredRegionUpdated) == 0x000388, "Member 'ARHHUDCommon::OnPreferredRegionUpdated' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, OnInputStateChanged) == 0x000398, "Member 'ARHHUDCommon::OnInputStateChanged' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, LoginDataFactory) == 0x0003C0, "Member 'ARHHUDCommon::LoginDataFactory' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, SettingsFactory) == 0x0003C8, "Member 'ARHHUDCommon::SettingsFactory' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, PartyManager) == 0x0003D0, "Member 'ARHHUDCommon::PartyManager' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, InputManager) == 0x0003D8, "Member 'ARHHUDCommon::InputManager' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, ViewManager) == 0x0003E0, "Member 'ARHHUDCommon::ViewManager' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, InputManagerClass) == 0x0003E8, "Member 'ARHHUDCommon::InputManagerClass' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, bUseRHNavigation) == 0x0003F0, "Member 'ARHHUDCommon::bUseRHNavigation' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, ColorPaletteDT) == 0x000400, "Member 'ARHHUDCommon::ColorPaletteDT' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, FontPaletteDT) == 0x000408, "Member 'ARHHUDCommon::FontPaletteDT' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, SoundTheme) == 0x000410, "Member 'ARHHUDCommon::SoundTheme' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, AcceptPressedAction) == 0x000438, "Member 'ARHHUDCommon::AcceptPressedAction' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, AcceptReleasedAction) == 0x000440, "Member 'ARHHUDCommon::AcceptReleasedAction' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, CancelPressedAction) == 0x000448, "Member 'ARHHUDCommon::CancelPressedAction' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, CancelReleasedAction) == 0x000450, "Member 'ARHHUDCommon::CancelReleasedAction' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, HoldToConfirmAction) == 0x000458, "Member 'ARHHUDCommon::HoldToConfirmAction' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, HoldToCancelAction) == 0x000460, "Member 'ARHHUDCommon::HoldToCancelAction' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, NavigateUpAction) == 0x000468, "Member 'ARHHUDCommon::NavigateUpAction' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, NavigateDownAction) == 0x000470, "Member 'ARHHUDCommon::NavigateDownAction' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, NavigateRightAction) == 0x000478, "Member 'ARHHUDCommon::NavigateRightAction' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, NavigateLeftAction) == 0x000480, "Member 'ARHHUDCommon::NavigateLeftAction' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, HUDMappingContext) == 0x000488, "Member 'ARHHUDCommon::HUDMappingContext' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, MutableMappingContext) == 0x000490, "Member 'ARHHUDCommon::MutableMappingContext' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, QueueDataFactorySoftClass) == 0x0004B0, "Member 'ARHHUDCommon::QueueDataFactorySoftClass' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, PartyManagerSoftClass) == 0x0004D0, "Member 'ARHHUDCommon::PartyManagerSoftClass' has a wrong offset!");
static_assert(offsetof(ARHHUDCommon, QueueDataFactory) == 0x0004F8, "Member 'ARHHUDCommon::QueueDataFactory' has a wrong offset!");

// Class RallyHereStart.RHGameHUD
// 0x0010 (0x0510 - 0x0500)
class ARHGameHUD final : public ARHHUDCommon
{
public:
	TSubclassOf<class URHWidget>                  GameHUDWidgetClass;                                // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHWidget*                              GameHUDWidget;                                     // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnGameHUDWidgetCreated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGameHUD">();
	}
	static class ARHGameHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARHGameHUD>();
	}
};
static_assert(alignof(ARHGameHUD) == 0x000008, "Wrong alignment on ARHGameHUD");
static_assert(sizeof(ARHGameHUD) == 0x000510, "Wrong size on ARHGameHUD");
static_assert(offsetof(ARHGameHUD, GameHUDWidgetClass) == 0x000500, "Member 'ARHGameHUD::GameHUDWidgetClass' has a wrong offset!");
static_assert(offsetof(ARHGameHUD, GameHUDWidget) == 0x000508, "Member 'ARHGameHUD::GameHUDWidget' has a wrong offset!");

// Class RallyHereStart.RHGameInstance
// 0x0160 (0x0328 - 0x01C8)
class URHGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_1C8[0x50];                                     // 0x01C8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLogoffOnAppSuspend;                               // 0x0218(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogoffOnAppResume;                                // 0x0219(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A[0xFE];                                     // 0x021A(0x00FE)(Fixing Size After Last Property [ Dumper-7 ])
	class URHQueueDataFactory*                    QueueDataFactory;                                  // 0x0318(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHPartyManager*                        PartyManager;                                      // 0x0320(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BeginLoadingScreen(const class FString& MapName);
	void EndLoadingScreen(class UWorld* World);
	void SetVoiceMuted(const struct FGuid& PlayerUuid, bool bIsMuted);

	class URHPartyManager* GetPartyManager() const;
	class URHQueueDataFactory* GetQueueDataFactory() const;
	bool IsVoiceMuted(const struct FGuid& PlayerUuid) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGameInstance">();
	}
	static class URHGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHGameInstance>();
	}
};
static_assert(alignof(URHGameInstance) == 0x000008, "Wrong alignment on URHGameInstance");
static_assert(sizeof(URHGameInstance) == 0x000328, "Wrong size on URHGameInstance");
static_assert(offsetof(URHGameInstance, bLogoffOnAppSuspend) == 0x000218, "Member 'URHGameInstance::bLogoffOnAppSuspend' has a wrong offset!");
static_assert(offsetof(URHGameInstance, bLogoffOnAppResume) == 0x000219, "Member 'URHGameInstance::bLogoffOnAppResume' has a wrong offset!");
static_assert(offsetof(URHGameInstance, QueueDataFactory) == 0x000318, "Member 'URHGameInstance::QueueDataFactory' has a wrong offset!");
static_assert(offsetof(URHGameInstance, PartyManager) == 0x000320, "Member 'URHGameInstance::PartyManager' has a wrong offset!");

// Class RallyHereStart.RHGameModeBase
// 0x0108 (0x0488 - 0x0380)
class ARHGameModeBase : public AGameMode
{
public:
	uint8                                         Pad_380[0x60];                                     // 0x0380(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MatchEndReturnToLobbyDelay;                        // 0x03E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchSpindownDelay;                                // 0x03E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SonyActivityId;                                    // 0x03E8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SonyActivityIdNetworkedMatch;                      // 0x03F8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SonyMatchOwnerNetTimeout;                          // 0x0408(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRHSonyMatchData                       SonyMatchData;                                     // 0x0410(0x0040)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FUniqueNetIdRepl>               SonyIneligibleMatchOwners;                         // 0x0450(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRHInactivePlayerStateEntry>    RHInactivePlayerArray;                             // 0x0470(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bGlobalDisableAIBackfill;                          // 0x0480(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowAIBackfill;                                  // 0x0481(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasPerformedInitialAIBackfill;                    // 0x0482(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_483[0x5];                                      // 0x0483(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateMatchCloseness();
	void CheckSonyMatchOwnerNetTimeout();
	void FinalizeMatchEnded();
	void FinalShutdown();
	void InactivePlayerStateDestroyed(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGameModeBase">();
	}
	static class ARHGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARHGameModeBase>();
	}
};
static_assert(alignof(ARHGameModeBase) == 0x000008, "Wrong alignment on ARHGameModeBase");
static_assert(sizeof(ARHGameModeBase) == 0x000488, "Wrong size on ARHGameModeBase");
static_assert(offsetof(ARHGameModeBase, MatchEndReturnToLobbyDelay) == 0x0003E0, "Member 'ARHGameModeBase::MatchEndReturnToLobbyDelay' has a wrong offset!");
static_assert(offsetof(ARHGameModeBase, MatchSpindownDelay) == 0x0003E4, "Member 'ARHGameModeBase::MatchSpindownDelay' has a wrong offset!");
static_assert(offsetof(ARHGameModeBase, SonyActivityId) == 0x0003E8, "Member 'ARHGameModeBase::SonyActivityId' has a wrong offset!");
static_assert(offsetof(ARHGameModeBase, SonyActivityIdNetworkedMatch) == 0x0003F8, "Member 'ARHGameModeBase::SonyActivityIdNetworkedMatch' has a wrong offset!");
static_assert(offsetof(ARHGameModeBase, SonyMatchOwnerNetTimeout) == 0x000408, "Member 'ARHGameModeBase::SonyMatchOwnerNetTimeout' has a wrong offset!");
static_assert(offsetof(ARHGameModeBase, SonyMatchData) == 0x000410, "Member 'ARHGameModeBase::SonyMatchData' has a wrong offset!");
static_assert(offsetof(ARHGameModeBase, SonyIneligibleMatchOwners) == 0x000450, "Member 'ARHGameModeBase::SonyIneligibleMatchOwners' has a wrong offset!");
static_assert(offsetof(ARHGameModeBase, RHInactivePlayerArray) == 0x000470, "Member 'ARHGameModeBase::RHInactivePlayerArray' has a wrong offset!");
static_assert(offsetof(ARHGameModeBase, bGlobalDisableAIBackfill) == 0x000480, "Member 'ARHGameModeBase::bGlobalDisableAIBackfill' has a wrong offset!");
static_assert(offsetof(ARHGameModeBase, bAllowAIBackfill) == 0x000481, "Member 'ARHGameModeBase::bAllowAIBackfill' has a wrong offset!");
static_assert(offsetof(ARHGameModeBase, bHasPerformedInitialAIBackfill) == 0x000482, "Member 'ARHGameModeBase::bHasPerformedInitialAIBackfill' has a wrong offset!");

// Class RallyHereStart.RHGamepadLookSpeedManager
// 0x0008 (0x0030 - 0x0028)
class URHGamepadLookSpeedManager : public UObject
{
public:
	class ARHPlayerController*                    PlayerController;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGamepadLookSpeedManager">();
	}
	static class URHGamepadLookSpeedManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHGamepadLookSpeedManager>();
	}
};
static_assert(alignof(URHGamepadLookSpeedManager) == 0x000008, "Wrong alignment on URHGamepadLookSpeedManager");
static_assert(sizeof(URHGamepadLookSpeedManager) == 0x000030, "Wrong size on URHGamepadLookSpeedManager");
static_assert(offsetof(URHGamepadLookSpeedManager, PlayerController) == 0x000028, "Member 'URHGamepadLookSpeedManager::PlayerController' has a wrong offset!");

// Class RallyHereStart.RHGamepadCurvedLookSpeedManager
// 0x00F0 (0x0120 - 0x0030)
class URHGamepadCurvedLookSpeedManager final : public URHGamepadLookSpeedManager
{
public:
	bool                                          bUseBaseVelocity;                                  // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           LookBaseVelocityCurve;                             // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BoostThreshold;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BoostMultiplier;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoostAcceleration;                                 // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           MouseLookMaxVelocityCurve;                         // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           MouseLookMaxVelocityADSCurve;                      // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BaseLookRateScale;                                 // 0x0078(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnRateMultiplier;                                // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookUpRateMultiplier;                              // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           MouseLookAccelerationCurve;                        // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           MouseLookAccelerationADSCurve;                     // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UCurveVector*>        TestBaseVelocityCurves;                            // 0x00A0(0x0050)(Edit, DisableEditOnInstance, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              LastRotationVelocityScale;                         // 0x00F0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              PrevInput;                                         // 0x0100(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              CurrentTurnSpeed;                                  // 0x0110(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PrintLookSpeedParameters();
	void SetBaseVelocityCurve(class FName TestCurveName);
	void SetBoostAcceleration(float NewAccel);
	void SetBoostMultiplier(float NewBoostX, float NewBoostY);
	void SetOuterDeadZone(float NewZoneX, float NewZoneY);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGamepadCurvedLookSpeedManager">();
	}
	static class URHGamepadCurvedLookSpeedManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHGamepadCurvedLookSpeedManager>();
	}
};
static_assert(alignof(URHGamepadCurvedLookSpeedManager) == 0x000008, "Wrong alignment on URHGamepadCurvedLookSpeedManager");
static_assert(sizeof(URHGamepadCurvedLookSpeedManager) == 0x000120, "Wrong size on URHGamepadCurvedLookSpeedManager");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, bUseBaseVelocity) == 0x000030, "Member 'URHGamepadCurvedLookSpeedManager::bUseBaseVelocity' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, LookBaseVelocityCurve) == 0x000038, "Member 'URHGamepadCurvedLookSpeedManager::LookBaseVelocityCurve' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, BoostThreshold) == 0x000040, "Member 'URHGamepadCurvedLookSpeedManager::BoostThreshold' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, BoostMultiplier) == 0x000050, "Member 'URHGamepadCurvedLookSpeedManager::BoostMultiplier' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, BoostAcceleration) == 0x000060, "Member 'URHGamepadCurvedLookSpeedManager::BoostAcceleration' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, MouseLookMaxVelocityCurve) == 0x000068, "Member 'URHGamepadCurvedLookSpeedManager::MouseLookMaxVelocityCurve' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, MouseLookMaxVelocityADSCurve) == 0x000070, "Member 'URHGamepadCurvedLookSpeedManager::MouseLookMaxVelocityADSCurve' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, BaseLookRateScale) == 0x000078, "Member 'URHGamepadCurvedLookSpeedManager::BaseLookRateScale' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, TurnRateMultiplier) == 0x000088, "Member 'URHGamepadCurvedLookSpeedManager::TurnRateMultiplier' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, LookUpRateMultiplier) == 0x00008C, "Member 'URHGamepadCurvedLookSpeedManager::LookUpRateMultiplier' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, MouseLookAccelerationCurve) == 0x000090, "Member 'URHGamepadCurvedLookSpeedManager::MouseLookAccelerationCurve' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, MouseLookAccelerationADSCurve) == 0x000098, "Member 'URHGamepadCurvedLookSpeedManager::MouseLookAccelerationADSCurve' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, TestBaseVelocityCurves) == 0x0000A0, "Member 'URHGamepadCurvedLookSpeedManager::TestBaseVelocityCurves' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, LastRotationVelocityScale) == 0x0000F0, "Member 'URHGamepadCurvedLookSpeedManager::LastRotationVelocityScale' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, PrevInput) == 0x000100, "Member 'URHGamepadCurvedLookSpeedManager::PrevInput' has a wrong offset!");
static_assert(offsetof(URHGamepadCurvedLookSpeedManager, CurrentTurnSpeed) == 0x000110, "Member 'URHGamepadCurvedLookSpeedManager::CurrentTurnSpeed' has a wrong offset!");

// Class RallyHereStart.RHGamepadPromptWidget
// 0x0010 (0x05C8 - 0x05B8)
class URHGamepadPromptWidget final : public URHWidget
{
public:
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyContext(const struct FButtonPromptContext& Context);
	void ClearAllContext();
	bool PopContext(struct FButtonPromptContext* OutContext);
	void PushContext(const struct FButtonPromptContext& PromptContext);
	void SetContext(const struct FButtonPromptContext& PromptContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGamepadPromptWidget">();
	}
	static class URHGamepadPromptWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHGamepadPromptWidget>();
	}
};
static_assert(alignof(URHGamepadPromptWidget) == 0x000008, "Wrong alignment on URHGamepadPromptWidget");
static_assert(sizeof(URHGamepadPromptWidget) == 0x0005C8, "Wrong size on URHGamepadPromptWidget");

// Class RallyHereStart.RHGameState
// 0x0000 (0x0310 - 0x0310)
class ARHGameState : public AGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGameState">();
	}
	static class ARHGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARHGameState>();
	}
};
static_assert(alignof(ARHGameState) == 0x000008, "Wrong alignment on ARHGameState");
static_assert(sizeof(ARHGameState) == 0x000310, "Wrong size on ARHGameState");

// Class RallyHereStart.RHSettingsSaveGame
// 0x0268 (0x0290 - 0x0028)
class URHSettingsSaveGame : public USaveGame
{
public:
	TMap<class FName, class FString>              SavedSettingsConfig;                               // 0x0028(0x0050)(NativeAccessSpecifierPublic)
	class FString                                 SavedDisplayLanguage;                              // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             SavedLocalActions;                                 // 0x0088(0x0050)(NativeAccessSpecifierPublic)
	class FString                                 SavedSelectedRegion;                               // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastWhatsNewVersion;                               // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRH_LootId>                     SavedTransientOrderIds;                            // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class FName>                             SavedViewedNewsPanelIds;                           // 0x0100(0x0050)(NativeAccessSpecifierPublic)
	TSet<struct FRH_LootId>                       SavedRecentlySeenStoreItemLootIds;                 // 0x0150(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FRH_LootId, int32>                SavedRecentlySeenStoreItemLootAmounts;             // 0x01A0(0x0050)(NativeAccessSpecifierPublic)
	TSet<struct FRH_ItemId>                       SavedSeenAcquiredItemIds;                          // 0x01F0(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FRH_ItemId, int32>                SavedSeenAcquiredItemAmount;                       // 0x0240(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsSaveGame">();
	}
	static class URHSettingsSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsSaveGame>();
	}
};
static_assert(alignof(URHSettingsSaveGame) == 0x000008, "Wrong alignment on URHSettingsSaveGame");
static_assert(sizeof(URHSettingsSaveGame) == 0x000290, "Wrong size on URHSettingsSaveGame");
static_assert(offsetof(URHSettingsSaveGame, SavedSettingsConfig) == 0x000028, "Member 'URHSettingsSaveGame::SavedSettingsConfig' has a wrong offset!");
static_assert(offsetof(URHSettingsSaveGame, SavedDisplayLanguage) == 0x000078, "Member 'URHSettingsSaveGame::SavedDisplayLanguage' has a wrong offset!");
static_assert(offsetof(URHSettingsSaveGame, SavedLocalActions) == 0x000088, "Member 'URHSettingsSaveGame::SavedLocalActions' has a wrong offset!");
static_assert(offsetof(URHSettingsSaveGame, SavedSelectedRegion) == 0x0000D8, "Member 'URHSettingsSaveGame::SavedSelectedRegion' has a wrong offset!");
static_assert(offsetof(URHSettingsSaveGame, LastWhatsNewVersion) == 0x0000E8, "Member 'URHSettingsSaveGame::LastWhatsNewVersion' has a wrong offset!");
static_assert(offsetof(URHSettingsSaveGame, SavedTransientOrderIds) == 0x0000F0, "Member 'URHSettingsSaveGame::SavedTransientOrderIds' has a wrong offset!");
static_assert(offsetof(URHSettingsSaveGame, SavedViewedNewsPanelIds) == 0x000100, "Member 'URHSettingsSaveGame::SavedViewedNewsPanelIds' has a wrong offset!");
static_assert(offsetof(URHSettingsSaveGame, SavedRecentlySeenStoreItemLootIds) == 0x000150, "Member 'URHSettingsSaveGame::SavedRecentlySeenStoreItemLootIds' has a wrong offset!");
static_assert(offsetof(URHSettingsSaveGame, SavedRecentlySeenStoreItemLootAmounts) == 0x0001A0, "Member 'URHSettingsSaveGame::SavedRecentlySeenStoreItemLootAmounts' has a wrong offset!");
static_assert(offsetof(URHSettingsSaveGame, SavedSeenAcquiredItemIds) == 0x0001F0, "Member 'URHSettingsSaveGame::SavedSeenAcquiredItemIds' has a wrong offset!");
static_assert(offsetof(URHSettingsSaveGame, SavedSeenAcquiredItemAmount) == 0x000240, "Member 'URHSettingsSaveGame::SavedSeenAcquiredItemAmount' has a wrong offset!");

// Class RallyHereStart.RHGameUserSettings
// 0x04F8 (0x0640 - 0x0148)
class URHGameUserSettings : public UGameUserSettings
{
public:
	uint8                                         Pad_148[0x468];                                    // 0x0148(0x0468)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnGamepadIconSetSettingsApplied;                   // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName SettingName)> OnLocalSettingSaved;                     // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName SettingName)> OnSettingApplied;                        // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x60];                                     // 0x05E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SaveLocalAction(const class FName& Name_0);

	EColorVisionDeficiency GetColorCorrection() const;
	float GetSafeFrameScale() const;
	bool GetTextChatEnabled() const;
	bool GetVoiceChatEnabled() const;
	bool IsLocalActionSaved(const class FName& Name_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGameUserSettings">();
	}
	static class URHGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHGameUserSettings>();
	}
};
static_assert(alignof(URHGameUserSettings) == 0x000008, "Wrong alignment on URHGameUserSettings");
static_assert(sizeof(URHGameUserSettings) == 0x000640, "Wrong size on URHGameUserSettings");
static_assert(offsetof(URHGameUserSettings, OnGamepadIconSetSettingsApplied) == 0x0005B0, "Member 'URHGameUserSettings::OnGamepadIconSetSettingsApplied' has a wrong offset!");
static_assert(offsetof(URHGameUserSettings, OnLocalSettingSaved) == 0x0005C0, "Member 'URHGameUserSettings::OnLocalSettingSaved' has a wrong offset!");
static_assert(offsetof(URHGameUserSettings, OnSettingApplied) == 0x0005D0, "Member 'URHGameUserSettings::OnSettingApplied' has a wrong offset!");

// Class RallyHereStart.RHGameWidget
// 0x0020 (0x05D8 - 0x05B8)
class URHGameWidget final : public URHWidget
{
public:
	class UDataTable*                             GameViewTable;                                     // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x10];                                     // 0x05C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ScorboardViewTag;                                  // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleScoreboardPressed();

	TArray<class UCanvasPanel*> GetPanelsForViewManager() const;
	TArray<struct FStickyWidgetData> GetStickyWidgetDataForViewManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGameWidget">();
	}
	static class URHGameWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHGameWidget>();
	}
};
static_assert(alignof(URHGameWidget) == 0x000008, "Wrong alignment on URHGameWidget");
static_assert(sizeof(URHGameWidget) == 0x0005D8, "Wrong size on URHGameWidget");
static_assert(offsetof(URHGameWidget, GameViewTable) == 0x0005B8, "Member 'URHGameWidget::GameViewTable' has a wrong offset!");
static_assert(offsetof(URHGameWidget, ScorboardViewTag) == 0x0005D0, "Member 'URHGameWidget::ScorboardViewTag' has a wrong offset!");

// Class RallyHereStart.RHHomeScreenWidget
// 0x0008 (0x05C0 - 0x05B8)
class URHHomeScreenWidget final : public URHWidget
{
public:
	struct FGameplayTag                           NewsViewTag;                                       // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CheckForOnShownEvents();
	void OnCrossplaySettingChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHHomeScreenWidget">();
	}
	static class URHHomeScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHHomeScreenWidget>();
	}
};
static_assert(alignof(URHHomeScreenWidget) == 0x000008, "Wrong alignment on URHHomeScreenWidget");
static_assert(sizeof(URHHomeScreenWidget) == 0x0005C0, "Wrong size on URHHomeScreenWidget");
static_assert(offsetof(URHHomeScreenWidget, NewsViewTag) == 0x0005B8, "Member 'URHHomeScreenWidget::NewsViewTag' has a wrong offset!");

// Class RallyHereStart.RHHUDInterface
// 0x0000 (0x0000 - 0x0000)
class IRHHUDInterface final
{
public:
	void BindEventToWidgetMessages(const TDelegate<void(class FName Message)>& Callback);
	void BroadcastWidgetMessage(class FName Message);
	void CreateGameRuleWidget(const struct FRHWidgetInfoParams& WidgetInfoParams);
	void OnLoadRoute(class FName Route, bool ForceTransition);
	void OnToggleHUD();
	void ReceivedGameModeClass(TSubclassOf<class AGameModeBase> GameModeClass);
	void SetHUDVisible(bool bVisible);
	void SetSafeFrameScale(float SafeFrameScale);

	TScriptInterface<class IRHSettingsCallbackInterface> GetSettingsCallbackInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHHUDInterface">();
	}
	static class IRHHUDInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRHHUDInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRHHUDInterface) == 0x000001, "Wrong alignment on IRHHUDInterface");
static_assert(sizeof(IRHHUDInterface) == 0x000001, "Wrong size on IRHHUDInterface");

// Class RallyHereStart.ContextActionData
// 0x00C8 (0x00F0 - 0x0028)
class UContextActionData final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RowName;                                           // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FormatAdditive;                                    // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FContextAction                         RowData;                                           // 0x0050(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnContextAction;                                   // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool bNext)>                   OnCycleAction;                                     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float fPercentage)>            OnHoldActionUpdate;                                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EContextActionHoldReleaseState Status)> OnHoldReleaseAction;                      // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearTriggerHoldAction();
	void StartTriggerHoldAction();
	void TriggerContextAction();
	void TriggerCycleContextAction(bool bNext);
	void TriggerCycleContextActionNext();
	void TriggerCycleContextActionPrev();
	void TriggerHoldReleaseContextAction(EContextActionHoldReleaseState Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextActionData">();
	}
	static class UContextActionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextActionData>();
	}
};
static_assert(alignof(UContextActionData) == 0x000008, "Wrong alignment on UContextActionData");
static_assert(sizeof(UContextActionData) == 0x0000F0, "Wrong size on UContextActionData");
static_assert(offsetof(UContextActionData, RowName) == 0x000030, "Member 'UContextActionData::RowName' has a wrong offset!");
static_assert(offsetof(UContextActionData, FormatAdditive) == 0x000038, "Member 'UContextActionData::FormatAdditive' has a wrong offset!");
static_assert(offsetof(UContextActionData, RowData) == 0x000050, "Member 'UContextActionData::RowData' has a wrong offset!");
static_assert(offsetof(UContextActionData, OnContextAction) == 0x0000A8, "Member 'UContextActionData::OnContextAction' has a wrong offset!");
static_assert(offsetof(UContextActionData, OnCycleAction) == 0x0000B8, "Member 'UContextActionData::OnCycleAction' has a wrong offset!");
static_assert(offsetof(UContextActionData, OnHoldActionUpdate) == 0x0000C8, "Member 'UContextActionData::OnHoldActionUpdate' has a wrong offset!");
static_assert(offsetof(UContextActionData, OnHoldReleaseAction) == 0x0000D8, "Member 'UContextActionData::OnHoldReleaseAction' has a wrong offset!");

// Class RallyHereStart.RHInputManager
// 0x0170 (0x0198 - 0x0028)
class URHInputManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class URHWidget*, struct FRHInputFocusDetails> InputFocusData;                              // 0x0030(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnhancedInputComponent*                InputComponent;                                    // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x3C];                                      // 0x00B0(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GlobalRouteTag;                                    // 0x00EC(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputMappingContext*                   ContextualMappingContext;                          // 0x00F8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        ContextActionDataTableClassName;                   // 0x0100(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ContextActionDT;                                   // 0x0120(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FRouteContextInfo> RouteContextInfoMap;                         // 0x0128(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ActiveRouteTag;                                    // 0x0178(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PendingRouteTag;                                   // 0x0180(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   OverrideRouteStack;                                // 0x0188(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddContextAction(const struct FGameplayTag& RouteTag, class FName ContextName, const class FText& FormatAdditive);
	void AddContextActions(const struct FGameplayTag& RouteTag, const TArray<class FName>& ContextNames);
	void ClearAllContextActions(const struct FGameplayTag& RouteTag);
	void ClearContextAction(const struct FGameplayTag& RouteTag, class FName ContextName);
	void ClearNavInputDebouncedThrottled();
	void ClearNavInputThrottled();
	void ClearOverrideRouteStack();
	bool GetAllButtonsForInputAction(class UInputAction* Action, TArray<struct FKey>* Buttons);
	bool GetButtonForInputAction(class UInputAction* Action, struct FKey* Button, bool IsGamepadKey);
	bool GetFocusedWidget(class URHWidget* ParentWidget, class UWidget** FocusWidget);
	void HandleModeChange(ERH_INPUT_STATE Mode);
	const struct FGameplayTag PopOverrideRoute();
	void PushOverrideRoute(const struct FGameplayTag& RouteTag);
	bool RemoveOverrideRoute(const struct FGameplayTag& RouteTag);
	void SetActiveRoute(const struct FGameplayTag& RouteTag);
	void SetContextAction(const struct FGameplayTag& RouteTag, class FName ContextName, const TDelegate<void()>& EventCallback);
	void SetContextCycleAction(const struct FGameplayTag& RouteTag, class FName ContextName, const TDelegate<void(bool bNext)>& EventCallback);
	void SetContextHoldReleaseAction(const struct FGameplayTag& RouteTag, class FName ContextName, const TDelegate<void(float fPercentage)>& UpdateCallback, const TDelegate<void(EContextActionHoldReleaseState Status)>& EventCallback);
	void SetInputActions(const TArray<class UContextActionData*>& ActionData);
	void SetPendingRoute(const struct FGameplayTag& RouteTag);

	const struct FGameplayTag GetCurrentContextRoute() const;
	const struct FGameplayTag GetCurrentRoute() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHInputManager">();
	}
	static class URHInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHInputManager>();
	}
};
static_assert(alignof(URHInputManager) == 0x000008, "Wrong alignment on URHInputManager");
static_assert(sizeof(URHInputManager) == 0x000198, "Wrong size on URHInputManager");
static_assert(offsetof(URHInputManager, InputFocusData) == 0x000030, "Member 'URHInputManager::InputFocusData' has a wrong offset!");
static_assert(offsetof(URHInputManager, InputComponent) == 0x0000A8, "Member 'URHInputManager::InputComponent' has a wrong offset!");
static_assert(offsetof(URHInputManager, GlobalRouteTag) == 0x0000EC, "Member 'URHInputManager::GlobalRouteTag' has a wrong offset!");
static_assert(offsetof(URHInputManager, ContextualMappingContext) == 0x0000F8, "Member 'URHInputManager::ContextualMappingContext' has a wrong offset!");
static_assert(offsetof(URHInputManager, ContextActionDataTableClassName) == 0x000100, "Member 'URHInputManager::ContextActionDataTableClassName' has a wrong offset!");
static_assert(offsetof(URHInputManager, ContextActionDT) == 0x000120, "Member 'URHInputManager::ContextActionDT' has a wrong offset!");
static_assert(offsetof(URHInputManager, RouteContextInfoMap) == 0x000128, "Member 'URHInputManager::RouteContextInfoMap' has a wrong offset!");
static_assert(offsetof(URHInputManager, ActiveRouteTag) == 0x000178, "Member 'URHInputManager::ActiveRouteTag' has a wrong offset!");
static_assert(offsetof(URHInputManager, PendingRouteTag) == 0x000180, "Member 'URHInputManager::PendingRouteTag' has a wrong offset!");
static_assert(offsetof(URHInputManager, OverrideRouteStack) == 0x000188, "Member 'URHInputManager::OverrideRouteStack' has a wrong offset!");

// Class RallyHereStart.RHLandingPanelJSONHandler
// 0x0128 (0x0150 - 0x0028)
class URHLandingPanelJSONHandler final : public UObject
{
public:
	TMulticastInlineDelegate<void(class URHLandingPanelJSONHandler* pHandler)> OnJsonReady;          // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHLandingPanelJSONHandler* pHandler)> OnImagesDownloaded;   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0xB8];                                      // 0x0048(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UTexture2DDynamic*> mapFilePathToTexture;                              // 0x0100(0x0050)(NativeAccessSpecifierPrivate)

public:
	void RequestNewJson();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLandingPanelJSONHandler">();
	}
	static class URHLandingPanelJSONHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLandingPanelJSONHandler>();
	}
};
static_assert(alignof(URHLandingPanelJSONHandler) == 0x000008, "Wrong alignment on URHLandingPanelJSONHandler");
static_assert(sizeof(URHLandingPanelJSONHandler) == 0x000150, "Wrong size on URHLandingPanelJSONHandler");
static_assert(offsetof(URHLandingPanelJSONHandler, OnJsonReady) == 0x000028, "Member 'URHLandingPanelJSONHandler::OnJsonReady' has a wrong offset!");
static_assert(offsetof(URHLandingPanelJSONHandler, OnImagesDownloaded) == 0x000038, "Member 'URHLandingPanelJSONHandler::OnImagesDownloaded' has a wrong offset!");
static_assert(offsetof(URHLandingPanelJSONHandler, mapFilePathToTexture) == 0x000100, "Member 'URHLandingPanelJSONHandler::mapFilePathToTexture' has a wrong offset!");

// Class RallyHereStart.RH_PlayerLoadoutItem
// 0x0040 (0x0068 - 0x0028)
class URH_PlayerLoadoutItem final : public UObject
{
public:
	class FString                                 LoadoutItemId;                                     // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             ItemId;                                            // 0x0038(0x0014)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemValueId;                                       // 0x0054(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CreationDate;                                      // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastModifiedTimestamp;                             // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetCount(int32 InCount);
	void SetCreationDate(const struct FDateTime& InCreationDate);
	void SetItemId(const struct FRH_ItemId& InItemId);
	void SetItemValueId(int32 InItemValueId);
	void SetLastModifiedTime(const struct FDateTime& InLastModifiedTime);
	void SetLoadoutItemId(const class FString& InLoadoutItemId);
	void SetSortOrder(int32 InSortOrder);

	int32 GetCount() const;
	struct FDateTime GetCreationDate() const;
	const struct FRH_ItemId GetItemId() const;
	int32 GetItemValueId() const;
	struct FDateTime GetLastModifiedTime() const;
	class FString GetLoadoutItemId() const;
	int32 GetSortOrder() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_PlayerLoadoutItem">();
	}
	static class URH_PlayerLoadoutItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_PlayerLoadoutItem>();
	}
};
static_assert(alignof(URH_PlayerLoadoutItem) == 0x000008, "Wrong alignment on URH_PlayerLoadoutItem");
static_assert(sizeof(URH_PlayerLoadoutItem) == 0x000068, "Wrong size on URH_PlayerLoadoutItem");
static_assert(offsetof(URH_PlayerLoadoutItem, LoadoutItemId) == 0x000028, "Member 'URH_PlayerLoadoutItem::LoadoutItemId' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadoutItem, ItemId) == 0x000038, "Member 'URH_PlayerLoadoutItem::ItemId' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadoutItem, Count) == 0x00004C, "Member 'URH_PlayerLoadoutItem::Count' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadoutItem, SortOrder) == 0x000050, "Member 'URH_PlayerLoadoutItem::SortOrder' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadoutItem, ItemValueId) == 0x000054, "Member 'URH_PlayerLoadoutItem::ItemValueId' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadoutItem, CreationDate) == 0x000058, "Member 'URH_PlayerLoadoutItem::CreationDate' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadoutItem, LastModifiedTimestamp) == 0x000060, "Member 'URH_PlayerLoadoutItem::LastModifiedTimestamp' has a wrong offset!");

// Class RallyHereStart.RH_PlayerLoadout
// 0x0188 (0x01B0 - 0x0028)
class URH_PlayerLoadout final : public UObject
{
public:
	uint8                                         Pad_28[0xE8];                                      // 0x0028(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LoadoutId;                                         // 0x0110(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         V;                                                 // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TypeValueId;                                       // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_0;                                            // 0x0130(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CreationDate;                                      // 0x0140(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastModifiedTimestamp;                             // 0x0148(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URH_PlayerLoadoutItem*>          Items;                                             // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ERHLoadoutSlotTypes, class UPlatformInventoryItem*> DefaultItems;                           // 0x0160(0x0050)(NativeAccessSpecifierPublic)

public:
	bool GetEquippedItemInSlot(TDelegate<void(const struct FRHEquippedLoadoutItemWrapper& ItemWrapper)> Event, ERHLoadoutSlotTypes LoadoutSlot);
	bool IsItemEquippedInSlot(class UPlatformInventoryItem* Item, ERHLoadoutSlotTypes LoadoutSlot);
	bool LocalEquipItemToSlot(class UPlatformInventoryItem* Item, ERHLoadoutSlotTypes LoadoutSlot);

	struct FDateTime GetCreationDate() const;
	TMap<ERHLoadoutSlotTypes, class UPlatformInventoryItem*> GetDefaultItems() const;
	TArray<class URH_PlayerLoadoutItem*> GetItems() const;
	struct FDateTime GetLastModifiedTime() const;
	class FString GetLoadoutId() const;
	class FString GetName() const;
	int32 GetSortOrder() const;
	int32 GetType() const;
	int32 GetV() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_PlayerLoadout">();
	}
	static class URH_PlayerLoadout* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_PlayerLoadout>();
	}
};
static_assert(alignof(URH_PlayerLoadout) == 0x000008, "Wrong alignment on URH_PlayerLoadout");
static_assert(sizeof(URH_PlayerLoadout) == 0x0001B0, "Wrong size on URH_PlayerLoadout");
static_assert(offsetof(URH_PlayerLoadout, LoadoutId) == 0x000110, "Member 'URH_PlayerLoadout::LoadoutId' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadout, V) == 0x000120, "Member 'URH_PlayerLoadout::V' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadout, TypeValueId) == 0x000124, "Member 'URH_PlayerLoadout::TypeValueId' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadout, SortOrder) == 0x000128, "Member 'URH_PlayerLoadout::SortOrder' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadout, Name_0) == 0x000130, "Member 'URH_PlayerLoadout::Name_0' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadout, CreationDate) == 0x000140, "Member 'URH_PlayerLoadout::CreationDate' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadout, LastModifiedTimestamp) == 0x000148, "Member 'URH_PlayerLoadout::LastModifiedTimestamp' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadout, Items) == 0x000150, "Member 'URH_PlayerLoadout::Items' has a wrong offset!");
static_assert(offsetof(URH_PlayerLoadout, DefaultItems) == 0x000160, "Member 'URH_PlayerLoadout::DefaultItems' has a wrong offset!");

// Class RallyHereStart.RHLoadoutSubsystem
// 0x0128 (0x0158 - 0x0030)
class URHLoadoutSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerLoadout*>& Loadouts)> OnPlayerLoadoutsUpdated; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AccountDefaultLoadoutsDataTableClassName;          // 0x0040(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             AccountDefaultsDT;                                 // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class URH_PlayerInfo*, struct FRHPlayerLoadoutsWrapper> PlayerLoadouts;                     // 0x0068(0x0050)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<ERHLoadoutSlotTypes, class UPlatformInventoryItem*> DefaultLoadoutItems;                    // 0x00B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x50];                                     // 0x0108(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BLUEPRINT_RequestPlayerLoadoutSettingByLoadoutType(class URH_PlayerInfo* PlayerInfo, ERHLoadoutTypes LoadoutType, bool bCreateIfNeeded, const struct FTimespan& StaleThreshold, bool bForceRefresh, const TDelegate<void(class URH_PlayerInfo* PlayerInfo, class URH_PlayerLoadout* Loadout)>& Delegate);
	void BLUEPRINT_RequestPlayerLoadoutSettings(class URH_PlayerInfo* PlayerInfo, const struct FTimespan& StaleThreshold, bool bForceRefresh, const TDelegate<void(class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerLoadout*>& Loadouts)>& Delegate);
	void BLUEPRINT_SetPlayerLoadoutSettings(class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerLoadout*>& Loadouts, const TDelegate<void(class URH_PlayerInfo* PlayerInfo, bool bSuccess)>& Delegate);
	class UPlatformInventoryItem* GetDefaultItemForLoadoutSlotType(const ERHLoadoutSlotTypes SlotType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLoadoutSubsystem">();
	}
	static class URHLoadoutSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLoadoutSubsystem>();
	}
};
static_assert(alignof(URHLoadoutSubsystem) == 0x000008, "Wrong alignment on URHLoadoutSubsystem");
static_assert(sizeof(URHLoadoutSubsystem) == 0x000158, "Wrong size on URHLoadoutSubsystem");
static_assert(offsetof(URHLoadoutSubsystem, OnPlayerLoadoutsUpdated) == 0x000030, "Member 'URHLoadoutSubsystem::OnPlayerLoadoutsUpdated' has a wrong offset!");
static_assert(offsetof(URHLoadoutSubsystem, AccountDefaultLoadoutsDataTableClassName) == 0x000040, "Member 'URHLoadoutSubsystem::AccountDefaultLoadoutsDataTableClassName' has a wrong offset!");
static_assert(offsetof(URHLoadoutSubsystem, AccountDefaultsDT) == 0x000060, "Member 'URHLoadoutSubsystem::AccountDefaultsDT' has a wrong offset!");
static_assert(offsetof(URHLoadoutSubsystem, PlayerLoadouts) == 0x000068, "Member 'URHLoadoutSubsystem::PlayerLoadouts' has a wrong offset!");
static_assert(offsetof(URHLoadoutSubsystem, DefaultLoadoutItems) == 0x0000B8, "Member 'URHLoadoutSubsystem::DefaultLoadoutItems' has a wrong offset!");

// Class RallyHereStart.RHLobbyHUD
// 0x0040 (0x0540 - 0x0500)
class ARHLobbyHUD : public ARHHUDCommon
{
public:
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnMinuteTimerUpdate;                               // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_518[0x10];                                     // 0x0518(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_PlayerInfo*                         LoggedInPlayerInfo;                                // 0x0528(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(bool ShowBlocker, class UUserWidget* WidgetToBind)> OnTriggerBlockerChange; // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ForceEulaAccept();
	void ForceMinuteTimerUpdate();
	class UPlatformInventoryItem* GetDefaultPlayerAccountItem(ERHLoadoutSlotTypes ItemSlot);
	class URHWidget* GetLobbyWidget();
	void HandleAcceptPartyInvitation();
	void HandleDenyPartyInvitation();
	void OnNotEnoughCurrency(class URHStorePurchaseRequest* PurchaseRequest);
	void OnSteamOverlayDisabled();
	void ShowPopupConfirmation(const class FText& Message, ESocialMessageType MessageType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLobbyHUD">();
	}
	static class ARHLobbyHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARHLobbyHUD>();
	}
};
static_assert(alignof(ARHLobbyHUD) == 0x000008, "Wrong alignment on ARHLobbyHUD");
static_assert(sizeof(ARHLobbyHUD) == 0x000540, "Wrong size on ARHLobbyHUD");
static_assert(offsetof(ARHLobbyHUD, OnMinuteTimerUpdate) == 0x000508, "Member 'ARHLobbyHUD::OnMinuteTimerUpdate' has a wrong offset!");
static_assert(offsetof(ARHLobbyHUD, LoggedInPlayerInfo) == 0x000528, "Member 'ARHLobbyHUD::LoggedInPlayerInfo' has a wrong offset!");
static_assert(offsetof(ARHLobbyHUD, OnTriggerBlockerChange) == 0x000530, "Member 'ARHLobbyHUD::OnTriggerBlockerChange' has a wrong offset!");

// Class RallyHereStart.RHLobbyWidget
// 0x0000 (0x05B8 - 0x05B8)
class URHLobbyWidget final : public URHWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLobbyWidget">();
	}
	static class URHLobbyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLobbyWidget>();
	}
};
static_assert(alignof(URHLobbyWidget) == 0x000008, "Wrong alignment on URHLobbyWidget");
static_assert(sizeof(URHLobbyWidget) == 0x0005B8, "Wrong size on URHLobbyWidget");

// Class RallyHereStart.RHLocalDataSubsystem
// 0x00A8 (0x00D8 - 0x0030)
class URHLocalDataSubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_30[0x78];                                      // 0x0030(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNeedsToShowNewsPanel;                             // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ShownNewsPanelIds;                                 // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bNeedsToRedeemVoucher;                             // 0x00C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasPlatformAchievements;                          // 0x00C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasPlatformAchievementDescriptions;               // 0x00C2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAchievementIntegrationEnabled;                    // 0x00C3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasFullPlayerInventory;                           // 0x00C4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LoggedInTime;                                      // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RewardRedemptionVendorId;                          // 0x00D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLocalDataSubsystem">();
	}
	static class URHLocalDataSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLocalDataSubsystem>();
	}
};
static_assert(alignof(URHLocalDataSubsystem) == 0x000008, "Wrong alignment on URHLocalDataSubsystem");
static_assert(sizeof(URHLocalDataSubsystem) == 0x0000D8, "Wrong size on URHLocalDataSubsystem");
static_assert(offsetof(URHLocalDataSubsystem, bNeedsToShowNewsPanel) == 0x0000A8, "Member 'URHLocalDataSubsystem::bNeedsToShowNewsPanel' has a wrong offset!");
static_assert(offsetof(URHLocalDataSubsystem, ShownNewsPanelIds) == 0x0000B0, "Member 'URHLocalDataSubsystem::ShownNewsPanelIds' has a wrong offset!");
static_assert(offsetof(URHLocalDataSubsystem, bNeedsToRedeemVoucher) == 0x0000C0, "Member 'URHLocalDataSubsystem::bNeedsToRedeemVoucher' has a wrong offset!");
static_assert(offsetof(URHLocalDataSubsystem, bHasPlatformAchievements) == 0x0000C1, "Member 'URHLocalDataSubsystem::bHasPlatformAchievements' has a wrong offset!");
static_assert(offsetof(URHLocalDataSubsystem, bHasPlatformAchievementDescriptions) == 0x0000C2, "Member 'URHLocalDataSubsystem::bHasPlatformAchievementDescriptions' has a wrong offset!");
static_assert(offsetof(URHLocalDataSubsystem, bAchievementIntegrationEnabled) == 0x0000C3, "Member 'URHLocalDataSubsystem::bAchievementIntegrationEnabled' has a wrong offset!");
static_assert(offsetof(URHLocalDataSubsystem, bHasFullPlayerInventory) == 0x0000C4, "Member 'URHLocalDataSubsystem::bHasFullPlayerInventory' has a wrong offset!");
static_assert(offsetof(URHLocalDataSubsystem, LoggedInTime) == 0x0000C8, "Member 'URHLocalDataSubsystem::LoggedInTime' has a wrong offset!");
static_assert(offsetof(URHLocalDataSubsystem, RewardRedemptionVendorId) == 0x0000D0, "Member 'URHLocalDataSubsystem::RewardRedemptionVendorId' has a wrong offset!");

// Class RallyHereStart.RHLoginDataFactory
// 0x0130 (0x0168 - 0x0038)
class URHLoginDataFactory final : public URHDataFactory
{
public:
	TMulticastInlineDelegate<void(ERHLoginState LoginState)> OnLoginStateChanged;                    // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText MessageText)> OnLoginError;                            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnControllerDisconnected;                          // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowLoginDuringPartialInstall;                   // 0x0080(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ErrorMsgsDT;                                       // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnLoginsLimitedChanged;                            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x70];                                      // 0x00A0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SavedCredentialPrefix;                             // 0x0110(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x38];                                     // 0x0120(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FLoginQueueInfo& LoginQueueInfo)> OnLoginWaitQueueMessage; // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static bool LoadEULAFile(class FString* SaveText);

	ERHLoginState GetCurrentLoginState();
	bool GetCurrentPlayerName(class FText* NameText);
	bool GetLastDisconnectReason(class FText* ErrorMsg);
	void HandleControllerConnectionChange(EInputDeviceConnectionState NewConnectionState, const struct FPlatformUserId& PlatformUserId, const struct FInputDeviceId& InputDeviceId);
	void HandleControllerPairingChange(const struct FInputDeviceId& InputDeviceId, const struct FPlatformUserId& NewUserPlatformId, const struct FPlatformUserId& OldUserPlatformId);
	void HandlePlayerLoggedOut(bool bSuccess);
	void HandlePlayerLoginOrTokenRefreshFailed();
	void LoginEvent_EACCompleted();
	void LoginEvent_EACFailed(const class FText& ErrorMsg);
	void LoginEvent_EACRequested();
	void LoginEvent_FailedClient(const class FText& ErrorMsg);
	void LoginEvent_FailedWithRestrictions(const TArray<struct FRHAPI_Restriction>& Restrictions);
	void LoginEvent_LoggedIn();
	void LoginEvent_LoginRequested();
	void LoginEvent_Queued(uint32 QueuePosition, uint32 QueueSize, uint32 queueEstimatedWait);
	void LoginEvent_ShowAgreements(bool bNeedsEULA, bool bNeedsTOS, bool bNeedsPP);
	void OnMcAfeeErrorDetected();
	void RecordLoginState(ERHLoginState NewState);
	void TriggerAutoLogin();
	void UIX_OnCancelLogin();
	void UIX_OnChangeUserAccount();
	void UIX_OnEulaAccept();
	void UIX_OnEulaDecline();
	void UIX_OnLinkDecline();
	void UIX_OnLinkExistingAccount(const class FString& UserName, const class FString& Password);
	void UIX_OnSignInWithApple(const struct FPlatformUserId& PlatformId);
	void UIX_OnSignInWithGoogle(const struct FPlatformUserId& PlatformId);
	void UIX_OnSubmitAutoLogin(const struct FPlatformUserId& PlatformId);
	void UIX_OnSubmitLogin(const class FString& UserName, const class FString& Password);
	void UIX_TriggerAutoLogin();

	bool AllowUserSwitching() const;
	bool AreLoginsLimited() const;
	bool GetCurrentPlayerId(class FText* ID) const;
	class URH_ConfigSubsystem* GetRH_ConfigSubsystem() const;
	class URH_LocalPlayerLoginSubsystem* GetRH_LocalPlayerLoginSubsystem() const;
	class URH_LocalPlayerSubsystem* GetRH_LocalPlayerSubsystem() const;
	bool ShouldDisplayDisconnectError() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLoginDataFactory">();
	}
	static class URHLoginDataFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLoginDataFactory>();
	}
};
static_assert(alignof(URHLoginDataFactory) == 0x000008, "Wrong alignment on URHLoginDataFactory");
static_assert(sizeof(URHLoginDataFactory) == 0x000168, "Wrong size on URHLoginDataFactory");
static_assert(offsetof(URHLoginDataFactory, OnLoginStateChanged) == 0x000038, "Member 'URHLoginDataFactory::OnLoginStateChanged' has a wrong offset!");
static_assert(offsetof(URHLoginDataFactory, OnLoginError) == 0x000048, "Member 'URHLoginDataFactory::OnLoginError' has a wrong offset!");
static_assert(offsetof(URHLoginDataFactory, OnControllerDisconnected) == 0x000060, "Member 'URHLoginDataFactory::OnControllerDisconnected' has a wrong offset!");
static_assert(offsetof(URHLoginDataFactory, bAllowLoginDuringPartialInstall) == 0x000080, "Member 'URHLoginDataFactory::bAllowLoginDuringPartialInstall' has a wrong offset!");
static_assert(offsetof(URHLoginDataFactory, ErrorMsgsDT) == 0x000088, "Member 'URHLoginDataFactory::ErrorMsgsDT' has a wrong offset!");
static_assert(offsetof(URHLoginDataFactory, OnLoginsLimitedChanged) == 0x000090, "Member 'URHLoginDataFactory::OnLoginsLimitedChanged' has a wrong offset!");
static_assert(offsetof(URHLoginDataFactory, SavedCredentialPrefix) == 0x000110, "Member 'URHLoginDataFactory::SavedCredentialPrefix' has a wrong offset!");
static_assert(offsetof(URHLoginDataFactory, OnLoginWaitQueueMessage) == 0x000158, "Member 'URHLoginDataFactory::OnLoginWaitQueueMessage' has a wrong offset!");

// Class RallyHereStart.RHViewRedirecter
// 0x0000 (0x0028 - 0x0028)
class URHViewRedirecter : public UObject
{
public:
	bool ShouldRedirect(class ARHHUDCommon* HUD, const struct FGameplayTag& RouteTag, class UObject** SceneData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHViewRedirecter">();
	}
	static class URHViewRedirecter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHViewRedirecter>();
	}
};
static_assert(alignof(URHViewRedirecter) == 0x000008, "Wrong alignment on URHViewRedirecter");
static_assert(sizeof(URHViewRedirecter) == 0x000028, "Wrong size on URHViewRedirecter");

// Class RallyHereStart.RHRedirectToLoginViewRedirector
// 0x0000 (0x0028 - 0x0028)
class URHRedirectToLoginViewRedirector final : public URHViewRedirecter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHRedirectToLoginViewRedirector">();
	}
	static class URHRedirectToLoginViewRedirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHRedirectToLoginViewRedirector>();
	}
};
static_assert(alignof(URHRedirectToLoginViewRedirector) == 0x000008, "Wrong alignment on URHRedirectToLoginViewRedirector");
static_assert(sizeof(URHRedirectToLoginViewRedirector) == 0x000028, "Wrong size on URHRedirectToLoginViewRedirector");

// Class RallyHereStart.RHWhatsNewModal
// 0x0018 (0x05D0 - 0x05B8)
class URHWhatsNewModal final : public URHWidget
{
public:
	int32                                         maxPanelCount;                                     // 0x05B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URHWhatsNewPanel*>               StoredPanels;                                      // 0x05C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void BLUEPRINT_GetPanelDataAsync(const TDelegate<void(const TArray<class URHWhatsNewPanel*>& PanelData)>& Delegate);
	class URHNewsSubsystem* GetNewsSubsystem();
	void OnJsonChanged();
	void UpdateWhatsNewPanels(const class FString& JsonName);

	int32 GetMaxPanelCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHWhatsNewModal">();
	}
	static class URHWhatsNewModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHWhatsNewModal>();
	}
};
static_assert(alignof(URHWhatsNewModal) == 0x000008, "Wrong alignment on URHWhatsNewModal");
static_assert(sizeof(URHWhatsNewModal) == 0x0005D0, "Wrong size on URHWhatsNewModal");
static_assert(offsetof(URHWhatsNewModal, maxPanelCount) == 0x0005B8, "Member 'URHWhatsNewModal::maxPanelCount' has a wrong offset!");
static_assert(offsetof(URHWhatsNewModal, StoredPanels) == 0x0005C0, "Member 'URHWhatsNewModal::StoredPanels' has a wrong offset!");

// Class RallyHereStart.RHLoginExistingBase
// 0x0018 (0x05D0 - 0x05B8)
class URHLoginExistingBase : public URHWidget
{
public:
	class UInputMappingContext*                   LoginOverride;                                     // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           LoginOverrideAction;                               // 0x05C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoginOverrideTriggered();

	bool ShouldBlockLogin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLoginExistingBase">();
	}
	static class URHLoginExistingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLoginExistingBase>();
	}
};
static_assert(alignof(URHLoginExistingBase) == 0x000008, "Wrong alignment on URHLoginExistingBase");
static_assert(sizeof(URHLoginExistingBase) == 0x0005D0, "Wrong size on URHLoginExistingBase");
static_assert(offsetof(URHLoginExistingBase, LoginOverride) == 0x0005B8, "Member 'URHLoginExistingBase::LoginOverride' has a wrong offset!");
static_assert(offsetof(URHLoginExistingBase, LoginOverrideAction) == 0x0005C0, "Member 'URHLoginExistingBase::LoginOverrideAction' has a wrong offset!");

// Class RallyHereStart.RHLoginInventoryCheckViewRedirector
// 0x0000 (0x0028 - 0x0028)
class URHLoginInventoryCheckViewRedirector final : public URHViewRedirecter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLoginInventoryCheckViewRedirector">();
	}
	static class URHLoginInventoryCheckViewRedirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLoginInventoryCheckViewRedirector>();
	}
};
static_assert(alignof(URHLoginInventoryCheckViewRedirector) == 0x000008, "Wrong alignment on URHLoginInventoryCheckViewRedirector");
static_assert(sizeof(URHLoginInventoryCheckViewRedirector) == 0x000028, "Wrong size on URHLoginInventoryCheckViewRedirector");

// Class RallyHereStart.RHLoginInventoryCheck
// 0x0008 (0x05C0 - 0x05B8)
class URHLoginInventoryCheck : public URHWidget
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelLogin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLoginInventoryCheck">();
	}
	static class URHLoginInventoryCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLoginInventoryCheck>();
	}
};
static_assert(alignof(URHLoginInventoryCheck) == 0x000008, "Wrong alignment on URHLoginInventoryCheck");
static_assert(sizeof(URHLoginInventoryCheck) == 0x0005C0, "Wrong size on URHLoginInventoryCheck");

// Class RallyHereStart.RHLootBox
// 0x0008 (0x0180 - 0x0178)
class URHLootBox final : public UPlatformInventoryItem
{
public:
	int32                                         LootBoxVendorId;                                   // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLootBox">();
	}
	static class URHLootBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLootBox>();
	}
};
static_assert(alignof(URHLootBox) == 0x000008, "Wrong alignment on URHLootBox");
static_assert(sizeof(URHLootBox) == 0x000180, "Wrong size on URHLootBox");
static_assert(offsetof(URHLootBox, LootBoxVendorId) == 0x000178, "Member 'URHLootBox::LootBoxVendorId' has a wrong offset!");

// Class RallyHereStart.RHLootBoxDetails
// 0x0018 (0x0040 - 0x0028)
class URHLootBoxDetails final : public UObject
{
public:
	class URHStoreItem*                           LootBox;                                           // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URHLootBoxContents*>             Contents;                                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLootBoxDetails">();
	}
	static class URHLootBoxDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLootBoxDetails>();
	}
};
static_assert(alignof(URHLootBoxDetails) == 0x000008, "Wrong alignment on URHLootBoxDetails");
static_assert(sizeof(URHLootBoxDetails) == 0x000040, "Wrong size on URHLootBoxDetails");
static_assert(offsetof(URHLootBoxDetails, LootBox) == 0x000028, "Member 'URHLootBoxDetails::LootBox' has a wrong offset!");
static_assert(offsetof(URHLootBoxDetails, Contents) == 0x000030, "Member 'URHLootBoxDetails::Contents' has a wrong offset!");

// Class RallyHereStart.RHLootBoxContents
// 0x0068 (0x0090 - 0x0028)
class URHLootBoxContents final : public UObject
{
public:
	int32                                         LootTableId;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class URHStoreItem>>    BundleContents;                                    // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FText> GetContentsFilterOptions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLootBoxContents">();
	}
	static class URHLootBoxContents* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLootBoxContents>();
	}
};
static_assert(alignof(URHLootBoxContents) == 0x000008, "Wrong alignment on URHLootBoxContents");
static_assert(sizeof(URHLootBoxContents) == 0x000090, "Wrong size on URHLootBoxContents");
static_assert(offsetof(URHLootBoxContents, LootTableId) == 0x000028, "Member 'URHLootBoxContents::LootTableId' has a wrong offset!");
static_assert(offsetof(URHLootBoxContents, BundleContents) == 0x000030, "Member 'URHLootBoxContents::BundleContents' has a wrong offset!");

// Class RallyHereStart.RHLootBoxSubsystem
// 0x00E8 (0x0118 - 0x0030)
class URHLootBoxSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnLootBoxOpenStarted;                              // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLootBoxOpenFailed;                               // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<class UPlatformInventoryItem*>& AcquiredItems)> OnLootBoxContentsReceived; // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHLootBox* LootBox)> OnDisplayLootBoxIntro;                 // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHLootBox* LootBox)> OnDisplayLootBoxIntroAndOpen;          // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLootBoxLeave;                                    // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLootBoxOpenSequenceCompleted;                    // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FRH_LootId>                     LootBoxLootIds;                                    // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class URHStoreSubsystem*                      StoreSubsystem;                                    // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FRH_LootId, class URHLootBoxDetails*> UnopenedLootBoxIdToContents;                   // 0x00C0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         LootBoxsVendorId;                                  // 0x0110(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LootBoxsRedemptionVendorId;                        // 0x0114(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class FText GetContentCategoryName(ELootBoxContentsCategories Category);

	void CallOnLootBoxOpeningSequenceComplete();
	void OnStoreVendorsLoaded(bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHLootBoxSubsystem">();
	}
	static class URHLootBoxSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHLootBoxSubsystem>();
	}
};
static_assert(alignof(URHLootBoxSubsystem) == 0x000008, "Wrong alignment on URHLootBoxSubsystem");
static_assert(sizeof(URHLootBoxSubsystem) == 0x000118, "Wrong size on URHLootBoxSubsystem");
static_assert(offsetof(URHLootBoxSubsystem, OnLootBoxOpenStarted) == 0x000030, "Member 'URHLootBoxSubsystem::OnLootBoxOpenStarted' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, OnLootBoxOpenFailed) == 0x000040, "Member 'URHLootBoxSubsystem::OnLootBoxOpenFailed' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, OnLootBoxContentsReceived) == 0x000050, "Member 'URHLootBoxSubsystem::OnLootBoxContentsReceived' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, OnDisplayLootBoxIntro) == 0x000060, "Member 'URHLootBoxSubsystem::OnDisplayLootBoxIntro' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, OnDisplayLootBoxIntroAndOpen) == 0x000070, "Member 'URHLootBoxSubsystem::OnDisplayLootBoxIntroAndOpen' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, OnLootBoxLeave) == 0x000080, "Member 'URHLootBoxSubsystem::OnLootBoxLeave' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, OnLootBoxOpenSequenceCompleted) == 0x000090, "Member 'URHLootBoxSubsystem::OnLootBoxOpenSequenceCompleted' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, LootBoxLootIds) == 0x0000A0, "Member 'URHLootBoxSubsystem::LootBoxLootIds' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, StoreSubsystem) == 0x0000B0, "Member 'URHLootBoxSubsystem::StoreSubsystem' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, UnopenedLootBoxIdToContents) == 0x0000C0, "Member 'URHLootBoxSubsystem::UnopenedLootBoxIdToContents' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, LootBoxsVendorId) == 0x000110, "Member 'URHLootBoxSubsystem::LootBoxsVendorId' has a wrong offset!");
static_assert(offsetof(URHLootBoxSubsystem, LootBoxsRedemptionVendorId) == 0x000114, "Member 'URHLootBoxSubsystem::LootBoxsRedemptionVendorId' has a wrong offset!");

// Class RallyHereStart.RHMapButton
// 0x0018 (0x05D0 - 0x05B8)
class URHMapButton : public URHWidget
{
public:
	TMulticastInlineDelegate<void(class FName MapName)> OnMapButtonClicked;                          // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   MapName;                                           // 0x05C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnButtonClicked();
	void SetMap(class FName InMapName);
	void SetSelected(bool bSelected);

	bool GetMapDetails(struct FRHMapDetails* OutMapDetails) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHMapButton">();
	}
	static class URHMapButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHMapButton>();
	}
};
static_assert(alignof(URHMapButton) == 0x000008, "Wrong alignment on URHMapButton");
static_assert(sizeof(URHMapButton) == 0x0005D0, "Wrong size on URHMapButton");
static_assert(offsetof(URHMapButton, OnMapButtonClicked) == 0x0005B8, "Member 'URHMapButton::OnMapButtonClicked' has a wrong offset!");
static_assert(offsetof(URHMapButton, MapName) == 0x0005C8, "Member 'URHMapButton::MapName' has a wrong offset!");

// Class RallyHereStart.RHDataMassInviteBase
// 0x0050 (0x0078 - 0x0028)
class URHDataMassInviteBase : public UObject
{
public:
	class FText                                   Title;                                             // 0x0028(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   ButtonLabel;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TDelegate<void(class URH_RHFriendAndPlatformFriend* PlayerAndPlatformInfo)> OnShouldShow;        // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnClose;                                           // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHDataMassInviteBase">();
	}
	static class URHDataMassInviteBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHDataMassInviteBase>();
	}
};
static_assert(alignof(URHDataMassInviteBase) == 0x000008, "Wrong alignment on URHDataMassInviteBase");
static_assert(sizeof(URHDataMassInviteBase) == 0x000078, "Wrong size on URHDataMassInviteBase");
static_assert(offsetof(URHDataMassInviteBase, Title) == 0x000028, "Member 'URHDataMassInviteBase::Title' has a wrong offset!");
static_assert(offsetof(URHDataMassInviteBase, ButtonLabel) == 0x000040, "Member 'URHDataMassInviteBase::ButtonLabel' has a wrong offset!");
static_assert(offsetof(URHDataMassInviteBase, OnShouldShow) == 0x000058, "Member 'URHDataMassInviteBase::OnShouldShow' has a wrong offset!");
static_assert(offsetof(URHDataMassInviteBase, OnClose) == 0x000068, "Member 'URHDataMassInviteBase::OnClose' has a wrong offset!");

// Class RallyHereStart.RHDataIndividualInviteSetup
// 0x0020 (0x0098 - 0x0078)
class URHDataIndividualInviteSetup final : public URHDataMassInviteBase
{
public:
	TDelegate<void(class URH_RHFriendAndPlatformFriend* PlayerInfo)> OnGetIsSelected;                // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class URH_RHFriendAndPlatformFriend* PlayerInfo)> OnSelect;                       // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class URHDataIndividualInviteSetup* SetCallbacks(TDelegate<void(class URH_RHFriendAndPlatformFriend* PlayerInfo)> GetIsSelected, TDelegate<void(class URH_RHFriendAndPlatformFriend* PlayerInfo)> Select, TDelegate<void(class URH_RHFriendAndPlatformFriend* PlayerAndPlatformInfo)> ShouldShowPlayer, TDelegate<void()> Close);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHDataIndividualInviteSetup">();
	}
	static class URHDataIndividualInviteSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHDataIndividualInviteSetup>();
	}
};
static_assert(alignof(URHDataIndividualInviteSetup) == 0x000008, "Wrong alignment on URHDataIndividualInviteSetup");
static_assert(sizeof(URHDataIndividualInviteSetup) == 0x000098, "Wrong size on URHDataIndividualInviteSetup");
static_assert(offsetof(URHDataIndividualInviteSetup, OnGetIsSelected) == 0x000078, "Member 'URHDataIndividualInviteSetup::OnGetIsSelected' has a wrong offset!");
static_assert(offsetof(URHDataIndividualInviteSetup, OnSelect) == 0x000088, "Member 'URHDataIndividualInviteSetup::OnSelect' has a wrong offset!");

// Class RallyHereStart.RHDataBatchInviteSetup
// 0x0010 (0x0088 - 0x0078)
class URHDataBatchInviteSetup final : public URHDataMassInviteBase
{
public:
	TDelegate<void(const TArray<class URH_RHFriendAndPlatformFriend*>& Friends)> OnSelect;           // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class URHDataBatchInviteSetup* SetCallbacks(TDelegate<void(const TArray<class URH_RHFriendAndPlatformFriend*>& Friends)> Select, TDelegate<void(class URH_RHFriendAndPlatformFriend* PlayerAndPlatformInfo)> ShouldShowPlayer, TDelegate<void()> Cancel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHDataBatchInviteSetup">();
	}
	static class URHDataBatchInviteSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHDataBatchInviteSetup>();
	}
};
static_assert(alignof(URHDataBatchInviteSetup) == 0x000008, "Wrong alignment on URHDataBatchInviteSetup");
static_assert(sizeof(URHDataBatchInviteSetup) == 0x000088, "Wrong size on URHDataBatchInviteSetup");
static_assert(offsetof(URHDataBatchInviteSetup, OnSelect) == 0x000078, "Member 'URHDataBatchInviteSetup::OnSelect' has a wrong offset!");

// Class RallyHereStart.RHMassInviteModal
// 0x0050 (0x0608 - 0x05B8)
class URHMassInviteModal : public URHWidget
{
public:
	TArray<class URH_RHFriendAndPlatformFriend*>  SelectedFriends;                                   // 0x05B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class URHDataMassInviteBase>   RouteData;                                         // 0x05C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URH_RHFriendAndPlatformFriend*>  FriendResults;                                     // 0x05D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class URH_RHFriendAndPlatformFriend*>  SearchResult;                                      // 0x05E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x18];                                     // 0x05F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseScreen(ERHInviteCloseAction CloseAction);
	void DoSearch(const class FText& SearchTerm);
	bool GetShouldSelect(class URH_RHFriendAndPlatformFriend* Friend);
	void OnSearchResultUpdated(const TArray<class URH_RHFriendAndPlatformFriend*>& ResultPlayers);
	void RequestFriends(TDelegate<void(const TArray<class URH_RHFriendAndPlatformFriend*>& PlayerAndPlatformInfos)> OnReceivePlayers);
	ERHInviteSelectResult SelectPlayer(class URH_RHFriendAndPlatformFriend* Friend);
	bool UpdateRouteData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHMassInviteModal">();
	}
	static class URHMassInviteModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHMassInviteModal>();
	}
};
static_assert(alignof(URHMassInviteModal) == 0x000008, "Wrong alignment on URHMassInviteModal");
static_assert(sizeof(URHMassInviteModal) == 0x000608, "Wrong size on URHMassInviteModal");
static_assert(offsetof(URHMassInviteModal, SelectedFriends) == 0x0005B8, "Member 'URHMassInviteModal::SelectedFriends' has a wrong offset!");
static_assert(offsetof(URHMassInviteModal, RouteData) == 0x0005C8, "Member 'URHMassInviteModal::RouteData' has a wrong offset!");
static_assert(offsetof(URHMassInviteModal, FriendResults) == 0x0005D0, "Member 'URHMassInviteModal::FriendResults' has a wrong offset!");
static_assert(offsetof(URHMassInviteModal, SearchResult) == 0x0005E0, "Member 'URHMassInviteModal::SearchResult' has a wrong offset!");

// Class RallyHereStart.RHMatchIdWidget
// 0x0000 (0x05B8 - 0x05B8)
class URHMatchIdWidget final : public URHWidget
{
public:
	class FText GetLongMatchId() const;
	class FText GetShortMatchId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHMatchIdWidget">();
	}
	static class URHMatchIdWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHMatchIdWidget>();
	}
};
static_assert(alignof(URHMatchIdWidget) == 0x000008, "Wrong alignment on URHMatchIdWidget");
static_assert(sizeof(URHMatchIdWidget) == 0x0005B8, "Wrong size on URHMatchIdWidget");

// Class RallyHereStart.RHMatchInvitationModal
// 0x0038 (0x05F0 - 0x05B8)
class URHMatchInvitationModal final : public URHWidget
{
public:
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           InvitationExpireTimeout;                           // 0x05C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x20];                                     // 0x05D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcceptInvite(int32 MapId);
	void AcceptInviteDefault();
	void CloseScreen();
	void DeclineInvite();
	void OnInvitationExpired();

	float GetInvitationTimeRemaining() const;
	float GetInvitationTotalTimeToExpire() const;
	class URHQueueDataFactory* GetQueueDataFactory() const;
	class URH_FriendSubsystem* GetRH_LocalPlayerFriendSubsystem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHMatchInvitationModal">();
	}
	static class URHMatchInvitationModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHMatchInvitationModal>();
	}
};
static_assert(alignof(URHMatchInvitationModal) == 0x000008, "Wrong alignment on URHMatchInvitationModal");
static_assert(sizeof(URHMatchInvitationModal) == 0x0005F0, "Wrong size on URHMatchInvitationModal");
static_assert(offsetof(URHMatchInvitationModal, InvitationExpireTimeout) == 0x0005C8, "Member 'URHMatchInvitationModal::InvitationExpireTimeout' has a wrong offset!");

// Class RallyHereStart.RHMediaPlayerWidget
// 0x0058 (0x0610 - 0x05B8)
class URHMediaPlayerWidget : public URHWidget
{
public:
	class UDataTable*                             PlaylistDataTable;                                 // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PlaylistDataTableClassName;                        // 0x05C0(0x0020)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x10];                                     // 0x05E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOnlyWatchFirstEntry;                              // 0x05F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F1[0x1F];                                     // 0x05F1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSubtitleText(const class FText& Subtitle);
	void HandleViewStateChanged(const struct FGameplayTag& CurrentRoute, const struct FGameplayTag& PreviousRoute, EViewManagerLayer Layer);
	void OnBeginLoadingMedia();
	void OnEndLoadingMedia();
	void OnPlaybackStarted(const class UPlatformMediaSource* PlatformMediaSource);
	void OnPlaylistComplete();
	void OnReadyForPlayback(const class UPlatformMediaSource* PlatformMediaSource);
	void OnShouldShowPromptChanged(bool bCanSkipEntry);
	void UIX_SkipEntry();

	bool IsCurrentEntrySkippable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHMediaPlayerWidget">();
	}
	static class URHMediaPlayerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHMediaPlayerWidget>();
	}
};
static_assert(alignof(URHMediaPlayerWidget) == 0x000008, "Wrong alignment on URHMediaPlayerWidget");
static_assert(sizeof(URHMediaPlayerWidget) == 0x000610, "Wrong size on URHMediaPlayerWidget");
static_assert(offsetof(URHMediaPlayerWidget, PlaylistDataTable) == 0x0005B8, "Member 'URHMediaPlayerWidget::PlaylistDataTable' has a wrong offset!");
static_assert(offsetof(URHMediaPlayerWidget, PlaylistDataTableClassName) == 0x0005C0, "Member 'URHMediaPlayerWidget::PlaylistDataTableClassName' has a wrong offset!");
static_assert(offsetof(URHMediaPlayerWidget, bOnlyWatchFirstEntry) == 0x0005F0, "Member 'URHMediaPlayerWidget::bOnlyWatchFirstEntry' has a wrong offset!");

// Class RallyHereStart.RHMobileLayoutSequencePlayer
// 0x0000 (0x0338 - 0x0338)
class URHMobileLayoutSequencePlayer final : public UUMGSequencePlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHMobileLayoutSequencePlayer">();
	}
	static class URHMobileLayoutSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHMobileLayoutSequencePlayer>();
	}
};
static_assert(alignof(URHMobileLayoutSequencePlayer) == 0x000008, "Wrong alignment on URHMobileLayoutSequencePlayer");
static_assert(sizeof(URHMobileLayoutSequencePlayer) == 0x000338, "Wrong size on URHMobileLayoutSequencePlayer");

// Class RallyHereStart.RHNavTabWidget
// 0x0040 (0x05F8 - 0x05B8)
class URHNavTabWidget : public URHWidget
{
public:
	TMulticastInlineDelegate<void(class URHNavTabWidget* SelectedNavTab)> OnNavTabSelected;          // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHNavTabWidget* UnselectedNavTab)> OnNavTabUnselected;      // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisabled;                                         // 0x05D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DA[0x6];                                      // 0x05DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NavText;                                           // 0x05E0(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	void SelectNavTab();
	void SetDisabled(bool bNewDisabled);
	void SetSelected(bool bNewSelected);
	void UnselectNavTab();

	bool IsDisabled() const;
	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHNavTabWidget">();
	}
	static class URHNavTabWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHNavTabWidget>();
	}
};
static_assert(alignof(URHNavTabWidget) == 0x000008, "Wrong alignment on URHNavTabWidget");
static_assert(sizeof(URHNavTabWidget) == 0x0005F8, "Wrong size on URHNavTabWidget");
static_assert(offsetof(URHNavTabWidget, OnNavTabSelected) == 0x0005B8, "Member 'URHNavTabWidget::OnNavTabSelected' has a wrong offset!");
static_assert(offsetof(URHNavTabWidget, OnNavTabUnselected) == 0x0005C8, "Member 'URHNavTabWidget::OnNavTabUnselected' has a wrong offset!");
static_assert(offsetof(URHNavTabWidget, bSelected) == 0x0005D8, "Member 'URHNavTabWidget::bSelected' has a wrong offset!");
static_assert(offsetof(URHNavTabWidget, bDisabled) == 0x0005D9, "Member 'URHNavTabWidget::bDisabled' has a wrong offset!");
static_assert(offsetof(URHNavTabWidget, NavText) == 0x0005E0, "Member 'URHNavTabWidget::NavText' has a wrong offset!");

// Class RallyHereStart.RHJsonData
// 0x0060 (0x0088 - 0x0028)
class URHJsonData : public UObject
{
public:
	class FName                                   UniqueID;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssociatedLootId;                                  // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 HideIfItemOwned;                                   // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ShowIfItemOwned;                                   // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          HideIfOwned;                                       // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinLevel;                                          // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x14];                                      // 0x0064(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          showSteam;                                         // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          showEpic;                                          // 0x0079(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          showWinGDK;                                        // 0x007A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          showPS4;                                           // 0x007B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          showPS5;                                           // 0x007C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          showXB1;                                           // 0x007D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          showXSX;                                           // 0x007E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          showNX;                                            // 0x007F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          showIOS;                                           // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          showAndroid;                                       // 0x0081(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHJsonData">();
	}
	static class URHJsonData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHJsonData>();
	}
};
static_assert(alignof(URHJsonData) == 0x000008, "Wrong alignment on URHJsonData");
static_assert(sizeof(URHJsonData) == 0x000088, "Wrong size on URHJsonData");
static_assert(offsetof(URHJsonData, UniqueID) == 0x000028, "Member 'URHJsonData::UniqueID' has a wrong offset!");
static_assert(offsetof(URHJsonData, AssociatedLootId) == 0x000030, "Member 'URHJsonData::AssociatedLootId' has a wrong offset!");
static_assert(offsetof(URHJsonData, HideIfItemOwned) == 0x000038, "Member 'URHJsonData::HideIfItemOwned' has a wrong offset!");
static_assert(offsetof(URHJsonData, ShowIfItemOwned) == 0x000048, "Member 'URHJsonData::ShowIfItemOwned' has a wrong offset!");
static_assert(offsetof(URHJsonData, HideIfOwned) == 0x000058, "Member 'URHJsonData::HideIfOwned' has a wrong offset!");
static_assert(offsetof(URHJsonData, MinLevel) == 0x00005C, "Member 'URHJsonData::MinLevel' has a wrong offset!");
static_assert(offsetof(URHJsonData, MaxLevel) == 0x000060, "Member 'URHJsonData::MaxLevel' has a wrong offset!");
static_assert(offsetof(URHJsonData, showSteam) == 0x000078, "Member 'URHJsonData::showSteam' has a wrong offset!");
static_assert(offsetof(URHJsonData, showEpic) == 0x000079, "Member 'URHJsonData::showEpic' has a wrong offset!");
static_assert(offsetof(URHJsonData, showWinGDK) == 0x00007A, "Member 'URHJsonData::showWinGDK' has a wrong offset!");
static_assert(offsetof(URHJsonData, showPS4) == 0x00007B, "Member 'URHJsonData::showPS4' has a wrong offset!");
static_assert(offsetof(URHJsonData, showPS5) == 0x00007C, "Member 'URHJsonData::showPS5' has a wrong offset!");
static_assert(offsetof(URHJsonData, showXB1) == 0x00007D, "Member 'URHJsonData::showXB1' has a wrong offset!");
static_assert(offsetof(URHJsonData, showXSX) == 0x00007E, "Member 'URHJsonData::showXSX' has a wrong offset!");
static_assert(offsetof(URHJsonData, showNX) == 0x00007F, "Member 'URHJsonData::showNX' has a wrong offset!");
static_assert(offsetof(URHJsonData, showIOS) == 0x000080, "Member 'URHJsonData::showIOS' has a wrong offset!");
static_assert(offsetof(URHJsonData, showAndroid) == 0x000081, "Member 'URHJsonData::showAndroid' has a wrong offset!");

// Class RallyHereStart.RHNewsRotatorData
// 0x0060 (0x00E8 - 0x0088)
class URHNewsRotatorData final : public URHJsonData
{
public:
	class UTexture2DDynamic*                      Image;                                             // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Header;                                            // 0x0090(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x00A8(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ENewsActions                                  PanelAction;                                       // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActionDetails;                                     // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHNewsRotatorData">();
	}
	static class URHNewsRotatorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHNewsRotatorData>();
	}
};
static_assert(alignof(URHNewsRotatorData) == 0x000008, "Wrong alignment on URHNewsRotatorData");
static_assert(sizeof(URHNewsRotatorData) == 0x0000E8, "Wrong size on URHNewsRotatorData");
static_assert(offsetof(URHNewsRotatorData, Image) == 0x000088, "Member 'URHNewsRotatorData::Image' has a wrong offset!");
static_assert(offsetof(URHNewsRotatorData, Header) == 0x000090, "Member 'URHNewsRotatorData::Header' has a wrong offset!");
static_assert(offsetof(URHNewsRotatorData, Body) == 0x0000A8, "Member 'URHNewsRotatorData::Body' has a wrong offset!");
static_assert(offsetof(URHNewsRotatorData, PanelAction) == 0x0000C0, "Member 'URHNewsRotatorData::PanelAction' has a wrong offset!");
static_assert(offsetof(URHNewsRotatorData, ActionDetails) == 0x0000C8, "Member 'URHNewsRotatorData::ActionDetails' has a wrong offset!");

// Class RallyHereStart.RHNewsRotatorWidget
// 0x0020 (0x05D8 - 0x05B8)
class URHNewsRotatorWidget final : public URHWidget
{
public:
	class FString                                 JsonSection;                                       // 0x05B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimePerSection;                                    // 0x05C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           StoreViewTag;                                      // 0x05CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BLUEPRINT_CheckShouldShowPanels(const TArray<class URHNewsRotatorData*>& Panels, const TDelegate<void(const TArray<class URHNewsRotatorData*>& Data)>& Delegate);
	void BLUEPRINT_GetPanelDataAsync(const TDelegate<void(const TArray<class URHNewsRotatorData*>& Data)>& Delegate);
	class URHNewsSubsystem* GetNewsSubsystem();
	void OnJsonChanged(const class FString& JsonName);
	void OnNewsPanelClicked(class URHNewsRotatorData* Panel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHNewsRotatorWidget">();
	}
	static class URHNewsRotatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHNewsRotatorWidget>();
	}
};
static_assert(alignof(URHNewsRotatorWidget) == 0x000008, "Wrong alignment on URHNewsRotatorWidget");
static_assert(sizeof(URHNewsRotatorWidget) == 0x0005D8, "Wrong size on URHNewsRotatorWidget");
static_assert(offsetof(URHNewsRotatorWidget, JsonSection) == 0x0005B8, "Member 'URHNewsRotatorWidget::JsonSection' has a wrong offset!");
static_assert(offsetof(URHNewsRotatorWidget, TimePerSection) == 0x0005C8, "Member 'URHNewsRotatorWidget::TimePerSection' has a wrong offset!");
static_assert(offsetof(URHNewsRotatorWidget, StoreViewTag) == 0x0005CC, "Member 'URHNewsRotatorWidget::StoreViewTag' has a wrong offset!");

// Class RallyHereStart.RH_PlayerShouldShowPanelsHelper
// 0x0088 (0x00B0 - 0x0028)
class URH_PlayerShouldShowPanelsHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class URHNewsSubsystem>        NewsSubsystem;                                     // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_PlayerShouldShowPanelsHelper">();
	}
	static class URH_PlayerShouldShowPanelsHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_PlayerShouldShowPanelsHelper>();
	}
};
static_assert(alignof(URH_PlayerShouldShowPanelsHelper) == 0x000008, "Wrong alignment on URH_PlayerShouldShowPanelsHelper");
static_assert(sizeof(URH_PlayerShouldShowPanelsHelper) == 0x0000B0, "Wrong size on URH_PlayerShouldShowPanelsHelper");
static_assert(offsetof(URH_PlayerShouldShowPanelsHelper, PlayerInfo) == 0x0000A0, "Member 'URH_PlayerShouldShowPanelsHelper::PlayerInfo' has a wrong offset!");
static_assert(offsetof(URH_PlayerShouldShowPanelsHelper, NewsSubsystem) == 0x0000A8, "Member 'URH_PlayerShouldShowPanelsHelper::NewsSubsystem' has a wrong offset!");

// Class RallyHereStart.RH_PlayerInventoryCountHelper
// 0x0080 (0x00A8 - 0x0028)
class URH_PlayerInventoryCountHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_PlayerInventoryCountHelper">();
	}
	static class URH_PlayerInventoryCountHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_PlayerInventoryCountHelper>();
	}
};
static_assert(alignof(URH_PlayerInventoryCountHelper) == 0x000008, "Wrong alignment on URH_PlayerInventoryCountHelper");
static_assert(sizeof(URH_PlayerInventoryCountHelper) == 0x0000A8, "Wrong size on URH_PlayerInventoryCountHelper");
static_assert(offsetof(URH_PlayerInventoryCountHelper, PlayerInfo) == 0x0000A0, "Member 'URH_PlayerInventoryCountHelper::PlayerInfo' has a wrong offset!");

// Class RallyHereStart.RHNewsSubsystem
// 0x0238 (0x0268 - 0x0030)
class URHNewsSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class FString, class UTexture2DDynamic*> mapFilePathToTexture;                              // 0x0030(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, TWeakObjectPtr<class UTexture2DDynamic>> FilePathToWeakTexture;              // 0x0080(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x100];                                     // 0x00D0(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class URH_PlayerInfo*, struct FRHJsonDataWrapper> CachedJsonDataByPlayer;                   // 0x01D0(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        PlayerProgressionXpClass;                          // 0x0220(0x0020)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class URHProgression>          PlayerXpProgression;                               // 0x0240(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleImagesReady(class URHLandingPanelJSONHandler* pHandler);
	void HandleJsonReady(class URHLandingPanelJSONHandler* pHandler);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHNewsSubsystem">();
	}
	static class URHNewsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHNewsSubsystem>();
	}
};
static_assert(alignof(URHNewsSubsystem) == 0x000008, "Wrong alignment on URHNewsSubsystem");
static_assert(sizeof(URHNewsSubsystem) == 0x000268, "Wrong size on URHNewsSubsystem");
static_assert(offsetof(URHNewsSubsystem, mapFilePathToTexture) == 0x000030, "Member 'URHNewsSubsystem::mapFilePathToTexture' has a wrong offset!");
static_assert(offsetof(URHNewsSubsystem, FilePathToWeakTexture) == 0x000080, "Member 'URHNewsSubsystem::FilePathToWeakTexture' has a wrong offset!");
static_assert(offsetof(URHNewsSubsystem, CachedJsonDataByPlayer) == 0x0001D0, "Member 'URHNewsSubsystem::CachedJsonDataByPlayer' has a wrong offset!");
static_assert(offsetof(URHNewsSubsystem, PlayerProgressionXpClass) == 0x000220, "Member 'URHNewsSubsystem::PlayerProgressionXpClass' has a wrong offset!");
static_assert(offsetof(URHNewsSubsystem, PlayerXpProgression) == 0x000240, "Member 'URHNewsSubsystem::PlayerXpProgression' has a wrong offset!");

// Class RallyHereStart.RHNewStartMenuData
// 0x0008 (0x0090 - 0x0088)
class URHNewStartMenuData final : public URHJsonData
{
public:
	class UTexture2DDynamic*                      Image;                                             // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHNewStartMenuData">();
	}
	static class URHNewStartMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHNewStartMenuData>();
	}
};
static_assert(alignof(URHNewStartMenuData) == 0x000008, "Wrong alignment on URHNewStartMenuData");
static_assert(sizeof(URHNewStartMenuData) == 0x000090, "Wrong size on URHNewStartMenuData");
static_assert(offsetof(URHNewStartMenuData, Image) == 0x000088, "Member 'URHNewStartMenuData::Image' has a wrong offset!");

// Class RallyHereStart.RHNewStartMenuWidget
// 0x0000 (0x05B8 - 0x05B8)
class URHNewStartMenuWidget : public URHWidget
{
public:
	void BLUEPRINT_CheckIsNewsAvailable(const TDelegate<void(bool bAvailable)>& Delegate);
	class URHNewsSubsystem* GetNewsSubsystem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHNewStartMenuWidget">();
	}
	static class URHNewStartMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHNewStartMenuWidget>();
	}
};
static_assert(alignof(URHNewStartMenuWidget) == 0x000008, "Wrong alignment on URHNewStartMenuWidget");
static_assert(sizeof(URHNewStartMenuWidget) == 0x0005B8, "Wrong size on URHNewStartMenuWidget");

// Class RallyHereStart.RHOrderViewRedirector
// 0x0010 (0x0038 - 0x0028)
class URHOrderViewRedirector : public URHViewRedirecter
{
public:
	TArray<ERHOrderType>                          ValidOrderTypes;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHOrderViewRedirector">();
	}
	static class URHOrderViewRedirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHOrderViewRedirector>();
	}
};
static_assert(alignof(URHOrderViewRedirector) == 0x000008, "Wrong alignment on URHOrderViewRedirector");
static_assert(sizeof(URHOrderViewRedirector) == 0x000038, "Wrong size on URHOrderViewRedirector");
static_assert(offsetof(URHOrderViewRedirector, ValidOrderTypes) == 0x000028, "Member 'URHOrderViewRedirector::ValidOrderTypes' has a wrong offset!");

// Class RallyHereStart.RHOrderModal
// 0x0058 (0x0610 - 0x05B8)
class URHOrderModal final : public URHWidget
{
public:
	class UDataTable*                             HeaderOverridesTable;                              // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FRH_LootId, class FText>          HeaderOverridesFromJson;                           // 0x05C0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	class FString GetAcquisitionReason(const class URHOrder* Order) const;
	class FText GetHeaderText(const class URHOrder* Order) const;
	class URHOrderSubsystem* GetOrderSubsystem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHOrderModal">();
	}
	static class URHOrderModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHOrderModal>();
	}
};
static_assert(alignof(URHOrderModal) == 0x000008, "Wrong alignment on URHOrderModal");
static_assert(sizeof(URHOrderModal) == 0x000610, "Wrong size on URHOrderModal");
static_assert(offsetof(URHOrderModal, HeaderOverridesTable) == 0x0005B8, "Member 'URHOrderModal::HeaderOverridesTable' has a wrong offset!");
static_assert(offsetof(URHOrderModal, HeaderOverridesFromJson) == 0x0005C0, "Member 'URHOrderModal::HeaderOverridesFromJson' has a wrong offset!");

// Class RallyHereStart.OrderItemData
// 0x0010 (0x0038 - 0x0028)
class UOrderItemData final : public UObject
{
public:
	class URHStoreItem*                           StoreItem;                                         // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrderItemData">();
	}
	static class UOrderItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrderItemData>();
	}
};
static_assert(alignof(UOrderItemData) == 0x000008, "Wrong alignment on UOrderItemData");
static_assert(sizeof(UOrderItemData) == 0x000038, "Wrong size on UOrderItemData");
static_assert(offsetof(UOrderItemData, StoreItem) == 0x000028, "Member 'UOrderItemData::StoreItem' has a wrong offset!");
static_assert(offsetof(UOrderItemData, Quantity) == 0x000030, "Member 'UOrderItemData::Quantity' has a wrong offset!");

// Class RallyHereStart.RHOrder
// 0x0058 (0x0080 - 0x0028)
class URHOrder final : public UObject
{
public:
	ERHOrderType                                  OrderType;                                         // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOrderItemData*>                 OrderItems;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SortOrderItemsBySortOrder();

	bool IsBundleOrder() const;
	bool IsPurchase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHOrder">();
	}
	static class URHOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHOrder>();
	}
};
static_assert(alignof(URHOrder) == 0x000008, "Wrong alignment on URHOrder");
static_assert(sizeof(URHOrder) == 0x000080, "Wrong size on URHOrder");
static_assert(offsetof(URHOrder, OrderType) == 0x000028, "Member 'URHOrder::OrderType' has a wrong offset!");
static_assert(offsetof(URHOrder, OrderItems) == 0x000030, "Member 'URHOrder::OrderItems' has a wrong offset!");

// Class RallyHereStart.RHOrderSubsystem
// 0x0098 (0x00C8 - 0x0030)
class URHOrderSubsystem : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class URHOrder* Order)> OnOrderReady;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class URHStoreItem* StoreItem)> OnOrderSuccess;                    // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText ErrorMsg)> OnOrderFailed;                              // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class URHOrder*>                       QueuedOrders;                                      // 0x0078(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class URHOrder*                               PendingOrder;                                      // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHStoreSubsystem*                      StoreSubsystem;                                    // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRH_ActiveOrderWatch>           ActiveOrderWatches;                                // 0x0098(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRH_LootId>                     BlacklistedLootIds;                                // 0x00A8(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRH_LootId>                     HotfixBlacklistedLootIds;                          // 0x00B8(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	void CreateOrderForItem(class URHStoreItem* StoreItem, const class URH_PlayerInfo* PlayerInfo);
	class URHOrder* GetNextOrder();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHOrderSubsystem">();
	}
	static class URHOrderSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHOrderSubsystem>();
	}
};
static_assert(alignof(URHOrderSubsystem) == 0x000008, "Wrong alignment on URHOrderSubsystem");
static_assert(sizeof(URHOrderSubsystem) == 0x0000C8, "Wrong size on URHOrderSubsystem");
static_assert(offsetof(URHOrderSubsystem, OnOrderReady) == 0x000038, "Member 'URHOrderSubsystem::OnOrderReady' has a wrong offset!");
static_assert(offsetof(URHOrderSubsystem, OnOrderSuccess) == 0x000058, "Member 'URHOrderSubsystem::OnOrderSuccess' has a wrong offset!");
static_assert(offsetof(URHOrderSubsystem, OnOrderFailed) == 0x000068, "Member 'URHOrderSubsystem::OnOrderFailed' has a wrong offset!");
static_assert(offsetof(URHOrderSubsystem, QueuedOrders) == 0x000078, "Member 'URHOrderSubsystem::QueuedOrders' has a wrong offset!");
static_assert(offsetof(URHOrderSubsystem, PendingOrder) == 0x000088, "Member 'URHOrderSubsystem::PendingOrder' has a wrong offset!");
static_assert(offsetof(URHOrderSubsystem, StoreSubsystem) == 0x000090, "Member 'URHOrderSubsystem::StoreSubsystem' has a wrong offset!");
static_assert(offsetof(URHOrderSubsystem, ActiveOrderWatches) == 0x000098, "Member 'URHOrderSubsystem::ActiveOrderWatches' has a wrong offset!");
static_assert(offsetof(URHOrderSubsystem, BlacklistedLootIds) == 0x0000A8, "Member 'URHOrderSubsystem::BlacklistedLootIds' has a wrong offset!");
static_assert(offsetof(URHOrderSubsystem, HotfixBlacklistedLootIds) == 0x0000B8, "Member 'URHOrderSubsystem::HotfixBlacklistedLootIds' has a wrong offset!");

// Class RallyHereStart.RHTabValidator
// 0x0000 (0x0028 - 0x0028)
class URHTabValidator final : public UObject
{
public:
	bool IsValidTab();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHTabValidator">();
	}
	static class URHTabValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHTabValidator>();
	}
};
static_assert(alignof(URHTabValidator) == 0x000008, "Wrong alignment on URHTabValidator");
static_assert(sizeof(URHTabValidator) == 0x000028, "Wrong size on URHTabValidator");

// Class RallyHereStart.RHOverlayTabEntryWidget
// 0x0068 (0x0620 - 0x05B8)
class URHOverlayTabEntryWidget final : public URHWidget
{
public:
	ERHOverlayTabState                            TabState;                                          // 0x05B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B9[0x3];                                      // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MyViewName;                                        // 0x05BC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOverlayTabViewRow                     MyViewInfo;                                        // 0x05C8(0x0030)(Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class FName ViewName)> OnActiveViewRequested;                      // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName ViewName)> OnFocusToViewRequested;                     // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UButton*                                HitTarget;                                         // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DisplayTabState();
	void DisplayViewInfo();
	void HandleActiveViewChanged(class FName ActiveView);
	void HandleClicked();
	void HandleHovered();
	void HandleInputStateChanged(ERH_INPUT_STATE InputState);
	void HandleTabsFocused();
	void HandleUnhovered();
	void HandleViewFocused();
	void SetTabState(ERHOverlayTabState InTabState);
	void SetViewInfo(const struct FOverlayTabViewRow& InViewInfo);
	void SetViewName(class FName InViewName);

	ERHOverlayTabState GetTabState() const;
	struct FOverlayTabViewRow GetViewInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHOverlayTabEntryWidget">();
	}
	static class URHOverlayTabEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHOverlayTabEntryWidget>();
	}
};
static_assert(alignof(URHOverlayTabEntryWidget) == 0x000008, "Wrong alignment on URHOverlayTabEntryWidget");
static_assert(sizeof(URHOverlayTabEntryWidget) == 0x000620, "Wrong size on URHOverlayTabEntryWidget");
static_assert(offsetof(URHOverlayTabEntryWidget, TabState) == 0x0005B8, "Member 'URHOverlayTabEntryWidget::TabState' has a wrong offset!");
static_assert(offsetof(URHOverlayTabEntryWidget, MyViewName) == 0x0005BC, "Member 'URHOverlayTabEntryWidget::MyViewName' has a wrong offset!");
static_assert(offsetof(URHOverlayTabEntryWidget, MyViewInfo) == 0x0005C8, "Member 'URHOverlayTabEntryWidget::MyViewInfo' has a wrong offset!");
static_assert(offsetof(URHOverlayTabEntryWidget, OnActiveViewRequested) == 0x0005F8, "Member 'URHOverlayTabEntryWidget::OnActiveViewRequested' has a wrong offset!");
static_assert(offsetof(URHOverlayTabEntryWidget, OnFocusToViewRequested) == 0x000608, "Member 'URHOverlayTabEntryWidget::OnFocusToViewRequested' has a wrong offset!");
static_assert(offsetof(URHOverlayTabEntryWidget, HitTarget) == 0x000618, "Member 'URHOverlayTabEntryWidget::HitTarget' has a wrong offset!");

// Class RallyHereStart.RHOverlayTabHubRouteData
// 0x0010 (0x0038 - 0x0028)
class URHOverlayTabHubRouteData final : public UObject
{
public:
	class FName                                   RedirectViewName;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URHWidget*                              LandingWidgetInView;                               // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHOverlayTabHubRouteData">();
	}
	static class URHOverlayTabHubRouteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHOverlayTabHubRouteData>();
	}
};
static_assert(alignof(URHOverlayTabHubRouteData) == 0x000008, "Wrong alignment on URHOverlayTabHubRouteData");
static_assert(sizeof(URHOverlayTabHubRouteData) == 0x000038, "Wrong size on URHOverlayTabHubRouteData");
static_assert(offsetof(URHOverlayTabHubRouteData, RedirectViewName) == 0x000028, "Member 'URHOverlayTabHubRouteData::RedirectViewName' has a wrong offset!");
static_assert(offsetof(URHOverlayTabHubRouteData, LandingWidgetInView) == 0x000030, "Member 'URHOverlayTabHubRouteData::LandingWidgetInView' has a wrong offset!");

// Class RallyHereStart.RHOverlayTabHubBase
// 0x00A8 (0x0660 - 0x05B8)
class URHOverlayTabHubBase final : public URHWidget
{
public:
	class FName                                   CurrentViewName;                                   // 0x05B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x58];                                     // 0x05C0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TabEntriesFocusGroup;                              // 0x0618(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ViewsTable;                                        // 0x0620(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           ViewNames;                                         // 0x0628(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_638[0x10];                                     // 0x0638(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        ViewSwitcher;                                      // 0x0648(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           TabContainer;                                      // 0x0650(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URHWidget>                  SoftTabWidgetClass;                                // 0x0658(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddView(class FName ViewName, const struct FOverlayTabViewRow& ViewInfo);
	void ChangeView(class FName ViewName);
	void CreateAllViews();
	class URHOverlayTabHubRouteData* GetLandingInfo();
	void HandleActiveViewRequested(class FName ViewName);
	void HandleBackContextAction();
	void HandleFocusToViewRequested(class FName ViewName);
	void OnTabsFocused();
	void OnViewAdded(class FName ViewName, const struct FOverlayTabViewRow& ViewInfo, class URHOverlayTabEntryWidget* TabEntry, class URHWidget* ViewWidget);
	void OnViewChanged();
	void SetFocusToTabs();
	void SetFocusToView(class URHWidget* InitialFocusedWidget);

	class URHWidget* GetCurrentViewWidget() const;
	TArray<class URHOverlayTabEntryWidget*> GetTabEntries() const;
	TArray<class URHWidget*> GetViewWidgets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHOverlayTabHubBase">();
	}
	static class URHOverlayTabHubBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHOverlayTabHubBase>();
	}
};
static_assert(alignof(URHOverlayTabHubBase) == 0x000008, "Wrong alignment on URHOverlayTabHubBase");
static_assert(sizeof(URHOverlayTabHubBase) == 0x000660, "Wrong size on URHOverlayTabHubBase");
static_assert(offsetof(URHOverlayTabHubBase, CurrentViewName) == 0x0005B8, "Member 'URHOverlayTabHubBase::CurrentViewName' has a wrong offset!");
static_assert(offsetof(URHOverlayTabHubBase, TabEntriesFocusGroup) == 0x000618, "Member 'URHOverlayTabHubBase::TabEntriesFocusGroup' has a wrong offset!");
static_assert(offsetof(URHOverlayTabHubBase, ViewsTable) == 0x000620, "Member 'URHOverlayTabHubBase::ViewsTable' has a wrong offset!");
static_assert(offsetof(URHOverlayTabHubBase, ViewNames) == 0x000628, "Member 'URHOverlayTabHubBase::ViewNames' has a wrong offset!");
static_assert(offsetof(URHOverlayTabHubBase, ViewSwitcher) == 0x000648, "Member 'URHOverlayTabHubBase::ViewSwitcher' has a wrong offset!");
static_assert(offsetof(URHOverlayTabHubBase, TabContainer) == 0x000650, "Member 'URHOverlayTabHubBase::TabContainer' has a wrong offset!");
static_assert(offsetof(URHOverlayTabHubBase, SoftTabWidgetClass) == 0x000658, "Member 'URHOverlayTabHubBase::SoftTabWidgetClass' has a wrong offset!");

// Class RallyHereStart.RHPartyManager
// 0x0268 (0x0290 - 0x0028)
class URHPartyManager : public UObject
{
public:
	class ARHHUDCommon*                           MyHud;                                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnPartyDataUpdated;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPartyLocalPlayerLeft;                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPartyLocalPlayerPromoted;                        // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGuid& PlayerId)> OnPartyMemberPromoted;              // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRH_PartyMemberData& PartyMember)> OnPartyMemberDataUpdated; // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRH_PartyMemberData& PartyMember)> OnPendingPartyMemberDataAdded; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRH_PartyMemberData& PartyMember)> OnPendingPartyMemberAccepted; // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGuid& PartyMemberId)> OnPartyMemberRemoved;          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRH_PartyMemberData& PartyMember)> OnPartyMemberLeft; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPartyDisbanded;                                  // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText ErrorMsg)> OnPartyInvitationError;                     // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URH_PlayerInfo* Invitee)> OnPartyInvitationSent;             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URH_PlayerInfo* Inviter)> OnPartyInvitationReceived;         // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPartyInvitationAccepted;                         // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPartyInvitationRejected;                         // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPartyInvitationExpired;                          // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPartyInfoUpdated;                                // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGuid& PlayerId)> OnPartyMemberStatusChanged;         // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRH_PartyMemberData>            PartyMembers;                                      // 0x0158(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class URH_PlayerInfo*                         PartyInviter;                                      // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LastInviteSentErrorMessage;                        // 0x0170(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x4];                                      // 0x0180(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPartySize;                                      // 0x0184(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 RHSessionType;                                     // 0x0188(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URH_JoinedSession*                      PartySession;                                      // 0x0198(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A0[0x90];                                     // 0x01A0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bIsDeserter, const struct FRH_PartyDeserters& DeserterStatus)> OnPartyDeserterUpdated; // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FRH_PartyDeserters                     ActiveDeserterStatuses;                            // 0x0240(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void BroadcastPartyInvitationError(const class FText& InvitationError);
	void CheckForInvites();
	bool DoesPartyHaveDeserter(struct FDateTime* OutExperationTime, class FString* OutPlayerInfo);
	struct FRH_PartyDeserters GetPartyDeserters();
	struct FRH_PartyMemberData GetPartyMemberByID(const struct FGuid& PlayerId);
	void HandlePartyMemberDeserterUpdated(class URH_PlayerInfoSubobject* deserterSubobject);
	void HandlePreferredRegionUpdated();
	bool IsPlayerInParty(const struct FGuid& PlayerId);
	void OnEngineExit();
	void PartyGiveInvitePermissionResponse();
	void PartyKickResponse();
	void PartyLeaveResponse();
	void PartyPromoteResponse();
	void PartyRevokeInvitePermissionResponse();
	void SetPartyInfo(const class FString& Key, const class FString& Value);
	void SetSelectedQueueId(const class FString& QueueId);
	void UIX_AcceptPartyInvitation();
	void UIX_DenyPartyInvitation();
	void UIX_DisbandParty();
	void UIX_GiveMemberInvitePermission(const struct FGuid& PlayerId);
	void UIX_InviteMemberToParty(class URH_RHFriendAndPlatformFriend* Invitee);
	void UIX_KickMemberFromParty(const struct FGuid& PlayerId);
	void UIX_LeaveParty();
	void UIX_PlayerKickedFromParty();
	void UIX_PromoteMemberToLeader(const struct FGuid& PlayerId);
	void UIX_RevokeMemberInvitePermission(const struct FGuid& PlayerId);

	bool CheckPartyMemberIsLeader(const struct FGuid& PlayerId, class URH_JoinedSession* Session) const;
	int32 GetMaxPartyMembers() const;
	class FString GetPartyInfo(const class FString& Key) const;
	ERH_PartyInviteRightsMode GetPartyInviteMode() const;
	class URH_PlayerInfo* GetPartyInviter() const;
	bool GetPartyLeader(struct FRHAPI_SessionPlayer* OutPlayer) const;
	int32 GetPartyMemberCount() const;
	TArray<struct FRH_PartyMemberData> GetPartyMembers() const;
	class URH_JoinedSession* GetPartySession() const;
	int32 GetReadyPartyMemberCount() const;
	class FString GetRHSessionType() const;
	class FString GetSelectedQueueId() const;
	bool HasInvitePermission(const struct FGuid& PlayerId) const;
	bool IsInParty() const;
	bool IsLeader(class URH_JoinedSession* Session) const;
	bool IsPartyMaxed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPartyManager">();
	}
	static class URHPartyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPartyManager>();
	}
};
static_assert(alignof(URHPartyManager) == 0x000008, "Wrong alignment on URHPartyManager");
static_assert(sizeof(URHPartyManager) == 0x000290, "Wrong size on URHPartyManager");
static_assert(offsetof(URHPartyManager, MyHud) == 0x000028, "Member 'URHPartyManager::MyHud' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyDataUpdated) == 0x000030, "Member 'URHPartyManager::OnPartyDataUpdated' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyLocalPlayerLeft) == 0x000040, "Member 'URHPartyManager::OnPartyLocalPlayerLeft' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyLocalPlayerPromoted) == 0x000050, "Member 'URHPartyManager::OnPartyLocalPlayerPromoted' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyMemberPromoted) == 0x000060, "Member 'URHPartyManager::OnPartyMemberPromoted' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyMemberDataUpdated) == 0x000070, "Member 'URHPartyManager::OnPartyMemberDataUpdated' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPendingPartyMemberDataAdded) == 0x000080, "Member 'URHPartyManager::OnPendingPartyMemberDataAdded' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPendingPartyMemberAccepted) == 0x000090, "Member 'URHPartyManager::OnPendingPartyMemberAccepted' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyMemberRemoved) == 0x0000A0, "Member 'URHPartyManager::OnPartyMemberRemoved' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyMemberLeft) == 0x0000B0, "Member 'URHPartyManager::OnPartyMemberLeft' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyDisbanded) == 0x0000C0, "Member 'URHPartyManager::OnPartyDisbanded' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyInvitationError) == 0x0000D0, "Member 'URHPartyManager::OnPartyInvitationError' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyInvitationSent) == 0x0000E0, "Member 'URHPartyManager::OnPartyInvitationSent' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyInvitationReceived) == 0x0000F0, "Member 'URHPartyManager::OnPartyInvitationReceived' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyInvitationAccepted) == 0x000100, "Member 'URHPartyManager::OnPartyInvitationAccepted' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyInvitationRejected) == 0x000110, "Member 'URHPartyManager::OnPartyInvitationRejected' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyInvitationExpired) == 0x000120, "Member 'URHPartyManager::OnPartyInvitationExpired' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyInfoUpdated) == 0x000130, "Member 'URHPartyManager::OnPartyInfoUpdated' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyMemberStatusChanged) == 0x000140, "Member 'URHPartyManager::OnPartyMemberStatusChanged' has a wrong offset!");
static_assert(offsetof(URHPartyManager, PartyMembers) == 0x000158, "Member 'URHPartyManager::PartyMembers' has a wrong offset!");
static_assert(offsetof(URHPartyManager, PartyInviter) == 0x000168, "Member 'URHPartyManager::PartyInviter' has a wrong offset!");
static_assert(offsetof(URHPartyManager, LastInviteSentErrorMessage) == 0x000170, "Member 'URHPartyManager::LastInviteSentErrorMessage' has a wrong offset!");
static_assert(offsetof(URHPartyManager, MaxPartySize) == 0x000184, "Member 'URHPartyManager::MaxPartySize' has a wrong offset!");
static_assert(offsetof(URHPartyManager, RHSessionType) == 0x000188, "Member 'URHPartyManager::RHSessionType' has a wrong offset!");
static_assert(offsetof(URHPartyManager, PartySession) == 0x000198, "Member 'URHPartyManager::PartySession' has a wrong offset!");
static_assert(offsetof(URHPartyManager, OnPartyDeserterUpdated) == 0x000230, "Member 'URHPartyManager::OnPartyDeserterUpdated' has a wrong offset!");
static_assert(offsetof(URHPartyManager, ActiveDeserterStatuses) == 0x000240, "Member 'URHPartyManager::ActiveDeserterStatuses' has a wrong offset!");

// Class RallyHereStart.RHPartyManagerWidgetBase
// 0x0010 (0x05C8 - 0x05B8)
class URHPartyManagerWidgetBase : public URHWidget
{
public:
	TArray<struct FRH_PartyMemberData>            CachedDisplayedPartyMembers;                       // 0x05B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void ApplyEmptyPartyData();
	void ApplyPartyData(const TArray<struct FRH_PartyMemberData>& PartyMembers);
	TArray<struct FRH_PartyMemberData> GetCachedDisplayedPartyMembers();
	class URHPartyManager* GetPartyManager();
	class URH_PlayerInfo* GetSuggestedInvite();
	void HandlePartyMemberDataUpdated(const struct FRH_PartyMemberData& MemberData);
	void HandlePartyMemberUpdateById(const struct FGuid& PlayerId);
	void HandlePartyMemberUpdateByInfo(class URH_PlayerInfo* PlayerInfo);
	void HandlePartyMemberUpdateByName(const class FText& PlayerName);
	void RefreshFromPartyData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPartyManagerWidgetBase">();
	}
	static class URHPartyManagerWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPartyManagerWidgetBase>();
	}
};
static_assert(alignof(URHPartyManagerWidgetBase) == 0x000008, "Wrong alignment on URHPartyManagerWidgetBase");
static_assert(sizeof(URHPartyManagerWidgetBase) == 0x0005C8, "Wrong size on URHPartyManagerWidgetBase");
static_assert(offsetof(URHPartyManagerWidgetBase, CachedDisplayedPartyMembers) == 0x0005B8, "Member 'URHPartyManagerWidgetBase::CachedDisplayedPartyMembers' has a wrong offset!");

// Class RallyHereStart.RHPlayerCardModuleBase
// 0x0008 (0x05C0 - 0x05B8)
class URHPlayerCardModuleBase : public URHWidget
{
public:
	class URH_RHFriendAndPlatformFriend*          AssignedFriend;                                    // 0x05B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRHFriendSet(class URH_RHFriendAndPlatformFriend* Friend);
	void View_SetFriend(class URH_RHFriendAndPlatformFriend* Friend);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPlayerCardModuleBase">();
	}
	static class URHPlayerCardModuleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPlayerCardModuleBase>();
	}
};
static_assert(alignof(URHPlayerCardModuleBase) == 0x000008, "Wrong alignment on URHPlayerCardModuleBase");
static_assert(sizeof(URHPlayerCardModuleBase) == 0x0005C0, "Wrong size on URHPlayerCardModuleBase");
static_assert(offsetof(URHPlayerCardModuleBase, AssignedFriend) == 0x0005B8, "Member 'URHPlayerCardModuleBase::AssignedFriend' has a wrong offset!");

// Class RallyHereStart.RHPlayerController
// 0x0128 (0x0980 - 0x0858)
class ARHPlayerController : public APlayerController
{
public:
	struct FGuid                                  RHPlayerUuid;                                      // 0x0858(0x0010)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UInputComponent>            InputComponentClass;                               // 0x0868(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_870[0xD8];                                     // 0x0870(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SonyMatchId;                                       // 0x0948(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SonyActivityId;                                    // 0x0958(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESonyMatchState                               SonyMatchState;                                    // 0x0968(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESonyMatchState                               QueuedSonyMatchState;                              // 0x0969(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSonyMatchOwner;                                 // 0x096A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEligibleSonyMatchOwner;                         // 0x096B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExclusiveSonyMatchOwner;                        // 0x096C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_96D[0x13];                                     // 0x096D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientCheckSonyMatchOwnerEligibility();
	void ClientUpdateSonyMatchData(const class FString& InMatchId, const class FString& InActivityId);
	void ServerReportPlayer(const struct FGuid& ReporterGuid, const struct FGuid& ReportedGuid, EReportPlayerReason ReportReason);
	void ServerUpdateSonyMatchData(const class FString& InMatchId);
	void ServerUpdateSonyMatchOwnerEligibility(bool bIsEligible);
	void UIX_FlushPressedKeys();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPlayerController">();
	}
	static class ARHPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARHPlayerController>();
	}
};
static_assert(alignof(ARHPlayerController) == 0x000008, "Wrong alignment on ARHPlayerController");
static_assert(sizeof(ARHPlayerController) == 0x000980, "Wrong size on ARHPlayerController");
static_assert(offsetof(ARHPlayerController, RHPlayerUuid) == 0x000858, "Member 'ARHPlayerController::RHPlayerUuid' has a wrong offset!");
static_assert(offsetof(ARHPlayerController, InputComponentClass) == 0x000868, "Member 'ARHPlayerController::InputComponentClass' has a wrong offset!");
static_assert(offsetof(ARHPlayerController, SonyMatchId) == 0x000948, "Member 'ARHPlayerController::SonyMatchId' has a wrong offset!");
static_assert(offsetof(ARHPlayerController, SonyActivityId) == 0x000958, "Member 'ARHPlayerController::SonyActivityId' has a wrong offset!");
static_assert(offsetof(ARHPlayerController, SonyMatchState) == 0x000968, "Member 'ARHPlayerController::SonyMatchState' has a wrong offset!");
static_assert(offsetof(ARHPlayerController, QueuedSonyMatchState) == 0x000969, "Member 'ARHPlayerController::QueuedSonyMatchState' has a wrong offset!");
static_assert(offsetof(ARHPlayerController, bIsSonyMatchOwner) == 0x00096A, "Member 'ARHPlayerController::bIsSonyMatchOwner' has a wrong offset!");
static_assert(offsetof(ARHPlayerController, bIsEligibleSonyMatchOwner) == 0x00096B, "Member 'ARHPlayerController::bIsEligibleSonyMatchOwner' has a wrong offset!");
static_assert(offsetof(ARHPlayerController, bIsExclusiveSonyMatchOwner) == 0x00096C, "Member 'ARHPlayerController::bIsExclusiveSonyMatchOwner' has a wrong offset!");

// Class RallyHereStart.RH_PlayerCosmeticOwnershipHelper
// 0x0050 (0x0078 - 0x0028)
class URH_PlayerCosmeticOwnershipHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_PlayerCosmeticOwnershipHelper">();
	}
	static class URH_PlayerCosmeticOwnershipHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_PlayerCosmeticOwnershipHelper>();
	}
};
static_assert(alignof(URH_PlayerCosmeticOwnershipHelper) == 0x000008, "Wrong alignment on URH_PlayerCosmeticOwnershipHelper");
static_assert(sizeof(URH_PlayerCosmeticOwnershipHelper) == 0x000078, "Wrong size on URH_PlayerCosmeticOwnershipHelper");
static_assert(offsetof(URH_PlayerCosmeticOwnershipHelper, PlayerInfo) == 0x000070, "Member 'URH_PlayerCosmeticOwnershipHelper::PlayerInfo' has a wrong offset!");

// Class RallyHereStart.RHPlayerCosmeticWidget
// 0x0010 (0x05C8 - 0x05B8)
class URHPlayerCosmeticWidget final : public URHWidget
{
public:
	TArray<class URH_PlayerCosmeticOwnershipHelper*> PendingOwnershipRequests;                       // 0x05B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	bool GetItemsForSlot(TDelegate<void(const struct FRHProfileItemsWrapper& ItemWrapper)> Event, ERHLoadoutSlotTypes SlotType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPlayerCosmeticWidget">();
	}
	static class URHPlayerCosmeticWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPlayerCosmeticWidget>();
	}
};
static_assert(alignof(URHPlayerCosmeticWidget) == 0x000008, "Wrong alignment on URHPlayerCosmeticWidget");
static_assert(sizeof(URHPlayerCosmeticWidget) == 0x0005C8, "Wrong size on URHPlayerCosmeticWidget");
static_assert(offsetof(URHPlayerCosmeticWidget, PendingOwnershipRequests) == 0x0005B8, "Member 'URHPlayerCosmeticWidget::PendingOwnershipRequests' has a wrong offset!");

// Class RallyHereStart.RHPlayerInfoDisplay
// 0x0038 (0x05F0 - 0x05B8)
class URHPlayerInfoDisplay : public URHWidget
{
public:
	class URH_RHFriendAndPlatformFriend*          MyRHFriend;                                        // 0x05B8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URH_PlayerInfo*                         MyPlayerInfo;                                      // 0x05C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        PlayerProgressionXpClass;                          // 0x05C8(0x0020)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URHProgression*                         PlayerXpProgression;                               // 0x05E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BLUEPRINT_GetPlayerLevel(const TDelegate<void(int32 InstanceCount)>& Delegate);
	void GetPlayerPlatform(const TDelegate<void(ERHPlatformDisplayType PlatformType)>& Delegate);
	void OnPartyMemberChanged(const struct FGuid& PlayerUuid);
	void OnPlayerPresenceUpdated(class URH_PlayerInfoSubobject* PlayerPresence);
	void OnPlayerProgressionLoaded();
	void RHUpdateFriends(class URH_RHFriendAndPlatformFriend* Friend);
	void SetPlayerInfo(class URH_PlayerInfo* PlayerInfo);
	void UpdateVoiceChatDisplay(bool bInVoiceChannel, bool bIsTalking, bool bIsMuted);

	class URHProgression* GetPlayerXpProgression() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPlayerInfoDisplay">();
	}
	static class URHPlayerInfoDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPlayerInfoDisplay>();
	}
};
static_assert(alignof(URHPlayerInfoDisplay) == 0x000008, "Wrong alignment on URHPlayerInfoDisplay");
static_assert(sizeof(URHPlayerInfoDisplay) == 0x0005F0, "Wrong size on URHPlayerInfoDisplay");
static_assert(offsetof(URHPlayerInfoDisplay, MyRHFriend) == 0x0005B8, "Member 'URHPlayerInfoDisplay::MyRHFriend' has a wrong offset!");
static_assert(offsetof(URHPlayerInfoDisplay, MyPlayerInfo) == 0x0005C0, "Member 'URHPlayerInfoDisplay::MyPlayerInfo' has a wrong offset!");
static_assert(offsetof(URHPlayerInfoDisplay, PlayerProgressionXpClass) == 0x0005C8, "Member 'URHPlayerInfoDisplay::PlayerProgressionXpClass' has a wrong offset!");
static_assert(offsetof(URHPlayerInfoDisplay, PlayerXpProgression) == 0x0005E8, "Member 'URHPlayerInfoDisplay::PlayerXpProgression' has a wrong offset!");

// Class RallyHereStart.RHPlayerInputDefault
// 0x0050 (0x0078 - 0x0028)
class URHPlayerInputDefault final : public UObject
{
public:
	TArray<struct FSettingConfigPair>             SettingsConfig;                                    // 0x0028(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FRHInputActionNameTypePair>     InputActionNameTypePairs;                          // 0x0038(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FRHInputActionTiedNames>        InputActionTiedNames;                              // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FRHCustomInputActionKey>        CustomInputActionKeys;                             // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FRHCustomInputAxisKey>          CustomInputAxisKeys;                               // 0x0068(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPlayerInputDefault">();
	}
	static class URHPlayerInputDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPlayerInputDefault>();
	}
};
static_assert(alignof(URHPlayerInputDefault) == 0x000008, "Wrong alignment on URHPlayerInputDefault");
static_assert(sizeof(URHPlayerInputDefault) == 0x000078, "Wrong size on URHPlayerInputDefault");
static_assert(offsetof(URHPlayerInputDefault, SettingsConfig) == 0x000028, "Member 'URHPlayerInputDefault::SettingsConfig' has a wrong offset!");
static_assert(offsetof(URHPlayerInputDefault, InputActionNameTypePairs) == 0x000038, "Member 'URHPlayerInputDefault::InputActionNameTypePairs' has a wrong offset!");
static_assert(offsetof(URHPlayerInputDefault, InputActionTiedNames) == 0x000048, "Member 'URHPlayerInputDefault::InputActionTiedNames' has a wrong offset!");
static_assert(offsetof(URHPlayerInputDefault, CustomInputActionKeys) == 0x000058, "Member 'URHPlayerInputDefault::CustomInputActionKeys' has a wrong offset!");
static_assert(offsetof(URHPlayerInputDefault, CustomInputAxisKeys) == 0x000068, "Member 'URHPlayerInputDefault::CustomInputAxisKeys' has a wrong offset!");

// Class RallyHereStart.RHPlayerInput
// 0x0328 (0x0B18 - 0x07F0)
class URHPlayerInput : public UEnhancedPlayerInput
{
public:
	TMap<class FName, class FString>              SavedSettingsConfig;                               // 0x07F0(0x0050)(Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_840[0xF0];                                     // 0x0840(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              GamepadLookAcceleration;                           // 0x0930(0x0010)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinMouseSenseScaling;                              // 0x0940(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxMouseSenseScaling;                              // 0x0944(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnKeyMappingsUpdated;                              // 0x0948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, struct FRHCustomInputActionKeyMappings> CustomActionKeyMappings;               // 0x0958(0x0050)(Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A8[0x50];                                     // 0x09A8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FRHCustomInputAxisKeyMappings> CustomAxisKeyMappings;                   // 0x09F8(0x0050)(Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A48[0x50];                                     // 0x0A48(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URHAnalogStickFilter>       LeftAnalogStickFilterClass;                        // 0x0A98(0x0008)(ZeroConstructor, Config, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URHAnalogStickFilter>       RightAnalogStickFilterClass;                       // 0x0AA0(0x0008)(ZeroConstructor, Config, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA8[0x1C];                                     // 0x0AA8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeyMouseSwitchDelta;                               // 0x0AC4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC8[0x4];                                      // 0x0AC8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadSwitchDelta;                                // 0x0ACC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD0[0x8];                                      // 0x0AD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URHAnalogStickFilter*                   LeftAnalogStickFilter;                             // 0x0AD8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AE0[0x18];                                     // 0x0AE0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class URHAnalogStickFilter*                   RightAnalogStickFilter;                            // 0x0AF8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B00[0x18];                                     // 0x0B00(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DoesInputTypeSupportChords(EInputType InputType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPlayerInput">();
	}
	static class URHPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPlayerInput>();
	}
};
static_assert(alignof(URHPlayerInput) == 0x000008, "Wrong alignment on URHPlayerInput");
static_assert(sizeof(URHPlayerInput) == 0x000B18, "Wrong size on URHPlayerInput");
static_assert(offsetof(URHPlayerInput, SavedSettingsConfig) == 0x0007F0, "Member 'URHPlayerInput::SavedSettingsConfig' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, GamepadLookAcceleration) == 0x000930, "Member 'URHPlayerInput::GamepadLookAcceleration' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, MinMouseSenseScaling) == 0x000940, "Member 'URHPlayerInput::MinMouseSenseScaling' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, MaxMouseSenseScaling) == 0x000944, "Member 'URHPlayerInput::MaxMouseSenseScaling' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, OnKeyMappingsUpdated) == 0x000948, "Member 'URHPlayerInput::OnKeyMappingsUpdated' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, CustomActionKeyMappings) == 0x000958, "Member 'URHPlayerInput::CustomActionKeyMappings' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, CustomAxisKeyMappings) == 0x0009F8, "Member 'URHPlayerInput::CustomAxisKeyMappings' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, LeftAnalogStickFilterClass) == 0x000A98, "Member 'URHPlayerInput::LeftAnalogStickFilterClass' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, RightAnalogStickFilterClass) == 0x000AA0, "Member 'URHPlayerInput::RightAnalogStickFilterClass' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, KeyMouseSwitchDelta) == 0x000AC4, "Member 'URHPlayerInput::KeyMouseSwitchDelta' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, GamepadSwitchDelta) == 0x000ACC, "Member 'URHPlayerInput::GamepadSwitchDelta' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, LeftAnalogStickFilter) == 0x000AD8, "Member 'URHPlayerInput::LeftAnalogStickFilter' has a wrong offset!");
static_assert(offsetof(URHPlayerInput, RightAnalogStickFilter) == 0x000AF8, "Member 'URHPlayerInput::RightAnalogStickFilter' has a wrong offset!");

// Class RallyHereStart.RHPlayerState
// 0x0040 (0x0390 - 0x0350)
class ARHPlayerState : public APlayerState
{
public:
	bool                                          bSavedIsEligibleSonyMatchOwner;                    // 0x0350(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SavedSonyActivityId;                               // 0x0358(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SavedSonyMatchId;                                  // 0x0368(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RHPlayerId;                                        // 0x0378(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  RHPlayerUuid;                                      // 0x037C(0x0010)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_RHPlayerUuid();

	class URH_PlayerInfo* GetPlayerInfo(class ARHHUDCommon* HUD) const;
	int32 GetRHPlayerId() const;
	struct FGuid GetRHPlayerUuid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPlayerState">();
	}
	static class ARHPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARHPlayerState>();
	}
};
static_assert(alignof(ARHPlayerState) == 0x000008, "Wrong alignment on ARHPlayerState");
static_assert(sizeof(ARHPlayerState) == 0x000390, "Wrong size on ARHPlayerState");
static_assert(offsetof(ARHPlayerState, bSavedIsEligibleSonyMatchOwner) == 0x000350, "Member 'ARHPlayerState::bSavedIsEligibleSonyMatchOwner' has a wrong offset!");
static_assert(offsetof(ARHPlayerState, SavedSonyActivityId) == 0x000358, "Member 'ARHPlayerState::SavedSonyActivityId' has a wrong offset!");
static_assert(offsetof(ARHPlayerState, SavedSonyMatchId) == 0x000368, "Member 'ARHPlayerState::SavedSonyMatchId' has a wrong offset!");
static_assert(offsetof(ARHPlayerState, RHPlayerId) == 0x000378, "Member 'ARHPlayerState::RHPlayerId' has a wrong offset!");
static_assert(offsetof(ARHPlayerState, RHPlayerUuid) == 0x00037C, "Member 'ARHPlayerState::RHPlayerUuid' has a wrong offset!");

// Class RallyHereStart.RHPopupManager
// 0x0160 (0x0718 - 0x05B8)
class URHPopupManager : public URHWidget
{
public:
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnTimerExpired;                                    // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bUsesPopupQueue;                                   // 0x05D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewPopupsShowOverCurrent;                         // 0x05D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DA[0x6];                                      // 0x05DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRHPopupConfig>                 PopupQueue;                                        // 0x05E0(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         m_nPopupId;                                        // 0x05F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F4[0x10C];                                    // 0x05F4(0x010C)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CommittedText;                                     // 0x0700(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	int32 AddPopup(const struct FRHPopupConfig& popupData);
	void CloseAllPopups();
	void CloseUnimportantPopups();
	void HidePopup();
	void NextPopup();
	void OnPopupCanceled();
	void OnPopupResponse(int32 nPopupId, int32 nResponseIndex);
	void RemovePopup(int32 PopupId);
	void ShowPopup(const struct FRHPopupConfig& popupData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPopupManager">();
	}
	static class URHPopupManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPopupManager>();
	}
};
static_assert(alignof(URHPopupManager) == 0x000008, "Wrong alignment on URHPopupManager");
static_assert(sizeof(URHPopupManager) == 0x000718, "Wrong size on URHPopupManager");
static_assert(offsetof(URHPopupManager, OnTimerExpired) == 0x0005C8, "Member 'URHPopupManager::OnTimerExpired' has a wrong offset!");
static_assert(offsetof(URHPopupManager, bUsesPopupQueue) == 0x0005D8, "Member 'URHPopupManager::bUsesPopupQueue' has a wrong offset!");
static_assert(offsetof(URHPopupManager, bNewPopupsShowOverCurrent) == 0x0005D9, "Member 'URHPopupManager::bNewPopupsShowOverCurrent' has a wrong offset!");
static_assert(offsetof(URHPopupManager, PopupQueue) == 0x0005E0, "Member 'URHPopupManager::PopupQueue' has a wrong offset!");
static_assert(offsetof(URHPopupManager, m_nPopupId) == 0x0005F0, "Member 'URHPopupManager::m_nPopupId' has a wrong offset!");
static_assert(offsetof(URHPopupManager, CommittedText) == 0x000700, "Member 'URHPopupManager::CommittedText' has a wrong offset!");

// Class RallyHereStart.RHPortalOffersWidget
// 0x0000 (0x05B8 - 0x05B8)
class URHPortalOffersWidget final : public URHWidget
{
public:
	TArray<class URHStoreItem*> GetPortalOfferItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPortalOffersWidget">();
	}
	static class URHPortalOffersWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPortalOffersWidget>();
	}
};
static_assert(alignof(URHPortalOffersWidget) == 0x000008, "Wrong alignment on URHPortalOffersWidget");
static_assert(sizeof(URHPortalOffersWidget) == 0x0005B8, "Wrong size on URHPortalOffersWidget");

// Class RallyHereStart.RHPriceTag
// 0x0000 (0x05B8 - 0x05B8)
class URHPriceTag : public URHWidget
{
public:
	void SetPriceTag(class URHStoreItemPrice* StoreItemPrice, class URHStoreItem* StoreItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPriceTag">();
	}
	static class URHPriceTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPriceTag>();
	}
};
static_assert(alignof(URHPriceTag) == 0x000008, "Wrong alignment on URHPriceTag");
static_assert(sizeof(URHPriceTag) == 0x0005B8, "Wrong size on URHPriceTag");

// Class RallyHereStart.RHProgression
// 0x0008 (0x0180 - 0x0178)
class URHProgression final : public UPlatformInventoryItem
{
public:
	int32                                         ProgressionXpTableId;                              // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetProgressionLevel(const class UObject* WorldContextObject, int32 ProgressAmount) const;
	float GetProgressionLevelPercent(const class UObject* WorldContextObject, int32 ProgressAmount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHProgression">();
	}
	static class URHProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHProgression>();
	}
};
static_assert(alignof(URHProgression) == 0x000008, "Wrong alignment on URHProgression");
static_assert(sizeof(URHProgression) == 0x000180, "Wrong size on URHProgression");
static_assert(offsetof(URHProgression, ProgressionXpTableId) == 0x000178, "Member 'URHProgression::ProgressionXpTableId' has a wrong offset!");

// Class RallyHereStart.RHPurchaseData
// 0x0030 (0x0058 - 0x0028)
class URHPurchaseData : public UObject
{
public:
	class URHStoreItem*                           StoreItem;                                         // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PurchaseQuantity;                                  // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExternalTransactionId;                             // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Success)>  PurchaseCompletedCallback;                         // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPurchaseData">();
	}
	static class URHPurchaseData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPurchaseData>();
	}
};
static_assert(alignof(URHPurchaseData) == 0x000008, "Wrong alignment on URHPurchaseData");
static_assert(sizeof(URHPurchaseData) == 0x000058, "Wrong size on URHPurchaseData");
static_assert(offsetof(URHPurchaseData, StoreItem) == 0x000028, "Member 'URHPurchaseData::StoreItem' has a wrong offset!");
static_assert(offsetof(URHPurchaseData, PurchaseQuantity) == 0x000030, "Member 'URHPurchaseData::PurchaseQuantity' has a wrong offset!");
static_assert(offsetof(URHPurchaseData, ExternalTransactionId) == 0x000038, "Member 'URHPurchaseData::ExternalTransactionId' has a wrong offset!");
static_assert(offsetof(URHPurchaseData, PurchaseCompletedCallback) == 0x000048, "Member 'URHPurchaseData::PurchaseCompletedCallback' has a wrong offset!");

// Class RallyHereStart.RHStoreSectionItemWithPurchaseData
// 0x0008 (0x0060 - 0x0058)
class URHStoreSectionItemWithPurchaseData final : public URHPurchaseData
{
public:
	class URHStoreSectionItem*                    StoreSectionItem;                                  // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStoreSectionItemWithPurchaseData">();
	}
	static class URHStoreSectionItemWithPurchaseData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStoreSectionItemWithPurchaseData>();
	}
};
static_assert(alignof(URHStoreSectionItemWithPurchaseData) == 0x000008, "Wrong alignment on URHStoreSectionItemWithPurchaseData");
static_assert(sizeof(URHStoreSectionItemWithPurchaseData) == 0x000060, "Wrong size on URHStoreSectionItemWithPurchaseData");
static_assert(offsetof(URHStoreSectionItemWithPurchaseData, StoreSectionItem) == 0x000058, "Member 'URHStoreSectionItemWithPurchaseData::StoreSectionItem' has a wrong offset!");

// Class RallyHereStart.RHStoreItemWithPurchaseData
// 0x0000 (0x0058 - 0x0058)
class URHStoreItemWithPurchaseData final : public URHPurchaseData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStoreItemWithPurchaseData">();
	}
	static class URHStoreItemWithPurchaseData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStoreItemWithPurchaseData>();
	}
};
static_assert(alignof(URHStoreItemWithPurchaseData) == 0x000008, "Wrong alignment on URHStoreItemWithPurchaseData");
static_assert(sizeof(URHStoreItemWithPurchaseData) == 0x000058, "Wrong size on URHStoreItemWithPurchaseData");

// Class RallyHereStart.RHStoreItemWithBattlepassData
// 0x0008 (0x0060 - 0x0058)
class URHStoreItemWithBattlepassData final : public URHPurchaseData
{
public:
	class URHBattlepass*                          BattlepassItem;                                    // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStoreItemWithBattlepassData">();
	}
	static class URHStoreItemWithBattlepassData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStoreItemWithBattlepassData>();
	}
};
static_assert(alignof(URHStoreItemWithBattlepassData) == 0x000008, "Wrong alignment on URHStoreItemWithBattlepassData");
static_assert(sizeof(URHStoreItemWithBattlepassData) == 0x000060, "Wrong size on URHStoreItemWithBattlepassData");
static_assert(offsetof(URHStoreItemWithBattlepassData, BattlepassItem) == 0x000058, "Member 'URHStoreItemWithBattlepassData::BattlepassItem' has a wrong offset!");

// Class RallyHereStart.RHPurchaseConfirmationWidget
// 0x0018 (0x05D0 - 0x05B8)
class URHPurchaseConfirmationWidget final : public URHWidget
{
public:
	class URHStoreItem*                           PurchaseItem;                                      // 0x05B8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PurchaseQuantity;                                  // 0x05C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URHPurchaseData*                        PurchaseRequestData;                               // 0x05C8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BLUEPRINT_CanChangePurchaseQuantity(int32 QuantityChangeAmount, const TDelegate<void(bool IsValid)>& Delegate);
	void BLUEPRINT_TryChangePurchaseQuantity(int32 QuantityChangeAmount, const TDelegate<void(bool IsValid)>& Delegate);
	void OnPurchaseComplete(bool bCompletedPurchase);
	void PromptAlreadyPurchasing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPurchaseConfirmationWidget">();
	}
	static class URHPurchaseConfirmationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPurchaseConfirmationWidget>();
	}
};
static_assert(alignof(URHPurchaseConfirmationWidget) == 0x000008, "Wrong alignment on URHPurchaseConfirmationWidget");
static_assert(sizeof(URHPurchaseConfirmationWidget) == 0x0005D0, "Wrong size on URHPurchaseConfirmationWidget");
static_assert(offsetof(URHPurchaseConfirmationWidget, PurchaseItem) == 0x0005B8, "Member 'URHPurchaseConfirmationWidget::PurchaseItem' has a wrong offset!");
static_assert(offsetof(URHPurchaseConfirmationWidget, PurchaseQuantity) == 0x0005C0, "Member 'URHPurchaseConfirmationWidget::PurchaseQuantity' has a wrong offset!");
static_assert(offsetof(URHPurchaseConfirmationWidget, PurchaseRequestData) == 0x0005C8, "Member 'URHPurchaseConfirmationWidget::PurchaseRequestData' has a wrong offset!");

// Class RallyHereStart.RHPurchaseModal
// 0x0000 (0x05B8 - 0x05B8)
class URHPurchaseModal final : public URHWidget
{
public:
	void HandleShowPurchaseModal(class URHStoreItem* Item, class URHStoreItemPrice* Price);
	void SetupBindings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPurchaseModal">();
	}
	static class URHPurchaseModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPurchaseModal>();
	}
};
static_assert(alignof(URHPurchaseModal) == 0x000008, "Wrong alignment on URHPurchaseModal");
static_assert(sizeof(URHPurchaseModal) == 0x0005B8, "Wrong size on URHPurchaseModal");

// Class RallyHereStart.RHJsonPushNotification
// 0x0030 (0x00B8 - 0x0088)
class URHJsonPushNotification final : public URHJsonData
{
public:
	class FString                                 Header;                                            // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Body;                                              // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActivationEvent;                                   // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHJsonPushNotification">();
	}
	static class URHJsonPushNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHJsonPushNotification>();
	}
};
static_assert(alignof(URHJsonPushNotification) == 0x000008, "Wrong alignment on URHJsonPushNotification");
static_assert(sizeof(URHJsonPushNotification) == 0x0000B8, "Wrong size on URHJsonPushNotification");
static_assert(offsetof(URHJsonPushNotification, Header) == 0x000088, "Member 'URHJsonPushNotification::Header' has a wrong offset!");
static_assert(offsetof(URHJsonPushNotification, Body) == 0x000098, "Member 'URHJsonPushNotification::Body' has a wrong offset!");
static_assert(offsetof(URHJsonPushNotification, ActivationEvent) == 0x0000A8, "Member 'URHJsonPushNotification::ActivationEvent' has a wrong offset!");

// Class RallyHereStart.RHPushNotificationSubsystem
// 0x0028 (0x0058 - 0x0030)
class URHPushNotificationSubsystem final : public UGameInstanceSubsystem
{
public:
	class FString                                 JsonPanel;                                         // 0x0030(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URHJsonPushNotification*>        Notifications;                                     // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	ERHPushNotificationState                      State;                                             // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotificationPermissionGranted;                    // 0x0051(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleJsonReady(const class FString& JsonName);
	void HandleRegisteredForRemoteNotifications(const TArray<uint8>& InToken);
	void HandleRegisteredForUserNotifications(int32 Types);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPushNotificationSubsystem">();
	}
	static class URHPushNotificationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPushNotificationSubsystem>();
	}
};
static_assert(alignof(URHPushNotificationSubsystem) == 0x000008, "Wrong alignment on URHPushNotificationSubsystem");
static_assert(sizeof(URHPushNotificationSubsystem) == 0x000058, "Wrong size on URHPushNotificationSubsystem");
static_assert(offsetof(URHPushNotificationSubsystem, JsonPanel) == 0x000030, "Member 'URHPushNotificationSubsystem::JsonPanel' has a wrong offset!");
static_assert(offsetof(URHPushNotificationSubsystem, Notifications) == 0x000040, "Member 'URHPushNotificationSubsystem::Notifications' has a wrong offset!");
static_assert(offsetof(URHPushNotificationSubsystem, State) == 0x000050, "Member 'URHPushNotificationSubsystem::State' has a wrong offset!");
static_assert(offsetof(URHPushNotificationSubsystem, bNotificationPermissionGranted) == 0x000051, "Member 'URHPushNotificationSubsystem::bNotificationPermissionGranted' has a wrong offset!");

// Class RallyHereStart.RHQueueDataFactory
// 0x02A8 (0x02D0 - 0x0028)
class URHQueueDataFactory : public UObject
{
public:
	class ARHHUDCommon*                           MyHud;                                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x1];                                       // 0x0030(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSuppressCustomMatchLobby;                         // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& QueueId)> OnQueueJoined;                      // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnQueueLeft;                                       // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ERH_MatchStatus MatchStatus)> OnQueueStatusChange;                 // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnQueueDataUpdated;                                // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSetQueueId;                                      // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText ErrorText)> OnMatchStatusUpdatedError;                 // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCustomMatchJoined;                               // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCustomMatchDataChanged;                          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCustomMatchMapChanged;                           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCustomMatchNameChanged;                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EHWCustomMatchPrivacy Privacy)> OnCustomMatchPrivacyChanged;       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& NewRegionId)> OnCustomMatchRegionChanged;     // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCustomMatchLeft;                                 // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<class URH_SessionView*>& CustomSessions)> OnCustomSearchResultReceived; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URH_JoinedSession* JoinedSession)> OnRejoinedMatch;          // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bCheckForAutoRejoin;                               // 0x0128(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RHSessionType;                                     // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SessionLeaderNameFieldName;                        // 0x0140(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MapRowFieldName;                                   // 0x0150(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DefaultMapRowName;                                 // 0x0160(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GameModeInfoTagFieldName;                          // 0x0170(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LobbyNameFieldName;                                // 0x0180(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CustomMatchStartedFieldName;                       // 0x0190(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DefaultGameModeInfoTag;                            // 0x01A0(0x0008)(Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x28];                                     // 0x01A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_JoinedSession*                      CustomMatchSession;                                // 0x01D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRH_CustomMatchMember>          CustomMatchMembers;                                // 0x01D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x20];                                     // 0x01E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         QueueIds;                                          // 0x0208(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 DefaultQueueId;                                    // 0x0218(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QueueUpdatePollInterval;                           // 0x0228(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           QueueUpdateTimerHandle;                            // 0x0230(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CustomLobbyMap;                                    // 0x0238(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CustomLobbyGameMode;                               // 0x0248(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             QueueDetailsDT;                                    // 0x0260(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MapsDetailsDT;                                     // 0x0268(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URH_SessionView*>                CustomSessions;                                    // 0x0270(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         CustomMatchMaxPlayersPerTeam;                      // 0x0280(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CustomMatchMaxSpectators;                          // 0x0284(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CustomMatchSpectatorSessionTeamNum;                // 0x0288(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        QueuesDataTableClassName;                          // 0x0290(0x0020)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        MapsDataTableClassName;                            // 0x02B0(0x0020)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AcceptMatchInvite();
	void AcceptMatchRejoin();
	bool AttemptRejoinMatch();
	void AttemptToJoinCustomMatchSession(const class URH_SessionView* InSession, TDelegate<void(bool bSuccess, const class URH_SessionView* SessionToJoin)> Delegate);
	void CreateCustomMatchSession(bool bAutoLaunchSelectedQueue);
	void DeclineMatchInvite();
	void DeclineMatchRejoin();
	void DoSearchForCustomGames();
	TArray<struct FRH_CustomMatchMember> GetCustomMatchMembers();
	void GetCustomSessionLobbyName(class URH_SessionView* InSession, TDelegate<void(bool bSuccess, const class FString& SanitizedName)> Delegate);
	class FText GetCustomSessionRegionAsText(const class URH_SessionView* InSession);
	class FString GetCustomSessionRegionId(const class URH_SessionView* InSession);
	void GetLocalCustomLobbyName(TDelegate<void(bool bSuccess, const class FString& SanitizedName)> Delegate);
	void HandleCancelKickCustomPlayer();
	void HandleCancelPromoteCustomPlayer();
	void HandleConfirmKickCustomPlayer();
	void HandleConfirmLeaveCustomLobby();
	void HandleConfirmPromoteCustomPlayer();
	void InviteToCustomMatch(const struct FGuid& PlayerId, int32 TeamNum);
	void JoinQueue(const class FString& QueueId, bool bBlockIfSessionActive);
	void JoinSelectedQueue(bool bBlockIfSessionActive);
	void KickFromCustomMatch(const struct FGuid& PlayerId);
	void LeaveCustomMatchSession();
	bool LeaveMatch();
	bool LeaveQueue();
	void OnMatchJoined(class URH_JoinedSession* JoinedSession, bool bSuccess, const class FString& Error);
	void PromoteToCustomMatchHost(const struct FGuid& PlayerId);
	void SetGameModeInfoTagForCustomMatch(const struct FGameplayTag& GameModeInfoTag);
	void SetLobbyNameForCustomMatch(const class FString& InNewName);
	void SetMapForCustomMatch(class FName MapRowName);
	void SetPlayerTeamCustomMatch(const struct FGuid& PlayerId, int32 TeamId);
	void SetPrivacyForCustomMatch(EHWCustomMatchPrivacy InPrivacy);
	void SetRegionForLocalCustomMatch(const class FString& InRegionId);
	bool SetSelectedQueueId(const class FString& QueueId);
	void StartCustomMatch(bool bDedicatedInstance);

	bool CanLocalPlayerControlCustomLobbyPlayer(const struct FGuid& PlayerId) const;
	bool CanLocalPlayerKickCustomLobbyPlayer(const struct FGuid& PlayerId) const;
	bool CanLocalPlayerPromoteCustomLobbyPlayer(const struct FGuid& PlayerId) const;
	bool CanQueue() const;
	ERH_MatchStatus GetCurrentQueueMatchState() const;
	class URH_JoinedSession* GetCustomMatchSession() const;
	ERHCustomMatchStatus GetCustomMatchStatus() const;
	bool GetCustomSessionGameModeInfoTag(class URH_SessionView* InSession, struct FGameplayTag* OutGameModeInfoTag) const;
	bool GetCustomSessionMapDetails(class URH_SessionView* InSession, class FName* MapRowName, struct FRHMapDetails* MapDetails) const;
	class FString GetGameSessionType() const;
	bool GetIsCustomMatchStarted(const class URH_SessionView* InSession) const;
	bool GetIsLocalCustomMatchStarted() const;
	class FString GetLobbyLeaderBrowserInfoFieldName() const;
	class FString GetLobbyNameBrowserInfoFieldName() const;
	EHWCustomMatchPrivacy GetLocalCustomMatchPrivacy() const;
	bool GetMapDetailsFromRowName(class FName MapRowName, struct FRHMapDetails* OutMapDetails) const;
	bool GetMapPathAndTranstionInfoTagFromGameModeTag(const struct FGameplayTag& GameModeTag, class FString* OutMapPath, struct FGameplayTag* OutTransitionInfoTag) const;
	class UDataTable* GetMapsDetailsDT() const;
	int32 GetMaxPlayerCountForSessionTeams(const class URH_SessionView* InSession, const TArray<int32>& TeamIds) const;
	int32 GetPlayerCountForSessionTeams(const class URH_SessionView* InSession, const TArray<int32>& TeamIds) const;
	int32 GetPlayerTeamId(const struct FGuid& PlayerId) const;
	bool GetQueueDetailsByQueue(class URH_MatchmakingQueueInfo* Queue, struct FRHQueueDetails* QueueDetails) const;
	bool GetQueueDetailsByQueueId(const class FString& QueueId, struct FRHQueueDetails* QueueDetails) const;
	class URH_MatchmakingQueueInfo* GetQueueInfoById(const class FString& QueueId) const;
	TArray<class URH_MatchmakingQueueInfo*> GetQueues() const;
	class FName GetSelectedCustomMap() const;
	class FString GetSelectedQueueId() const;
	int32 GetTeamMemberCount(int32 TeamId) const;
	float GetTimeInQueueSeconds() const;
	bool IsCustomGameSession(const class URH_SessionView* pSession) const;
	bool IsCustomInvitePending(const struct FGuid& PlayerId) const;
	bool IsCustomMatchEnabled() const;
	bool IsInCustomLobbyWithNoInstance() const;
	bool IsInCustomMatch() const;
	bool IsInQueue() const;
	bool IsLocalPlayerCustomLobbyLeader() const;
	bool IsPlayerCustomLobbyLeader(const struct FGuid& PlayerUuid) const;
	bool IsQueueActive(const class FString& QueueId) const;
	bool ValidateActiveSessionForQueueJoin(class URH_JoinedSession* ActiveSession) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHQueueDataFactory">();
	}
	static class URHQueueDataFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHQueueDataFactory>();
	}
};
static_assert(alignof(URHQueueDataFactory) == 0x000008, "Wrong alignment on URHQueueDataFactory");
static_assert(sizeof(URHQueueDataFactory) == 0x0002D0, "Wrong size on URHQueueDataFactory");
static_assert(offsetof(URHQueueDataFactory, MyHud) == 0x000028, "Member 'URHQueueDataFactory::MyHud' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, bSuppressCustomMatchLobby) == 0x000031, "Member 'URHQueueDataFactory::bSuppressCustomMatchLobby' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnQueueJoined) == 0x000038, "Member 'URHQueueDataFactory::OnQueueJoined' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnQueueLeft) == 0x000048, "Member 'URHQueueDataFactory::OnQueueLeft' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnQueueStatusChange) == 0x000058, "Member 'URHQueueDataFactory::OnQueueStatusChange' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnQueueDataUpdated) == 0x000068, "Member 'URHQueueDataFactory::OnQueueDataUpdated' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnSetQueueId) == 0x000078, "Member 'URHQueueDataFactory::OnSetQueueId' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnMatchStatusUpdatedError) == 0x000088, "Member 'URHQueueDataFactory::OnMatchStatusUpdatedError' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnCustomMatchJoined) == 0x000098, "Member 'URHQueueDataFactory::OnCustomMatchJoined' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnCustomMatchDataChanged) == 0x0000A8, "Member 'URHQueueDataFactory::OnCustomMatchDataChanged' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnCustomMatchMapChanged) == 0x0000B8, "Member 'URHQueueDataFactory::OnCustomMatchMapChanged' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnCustomMatchNameChanged) == 0x0000C8, "Member 'URHQueueDataFactory::OnCustomMatchNameChanged' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnCustomMatchPrivacyChanged) == 0x0000D8, "Member 'URHQueueDataFactory::OnCustomMatchPrivacyChanged' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnCustomMatchRegionChanged) == 0x0000E8, "Member 'URHQueueDataFactory::OnCustomMatchRegionChanged' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnCustomMatchLeft) == 0x0000F8, "Member 'URHQueueDataFactory::OnCustomMatchLeft' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnCustomSearchResultReceived) == 0x000108, "Member 'URHQueueDataFactory::OnCustomSearchResultReceived' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, OnRejoinedMatch) == 0x000118, "Member 'URHQueueDataFactory::OnRejoinedMatch' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, bCheckForAutoRejoin) == 0x000128, "Member 'URHQueueDataFactory::bCheckForAutoRejoin' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, RHSessionType) == 0x000130, "Member 'URHQueueDataFactory::RHSessionType' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, SessionLeaderNameFieldName) == 0x000140, "Member 'URHQueueDataFactory::SessionLeaderNameFieldName' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, MapRowFieldName) == 0x000150, "Member 'URHQueueDataFactory::MapRowFieldName' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, DefaultMapRowName) == 0x000160, "Member 'URHQueueDataFactory::DefaultMapRowName' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, GameModeInfoTagFieldName) == 0x000170, "Member 'URHQueueDataFactory::GameModeInfoTagFieldName' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, LobbyNameFieldName) == 0x000180, "Member 'URHQueueDataFactory::LobbyNameFieldName' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, CustomMatchStartedFieldName) == 0x000190, "Member 'URHQueueDataFactory::CustomMatchStartedFieldName' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, DefaultGameModeInfoTag) == 0x0001A0, "Member 'URHQueueDataFactory::DefaultGameModeInfoTag' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, CustomMatchSession) == 0x0001D0, "Member 'URHQueueDataFactory::CustomMatchSession' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, CustomMatchMembers) == 0x0001D8, "Member 'URHQueueDataFactory::CustomMatchMembers' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, QueueIds) == 0x000208, "Member 'URHQueueDataFactory::QueueIds' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, DefaultQueueId) == 0x000218, "Member 'URHQueueDataFactory::DefaultQueueId' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, QueueUpdatePollInterval) == 0x000228, "Member 'URHQueueDataFactory::QueueUpdatePollInterval' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, QueueUpdateTimerHandle) == 0x000230, "Member 'URHQueueDataFactory::QueueUpdateTimerHandle' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, CustomLobbyMap) == 0x000238, "Member 'URHQueueDataFactory::CustomLobbyMap' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, CustomLobbyGameMode) == 0x000248, "Member 'URHQueueDataFactory::CustomLobbyGameMode' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, QueueDetailsDT) == 0x000260, "Member 'URHQueueDataFactory::QueueDetailsDT' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, MapsDetailsDT) == 0x000268, "Member 'URHQueueDataFactory::MapsDetailsDT' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, CustomSessions) == 0x000270, "Member 'URHQueueDataFactory::CustomSessions' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, CustomMatchMaxPlayersPerTeam) == 0x000280, "Member 'URHQueueDataFactory::CustomMatchMaxPlayersPerTeam' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, CustomMatchMaxSpectators) == 0x000284, "Member 'URHQueueDataFactory::CustomMatchMaxSpectators' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, CustomMatchSpectatorSessionTeamNum) == 0x000288, "Member 'URHQueueDataFactory::CustomMatchSpectatorSessionTeamNum' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, QueuesDataTableClassName) == 0x000290, "Member 'URHQueueDataFactory::QueuesDataTableClassName' has a wrong offset!");
static_assert(offsetof(URHQueueDataFactory, MapsDataTableClassName) == 0x0002B0, "Member 'URHQueueDataFactory::MapsDataTableClassName' has a wrong offset!");

// Class RallyHereStart.RHQueuedMessageWidget
// 0x0018 (0x05D0 - 0x05B8)
class URHQueuedMessageWidget final : public URHWidget
{
public:
	uint8                                         Pad_5B8[0x18];                                     // 0x05B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetNextMessage(class FText* Message);
	void QueueMessage(const class FText& Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHQueuedMessageWidget">();
	}
	static class URHQueuedMessageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHQueuedMessageWidget>();
	}
};
static_assert(alignof(URHQueuedMessageWidget) == 0x000008, "Wrong alignment on URHQueuedMessageWidget");
static_assert(sizeof(URHQueuedMessageWidget) == 0x0005D0, "Wrong size on URHQueuedMessageWidget");

// Class RallyHereStart.RHQueueWidgetBase
// 0x0000 (0x05B8 - 0x05B8)
class URHQueueWidgetBase : public URHWidget
{
public:
	bool CheckDeserterPartyStatus();
	class URH_MatchmakingQueueInfo* GetQueueInfoById(const class FString& QueueId);
	void GetQueuePermissions(bool* CanControl, bool* CanQueue);
	TArray<class URH_MatchmakingQueueInfo*> GetQueues();
	void HandleConfirmLeaveQueue();
	void HandleMatchStatusUpdate(ERH_MatchStatus MatchStatus);
	void HandlePartyDeserterUpdated(bool bIsDeserter, const struct FRH_PartyDeserters& DeserterStatuses);
	void HandlePartyMemberDataUpdated(const struct FRH_PartyMemberData& PartyMember);
	void HandlePartyMemberInventoryUpdated(bool bSuccess);
	void HandlePartyMemberRemoved(const struct FGuid& PartyMemberId);
	void HandlePlayerSettingsUpdated(class URH_ConfigSubsystem* ConfigSubsystem);
	void HandleSelectedQueueIdSet();
	void OnControlQueuePermissionUpdate(bool CanControl);
	void OnQueuePermissionUpdate(bool CanQueue);
	void OnQueueStateUpdate(ERH_MatchStatus CurrentMatchStatus);
	void OnSelectedQueueUpdate(class URH_MatchmakingQueueInfo* CurrentSelectedQueue);
	void ReceiveMatchStatusUpdate(ERH_MatchStatus CurrentMatchStatus);
	void RequestPartyMemberDeserterItems();
	bool SetCurrentlySelectedQueue(const class FString& QueueId);
	void SetupBindings();
	void SetupReadyForQueueing();
	bool UIX_AttemptCancelQueue();
	bool UIX_AttemptJoinSelectedQueue();
	bool UIX_AttemptLeaveMatch();
	bool UIX_AttemptRejoinMatch();
	void UpdateQueuePermissions();
	void UpdateQueueSelection();

	class URH_MatchmakingQueueInfo* GetCurrentlySelectedQueue() const;
	class URHPartyManager* GetPartyManager() const;
	class URHQueueDataFactory* GetQueueDataFactory() const;
	bool IsValidQueue(const class FString& QueueId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHQueueWidgetBase">();
	}
	static class URHQueueWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHQueueWidgetBase>();
	}
};
static_assert(alignof(URHQueueWidgetBase) == 0x000008, "Wrong alignment on URHQueueWidgetBase");
static_assert(sizeof(URHQueueWidgetBase) == 0x0005B8, "Wrong size on URHQueueWidgetBase");

// Class RallyHereStart.RHQueueTimerWidgetBase
// 0x0010 (0x05C8 - 0x05B8)
class URHQueueTimerWidgetBase : public URHQueueWidgetBase
{
public:
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateQueueTime(float TimeSecs);
	void OnUpdateQueueTimerState(EQueueTimerState State);

	EQueueTimerState GetCurrentTimerState() const;
	int32 GetQueueTime_PartHours() const;
	int32 GetQueueTime_PartMins() const;
	int32 GetQueueTime_PartSecs() const;
	float GetQueueTime_TotalSecs() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHQueueTimerWidgetBase">();
	}
	static class URHQueueTimerWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHQueueTimerWidgetBase>();
	}
};
static_assert(alignof(URHQueueTimerWidgetBase) == 0x000008, "Wrong alignment on URHQueueTimerWidgetBase");
static_assert(sizeof(URHQueueTimerWidgetBase) == 0x0005C8, "Wrong size on URHQueueTimerWidgetBase");

// Class RallyHereStart.RHQuickPlay
// 0x0030 (0x05E8 - 0x05B8)
class URHQuickPlay : public URHWidget
{
public:
	TMulticastInlineDelegate<void(class URH_MatchmakingQueueInfo* SelectedQueue)> OnSelectedQueueChanged; // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          CanCurrentlyJoinQueue;                             // 0x05C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanControlQueue;                                   // 0x05C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CA[0x6];                                      // 0x05CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DefaultSelectedQueueId;                            // 0x05D0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ReadyForQueueing;                                  // 0x05E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E1[0x7];                                      // 0x05E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URH_MatchmakingQueueInfo* GetQueueInfoById(const class FString& QueueId);
	TArray<class URH_MatchmakingQueueInfo*> GetQueues();
	void HandlePartyMemberDataUpdated(const struct FRH_PartyMemberData& PartyMember);
	void HandlePracticeButtonClicked(const class FString& LevelName, const struct FGameplayTag& TransitionTag);
	void OnControlQueuePermissionChanged(bool CanControl);
	void OnQueuePermissionChanged(bool CanQueue);
	void ReceiveMatchStatusUpdate(ERH_MatchStatus CurrentMatchStatus);
	bool SetCurrentlySelectedQueue(const class FString& QueueId);
	void SetupBindings();
	void SetupReadyForQueueing();
	void UpdateQueuePermissions();

	class URH_MatchmakingQueueInfo* GetCurrentlySelectedQueue() const;
	class FString GetDefaultSelectedQueueId() const;
	class URHPartyManager* GetPartyManager() const;
	class URHQueueDataFactory* GetQueueDataFactory() const;
	bool IsValidQueue(const class FString& QueueId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHQuickPlay">();
	}
	static class URHQuickPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHQuickPlay>();
	}
};
static_assert(alignof(URHQuickPlay) == 0x000008, "Wrong alignment on URHQuickPlay");
static_assert(sizeof(URHQuickPlay) == 0x0005E8, "Wrong size on URHQuickPlay");
static_assert(offsetof(URHQuickPlay, OnSelectedQueueChanged) == 0x0005B8, "Member 'URHQuickPlay::OnSelectedQueueChanged' has a wrong offset!");
static_assert(offsetof(URHQuickPlay, CanCurrentlyJoinQueue) == 0x0005C8, "Member 'URHQuickPlay::CanCurrentlyJoinQueue' has a wrong offset!");
static_assert(offsetof(URHQuickPlay, CanControlQueue) == 0x0005C9, "Member 'URHQuickPlay::CanControlQueue' has a wrong offset!");
static_assert(offsetof(URHQuickPlay, DefaultSelectedQueueId) == 0x0005D0, "Member 'URHQuickPlay::DefaultSelectedQueueId' has a wrong offset!");
static_assert(offsetof(URHQuickPlay, ReadyForQueueing) == 0x0005E0, "Member 'URHQuickPlay::ReadyForQueueing' has a wrong offset!");

// Class RallyHereStart.RHQuickPlayWidget
// 0x0020 (0x05D8 - 0x05B8)
class URHQuickPlayWidget : public URHQueueWidgetBase
{
public:
	uint8                                         Pad_5B8[0x20];                                     // 0x05B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetGameModeDisplayName(class FText* GameModeDisplayName);
	bool IsPendingQueueUpdate();
	void OnUpdatePenaltyTimeLeft(int32 TimeLeft);
	void OnUpdateQueueTimeElapsed(float TimeElapsed);
	void OnUpdateQuickPlayCanPlay(bool CanPlay);
	void OnUpdateQuickPlayState(EQuickPlayQueueState QueueState);
	void SetIsPendingQueueUpdate(bool IsPending);
	void UpdateState();

	EQuickPlayQueueState GetCurrentQuickPlayState() const;
	EQuickPlayQueueState GetSelectedQueueState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHQuickPlayWidget">();
	}
	static class URHQuickPlayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHQuickPlayWidget>();
	}
};
static_assert(alignof(URHQuickPlayWidget) == 0x000008, "Wrong alignment on URHQuickPlayWidget");
static_assert(sizeof(URHQuickPlayWidget) == 0x0005D8, "Wrong size on URHQuickPlayWidget");

// Class RallyHereStart.RHRedeemCodeScreenBase
// 0x0018 (0x05D0 - 0x05B8)
class URHRedeemCodeScreenBase : public URHWidget
{
public:
	uint8                                         Pad_5B8[0x18];                                     // 0x05B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRedeemCodeResult(bool Success, const class FText& Error);
	void OnRedeemCodeSubmit();
	void RedeemCode(const class FString& Code);

	bool IsPendingServerReply() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHRedeemCodeScreenBase">();
	}
	static class URHRedeemCodeScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHRedeemCodeScreenBase>();
	}
};
static_assert(alignof(URHRedeemCodeScreenBase) == 0x000008, "Wrong alignment on URHRedeemCodeScreenBase");
static_assert(sizeof(URHRedeemCodeScreenBase) == 0x0005D0, "Wrong size on URHRedeemCodeScreenBase");

// Class RallyHereStart.RHRegionSelectModalViewRedirector
// 0x0000 (0x0028 - 0x0028)
class URHRegionSelectModalViewRedirector final : public URHViewRedirecter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHRegionSelectModalViewRedirector">();
	}
	static class URHRegionSelectModalViewRedirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHRegionSelectModalViewRedirector>();
	}
};
static_assert(alignof(URHRegionSelectModalViewRedirector) == 0x000008, "Wrong alignment on URHRegionSelectModalViewRedirector");
static_assert(sizeof(URHRegionSelectModalViewRedirector) == 0x000028, "Wrong size on URHRegionSelectModalViewRedirector");

// Class RallyHereStart.RHRegionSelectModal
// 0x0000 (0x05B8 - 0x05B8)
class URHRegionSelectModal : public URHWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHRegionSelectModal">();
	}
	static class URHRegionSelectModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHRegionSelectModal>();
	}
};
static_assert(alignof(URHRegionSelectModal) == 0x000008, "Wrong alignment on URHRegionSelectModal");
static_assert(sizeof(URHRegionSelectModal) == 0x0005B8, "Wrong size on URHRegionSelectModal");

// Class RallyHereStart.RHSafeZone
// 0x0008 (0x01B8 - 0x01B0)
class URHSafeZone final : public USafeZone
{
public:
	bool                                          bBorderLeft;                                       // 0x01B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBorderRight;                                      // 0x01B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBorderTop;                                        // 0x01B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBorderBottom;                                     // 0x01B3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDrawBorders;                                 // 0x01B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B5[0x3];                                      // 0x01B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBorderSides(bool bInBorderLeft, bool bInBorderRight, bool bInBorderTop, bool bInBorderBottom);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSafeZone">();
	}
	static class URHSafeZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSafeZone>();
	}
};
static_assert(alignof(URHSafeZone) == 0x000008, "Wrong alignment on URHSafeZone");
static_assert(sizeof(URHSafeZone) == 0x0001B8, "Wrong size on URHSafeZone");
static_assert(offsetof(URHSafeZone, bBorderLeft) == 0x0001B0, "Member 'URHSafeZone::bBorderLeft' has a wrong offset!");
static_assert(offsetof(URHSafeZone, bBorderRight) == 0x0001B1, "Member 'URHSafeZone::bBorderRight' has a wrong offset!");
static_assert(offsetof(URHSafeZone, bBorderTop) == 0x0001B2, "Member 'URHSafeZone::bBorderTop' has a wrong offset!");
static_assert(offsetof(URHSafeZone, bBorderBottom) == 0x0001B3, "Member 'URHSafeZone::bBorderBottom' has a wrong offset!");
static_assert(offsetof(URHSafeZone, bForceDrawBorders) == 0x0001B4, "Member 'URHSafeZone::bForceDrawBorders' has a wrong offset!");

// Class RallyHereStart.RHUnsafeZone
// 0x0000 (0x01B0 - 0x01B0)
class URHUnsafeZone final : public USafeZone
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHUnsafeZone">();
	}
	static class URHUnsafeZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHUnsafeZone>();
	}
};
static_assert(alignof(URHUnsafeZone) == 0x000008, "Wrong alignment on URHUnsafeZone");
static_assert(sizeof(URHUnsafeZone) == 0x0001B0, "Wrong size on URHUnsafeZone");

// Class RallyHereStart.RHSettingsCallbackInterface
// 0x0000 (0x0000 - 0x0000)
class IRHSettingsCallbackInterface final
{
public:
	void BindSettingCallbacks(class FName Name_0, const struct FSettingDelegateStruct& SettingDelegateStruct);

	bool GetSettingAsBool(class FName Name_0, bool* OutBool) const;
	bool GetSettingAsFloat(class FName Name_0, float* OutFloat) const;
	bool GetSettingAsInt(class FName Name_0, int32* OutInt) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsCallbackInterface">();
	}
	static class IRHSettingsCallbackInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRHSettingsCallbackInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRHSettingsCallbackInterface) == 0x000001, "Wrong alignment on IRHSettingsCallbackInterface");
static_assert(sizeof(IRHSettingsCallbackInterface) == 0x000001, "Wrong size on IRHSettingsCallbackInterface");

// Class RallyHereStart.RHSettingsCallbackStatics
// 0x0000 (0x0028 - 0x0028)
class URHSettingsCallbackStatics final : public UBlueprintFunctionLibrary
{
public:
	static void BindSettingCallback(class FName Name_0, const struct FSettingDelegateStruct& SettingDelegateStruct, const class UObject* WorldContextObject);
	static void BindSettingCallbackToPlayer(class FName Name_0, const struct FSettingDelegateStruct& SettingDelegateStruct, class APlayerController* InPlayer);
	static bool GetLocalSettingAsBool(class FName Name_0, bool* OutBool, const class UObject* WorldContextObject);
	static bool GetLocalSettingAsBoolFromPlayer(class FName Name_0, bool* OutBool, class APlayerController* InPlayer);
	static bool GetLocalSettingAsFloat(class FName Name_0, float* OutFloat, const class UObject* WorldContextObject);
	static bool GetLocalSettingAsFloatFromPlayer(class FName Name_0, float* OutFloat, class APlayerController* InPlayer);
	static bool GetLocalSettingAsInt(class FName Name_0, int32* OutInt, const class UObject* WorldContextObject);
	static bool GetLocalSettingAsIntFromPlayer(class FName Name_0, int32* OutInt, class APlayerController* InPlayer);
	static TScriptInterface<class IRHSettingsCallbackInterface> GetLocalSettingsCallbackInterface(const class UObject* WorldContextObject);
	static TScriptInterface<class IRHSettingsCallbackInterface> GetLocalSettingsCallbackInterfaceFromPlayer(class APlayerController* InPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsCallbackStatics">();
	}
	static class URHSettingsCallbackStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsCallbackStatics>();
	}
};
static_assert(alignof(URHSettingsCallbackStatics) == 0x000008, "Wrong alignment on URHSettingsCallbackStatics");
static_assert(sizeof(URHSettingsCallbackStatics) == 0x000028, "Wrong size on URHSettingsCallbackStatics");

// Class RallyHereStart.RHSettingsColorOptionsAsset
// 0x0010 (0x0040 - 0x0030)
class URHSettingsColorOptionsAsset final : public UDataAsset
{
public:
	TArray<struct FColorOptions>                  ColorOptions;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsColorOptionsAsset">();
	}
	static class URHSettingsColorOptionsAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsColorOptionsAsset>();
	}
};
static_assert(alignof(URHSettingsColorOptionsAsset) == 0x000008, "Wrong alignment on URHSettingsColorOptionsAsset");
static_assert(sizeof(URHSettingsColorOptionsAsset) == 0x000040, "Wrong size on URHSettingsColorOptionsAsset");
static_assert(offsetof(URHSettingsColorOptionsAsset, ColorOptions) == 0x000030, "Member 'URHSettingsColorOptionsAsset::ColorOptions' has a wrong offset!");

// Class RallyHereStart.RHSettingsContainerConfigAsset
// 0x0108 (0x0138 - 0x0030)
class URHSettingsContainerConfigAsset final : public UDataAsset
{
public:
	bool                                          bIsAvailableOffline;                               // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRHAllowedPlatformTypes                AllowedPlatformTypes;                              // 0x0031(0x000A)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FRHRequiredInputTypes                  RequiredInputTypes;                                // 0x003B(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RequiredExperiment;                                // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePreview;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRHSettingsWidgetConfig>        WidgetConfigs;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SettingName;                                       // 0x0068(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class FText>              SettingNameByPlatform;                             // 0x0080(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   SettingDescription;                                // 0x00D0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class FText>              SettingDescriptionByPlatform;                      // 0x00E8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	const class FText GetSettingDescription() const;
	const class FText GetSettingName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsContainerConfigAsset">();
	}
	static class URHSettingsContainerConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsContainerConfigAsset>();
	}
};
static_assert(alignof(URHSettingsContainerConfigAsset) == 0x000008, "Wrong alignment on URHSettingsContainerConfigAsset");
static_assert(sizeof(URHSettingsContainerConfigAsset) == 0x000138, "Wrong size on URHSettingsContainerConfigAsset");
static_assert(offsetof(URHSettingsContainerConfigAsset, bIsAvailableOffline) == 0x000030, "Member 'URHSettingsContainerConfigAsset::bIsAvailableOffline' has a wrong offset!");
static_assert(offsetof(URHSettingsContainerConfigAsset, AllowedPlatformTypes) == 0x000031, "Member 'URHSettingsContainerConfigAsset::AllowedPlatformTypes' has a wrong offset!");
static_assert(offsetof(URHSettingsContainerConfigAsset, RequiredInputTypes) == 0x00003B, "Member 'URHSettingsContainerConfigAsset::RequiredInputTypes' has a wrong offset!");
static_assert(offsetof(URHSettingsContainerConfigAsset, RequiredExperiment) == 0x000040, "Member 'URHSettingsContainerConfigAsset::RequiredExperiment' has a wrong offset!");
static_assert(offsetof(URHSettingsContainerConfigAsset, bUsePreview) == 0x000050, "Member 'URHSettingsContainerConfigAsset::bUsePreview' has a wrong offset!");
static_assert(offsetof(URHSettingsContainerConfigAsset, WidgetConfigs) == 0x000058, "Member 'URHSettingsContainerConfigAsset::WidgetConfigs' has a wrong offset!");
static_assert(offsetof(URHSettingsContainerConfigAsset, SettingName) == 0x000068, "Member 'URHSettingsContainerConfigAsset::SettingName' has a wrong offset!");
static_assert(offsetof(URHSettingsContainerConfigAsset, SettingNameByPlatform) == 0x000080, "Member 'URHSettingsContainerConfigAsset::SettingNameByPlatform' has a wrong offset!");
static_assert(offsetof(URHSettingsContainerConfigAsset, SettingDescription) == 0x0000D0, "Member 'URHSettingsContainerConfigAsset::SettingDescription' has a wrong offset!");
static_assert(offsetof(URHSettingsContainerConfigAsset, SettingDescriptionByPlatform) == 0x0000E8, "Member 'URHSettingsContainerConfigAsset::SettingDescriptionByPlatform' has a wrong offset!");

// Class RallyHereStart.RHSettingsSectionConfigAsset
// 0x0078 (0x00A8 - 0x0030)
class URHSettingsSectionConfigAsset final : public UDataAsset
{
public:
	TArray<struct FRHSettingsGroupConfig>         SettingsGroups;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Heading;                                           // 0x0040(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class FText>              HeadingByPlatform;                                 // 0x0058(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	const class FText GetHeading() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsSectionConfigAsset">();
	}
	static class URHSettingsSectionConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsSectionConfigAsset>();
	}
};
static_assert(alignof(URHSettingsSectionConfigAsset) == 0x000008, "Wrong alignment on URHSettingsSectionConfigAsset");
static_assert(sizeof(URHSettingsSectionConfigAsset) == 0x0000A8, "Wrong size on URHSettingsSectionConfigAsset");
static_assert(offsetof(URHSettingsSectionConfigAsset, SettingsGroups) == 0x000030, "Member 'URHSettingsSectionConfigAsset::SettingsGroups' has a wrong offset!");
static_assert(offsetof(URHSettingsSectionConfigAsset, Heading) == 0x000040, "Member 'URHSettingsSectionConfigAsset::Heading' has a wrong offset!");
static_assert(offsetof(URHSettingsSectionConfigAsset, HeadingByPlatform) == 0x000058, "Member 'URHSettingsSectionConfigAsset::HeadingByPlatform' has a wrong offset!");

// Class RallyHereStart.RHSettingsPageConfigAsset
// 0x0078 (0x00A8 - 0x0030)
class URHSettingsPageConfigAsset final : public UDataAsset
{
public:
	TArray<class URHSettingsSectionConfigAsset*>  SettingsSectionConfigs;                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PageName;                                          // 0x0040(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class FText>              HeadingByPlatform;                                 // 0x0058(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	const class FText GetPageName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsPageConfigAsset">();
	}
	static class URHSettingsPageConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsPageConfigAsset>();
	}
};
static_assert(alignof(URHSettingsPageConfigAsset) == 0x000008, "Wrong alignment on URHSettingsPageConfigAsset");
static_assert(sizeof(URHSettingsPageConfigAsset) == 0x0000A8, "Wrong size on URHSettingsPageConfigAsset");
static_assert(offsetof(URHSettingsPageConfigAsset, SettingsSectionConfigs) == 0x000030, "Member 'URHSettingsPageConfigAsset::SettingsSectionConfigs' has a wrong offset!");
static_assert(offsetof(URHSettingsPageConfigAsset, PageName) == 0x000040, "Member 'URHSettingsPageConfigAsset::PageName' has a wrong offset!");
static_assert(offsetof(URHSettingsPageConfigAsset, HeadingByPlatform) == 0x000058, "Member 'URHSettingsPageConfigAsset::HeadingByPlatform' has a wrong offset!");

// Class RallyHereStart.RHSettingsMenuConfigAsset
// 0x0010 (0x0040 - 0x0030)
class URHSettingsMenuConfigAsset final : public UDataAsset
{
public:
	TArray<class URHSettingsPageConfigAsset*>     SettingsPageConfigs;                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsMenuConfigAsset">();
	}
	static class URHSettingsMenuConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsMenuConfigAsset>();
	}
};
static_assert(alignof(URHSettingsMenuConfigAsset) == 0x000008, "Wrong alignment on URHSettingsMenuConfigAsset");
static_assert(sizeof(URHSettingsMenuConfigAsset) == 0x000040, "Wrong size on URHSettingsMenuConfigAsset");
static_assert(offsetof(URHSettingsMenuConfigAsset, SettingsPageConfigs) == 0x000030, "Member 'URHSettingsMenuConfigAsset::SettingsPageConfigs' has a wrong offset!");

// Class RallyHereStart.RHSettingsDataFactory
// 0x0228 (0x0260 - 0x0038)
class URHSettingsDataFactory final : public URHDataFactory
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnSettingsReceivedFromPlayerAccount;               // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0xA0];                                      // 0x0050(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRHSettingPropertyId>           BoolSettingPropertyIds;                            // 0x00F0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x50];                                     // 0x0100(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRHSettingPropertyId>           IntSettingPropertyIds;                             // 0x0150(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x50];                                     // 0x0160(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRHSettingPropertyId>           FloatSettingPropertyIds;                           // 0x01B0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C0[0x60];                                     // 0x01C0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FIntPoint& SettingValue)> OnScreenResolutionApplied;  // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FIntPoint& SettingValue)> OnScreenResolutionSaved;    // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName SettingId, int32 SettingValue)> OnSettingValueChanged; // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyScreenResolution(const struct FIntPoint& ScreenResolution);
	void ApplySettingAsBool(class FName Name_0, bool Value);
	void ApplySettingAsFloat(class FName Name_0, float Value);
	void ApplySettingAsInt(class FName Name_0, int32 Value);
	bool IsUserLoggedIn();
	bool OnSettingChanged(class FName SettingId, int32 SettingValue);
	void RevertPlayerPreferences();
	void RevertScreenResolution();
	void SaveScreenResolution();
	void SaveSettingAsBool(class FName Name_0);
	void SaveSettingAsFloat(class FName Name_0);
	void SaveSettingAsInt(class FName Name_0);
	void SaveSettings();
	bool SetSelectedRegion(const class FString& RegionId);

	struct FIntPoint GetScreenResolution() const;
	class FString GetSelectedRegion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsDataFactory">();
	}
	static class URHSettingsDataFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsDataFactory>();
	}
};
static_assert(alignof(URHSettingsDataFactory) == 0x000008, "Wrong alignment on URHSettingsDataFactory");
static_assert(sizeof(URHSettingsDataFactory) == 0x000260, "Wrong size on URHSettingsDataFactory");
static_assert(offsetof(URHSettingsDataFactory, OnSettingsReceivedFromPlayerAccount) == 0x000040, "Member 'URHSettingsDataFactory::OnSettingsReceivedFromPlayerAccount' has a wrong offset!");
static_assert(offsetof(URHSettingsDataFactory, BoolSettingPropertyIds) == 0x0000F0, "Member 'URHSettingsDataFactory::BoolSettingPropertyIds' has a wrong offset!");
static_assert(offsetof(URHSettingsDataFactory, IntSettingPropertyIds) == 0x000150, "Member 'URHSettingsDataFactory::IntSettingPropertyIds' has a wrong offset!");
static_assert(offsetof(URHSettingsDataFactory, FloatSettingPropertyIds) == 0x0001B0, "Member 'URHSettingsDataFactory::FloatSettingPropertyIds' has a wrong offset!");
static_assert(offsetof(URHSettingsDataFactory, OnScreenResolutionApplied) == 0x000220, "Member 'URHSettingsDataFactory::OnScreenResolutionApplied' has a wrong offset!");
static_assert(offsetof(URHSettingsDataFactory, OnScreenResolutionSaved) == 0x000230, "Member 'URHSettingsDataFactory::OnScreenResolutionSaved' has a wrong offset!");
static_assert(offsetof(URHSettingsDataFactory, OnSettingValueChanged) == 0x000240, "Member 'URHSettingsDataFactory::OnSettingValueChanged' has a wrong offset!");

// Class RallyHereStart.RHSettingsInfoBase
// 0x0158 (0x0188 - 0x0030)
class URHSettingsInfoBase : public UPrimaryDataAsset
{
public:
	ERHSettingType                                SettingValueType;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERHSettingSaveType                            SettingSaveType;                                   // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name_0;                                            // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSaveForDataAnalysis;                              // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool ChangedExternally)> OnSettingValueChanged;                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSettingPreviewChanged;                           // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsAutoApplied;                                    // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAutoSaved;                                      // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62[0x86];                                      // 0x0062(0x0086)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           TextOptions;                                       // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   InvalidOption;                                     // 0x00F8(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnTextOptionsChanged;                              // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FString                                 DefaultValue;                                      // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EditorDefaultValue;                                // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XboxDefaultValue;                                  // 0x0140(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlaystationDefaultValue;                           // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x0164(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideDisplayRange;                             // 0x0168(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDisplayValue;                                   // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDisplayValue;                                   // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepValue;                                         // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRoundValue;                                       // 0x0178(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RoundToNearest;                                    // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPercent;                                        // 0x0180(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Apply();
	bool ApplyBoolValue(bool InBool);
	bool ApplyFloatValue(float InFloat);
	bool ApplyIntValue(int32 inInt);
	bool ApplyKeyBindValue(const struct FRHKeyBind& InKeyBind);
	void ApplyPreview();
	bool ApplyPreviewBoolValue(bool InBool);
	bool ApplyPreviewFloatValue(float InFloat);
	bool ApplyPreviewIntValue(int32 inInt);
	bool GetDirtyValueBool();
	float GetDirtyValueFloat();
	int32 GetDirtyValueInt();
	struct FRHKeyBind GetDirtyValueKeyBind();
	bool GetPreviewValueBool();
	float GetPreviewValueFloat();
	int32 GetPreviewValueInt();
	bool GetValueBool();
	float GetValueFloat();
	int32 GetValueInt();
	struct FRHKeyBind GetValueKeyBind();
	void InitializeValue();
	void OnValueBoolApplied(bool AppliedBool);
	void OnValueBoolSaved(bool SavedBool);
	void OnValueFloatApplied(float AppliedFloat);
	void OnValueFloatSaved(float SavedFloat);
	void OnValueIntApplied(int32 AppliedInt);
	void OnValueIntSaved(int32 SavedInt);
	void OnValueKeyBindApplied(const struct FRHKeyBind& AppliedKeyBind);
	void OnValueKeyBindSaved(const struct FRHKeyBind& SavedKeyBind);
	void ResetPreview();
	void Revert();
	void RevertSettingToDefault();
	void Save();
	bool SaveBoolValue(bool InBool);
	bool SaveFloatValue(float InFloat);
	bool SaveIntValue(int32 inInt);
	bool SaveKeyBindValue(const struct FRHKeyBind& InKeyBind);
	bool SetDesiredValueBool(bool InBool);
	bool SetDesiredValueFloat(float InFloat);
	bool SetDesiredValueInt(int32 inInt);
	bool SetDesiredValueKeyBind(const struct FRHKeyBind& InKeyBind);
	bool SetPreviewValueBool(bool InBool);
	bool SetPreviewValueFloat(float InFloat);
	bool SetPreviewValueInt(int32 inInt);
	void UpdateTextOptions(const TArray<class FText>& NewOptions);

	bool CanRevert() const;
	bool FixupInvalidBool(bool InBool) const;
	float FixupInvalidFloat(float InFloat) const;
	int32 FixupInvalidInt(int32 inInt) const;
	struct FRHKeyBind FixupInvalidKeyBind(const struct FRHKeyBind& InKey) const;
	bool GetIsPercent() const;
	float GetMax() const;
	float GetMaxDisplay() const;
	float GetMin() const;
	float GetMinDisplay() const;
	int32 GetNumTextOptions() const;
	class ARHHUDCommon* GetRHHUD() const;
	bool GetRound() const;
	float GetRoundToNearest() const;
	class FName GetSettingName() const;
	ERHSettingSaveType GetSettingSaveType() const;
	ERHSettingType GetSettingType() const;
	float GetStep() const;
	class FText GetTextOption(int32 Index_0) const;
	const TArray<class FText> GetTextOptions() const;
	bool IsDirty() const;
	bool IsValidValueBool(bool InBool) const;
	bool IsValidValueFloat(float InFloat) const;
	bool IsValidValueInt(int32 inInt) const;
	bool IsValidValueKeyBind(const struct FRHKeyBind& InKey) const;
	bool NeedsSave() const;
	float RoundToNearestValueFloat(float ValueToRound) const;
	bool ShouldSaveForDataAnalysis() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsInfoBase">();
	}
	static class URHSettingsInfoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsInfoBase>();
	}
};
static_assert(alignof(URHSettingsInfoBase) == 0x000008, "Wrong alignment on URHSettingsInfoBase");
static_assert(sizeof(URHSettingsInfoBase) == 0x000188, "Wrong size on URHSettingsInfoBase");
static_assert(offsetof(URHSettingsInfoBase, SettingValueType) == 0x000030, "Member 'URHSettingsInfoBase::SettingValueType' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, SettingSaveType) == 0x000031, "Member 'URHSettingsInfoBase::SettingSaveType' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, Name_0) == 0x000034, "Member 'URHSettingsInfoBase::Name_0' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, bSaveForDataAnalysis) == 0x00003C, "Member 'URHSettingsInfoBase::bSaveForDataAnalysis' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, OnSettingValueChanged) == 0x000040, "Member 'URHSettingsInfoBase::OnSettingValueChanged' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, OnSettingPreviewChanged) == 0x000050, "Member 'URHSettingsInfoBase::OnSettingPreviewChanged' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, bIsAutoApplied) == 0x000060, "Member 'URHSettingsInfoBase::bIsAutoApplied' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, bIsAutoSaved) == 0x000061, "Member 'URHSettingsInfoBase::bIsAutoSaved' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, TextOptions) == 0x0000E8, "Member 'URHSettingsInfoBase::TextOptions' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, InvalidOption) == 0x0000F8, "Member 'URHSettingsInfoBase::InvalidOption' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, OnTextOptionsChanged) == 0x000110, "Member 'URHSettingsInfoBase::OnTextOptionsChanged' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, DefaultValue) == 0x000120, "Member 'URHSettingsInfoBase::DefaultValue' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, EditorDefaultValue) == 0x000130, "Member 'URHSettingsInfoBase::EditorDefaultValue' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, XboxDefaultValue) == 0x000140, "Member 'URHSettingsInfoBase::XboxDefaultValue' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, PlaystationDefaultValue) == 0x000150, "Member 'URHSettingsInfoBase::PlaystationDefaultValue' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, MinValue) == 0x000160, "Member 'URHSettingsInfoBase::MinValue' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, MaxValue) == 0x000164, "Member 'URHSettingsInfoBase::MaxValue' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, bOverrideDisplayRange) == 0x000168, "Member 'URHSettingsInfoBase::bOverrideDisplayRange' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, MinDisplayValue) == 0x00016C, "Member 'URHSettingsInfoBase::MinDisplayValue' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, MaxDisplayValue) == 0x000170, "Member 'URHSettingsInfoBase::MaxDisplayValue' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, StepValue) == 0x000174, "Member 'URHSettingsInfoBase::StepValue' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, bRoundValue) == 0x000178, "Member 'URHSettingsInfoBase::bRoundValue' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, RoundToNearest) == 0x00017C, "Member 'URHSettingsInfoBase::RoundToNearest' has a wrong offset!");
static_assert(offsetof(URHSettingsInfoBase, bIsPercent) == 0x000180, "Member 'URHSettingsInfoBase::bIsPercent' has a wrong offset!");

// Class RallyHereStart.RHSettingsInfo_Brightness
// 0x0000 (0x0188 - 0x0188)
class URHSettingsInfo_Brightness : public URHSettingsInfoBase
{
public:
	void OnSettingApplied();
	void OnSettingSaved();

	class URHSettingsDataFactory* GetRHSettingsDataFactory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsInfo_Brightness">();
	}
	static class URHSettingsInfo_Brightness* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsInfo_Brightness>();
	}
};
static_assert(alignof(URHSettingsInfo_Brightness) == 0x000008, "Wrong alignment on URHSettingsInfo_Brightness");
static_assert(sizeof(URHSettingsInfo_Brightness) == 0x000188, "Wrong size on URHSettingsInfo_Brightness");

// Class RallyHereStart.RHSettingsInfo_Generic
// 0x0000 (0x0188 - 0x0188)
class URHSettingsInfo_Generic final : public URHSettingsInfoBase
{
public:
	void OnSettingApplied();
	void OnSettingSaved();

	class URHSettingsDataFactory* GetRHSettingsDataFactory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsInfo_Generic">();
	}
	static class URHSettingsInfo_Generic* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsInfo_Generic>();
	}
};
static_assert(alignof(URHSettingsInfo_Generic) == 0x000008, "Wrong alignment on URHSettingsInfo_Generic");
static_assert(sizeof(URHSettingsInfo_Generic) == 0x000188, "Wrong size on URHSettingsInfo_Generic");

// Class RallyHereStart.RHSettingsWidget
// 0x0050 (0x0608 - 0x05B8)
class URHSettingsWidget : public URHWidget
{
public:
	struct FRHSettingsWidgetConfig                WidgetConfig;                                      // 0x05B8(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   WidgetContainerTitle;                              // 0x05C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   WidgetContainerDescription;                        // 0x05E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasPreview;                                       // 0x05F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F9[0x7];                                      // 0x05F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URHSettingsInfoBase*                    SettingsInfo;                                      // 0x0600(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplySetting();
	bool CanGamepadNavigate();
	bool IsApplied();
	bool IsSaved();
	void OnInputAttached(bool bGamepadAttached, bool bMouseAttached);
	void OnSettingsInfoValueChanged(bool bChangedExternally);
	void OnWidgetConfigSet();
	void OnWidgetContainerDescriptionSet();
	void OnWidgetContainerPreviewSet();
	void OnWidgetContainerTitleSet();
	void OnWidgetSettingsInfoSet();
	void RevertSetting();
	void SaveSetting();

	bool HasPreview() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSettingsWidget">();
	}
	static class URHSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSettingsWidget>();
	}
};
static_assert(alignof(URHSettingsWidget) == 0x000008, "Wrong alignment on URHSettingsWidget");
static_assert(sizeof(URHSettingsWidget) == 0x000608, "Wrong size on URHSettingsWidget");
static_assert(offsetof(URHSettingsWidget, WidgetConfig) == 0x0005B8, "Member 'URHSettingsWidget::WidgetConfig' has a wrong offset!");
static_assert(offsetof(URHSettingsWidget, WidgetContainerTitle) == 0x0005C8, "Member 'URHSettingsWidget::WidgetContainerTitle' has a wrong offset!");
static_assert(offsetof(URHSettingsWidget, WidgetContainerDescription) == 0x0005E0, "Member 'URHSettingsWidget::WidgetContainerDescription' has a wrong offset!");
static_assert(offsetof(URHSettingsWidget, bHasPreview) == 0x0005F8, "Member 'URHSettingsWidget::bHasPreview' has a wrong offset!");
static_assert(offsetof(URHSettingsWidget, SettingsInfo) == 0x000600, "Member 'URHSettingsWidget::SettingsInfo' has a wrong offset!");

// Class RallyHereStart.RHShippingConsole
// 0x0000 (0x0130 - 0x0130)
class URHShippingConsole : public UShippingConsole
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHShippingConsole">();
	}
	static class URHShippingConsole* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHShippingConsole>();
	}
};
static_assert(alignof(URHShippingConsole) == 0x000008, "Wrong alignment on URHShippingConsole");
static_assert(sizeof(URHShippingConsole) == 0x000130, "Wrong size on URHShippingConsole");

// Class RallyHereStart.RHSocialPanelBase
// 0x0060 (0x0618 - 0x05B8)
class URHSocialPanelBase : public URHWidget
{
public:
	TMulticastInlineDelegate<void(const TArray<class URHDataSocialCategory*>& SortedData)> OnDataReady; // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHWidget* PlayerCard)> OnPlayerCardClicked;                 // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHWidget* Header)> OnSocialHeaderClicked;                   // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UTreeView*                              TreeView;                                          // 0x05E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URHSocialOverlay*                       DataSource;                                        // 0x05F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x10];                                     // 0x05F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URHDataSocialCategory*>          CategoriesList;                                    // 0x0608(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void GetSubListFromData(class UObject* Source, TArray<class UObject*>* Out_List);
	void OnDataChange(const TArray<struct FRHSocialOverlaySectionInfo>& Sections);
	void SetDataSource(class URHSocialOverlay* Source);
	void SetupTreeView(class UTreeView* List);
	void UpdateListData();

	class URHSocialOverlay* GetDataSource() const;
	class UTreeView* GetTreeView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSocialPanelBase">();
	}
	static class URHSocialPanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSocialPanelBase>();
	}
};
static_assert(alignof(URHSocialPanelBase) == 0x000008, "Wrong alignment on URHSocialPanelBase");
static_assert(sizeof(URHSocialPanelBase) == 0x000618, "Wrong size on URHSocialPanelBase");
static_assert(offsetof(URHSocialPanelBase, OnDataReady) == 0x0005B8, "Member 'URHSocialPanelBase::OnDataReady' has a wrong offset!");
static_assert(offsetof(URHSocialPanelBase, OnPlayerCardClicked) == 0x0005C8, "Member 'URHSocialPanelBase::OnPlayerCardClicked' has a wrong offset!");
static_assert(offsetof(URHSocialPanelBase, OnSocialHeaderClicked) == 0x0005D8, "Member 'URHSocialPanelBase::OnSocialHeaderClicked' has a wrong offset!");
static_assert(offsetof(URHSocialPanelBase, TreeView) == 0x0005E8, "Member 'URHSocialPanelBase::TreeView' has a wrong offset!");
static_assert(offsetof(URHSocialPanelBase, DataSource) == 0x0005F0, "Member 'URHSocialPanelBase::DataSource' has a wrong offset!");
static_assert(offsetof(URHSocialPanelBase, CategoriesList) == 0x000608, "Member 'URHSocialPanelBase::CategoriesList' has a wrong offset!");

// Class RallyHereStart.RHSocialFriendsPanel
// 0x0018 (0x0630 - 0x0618)
class URHSocialFriendsPanel : public URHSocialPanelBase
{
public:
	TArray<class URHDataSocialCategory*>          CategoryData;                                      // 0x0618(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	class URHSocialOverlay*                       Parent;                                            // 0x0628(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSocialFriendsPanel">();
	}
	static class URHSocialFriendsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSocialFriendsPanel>();
	}
};
static_assert(alignof(URHSocialFriendsPanel) == 0x000008, "Wrong alignment on URHSocialFriendsPanel");
static_assert(sizeof(URHSocialFriendsPanel) == 0x000630, "Wrong size on URHSocialFriendsPanel");
static_assert(offsetof(URHSocialFriendsPanel, CategoryData) == 0x000618, "Member 'URHSocialFriendsPanel::CategoryData' has a wrong offset!");
static_assert(offsetof(URHSocialFriendsPanel, Parent) == 0x000628, "Member 'URHSocialFriendsPanel::Parent' has a wrong offset!");

// Class RallyHereStart.RHSocialOverlay
// 0x0130 (0x06E8 - 0x05B8)
class URHSocialOverlay : public URHWidget
{
public:
	TMulticastInlineDelegate<void(const TArray<struct FRHSocialOverlaySectionInfo>& SectionsChanged)> OnDataChanged; // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         OSSFriendsListRefreshInterval;                     // 0x05C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGSequencePlayer*                     TransitionOutSequencePlayer;                       // 0x05D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class URHDataSocialCategory*>          CategoriesList;                                    // 0x05D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class URH_RHFriendAndPlatformFriend>, struct FRHSocialOverlaySectionInfo> PlayerCategoryMap; // 0x05F0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class URH_RHFriendAndPlatformFriend>> PlayersToUpdate;                     // 0x0640(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_650[0x10];                                     // 0x0650(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URHDataSocialPlayer*>            UnusedEntries;                                     // 0x0660(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         SessionsTypesToDisplay;                            // 0x0670(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_680[0x68];                                     // 0x0680(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLogInUserChanged();
	void HandleUpdatePlayers();
	void OnFriendsReceived();
	void OnPartyMemberChanged(const struct FGuid& PlayerUuid);
	void PlayTransition(class UWidgetAnimation* Animation, bool TransitionOut);
	void RepopulateAll();

	TArray<class URHDataSocialCategory*> GetCategories(const TArray<ERHSocialOverlaySection>& Categories) const;
	class URHDataSocialCategory* GetCategory(const struct FRHSocialOverlaySectionInfo& Section) const;
	const TArray<class URHDataSocialCategory*> GetData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSocialOverlay">();
	}
	static class URHSocialOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSocialOverlay>();
	}
};
static_assert(alignof(URHSocialOverlay) == 0x000008, "Wrong alignment on URHSocialOverlay");
static_assert(sizeof(URHSocialOverlay) == 0x0006E8, "Wrong size on URHSocialOverlay");
static_assert(offsetof(URHSocialOverlay, OnDataChanged) == 0x0005B8, "Member 'URHSocialOverlay::OnDataChanged' has a wrong offset!");
static_assert(offsetof(URHSocialOverlay, OSSFriendsListRefreshInterval) == 0x0005C8, "Member 'URHSocialOverlay::OSSFriendsListRefreshInterval' has a wrong offset!");
static_assert(offsetof(URHSocialOverlay, TransitionOutSequencePlayer) == 0x0005D0, "Member 'URHSocialOverlay::TransitionOutSequencePlayer' has a wrong offset!");
static_assert(offsetof(URHSocialOverlay, CategoriesList) == 0x0005D8, "Member 'URHSocialOverlay::CategoriesList' has a wrong offset!");
static_assert(offsetof(URHSocialOverlay, PlayerCategoryMap) == 0x0005F0, "Member 'URHSocialOverlay::PlayerCategoryMap' has a wrong offset!");
static_assert(offsetof(URHSocialOverlay, PlayersToUpdate) == 0x000640, "Member 'URHSocialOverlay::PlayersToUpdate' has a wrong offset!");
static_assert(offsetof(URHSocialOverlay, UnusedEntries) == 0x000660, "Member 'URHSocialOverlay::UnusedEntries' has a wrong offset!");
static_assert(offsetof(URHSocialOverlay, SessionsTypesToDisplay) == 0x000670, "Member 'URHSocialOverlay::SessionsTypesToDisplay' has a wrong offset!");

// Class RallyHereStart.RHSocialSearchPanel
// 0x0040 (0x0658 - 0x0618)
class URHSocialSearchPanel : public URHSocialPanelBase
{
public:
	TMulticastInlineDelegate<void()>              OnOpen;                                            // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnClose;                                           // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         VisiblePlayerCount;                                // 0x0638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63C[0x1C];                                     // 0x063C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoSearch(const class FText& SearchTerm);
	void OnOverlayClosed();
	void OnSearchComplete(const class FText& SearchTerm, const class FText& Error, const TArray<class URHDataSocialPlayer*>& Results);

	class FText GetActiveSearchTerm() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSocialSearchPanel">();
	}
	static class URHSocialSearchPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSocialSearchPanel>();
	}
};
static_assert(alignof(URHSocialSearchPanel) == 0x000008, "Wrong alignment on URHSocialSearchPanel");
static_assert(sizeof(URHSocialSearchPanel) == 0x000658, "Wrong size on URHSocialSearchPanel");
static_assert(offsetof(URHSocialSearchPanel, OnOpen) == 0x000618, "Member 'URHSocialSearchPanel::OnOpen' has a wrong offset!");
static_assert(offsetof(URHSocialSearchPanel, OnClose) == 0x000628, "Member 'URHSocialSearchPanel::OnClose' has a wrong offset!");
static_assert(offsetof(URHSocialSearchPanel, VisiblePlayerCount) == 0x000638, "Member 'URHSocialSearchPanel::VisiblePlayerCount' has a wrong offset!");

// Class RallyHereStart.RHSocialWidgetBase
// 0x0000 (0x05B8 - 0x05B8)
class URHSocialWidgetBase : public URHWidget
{
public:
	class URHPartyManager* GetPartyManager();
	void HandleFriendDataUpdated();
	void HandlePartyDataUpdated();
	void HandleSpecificPartyDataAdded(const struct FRH_PartyMemberData& PartyMember);
	void HandleSpecificPartyDataUpdated(const struct FRH_PartyMemberData& PartyMember);
	void HandleSpecificPartyIdDataUpdated(const struct FGuid& PlayerId);
	void RHUpdateFriends(const TArray<class URH_RHFriendAndPlatformFriend*>& UpdatedFriends);

	int32 GetIncomingInvitesCount() const;
	int32 GetOnlineFriendCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSocialWidgetBase">();
	}
	static class URHSocialWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSocialWidgetBase>();
	}
};
static_assert(alignof(URHSocialWidgetBase) == 0x000008, "Wrong alignment on URHSocialWidgetBase");
static_assert(sizeof(URHSocialWidgetBase) == 0x0005B8, "Wrong size on URHSocialWidgetBase");

// Class RallyHereStart.RHSortableGridPanel
// 0x0018 (0x01E0 - 0x01C8)
class URHSortableGridPanel final : public UGridPanel
{
public:
	EOrientation                                  Orientation;                                       // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const class UWidget* LHS, const class UWidget* RHS)> OnSortCompareChildrenEvent;  // 0x01CC(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGridSlot* AddChildAutoLayout(class UWidget* Content);
	void SortChildren();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSortableGridPanel">();
	}
	static class URHSortableGridPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSortableGridPanel>();
	}
};
static_assert(alignof(URHSortableGridPanel) == 0x000008, "Wrong alignment on URHSortableGridPanel");
static_assert(sizeof(URHSortableGridPanel) == 0x0001E0, "Wrong size on URHSortableGridPanel");
static_assert(offsetof(URHSortableGridPanel, Orientation) == 0x0001C8, "Member 'URHSortableGridPanel::Orientation' has a wrong offset!");
static_assert(offsetof(URHSortableGridPanel, OnSortCompareChildrenEvent) == 0x0001CC, "Member 'URHSortableGridPanel::OnSortCompareChildrenEvent' has a wrong offset!");

// Class RallyHereStart.RHSortableVerticalBox
// 0x0010 (0x01B8 - 0x01A8)
class URHSortableVerticalBox final : public UVerticalBox
{
public:
	TDelegate<void(const class UWidget* LHS, const class UWidget* RHS)> OnSortCompareChildrenEvent;  // 0x01A8(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SortChildren();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHSortableVerticalBox">();
	}
	static class URHSortableVerticalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHSortableVerticalBox>();
	}
};
static_assert(alignof(URHSortableVerticalBox) == 0x000008, "Wrong alignment on URHSortableVerticalBox");
static_assert(sizeof(URHSortableVerticalBox) == 0x0001B8, "Wrong size on URHSortableVerticalBox");
static_assert(offsetof(URHSortableVerticalBox, OnSortCompareChildrenEvent) == 0x0001A8, "Member 'URHSortableVerticalBox::OnSortCompareChildrenEvent' has a wrong offset!");

// Class RallyHereStart.RHStatsMgr
// 0x0088 (0x00B0 - 0x0028)
class URHStatsMgr final : public UObject
{
public:
	struct FRH_LootId                             PlayerXpLootId;                                    // 0x0028(0x0014)(Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_LootId                             BattlepassXpLootId;                                // 0x003C(0x0014)(Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x60];                                      // 0x0050(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FRH_LootId GetBattlepassXpLootId() const;
	const struct FRH_LootId GetPlayerXpLootId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStatsMgr">();
	}
	static class URHStatsMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStatsMgr>();
	}
};
static_assert(alignof(URHStatsMgr) == 0x000008, "Wrong alignment on URHStatsMgr");
static_assert(sizeof(URHStatsMgr) == 0x0000B0, "Wrong size on URHStatsMgr");
static_assert(offsetof(URHStatsMgr, PlayerXpLootId) == 0x000028, "Member 'URHStatsMgr::PlayerXpLootId' has a wrong offset!");
static_assert(offsetof(URHStatsMgr, BattlepassXpLootId) == 0x00003C, "Member 'URHStatsMgr::BattlepassXpLootId' has a wrong offset!");

// Class RallyHereStart.RH_Coupon
// 0x0000 (0x0178 - 0x0178)
class URH_Coupon final : public UPlatformInventoryItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_Coupon">();
	}
	static class URH_Coupon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_Coupon>();
	}
};
static_assert(alignof(URH_Coupon) == 0x000008, "Wrong alignment on URH_Coupon");
static_assert(sizeof(URH_Coupon) == 0x000178, "Wrong size on URH_Coupon");

// Class RallyHereStart.RHStorePurchaseRequest
// 0x0068 (0x0090 - 0x0028)
class URHStorePurchaseRequest final : public UObject
{
public:
	struct FRH_LootId                             LootTableItemId;                                   // 0x0028(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VendorId;                                          // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRHStorePurchaseCurrencyPrice>  CurrencyPrices;                                    // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationId;                                        // 0x0054(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExternalTransactionId;                             // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             CouponId;                                          // 0x0068(0x0014)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipCurrencyAmountValidation;                      // 0x007C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_PlayerInfo*                         RequestingPlayerInfo;                              // 0x0080(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class URHStoreSubsystem>       pStoreSubsystem;                                   // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SubmitPurchaseRequest(const TDelegate<void(bool bSuccess)>& Delegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStorePurchaseRequest">();
	}
	static class URHStorePurchaseRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStorePurchaseRequest>();
	}
};
static_assert(alignof(URHStorePurchaseRequest) == 0x000008, "Wrong alignment on URHStorePurchaseRequest");
static_assert(sizeof(URHStorePurchaseRequest) == 0x000090, "Wrong size on URHStorePurchaseRequest");
static_assert(offsetof(URHStorePurchaseRequest, LootTableItemId) == 0x000028, "Member 'URHStorePurchaseRequest::LootTableItemId' has a wrong offset!");
static_assert(offsetof(URHStorePurchaseRequest, VendorId) == 0x00003C, "Member 'URHStorePurchaseRequest::VendorId' has a wrong offset!");
static_assert(offsetof(URHStorePurchaseRequest, CurrencyPrices) == 0x000040, "Member 'URHStorePurchaseRequest::CurrencyPrices' has a wrong offset!");
static_assert(offsetof(URHStorePurchaseRequest, Quantity) == 0x000050, "Member 'URHStorePurchaseRequest::Quantity' has a wrong offset!");
static_assert(offsetof(URHStorePurchaseRequest, LocationId) == 0x000054, "Member 'URHStorePurchaseRequest::LocationId' has a wrong offset!");
static_assert(offsetof(URHStorePurchaseRequest, ExternalTransactionId) == 0x000058, "Member 'URHStorePurchaseRequest::ExternalTransactionId' has a wrong offset!");
static_assert(offsetof(URHStorePurchaseRequest, CouponId) == 0x000068, "Member 'URHStorePurchaseRequest::CouponId' has a wrong offset!");
static_assert(offsetof(URHStorePurchaseRequest, SkipCurrencyAmountValidation) == 0x00007C, "Member 'URHStorePurchaseRequest::SkipCurrencyAmountValidation' has a wrong offset!");
static_assert(offsetof(URHStorePurchaseRequest, RequestingPlayerInfo) == 0x000080, "Member 'URHStorePurchaseRequest::RequestingPlayerInfo' has a wrong offset!");
static_assert(offsetof(URHStorePurchaseRequest, pStoreSubsystem) == 0x000088, "Member 'URHStorePurchaseRequest::pStoreSubsystem' has a wrong offset!");

// Class RallyHereStart.RHPortalOffer
// 0x00B0 (0x00D8 - 0x0028)
class URHPortalOffer final : public UObject
{
public:
	class FString                                 Sku;                                               // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreSaleCost;                                       // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayPreSaleCost;                                // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Cost;                                              // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayCost;                                       // 0x0060(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CurrencyCode;                                      // 0x0078(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Name_0;                                            // 0x0090(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Desc;                                              // 0x00A8(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ShortDesc;                                         // 0x00C0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	int32 GetDiscountPercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHPortalOffer">();
	}
	static class URHPortalOffer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHPortalOffer>();
	}
};
static_assert(alignof(URHPortalOffer) == 0x000008, "Wrong alignment on URHPortalOffer");
static_assert(sizeof(URHPortalOffer) == 0x0000D8, "Wrong size on URHPortalOffer");
static_assert(offsetof(URHPortalOffer, Sku) == 0x000028, "Member 'URHPortalOffer::Sku' has a wrong offset!");
static_assert(offsetof(URHPortalOffer, PreSaleCost) == 0x000038, "Member 'URHPortalOffer::PreSaleCost' has a wrong offset!");
static_assert(offsetof(URHPortalOffer, DisplayPreSaleCost) == 0x000040, "Member 'URHPortalOffer::DisplayPreSaleCost' has a wrong offset!");
static_assert(offsetof(URHPortalOffer, Cost) == 0x000058, "Member 'URHPortalOffer::Cost' has a wrong offset!");
static_assert(offsetof(URHPortalOffer, DisplayCost) == 0x000060, "Member 'URHPortalOffer::DisplayCost' has a wrong offset!");
static_assert(offsetof(URHPortalOffer, CurrencyCode) == 0x000078, "Member 'URHPortalOffer::CurrencyCode' has a wrong offset!");
static_assert(offsetof(URHPortalOffer, Name_0) == 0x000090, "Member 'URHPortalOffer::Name_0' has a wrong offset!");
static_assert(offsetof(URHPortalOffer, Desc) == 0x0000A8, "Member 'URHPortalOffer::Desc' has a wrong offset!");
static_assert(offsetof(URHPortalOffer, ShortDesc) == 0x0000C0, "Member 'URHPortalOffer::ShortDesc' has a wrong offset!");

// Class RallyHereStart.RHStoreItemPrice
// 0x0018 (0x0040 - 0x0028)
class URHStoreItemPrice final : public UObject
{
public:
	TArray<struct FRHStoreItemCurrencyPrice>      CurrencyPrices;                                    // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class URHStoreSubsystem>       pStoreSubsystem;                                   // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BLUEPRINT_CanAfford(const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(bool IsValid)>& Delegate, int32 Quantity, class URHStoreItem* Coupon);

	int32 GetDiscountPercentage() const;
	int32 GetPriceWithCoupon(class URHStoreItem* Coupon) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStoreItemPrice">();
	}
	static class URHStoreItemPrice* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStoreItemPrice>();
	}
};
static_assert(alignof(URHStoreItemPrice) == 0x000008, "Wrong alignment on URHStoreItemPrice");
static_assert(sizeof(URHStoreItemPrice) == 0x000040, "Wrong size on URHStoreItemPrice");
static_assert(offsetof(URHStoreItemPrice, CurrencyPrices) == 0x000028, "Member 'URHStoreItemPrice::CurrencyPrices' has a wrong offset!");
static_assert(offsetof(URHStoreItemPrice, pStoreSubsystem) == 0x000038, "Member 'URHStoreItemPrice::pStoreSubsystem' has a wrong offset!");

// Class RallyHereStart.RHStoreItem
// 0x0098 (0x00C0 - 0x0028)
class URHStoreItem : public UObject
{
public:
	TMulticastInlineDelegate<void()>              OnPriceSetDirty;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPortalPurchaseSubmitted;                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class URHStoreSubsystem>       pStoreSubsystem;                                   // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UPlatformInventoryItem>  InventoryItem;                                     // 0x0080(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHPortalOffer*                         PortalOffer;                                       // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URH_GetOwnedCouponsAsyncTaskHelper*> GetOwnedCouponsTaskHelpers;                    // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void BLUEPRINT_CanAfford(const class URH_PlayerInfo* PlayerInfo, const class URHStoreItemPrice* Price, const TDelegate<void(bool IsValid)>& Delegate, int32 Quantity);
	void BLUEPRINT_CanOwnMore(const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(bool IsValid)>& Delegate);
	void BLUEPRINT_GetBestCouponForPrice(const class URHStoreItemPrice* Price, const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(class URHStoreItem* StoreItem)>& Delegate);
	void BLUEPRINT_GetCouponsForPrice(const class URHStoreItemPrice* Price, const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(const TArray<class URHStoreItem*>& StoreItems)>& Delegate);
	void BLUEPRINT_GetQuantityOwned(const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(int32 InstanceCount)>& Delegate);
	void BLUEPRINT_IsOwned(const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(bool IsValid)>& Delegate);
	void BLUEPRINT_IsRented(const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(bool IsValid)>& Delegate);
	void ConfirmGotoPortalOffer();
	int32 GetBestDiscount();
	class URHStoreItem* GetDLCForVoucher();
	class URHStoreItemPrice* GetPrice(TSoftObjectPtr<class UPlatformInventoryItem> nCurrencyType);
	TArray<class URHStoreItemPrice*> GetPrices();
	class URHStorePurchaseRequest* GetPurchaseRequest();
	class URHStorePurchaseRequest* GetPurchaseRequestFromPrice(class URHStoreItemPrice* pPrice, int32 Quantity);
	bool IsOnSale();
	void PurchaseFromPortal();
	void UIX_ShowPurchaseConfirmation(class URHStoreItemPrice* pPrice);

	bool BundleContainsItemId(const struct FRH_ItemId& nItemId, bool bSearchSubContainers) const;
	bool GetBundledContents(TArray<class URHStoreItem*>* ContainedItems) const;
	int32 GetBundleId() const;
	class FText GetDescription() const;
	class FText GetFormattedDescDisplay() const;
	class FText GetFormattedNameDisplay(int32 ExternalQuantity) const;
	class UIconInfo* GetIconInfo() const;
	TSoftObjectPtr<class UPlatformInventoryItem> GetInventoryItem() const;
	ERHAPI_InventoryOperation GetInventoryOperation() const;
	ERHAPI_InventorySelector GetInventorySelector() const;
	struct FRH_ItemId GetItemId() const;
	const struct FRH_LootId GetLootId() const;
	int32 GetLootQuantity() const;
	class FText GetName() const;
	class URHPortalOffer* GetPortalOffer() const;
	int32 GetSortOrder() const;
	int32 GetUIHint() const;
	int32 GetVendorId() const;
	bool HasPortalOffer() const;
	bool IsActive() const;
	bool IsBundleWithPriceReduction(int32* OutSubVendorId) const;
	bool ShouldDisplayToUser() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStoreItem">();
	}
	static class URHStoreItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStoreItem>();
	}
};
static_assert(alignof(URHStoreItem) == 0x000008, "Wrong alignment on URHStoreItem");
static_assert(sizeof(URHStoreItem) == 0x0000C0, "Wrong size on URHStoreItem");
static_assert(offsetof(URHStoreItem, OnPriceSetDirty) == 0x000028, "Member 'URHStoreItem::OnPriceSetDirty' has a wrong offset!");
static_assert(offsetof(URHStoreItem, OnPortalPurchaseSubmitted) == 0x000038, "Member 'URHStoreItem::OnPortalPurchaseSubmitted' has a wrong offset!");
static_assert(offsetof(URHStoreItem, pStoreSubsystem) == 0x000078, "Member 'URHStoreItem::pStoreSubsystem' has a wrong offset!");
static_assert(offsetof(URHStoreItem, InventoryItem) == 0x000080, "Member 'URHStoreItem::InventoryItem' has a wrong offset!");
static_assert(offsetof(URHStoreItem, PortalOffer) == 0x0000A8, "Member 'URHStoreItem::PortalOffer' has a wrong offset!");
static_assert(offsetof(URHStoreItem, GetOwnedCouponsTaskHelpers) == 0x0000B0, "Member 'URHStoreItem::GetOwnedCouponsTaskHelpers' has a wrong offset!");

// Class RallyHereStart.RHStoreSubsystem
// 0x02C0 (0x02F0 - 0x0030)
class URHStoreSubsystem : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(class URHStoreItem* Item, class URHStoreItemPrice* Price)> OnPurchaseItem; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHStoreItem* Item)> OnPurchasePortalItem;                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSteamOverlayDisabled;                            // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URHStorePurchaseRequest* PurchaseRequest)> OnNotEnoughCurrency; // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReceiveXpTables;                                 // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReceivePricePoints;                              // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPortalOffersReceived;                            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPendingPurchaseReceived;                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnPurchaseSubmitted;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          StoreVendorsLoaded;                                // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnStoreItemsReady;                                 // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class URH_GetAllAffordableItemsHelper*> GetOwnershipTrackers;                             // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class URHStoreItem*>      SkuToStoreItem;                                    // 0x0108(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FRH_LootId, class URHStoreItem*>  StoreItems;                                        // 0x0158(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0xA0];                                     // 0x01A8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StoreOSS;                                          // 0x0248(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          XpTablesLoaded;                                    // 0x0250(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InventoryBucketUseRuleSetsLoaded;                  // 0x0251(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PricePointsLoaded;                                 // 0x0252(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PortalOffersLoaded;                                // 0x0253(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasPortalOffers;                                  // 0x0254(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BaseStoreVendorsLoaded;                            // 0x0255(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsQueryingPortalOffers;                            // 0x0256(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_257[0x1];                                      // 0x0257(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PortalOffersVendorId;                              // 0x0258(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StoreVendorId;                                     // 0x025C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GameCurrencyVendorId;                              // 0x0260(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DailyRotationVendorId;                             // 0x0264(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CouponVendorId;                                    // 0x0268(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EpicVoucherVendorId;                               // 0x026C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ValveVoucherVendorId;                              // 0x0270(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NintendoVoucherVendorId;                           // 0x0274(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MicrosoftVoucherVendorId;                          // 0x0278(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SonyVoucherVendorId;                               // 0x027C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class URHCurrency>             FreeCurrencyItemSoftPtr;                           // 0x0280(0x0028)(BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class URHCurrency>             PremiumCurrencyItemSoftPtr;                        // 0x02A8(0x0028)(BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHCurrency*                            PremiumCurrencyItem;                               // 0x02D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHCurrency*                            FreeCurrencyItem;                                  // 0x02D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URH_PurchaseAsyncTaskHelper*            PurchaseTaskHelper;                                // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AreInventoryBucketUseRuleSetsLoaded();
	bool ArePortalOffersLoaded();
	bool ArePricePointsLoaded();
	bool AreXpTablesLoaded();
	void BLUEPRINT_RequestVendorData(const TArray<int32>& VendorIds, const TDelegate<void(bool bSuccess)>& Delegate);
	bool CheckEmptyInGameStore(const class UObject* WorldContextObject);
	void EnterInGameStoreUI();
	void ExitInGameStoreUI();
	class URHStoreItem* GetStoreItem(const struct FRH_LootId& LootId);
	class URHStoreItem* GetStoreItemForVendor(int32 nVendorId, const struct FRH_LootId& nLootItemId);
	TArray<class URHStoreItem*> GetStoreItemsAndQuantitiesForVendor(int32 nVendorId, bool bIncludeInactiveItems, bool bSearchSubContainers, TMap<struct FRH_LootId, int32>* QuantityMap, int32 ExternalQuantity);
	TArray<class URHStoreItem*> GetStoreItemsForVendor(int32 nVendorId, bool bIncludeInactiveItems, bool bSearchSubContainers);
	bool GetXpTable(int32 XpTableId, struct FRHAPI_XpTable* XpTable);
	void OnEntitlementResult(const TArray<struct FRHAPI_PlayerOrder>& OrderResults, const class URH_PlayerInfo* PlayerInfo);
	void OnInventoryBucketUseRuleSetsUpdated(bool Success);
	void OnPricePointsUpdated(bool Success);
	void OnStoreVendorsUpdated(bool Success);
	void OnXpTablesUpdated(bool Success);
	void RedeemDLCVoucher(class URHStoreItem* DLCVoucher, class URH_PlayerInfo* PlayerInfo, const TDelegate<void(bool bSuccess)>& Delegate);
	void UIX_CompletePurchaseItem(class URHStorePurchaseRequest* PurchaseRequest, const TDelegate<void(bool bSuccess)>& Delegate);

	bool DoesPortalHaveOffers() const;
	class URHCurrency* GetCurrencyItem(const struct FRH_ItemId& ItemId) const;
	class URHCurrency* GetFreeCurrencyItem() const;
	TArray<class URHStorePurchaseRequest*> GetPendingPurchaseData() const;
	class URHCurrency* GetPremiumCurrencyItem() const;
	bool HasPendingPurchase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStoreSubsystem">();
	}
	static class URHStoreSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStoreSubsystem>();
	}
};
static_assert(alignof(URHStoreSubsystem) == 0x000008, "Wrong alignment on URHStoreSubsystem");
static_assert(sizeof(URHStoreSubsystem) == 0x0002F0, "Wrong size on URHStoreSubsystem");
static_assert(offsetof(URHStoreSubsystem, OnPurchaseItem) == 0x000030, "Member 'URHStoreSubsystem::OnPurchaseItem' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, OnPurchasePortalItem) == 0x000040, "Member 'URHStoreSubsystem::OnPurchasePortalItem' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, OnSteamOverlayDisabled) == 0x000050, "Member 'URHStoreSubsystem::OnSteamOverlayDisabled' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, OnNotEnoughCurrency) == 0x000060, "Member 'URHStoreSubsystem::OnNotEnoughCurrency' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, OnReceiveXpTables) == 0x000070, "Member 'URHStoreSubsystem::OnReceiveXpTables' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, OnReceivePricePoints) == 0x000080, "Member 'URHStoreSubsystem::OnReceivePricePoints' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, OnPortalOffersReceived) == 0x000090, "Member 'URHStoreSubsystem::OnPortalOffersReceived' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, OnPendingPurchaseReceived) == 0x0000A0, "Member 'URHStoreSubsystem::OnPendingPurchaseReceived' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, OnPurchaseSubmitted) == 0x0000C0, "Member 'URHStoreSubsystem::OnPurchaseSubmitted' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, StoreVendorsLoaded) == 0x0000D0, "Member 'URHStoreSubsystem::StoreVendorsLoaded' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, OnStoreItemsReady) == 0x0000D8, "Member 'URHStoreSubsystem::OnStoreItemsReady' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, GetOwnershipTrackers) == 0x0000E8, "Member 'URHStoreSubsystem::GetOwnershipTrackers' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, SkuToStoreItem) == 0x000108, "Member 'URHStoreSubsystem::SkuToStoreItem' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, StoreItems) == 0x000158, "Member 'URHStoreSubsystem::StoreItems' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, StoreOSS) == 0x000248, "Member 'URHStoreSubsystem::StoreOSS' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, XpTablesLoaded) == 0x000250, "Member 'URHStoreSubsystem::XpTablesLoaded' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, InventoryBucketUseRuleSetsLoaded) == 0x000251, "Member 'URHStoreSubsystem::InventoryBucketUseRuleSetsLoaded' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, PricePointsLoaded) == 0x000252, "Member 'URHStoreSubsystem::PricePointsLoaded' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, PortalOffersLoaded) == 0x000253, "Member 'URHStoreSubsystem::PortalOffersLoaded' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, bHasPortalOffers) == 0x000254, "Member 'URHStoreSubsystem::bHasPortalOffers' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, BaseStoreVendorsLoaded) == 0x000255, "Member 'URHStoreSubsystem::BaseStoreVendorsLoaded' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, IsQueryingPortalOffers) == 0x000256, "Member 'URHStoreSubsystem::IsQueryingPortalOffers' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, PortalOffersVendorId) == 0x000258, "Member 'URHStoreSubsystem::PortalOffersVendorId' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, StoreVendorId) == 0x00025C, "Member 'URHStoreSubsystem::StoreVendorId' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, GameCurrencyVendorId) == 0x000260, "Member 'URHStoreSubsystem::GameCurrencyVendorId' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, DailyRotationVendorId) == 0x000264, "Member 'URHStoreSubsystem::DailyRotationVendorId' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, CouponVendorId) == 0x000268, "Member 'URHStoreSubsystem::CouponVendorId' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, EpicVoucherVendorId) == 0x00026C, "Member 'URHStoreSubsystem::EpicVoucherVendorId' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, ValveVoucherVendorId) == 0x000270, "Member 'URHStoreSubsystem::ValveVoucherVendorId' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, NintendoVoucherVendorId) == 0x000274, "Member 'URHStoreSubsystem::NintendoVoucherVendorId' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, MicrosoftVoucherVendorId) == 0x000278, "Member 'URHStoreSubsystem::MicrosoftVoucherVendorId' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, SonyVoucherVendorId) == 0x00027C, "Member 'URHStoreSubsystem::SonyVoucherVendorId' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, FreeCurrencyItemSoftPtr) == 0x000280, "Member 'URHStoreSubsystem::FreeCurrencyItemSoftPtr' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, PremiumCurrencyItemSoftPtr) == 0x0002A8, "Member 'URHStoreSubsystem::PremiumCurrencyItemSoftPtr' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, PremiumCurrencyItem) == 0x0002D0, "Member 'URHStoreSubsystem::PremiumCurrencyItem' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, FreeCurrencyItem) == 0x0002D8, "Member 'URHStoreSubsystem::FreeCurrencyItem' has a wrong offset!");
static_assert(offsetof(URHStoreSubsystem, PurchaseTaskHelper) == 0x0002E0, "Member 'URHStoreSubsystem::PurchaseTaskHelper' has a wrong offset!");

// Class RallyHereStart.RH_PurchaseAsyncTaskHelper
// 0x0038 (0x0060 - 0x0028)
class URH_PurchaseAsyncTaskHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_CatalogSubsystem*                   CatalogSubsystem;                                  // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URHStoreSubsystem*                      StoreSubsystem;                                    // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URHStorePurchaseRequest*>        PurchaseRequests;                                  // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_PurchaseAsyncTaskHelper">();
	}
	static class URH_PurchaseAsyncTaskHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_PurchaseAsyncTaskHelper>();
	}
};
static_assert(alignof(URH_PurchaseAsyncTaskHelper) == 0x000008, "Wrong alignment on URH_PurchaseAsyncTaskHelper");
static_assert(sizeof(URH_PurchaseAsyncTaskHelper) == 0x000060, "Wrong size on URH_PurchaseAsyncTaskHelper");
static_assert(offsetof(URH_PurchaseAsyncTaskHelper, CatalogSubsystem) == 0x000030, "Member 'URH_PurchaseAsyncTaskHelper::CatalogSubsystem' has a wrong offset!");
static_assert(offsetof(URH_PurchaseAsyncTaskHelper, StoreSubsystem) == 0x000038, "Member 'URH_PurchaseAsyncTaskHelper::StoreSubsystem' has a wrong offset!");
static_assert(offsetof(URH_PurchaseAsyncTaskHelper, PurchaseRequests) == 0x000050, "Member 'URH_PurchaseAsyncTaskHelper::PurchaseRequests' has a wrong offset!");

// Class RallyHereStart.RH_GetOwnedCouponsAsyncTaskHelper
// 0x0040 (0x0068 - 0x0028)
class URH_GetOwnedCouponsAsyncTaskHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_PlayerInventory*                    PlayerInventory;                                   // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URHStoreItem*>                   ItemsToCheck;                                      // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class URHStoreItem*>                   OwnedItems;                                        // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_GetOwnedCouponsAsyncTaskHelper">();
	}
	static class URH_GetOwnedCouponsAsyncTaskHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_GetOwnedCouponsAsyncTaskHelper>();
	}
};
static_assert(alignof(URH_GetOwnedCouponsAsyncTaskHelper) == 0x000008, "Wrong alignment on URH_GetOwnedCouponsAsyncTaskHelper");
static_assert(sizeof(URH_GetOwnedCouponsAsyncTaskHelper) == 0x000068, "Wrong size on URH_GetOwnedCouponsAsyncTaskHelper");
static_assert(offsetof(URH_GetOwnedCouponsAsyncTaskHelper, PlayerInventory) == 0x000040, "Member 'URH_GetOwnedCouponsAsyncTaskHelper::PlayerInventory' has a wrong offset!");
static_assert(offsetof(URH_GetOwnedCouponsAsyncTaskHelper, ItemsToCheck) == 0x000048, "Member 'URH_GetOwnedCouponsAsyncTaskHelper::ItemsToCheck' has a wrong offset!");
static_assert(offsetof(URH_GetOwnedCouponsAsyncTaskHelper, OwnedItems) == 0x000058, "Member 'URH_GetOwnedCouponsAsyncTaskHelper::OwnedItems' has a wrong offset!");

// Class RallyHereStart.RH_GetAllAffordableItemsHelper
// 0x00B8 (0x00E0 - 0x0028)
class URH_GetAllAffordableItemsHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URHStoreItem*>                   PurchaseItems;                                     // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UPlatformInventoryItem>> CurrencyItems;                              // 0x0060(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URHStoreSubsystem*                      StoreSubsystem;                                    // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class URHStoreItem*, class URHStoreItemPrice*> ItemsToCheck;                                // 0x0080(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<class URHStoreItem*>                   AffordableItems;                                   // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_GetAllAffordableItemsHelper">();
	}
	static class URH_GetAllAffordableItemsHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_GetAllAffordableItemsHelper>();
	}
};
static_assert(alignof(URH_GetAllAffordableItemsHelper) == 0x000008, "Wrong alignment on URH_GetAllAffordableItemsHelper");
static_assert(sizeof(URH_GetAllAffordableItemsHelper) == 0x0000E0, "Wrong size on URH_GetAllAffordableItemsHelper");
static_assert(offsetof(URH_GetAllAffordableItemsHelper, PurchaseItems) == 0x000050, "Member 'URH_GetAllAffordableItemsHelper::PurchaseItems' has a wrong offset!");
static_assert(offsetof(URH_GetAllAffordableItemsHelper, CurrencyItems) == 0x000060, "Member 'URH_GetAllAffordableItemsHelper::CurrencyItems' has a wrong offset!");
static_assert(offsetof(URH_GetAllAffordableItemsHelper, PlayerInfo) == 0x000070, "Member 'URH_GetAllAffordableItemsHelper::PlayerInfo' has a wrong offset!");
static_assert(offsetof(URH_GetAllAffordableItemsHelper, StoreSubsystem) == 0x000078, "Member 'URH_GetAllAffordableItemsHelper::StoreSubsystem' has a wrong offset!");
static_assert(offsetof(URH_GetAllAffordableItemsHelper, ItemsToCheck) == 0x000080, "Member 'URH_GetAllAffordableItemsHelper::ItemsToCheck' has a wrong offset!");
static_assert(offsetof(URH_GetAllAffordableItemsHelper, AffordableItems) == 0x0000D0, "Member 'URH_GetAllAffordableItemsHelper::AffordableItems' has a wrong offset!");

// Class RallyHereStart.RHStorePanelItem
// 0x0028 (0x0050 - 0x0028)
class URHStorePanelItem final : public UObject
{
public:
	class URHStoreItem*                           StoreItem;                                         // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisplaySaleTag;                                    // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenSeen;                                       // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CustomBannerText;                                  // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	bool IsOnSale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStorePanelItem">();
	}
	static class URHStorePanelItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStorePanelItem>();
	}
};
static_assert(alignof(URHStorePanelItem) == 0x000008, "Wrong alignment on URHStorePanelItem");
static_assert(sizeof(URHStorePanelItem) == 0x000050, "Wrong size on URHStorePanelItem");
static_assert(offsetof(URHStorePanelItem, StoreItem) == 0x000028, "Member 'URHStorePanelItem::StoreItem' has a wrong offset!");
static_assert(offsetof(URHStorePanelItem, IsNew) == 0x000030, "Member 'URHStorePanelItem::IsNew' has a wrong offset!");
static_assert(offsetof(URHStorePanelItem, DisplaySaleTag) == 0x000031, "Member 'URHStorePanelItem::DisplaySaleTag' has a wrong offset!");
static_assert(offsetof(URHStorePanelItem, HasBeenSeen) == 0x000032, "Member 'URHStorePanelItem::HasBeenSeen' has a wrong offset!");
static_assert(offsetof(URHStorePanelItem, CustomBannerText) == 0x000038, "Member 'URHStorePanelItem::CustomBannerText' has a wrong offset!");

// Class RallyHereStart.RHStoreSectionItem
// 0x0028 (0x0050 - 0x0028)
class URHStoreSectionItem final : public UObject
{
public:
	TArray<class URHStorePanelItem*>              StorePanelItems;                                   // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Column;                                            // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Row;                                               // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStoreItemWidgetType                          WidgetType;                                        // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URHStorePanelItem*                      CurrentlyViewedItem;                               // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool HasUnseenItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStoreSectionItem">();
	}
	static class URHStoreSectionItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStoreSectionItem>();
	}
};
static_assert(alignof(URHStoreSectionItem) == 0x000008, "Wrong alignment on URHStoreSectionItem");
static_assert(sizeof(URHStoreSectionItem) == 0x000050, "Wrong size on URHStoreSectionItem");
static_assert(offsetof(URHStoreSectionItem, StorePanelItems) == 0x000028, "Member 'URHStoreSectionItem::StorePanelItems' has a wrong offset!");
static_assert(offsetof(URHStoreSectionItem, Column) == 0x000038, "Member 'URHStoreSectionItem::Column' has a wrong offset!");
static_assert(offsetof(URHStoreSectionItem, Row) == 0x00003C, "Member 'URHStoreSectionItem::Row' has a wrong offset!");
static_assert(offsetof(URHStoreSectionItem, WidgetType) == 0x000040, "Member 'URHStoreSectionItem::WidgetType' has a wrong offset!");
static_assert(offsetof(URHStoreSectionItem, CurrentlyViewedItem) == 0x000048, "Member 'URHStoreSectionItem::CurrentlyViewedItem' has a wrong offset!");

// Class RallyHereStart.RHStoreSection
// 0x0038 (0x0060 - 0x0028)
class URHStoreSection final : public UObject
{
public:
	TArray<class URHStoreSectionItem*>            SectionItems;                                      // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EStoreSectionTypes                            SectionType;                                       // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x27];                                      // 0x0039(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetSecondsRemaining() const;
	class FText GetSectionHeader() const;
	bool HasUnseenItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStoreSection">();
	}
	static class URHStoreSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStoreSection>();
	}
};
static_assert(alignof(URHStoreSection) == 0x000008, "Wrong alignment on URHStoreSection");
static_assert(sizeof(URHStoreSection) == 0x000060, "Wrong size on URHStoreSection");
static_assert(offsetof(URHStoreSection, SectionItems) == 0x000028, "Member 'URHStoreSection::SectionItems' has a wrong offset!");
static_assert(offsetof(URHStoreSection, SectionType) == 0x000038, "Member 'URHStoreSection::SectionType' has a wrong offset!");

// Class RallyHereStart.RHStoreWidget
// 0x0000 (0x05B8 - 0x05B8)
class URHStoreWidget final : public URHWidget
{
public:
	TArray<class URHStoreSection*> GetStoreLayout(int32* ErrorCode);
	void OnPortalOffersReceived();
	void OnPricePointsReveived();

	bool HasAllRequiredStoreInformation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHStoreWidget">();
	}
	static class URHStoreWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHStoreWidget>();
	}
};
static_assert(alignof(URHStoreWidget) == 0x000008, "Wrong alignment on URHStoreWidget");
static_assert(sizeof(URHStoreWidget) == 0x0005B8, "Wrong size on URHStoreWidget");

// Class RallyHereStart.RHTabScreenWidget
// 0x0018 (0x05D0 - 0x05B8)
class URHTabScreenWidget final : public URHWidget
{
public:
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ScoreboardViewTag;                                 // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddPlayerToScoreboard(int32 TeamNum, const class FString& PlayerName);
	void ClearScoreboard();
	void HandleScoreboardReleased();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHTabScreenWidget">();
	}
	static class URHTabScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHTabScreenWidget>();
	}
};
static_assert(alignof(URHTabScreenWidget) == 0x000008, "Wrong alignment on URHTabScreenWidget");
static_assert(sizeof(URHTabScreenWidget) == 0x0005D0, "Wrong size on URHTabScreenWidget");
static_assert(offsetof(URHTabScreenWidget, ScoreboardViewTag) == 0x0005C8, "Member 'URHTabScreenWidget::ScoreboardViewTag' has a wrong offset!");

// Class RallyHereStart.RHTitle
// 0x0018 (0x0190 - 0x0178)
class URHTitle final : public UPlatformInventoryItem
{
public:
	class FText                                   TitleText;                                         // 0x0178(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHTitle">();
	}
	static class URHTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHTitle>();
	}
};
static_assert(alignof(URHTitle) == 0x000008, "Wrong alignment on URHTitle");
static_assert(sizeof(URHTitle) == 0x000190, "Wrong size on URHTitle");
static_assert(offsetof(URHTitle, TitleText) == 0x000178, "Member 'URHTitle::TitleText' has a wrong offset!");

// Class RallyHereStart.RHToastNotificationWidgetBase
// 0x0040 (0x05F8 - 0x05B8)
class URHToastNotificationWidgetBase : public URHWidget
{
public:
	TMulticastInlineDelegate<void()>              OnToastReceived;                                   // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MaxToastNotification;                              // 0x05C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentToastCount;                                 // 0x05CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBusy;                                            // 0x05D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D1[0x7];                                      // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FToastData>                     ToastQueue;                                        // 0x05D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FToastData>                     PostMatchToasts;                                   // 0x05E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void ClearNotificationQueue();
	void ClearPostMatchQueue();
	class URH_FriendSubsystem* GetFriendSubsystem();
	bool GetNext(struct FToastData* NextToastNotification);
	class URHPartyManager* GetPartyManager();
	void HandlePartyDisbanded();
	void HandlePartyInviteAccepted();
	void HandlePartyInviteError(const class FText& PlayerName);
	void HandlePartyInviteReceived(class URH_PlayerInfo* PartyInviter);
	void HandlePartyInviteRejected();
	void HandlePartyInviteSent(class URH_PlayerInfo* Invitee);
	void HandlePartyLocalPlayerLeft();
	void HandlePartyMemberAdded(const struct FRH_PartyMemberData& PartyMemberData);
	void HandlePartyMemberKick(const struct FGuid& PlayerId);
	void HandlePartyMemberLeft(const struct FRH_PartyMemberData& PartyMemberData);
	void HandlePartyMemberLeftGeneric();
	void HandlePartyMemberPromoted(const struct FGuid& PlayerId);
	void NotifyToastHidden();
	void NotifyToastShown();
	void OnFriendUpdated(class URH_RHFriendAndPlatformFriend* UpdatedFriend);
	void OnToastNotificationReceived(const struct FToastData& ToastData);
	void ShowToastNotification();
	void StoreToastQueue(const struct FToastData& ToastNotification);

	TArray<struct FToastData> GetPostMatchToasts() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHToastNotificationWidgetBase">();
	}
	static class URHToastNotificationWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHToastNotificationWidgetBase>();
	}
};
static_assert(alignof(URHToastNotificationWidgetBase) == 0x000008, "Wrong alignment on URHToastNotificationWidgetBase");
static_assert(sizeof(URHToastNotificationWidgetBase) == 0x0005F8, "Wrong size on URHToastNotificationWidgetBase");
static_assert(offsetof(URHToastNotificationWidgetBase, OnToastReceived) == 0x0005B8, "Member 'URHToastNotificationWidgetBase::OnToastReceived' has a wrong offset!");
static_assert(offsetof(URHToastNotificationWidgetBase, MaxToastNotification) == 0x0005C8, "Member 'URHToastNotificationWidgetBase::MaxToastNotification' has a wrong offset!");
static_assert(offsetof(URHToastNotificationWidgetBase, CurrentToastCount) == 0x0005CC, "Member 'URHToastNotificationWidgetBase::CurrentToastCount' has a wrong offset!");
static_assert(offsetof(URHToastNotificationWidgetBase, IsBusy) == 0x0005D0, "Member 'URHToastNotificationWidgetBase::IsBusy' has a wrong offset!");
static_assert(offsetof(URHToastNotificationWidgetBase, ToastQueue) == 0x0005D8, "Member 'URHToastNotificationWidgetBase::ToastQueue' has a wrong offset!");
static_assert(offsetof(URHToastNotificationWidgetBase, PostMatchToasts) == 0x0005E8, "Member 'URHToastNotificationWidgetBase::PostMatchToasts' has a wrong offset!");

// Class RallyHereStart.RHTreeView
// 0x0000 (0x0CD0 - 0x0CD0)
class URHTreeView final : public UTreeView
{
public:
	TWeakObjectPtr<class ARHHUDCommon>            MyHud;                                             // 0x0CC8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeWidget();
	void NavigateSelectItem(class UObject* Item);
	void UninitializeWidget();

	bool BP_GetEntryWidgetFromItem(const class UObject* Item, class UUserWidget** OutWidget) const;
	int32 GetNumItemsInLayout() const;
	bool IsItemExpanded(const class UObject* Item) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHTreeView">();
	}
	static class URHTreeView* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHTreeView>();
	}
};
static_assert(alignof(URHTreeView) == 0x000010, "Wrong alignment on URHTreeView");
static_assert(sizeof(URHTreeView) == 0x000CD0, "Wrong size on URHTreeView");
static_assert(offsetof(URHTreeView, MyHud) == 0x000CC8, "Member 'URHTreeView::MyHud' has a wrong offset!");

// Class RallyHereStart.RHUIBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URHUIBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AllowActionsOnOfflinePlayers(const class UObject* WorldContextObject);
	static bool CanEnterPracticeMode(const class UObject* WorldContextObject);
	static bool CanReportPlayer(const struct FReportPlayerParams& Params_0);
	static bool CanReportServer(const class UObject* WorldContextObject);
	static bool CanViewPlatformProfileForPlayerState(class ARHHUDCommon* pHUD, class ARHPlayerState* PlayerState);
	static void CheckPlayerBlockedAsync(const struct FGuid& RHPlayerUuid, class URH_SessionView* pSession, const class URH_FriendSubsystem* pFriendSubsystem, const TDelegate<void(bool bIsBlocked)>& Delegate);
	static int32 CompareStrings(const class FString& LeftString, const class FString& RightString);
	static ERHPlatformDisplayType ConvertPlatformTypeToDisplayType(class ARHHUDCommon* pHUD, ERHAPI_Platform PlatformType);
	static class URHSettingsWidget* CreateSettingsWidget(class ARHHUDCommon* HUD, const TSubclassOf<class URHSettingsWidget>& SettingsWidgetClass);
	static class URHSettingsWidget* CreateSettingsWidgetWithConfig(class ARHHUDCommon* HUD, const struct FRHSettingsWidgetConfig& SettingsWidgetConfig);
	static class URHBattlepass* GetActiveBattlepass(const class UObject* WorldContextObject);
	static class URHCurrency* GetCurrencyItemByItemId(const struct FRH_ItemId& CurrencyItemId);
	static ERHPlayerOnlineStatus GetFriendOnlineStatus(const class UObject* WorldContextObject, const class URH_RHFriendAndPlatformFriend* Friend, const class URH_LocalPlayerSubsystem* LocalPlayerSS, bool bAllowPartyStatus, bool bAllowFriendRequestStatus);
	static class FText GetFriendStatusMessage(const class UObject* WorldContextObject, const class URH_RHFriendAndPlatformFriend* Friend, const class URH_LocalPlayerSubsystem* LocalPlayerSS);
	static struct FKey GetGamepadCancelButton();
	static struct FKey GetGamepadConfirmButton();
	static EGamepadIcons GetGamepadIconSet();
	static class ARHGameState* GetGameState(const class UObject* WorldContextObject);
	static struct FKey GetKeyForBinding(class APlayerController* PlayerController, class FName Binding, bool SecondaryKey, bool FallbackToDefault, bool IsGamepadDoubleTap);
	static class FName GetKeyName(const struct FKey& Key);
	static class APlayerController* GetLocalPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class URH_PlayerInfo* GetLocalPlayerInfo(class ARHHUDCommon* HUD);
	static ERHAPI_Platform GetLocalPlayerPlatformId(class ARHHUDCommon* pHUD);
	static ERHAPI_Platform GetLoggedInPlatformId(class ARHHUDCommon* pHUD);
	static void GetPCPlatform(bool* OutIsSteam, bool* OutIsEpic);
	static ERHPlatformDisplayType GetPlatformDisplayTypeFromFriend(class ARHHUDCommon* pHUD, class URH_RHFriendAndPlatformFriend* Friend);
	static void GetPlatformDisplayTypeFromPlayerInfo(class ARHHUDCommon* pHUD, class URH_PlayerInfo* PlayerInfo, const TDelegate<void(ERHPlatformDisplayType PlatformType)>& Delegate);
	static void GetPlatformDisplayTypeFromPlayerState(class ARHHUDCommon* pHUD, class ARHPlayerState* PlayerState, const TDelegate<void(ERHPlatformDisplayType PlatformType)>& Delegate);
	static ERHAPI_Platform GetPlatformIdByOSSName(class FName OSSName);
	static int32 GetPlayerCohortGroup(class URH_PlayerInfo* PlayerInfo, int32 NumberOfGroups);
	static ERHPlayerOnlineStatus GetPlayerOnlineStatus(const class UObject* WorldContextObject, class URH_PlayerInfo* PlayerInfo, const class URH_LocalPlayerSubsystem* LocalPlayerSS, bool bAllowPartyStatus, bool bAllowFriendRequestStatus);
	static class FText GetPlayerStatusMessage(const class UObject* WorldContextObject, class URH_PlayerInfo* PlayerInfo, const class URH_LocalPlayerSubsystem* LocalPlayerSS);
	static class FText GetStatusMessage(ERHPlayerOnlineStatus PlayerStatus);
	static const class FText GetTextByPlatform(const class FText& DefaultText, const TMap<class FString, class FText>& PlatformTexts);
	static float GetUMG_DPI_Scaling();
	static bool HasCinematicToPlay(class UDataTable* CinematicDataTable);
	static bool IsAnonymousLogin(class ARHHUDCommon* pHUD);
	static bool IsGameClosing(class ARHHUDCommon* pHUD);
	static bool IsInMatch(const class URH_LocalPlayerSubsystem* LocalPlayerSS);
	static bool IsPlatformType(bool IsConsole, bool IsPC, bool IsMobile);
	static bool IsSteamDeck();
	static bool IsWithEditor();
	static class FText Key_GetShortDisplayName(const struct FKey& Key);
	static bool LeaveSession(const class ARHHUDCommon* pHUD, const class FString& SessionType);
	static bool LeaveSessionById(const class ARHHUDCommon* pHUD, const class FString& SessionId);
	static void RegisterGridNavigation(class URHWidget* ParentWidget, int32 FocusGroup, const TArray<class UWidget*>& NavWidgets, int32 GridWidth, bool NavToLastElementOnDown);
	static void RegisterLinearNavigation(class URHWidget* ParentWidget, const TArray<class URHWidget*>& NavWidgets, int32 FocusGroup, bool bHorizontal, bool bLooping, class URHWidget* NavUpLeftWidget, class URHWidget* NavDownRightWidget);
	static struct FReportPlayerParams SetupReportPlayerFromGameState(const struct FGuid& PlayerId, const class ARHGameState* State);
	static bool UIX_ReportPlayer(const class UObject* WorldContextObject, const struct FReportPlayerParams& Params_0);
	static void ViewPlatformProfileForPlayerState(class ARHHUDCommon* pHUD, class ARHPlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHUIBlueprintFunctionLibrary">();
	}
	static class URHUIBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHUIBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(URHUIBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on URHUIBlueprintFunctionLibrary");
static_assert(sizeof(URHUIBlueprintFunctionLibrary) == 0x000028, "Wrong size on URHUIBlueprintFunctionLibrary");

// Class RallyHereStart.RHUISoundTheme
// 0x0050 (0x0078 - 0x0028)
class URHUISoundTheme final : public UObject
{
public:
	TMap<class FName, struct FRHSoundThemeEventMapping> SoundEventBindings;                          // 0x0028(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHUISoundTheme">();
	}
	static class URHUISoundTheme* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHUISoundTheme>();
	}
};
static_assert(alignof(URHUISoundTheme) == 0x000008, "Wrong alignment on URHUISoundTheme");
static_assert(sizeof(URHUISoundTheme) == 0x000078, "Wrong size on URHUISoundTheme");
static_assert(offsetof(URHUISoundTheme, SoundEventBindings) == 0x000028, "Member 'URHUISoundTheme::SoundEventBindings' has a wrong offset!");

// Class RallyHereStart.RHViewItemData
// 0x0028 (0x05E0 - 0x05B8)
class URHViewItemData final : public URHWidget
{
public:
	TArray<TSoftObjectPtr<class URHStoreItem>>    StoreItems;                                        // 0x05B8(0x0010)(BlueprintVisible, ZeroConstructor, ExposeOnSpawn, UObjectWrapper, NativeAccessSpecifierPublic)
	class UPlatformInventoryItem*                 InventoryItem;                                     // 0x05C8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SceneCamera;                                       // 0x05D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SceneViewModel;                                    // 0x05D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHViewItemData">();
	}
	static class URHViewItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHViewItemData>();
	}
};
static_assert(alignof(URHViewItemData) == 0x000008, "Wrong alignment on URHViewItemData");
static_assert(sizeof(URHViewItemData) == 0x0005E0, "Wrong size on URHViewItemData");
static_assert(offsetof(URHViewItemData, StoreItems) == 0x0005B8, "Member 'URHViewItemData::StoreItems' has a wrong offset!");
static_assert(offsetof(URHViewItemData, InventoryItem) == 0x0005C8, "Member 'URHViewItemData::InventoryItem' has a wrong offset!");
static_assert(offsetof(URHViewItemData, SceneCamera) == 0x0005D0, "Member 'URHViewItemData::SceneCamera' has a wrong offset!");
static_assert(offsetof(URHViewItemData, SceneViewModel) == 0x0005D8, "Member 'URHViewItemData::SceneViewModel' has a wrong offset!");

// Class RallyHereStart.RHViewItemsWidget
// 0x0000 (0x05B8 - 0x05B8)
class URHViewItemsWidget : public URHWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHViewItemsWidget">();
	}
	static class URHViewItemsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHViewItemsWidget>();
	}
};
static_assert(alignof(URHViewItemsWidget) == 0x000008, "Wrong alignment on URHViewItemsWidget");
static_assert(sizeof(URHViewItemsWidget) == 0x0005B8, "Wrong size on URHViewItemsWidget");

// Class RallyHereStart.RHGenericRouteDataObject
// 0x0020 (0x0048 - 0x0028)
class URHGenericRouteDataObject final : public UObject
{
public:
	class FString                                 StringValue;                                       // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntValue;                                          // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NameValue;                                         // 0x003C(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHGenericRouteDataObject">();
	}
	static class URHGenericRouteDataObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHGenericRouteDataObject>();
	}
};
static_assert(alignof(URHGenericRouteDataObject) == 0x000008, "Wrong alignment on URHGenericRouteDataObject");
static_assert(sizeof(URHGenericRouteDataObject) == 0x000048, "Wrong size on URHGenericRouteDataObject");
static_assert(offsetof(URHGenericRouteDataObject, StringValue) == 0x000028, "Member 'URHGenericRouteDataObject::StringValue' has a wrong offset!");
static_assert(offsetof(URHGenericRouteDataObject, IntValue) == 0x000038, "Member 'URHGenericRouteDataObject::IntValue' has a wrong offset!");
static_assert(offsetof(URHGenericRouteDataObject, NameValue) == 0x00003C, "Member 'URHGenericRouteDataObject::NameValue' has a wrong offset!");

// Class RallyHereStart.RHViewLayer
// 0x0138 (0x0160 - 0x0028)
class URHViewLayer final : public UObject
{
public:
	class UCanvasPanel*                           DisplayTarget;                                     // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URHViewManager*                         MyManager;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewManagerTransitionState                   CurrentTransitionState;                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   CurrentRouteStack;                                 // 0x0040(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   CurrentTransitionRouteStack;                       // 0x0050(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class URHWidget*>   RouteWidgetMap;                                    // 0x0060(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DefaultRoute;                                      // 0x00B0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UObject*>     PendingRouteData;                                  // 0x00C0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FViewRoute>  Routes;                                            // 0x0110(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void GoToRoute_HandleHideFinished(class URHWidget* Widget);
	void GoToRoute_HandleShowFinished(class URHWidget* Widget);
	void GoToRoute_InternalShowStep();
	bool IsRouteValid(const struct FGameplayTag& RouteTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHViewLayer">();
	}
	static class URHViewLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHViewLayer>();
	}
};
static_assert(alignof(URHViewLayer) == 0x000008, "Wrong alignment on URHViewLayer");
static_assert(sizeof(URHViewLayer) == 0x000160, "Wrong size on URHViewLayer");
static_assert(offsetof(URHViewLayer, DisplayTarget) == 0x000028, "Member 'URHViewLayer::DisplayTarget' has a wrong offset!");
static_assert(offsetof(URHViewLayer, MyManager) == 0x000030, "Member 'URHViewLayer::MyManager' has a wrong offset!");
static_assert(offsetof(URHViewLayer, CurrentTransitionState) == 0x000038, "Member 'URHViewLayer::CurrentTransitionState' has a wrong offset!");
static_assert(offsetof(URHViewLayer, CurrentRouteStack) == 0x000040, "Member 'URHViewLayer::CurrentRouteStack' has a wrong offset!");
static_assert(offsetof(URHViewLayer, CurrentTransitionRouteStack) == 0x000050, "Member 'URHViewLayer::CurrentTransitionRouteStack' has a wrong offset!");
static_assert(offsetof(URHViewLayer, RouteWidgetMap) == 0x000060, "Member 'URHViewLayer::RouteWidgetMap' has a wrong offset!");
static_assert(offsetof(URHViewLayer, DefaultRoute) == 0x0000B0, "Member 'URHViewLayer::DefaultRoute' has a wrong offset!");
static_assert(offsetof(URHViewLayer, PendingRouteData) == 0x0000C0, "Member 'URHViewLayer::PendingRouteData' has a wrong offset!");
static_assert(offsetof(URHViewLayer, Routes) == 0x000110, "Member 'URHViewLayer::Routes' has a wrong offset!");

// Class RallyHereStart.RHViewManager
// 0x0158 (0x0180 - 0x0028)
class URHViewManager : public UObject
{
public:
	TArray<class URHViewLayer*>                   ViewLayers;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, class URHWidget*>           StickyWidgetMap;                                   // 0x0038(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& CurrentRoute, const struct FGameplayTag& PreviousRoute, EViewManagerLayer Layer)> OnViewStateChanged; // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& CurrentRoute, const struct FGameplayTag& NextRoute, EViewManagerLayer Layer)> OnViewStateChangeStarted; // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& ViewRouteTag)> OnViewRouteAdded;        // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& ViewRouteTag)> OnViewRouteRemoved;      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ARHHUDCommon*                           HudRef;                                            // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCanvasPanel*>                   CanvasPanels;                                      // 0x00D0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	TArray<struct FStickyWidgetData>              StickyWidgets;                                     // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              InitializationDataTableSoftPtr;                    // 0x00F0(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBaseLayerBeEmpty;                              // 0x0118(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FViewRoute>  Routes;                                            // 0x0120(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FViewRouteRedirectData>         AlwaysCheckRouteData;                              // 0x0170(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	bool ContainsRoute(const struct FGameplayTag& RouteTag);
	bool GetPendingRouteData(const struct FGameplayTag& RouteTag, class UObject** Data);
	bool GetViewRoute(const struct FGameplayTag& RouteTag, struct FViewRoute* ViewRoute);
	void Initialize();
	void InitializeRoutes();
	bool PopRoute(bool ForceTransition);
	bool PushRoute(const struct FGameplayTag& RouteTag, bool ForceTransition, class UObject* Data);
	bool RemoveRoute(const struct FGameplayTag& RouteTag, bool ForceTransition);
	bool ReplaceRoute(const struct FGameplayTag& RouteTag, bool ForceTransition, class UObject* Data);
	void SetCursorEnabled(const struct FGameplayTag& RouteTag);
	void SetPendingRouteData(const struct FGameplayTag& RouteTag, class UObject* Data);
	bool SwapRoute(const struct FGameplayTag& RouteTag, const struct FGameplayTag& SwapTargetRouteTag, bool ForceTransition);

	const struct FGameplayTag GetCurrentRoute(EViewManagerLayer Layer) const;
	const struct FGameplayTag GetCurrentTransitionRoute(EViewManagerLayer Layer) const;
	const struct FGameplayTag GetDefaultRouteForLayer(EViewManagerLayer LayerType) const;
	EViewManagerLayer GetTopLayer() const;
	const struct FGameplayTag GetTopViewRoute() const;
	class URHWidget* GetTopViewRouteWidget() const;
	int32 GetViewRouteCount() const;
	bool HasCompletedRedirectFlow(EViewRouteRedirectionPhase RedirectPhase) const;
	bool IsBlockingOrders() const;
	bool IsEveryLayerIdle() const;
	bool IsLayerIdle(EViewManagerLayer LayerType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHViewManager">();
	}
	static class URHViewManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHViewManager>();
	}
};
static_assert(alignof(URHViewManager) == 0x000008, "Wrong alignment on URHViewManager");
static_assert(sizeof(URHViewManager) == 0x000180, "Wrong size on URHViewManager");
static_assert(offsetof(URHViewManager, ViewLayers) == 0x000028, "Member 'URHViewManager::ViewLayers' has a wrong offset!");
static_assert(offsetof(URHViewManager, StickyWidgetMap) == 0x000038, "Member 'URHViewManager::StickyWidgetMap' has a wrong offset!");
static_assert(offsetof(URHViewManager, OnViewStateChanged) == 0x000088, "Member 'URHViewManager::OnViewStateChanged' has a wrong offset!");
static_assert(offsetof(URHViewManager, OnViewStateChangeStarted) == 0x000098, "Member 'URHViewManager::OnViewStateChangeStarted' has a wrong offset!");
static_assert(offsetof(URHViewManager, OnViewRouteAdded) == 0x0000A8, "Member 'URHViewManager::OnViewRouteAdded' has a wrong offset!");
static_assert(offsetof(URHViewManager, OnViewRouteRemoved) == 0x0000B8, "Member 'URHViewManager::OnViewRouteRemoved' has a wrong offset!");
static_assert(offsetof(URHViewManager, HudRef) == 0x0000C8, "Member 'URHViewManager::HudRef' has a wrong offset!");
static_assert(offsetof(URHViewManager, CanvasPanels) == 0x0000D0, "Member 'URHViewManager::CanvasPanels' has a wrong offset!");
static_assert(offsetof(URHViewManager, StickyWidgets) == 0x0000E0, "Member 'URHViewManager::StickyWidgets' has a wrong offset!");
static_assert(offsetof(URHViewManager, InitializationDataTableSoftPtr) == 0x0000F0, "Member 'URHViewManager::InitializationDataTableSoftPtr' has a wrong offset!");
static_assert(offsetof(URHViewManager, bCanBaseLayerBeEmpty) == 0x000118, "Member 'URHViewManager::bCanBaseLayerBeEmpty' has a wrong offset!");
static_assert(offsetof(URHViewManager, Routes) == 0x000120, "Member 'URHViewManager::Routes' has a wrong offset!");
static_assert(offsetof(URHViewManager, AlwaysCheckRouteData) == 0x000170, "Member 'URHViewManager::AlwaysCheckRouteData' has a wrong offset!");

// Class RallyHereStart.RHViewRedirector_LocalSetting
// 0x0008 (0x0030 - 0x0028)
class URHViewRedirector_LocalSetting : public URHViewRedirecter
{
public:
	class FName                                   LocalActionName;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool DoesLocalSettingApply(class ARHHUDCommon* HUD) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHViewRedirector_LocalSetting">();
	}
	static class URHViewRedirector_LocalSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHViewRedirector_LocalSetting>();
	}
};
static_assert(alignof(URHViewRedirector_LocalSetting) == 0x000008, "Wrong alignment on URHViewRedirector_LocalSetting");
static_assert(sizeof(URHViewRedirector_LocalSetting) == 0x000030, "Wrong size on URHViewRedirector_LocalSetting");
static_assert(offsetof(URHViewRedirector_LocalSetting, LocalActionName) == 0x000028, "Member 'URHViewRedirector_LocalSetting::LocalActionName' has a wrong offset!");

// Class RallyHereStart.RHVoiceActivityWidget
// 0x0030 (0x05E8 - 0x05B8)
class URHVoiceActivityWidget : public URHWidget
{
public:
	TMulticastInlineDelegate<void(const struct FGuid& PlayerUuid, bool bInVoiceChannel, bool bIsTalking, bool bIsMuted)> VoiceChatStateChanged; // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              VoiceChatDisconnected;                             // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x10];                                     // 0x05D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVoiceChatStateChanged(const struct FGuid& PlayerUuid, bool bInVoiceChannel, bool bIsTalking, bool bIsMuted);

	class URH_PlayerInfo* GetPlayerInfoByUuid(const struct FGuid& VoiceId) const;
	class ARHPlayerState* GetPlayerStateByUuid(const struct FGuid& VoiceId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHVoiceActivityWidget">();
	}
	static class URHVoiceActivityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHVoiceActivityWidget>();
	}
};
static_assert(alignof(URHVoiceActivityWidget) == 0x000008, "Wrong alignment on URHVoiceActivityWidget");
static_assert(sizeof(URHVoiceActivityWidget) == 0x0005E8, "Wrong size on URHVoiceActivityWidget");
static_assert(offsetof(URHVoiceActivityWidget, VoiceChatStateChanged) == 0x0005B8, "Member 'URHVoiceActivityWidget::VoiceChatStateChanged' has a wrong offset!");
static_assert(offsetof(URHVoiceActivityWidget, VoiceChatDisconnected) == 0x0005C8, "Member 'URHVoiceActivityWidget::VoiceChatDisconnected' has a wrong offset!");

// Class RallyHereStart.RHVoucherOrder
// 0x0008 (0x05C0 - 0x05B8)
class URHVoucherOrder : public URHWidget
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisplayVoucherRedemptionFailed();
	void GetVoucherOrders(const TDelegate<void(const TArray<class URHStoreItem*>& PurchaseItems, const TArray<TSoftObjectPtr<class UPlatformInventoryItem>>& CurrencyItems)>& Delegate);
	void RedeemVouchers(const TArray<class URHStoreItem*>& VoucherItems, const TDelegate<void(bool bSuccess)>& Delegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHVoucherOrder">();
	}
	static class URHVoucherOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHVoucherOrder>();
	}
};
static_assert(alignof(URHVoucherOrder) == 0x000008, "Wrong alignment on URHVoucherOrder");
static_assert(sizeof(URHVoucherOrder) == 0x0005C0, "Wrong size on URHVoucherOrder");

// Class RallyHereStart.RH_RedeemVouchersAsyncTaskHelper
// 0x0040 (0x0068 - 0x0028)
class URH_RedeemVouchersAsyncTaskHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URHStoreItem*>                   VoucherItems;                                      // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class URHStorePurchaseRequest*>        PurchaseRequests;                                  // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RH_RedeemVouchersAsyncTaskHelper">();
	}
	static class URH_RedeemVouchersAsyncTaskHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URH_RedeemVouchersAsyncTaskHelper>();
	}
};
static_assert(alignof(URH_RedeemVouchersAsyncTaskHelper) == 0x000008, "Wrong alignment on URH_RedeemVouchersAsyncTaskHelper");
static_assert(sizeof(URH_RedeemVouchersAsyncTaskHelper) == 0x000068, "Wrong size on URH_RedeemVouchersAsyncTaskHelper");
static_assert(offsetof(URH_RedeemVouchersAsyncTaskHelper, PlayerInfo) == 0x000040, "Member 'URH_RedeemVouchersAsyncTaskHelper::PlayerInfo' has a wrong offset!");
static_assert(offsetof(URH_RedeemVouchersAsyncTaskHelper, VoucherItems) == 0x000048, "Member 'URH_RedeemVouchersAsyncTaskHelper::VoucherItems' has a wrong offset!");
static_assert(offsetof(URH_RedeemVouchersAsyncTaskHelper, PurchaseRequests) == 0x000058, "Member 'URH_RedeemVouchersAsyncTaskHelper::PurchaseRequests' has a wrong offset!");

// Class RallyHereStart.RHWhatsNewPanel
// 0x0068 (0x00F0 - 0x0088)
class URHWhatsNewPanel final : public URHJsonData
{
public:
	class FText                                   Header;                                            // 0x0088(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   SubHeader;                                         // 0x00A0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ENewsHeaderAlignment                          HeaderAlignment;                                   // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSubPanel>                      SubPanels;                                         // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ESubPanelAlignment                            Alignment;                                         // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BgBoxOpacity;                                      // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2DDynamic*                      Image;                                             // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RHWhatsNewPanel">();
	}
	static class URHWhatsNewPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URHWhatsNewPanel>();
	}
};
static_assert(alignof(URHWhatsNewPanel) == 0x000008, "Wrong alignment on URHWhatsNewPanel");
static_assert(sizeof(URHWhatsNewPanel) == 0x0000F0, "Wrong size on URHWhatsNewPanel");
static_assert(offsetof(URHWhatsNewPanel, Header) == 0x000088, "Member 'URHWhatsNewPanel::Header' has a wrong offset!");
static_assert(offsetof(URHWhatsNewPanel, SubHeader) == 0x0000A0, "Member 'URHWhatsNewPanel::SubHeader' has a wrong offset!");
static_assert(offsetof(URHWhatsNewPanel, HeaderAlignment) == 0x0000B8, "Member 'URHWhatsNewPanel::HeaderAlignment' has a wrong offset!");
static_assert(offsetof(URHWhatsNewPanel, SubPanels) == 0x0000C0, "Member 'URHWhatsNewPanel::SubPanels' has a wrong offset!");
static_assert(offsetof(URHWhatsNewPanel, Alignment) == 0x0000D0, "Member 'URHWhatsNewPanel::Alignment' has a wrong offset!");
static_assert(offsetof(URHWhatsNewPanel, BgBoxOpacity) == 0x0000D4, "Member 'URHWhatsNewPanel::BgBoxOpacity' has a wrong offset!");
static_assert(offsetof(URHWhatsNewPanel, Image) == 0x0000D8, "Member 'URHWhatsNewPanel::Image' has a wrong offset!");
static_assert(offsetof(URHWhatsNewPanel, URL) == 0x0000E0, "Member 'URHWhatsNewPanel::URL' has a wrong offset!");

// Class RallyHereStart.TickAnimationManager
// 0x0050 (0x0078 - 0x0028)
class UTickAnimationManager final : public UObject
{
public:
	TMap<class FName, struct FTickAnimationParams> AnimsByName;                                      // 0x0028(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddAnimation(class FName AnimName, float Duration, const TDelegate<void(float ElapsedTime, float ElapsedAlpha)>& UpdateEvent, const TDelegate<void()>& FinishedEvent);
	void ApplyTick(float DeltaTime);
	bool GetAnimationInfo(class FName AnimName, struct FTickAnimationParams* OutAnimParams);
	void PauseAnimation(class FName AnimName);
	void PlayAnimation(class FName AnimName);
	void RemoveAnimation(class FName AnimName);
	void ResumeAnimation(class FName AnimName);
	void SkipToEndAnimation(class FName AnimName);
	void StopAnimation(class FName AnimName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickAnimationManager">();
	}
	static class UTickAnimationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTickAnimationManager>();
	}
};
static_assert(alignof(UTickAnimationManager) == 0x000008, "Wrong alignment on UTickAnimationManager");
static_assert(sizeof(UTickAnimationManager) == 0x000078, "Wrong size on UTickAnimationManager");
static_assert(offsetof(UTickAnimationManager, AnimsByName) == 0x000028, "Member 'UTickAnimationManager::AnimsByName' has a wrong offset!");

}

