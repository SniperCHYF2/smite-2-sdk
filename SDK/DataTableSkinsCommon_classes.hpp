#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DataTableSkinsCommon

#include "Basic.hpp"

#include "DataTableSkinsCommon_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AnimationBudgetAllocator_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class DataTableSkinsCommon.AssetAdditionalInfo
// 0x0008 (0x0030 - 0x0028)
class UAssetAdditionalInfo : public UObject
{
public:
	EAssetAdditionalInfoType                      AssetInfoType;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetAdditionalInfo">();
	}
	static class UAssetAdditionalInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetAdditionalInfo>();
	}
};
static_assert(alignof(UAssetAdditionalInfo) == 0x000008, "Wrong alignment on UAssetAdditionalInfo");
static_assert(sizeof(UAssetAdditionalInfo) == 0x000030, "Wrong size on UAssetAdditionalInfo");
static_assert(offsetof(UAssetAdditionalInfo, AssetInfoType) == 0x000028, "Member 'UAssetAdditionalInfo::AssetInfoType' has a wrong offset!");

// Class DataTableSkinsCommon.AnimAdditionalInfo
// 0x0000 (0x0030 - 0x0030)
class UAnimAdditionalInfo : public UAssetAdditionalInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimAdditionalInfo">();
	}
	static class UAnimAdditionalInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimAdditionalInfo>();
	}
};
static_assert(alignof(UAnimAdditionalInfo) == 0x000008, "Wrong alignment on UAnimAdditionalInfo");
static_assert(sizeof(UAnimAdditionalInfo) == 0x000030, "Wrong size on UAnimAdditionalInfo");

// Class DataTableSkinsCommon.AnimMontageAdditionalInfo
// 0x0010 (0x0040 - 0x0030)
class UAnimMontageAdditionalInfo final : public UAnimAdditionalInfo
{
public:
	float                                         DefaultPlayRate;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartingMontageSection;                            // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinuePlayingMontagePastAbilityEnd;             // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinuePlayingMontagePastAbilityCancel;          // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimMontageAdditionalInfo">();
	}
	static class UAnimMontageAdditionalInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimMontageAdditionalInfo>();
	}
};
static_assert(alignof(UAnimMontageAdditionalInfo) == 0x000008, "Wrong alignment on UAnimMontageAdditionalInfo");
static_assert(sizeof(UAnimMontageAdditionalInfo) == 0x000040, "Wrong size on UAnimMontageAdditionalInfo");
static_assert(offsetof(UAnimMontageAdditionalInfo, DefaultPlayRate) == 0x000030, "Member 'UAnimMontageAdditionalInfo::DefaultPlayRate' has a wrong offset!");
static_assert(offsetof(UAnimMontageAdditionalInfo, StartingMontageSection) == 0x000034, "Member 'UAnimMontageAdditionalInfo::StartingMontageSection' has a wrong offset!");
static_assert(offsetof(UAnimMontageAdditionalInfo, bContinuePlayingMontagePastAbilityEnd) == 0x00003C, "Member 'UAnimMontageAdditionalInfo::bContinuePlayingMontagePastAbilityEnd' has a wrong offset!");
static_assert(offsetof(UAnimMontageAdditionalInfo, bContinuePlayingMontagePastAbilityCancel) == 0x00003D, "Member 'UAnimMontageAdditionalInfo::bContinuePlayingMontagePastAbilityCancel' has a wrong offset!");

// Class DataTableSkinsCommon.AnimSequenceAdditionalInfo
// 0x0000 (0x0030 - 0x0030)
class UAnimSequenceAdditionalInfo final : public UAnimAdditionalInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimSequenceAdditionalInfo">();
	}
	static class UAnimSequenceAdditionalInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimSequenceAdditionalInfo>();
	}
};
static_assert(alignof(UAnimSequenceAdditionalInfo) == 0x000008, "Wrong alignment on UAnimSequenceAdditionalInfo");
static_assert(sizeof(UAnimSequenceAdditionalInfo) == 0x000030, "Wrong size on UAnimSequenceAdditionalInfo");

// Class DataTableSkinsCommon.BlendSpaceAdditionalInfo
// 0x0000 (0x0030 - 0x0030)
class UBlendSpaceAdditionalInfo final : public UAnimAdditionalInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendSpaceAdditionalInfo">();
	}
	static class UBlendSpaceAdditionalInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlendSpaceAdditionalInfo>();
	}
};
static_assert(alignof(UBlendSpaceAdditionalInfo) == 0x000008, "Wrong alignment on UBlendSpaceAdditionalInfo");
static_assert(sizeof(UBlendSpaceAdditionalInfo) == 0x000030, "Wrong size on UBlendSpaceAdditionalInfo");

// Class DataTableSkinsCommon.AimOffsetAdditionalInfo
// 0x0000 (0x0030 - 0x0030)
class UAimOffsetAdditionalInfo final : public UAnimAdditionalInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimOffsetAdditionalInfo">();
	}
	static class UAimOffsetAdditionalInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimOffsetAdditionalInfo>();
	}
};
static_assert(alignof(UAimOffsetAdditionalInfo) == 0x000008, "Wrong alignment on UAimOffsetAdditionalInfo");
static_assert(sizeof(UAimOffsetAdditionalInfo) == 0x000030, "Wrong size on UAimOffsetAdditionalInfo");

// Class DataTableSkinsCommon.PoseAssetAdditionalInfo
// 0x0000 (0x0030 - 0x0030)
class UPoseAssetAdditionalInfo final : public UAnimAdditionalInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoseAssetAdditionalInfo">();
	}
	static class UPoseAssetAdditionalInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoseAssetAdditionalInfo>();
	}
};
static_assert(alignof(UPoseAssetAdditionalInfo) == 0x000008, "Wrong alignment on UPoseAssetAdditionalInfo");
static_assert(sizeof(UPoseAssetAdditionalInfo) == 0x000030, "Wrong size on UPoseAssetAdditionalInfo");

// Class DataTableSkinsCommon.DynamicSkinTable
// 0x0270 (0x0298 - 0x0028)
class UDynamicSkinTable final : public UObject
{
public:
	TArray<struct FDataTableInfo>                 ActiveDataTables;                                  // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDataTableInfo>                 InactiveDataTables;                                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDynamicSkinTable* DynamicSkinTable)> OnFinishedAllPendingLoadsDel; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FAssetRequestKey>                 ActiveEntries;                                     // 0x00A8(0x0050)(NativeAccessSpecifierPrivate)
	TSet<struct FAssetRequestKey>                 PendingEntries;                                    // 0x00F8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x130];                                    // 0x0148(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bWantsToBeRecycled : 1;                            // 0x0278(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class ISkinTagAssetInterface> SkinTagAsset;                                     // 0x0280(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDataTable(class UDataTable* InTable, int32 InPriority);
	void AddDataTables(const TArray<struct FDataTableInfo>& InTableInfos);
	void AddDataTableWithQuery(class UDataTable* InTable, int32 InPriority, const struct FGameplayTagQuery& InQuery);
	void RemoveDataTable(class UDataTable* InTable);
	void RemoveDataTables(const TArray<class UDataTable*>& InTables);

	void GetAllKeywords(TSet<struct FAssetRequestKey>* InOutKeywords) const;
	class UAimOffsetBlendSpace* GetAnimAimOffset(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UAnimationAsset* GetAnimationAsset(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UBlendSpace* GetAnimBlendSpace(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UAnimMontage* GetAnimMontage(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UAnimSequence* GetAnimSequence(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	bool GetBool(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UClass* GetClass(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UDataAsset* GetDataAsset(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	float GetFloat(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	int32 GetInt(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	struct FLinearColor GetLinearColor(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UMaterialInterface* GetMaterialInterface(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UMetaSoundSource* GetMetaSoundSource(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class FName GetNameField(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UNiagaraSystem* GetNiagaraSystem(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UPhysicsAsset* GetPhysicsAsset(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UPoseAsset* GetPoseAsset(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class USkeletalMesh* GetSkeletalMesh(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UStaticMesh* GetStaticMesh(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	class UTexture* GetTexture(const struct FAssetRequestKey& AssetRequestKey, int32* Priority) const;
	bool IsTablePendingAssetLoad() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicSkinTable">();
	}
	static class UDynamicSkinTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicSkinTable>();
	}
};
static_assert(alignof(UDynamicSkinTable) == 0x000008, "Wrong alignment on UDynamicSkinTable");
static_assert(sizeof(UDynamicSkinTable) == 0x000298, "Wrong size on UDynamicSkinTable");
static_assert(offsetof(UDynamicSkinTable, ActiveDataTables) == 0x000028, "Member 'UDynamicSkinTable::ActiveDataTables' has a wrong offset!");
static_assert(offsetof(UDynamicSkinTable, InactiveDataTables) == 0x000038, "Member 'UDynamicSkinTable::InactiveDataTables' has a wrong offset!");
static_assert(offsetof(UDynamicSkinTable, OnFinishedAllPendingLoadsDel) == 0x000048, "Member 'UDynamicSkinTable::OnFinishedAllPendingLoadsDel' has a wrong offset!");
static_assert(offsetof(UDynamicSkinTable, ActiveEntries) == 0x0000A8, "Member 'UDynamicSkinTable::ActiveEntries' has a wrong offset!");
static_assert(offsetof(UDynamicSkinTable, PendingEntries) == 0x0000F8, "Member 'UDynamicSkinTable::PendingEntries' has a wrong offset!");
static_assert(offsetof(UDynamicSkinTable, SkinTagAsset) == 0x000280, "Member 'UDynamicSkinTable::SkinTagAsset' has a wrong offset!");

// Class DataTableSkinsCommon.MultiSkinObject
// 0x01A8 (0x01D0 - 0x0028)
class UMultiSkinObject final : public UObject
{
public:
	TArray<class UMultiSkinObject*>               ParentSkinnedObjects;                              // 0x0028(0x0010)(ZeroConstructor, DuplicateTransient, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UMultiSkinObject>> ChildSkinnedObjects;                              // 0x0038(0x0010)(ZeroConstructor, DuplicateTransient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<struct FAssetRequestKey>                 SubscribedKeywords;                                // 0x0048(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class FName>                             SubscribedMaterialPrefixes;                        // 0x0098(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         bSubscribeToAllKeywords : 1;                       // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bWantsToBeRecycled : 1;                            // 0x00E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_E9[0x1F];                                      // 0x00E9(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const TSet<struct FAssetRequestKey>& Keywords)> OnFinishedAllPendingLoadsDel; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, DuplicateTransient, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x18];                                     // 0x0118(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FDynamicSkinTableMapEntry> DynamicSkinTables;                                 // 0x0130(0x0050)(DuplicateTransient, NativeAccessSpecifierPrivate)
	TMap<struct FAssetRequestKey, struct FCachedRowsEntry> CachedRows;                               // 0x0180(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddParent(class UMultiSkinObject* InParent);
	void RemoveParent(class UMultiSkinObject* InParent);
	void SubscribeToAllKeywords();
	void SubscribeToKeyword(struct FAssetRequestKey* InKeyword);
	void SubscribeToKeywords(const TArray<struct FAssetRequestKey>& InKeywords);
	void UnsubscribeToAllKeywords();
	void UnsubscribeToKeyword(struct FAssetRequestKey* InKeyword);
	void UnsubscribeToKeywords(const TArray<struct FAssetRequestKey>& InKeywords);

	void GetAllSkinKeywords(TSet<struct FAssetRequestKey>* InOutKeywords) const;
	class UAimOffsetBlendSpace* GetAnimAimOffset(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	bool GetAnimAimOffsetWithAdditionalInfo(const struct FAssetRequestKey& RequestKey, int32* Priority, class UAimOffsetBlendSpace** OutAsset, class UAimOffsetAdditionalInfo** OutInfo) const;
	class UBlendSpace* GetAnimBlendSpace(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	bool GetAnimBlendSpaceWithAdditionalInfo(const struct FAssetRequestKey& RequestKey, int32* Priority, class UBlendSpace** OutAsset, class UBlendSpaceAdditionalInfo** OutInfo) const;
	class UAnimMontage* GetAnimMontage(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	bool GetAnimMontageWithAdditionalInfo(const struct FAssetRequestKey& RequestKey, int32* Priority, class UAnimMontage** OutAsset, class UAnimMontageAdditionalInfo** OutInfo) const;
	class UAnimSequence* GetAnimSequence(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	bool GetAnimSequenceWithAdditionalInfo(const struct FAssetRequestKey& RequestKey, int32* Priority, class UAnimSequence** OutAsset, class UAnimSequenceAdditionalInfo** OutInfo) const;
	bool GetBool(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	class UClass* GetClass(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	class UDataAsset* GetDataAsset(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	float GetFloat(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	int32 GetInt(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	struct FLinearColor GetLinearColor(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	class UMaterialInterface* GetMaterialInterface(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	class UMetaSoundSource* GetMetaSoundSource(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	class FName GetNameField(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	class UNiagaraSystem* GetNiagaraSystem(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	class UPhysicsAsset* GetPhysicsAsset(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	class UPoseAsset* GetPoseAsset(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	bool GetPoseAssetWithAdditionalInfo(const struct FAssetRequestKey& RequestKey, int32* Priority, class UPoseAsset** OutAsset, class UPoseAssetAdditionalInfo** OutInfo) const;
	class USkeletalMesh* GetSkeletalMesh(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	class UStaticMesh* GetStaticMesh(const struct FAssetRequestKey& RequestKey, int32* Priority) const;
	class UTexture* GetTexture(const struct FAssetRequestKey& RequestKey, int32* Priority) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiSkinObject">();
	}
	static class UMultiSkinObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiSkinObject>();
	}
};
static_assert(alignof(UMultiSkinObject) == 0x000008, "Wrong alignment on UMultiSkinObject");
static_assert(sizeof(UMultiSkinObject) == 0x0001D0, "Wrong size on UMultiSkinObject");
static_assert(offsetof(UMultiSkinObject, ParentSkinnedObjects) == 0x000028, "Member 'UMultiSkinObject::ParentSkinnedObjects' has a wrong offset!");
static_assert(offsetof(UMultiSkinObject, ChildSkinnedObjects) == 0x000038, "Member 'UMultiSkinObject::ChildSkinnedObjects' has a wrong offset!");
static_assert(offsetof(UMultiSkinObject, SubscribedKeywords) == 0x000048, "Member 'UMultiSkinObject::SubscribedKeywords' has a wrong offset!");
static_assert(offsetof(UMultiSkinObject, SubscribedMaterialPrefixes) == 0x000098, "Member 'UMultiSkinObject::SubscribedMaterialPrefixes' has a wrong offset!");
static_assert(offsetof(UMultiSkinObject, OnFinishedAllPendingLoadsDel) == 0x000108, "Member 'UMultiSkinObject::OnFinishedAllPendingLoadsDel' has a wrong offset!");
static_assert(offsetof(UMultiSkinObject, DynamicSkinTables) == 0x000130, "Member 'UMultiSkinObject::DynamicSkinTables' has a wrong offset!");
static_assert(offsetof(UMultiSkinObject, CachedRows) == 0x000180, "Member 'UMultiSkinObject::CachedRows' has a wrong offset!");

// Class DataTableSkinsCommon.SkinnableSkeletalMeshComponent
// 0x0150 (0x1120 - 0x0FD0)
class USkinnableSkeletalMeshComponent : public USkeletalMeshComponentBudgeted
{
public:
	TMulticastInlineDelegate<void()>              PostPerformSkinUpdateDelegate;                     // 0x0FC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bDelaySkinUpdatesUntilTick;                        // 0x0FD8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkinUpdateIsQueued;                               // 0x0FD9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FDA[0x2];                                      // 0x0FDA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkeletalMeshKeyword;                               // 0x0FDC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE4[0x4];                                      // 0x0FE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          FailSafeSkeletalMesh;                              // 0x0FE8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PhysicsAssetKeyword;                               // 0x0FF0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          FailSafePhysicsAsset;                              // 0x0FF8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AnimInstanceClassKeyword;                          // 0x1000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              FailSafeAnimClass;                                 // 0x1008(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              LastSkinnedAnimClass;                              // 0x1010(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceAnimationUpdateOnSkinUpdate;                 // 0x1018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1019[0x7];                                     // 0x1019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMultiSkinObject*                       SkinObject;                                        // 0x1020(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class USkinnableSkeletalMeshComponent* SkinnableSkelComp, class UAnimInstance* AnimInstance)> OnAnimInitializedOnSkinnableMeshDel; // 0x1028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1038[0x30];                                    // 0x1038(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowMaterialSkinning;                            // 0x1068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1069[0x7];                                     // 0x1069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         MaterialSkinningPrefixes;                          // 0x1070(0x0010)(ZeroConstructor, Deprecated, Protected, NativeAccessSpecifierProtected)
	TSet<class FName>                             MaterialSkinningPrefixes_New;                      // 0x1080(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D0[0x48];                                    // 0x10D0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ForcedLodModel_Skinned;                            // 0x1118(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111C[0x4];                                     // 0x111C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void StaticSetForcedLOD(class USkinnedMeshComponent* InMeshComp, int32 InForcedLOD);

	bool ChangePersistentMaterialOverrideById(int32 ParameterId, class UMaterialInterface* MaterialInterface);
	bool ChangePersistentScalarOverrideById(int32 ParameterId, float ParameterValue);
	bool ChangePersistentTextureOverrideById(int32 ParameterId, class UTexture* ParameterValue);
	bool ChangePersistentVectorOverrideById(int32 ParameterId, const struct FLinearColor& ParameterValue);
	void ForwardAnimInitialized();
	void RefreshAnimation();
	void RemovePersistentMaterialParameter(int32 ParameterId);
	void SetAnimClassKeyword(class FName InKeyword, TSubclassOf<class UAnimInstance> InFailSafeAnimClass);
	void SetForcedLOD_Skinned(int32 InNewForcedLOD);
	int32 SetPersistentMaterialOverride(int32 MaterialSlot, class UMaterialInterface* MaterialInterface, bool bForceNewOverride);
	int32 SetPersistentMaterialOverrideOnAllSlots(class UMaterialInterface* MaterialInterface, bool bForceNewOverride);
	int32 SetPersistentScalarParameter(int32 MaterialSlot, class FName ParameterName, float ParameterValue, bool bForceNewOverride);
	int32 SetPersistentScalarParameterOnAllMaterials(class FName ParameterName, float ParameterValue, bool bForceNewOverride);
	int32 SetPersistentTextureParameter(int32 MaterialSlot, class FName ParameterName, class UTexture* ParameterValue, bool bForceNewOverride);
	int32 SetPersistentTextureParameterOnAllMaterials(class FName ParameterName, class UTexture* ParameterValue, bool bForceNewOverride);
	int32 SetPersistentVectorParameter(int32 MaterialSlot, class FName ParameterName, const struct FLinearColor& ParameterValue, bool bForceNewOverride);
	int32 SetPersistentVectorParameterOnAllMaterials(class FName ParameterName, const struct FLinearColor& ParameterValue, bool bForceNewOverride);
	void SetPhysicsAssetKeyword(class FName InKeyword, class UPhysicsAsset* InFailSafePhysicsAsset);
	void SetSkeletalMeshKeyword(class FName InKeyword, class USkeletalMesh* InFailSafeSkeletalMesh);

	class UMultiSkinObject* GetSkinObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinnableSkeletalMeshComponent">();
	}
	static class USkinnableSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkinnableSkeletalMeshComponent>();
	}
};
static_assert(alignof(USkinnableSkeletalMeshComponent) == 0x000010, "Wrong alignment on USkinnableSkeletalMeshComponent");
static_assert(sizeof(USkinnableSkeletalMeshComponent) == 0x001120, "Wrong size on USkinnableSkeletalMeshComponent");
static_assert(offsetof(USkinnableSkeletalMeshComponent, PostPerformSkinUpdateDelegate) == 0x000FC8, "Member 'USkinnableSkeletalMeshComponent::PostPerformSkinUpdateDelegate' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, bDelaySkinUpdatesUntilTick) == 0x000FD8, "Member 'USkinnableSkeletalMeshComponent::bDelaySkinUpdatesUntilTick' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, bSkinUpdateIsQueued) == 0x000FD9, "Member 'USkinnableSkeletalMeshComponent::bSkinUpdateIsQueued' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, SkeletalMeshKeyword) == 0x000FDC, "Member 'USkinnableSkeletalMeshComponent::SkeletalMeshKeyword' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, FailSafeSkeletalMesh) == 0x000FE8, "Member 'USkinnableSkeletalMeshComponent::FailSafeSkeletalMesh' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, PhysicsAssetKeyword) == 0x000FF0, "Member 'USkinnableSkeletalMeshComponent::PhysicsAssetKeyword' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, FailSafePhysicsAsset) == 0x000FF8, "Member 'USkinnableSkeletalMeshComponent::FailSafePhysicsAsset' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, AnimInstanceClassKeyword) == 0x001000, "Member 'USkinnableSkeletalMeshComponent::AnimInstanceClassKeyword' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, FailSafeAnimClass) == 0x001008, "Member 'USkinnableSkeletalMeshComponent::FailSafeAnimClass' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, LastSkinnedAnimClass) == 0x001010, "Member 'USkinnableSkeletalMeshComponent::LastSkinnedAnimClass' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, bForceAnimationUpdateOnSkinUpdate) == 0x001018, "Member 'USkinnableSkeletalMeshComponent::bForceAnimationUpdateOnSkinUpdate' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, SkinObject) == 0x001020, "Member 'USkinnableSkeletalMeshComponent::SkinObject' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, OnAnimInitializedOnSkinnableMeshDel) == 0x001028, "Member 'USkinnableSkeletalMeshComponent::OnAnimInitializedOnSkinnableMeshDel' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, bAllowMaterialSkinning) == 0x001068, "Member 'USkinnableSkeletalMeshComponent::bAllowMaterialSkinning' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, MaterialSkinningPrefixes) == 0x001070, "Member 'USkinnableSkeletalMeshComponent::MaterialSkinningPrefixes' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, MaterialSkinningPrefixes_New) == 0x001080, "Member 'USkinnableSkeletalMeshComponent::MaterialSkinningPrefixes_New' has a wrong offset!");
static_assert(offsetof(USkinnableSkeletalMeshComponent, ForcedLodModel_Skinned) == 0x001118, "Member 'USkinnableSkeletalMeshComponent::ForcedLodModel_Skinned' has a wrong offset!");

// Class DataTableSkinsCommon.SkinnableMergedMeshComponent
// 0x0060 (0x1180 - 0x1120)
class USkinnableMergedMeshComponent final : public USkinnableSkeletalMeshComponent
{
public:
	TMulticastInlineDelegate<void()>              OnMeshMergeComplete;                               // 0x1120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FName>                           CompositeSkeletalMeshKeywords;                     // 0x1130(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAlwaysUseTheFailsafeMeshWhileMerging;             // 0x1140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1141[0x3];                                     // 0x1141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MeshNeedsCPUAccessKeyword;                         // 0x1144(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDelayFullSkinUpdateUntilMeshMergingIsComplete;    // 0x114C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114D[0x3];                                     // 0x114D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          BestPlaceHolderMesh;                               // 0x1150(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMergeMarkedComplete;                              // 0x1158(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1159[0x7];                                     // 0x1159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          CachedMergeResult;                                 // 0x1160(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1168[0x18];                                    // 0x1168(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSkeletalMeshKeyword(class FName InKeyword);
	void RemoveSkeletalMeshKeyword(class FName InKeyword);
	void SetSkeletalMeshKeywords(const TArray<class FName>& InKeywords, class USkeletalMesh* InFailSafeSkeletalMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinnableMergedMeshComponent">();
	}
	static class USkinnableMergedMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkinnableMergedMeshComponent>();
	}
};
static_assert(alignof(USkinnableMergedMeshComponent) == 0x000010, "Wrong alignment on USkinnableMergedMeshComponent");
static_assert(sizeof(USkinnableMergedMeshComponent) == 0x001180, "Wrong size on USkinnableMergedMeshComponent");
static_assert(offsetof(USkinnableMergedMeshComponent, OnMeshMergeComplete) == 0x001120, "Member 'USkinnableMergedMeshComponent::OnMeshMergeComplete' has a wrong offset!");
static_assert(offsetof(USkinnableMergedMeshComponent, CompositeSkeletalMeshKeywords) == 0x001130, "Member 'USkinnableMergedMeshComponent::CompositeSkeletalMeshKeywords' has a wrong offset!");
static_assert(offsetof(USkinnableMergedMeshComponent, bAlwaysUseTheFailsafeMeshWhileMerging) == 0x001140, "Member 'USkinnableMergedMeshComponent::bAlwaysUseTheFailsafeMeshWhileMerging' has a wrong offset!");
static_assert(offsetof(USkinnableMergedMeshComponent, MeshNeedsCPUAccessKeyword) == 0x001144, "Member 'USkinnableMergedMeshComponent::MeshNeedsCPUAccessKeyword' has a wrong offset!");
static_assert(offsetof(USkinnableMergedMeshComponent, bDelayFullSkinUpdateUntilMeshMergingIsComplete) == 0x00114C, "Member 'USkinnableMergedMeshComponent::bDelayFullSkinUpdateUntilMeshMergingIsComplete' has a wrong offset!");
static_assert(offsetof(USkinnableMergedMeshComponent, BestPlaceHolderMesh) == 0x001150, "Member 'USkinnableMergedMeshComponent::BestPlaceHolderMesh' has a wrong offset!");
static_assert(offsetof(USkinnableMergedMeshComponent, bMergeMarkedComplete) == 0x001158, "Member 'USkinnableMergedMeshComponent::bMergeMarkedComplete' has a wrong offset!");
static_assert(offsetof(USkinnableMergedMeshComponent, CachedMergeResult) == 0x001160, "Member 'USkinnableMergedMeshComponent::CachedMergeResult' has a wrong offset!");

// Class DataTableSkinsCommon.SkinnableStaticMeshComponent
// 0x00C0 (0x06F0 - 0x0630)
class USkinnableStaticMeshComponent : public UStaticMeshComponent
{
public:
	bool                                          bDelaySkinUpdatesUntilTick;                        // 0x0628(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkinUpdateIsQueued;                               // 0x0629(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62A[0x2];                                      // 0x062A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StaticMeshKeyword;                                 // 0x062C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            FailSafeStaticMesh;                                // 0x0638(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMultiSkinObject*                       SkinObject;                                        // 0x0640(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowMaterialSkinning;                            // 0x0648(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_649[0x7];                                      // 0x0649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             MaterialSkinningPrefixes;                          // 0x0650(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A0[0x50];                                     // 0x06A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChangePersistentMaterialOverrideById(int32 ParameterId, class UMaterialInterface* MaterialInterface);
	bool ChangePersistentScalarOverrideById(int32 ParameterId, float ParameterValue);
	bool ChangePersistentTextureOverrideById(int32 ParameterId, class UTexture* ParameterValue);
	bool ChangePersistentVectorOverrideById(int32 ParameterId, const struct FLinearColor& ParameterValue);
	void RemovePersistentMaterialParameter(int32 ParameterId);
	int32 SetPersistentMaterialOverride(int32 MaterialSlot, class UMaterialInterface* MaterialInterface, bool bForceNewOverride);
	int32 SetPersistentMaterialOverrideOnAllSlots(class UMaterialInterface* MaterialInterface, bool bForceNewOverride);
	int32 SetPersistentScalarParameter(int32 MaterialSlot, class FName ParameterName, float ParameterValue, bool bForceNewOverride);
	int32 SetPersistentScalarParameterOnAllMaterials(class FName ParameterName, float ParameterValue, bool bForceNewOverride);
	int32 SetPersistentTextureParameter(int32 MaterialSlot, class FName ParameterName, class UTexture* ParameterValue, bool bForceNewOverride);
	int32 SetPersistentTextureParameterOnAllMaterials(class FName ParameterName, class UTexture* ParameterValue, bool bForceNewOverride);
	int32 SetPersistentVectorParameter(int32 MaterialSlot, class FName ParameterName, const struct FLinearColor& ParameterValue, bool bForceNewOverride);
	int32 SetPersistentVectorParameterOnAllMaterials(class FName ParameterName, const struct FLinearColor& ParameterValue, bool bForceNewOverride);
	void SetStaticMeshKeyword(class FName InKeyword, class UStaticMesh* InFailSafeStaticMesh);

	class UMultiSkinObject* GetSkinObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinnableStaticMeshComponent">();
	}
	static class USkinnableStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkinnableStaticMeshComponent>();
	}
};
static_assert(alignof(USkinnableStaticMeshComponent) == 0x000010, "Wrong alignment on USkinnableStaticMeshComponent");
static_assert(sizeof(USkinnableStaticMeshComponent) == 0x0006F0, "Wrong size on USkinnableStaticMeshComponent");
static_assert(offsetof(USkinnableStaticMeshComponent, bDelaySkinUpdatesUntilTick) == 0x000628, "Member 'USkinnableStaticMeshComponent::bDelaySkinUpdatesUntilTick' has a wrong offset!");
static_assert(offsetof(USkinnableStaticMeshComponent, bSkinUpdateIsQueued) == 0x000629, "Member 'USkinnableStaticMeshComponent::bSkinUpdateIsQueued' has a wrong offset!");
static_assert(offsetof(USkinnableStaticMeshComponent, StaticMeshKeyword) == 0x00062C, "Member 'USkinnableStaticMeshComponent::StaticMeshKeyword' has a wrong offset!");
static_assert(offsetof(USkinnableStaticMeshComponent, FailSafeStaticMesh) == 0x000638, "Member 'USkinnableStaticMeshComponent::FailSafeStaticMesh' has a wrong offset!");
static_assert(offsetof(USkinnableStaticMeshComponent, SkinObject) == 0x000640, "Member 'USkinnableStaticMeshComponent::SkinObject' has a wrong offset!");
static_assert(offsetof(USkinnableStaticMeshComponent, bAllowMaterialSkinning) == 0x000648, "Member 'USkinnableStaticMeshComponent::bAllowMaterialSkinning' has a wrong offset!");
static_assert(offsetof(USkinnableStaticMeshComponent, MaterialSkinningPrefixes) == 0x000650, "Member 'USkinnableStaticMeshComponent::MaterialSkinningPrefixes' has a wrong offset!");

// Class DataTableSkinsCommon.SkinObjectManagerComponent
// 0x00A0 (0x0140 - 0x00A0)
class USkinObjectManagerComponent final : public UActorComponent
{
public:
	TMap<class FName, class UMultiSkinObject*>    SkinObjects;                                       // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class UMultiSkinObject*>                 SkinObjectsSet;                                    // 0x00F0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinObjectManagerComponent">();
	}
	static class USkinObjectManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkinObjectManagerComponent>();
	}
};
static_assert(alignof(USkinObjectManagerComponent) == 0x000008, "Wrong alignment on USkinObjectManagerComponent");
static_assert(sizeof(USkinObjectManagerComponent) == 0x000140, "Wrong size on USkinObjectManagerComponent");
static_assert(offsetof(USkinObjectManagerComponent, SkinObjects) == 0x0000A0, "Member 'USkinObjectManagerComponent::SkinObjects' has a wrong offset!");
static_assert(offsetof(USkinObjectManagerComponent, SkinObjectsSet) == 0x0000F0, "Member 'USkinObjectManagerComponent::SkinObjectsSet' has a wrong offset!");

// Class DataTableSkinsCommon.SkinTagAssetInterface
// 0x0000 (0x0000 - 0x0000)
class ISkinTagAssetInterface final
{
public:
	void HandleOnNewSkinTagAsset(TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset);
	void HandleOnSkinTagAssetRemoved(TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinTagAssetInterface">();
	}
	static class ISkinTagAssetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkinTagAssetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISkinTagAssetInterface) == 0x000001, "Wrong alignment on ISkinTagAssetInterface");
static_assert(sizeof(ISkinTagAssetInterface) == 0x000001, "Wrong size on ISkinTagAssetInterface");

}

