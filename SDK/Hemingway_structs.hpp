#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hemingway

#include "Basic.hpp"

#include "RallyHereIntegration_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "NetCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "BanPickDraftCommon_structs.hpp"
#include "RallyHereAPI_structs.hpp"
#include "AIModule_structs.hpp"
#include "KantanChartsDatasource_structs.hpp"
#include "RallyHereStart_structs.hpp"
#include "DataTableSkinsCommon_structs.hpp"


namespace SDK
{

// Enum Hemingway.EHWAdjustAttributeEventType
// NumValues: 0x000D
enum class EHWAdjustAttributeEventType : uint8
{
	AdjustBaseDamageToTarget                 = 0,
	AdjustDamageToTarget                     = 1,
	AdjustDamageReceived                     = 2,
	AdjustAttackPowerScaling                 = 3,
	AdjustPenetration                        = 4,
	AdjustCritDamageMultiplierToTarget       = 5,
	AdjustCritDamageMultiplierReceived       = 6,
	AdjustHealToSelf                         = 7,
	AdjustHealToTarget                       = 8,
	AdjustHealPowerScaling                   = 9,
	AdjustGoldRecieved                       = 10,
	AdjustXpRecieved                         = 11,
	EHWAdjustAttributeEventType_MAX          = 12,
};

// Enum Hemingway.EHWAttributeModifierEnum
// NumValues: 0x000C
enum class EHWAttributeModifierEnum : uint8
{
	BaseDamage                               = 0,
	Damage                                   = 1,
	AttackPowerScaling                       = 2,
	FlatPen                                  = 3,
	PercentPen                               = 4,
	TotalPenetration                         = 5,
	CritDamageMultiplier                     = 6,
	Heal                                     = 7,
	HealPowerScaling                         = 8,
	Gold                                     = 9,
	XP                                       = 10,
	EHWAttributeModifierEnum_MAX             = 11,
};

// Enum Hemingway.EHWBoulderState
// NumValues: 0x0006
enum class EHWBoulderState : uint8
{
	Active                                   = 0,
	Inactive_RollOutHitTarget                = 1,
	Inactive_LeapFinished                    = 2,
	Inactive_TimedOut                        = 3,
	Inactive_Canceled                        = 4,
	EHWBoulderState_MAX                      = 5,
};

// Enum Hemingway.EHWEndFlightReason
// NumValues: 0x0004
enum class EHWEndFlightReason : uint8
{
	FlightComplete                           = 0,
	FlightForceEnd                           = 1,
	CharacterDeath                           = 2,
	EHWEndFlightReason_MAX                   = 3,
};

// Enum Hemingway.EHWEndGrabReason
// NumValues: 0x0006
enum class EHWEndGrabReason : uint8
{
	Complete                                 = 0,
	ForceEnd                                 = 1,
	CharacterDeath                           = 2,
	DisabledMovement                         = 3,
	NewGrabStart                             = 4,
	EHWEndGrabReason_MAX                     = 5,
};

// Enum Hemingway.EHWEndTweenReason
// NumValues: 0x0007
enum class EHWEndTweenReason : uint8
{
	TweenComplete                            = 0,
	TweenForceEnd                            = 1,
	CharacterDeath                           = 2,
	NewTweenStart                            = 3,
	FailedToStart                            = 4,
	InvalidPlaneOfExistence                  = 5,
	EHWEndTweenReason_MAX                    = 6,
};

// Enum Hemingway.EAbilityFlowPhase
// NumValues: 0x0009
enum class EAbilityFlowPhase : uint8
{
	None                                     = 0,
	Targeting                                = 1,
	BuildUp                                  = 2,
	PreFire                                  = 4,
	Fire                                     = 8,
	PostFire                                 = 16,
	Ending                                   = 32,
	Inactive                                 = 64,
	EAbilityFlowPhase_MAX                    = 65,
};

// Enum Hemingway.EHWAIGoalStatus
// NumValues: 0x0005
enum class EHWAIGoalStatus : uint8
{
	Inactive                                 = 0,
	InProgress                               = 1,
	Failed                                   = 2,
	Succeeded                                = 3,
	EHWAIGoalStatus_MAX                      = 4,
};

// Enum Hemingway.ETargetDataTypeSlot
// NumValues: 0x0003
enum class ETargetDataTypeSlot : uint8
{
	AimData                                  = 0,
	TargetList                               = 1,
	ETargetDataTypeSlot_MAX                  = 2,
};

// Enum Hemingway.EAbilityAttackActivationTrigger
// NumValues: 0x0004
enum class EAbilityAttackActivationTrigger : uint8
{
	Instant                                  = 0,
	Delayed                                  = 1,
	Custom                                   = 2,
	EAbilityAttackActivationTrigger_MAX      = 3,
};

// Enum Hemingway.EHWCollectionItemType
// NumValues: 0x0019
enum class EHWCollectionItemType : uint8
{
	None                                     = 0,
	PlayerBadge                              = 1,
	Title                                    = 2,
	Tracker                                  = 3,
	Skin                                     = 4,
	CardVFX                                  = 5,
	Emote                                    = 6,
	AscensionPass                            = 7,
	Anim                                     = 8,
	Character                                = 9,
	JumpStamp                                = 10,
	SeasonShopSeason                         = 11,
	Chest                                    = 12,
	MusicPack                                = 13,
	Bundle                                   = 14,
	Booster                                  = 15,
	PlayerNameColor                          = 16,
	Ward                                     = 17,
	GlobalEmoteSlot                          = 18,
	Notification                             = 19,
	SoundEmote                               = 20,
	SoundEmoteSlot                           = 21,
	AnnouncerPack                            = 22,
	TeleporterVFX                            = 23,
	EHWCollectionItemType_MAX                = 24,
};

// Enum Hemingway.EHWVIPOwnershipLevel
// NumValues: 0x0003
enum class EHWVIPOwnershipLevel : uint8
{
	None                                     = 0,
	Base                                     = 1,
	EHWVIPOwnershipLevel_MAX                 = 2,
};

// Enum Hemingway.EHWEndLevitationReason
// NumValues: 0x0004
enum class EHWEndLevitationReason : uint8
{
	LevitationComplete                       = 0,
	LevitationForceEnd                       = 1,
	CharacterDeath                           = 2,
	EHWEndLevitationReason_MAX               = 3,
};

// Enum Hemingway.EAbilityCastStyle
// NumValues: 0x0005
enum class EAbilityCastStyle : uint8
{
	None                                     = 0,
	InstantCast                              = 1,
	QuickCast                                = 2,
	NormalCast                               = 4,
	EAbilityCastStyle_MAX                    = 5,
};

// Enum Hemingway.ECharacterRole
// NumValues: 0x0008
enum class ECharacterRole : uint8
{
	ENone                                    = 0,
	ESolo                                    = 1,
	EJungle                                  = 2,
	EMiddle                                  = 3,
	ECarry                                   = 4,
	ESupport                                 = 5,
	EFill                                    = 6,
	ECharacterRole_MAX                       = 7,
};

// Enum Hemingway.EHWAutoBuyState
// NumValues: 0x0005
enum class EHWAutoBuyState : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	BuildComplete                            = 2,
	Manual                                   = 3,
	EHWAutoBuyState_MAX                      = 4,
};

// Enum Hemingway.EHWBackfillState
// NumValues: 0x0005
enum class EHWBackfillState : uint8
{
	Connecting                               = 1,
	Backfilling                              = 2,
	Joining                                  = 3,
	None                                     = 0,
	EHWBackfillState_MAX                     = 4,
};

// Enum Hemingway.EHWChatEntryType
// NumValues: 0x0006
enum class EHWChatEntryType : uint8
{
	Unknown                                  = 0,
	Command                                  = 1,
	System                                   = 2,
	Player                                   = 3,
	VGS                                      = 4,
	EHWChatEntryType_MAX                     = 5,
};

// Enum Hemingway.EDynamicItemAvailabilityRestriction
// NumValues: 0x0004
enum class EDynamicItemAvailabilityRestriction : uint8
{
	All                                      = 0,
	TeamOfRelatedCharacter                   = 1,
	RelatedCharacterOnly                     = 2,
	EDynamicItemAvailabilityRestriction_MAX  = 3,
};

// Enum Hemingway.EHWGameStatePhase
// NumValues: 0x0005
enum class EHWGameStatePhase : uint8
{
	None                                     = 0,
	DraftPick                                = 1,
	Preparation                              = 2,
	MinionsSpawned                           = 3,
	EHWGameStatePhase_MAX                    = 4,
};

// Enum Hemingway.EHWInventoryChangeReason
// NumValues: 0x0009
enum class EHWInventoryChangeReason : uint8
{
	None                                     = 0,
	Purchase                                 = 1,
	Sold                                     = 2,
	Undo                                     = 3,
	Granted                                  = 4,
	Swap                                     = 5,
	DroppedItem                              = 6,
	PickedUpItem                             = 7,
	EHWInventoryChangeReason_MAX             = 8,
};

// Enum Hemingway.EHWInputHardwareType
// NumValues: 0x0007
enum class EHWInputHardwareType : uint8
{
	MouseAndKeyboard                         = 0,
	DualShock                                = 1,
	XBox                                     = 2,
	Switch                                   = 3,
	Steam                                    = 4,
	None                                     = 5,
	EHWInputHardwareType_MAX                 = 6,
};

// Enum Hemingway.EHWDestroyProjectileReason
// NumValues: 0x0005
enum class EHWDestroyProjectileReason : uint8
{
	None                                     = 0,
	Expired                                  = 1,
	ExplodeOnWorld                           = 2,
	ExplodeOnTarget                          = 4,
	EHWDestroyProjectileReason_MAX           = 5,
};

// Enum Hemingway.EHWTradeRequestResult
// NumValues: 0x0007
enum class EHWTradeRequestResult : uint8
{
	Invalid                                  = 0,
	Blocked                                  = 1,
	Pending                                  = 2,
	Accepted                                 = 3,
	Declined                                 = 4,
	TimedOut                                 = 5,
	EHWTradeRequestResult_MAX                = 6,
};

// Enum Hemingway.EHWVoteResult
// NumValues: 0x0005
enum class EHWVoteResult : uint8
{
	Timeout                                  = 0,
	Restricted                               = 1,
	Passed                                   = 2,
	Failed                                   = 3,
	EHWVoteResult_MAX                        = 4,
};

// Enum Hemingway.EAbilityCollisionType
// NumValues: 0x0004
enum class EAbilityCollisionType : uint8
{
	AbilityVolume_Default                    = 0,
	AbilityVolume_Aura                       = 1,
	AbilityVolume_Custom                     = 2,
	AbilityVolume_MAX                        = 3,
};

// Enum Hemingway.EHWPushPullForceMode
// NumValues: 0x0003
enum class EHWPushPullForceMode : uint8
{
	Push                                     = 0,
	Pull                                     = 1,
	EHWPushPullForceMode_MAX                 = 2,
};

// Enum Hemingway.EHWForceDirectionBehavior
// NumValues: 0x0003
enum class EHWForceDirectionBehavior : uint8
{
	Radial                                   = 0,
	FixedDirection                           = 1,
	EHWForceDirectionBehavior_MAX            = 2,
};

// Enum Hemingway.EHWAladdinWallRunDirection
// NumValues: 0x0004
enum class EHWAladdinWallRunDirection : uint8
{
	Center                                   = 0,
	Left                                     = 1,
	Right                                    = 2,
	EHWAladdinWallRunDirection_MAX           = 3,
};

// Enum Hemingway.EHWAladdinWallRunClampBehavior
// NumValues: 0x0004
enum class EHWAladdinWallRunClampBehavior : uint8
{
	HeightAndDistance                        = 0,
	HeightAndHypotenus                       = 1,
	DistanceAndHypotenus                     = 2,
	EHWAladdinWallRunClampBehavior_MAX       = 3,
};

// Enum Hemingway.EHWAdvantageTypes
// NumValues: 0x0006
enum class EHWAdvantageTypes : uint8
{
	Disadvantage                             = 0,
	Neutral                                  = 1,
	Advantage                                = 2,
	MassiveDisadvantage                      = 3,
	MassiveAdvantage                         = 4,
	EHWAdvantageTypes_MAX                    = 5,
};

// Enum Hemingway.EHWBotDifficulty
// NumValues: 0x0005
enum class EHWBotDifficulty : uint8
{
	Easy                                     = 0,
	Medium                                   = 1,
	Hard                                     = 2,
	Unknown                                  = 3,
	EHWBotDifficulty_MAX                     = 4,
};

// Enum Hemingway.EHWAIPlayTargetDisplayType
// NumValues: 0x0006
enum class EHWAIPlayTargetDisplayType : uint8
{
	PlayerName                               = 0,
	GodPortrait                              = 1,
	Lane                                     = 2,
	GodName                                  = 3,
	None                                     = 4,
	EHWAIPlayTargetDisplayType_MAX           = 5,
};

// Enum Hemingway.EHWAIPlayGameStage
// NumValues: 0x0005
enum class EHWAIPlayGameStage : uint8
{
	Setup                                    = 0,
	Laning                                   = 1,
	Teamfight                                = 2,
	Endgame                                  = 3,
	EHWAIPlayGameStage_MAX                   = 4,
};

// Enum Hemingway.ELaneSelectType
// NumValues: 0x0003
enum class ELaneSelectType : uint8
{
	Sequential                               = 0,
	Random                                   = 1,
	ELaneSelectType_MAX                      = 2,
};

// Enum Hemingway.EWaypointPathDirectionType
// NumValues: 0x0004
enum class EWaypointPathDirectionType : uint8
{
	TwoWay                                   = 0,
	OneWayForward                            = 1,
	OneWayReverse                            = 2,
	EWaypointPathDirectionType_MAX           = 3,
};

// Enum Hemingway.EAITargetPriorityType
// NumValues: 0x0005
enum class EAITargetPriorityType : uint8
{
	None                                     = 0,
	LeastTargeted                            = 1,
	LowestHP                                 = 2,
	HighestHP                                = 3,
	EAITargetPriorityType_MAX                = 4,
};

// Enum Hemingway.EAITargetRangeType
// NumValues: 0x0004
enum class EAITargetRangeType : uint8
{
	None                                     = 0,
	CloserThan                               = 1,
	FartherThan                              = 2,
	EAITargetRangeType_MAX                   = 3,
};

// Enum Hemingway.EHWNiagaraVarType
// NumValues: 0x0007
enum class EHWNiagaraVarType : uint8
{
	None                                     = 0,
	BoolParam                                = 1,
	IntParam                                 = 2,
	FloatParam                               = 3,
	ColorParam                               = 4,
	Vector3Param                             = 5,
	EHWNiagaraVarType_MAX                    = 6,
};

// Enum Hemingway.EHWApparelApplicationResult
// NumValues: 0x0007
enum class EHWApparelApplicationResult : uint8
{
	NotStarted                               = 0,
	InProgress                               = 1,
	Success                                  = 2,
	Applied                                  = 3,
	Failed                                   = 4,
	Unloaded                                 = 5,
	EHWApparelApplicationResult_MAX          = 6,
};

// Enum Hemingway.EFactoryMinimapState
// NumValues: 0x0005
enum class EFactoryMinimapState : uint8
{
	FactoryEmpty                             = 0,
	FactoryActive                            = 1,
	FactoryHoldingBuff                       = 2,
	FactoryRespawning                        = 3,
	EFactoryMinimapState_MAX                 = 4,
};

// Enum Hemingway.EAbilityDataType
// NumValues: 0x0004
enum class EAbilityDataType : uint8
{
	Range                                    = 0,
	Angle                                    = 1,
	Radius                                   = 2,
	EAbilityDataType_MAX                     = 3,
};

// Enum Hemingway.EHWNpcPostureState
// NumValues: 0x0004
enum class EHWNpcPostureState : uint8
{
	Default                                  = 0,
	Aware                                    = 1,
	Resting                                  = 2,
	EHWNpcPostureState_MAX                   = 3,
};

// Enum Hemingway.EHWPlayerChatMode
// NumValues: 0x0005
enum class EHWPlayerChatMode : uint8
{
	NoPlayerChat                             = 0,
	TeamOnly                                 = 1,
	AllChat                                  = 2,
	Invalid                                  = 3,
	EHWPlayerChatMode_MAX                    = 4,
};

// Enum Hemingway.ECombatEventType
// NumValues: 0x000E
enum class ECombatEventType : uint8
{
	Damage                                   = 0,
	CRIT_DAMAGE                              = 1,
	EXPERIENCE                               = 2,
	CURRENCY                                 = 3,
	KILLING_BLOW                             = 4,
	Healing                                  = 5,
	CROWD_CONTROL                            = 6,
	ASSIST                                   = 7,
	Death                                    = 8,
	Status                                   = 9,
	LEVEL_UP                                 = 10,
	MANA_RESTORE                             = 11,
	None                                     = 12,
	ECombatEventType_MAX                     = 13,
};

// Enum Hemingway.EItemEventType
// NumValues: 0x0007
enum class EItemEventType : uint8
{
	CAST_START                               = 0,
	CAST_COMPLETE                            = 1,
	CAST_INTERRUPT                           = 2,
	ITEM_PURCHASE                            = 3,
	ITEM_SELL                                = 4,
	ABILITY_PURCHASE                         = 5,
	EItemEventType_MAX                       = 6,
};

// Enum Hemingway.EPlayerEventType
// NumValues: 0x0006
enum class EPlayerEventType : uint8
{
	GOD_HOVERED                              = 0,
	GOD_PICKED                               = 1,
	SKIN_HOVERED                             = 2,
	SKIN_PICKED                              = 3,
	ROLE_ASSIGNED                            = 4,
	EPlayerEventType_MAX                     = 5,
};

// Enum Hemingway.ERewardSourceType
// NumValues: 0x0005
enum class ERewardSourceType : uint8
{
	REWARD_MISC                              = 0,
	REWARD_PRIMARY_KILLER                    = 1,
	REWARD_ASSIST                            = 2,
	REWARD_TEAM_OBJECTIVE                    = 3,
	REWARD_MAX                               = 4,
};

// Enum Hemingway.EHWCameraMode
// NumValues: 0x0004
enum class EHWCameraMode : uint8
{
	Default                                  = 0,
	Free1                                    = 1,
	Free2                                    = 2,
	EHWCameraMode_MAX                        = 3,
};

// Enum Hemingway.EHWVisibilityRequired
// NumValues: 0x0005
enum class EHWVisibilityRequired : uint8
{
	None                                     = 0,
	Minimap                                  = 1,
	LocalFieldOfView                         = 2,
	Any                                      = 4,
	EHWVisibilityRequired_MAX                = 5,
};

// Enum Hemingway.EHWDisplayOnCharacterType
// NumValues: 0x0007
enum class EHWDisplayOnCharacterType : uint8
{
	None                                     = 0,
	LocalCharacter                           = 1,
	RemoteCharacter                          = 2,
	FriendlyCharacter                        = 4,
	HostileCharacter                         = 8,
	Any                                      = 255,
	EHWDisplayOnCharacterType_MAX            = 256,
};

// Enum Hemingway.EHWDisplayInfoComponentFlag
// NumValues: 0x0004
enum class EHWDisplayInfoComponentFlag : uint8
{
	None                                     = 0,
	OwnerIsLockedOnCandidate                 = 1,
	OwnerIsHighlighted                       = 2,
	EHWDisplayInfoComponentFlag_MAX          = 3,
};

// Enum Hemingway.EHWDraftHealerRequirement
// NumValues: 0x0006
enum class EHWDraftHealerRequirement : uint8
{
	None                                     = 0,
	Tier1                                    = 1,
	Tier2                                    = 2,
	Tier3                                    = 3,
	Open                                     = 4,
	EHWDraftHealerRequirement_MAX            = 5,
};

// Enum Hemingway.EHWDraftType
// NumValues: 0x0006
enum class EHWDraftType : uint8
{
	Casual                                   = 0,
	Ranked                                   = 1,
	Skin                                     = 2,
	Assault                                  = 3,
	Duel                                     = 4,
	EHWDraftType_MAX                         = 5,
};

// Enum Hemingway.LevitateCollisionProfileChoice
// NumValues: 0x0005
enum class ELevitateCollisionProfileChoice : uint8
{
	MaintainCharacterCollision               = 0,
	Custom                                   = 1,
	NoCollision                              = 2,
	WorldCollision                           = 3,
	LevitateCollisionProfileChoice_MAX       = 4,
};

// Enum Hemingway.EHWEndLevitationBehavior
// NumValues: 0x0003
enum class EHWEndLevitationBehavior : uint8
{
	InPlace                                  = 0,
	ToEndLocation                            = 1,
	EHWEndLevitationBehavior_MAX             = 2,
};

// Enum Hemingway.EHWLevitationState
// NumValues: 0x0007
enum class EHWLevitationState : uint8
{
	Starting                                 = 0,
	Ascending                                = 1,
	Hovering                                 = 2,
	Descending                               = 3,
	Ending                                   = 4,
	Inactive                                 = 5,
	EHWLevitationState_MAX                   = 6,
};

// Enum Hemingway.EHWGroupingField
// NumValues: 0x0006
enum class EHWGroupingField : uint8
{
	None                                     = 0,
	Team                                     = 1,
	Source                                   = 2,
	Target                                   = 3,
	Item                                     = 4,
	EHWGroupingField_MAX                     = 5,
};

// Enum Hemingway.EHWBoosterClaimType
// NumValues: 0x0003
enum class EHWBoosterClaimType : uint8
{
	EManualClaim                             = 0,
	EMatchStart                              = 1,
	EHWBoosterClaimType_MAX                  = 2,
};

// Enum Hemingway.EHWPingScope
// NumValues: 0x0004
enum class EHWPingScope : uint8
{
	Team                                     = 0,
	Global                                   = 1,
	Owner                                    = 2,
	EHWPingScope_MAX                         = 3,
};

// Enum Hemingway.EHWPingDisplayArea
// NumValues: 0x0004
enum class EHWPingDisplayArea : uint8
{
	Minimap                                  = 0,
	World                                    = 1,
	All                                      = 2,
	EHWPingDisplayArea_MAX                   = 3,
};

// Enum Hemingway.EHWPingSource
// NumValues: 0x0004
enum class EHWPingSource : uint8
{
	Unknown                                  = 0,
	VGSInput                                 = 1,
	MinimapInput                             = 2,
	EHWPingSource_MAX                        = 3,
};

// Enum Hemingway.EHWProjectileReturnTrigger
// NumValues: 0x0004
enum class EHWProjectileReturnTrigger : uint8
{
	MaxRange                                 = 0,
	Time                                     = 1,
	Custom                                   = 2,
	EHWProjectileReturnTrigger_MAX           = 3,
};

// Enum Hemingway.EHWQuestComponent_KVMultiplierType
// NumValues: 0x0003
enum class EHWQuestComponent_KVMultiplierType : uint32
{
	KVAsValue                                = 0,
	KVAsFlag                                 = 1,
	EHWQuestComponent_MAX                    = 2,
};

// Enum Hemingway.EShieldType
// NumValues: 0x0004
enum class EShieldType : uint8
{
	Shield_Physical                          = 0,
	Shield_Magical                           = 1,
	Shield_Omni                              = 2,
	Shield_MAX                               = 3,
};

// Enum Hemingway.EHWVGSFloodProtectionType
// NumValues: 0x0005
enum class EHWVGSFloodProtectionType : uint8
{
	AllClients                               = 0,
	RemoteClientsOnly                        = 1,
	None                                     = 2,
	Emote                                    = 3,
	EHWVGSFloodProtectionType_MAX            = 4,
};

// Enum Hemingway.EVolumeApplicationTiming
// NumValues: 0x0004
enum class EVolumeApplicationTiming : uint32
{
	Enter                                    = 0,
	Leave                                    = 1,
	None                                     = 2,
	EVolumeApplicationTiming_MAX             = 3,
};

// Enum Hemingway.EHWSmiteTeamId
// NumValues: 0x0006
enum class EHWSmiteTeamId : uint8
{
	None                                     = 0,
	Order                                    = 1,
	Chaos                                    = 2,
	Neutral                                  = 3,
	Spectator                                = 16,
	EHWSmiteTeamId_MAX                       = 17,
};

// Enum Hemingway.EHWAimSettingLockOnCalcBehavior
// NumValues: 0x0004
enum class EHWAimSettingLockOnCalcBehavior : uint8
{
	Modular                                  = 0,
	Global                                   = 1,
	RadialPlayerSelector                     = 2,
	EHWAimSettingLockOnCalcBehavior_MAX      = 3,
};

// Enum Hemingway.EHWAimSettingGlobalLockOnTargetType
// NumValues: 0x0003
enum class EHWAimSettingGlobalLockOnTargetType : uint8
{
	None                                     = 0,
	Gods                                     = 1,
	EHWAimSettingGlobalLockOnTargetType_MAX  = 2,
};

// Enum Hemingway.EAbilityAttackType
// NumValues: 0x000A
enum class EAbilityAttackType : uint8
{
	Custom                                   = 0,
	InstantShape                             = 1,
	Deployable                               = 2,
	Projectile                               = 3,
	Collision                                = 4,
	Dash                                     = 5,
	CloneCharacterSwap                       = 6,
	SpawnFamiliar                            = 7,
	Interact                                 = 8,
	EAbilityAttackType_MAX                   = 9,
};

// Enum Hemingway.EHWDeployableAttackSettingUseAimOriginForHighlighting
// NumValues: 0x0004
enum class EHWDeployableAttackSettingUseAimOriginForHighlighting : uint8
{
	Default                                  = 0,
	Yes                                      = 1,
	No                                       = 2,
	EHWDeployableAttackSettingUseAimOriginForHighlighting_MAX = 3,
};

// Enum Hemingway.EHWTargetingSearchType
// NumValues: 0x0003
enum class EHWTargetingSearchType : uint8
{
	CollisionTrace                           = 0,
	ObjectType                               = 1,
	EHWTargetingSearchType_MAX               = 2,
};

// Enum Hemingway.EHWAbilityActivationPolicy
// NumValues: 0x0005
enum class EHWAbilityActivationPolicy : uint8
{
	OnInputTriggered                         = 0,
	WhileInputActive                         = 1,
	ActivateOnGranted                        = 2,
	Custom                                   = 3,
	EHWAbilityActivationPolicy_MAX           = 4,
};

// Enum Hemingway.EAbilityCommitPolicyType
// NumValues: 0x0008
enum class EAbilityCommitPolicyType : uint8
{
	CommitOnTargeting                        = 0,
	CommitOnBuildUp                          = 1,
	CommitOnPrefire                          = 2,
	CommitOnFire                             = 3,
	CommitOnFireAttack                       = 4,
	CommitOnEndAbility                       = 5,
	Custom                                   = 6,
	EAbilityCommitPolicyType_MAX             = 7,
};

// Enum Hemingway.EAbilityAimType
// NumValues: 0x0006
enum class EAbilityAimType : uint8
{
	Custom                                   = 0,
	Self                                     = 1,
	Linear                                   = 2,
	GroundTarget                             = 3,
	Wedge                                    = 4,
	EAbilityAimType_MAX                      = 5,
};

// Enum Hemingway.EHWForcedCharacterFiringCategory
// NumValues: 0x0003
enum class EHWForcedCharacterFiringCategory : uint8
{
	ManualInterval                           = 0,
	ContinuousFiring                         = 1,
	EHWForcedCharacterFiringCategory_MAX     = 2,
};

// Enum Hemingway.EHWForcedCharacterMovementCategory
// NumValues: 0x0006
enum class EHWForcedCharacterMovementCategory : uint8
{
	None                                     = 0,
	Taunt                                    = 1,
	Madness                                  = 2,
	Fear                                     = 3,
	Sliding                                  = 4,
	EHWForcedCharacterMovementCategory_MAX   = 5,
};

// Enum Hemingway.EHWForcedCharacterMovementBehavior
// NumValues: 0x0007
enum class EHWForcedCharacterMovementBehavior : uint8
{
	None                                     = 0,
	AwayFromEffectCauser                     = 1,
	TowardsEffectCauser                      = 2,
	AwayFromInstigator                       = 3,
	TowardsInstigator                        = 4,
	RandomDirection                          = 5,
	EHWForcedCharacterMovementBehavior_MAX   = 6,
};

// Enum Hemingway.EHWDeathImmunityHealthThresholdType
// NumValues: 0x0003
enum class EHWDeathImmunityHealthThresholdType : uint8
{
	SpecificValue                            = 0,
	PercentageOfMaxHealth                    = 1,
	EHWDeathImmunityHealthThresholdType_MAX  = 2,
};

// Enum Hemingway.EHWTetherType
// NumValues: 0x0003
enum class EHWTetherType : uint8
{
	VFX_Beam                                 = 0,
	SplineMesh                               = 1,
	EHWTetherType_MAX                        = 2,
};

// Enum Hemingway.EHWEffectApplicationPolicy
// NumValues: 0x0004
enum class EHWEffectApplicationPolicy : uint8
{
	None                                     = 0,
	StrongestWins                            = 1,
	NewestWins                               = 2,
	EHWEffectApplicationPolicy_MAX           = 3,
};

// Enum Hemingway.EHWEffectGrantedVisionType
// NumValues: 0x0003
enum class EHWEffectGrantedVisionType : uint8
{
	GrantVisionToTeamOfInstigator            = 0,
	GrantVisionToInstigatorOnly              = 1,
	EHWEffectGrantedVisionType_MAX           = 2,
};

// Enum Hemingway.EHWImpulseVectorOverrideType
// NumValues: 0x0004
enum class EHWImpulseVectorOverrideType : uint8
{
	NoOverride                               = 0,
	UseTargetDestination                     = 1,
	UseTargetDirectionLateral                = 2,
	EHWImpulseVectorOverrideType_MAX         = 3,
};

// Enum Hemingway.EStealthCategory
// NumValues: 0x0006
enum class EStealthCategory : uint8
{
	None                                     = 0,
	MinimapStealth                           = 1,
	OverlayStealth                           = 2,
	MeshStealth                              = 4,
	SpectatorStealth                         = 8,
	EStealthCategory_MAX                     = 9,
};

// Enum Hemingway.EUndyingThresholdType
// NumValues: 0x0003
enum class EUndyingThresholdType : uint8
{
	SpecificValue                            = 0,
	PercentageOfMaxHealth                    = 1,
	EUndyingThresholdType_MAX                = 2,
};

// Enum Hemingway.ETargetDataFilterTeam
// NumValues: 0x0004
enum class ETargetDataFilterTeam : uint8
{
	AnyTeam                                  = 0,
	Enemies                                  = 1,
	Friendlies                               = 2,
	ETargetDataFilterTeam_MAX                = 3,
};

// Enum Hemingway.ETargetingLocationPriorityBehavior
// NumValues: 0x0005
enum class ETargetingLocationPriorityBehavior : uint8
{
	None                                     = 0,
	ClosestToAimOrigin                       = 1,
	ClosestToAimVector                       = 2,
	ClosestToVectorWithinRadiusThreshold     = 3,
	ETargetingLocationPriorityBehavior_MAX   = 4,
};

// Enum Hemingway.EHWGroundTargetValidationType
// NumValues: 0x0005
enum class EHWGroundTargetValidationType : uint8
{
	None                                     = 0,
	AimCenter                                = 1,
	SourceActorCollision                     = 2,
	ManualCollision                          = 3,
	EHWGroundTargetValidationType_MAX        = 4,
};

// Enum Hemingway.EReticleOrientationBehavior
// NumValues: 0x0006
enum class EReticleOrientationBehavior : uint8
{
	None                                     = 0,
	FaceTowardsInstigator                    = 1,
	FaceAwayFromInstigator                   = 2,
	MatchAimRotation                         = 3,
	MatchControlRotation                     = 4,
	EReticleOrientationBehavior_MAX          = 5,
};

// Enum Hemingway.EReticlePlacementBehavior
// NumValues: 0x0006
enum class EReticlePlacementBehavior : uint8
{
	None                                     = 0,
	Origin                                   = 1,
	EndPosition                              = 2,
	ProjectileExplodeLocation                = 3,
	Custom                                   = 4,
	EReticlePlacementBehavior_MAX            = 5,
};

// Enum Hemingway.EReticleRenderBehavior
// NumValues: 0x0006
enum class EReticleRenderBehavior : uint8
{
	None                                     = 0,
	Background                               = 1,
	BackgroundInvalid                        = 2,
	Foreground                               = 3,
	ForegroundInvalid                        = 4,
	EReticleRenderBehavior_MAX               = 5,
};

// Enum Hemingway.EMontagePhaseNotifyEvent
// NumValues: 0x0006
enum class EMontagePhaseNotifyEvent : uint8
{
	Invalid                                  = 0,
	Exclusive                                = 1,
	Starting                                 = 2,
	Ending                                   = 3,
	Instant                                  = 4,
	EMontagePhaseNotifyEvent_MAX             = 5,
};

// Enum Hemingway.EFactorySpawnQueueWaveSelectionMethod
// NumValues: 0x0002
enum class EFactorySpawnQueueWaveSelectionMethod : uint8
{
	Sequential                               = 0,
	EFactorySpawnQueueWaveSelectionMethod_MAX = 1,
};

// Enum Hemingway.EFactorySpawnQueueRestartTriggerMethod
// NumValues: 0x0004
enum class EFactorySpawnQueueRestartTriggerMethod : uint8
{
	None                                     = 0,
	OnSpawnQueueEnd                          = 1,
	OnFactoryEmptied                         = 2,
	EFactorySpawnQueueRestartTriggerMethod_MAX = 3,
};

// Enum Hemingway.EFactorySpawnPointSelectionMethod
// NumValues: 0x0003
enum class EFactorySpawnPointSelectionMethod : uint8
{
	Sequential                               = 0,
	Random                                   = 1,
	EFactorySpawnPointSelectionMethod_MAX    = 2,
};

// Enum Hemingway.EFactoryRewardType
// NumValues: 0x0003
enum class EFactoryRewardType : uint8
{
	Buff                                     = 0,
	GameplayEffect                           = 1,
	EFactoryRewardType_MAX                   = 2,
};

// Enum Hemingway.EFactoryRewardTrigger
// NumValues: 0x0003
enum class EFactoryRewardTrigger : uint8
{
	OnFactoryEmptied                         = 0,
	OnTargetSpawnKilled                      = 1,
	EFactoryRewardTrigger_MAX                = 2,
};

// Enum Hemingway.EFactoryRewardTarget
// NumValues: 0x0003
enum class EFactoryRewardTarget : uint8
{
	Killer                                   = 0,
	KillerTeam                               = 1,
	EFactoryRewardTarget_MAX                 = 2,
};

// Enum Hemingway.EIntroPresentationType
// NumValues: 0x0005
enum class EIntroPresentationType : uint8
{
	None                                     = 0,
	God                                      = 1,
	Skin                                     = 2,
	InstantOn                                = 3,
	EIntroPresentationType_MAX               = 4,
};

// Enum Hemingway.EBlockActionPresets
// NumValues: 0x0003
enum class EBlockActionPresets : uint8
{
	NONE                                     = 0,
	Custom                                   = 1,
	EBlockActionPresets_MAX                  = 2,
};

// Enum Hemingway.EHWPlayerDraftingState
// NumValues: 0x0005
enum class EHWPlayerDraftingState : uint8
{
	None                                     = 0,
	Banning                                  = 1,
	Picking                                  = 2,
	LockedIn                                 = 3,
	EHWPlayerDraftingState_MAX               = 4,
};

// Enum Hemingway.EHWCustomMovementMode
// NumValues: 0x0006
enum class EHWCustomMovementMode : uint8
{
	None                                     = 0,
	Tweening                                 = 4,
	Dashing                                  = 8,
	Grabbed                                  = 16,
	Flying                                   = 32,
	EHWCustomMovementMode_MAX                = 33,
};

// Enum Hemingway.EHWMovementDirection
// NumValues: 0x0004
enum class EHWMovementDirection : uint8
{
	Forward                                  = 0,
	Backpedal                                = 1,
	Strafe                                   = 2,
	EHWMovementDirection_MAX                 = 3,
};

// Enum Hemingway.EHWAnimStatusEffectState
// NumValues: 0x0009
enum class EHWAnimStatusEffectState : uint8
{
	None                                     = 0,
	Stunned                                  = 1,
	Rooted                                   = 2,
	Knockback                                = 3,
	Silence                                  = 4,
	Feared                                   = 5,
	Stasis                                   = 6,
	Slow                                     = 7,
	EHWAnimStatusEffectState_MAX             = 8,
};

// Enum Hemingway.EHWAnimVisualEffectState
// NumValues: 0x0003
enum class EHWAnimVisualEffectState : uint8
{
	None                                     = 0,
	Falling                                  = 1,
	EHWAnimVisualEffectState_MAX             = 2,
};

// Enum Hemingway.EHWAnimTurnInPlaceType
// NumValues: 0x0003
enum class EHWAnimTurnInPlaceType : uint8
{
	Standing                                 = 0,
	Floating                                 = 1,
	EHWAnimTurnInPlaceType_MAX               = 2,
};

// Enum Hemingway.EHWAnimTurninPLace
// NumValues: 0x0005
enum class EHWAnimTurninPLace : uint8
{
	Left90                                   = 0,
	Left180                                  = 1,
	Right90                                  = 2,
	Right180                                 = 3,
	EHWAnimTurninPLace_MAX                   = 4,
};

// Enum Hemingway.EHWRunDirection
// NumValues: 0x0005
enum class EHWRunDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	Left                                     = 2,
	Right                                    = 3,
	EHWRunDirection_MAX                      = 4,
};

// Enum Hemingway.EHWHitReaction
// NumValues: 0x0004
enum class EHWHitReaction : uint8
{
	None                                     = 0,
	SmallHitReaction                         = 1,
	LargeHitReaction                         = 2,
	EHWHitReaction_MAX                       = 3,
};

// Enum Hemingway.EHWAnimCombatState
// NumValues: 0x0003
enum class EHWAnimCombatState : uint8
{
	NonCombat                                = 0,
	Combat                                   = 1,
	EHWAnimCombatState_MAX                   = 2,
};

// Enum Hemingway.EHWMinimapType
// NumValues: 0x0004
enum class EHWMinimapType : uint8
{
	Melee                                    = 0,
	Ranged                                   = 1,
	Minotaur                                 = 2,
	EHWMinimapType_MAX                       = 3,
};

// Enum Hemingway.EHWMinimapModifier
// NumValues: 0x0004
enum class EHWMinimapModifier : uint8
{
	None                                     = 0,
	Fire                                     = 1,
	Champion                                 = 2,
	EHWMinimapModifier_MAX                   = 3,
};

// Enum Hemingway.EHWApparelComponentState
// NumValues: 0x0009
enum class EHWApparelComponentState : uint8
{
	WaitingForInitialApparel                 = 0,
	ReconcilingReplicatedApparel             = 1,
	WaitingToProcessApparel                  = 2,
	ProcessingApparel                        = 3,
	LoadingInProgress                        = 4,
	WaitingToApply                           = 5,
	Applying                                 = 6,
	AppliedAndReady                          = 7,
	EHWApparelComponentState_MAX             = 8,
};

// Enum Hemingway.EGameplayParameterType
// NumValues: 0x0003
enum class EGameplayParameterType : uint32
{
	ScalarGameplayParameter                  = 0,
	VectorGameplayParameter                  = 1,
	EGameplayParameterType_MAX               = 2,
};

// Enum Hemingway.EHWSplineSegmentMeshType
// NumValues: 0x0004
enum class EHWSplineSegmentMeshType : uint8
{
	StartCap                                 = 0,
	Middle                                   = 1,
	EndCap                                   = 2,
	EHWSplineSegmentMeshType_MAX             = 3,
};

// Enum Hemingway.EHWSplineMeshPlacementBehavior
// NumValues: 0x0003
enum class EHWSplineMeshPlacementBehavior : uint8
{
	OneMeshPerSplineSegment                  = 0,
	DistributeMeshAtFixedIntervals           = 1,
	EHWSplineMeshPlacementBehavior_MAX       = 2,
};

// Enum Hemingway.EHWVisibilityType
// NumValues: 0x0004
enum class EHWVisibilityType : uint8
{
	MeshVisible                              = 0,
	MinimapVisible                           = 1,
	OverlayVisible                           = 2,
	EHWVisibilityType_MAX                    = 3,
};

// Enum Hemingway.EHWCachedProximityVisibilityState
// NumValues: 0x0004
enum class EHWCachedProximityVisibilityState : uint8
{
	NotCached                                = 0,
	CachedVisible                            = 1,
	UnableToCache                            = 2,
	EHWCachedProximityVisibilityState_MAX    = 3,
};

// Enum Hemingway.EHWClampAxis
// NumValues: 0x0005
enum class EHWClampAxis : uint8
{
	ClampNone                                = 0,
	ClampX                                   = 1,
	ClampY                                   = 2,
	ClampZ                                   = 4,
	EHWClampAxis_MAX                         = 5,
};

// Enum Hemingway.EHWDisplayInfoHiddenReason
// NumValues: 0x0006
enum class EHWDisplayInfoHiddenReason : uint8
{
	NotHidden                                = 0,
	UserRequested                            = 1,
	NoMinimapVisibility                      = 2,
	NoLocalFoVVisibility                     = 4,
	NoAnyVisibility                          = 8,
	EHWDisplayInfoHiddenReason_MAX           = 9,
};

// Enum Hemingway.EHWAbilitySwapBehavior
// NumValues: 0x0002
enum class EHWAbilitySwapBehavior : uint8
{
	SwapOnTrigger                            = 0,
	EHWAbilitySwapBehavior_MAX               = 1,
};

// Enum Hemingway.EHWEndAbilitySwapReason
// NumValues: 0x0003
enum class EHWEndAbilitySwapReason : uint8
{
	WindowDurationExpired                    = 0,
	SwapAbilityFired                         = 1,
	EHWEndAbilitySwapReason_MAX              = 2,
};

// Enum Hemingway.EHWFiringInstanceTrackingBehavior
// NumValues: 0x0005
enum class EHWFiringInstanceTrackingBehavior : uint8
{
	OncePerAbility                           = 0,
	OncePerAbilityPerTarget                  = 1,
	OncePerAbilityPerTargetPerEffect         = 2,
	Custom                                   = 3,
	EHWFiringInstanceTrackingBehavior_MAX    = 4,
};

// Enum Hemingway.ERefireAbilityBehavior
// NumValues: 0x0004
enum class ERefireAbilityBehavior : uint32
{
	RefireOriginalChannelingAbility          = 0,
	RefireOriginalNonChannelingAbility       = 1,
	UseSeperateRefireAbility                 = 2,
	ERefireAbilityBehavior_MAX               = 3,
};

// Enum Hemingway.EHWRefireTrigger
// NumValues: 0x0005
enum class EHWRefireTrigger : uint8
{
	None                                     = 0,
	AbilityInput                             = 1,
	AbilityConfirmInput                      = 2,
	AbilityCancelInput                       = 4,
	EHWRefireTrigger_MAX                     = 5,
};

// Enum Hemingway.EItemTransactionRule
// NumValues: 0x0005
enum class EItemTransactionRule : uint8
{
	Default                                  = 0,
	CommitImmediately                        = 1,
	CommitOnAbilityFired                     = 2,
	CommitOnAbilityCooldown                  = 4,
	EItemTransactionRule_MAX                 = 5,
};

// Enum Hemingway.EHWEquipmentItemTooltip_DisplayPhase
// NumValues: 0x0005
enum class EHWEquipmentItemTooltip_DisplayPhase : uint8
{
	OutOfGame                                = 0,
	InGame                                   = 1,
	Both                                     = 2,
	None                                     = 3,
	EHWEquipmentItemTooltip_MAX              = 4,
};

// Enum Hemingway.EHWEquipmentItemTooltip_DisplayMode
// NumValues: 0x0005
enum class EHWEquipmentItemTooltip_DisplayMode : uint8
{
	Simplified                               = 0,
	Advanced                                 = 1,
	Both                                     = 2,
	None                                     = 3,
	EHWEquipmentItemTooltip_MAX              = 4,
};

// Enum Hemingway.EHWEquipmentItemTooltip_DetailType
// NumValues: 0x0004
enum class EHWEquipmentItemTooltip_DetailType : uint8
{
	Keyword                                  = 0,
	CustomText                               = 1,
	Divider                                  = 2,
	EHWEquipmentItemTooltip_MAX              = 3,
};

// Enum Hemingway.EHWEquipmentItemTooltip_TalentRestriction
// NumValues: 0x0005
enum class EHWEquipmentItemTooltip_TalentRestriction : uint8
{
	None                                     = 0,
	NoTalent                                 = 1,
	Talent1                                  = 2,
	All                                      = 255,
	EHWEquipmentItemTooltip_MAX              = 256,
};

// Enum Hemingway.EHWEquipmentItemTooltip_DescriptionType
// NumValues: 0x0004
enum class EHWEquipmentItemTooltip_DescriptionType : uint8
{
	None                                     = 0,
	Short                                    = 1,
	Long                                     = 2,
	EHWEquipmentItemTooltip_MAX              = 3,
};

// Enum Hemingway.EHWAutoBuyFailureSkipType
// NumValues: 0x0004
enum class EHWAutoBuyFailureSkipType : uint32
{
	NeverSkip                                = 0,
	SkipUntilNextAutoBuy                     = 1,
	AlwaysSkip                               = 2,
	EHWAutoBuyFailureSkipType_MAX            = 3,
};

// Enum Hemingway.EHWInventorySortBehavior
// NumValues: 0x0004
enum class EHWInventorySortBehavior : uint32
{
	None                                     = 0,
	Smite2Rules                              = 1,
	FillNoEmptySlots                         = 2,
	EHWInventorySortBehavior_MAX             = 3,
};

// Enum Hemingway.EHWCraftingFailureReason
// NumValues: 0x000A
enum class EHWCraftingFailureReason : uint8
{
	Unknown                                  = 0,
	InsufficientGold                         = 1,
	MissingRequireComponents                 = 2,
	NoInventorySlotAvailable                 = 3,
	MaxAllowedEquippedReached                = 4,
	MaxAllowedInInventoryReached             = 5,
	MaxAmmoReached                           = 6,
	MaxActiveItemsReached                    = 7,
	InsufficentCharacterLevel                = 8,
	EHWCraftingFailureReason_MAX             = 9,
};

// Enum Hemingway.EHWInventoryTransactionType
// NumValues: 0x0004
enum class EHWInventoryTransactionType : uint8
{
	Sell                                     = 0,
	Purchase                                 = 1,
	Upgrade                                  = 2,
	EHWInventoryTransactionType_MAX          = 3,
};

// Enum Hemingway.EHWInventoryModifierType
// NumValues: 0x0004
enum class EHWInventoryModifierType : uint8
{
	None                                     = 0,
	BuyAmmo                                  = 1,
	SellAmmo                                 = 2,
	EHWInventoryModifierType_MAX             = 3,
};

// Enum Hemingway.EHWFriendlyEnemyReferenceActorChoice
// NumValues: 0x0003
enum class EHWFriendlyEnemyReferenceActorChoice : uint8
{
	Owner                                    = 0,
	Instigator                               = 1,
	EHWFriendlyEnemyReferenceActorChoice_MAX = 2,
};

// Enum Hemingway.EFamiliarLevelType
// NumValues: 0x0004
enum class EFamiliarLevelType : uint8
{
	CustomLevel                              = 0,
	InheritOwnerLevel                        = 1,
	InheritAbilityLevel                      = 2,
	EFamiliarLevelType_MAX                   = 3,
};

// Enum Hemingway.EDashType
// NumValues: 0x0003
enum class EDashType : uint8
{
	Dash_FixedDirection                      = 0,
	Dash_Steerable                           = 1,
	Dash_MAX                                 = 2,
};

// Enum Hemingway.EDashCollisionType
// NumValues: 0x0004
enum class EDashCollisionType : uint8
{
	MaintainCharacterCollision               = 0,
	OverlapPawnsBlockOnWorld                 = 1,
	Custom                                   = 2,
	EDashCollisionType_MAX                   = 3,
};

// Enum Hemingway.EHWEndDashBehavior
// NumValues: 0x0003
enum class EHWEndDashBehavior : uint8
{
	AttemptEnterWalking                      = 0,
	EnterFalling                             = 1,
	EHWEndDashBehavior_MAX                   = 2,
};

// Enum Hemingway.EHWDashSpeedCalculationBehavior
// NumValues: 0x0006
enum class EHWDashSpeedCalculationBehavior : uint8
{
	Speed                                    = 0,
	Acceleration                             = 1,
	Distance                                 = 2,
	Duration_VariableRange                   = 3,
	ForcedWalk                               = 4,
	EHWDashSpeedCalculationBehavior_MAX      = 5,
};

// Enum Hemingway.EHWDashAccelerationBehavior
// NumValues: 0x0003
enum class EHWDashAccelerationBehavior : uint8
{
	Explicit                                 = 0,
	Calculated                               = 1,
	EHWDashAccelerationBehavior_MAX          = 2,
};

// Enum Hemingway.EHWDashAccelerationStartingSpeedBehavior
// NumValues: 0x0004
enum class EHWDashAccelerationStartingSpeedBehavior : uint8
{
	Explicit                                 = 0,
	CurrentSpeed                             = 1,
	NonDiminishingCurrentSpeed               = 2,
	EHWDashAccelerationStartingSpeedBehavior_MAX = 3,
};

// Enum Hemingway.FlightCollisionProfileChoice
// NumValues: 0x0004
enum class EFlightCollisionProfileChoice : uint8
{
	Custom                                   = 0,
	NoCollision                              = 1,
	WorldCollision                           = 2,
	FlightCollisionProfileChoice_MAX         = 3,
};

// Enum Hemingway.EHWEndFlightBehavior
// NumValues: 0x0002
enum class EHWEndFlightBehavior : uint8
{
	InPlace                                  = 0,
	EHWEndFlightBehavior_MAX                 = 1,
};

// Enum Hemingway.EFlightAscentType
// NumValues: 0x0004
enum class EFlightAscentType : uint8
{
	Physics                                  = 0,
	Curve                                    = 1,
	Tween                                    = 2,
	EFlightAscentType_MAX                    = 3,
};

// Enum Hemingway.EFlightHorizontalSpeedType
// NumValues: 0x0003
enum class EFlightHorizontalSpeedType : uint8
{
	MaxSpeedModifier                         = 0,
	Absolute                                 = 1,
	EFlightHorizontalSpeedType_MAX           = 2,
};

// Enum Hemingway.EGrabControlType
// NumValues: 0x0003
enum class EGrabControlType : uint8
{
	TargetsFollowSource                      = 0,
	SourceFollowsTarget                      = 1,
	EGrabControlType_MAX                     = 2,
};

// Enum Hemingway.EGrabInterruptType
// NumValues: 0x0003
enum class EGrabInterruptType : uint8
{
	Breakable                                = 0,
	Unbreakable                              = 1,
	EGrabInterruptType_MAX                   = 2,
};

// Enum Hemingway.EGrabPositionType
// NumValues: 0x0004
enum class EGrabPositionType : uint32
{
	Front                                    = 0,
	Behind                                   = 1,
	CustomAngle                              = 2,
	EGrabPositionType_MAX                    = 3,
};

// Enum Hemingway.EGrabRotationType
// NumValues: 0x0005
enum class EGrabRotationType : uint32
{
	PlayerControlRotation                    = 0,
	FixedToSocketRotation                    = 1,
	MaintainStarting                         = 2,
	FixedToFollowActor                       = 3,
	EGrabRotationType_MAX                    = 4,
};

// Enum Hemingway.GrabCollisionProfileChoice
// NumValues: 0x0005
enum class EGrabCollisionProfileChoice : uint8
{
	MaintainCharacterCollision               = 0,
	Custom                                   = 1,
	NoCollision                              = 2,
	WorldCollision                           = 3,
	GrabCollisionProfileChoice_MAX           = 4,
};

// Enum Hemingway.EHWEndGrabBehavior
// NumValues: 0x0003
enum class EHWEndGrabBehavior : uint8
{
	InPlace                                  = 0,
	InFront                                  = 1,
	EHWEndGrabBehavior_MAX                   = 2,
};

// Enum Hemingway.EHWProjectileLobType
// NumValues: 0x0005
enum class EHWProjectileLobType : uint32
{
	None                                     = 0,
	FixedHorizontalVelocity                  = 1,
	FixedTime                                = 2,
	FixedAngle                               = 3,
	EHWProjectileLobType_MAX                 = 4,
};

// Enum Hemingway.ETweenType
// NumValues: 0x0006
enum class ETweenType : uint8
{
	Custom                                   = 0,
	Tween_ToLocation                         = 1,
	Tween_ToLocation_FixedTargetDist         = 2,
	Tween_ToTargetActor                      = 3,
	Tween_AlongPath                          = 4,
	ETweenType_MAX                           = 5,
};

// Enum Hemingway.TweenCollisionProfileChoice
// NumValues: 0x0006
enum class ETweenCollisionProfileChoice : uint8
{
	MaintainCharacterCollision               = 0,
	Custom                                   = 1,
	NoCollision                              = 2,
	WorldCollision                           = 3,
	TargetableButPassthrough                 = 4,
	TweenCollisionProfileChoice_MAX          = 5,
};

// Enum Hemingway.EHWEndTweenBehavior
// NumValues: 0x0003
enum class EHWEndTweenBehavior : uint8
{
	InPlace                                  = 0,
	SnapToEnd                                = 1,
	EHWEndTweenBehavior_MAX                  = 2,
};

// Enum Hemingway.EHWTweenStartLocationBehavior
// NumValues: 0x0003
enum class EHWTweenStartLocationBehavior : uint8
{
	ActorLocation                            = 0,
	AimDataOrigin                            = 1,
	EHWTweenStartLocationBehavior_MAX        = 2,
};

// Enum Hemingway.EHWProjectileTargetCollisionType
// NumValues: 0x0004
enum class EHWProjectileTargetCollisionType : uint32
{
	Sphere                                   = 0,
	Box                                      = 1,
	Capsule                                  = 2,
	EHWProjectileTargetCollisionType_MAX     = 3,
};

// Enum Hemingway.EHWProjectileSpawnDeployableTrigger
// NumValues: 0x0004
enum class EHWProjectileSpawnDeployableTrigger : uint8
{
	Custom                                   = 0,
	OnHit                                    = 1,
	OnDestroy                                = 2,
	EHWProjectileSpawnDeployableTrigger_MAX  = 3,
};

// Enum Hemingway.EHWRealtimeMultiplayStatus
// NumValues: 0x0005
enum class EHWRealtimeMultiplayStatus : uint8
{
	None                                     = 0,
	WaitingForPlayers                        = 1,
	PlayingMatch                             = 2,
	Complete                                 = 3,
	EHWRealtimeMultiplayStatus_MAX           = 4,
};

// Enum Hemingway.EHWVoteState
// NumValues: 0x0004
enum class EHWVoteState : uint8
{
	Undecided                                = 0,
	Yes                                      = 1,
	No                                       = 2,
	EHWVoteState_MAX                         = 3,
};

// Enum Hemingway.EHWSkinTier
// NumValues: 0x0007
enum class EHWSkinTier : uint8
{
	T0                                       = 0,
	T1                                       = 1,
	T2                                       = 2,
	T3                                       = 3,
	T4                                       = 4,
	T5                                       = 5,
	EHWSkinTier_MAX                          = 6,
};

// Enum Hemingway.EHWBariBellState
// NumValues: 0x0006
enum class EHWBariBellState : uint8
{
	Idle                                     = 0,
	Lobbing                                  = 1,
	Exploded                                 = 2,
	Rolling                                  = 3,
	Recalling                                = 4,
	EHWBariBellState_MAX                     = 5,
};

// Enum Hemingway.EHWBellonaInhandWeaponType
// NumValues: 0x0005
enum class EHWBellonaInhandWeaponType : uint8
{
	Standard                                 = 0,
	Shield                                   = 1,
	Hammer                                   = 2,
	ChainWhip                                = 3,
	EHWBellonaInhandWeaponType_MAX           = 4,
};

// Enum Hemingway.ETriggerSourceType
// NumValues: 0x0004
enum class ETriggerSourceType : uint8
{
	Inhand                                   = 0,
	Offhand                                  = 1,
	Inactive                                 = 2,
	ETriggerSourceType_MAX                   = 3,
};

// Enum Hemingway.EHWMulanEvolutionState
// NumValues: 0x0005
enum class EHWMulanEvolutionState : uint8
{
	Base                                     = 0,
	Evolution1                               = 1,
	Evolution2                               = 2,
	Evolution3                               = 3,
	EHWMulanEvolutionState_MAX               = 4,
};

// Enum Hemingway.EHWNvidiaReflexMode
// NumValues: 0x0004
enum class EHWNvidiaReflexMode : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	EnabledPlusBoost                         = 3,
	EHWNvidiaReflexMode_MAX                  = 4,
};

// Enum Hemingway.EHWConsoleType
// NumValues: 0x0005
enum class EHWConsoleType : uint8
{
	NotConsole                               = 0,
	PlayStation5                             = 1,
	XboxSeriesS                              = 2,
	XboxSeriesX                              = 3,
	EHWConsoleType_MAX                       = 4,
};

// Enum Hemingway.EHWInputActionAffectedBySetting
// NumValues: 0x000B
enum class EHWInputActionAffectedBySetting : uint8
{
	None                                     = 0,
	InvertXAxis                              = 1,
	InvertYAxis                              = 2,
	CameraXSensitivity                       = 4,
	CameraYSensitivity                       = 8,
	MoveDeadzoneSettings                     = 16,
	LookDeadzoneSettings                     = 32,
	InvertAxis                               = 3,
	CameraSensitivity                        = 12,
	DeadzoneSettings                         = 48,
	EHWInputActionAffectedBySetting_MAX      = 49,
};

// Enum Hemingway.EHWInputActionAllowedRebind
// NumValues: 0x0005
enum class EHWInputActionAllowedRebind : uint8
{
	None                                     = 0,
	KBM                                      = 1,
	Gamepad                                  = 2,
	All                                      = 3,
	EHWInputActionAllowedRebind_MAX          = 4,
};

// Enum Hemingway.EHWSOCDPolicy
// NumValues: 0x0003
enum class EHWSOCDPolicy : uint8
{
	Neutral                                  = 0,
	LastInputPriority                        = 1,
	EHWSOCDPolicy_MAX                        = 2,
};

// Enum Hemingway.EHWInputTriggerKeyConsumePolicy
// NumValues: 0x0004
enum class EHWInputTriggerKeyConsumePolicy : uint8
{
	Never                                    = 0,
	Always                                   = 1,
	SlotCastStyle                            = 2,
	EHWInputTriggerKeyConsumePolicy_MAX      = 3,
};

// Enum Hemingway.EHWKeyRebindOverlapBehavior
// NumValues: 0x0004
enum class EHWKeyRebindOverlapBehavior : uint8
{
	RejectRebind                             = 0,
	ClearExisting                            = 1,
	SwapBinds                                = 2,
	EHWKeyRebindOverlapBehavior_MAX          = 3,
};

// Enum Hemingway.EHWCollectionItemStatus
// NumValues: 0x0006
enum class EHWCollectionItemStatus : uint8
{
	None                                     = 0,
	Owned                                    = 1,
	Unobtainable                             = 2,
	Locked                                   = 3,
	Purchaseable                             = 4,
	EHWCollectionItemStatus_MAX              = 5,
};

// Enum Hemingway.EHWItemDisabledReason
// NumValues: 0x0005
enum class EHWItemDisabledReason : uint8
{
	Unknown                                  = 0,
	NotDisabled                              = 1,
	InactiveLoot                             = 2,
	TemporarilyDisabledKV                    = 3,
	EHWItemDisabledReason_MAX                = 4,
};

// Enum Hemingway.EVoicePackType
// NumValues: 0x0004
enum class EVoicePackType : uint8
{
	All                                      = 0,
	God                                      = 1,
	Skin                                     = 2,
	EVoicePackType_MAX                       = 3,
};

// Enum Hemingway.EHWAllowedInputCategory
// NumValues: 0x0007
enum class EHWAllowedInputCategory : uint8
{
	None                                     = 0,
	Movement                                 = 1,
	Look                                     = 2,
	Ability                                  = 4,
	UI                                       = 8,
	All                                      = 255,
	EHWAllowedInputCategory_MAX              = 256,
};

// Enum Hemingway.EHWTradeRequestType
// NumValues: 0x0004
enum class EHWTradeRequestType : uint8
{
	None                                     = 0,
	Role                                     = 1,
	Character                                = 2,
	EHWTradeRequestType_MAX                  = 3,
};

// Enum Hemingway.EHWClientLoadState
// NumValues: 0x0005
enum class EHWClientLoadState : uint8
{
	NotInitialized                           = 0,
	Loading                                  = 1,
	Loaded                                   = 2,
	NotHuman                                 = 3,
	EHWClientLoadState_MAX                   = 4,
};

// Enum Hemingway.EHWQuestTrackerAwardType
// NumValues: 0x0004
enum class EHWQuestTrackerAwardType : uint8
{
	Quantity                                 = 0,
	DistanceInMeters                         = 1,
	DurationInSeconds                        = 2,
	EHWQuestTrackerAwardType_MAX             = 3,
};

// Enum Hemingway.EHWPriceDisplayType
// NumValues: 0x0003
enum class EHWPriceDisplayType : uint8
{
	Price                                    = 0,
	FreeText                                 = 1,
	EHWPriceDisplayType_MAX                  = 2,
};

// Enum Hemingway.EHWCurrencyType
// NumValues: 0x0006
enum class EHWCurrencyType : uint8
{
	None                                     = 0,
	Premium                                  = 1,
	Legacy                                   = 2,
	Free                                     = 3,
	Other                                    = 4,
	EHWCurrencyType_MAX                      = 5,
};

// Enum Hemingway.EHWFoundersOwnershipLevel
// NumValues: 0x0005
enum class EHWFoundersOwnershipLevel : uint8
{
	None                                     = 0,
	Base                                     = 1,
	Deluxe                                   = 2,
	Ultimate                                 = 3,
	EHWFoundersOwnershipLevel_MAX            = 4,
};

// Enum Hemingway.EHWCallToActionAffixPath
// NumValues: 0x0009
enum class EHWCallToActionAffixPath : uint8
{
	None                                     = 0,
	Gods                                     = 1,
	Ascension                                = 2,
	AscensionClaim                           = 3,
	Collection                               = 4,
	Player                                   = 5,
	Event                                    = 6,
	SeasonShop                               = 7,
	EHWCallToActionAffixPath_MAX             = 8,
};

// Enum Hemingway.EHWItemStoreMajorCategory
// NumValues: 0x0008
enum class EHWItemStoreMajorCategory : uint8
{
	None                                     = 0,
	Recommended                              = 1,
	Offensive                                = 2,
	Defensive                                = 3,
	Utility                                  = 4,
	Active                                   = 5,
	Main                                     = 6,
	EHWItemStoreMajorCategory_MAX            = 7,
};

// Enum Hemingway.EHWCachedBuildType
// NumValues: 0x0005
enum class EHWCachedBuildType : uint8
{
	None                                     = 0,
	Pinned                                   = 1,
	Promoted                                 = 2,
	AutoBuild                                = 3,
	EHWCachedBuildType_MAX                   = 4,
};

// Enum Hemingway.EHWPlayerBotRHIdUsage
// NumValues: 0x0005
enum class EHWPlayerBotRHIdUsage : uint8
{
	None                                     = 0,
	CustomLobby                              = 1,
	MatchmadeQueue                           = 2,
	All                                      = 255,
	EHWPlayerBotRHIdUsage_MAX                = 256,
};

// Enum Hemingway.ECombatLogType
// NumValues: 0x0008
enum class ECombatLogType : uint8
{
	PIPED                                    = 0,
	RAWTEXT                                  = 1,
	XML                                      = 2,
	Json                                     = 3,
	AWS                                      = 4,
	TIMELINEJSON                             = 5,
	Default                                  = 3,
	ECombatLogType_MAX                       = 6,
};

// Enum Hemingway.ESimProjectileFlashEventType
// NumValues: 0x0005
enum class ESimProjectileFlashEventType : uint8
{
	None                                     = 0,
	Expired                                  = 1,
	ExplodeOnTarget                          = 2,
	ExplodeOnWorld                           = 3,
	ESimProjectileFlashEventType_MAX         = 4,
};

// ScriptStruct Hemingway.HWObstacleAvoidanceParams
// 0x0028 (0x0028 - 0x0000)
struct FHWObstacleAvoidanceParams final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWVectorFieldFollowerComponent*        VectorFieldComp;                                   // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWVectorFieldFollowCalc*               Calculation;                                       // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAheadDistance;                                 // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWObstacleAvoidanceParams) == 0x000008, "Wrong alignment on FHWObstacleAvoidanceParams");
static_assert(sizeof(FHWObstacleAvoidanceParams) == 0x000028, "Wrong size on FHWObstacleAvoidanceParams");
static_assert(offsetof(FHWObstacleAvoidanceParams, Source) == 0x000000, "Member 'FHWObstacleAvoidanceParams::Source' has a wrong offset!");
static_assert(offsetof(FHWObstacleAvoidanceParams, Target) == 0x000008, "Member 'FHWObstacleAvoidanceParams::Target' has a wrong offset!");
static_assert(offsetof(FHWObstacleAvoidanceParams, VectorFieldComp) == 0x000010, "Member 'FHWObstacleAvoidanceParams::VectorFieldComp' has a wrong offset!");
static_assert(offsetof(FHWObstacleAvoidanceParams, Calculation) == 0x000018, "Member 'FHWObstacleAvoidanceParams::Calculation' has a wrong offset!");
static_assert(offsetof(FHWObstacleAvoidanceParams, LookAheadDistance) == 0x000020, "Member 'FHWObstacleAvoidanceParams::LookAheadDistance' has a wrong offset!");
static_assert(offsetof(FHWObstacleAvoidanceParams, Weight) == 0x000024, "Member 'FHWObstacleAvoidanceParams::Weight' has a wrong offset!");

// ScriptStruct Hemingway.HWAzureCategoryResult
// 0x0018 (0x0018 - 0x0000)
struct FHWAzureCategoryResult final
{
public:
	class FString                                 Category;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Result;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfiguredThreshold;                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAzureCategoryResult) == 0x000008, "Wrong alignment on FHWAzureCategoryResult");
static_assert(sizeof(FHWAzureCategoryResult) == 0x000018, "Wrong size on FHWAzureCategoryResult");
static_assert(offsetof(FHWAzureCategoryResult, Category) == 0x000000, "Member 'FHWAzureCategoryResult::Category' has a wrong offset!");
static_assert(offsetof(FHWAzureCategoryResult, Result) == 0x000010, "Member 'FHWAzureCategoryResult::Result' has a wrong offset!");
static_assert(offsetof(FHWAzureCategoryResult, ConfiguredThreshold) == 0x000014, "Member 'FHWAzureCategoryResult::ConfiguredThreshold' has a wrong offset!");

// ScriptStruct Hemingway.HWChatLogAzureResult
// 0x0040 (0x0040 - 0x0000)
struct FHWChatLogAzureResult final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ConcatenatedMessage;                               // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResultType;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWAzureCategoryResult>         AzureCategories;                                   // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWChatLogAzureResult) == 0x000008, "Wrong alignment on FHWChatLogAzureResult");
static_assert(sizeof(FHWChatLogAzureResult) == 0x000040, "Wrong size on FHWChatLogAzureResult");
static_assert(offsetof(FHWChatLogAzureResult, Message) == 0x000000, "Member 'FHWChatLogAzureResult::Message' has a wrong offset!");
static_assert(offsetof(FHWChatLogAzureResult, ConcatenatedMessage) == 0x000010, "Member 'FHWChatLogAzureResult::ConcatenatedMessage' has a wrong offset!");
static_assert(offsetof(FHWChatLogAzureResult, ResultType) == 0x000020, "Member 'FHWChatLogAzureResult::ResultType' has a wrong offset!");
static_assert(offsetof(FHWChatLogAzureResult, AzureCategories) == 0x000030, "Member 'FHWChatLogAzureResult::AzureCategories' has a wrong offset!");

// ScriptStruct Hemingway.HWCombatEvent_Base
// 0x0004 (0x0004 - 0x0000)
struct FHWCombatEvent_Base
{
public:
	int32                                         InstanceId;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCombatEvent_Base) == 0x000004, "Wrong alignment on FHWCombatEvent_Base");
static_assert(sizeof(FHWCombatEvent_Base) == 0x000004, "Wrong size on FHWCombatEvent_Base");
static_assert(offsetof(FHWCombatEvent_Base, InstanceId) == 0x000000, "Member 'FHWCombatEvent_Base::InstanceId' has a wrong offset!");

// ScriptStruct Hemingway.HWAILearningMainCharacterObservationData
// 0x0058 (0x0058 - 0x0000)
struct FHWAILearningMainCharacterObservationData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InhandRange;                                       // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAILearningMainCharacterObservationData) == 0x000008, "Wrong alignment on FHWAILearningMainCharacterObservationData");
static_assert(sizeof(FHWAILearningMainCharacterObservationData) == 0x000058, "Wrong size on FHWAILearningMainCharacterObservationData");
static_assert(offsetof(FHWAILearningMainCharacterObservationData, Location) == 0x000000, "Member 'FHWAILearningMainCharacterObservationData::Location' has a wrong offset!");
static_assert(offsetof(FHWAILearningMainCharacterObservationData, Rotation) == 0x000018, "Member 'FHWAILearningMainCharacterObservationData::Rotation' has a wrong offset!");
static_assert(offsetof(FHWAILearningMainCharacterObservationData, Velocity) == 0x000030, "Member 'FHWAILearningMainCharacterObservationData::Velocity' has a wrong offset!");
static_assert(offsetof(FHWAILearningMainCharacterObservationData, Health) == 0x000048, "Member 'FHWAILearningMainCharacterObservationData::Health' has a wrong offset!");
static_assert(offsetof(FHWAILearningMainCharacterObservationData, Level) == 0x00004C, "Member 'FHWAILearningMainCharacterObservationData::Level' has a wrong offset!");
static_assert(offsetof(FHWAILearningMainCharacterObservationData, InhandRange) == 0x000050, "Member 'FHWAILearningMainCharacterObservationData::InhandRange' has a wrong offset!");

// ScriptStruct Hemingway.HWAILearningCharacterObservationData
// 0x0060 (0x0060 - 0x0000)
struct FHWAILearningCharacterObservationData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InhandRange;                                       // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Type;                                              // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFriendly;                                       // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAILearningCharacterObservationData) == 0x000008, "Wrong alignment on FHWAILearningCharacterObservationData");
static_assert(sizeof(FHWAILearningCharacterObservationData) == 0x000060, "Wrong size on FHWAILearningCharacterObservationData");
static_assert(offsetof(FHWAILearningCharacterObservationData, Location) == 0x000000, "Member 'FHWAILearningCharacterObservationData::Location' has a wrong offset!");
static_assert(offsetof(FHWAILearningCharacterObservationData, Rotation) == 0x000018, "Member 'FHWAILearningCharacterObservationData::Rotation' has a wrong offset!");
static_assert(offsetof(FHWAILearningCharacterObservationData, Velocity) == 0x000030, "Member 'FHWAILearningCharacterObservationData::Velocity' has a wrong offset!");
static_assert(offsetof(FHWAILearningCharacterObservationData, Health) == 0x000048, "Member 'FHWAILearningCharacterObservationData::Health' has a wrong offset!");
static_assert(offsetof(FHWAILearningCharacterObservationData, Level) == 0x00004C, "Member 'FHWAILearningCharacterObservationData::Level' has a wrong offset!");
static_assert(offsetof(FHWAILearningCharacterObservationData, InhandRange) == 0x000050, "Member 'FHWAILearningCharacterObservationData::InhandRange' has a wrong offset!");
static_assert(offsetof(FHWAILearningCharacterObservationData, Type) == 0x000054, "Member 'FHWAILearningCharacterObservationData::Type' has a wrong offset!");
static_assert(offsetof(FHWAILearningCharacterObservationData, bIsFriendly) == 0x000058, "Member 'FHWAILearningCharacterObservationData::bIsFriendly' has a wrong offset!");

// ScriptStruct Hemingway.HWAILearningThreatObservationData
// 0x0050 (0x0050 - 0x0000)
struct FHWAILearningThreatObservationData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAILearningThreatObservationData) == 0x000008, "Wrong alignment on FHWAILearningThreatObservationData");
static_assert(sizeof(FHWAILearningThreatObservationData) == 0x000050, "Wrong size on FHWAILearningThreatObservationData");
static_assert(offsetof(FHWAILearningThreatObservationData, Location) == 0x000000, "Member 'FHWAILearningThreatObservationData::Location' has a wrong offset!");
static_assert(offsetof(FHWAILearningThreatObservationData, Rotation) == 0x000018, "Member 'FHWAILearningThreatObservationData::Rotation' has a wrong offset!");
static_assert(offsetof(FHWAILearningThreatObservationData, Velocity) == 0x000030, "Member 'FHWAILearningThreatObservationData::Velocity' has a wrong offset!");
static_assert(offsetof(FHWAILearningThreatObservationData, Radius) == 0x000048, "Member 'FHWAILearningThreatObservationData::Radius' has a wrong offset!");

// ScriptStruct Hemingway.HWAILearningActionData
// 0x0020 (0x0020 - 0x0000)
struct FHWAILearningActionData final
{
public:
	struct FVector                                DesiredControlVector;                              // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredRotation;                                   // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAILearningActionData) == 0x000008, "Wrong alignment on FHWAILearningActionData");
static_assert(sizeof(FHWAILearningActionData) == 0x000020, "Wrong size on FHWAILearningActionData");
static_assert(offsetof(FHWAILearningActionData, DesiredControlVector) == 0x000000, "Member 'FHWAILearningActionData::DesiredControlVector' has a wrong offset!");
static_assert(offsetof(FHWAILearningActionData, DesiredRotation) == 0x000018, "Member 'FHWAILearningActionData::DesiredRotation' has a wrong offset!");

// ScriptStruct Hemingway.HWAILearningAgentData
// 0x0098 (0x0098 - 0x0000)
struct FHWAILearningAgentData final
{
public:
	struct FHWAILearningMainCharacterObservationData Main;                                           // 0x0000(0x0058)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FHWAILearningCharacterObservationData> Other;                                      // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWAILearningThreatObservationData> Threats;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHWAILearningActionData                Action;                                            // 0x0078(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAILearningAgentData) == 0x000008, "Wrong alignment on FHWAILearningAgentData");
static_assert(sizeof(FHWAILearningAgentData) == 0x000098, "Wrong size on FHWAILearningAgentData");
static_assert(offsetof(FHWAILearningAgentData, Main) == 0x000000, "Member 'FHWAILearningAgentData::Main' has a wrong offset!");
static_assert(offsetof(FHWAILearningAgentData, Other) == 0x000058, "Member 'FHWAILearningAgentData::Other' has a wrong offset!");
static_assert(offsetof(FHWAILearningAgentData, Threats) == 0x000068, "Member 'FHWAILearningAgentData::Threats' has a wrong offset!");
static_assert(offsetof(FHWAILearningAgentData, Action) == 0x000078, "Member 'FHWAILearningAgentData::Action' has a wrong offset!");

// ScriptStruct Hemingway.HWAILearningSampleData
// 0x0018 (0x0018 - 0x0000)
struct FHWAILearningSampleData final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWAILearningAgentData>         Agents;                                            // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAILearningSampleData) == 0x000008, "Wrong alignment on FHWAILearningSampleData");
static_assert(sizeof(FHWAILearningSampleData) == 0x000018, "Wrong size on FHWAILearningSampleData");
static_assert(offsetof(FHWAILearningSampleData, Timestamp) == 0x000000, "Member 'FHWAILearningSampleData::Timestamp' has a wrong offset!");
static_assert(offsetof(FHWAILearningSampleData, Agents) == 0x000008, "Member 'FHWAILearningSampleData::Agents' has a wrong offset!");

// ScriptStruct Hemingway.HWPlatformBool
// 0x0003 (0x0003 - 0x0000)
struct FHWPlatformBool final
{
public:
	bool                                          bPC;                                               // 0x0000(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPS5;                                              // 0x0001(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXBox;                                             // 0x0002(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPlatformBool) == 0x000001, "Wrong alignment on FHWPlatformBool");
static_assert(sizeof(FHWPlatformBool) == 0x000003, "Wrong size on FHWPlatformBool");
static_assert(offsetof(FHWPlatformBool, bPC) == 0x000000, "Member 'FHWPlatformBool::bPC' has a wrong offset!");
static_assert(offsetof(FHWPlatformBool, bPS5) == 0x000001, "Member 'FHWPlatformBool::bPS5' has a wrong offset!");
static_assert(offsetof(FHWPlatformBool, bXBox) == 0x000002, "Member 'FHWPlatformBool::bXBox' has a wrong offset!");

// ScriptStruct Hemingway.HWPersistentPlayerId
// 0x0020 (0x0020 - 0x0000)
struct FHWPersistentPlayerId final
{
public:
	struct FGuid                                  RHPlayerId;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  PersistentBotId;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPersistentPlayerId) == 0x000004, "Wrong alignment on FHWPersistentPlayerId");
static_assert(sizeof(FHWPersistentPlayerId) == 0x000020, "Wrong size on FHWPersistentPlayerId");
static_assert(offsetof(FHWPersistentPlayerId, RHPlayerId) == 0x000000, "Member 'FHWPersistentPlayerId::RHPlayerId' has a wrong offset!");
static_assert(offsetof(FHWPersistentPlayerId, PersistentBotId) == 0x000010, "Member 'FHWPersistentPlayerId::PersistentBotId' has a wrong offset!");

// ScriptStruct Hemingway.HWGodBuildEntry
// 0x0068 (0x0068 - 0x0000)
struct FHWGodBuildEntry final
{
public:
	class FString                                 Title;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShortDesc;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LongDesc;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             StarterItemId;                                     // 0x0030(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             RelicItemId;                                       // 0x0044(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRH_ItemId>                     EntryItemIds;                                      // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWGodBuildEntry) == 0x000008, "Wrong alignment on FHWGodBuildEntry");
static_assert(sizeof(FHWGodBuildEntry) == 0x000068, "Wrong size on FHWGodBuildEntry");
static_assert(offsetof(FHWGodBuildEntry, Title) == 0x000000, "Member 'FHWGodBuildEntry::Title' has a wrong offset!");
static_assert(offsetof(FHWGodBuildEntry, ShortDesc) == 0x000010, "Member 'FHWGodBuildEntry::ShortDesc' has a wrong offset!");
static_assert(offsetof(FHWGodBuildEntry, LongDesc) == 0x000020, "Member 'FHWGodBuildEntry::LongDesc' has a wrong offset!");
static_assert(offsetof(FHWGodBuildEntry, StarterItemId) == 0x000030, "Member 'FHWGodBuildEntry::StarterItemId' has a wrong offset!");
static_assert(offsetof(FHWGodBuildEntry, RelicItemId) == 0x000044, "Member 'FHWGodBuildEntry::RelicItemId' has a wrong offset!");
static_assert(offsetof(FHWGodBuildEntry, EntryItemIds) == 0x000058, "Member 'FHWGodBuildEntry::EntryItemIds' has a wrong offset!");

// ScriptStruct Hemingway.HWGodBuild
// 0x0190 (0x0190 - 0x0000)
struct FHWGodBuild final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWPersistentPlayerId                  OwnerId;                                           // 0x0010(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameVersion;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             GodItemId;                                         // 0x0060(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x14];                                      // 0x0074(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	ECharacterRole                                Role;                                              // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Mode;                                              // 0x008C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PromotionValue;                                    // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFavorite;                                       // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AbilityOrder;                                      // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHWGodBuildEntry                       FinalBuild;                                        // 0x00B0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHWGodBuildEntry                       StartingItems;                                     // 0x0118(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHWGodBuildEntry>               BuildEntries;                                      // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWGodBuild) == 0x000008, "Wrong alignment on FHWGodBuild");
static_assert(sizeof(FHWGodBuild) == 0x000190, "Wrong size on FHWGodBuild");
static_assert(offsetof(FHWGodBuild, ID) == 0x000000, "Member 'FHWGodBuild::ID' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, OwnerId) == 0x000010, "Member 'FHWGodBuild::OwnerId' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, Title) == 0x000030, "Member 'FHWGodBuild::Title' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, Desc) == 0x000040, "Member 'FHWGodBuild::Desc' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, GameVersion) == 0x000050, "Member 'FHWGodBuild::GameVersion' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, GodItemId) == 0x000060, "Member 'FHWGodBuild::GodItemId' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, Role) == 0x000088, "Member 'FHWGodBuild::Role' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, Mode) == 0x00008C, "Member 'FHWGodBuild::Mode' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, PromotionValue) == 0x000094, "Member 'FHWGodBuild::PromotionValue' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, bIsFavorite) == 0x000098, "Member 'FHWGodBuild::bIsFavorite' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, AbilityOrder) == 0x0000A0, "Member 'FHWGodBuild::AbilityOrder' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, FinalBuild) == 0x0000B0, "Member 'FHWGodBuild::FinalBuild' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, StartingItems) == 0x000118, "Member 'FHWGodBuild::StartingItems' has a wrong offset!");
static_assert(offsetof(FHWGodBuild, BuildEntries) == 0x000180, "Member 'FHWGodBuild::BuildEntries' has a wrong offset!");

// ScriptStruct Hemingway.BoxTargetingData
// 0x0080 (0x0080 - 0x0000)
struct FBoxTargetingData final
{
public:
	float                                         Width;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       AimData;                                           // 0x0010(0x0028)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	int32                                         MaxTargetsAllowed;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTargetDataFilterHandle> PriorityFilters;                                  // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	ETargetingLocationPriorityBehavior            LocationPriorityBehavior;                          // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationPriorityRadiusThreshold;                   // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        AcceptableTargetFilter;                            // 0x0058(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoxTargetingData) == 0x000008, "Wrong alignment on FBoxTargetingData");
static_assert(sizeof(FBoxTargetingData) == 0x000080, "Wrong size on FBoxTargetingData");
static_assert(offsetof(FBoxTargetingData, Width) == 0x000000, "Member 'FBoxTargetingData::Width' has a wrong offset!");
static_assert(offsetof(FBoxTargetingData, Length) == 0x000004, "Member 'FBoxTargetingData::Length' has a wrong offset!");
static_assert(offsetof(FBoxTargetingData, Height) == 0x000008, "Member 'FBoxTargetingData::Height' has a wrong offset!");
static_assert(offsetof(FBoxTargetingData, AimData) == 0x000010, "Member 'FBoxTargetingData::AimData' has a wrong offset!");
static_assert(offsetof(FBoxTargetingData, MaxTargetsAllowed) == 0x000038, "Member 'FBoxTargetingData::MaxTargetsAllowed' has a wrong offset!");
static_assert(offsetof(FBoxTargetingData, PriorityFilters) == 0x000040, "Member 'FBoxTargetingData::PriorityFilters' has a wrong offset!");
static_assert(offsetof(FBoxTargetingData, LocationPriorityBehavior) == 0x000050, "Member 'FBoxTargetingData::LocationPriorityBehavior' has a wrong offset!");
static_assert(offsetof(FBoxTargetingData, LocationPriorityRadiusThreshold) == 0x000054, "Member 'FBoxTargetingData::LocationPriorityRadiusThreshold' has a wrong offset!");
static_assert(offsetof(FBoxTargetingData, AcceptableTargetFilter) == 0x000058, "Member 'FBoxTargetingData::AcceptableTargetFilter' has a wrong offset!");
static_assert(offsetof(FBoxTargetingData, ActorsToIgnore) == 0x000068, "Member 'FBoxTargetingData::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(FBoxTargetingData, bDrawDebug) == 0x000078, "Member 'FBoxTargetingData::bDrawDebug' has a wrong offset!");

// ScriptStruct Hemingway.HWEffectCalcInfo
// 0x0088 (0x0088 - 0x0000)
struct FHWEffectCalcInfo
{
public:
	class UHWAbilitySystemComponent*              SourceASC;                                         // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              TargetASC;                                         // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecHandle              EffectSpecHandle;                                  // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x68];                                      // 0x0020(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWEffectCalcInfo) == 0x000008, "Wrong alignment on FHWEffectCalcInfo");
static_assert(sizeof(FHWEffectCalcInfo) == 0x000088, "Wrong size on FHWEffectCalcInfo");
static_assert(offsetof(FHWEffectCalcInfo, SourceASC) == 0x000000, "Member 'FHWEffectCalcInfo::SourceASC' has a wrong offset!");
static_assert(offsetof(FHWEffectCalcInfo, TargetASC) == 0x000008, "Member 'FHWEffectCalcInfo::TargetASC' has a wrong offset!");
static_assert(offsetof(FHWEffectCalcInfo, EffectSpecHandle) == 0x000010, "Member 'FHWEffectCalcInfo::EffectSpecHandle' has a wrong offset!");

// ScriptStruct Hemingway.HealCalcInfo
// 0x0008 (0x0090 - 0x0088)
struct FHealCalcInfo final : public FHWEffectCalcInfo
{
public:
	struct FGameplayTag                           HealType;                                          // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHealCalcInfo) == 0x000008, "Wrong alignment on FHealCalcInfo");
static_assert(sizeof(FHealCalcInfo) == 0x000090, "Wrong size on FHealCalcInfo");
static_assert(offsetof(FHealCalcInfo, HealType) == 0x000088, "Member 'FHealCalcInfo::HealType' has a wrong offset!");

// ScriptStruct Hemingway.HWSystemMessageConfig
// 0x0050 (0x0050 - 0x0000)
struct FHWSystemMessageConfig final
{
public:
	class FText                                   MessageText;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWChatManagerMessageFormatter> MessageFormatter;                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              MessageSound;                                      // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayForSourcePlayer;                              // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWSystemMessageConfig) == 0x000008, "Wrong alignment on FHWSystemMessageConfig");
static_assert(sizeof(FHWSystemMessageConfig) == 0x000050, "Wrong size on FHWSystemMessageConfig");
static_assert(offsetof(FHWSystemMessageConfig, MessageText) == 0x000000, "Member 'FHWSystemMessageConfig::MessageText' has a wrong offset!");
static_assert(offsetof(FHWSystemMessageConfig, MessageFormatter) == 0x000018, "Member 'FHWSystemMessageConfig::MessageFormatter' has a wrong offset!");
static_assert(offsetof(FHWSystemMessageConfig, MessageSound) == 0x000020, "Member 'FHWSystemMessageConfig::MessageSound' has a wrong offset!");
static_assert(offsetof(FHWSystemMessageConfig, bPlayForSourcePlayer) == 0x000048, "Member 'FHWSystemMessageConfig::bPlayForSourcePlayer' has a wrong offset!");

// ScriptStruct Hemingway.HWInstanceInfo_PlayerData
// 0x0110 (0x0110 - 0x0000)
struct FHWInstanceInfo_PlayerData final
{
public:
	struct FRH_ItemId                             CharacterDraftChoice;                              // 0x0000(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             SkinDraftChoice;                                   // 0x0014(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             PlayerNameColor;                                   // 0x0028(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             PlayerTitle;                                       // 0x003C(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FRH_ItemId, int32>                CharacterTrackerData;                              // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FRH_ItemId, int32>                CharacterBadgeData;                                // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
	struct FRH_ItemId                             CharacterCardVFX;                                  // 0x00F0(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterMasteryLevel;                             // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterS1MasteryLevel;                           // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x010C(0x0001)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWInstanceInfo_PlayerData) == 0x000008, "Wrong alignment on FHWInstanceInfo_PlayerData");
static_assert(sizeof(FHWInstanceInfo_PlayerData) == 0x000110, "Wrong size on FHWInstanceInfo_PlayerData");
static_assert(offsetof(FHWInstanceInfo_PlayerData, CharacterDraftChoice) == 0x000000, "Member 'FHWInstanceInfo_PlayerData::CharacterDraftChoice' has a wrong offset!");
static_assert(offsetof(FHWInstanceInfo_PlayerData, SkinDraftChoice) == 0x000014, "Member 'FHWInstanceInfo_PlayerData::SkinDraftChoice' has a wrong offset!");
static_assert(offsetof(FHWInstanceInfo_PlayerData, PlayerNameColor) == 0x000028, "Member 'FHWInstanceInfo_PlayerData::PlayerNameColor' has a wrong offset!");
static_assert(offsetof(FHWInstanceInfo_PlayerData, PlayerTitle) == 0x00003C, "Member 'FHWInstanceInfo_PlayerData::PlayerTitle' has a wrong offset!");
static_assert(offsetof(FHWInstanceInfo_PlayerData, CharacterTrackerData) == 0x000050, "Member 'FHWInstanceInfo_PlayerData::CharacterTrackerData' has a wrong offset!");
static_assert(offsetof(FHWInstanceInfo_PlayerData, CharacterBadgeData) == 0x0000A0, "Member 'FHWInstanceInfo_PlayerData::CharacterBadgeData' has a wrong offset!");
static_assert(offsetof(FHWInstanceInfo_PlayerData, CharacterCardVFX) == 0x0000F0, "Member 'FHWInstanceInfo_PlayerData::CharacterCardVFX' has a wrong offset!");
static_assert(offsetof(FHWInstanceInfo_PlayerData, CharacterMasteryLevel) == 0x000104, "Member 'FHWInstanceInfo_PlayerData::CharacterMasteryLevel' has a wrong offset!");
static_assert(offsetof(FHWInstanceInfo_PlayerData, CharacterS1MasteryLevel) == 0x000108, "Member 'FHWInstanceInfo_PlayerData::CharacterS1MasteryLevel' has a wrong offset!");
static_assert(offsetof(FHWInstanceInfo_PlayerData, TeamId) == 0x00010C, "Member 'FHWInstanceInfo_PlayerData::TeamId' has a wrong offset!");

// ScriptStruct Hemingway.HWAscensionInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FHWAscensionInfo final
{
public:
	struct FRH_ItemId                             AscensionItemId;                                   // 0x0000(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             AscensionPurchaseLootId;                           // 0x0014(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             RepeatableCouponItemId;                            // 0x0028(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             RepeatableRewardLootId;                            // 0x003C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LegacyIdToGuid                     AscensionMasteryRewardVendorId;                    // 0x0050(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FRH_LootId>                AscensionPassTrack;                                // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAscensionInfo) == 0x000008, "Wrong alignment on FHWAscensionInfo");
static_assert(sizeof(FHWAscensionInfo) == 0x0000B8, "Wrong size on FHWAscensionInfo");
static_assert(offsetof(FHWAscensionInfo, AscensionItemId) == 0x000000, "Member 'FHWAscensionInfo::AscensionItemId' has a wrong offset!");
static_assert(offsetof(FHWAscensionInfo, AscensionPurchaseLootId) == 0x000014, "Member 'FHWAscensionInfo::AscensionPurchaseLootId' has a wrong offset!");
static_assert(offsetof(FHWAscensionInfo, RepeatableCouponItemId) == 0x000028, "Member 'FHWAscensionInfo::RepeatableCouponItemId' has a wrong offset!");
static_assert(offsetof(FHWAscensionInfo, RepeatableRewardLootId) == 0x00003C, "Member 'FHWAscensionInfo::RepeatableRewardLootId' has a wrong offset!");
static_assert(offsetof(FHWAscensionInfo, AscensionMasteryRewardVendorId) == 0x000050, "Member 'FHWAscensionInfo::AscensionMasteryRewardVendorId' has a wrong offset!");
static_assert(offsetof(FHWAscensionInfo, AscensionPassTrack) == 0x000068, "Member 'FHWAscensionInfo::AscensionPassTrack' has a wrong offset!");

// ScriptStruct Hemingway.DamageEventData
// 0x006C (0x0070 - 0x0004)
struct FDamageEventData final : public FHWCombatEvent_Base
{
public:
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  OriginalInstigator;                                // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AttackTags;                                        // 0x0020(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         TargetHealth;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreMitigatedDamage;                                // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MitigatedDamage;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDone;                                        // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldDamageDone;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageDidKill;                                    // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCrit;                                          // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipTimeAfterDeath;                               // 0x0056(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAwardKillCredit;                                  // 0x0057(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBestowedToNewOriginalInstigator;                  // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectSpecHandle              EffectSpecHandle;                                  // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageEventData) == 0x000008, "Wrong alignment on FDamageEventData");
static_assert(sizeof(FDamageEventData) == 0x000070, "Wrong size on FDamageEventData");
static_assert(offsetof(FDamageEventData, Instigator) == 0x000004, "Member 'FDamageEventData::Instigator' has a wrong offset!");
static_assert(offsetof(FDamageEventData, OriginalInstigator) == 0x00000C, "Member 'FDamageEventData::OriginalInstigator' has a wrong offset!");
static_assert(offsetof(FDamageEventData, Target) == 0x000014, "Member 'FDamageEventData::Target' has a wrong offset!");
static_assert(offsetof(FDamageEventData, AttackTags) == 0x000020, "Member 'FDamageEventData::AttackTags' has a wrong offset!");
static_assert(offsetof(FDamageEventData, TargetHealth) == 0x000040, "Member 'FDamageEventData::TargetHealth' has a wrong offset!");
static_assert(offsetof(FDamageEventData, PreMitigatedDamage) == 0x000044, "Member 'FDamageEventData::PreMitigatedDamage' has a wrong offset!");
static_assert(offsetof(FDamageEventData, MitigatedDamage) == 0x000048, "Member 'FDamageEventData::MitigatedDamage' has a wrong offset!");
static_assert(offsetof(FDamageEventData, DamageDone) == 0x00004C, "Member 'FDamageEventData::DamageDone' has a wrong offset!");
static_assert(offsetof(FDamageEventData, ShieldDamageDone) == 0x000050, "Member 'FDamageEventData::ShieldDamageDone' has a wrong offset!");
static_assert(offsetof(FDamageEventData, bDamageDidKill) == 0x000054, "Member 'FDamageEventData::bDamageDidKill' has a wrong offset!");
static_assert(offsetof(FDamageEventData, bWasCrit) == 0x000055, "Member 'FDamageEventData::bWasCrit' has a wrong offset!");
static_assert(offsetof(FDamageEventData, bSkipTimeAfterDeath) == 0x000056, "Member 'FDamageEventData::bSkipTimeAfterDeath' has a wrong offset!");
static_assert(offsetof(FDamageEventData, bAwardKillCredit) == 0x000057, "Member 'FDamageEventData::bAwardKillCredit' has a wrong offset!");
static_assert(offsetof(FDamageEventData, bBestowedToNewOriginalInstigator) == 0x000058, "Member 'FDamageEventData::bBestowedToNewOriginalInstigator' has a wrong offset!");
static_assert(offsetof(FDamageEventData, EffectSpecHandle) == 0x000060, "Member 'FDamageEventData::EffectSpecHandle' has a wrong offset!");

// ScriptStruct Hemingway.HWManageCharacterLaneParams
// 0x0038 (0x0038 - 0x0000)
struct FHWManageCharacterLaneParams final
{
public:
	class AHWCharacter_Base*                      Character;                                         // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWAIController*                        Controller;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Lanes;                                             // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   JungleLaneId;                                      // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ImmunityTag;                                       // 0x0028(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinJungleLevelForSiege;                            // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinJungleDefeatedLanesForSiege;                    // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWManageCharacterLaneParams) == 0x000008, "Wrong alignment on FHWManageCharacterLaneParams");
static_assert(sizeof(FHWManageCharacterLaneParams) == 0x000038, "Wrong size on FHWManageCharacterLaneParams");
static_assert(offsetof(FHWManageCharacterLaneParams, Character) == 0x000000, "Member 'FHWManageCharacterLaneParams::Character' has a wrong offset!");
static_assert(offsetof(FHWManageCharacterLaneParams, Controller) == 0x000008, "Member 'FHWManageCharacterLaneParams::Controller' has a wrong offset!");
static_assert(offsetof(FHWManageCharacterLaneParams, Lanes) == 0x000010, "Member 'FHWManageCharacterLaneParams::Lanes' has a wrong offset!");
static_assert(offsetof(FHWManageCharacterLaneParams, JungleLaneId) == 0x000020, "Member 'FHWManageCharacterLaneParams::JungleLaneId' has a wrong offset!");
static_assert(offsetof(FHWManageCharacterLaneParams, ImmunityTag) == 0x000028, "Member 'FHWManageCharacterLaneParams::ImmunityTag' has a wrong offset!");
static_assert(offsetof(FHWManageCharacterLaneParams, MinJungleLevelForSiege) == 0x000030, "Member 'FHWManageCharacterLaneParams::MinJungleLevelForSiege' has a wrong offset!");
static_assert(offsetof(FHWManageCharacterLaneParams, MinJungleDefeatedLanesForSiege) == 0x000034, "Member 'FHWManageCharacterLaneParams::MinJungleDefeatedLanesForSiege' has a wrong offset!");

// ScriptStruct Hemingway.HWAladdinWallRunVisualInfo
// 0x0002 (0x0002 - 0x0000)
struct FHWAladdinWallRunVisualInfo final
{
public:
	bool                                          bWallRunEnabled;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWAladdinWallRunDirection                    RunDirection;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAladdinWallRunVisualInfo) == 0x000001, "Wrong alignment on FHWAladdinWallRunVisualInfo");
static_assert(sizeof(FHWAladdinWallRunVisualInfo) == 0x000002, "Wrong size on FHWAladdinWallRunVisualInfo");
static_assert(offsetof(FHWAladdinWallRunVisualInfo, bWallRunEnabled) == 0x000000, "Member 'FHWAladdinWallRunVisualInfo::bWallRunEnabled' has a wrong offset!");
static_assert(offsetof(FHWAladdinWallRunVisualInfo, RunDirection) == 0x000001, "Member 'FHWAladdinWallRunVisualInfo::RunDirection' has a wrong offset!");

// ScriptStruct Hemingway.HWKillRewardGameplayCueInfo
// 0x000C (0x000C - 0x0000)
struct FHWKillRewardGameplayCueInfo final
{
public:
	float                                         TotalGoldReward;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalXPReward;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLastHitCue;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWKillRewardGameplayCueInfo) == 0x000004, "Wrong alignment on FHWKillRewardGameplayCueInfo");
static_assert(sizeof(FHWKillRewardGameplayCueInfo) == 0x00000C, "Wrong size on FHWKillRewardGameplayCueInfo");
static_assert(offsetof(FHWKillRewardGameplayCueInfo, TotalGoldReward) == 0x000000, "Member 'FHWKillRewardGameplayCueInfo::TotalGoldReward' has a wrong offset!");
static_assert(offsetof(FHWKillRewardGameplayCueInfo, TotalXPReward) == 0x000004, "Member 'FHWKillRewardGameplayCueInfo::TotalXPReward' has a wrong offset!");
static_assert(offsetof(FHWKillRewardGameplayCueInfo, bShowLastHitCue) == 0x000008, "Member 'FHWKillRewardGameplayCueInfo::bShowLastHitCue' has a wrong offset!");

// ScriptStruct Hemingway.DamageCalcInfo
// 0x0008 (0x0090 - 0x0088)
struct FDamageCalcInfo final : public FHWEffectCalcInfo
{
public:
	struct FGameplayTag                           DamageType;                                        // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageCalcInfo) == 0x000008, "Wrong alignment on FDamageCalcInfo");
static_assert(sizeof(FDamageCalcInfo) == 0x000090, "Wrong size on FDamageCalcInfo");
static_assert(offsetof(FDamageCalcInfo, DamageType) == 0x000088, "Member 'FDamageCalcInfo::DamageType' has a wrong offset!");

// ScriptStruct Hemingway.HWPingDisplayInfoConfig
// 0x0018 (0x0018 - 0x0000)
struct FHWPingDisplayInfoConfig final
{
public:
	EHWPingDisplayArea                            PingDisplayArea;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressWorldForMinimapSource;                    // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialActorPoolSize;                              // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWPingScope                                  PingScope;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PingDuration;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHWPingWorldActor>          PingWorldActorClass;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPingDisplayInfoConfig) == 0x000008, "Wrong alignment on FHWPingDisplayInfoConfig");
static_assert(sizeof(FHWPingDisplayInfoConfig) == 0x000018, "Wrong size on FHWPingDisplayInfoConfig");
static_assert(offsetof(FHWPingDisplayInfoConfig, PingDisplayArea) == 0x000000, "Member 'FHWPingDisplayInfoConfig::PingDisplayArea' has a wrong offset!");
static_assert(offsetof(FHWPingDisplayInfoConfig, bSuppressWorldForMinimapSource) == 0x000001, "Member 'FHWPingDisplayInfoConfig::bSuppressWorldForMinimapSource' has a wrong offset!");
static_assert(offsetof(FHWPingDisplayInfoConfig, InitialActorPoolSize) == 0x000004, "Member 'FHWPingDisplayInfoConfig::InitialActorPoolSize' has a wrong offset!");
static_assert(offsetof(FHWPingDisplayInfoConfig, PingScope) == 0x000008, "Member 'FHWPingDisplayInfoConfig::PingScope' has a wrong offset!");
static_assert(offsetof(FHWPingDisplayInfoConfig, PingDuration) == 0x00000C, "Member 'FHWPingDisplayInfoConfig::PingDuration' has a wrong offset!");
static_assert(offsetof(FHWPingDisplayInfoConfig, PingWorldActorClass) == 0x000010, "Member 'FHWPingDisplayInfoConfig::PingWorldActorClass' has a wrong offset!");

// ScriptStruct Hemingway.HWSplineOverlapInfo
// 0x0038 (0x0038 - 0x0000)
struct FHWSplineOverlapInfo final
{
public:
	struct FGameplayAbilityTargetDataHandle       InitialOverlapTargetData;                          // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           OverlappedSplineSegments;                          // 0x0028(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSplineOverlapInfo) == 0x000008, "Wrong alignment on FHWSplineOverlapInfo");
static_assert(sizeof(FHWSplineOverlapInfo) == 0x000038, "Wrong size on FHWSplineOverlapInfo");
static_assert(offsetof(FHWSplineOverlapInfo, InitialOverlapTargetData) == 0x000000, "Member 'FHWSplineOverlapInfo::InitialOverlapTargetData' has a wrong offset!");
static_assert(offsetof(FHWSplineOverlapInfo, OverlappedSplineSegments) == 0x000028, "Member 'FHWSplineOverlapInfo::OverlappedSplineSegments' has a wrong offset!");

// ScriptStruct Hemingway.SphereTargetingData
// 0x0078 (0x0078 - 0x0000)
struct FSphereTargetingData final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       AimData;                                           // 0x0008(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MaxTargetsAllowed;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTargetDataFilterHandle> PriorityFilters;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	ETargetingLocationPriorityBehavior            LocationPriorityBehavior;                          // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationPriorityRadiusThreshold;                   // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        AcceptableTargetFilter;                            // 0x0050(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSphereTargetingData) == 0x000008, "Wrong alignment on FSphereTargetingData");
static_assert(sizeof(FSphereTargetingData) == 0x000078, "Wrong size on FSphereTargetingData");
static_assert(offsetof(FSphereTargetingData, Radius) == 0x000000, "Member 'FSphereTargetingData::Radius' has a wrong offset!");
static_assert(offsetof(FSphereTargetingData, AimData) == 0x000008, "Member 'FSphereTargetingData::AimData' has a wrong offset!");
static_assert(offsetof(FSphereTargetingData, MaxTargetsAllowed) == 0x000030, "Member 'FSphereTargetingData::MaxTargetsAllowed' has a wrong offset!");
static_assert(offsetof(FSphereTargetingData, PriorityFilters) == 0x000038, "Member 'FSphereTargetingData::PriorityFilters' has a wrong offset!");
static_assert(offsetof(FSphereTargetingData, LocationPriorityBehavior) == 0x000048, "Member 'FSphereTargetingData::LocationPriorityBehavior' has a wrong offset!");
static_assert(offsetof(FSphereTargetingData, LocationPriorityRadiusThreshold) == 0x00004C, "Member 'FSphereTargetingData::LocationPriorityRadiusThreshold' has a wrong offset!");
static_assert(offsetof(FSphereTargetingData, AcceptableTargetFilter) == 0x000050, "Member 'FSphereTargetingData::AcceptableTargetFilter' has a wrong offset!");
static_assert(offsetof(FSphereTargetingData, ActorsToIgnore) == 0x000060, "Member 'FSphereTargetingData::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(FSphereTargetingData, bDrawDebug) == 0x000070, "Member 'FSphereTargetingData::bDrawDebug' has a wrong offset!");

// ScriptStruct Hemingway.GoldXpCalcInfo
// 0x0000 (0x0088 - 0x0088)
struct FGoldXpCalcInfo final : public FHWEffectCalcInfo
{
};
static_assert(alignof(FGoldXpCalcInfo) == 0x000008, "Wrong alignment on FGoldXpCalcInfo");
static_assert(sizeof(FGoldXpCalcInfo) == 0x000088, "Wrong size on FGoldXpCalcInfo");

// ScriptStruct Hemingway.IzanamiPassiveTrackedDamageInstance
// 0x0008 (0x0008 - 0x0000)
struct FIzanamiPassiveTrackedDamageInstance final
{
public:
	float                                         FutureExpirationTime;                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIzanamiPassiveTrackedDamageInstance) == 0x000004, "Wrong alignment on FIzanamiPassiveTrackedDamageInstance");
static_assert(sizeof(FIzanamiPassiveTrackedDamageInstance) == 0x000008, "Wrong size on FIzanamiPassiveTrackedDamageInstance");
static_assert(offsetof(FIzanamiPassiveTrackedDamageInstance, FutureExpirationTime) == 0x000000, "Member 'FIzanamiPassiveTrackedDamageInstance::FutureExpirationTime' has a wrong offset!");
static_assert(offsetof(FIzanamiPassiveTrackedDamageInstance, DamageAmount) == 0x000004, "Member 'FIzanamiPassiveTrackedDamageInstance::DamageAmount' has a wrong offset!");

// ScriptStruct Hemingway.HWCollisionState
// 0x003C (0x003C - 0x0000)
struct FHWCollisionState final
{
public:
	class FName                                   CollisionProfileName;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             CollisionEnabled;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionObjectType;                               // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionResponseContainer            CollisionResponseContainer;                        // 0x000A(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityScale;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSafelyReturnToWalkingModeOnSet;                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSafelyReturnToWalkingModeOnReturnToBase;          // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialized;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCollisionState) == 0x000004, "Wrong alignment on FHWCollisionState");
static_assert(sizeof(FHWCollisionState) == 0x00003C, "Wrong size on FHWCollisionState");
static_assert(offsetof(FHWCollisionState, CollisionProfileName) == 0x000000, "Member 'FHWCollisionState::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(FHWCollisionState, CollisionEnabled) == 0x000008, "Member 'FHWCollisionState::CollisionEnabled' has a wrong offset!");
static_assert(offsetof(FHWCollisionState, CollisionObjectType) == 0x000009, "Member 'FHWCollisionState::CollisionObjectType' has a wrong offset!");
static_assert(offsetof(FHWCollisionState, CollisionResponseContainer) == 0x00000A, "Member 'FHWCollisionState::CollisionResponseContainer' has a wrong offset!");
static_assert(offsetof(FHWCollisionState, GravityScale) == 0x00002C, "Member 'FHWCollisionState::GravityScale' has a wrong offset!");
static_assert(offsetof(FHWCollisionState, bSafelyReturnToWalkingModeOnSet) == 0x000030, "Member 'FHWCollisionState::bSafelyReturnToWalkingModeOnSet' has a wrong offset!");
static_assert(offsetof(FHWCollisionState, bSafelyReturnToWalkingModeOnReturnToBase) == 0x000031, "Member 'FHWCollisionState::bSafelyReturnToWalkingModeOnReturnToBase' has a wrong offset!");
static_assert(offsetof(FHWCollisionState, Priority) == 0x000034, "Member 'FHWCollisionState::Priority' has a wrong offset!");
static_assert(offsetof(FHWCollisionState, bInitialized) == 0x000038, "Member 'FHWCollisionState::bInitialized' has a wrong offset!");

// ScriptStruct Hemingway.HWDynamicItemInfo
// 0x0040 (0x0040 - 0x0000)
struct FHWDynamicItemInfo final
{
public:
	TWeakObjectPtr<class AHWCharacterAbilitySystemActor> RelatedCharacterAbilitySystemActor;         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWEquipmentItem>        DynamicItem;                                       // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicItemAvailabilityRestriction           AvailabilityRestriction;                           // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AvailabilityDuration;                              // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSellItem;                                      // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWDynamicItemInfo) == 0x000008, "Wrong alignment on FHWDynamicItemInfo");
static_assert(sizeof(FHWDynamicItemInfo) == 0x000040, "Wrong size on FHWDynamicItemInfo");
static_assert(offsetof(FHWDynamicItemInfo, RelatedCharacterAbilitySystemActor) == 0x000000, "Member 'FHWDynamicItemInfo::RelatedCharacterAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(FHWDynamicItemInfo, DynamicItem) == 0x000008, "Member 'FHWDynamicItemInfo::DynamicItem' has a wrong offset!");
static_assert(offsetof(FHWDynamicItemInfo, AvailabilityRestriction) == 0x000030, "Member 'FHWDynamicItemInfo::AvailabilityRestriction' has a wrong offset!");
static_assert(offsetof(FHWDynamicItemInfo, AvailabilityDuration) == 0x000034, "Member 'FHWDynamicItemInfo::AvailabilityDuration' has a wrong offset!");
static_assert(offsetof(FHWDynamicItemInfo, bCanSellItem) == 0x000038, "Member 'FHWDynamicItemInfo::bCanSellItem' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilityItemWithComboTag
// 0x0030 (0x0030 - 0x0000)
struct FHWAbilityItemWithComboTag final
{
public:
	TSoftObjectPtr<class UHWEquipmentItem>        AbilityEquipmentItem;                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DisplayComboTag;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAbilityItemWithComboTag) == 0x000008, "Wrong alignment on FHWAbilityItemWithComboTag");
static_assert(sizeof(FHWAbilityItemWithComboTag) == 0x000030, "Wrong size on FHWAbilityItemWithComboTag");
static_assert(offsetof(FHWAbilityItemWithComboTag, AbilityEquipmentItem) == 0x000000, "Member 'FHWAbilityItemWithComboTag::AbilityEquipmentItem' has a wrong offset!");
static_assert(offsetof(FHWAbilityItemWithComboTag, DisplayComboTag) == 0x000028, "Member 'FHWAbilityItemWithComboTag::DisplayComboTag' has a wrong offset!");

// ScriptStruct Hemingway.HWActiveFamiliarHandle
// 0x000C (0x000C - 0x0000)
struct FHWActiveFamiliarHandle final
{
public:
	int32                                         FamiliarID;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UHWFamiliarManagerComponent> OwningManager;                                 // 0x0004(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHWActiveFamiliarHandle) == 0x000004, "Wrong alignment on FHWActiveFamiliarHandle");
static_assert(sizeof(FHWActiveFamiliarHandle) == 0x00000C, "Wrong size on FHWActiveFamiliarHandle");
static_assert(offsetof(FHWActiveFamiliarHandle, FamiliarID) == 0x000000, "Member 'FHWActiveFamiliarHandle::FamiliarID' has a wrong offset!");
static_assert(offsetof(FHWActiveFamiliarHandle, OwningManager) == 0x000004, "Member 'FHWActiveFamiliarHandle::OwningManager' has a wrong offset!");

// ScriptStruct Hemingway.HWActiveFamiliarInfo
// 0x0050 (0x0050 - 0x0000)
struct FHWActiveFamiliarInfo final
{
public:
	struct FHWActiveFamiliarHandle                Handle;                                            // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWCharacter_Base*                      Character;                                         // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         AbilitySystemActor;                                // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWFamiliarConfigSettings*              Config;                                            // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LivesRemaining;                                    // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LifetimeTimer;                                     // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           RespawnTimer;                                      // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPendingDestroy;                                 // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWActiveFamiliarInfo) == 0x000008, "Wrong alignment on FHWActiveFamiliarInfo");
static_assert(sizeof(FHWActiveFamiliarInfo) == 0x000050, "Wrong size on FHWActiveFamiliarInfo");
static_assert(offsetof(FHWActiveFamiliarInfo, Handle) == 0x000000, "Member 'FHWActiveFamiliarInfo::Handle' has a wrong offset!");
static_assert(offsetof(FHWActiveFamiliarInfo, Character) == 0x000010, "Member 'FHWActiveFamiliarInfo::Character' has a wrong offset!");
static_assert(offsetof(FHWActiveFamiliarInfo, AbilitySystemActor) == 0x000018, "Member 'FHWActiveFamiliarInfo::AbilitySystemActor' has a wrong offset!");
static_assert(offsetof(FHWActiveFamiliarInfo, AbilityHandle) == 0x000020, "Member 'FHWActiveFamiliarInfo::AbilityHandle' has a wrong offset!");
static_assert(offsetof(FHWActiveFamiliarInfo, Config) == 0x000028, "Member 'FHWActiveFamiliarInfo::Config' has a wrong offset!");
static_assert(offsetof(FHWActiveFamiliarInfo, LivesRemaining) == 0x000030, "Member 'FHWActiveFamiliarInfo::LivesRemaining' has a wrong offset!");
static_assert(offsetof(FHWActiveFamiliarInfo, LifetimeTimer) == 0x000038, "Member 'FHWActiveFamiliarInfo::LifetimeTimer' has a wrong offset!");
static_assert(offsetof(FHWActiveFamiliarInfo, RespawnTimer) == 0x000040, "Member 'FHWActiveFamiliarInfo::RespawnTimer' has a wrong offset!");
static_assert(offsetof(FHWActiveFamiliarInfo, bIsPendingDestroy) == 0x000048, "Member 'FHWActiveFamiliarInfo::bIsPendingDestroy' has a wrong offset!");

// ScriptStruct Hemingway.HWChatFilterHttpRequest
// 0x0048 (0x0048 - 0x0000)
struct FHWChatFilterHttpRequest final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Categories;                                        // 0x0010(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         BlockListNames;                                    // 0x0020(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          HaltOnBlocklistHit;                                // 0x0030(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutputType;                                        // 0x0038(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWChatFilterHttpRequest) == 0x000008, "Wrong alignment on FHWChatFilterHttpRequest");
static_assert(sizeof(FHWChatFilterHttpRequest) == 0x000048, "Wrong size on FHWChatFilterHttpRequest");
static_assert(offsetof(FHWChatFilterHttpRequest, Text) == 0x000000, "Member 'FHWChatFilterHttpRequest::Text' has a wrong offset!");
static_assert(offsetof(FHWChatFilterHttpRequest, Categories) == 0x000010, "Member 'FHWChatFilterHttpRequest::Categories' has a wrong offset!");
static_assert(offsetof(FHWChatFilterHttpRequest, BlockListNames) == 0x000020, "Member 'FHWChatFilterHttpRequest::BlockListNames' has a wrong offset!");
static_assert(offsetof(FHWChatFilterHttpRequest, HaltOnBlocklistHit) == 0x000030, "Member 'FHWChatFilterHttpRequest::HaltOnBlocklistHit' has a wrong offset!");
static_assert(offsetof(FHWChatFilterHttpRequest, OutputType) == 0x000038, "Member 'FHWChatFilterHttpRequest::OutputType' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilityFiringInstanceId
// 0x0008 (0x0008 - 0x0000)
struct FHWAbilityFiringInstanceId final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceId;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAbilityFiringInstanceId) == 0x000004, "Wrong alignment on FHWAbilityFiringInstanceId");
static_assert(sizeof(FHWAbilityFiringInstanceId) == 0x000008, "Wrong size on FHWAbilityFiringInstanceId");
static_assert(offsetof(FHWAbilityFiringInstanceId, AbilityHandle) == 0x000000, "Member 'FHWAbilityFiringInstanceId::AbilityHandle' has a wrong offset!");
static_assert(offsetof(FHWAbilityFiringInstanceId, InstanceId) == 0x000004, "Member 'FHWAbilityFiringInstanceId::InstanceId' has a wrong offset!");

// ScriptStruct Hemingway.SpreadStruct
// 0x0040 (0x0040 - 0x0000)
struct FSpreadStruct final
{
public:
	TWeakObjectPtr<class AHWCharacter_NPC>        Character;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentLocation;                                   // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestinationLocation;                               // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpreadStruct) == 0x000008, "Wrong alignment on FSpreadStruct");
static_assert(sizeof(FSpreadStruct) == 0x000040, "Wrong size on FSpreadStruct");
static_assert(offsetof(FSpreadStruct, Character) == 0x000000, "Member 'FSpreadStruct::Character' has a wrong offset!");
static_assert(offsetof(FSpreadStruct, CurrentLocation) == 0x000008, "Member 'FSpreadStruct::CurrentLocation' has a wrong offset!");
static_assert(offsetof(FSpreadStruct, DestinationLocation) == 0x000020, "Member 'FSpreadStruct::DestinationLocation' has a wrong offset!");
static_assert(offsetof(FSpreadStruct, CollisionRadius) == 0x000038, "Member 'FSpreadStruct::CollisionRadius' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilityAttackInstance
// 0x0080 (0x0080 - 0x0000)
struct FHWAbilityAttackInstance final
{
public:
	struct FGameplayTag                           ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackSettingId;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AimSettingId;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCachedAim;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCachedTargets;                                 // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AttackFireCount;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefirePeriod;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCommitCostsOnRefire;                        // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActiveFireDuration;                                // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityAttackActivationTrigger               ActivationTriggerBehavior;                         // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerDelayTime;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEndFirePhaseOnAttackEnd;                    // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETargetDataTypeSlot, int32>              TargetDataSlotIndexMap;                            // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAbilityAttackInstance) == 0x000008, "Wrong alignment on FHWAbilityAttackInstance");
static_assert(sizeof(FHWAbilityAttackInstance) == 0x000080, "Wrong size on FHWAbilityAttackInstance");
static_assert(offsetof(FHWAbilityAttackInstance, ID) == 0x000000, "Member 'FHWAbilityAttackInstance::ID' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, AttackSettingId) == 0x000008, "Member 'FHWAbilityAttackInstance::AttackSettingId' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, AimSettingId) == 0x00000C, "Member 'FHWAbilityAttackInstance::AimSettingId' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, bUseCachedAim) == 0x000010, "Member 'FHWAbilityAttackInstance::bUseCachedAim' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, bUseCachedTargets) == 0x000011, "Member 'FHWAbilityAttackInstance::bUseCachedTargets' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, AttackFireCount) == 0x000014, "Member 'FHWAbilityAttackInstance::AttackFireCount' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, RefirePeriod) == 0x000018, "Member 'FHWAbilityAttackInstance::RefirePeriod' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, bShouldCommitCostsOnRefire) == 0x00001C, "Member 'FHWAbilityAttackInstance::bShouldCommitCostsOnRefire' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, ActiveFireDuration) == 0x000020, "Member 'FHWAbilityAttackInstance::ActiveFireDuration' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, ActivationTriggerBehavior) == 0x000024, "Member 'FHWAbilityAttackInstance::ActivationTriggerBehavior' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, TriggerDelayTime) == 0x000028, "Member 'FHWAbilityAttackInstance::TriggerDelayTime' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, bShouldEndFirePhaseOnAttackEnd) == 0x00002C, "Member 'FHWAbilityAttackInstance::bShouldEndFirePhaseOnAttackEnd' has a wrong offset!");
static_assert(offsetof(FHWAbilityAttackInstance, TargetDataSlotIndexMap) == 0x000030, "Member 'FHWAbilityAttackInstance::TargetDataSlotIndexMap' has a wrong offset!");

// ScriptStruct Hemingway.DeferredProjFlashEvent
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FDeferredProjFlashEvent final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeferredProjFlashEvent) == 0x000008, "Wrong alignment on FDeferredProjFlashEvent");
static_assert(sizeof(FDeferredProjFlashEvent) == 0x000058, "Wrong size on FDeferredProjFlashEvent");

// ScriptStruct Hemingway.HWInventorySlot
// 0x000C (0x000C - 0x0000)
struct FHWInventorySlot final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWInventorySlot) == 0x000004, "Wrong alignment on FHWInventorySlot");
static_assert(sizeof(FHWInventorySlot) == 0x00000C, "Wrong size on FHWInventorySlot");
static_assert(offsetof(FHWInventorySlot, Type) == 0x000000, "Member 'FHWInventorySlot::Type' has a wrong offset!");
static_assert(offsetof(FHWInventorySlot, ID) == 0x000008, "Member 'FHWInventorySlot::ID' has a wrong offset!");

// ScriptStruct Hemingway.HWCombatEvent
// 0x0070 (0x0070 - 0x0000)
struct FHWCombatEvent final
{
public:
	struct FGenericTeamId                         TeamIdentity;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DamageType;                                        // 0x0004(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UHWCharacterItem>        SourceCharacterItem;                               // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UHWCharacterItem>        TargetCharacterItem;                               // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWEquipmentItem*                       EquipmentItem;                                     // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EquipmentInventorySlotType;                        // 0x0030(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipmentInventorySlotId;                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDamageTaken;                                    // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNPC;                                            // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TargetDisplayName;                                 // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SourceDisplayName;                                 // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DamageTimestamp;                                   // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCombatEvent) == 0x000008, "Wrong alignment on FHWCombatEvent");
static_assert(sizeof(FHWCombatEvent) == 0x000070, "Wrong size on FHWCombatEvent");
static_assert(offsetof(FHWCombatEvent, TeamIdentity) == 0x000000, "Member 'FHWCombatEvent::TeamIdentity' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, DamageType) == 0x000004, "Member 'FHWCombatEvent::DamageType' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, EventTag) == 0x00000C, "Member 'FHWCombatEvent::EventTag' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, SourceCharacterItem) == 0x000014, "Member 'FHWCombatEvent::SourceCharacterItem' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, TargetCharacterItem) == 0x00001C, "Member 'FHWCombatEvent::TargetCharacterItem' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, EquipmentItem) == 0x000028, "Member 'FHWCombatEvent::EquipmentItem' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, EquipmentInventorySlotType) == 0x000030, "Member 'FHWCombatEvent::EquipmentInventorySlotType' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, EquipmentInventorySlotId) == 0x000038, "Member 'FHWCombatEvent::EquipmentInventorySlotId' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, bIsDamageTaken) == 0x00003C, "Member 'FHWCombatEvent::bIsDamageTaken' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, bIsNPC) == 0x00003D, "Member 'FHWCombatEvent::bIsNPC' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, TargetDisplayName) == 0x000040, "Member 'FHWCombatEvent::TargetDisplayName' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, SourceDisplayName) == 0x000050, "Member 'FHWCombatEvent::SourceDisplayName' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, Damage) == 0x000060, "Member 'FHWCombatEvent::Damage' has a wrong offset!");
static_assert(offsetof(FHWCombatEvent, DamageTimestamp) == 0x000068, "Member 'FHWCombatEvent::DamageTimestamp' has a wrong offset!");

// ScriptStruct Hemingway.HWEventCharacter
// 0x003C (0x003C - 0x0000)
struct FHWEventCharacter final
{
public:
	struct FHWPersistentPlayerId                  PersistentPlayerId;                                // 0x0000(0x0020)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        CharacterAssetId;                                  // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x0030(0x0001)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           BotFactoryAssetTag;                                // 0x0034(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEventCharacter) == 0x000004, "Wrong alignment on FHWEventCharacter");
static_assert(sizeof(FHWEventCharacter) == 0x00003C, "Wrong size on FHWEventCharacter");
static_assert(offsetof(FHWEventCharacter, PersistentPlayerId) == 0x000000, "Member 'FHWEventCharacter::PersistentPlayerId' has a wrong offset!");
static_assert(offsetof(FHWEventCharacter, CharacterAssetId) == 0x000020, "Member 'FHWEventCharacter::CharacterAssetId' has a wrong offset!");
static_assert(offsetof(FHWEventCharacter, TeamId) == 0x000030, "Member 'FHWEventCharacter::TeamId' has a wrong offset!");
static_assert(offsetof(FHWEventCharacter, BotFactoryAssetTag) == 0x000034, "Member 'FHWEventCharacter::BotFactoryAssetTag' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerSettings_Entry
// 0x0018 (0x0018 - 0x0000)
struct FHWPlayerSettings_Entry final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Version;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWPlayerSettings_Entry) == 0x000008, "Wrong alignment on FHWPlayerSettings_Entry");
static_assert(sizeof(FHWPlayerSettings_Entry) == 0x000018, "Wrong size on FHWPlayerSettings_Entry");
static_assert(offsetof(FHWPlayerSettings_Entry, Value) == 0x000000, "Member 'FHWPlayerSettings_Entry::Value' has a wrong offset!");
static_assert(offsetof(FHWPlayerSettings_Entry, Version) == 0x000010, "Member 'FHWPlayerSettings_Entry::Version' has a wrong offset!");

// ScriptStruct Hemingway.HWGodLoadoutItemCollection
// 0x0010 (0x0010 - 0x0000)
struct FHWGodLoadoutItemCollection final
{
public:
	TArray<struct FRH_ItemId>                     LoadoutItems;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWGodLoadoutItemCollection) == 0x000008, "Wrong alignment on FHWGodLoadoutItemCollection");
static_assert(sizeof(FHWGodLoadoutItemCollection) == 0x000010, "Wrong size on FHWGodLoadoutItemCollection");
static_assert(offsetof(FHWGodLoadoutItemCollection, LoadoutItems) == 0x000000, "Member 'FHWGodLoadoutItemCollection::LoadoutItems' has a wrong offset!");

// ScriptStruct Hemingway.HWGodLoadout
// 0x0128 (0x0128 - 0x0000)
struct FHWGodLoadout final
{
public:
	struct FRH_ItemId                             SkinItemId;                                        // 0x0000(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             CardVFXItemId;                                     // 0x0014(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             JumpStampItemId;                                   // 0x0028(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRH_ItemId>                     TrackerItemIds;                                    // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRH_ItemId>                     BadgeItemIds;                                      // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             EquippedAspectId;                                  // 0x0060(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FHWPlayerSettings_Entry> SettingData;                                 // 0x0078(0x0050)(NativeAccessSpecifierPublic)
	struct FGuid                                  PinnedGodBuild;                                    // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EHWCollectionItemType, struct FHWGodLoadoutItemCollection> LoadoutItemMap;                  // 0x00D8(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWGodLoadout) == 0x000008, "Wrong alignment on FHWGodLoadout");
static_assert(sizeof(FHWGodLoadout) == 0x000128, "Wrong size on FHWGodLoadout");
static_assert(offsetof(FHWGodLoadout, SkinItemId) == 0x000000, "Member 'FHWGodLoadout::SkinItemId' has a wrong offset!");
static_assert(offsetof(FHWGodLoadout, CardVFXItemId) == 0x000014, "Member 'FHWGodLoadout::CardVFXItemId' has a wrong offset!");
static_assert(offsetof(FHWGodLoadout, JumpStampItemId) == 0x000028, "Member 'FHWGodLoadout::JumpStampItemId' has a wrong offset!");
static_assert(offsetof(FHWGodLoadout, TrackerItemIds) == 0x000040, "Member 'FHWGodLoadout::TrackerItemIds' has a wrong offset!");
static_assert(offsetof(FHWGodLoadout, BadgeItemIds) == 0x000050, "Member 'FHWGodLoadout::BadgeItemIds' has a wrong offset!");
static_assert(offsetof(FHWGodLoadout, EquippedAspectId) == 0x000060, "Member 'FHWGodLoadout::EquippedAspectId' has a wrong offset!");
static_assert(offsetof(FHWGodLoadout, SettingData) == 0x000078, "Member 'FHWGodLoadout::SettingData' has a wrong offset!");
static_assert(offsetof(FHWGodLoadout, PinnedGodBuild) == 0x0000C8, "Member 'FHWGodLoadout::PinnedGodBuild' has a wrong offset!");
static_assert(offsetof(FHWGodLoadout, LoadoutItemMap) == 0x0000D8, "Member 'FHWGodLoadout::LoadoutItemMap' has a wrong offset!");

// ScriptStruct Hemingway.BlockDamageEventData
// 0x004C (0x0050 - 0x0004)
struct FBlockDamageEventData final : public FHWCombatEvent_Base
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AttackTags;                                        // 0x0018(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DamageBlocked;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectSpecHandle              EffectSpecHandle;                                  // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockDamageEventData) == 0x000008, "Wrong alignment on FBlockDamageEventData");
static_assert(sizeof(FBlockDamageEventData) == 0x000050, "Wrong size on FBlockDamageEventData");
static_assert(offsetof(FBlockDamageEventData, Instigator) == 0x000008, "Member 'FBlockDamageEventData::Instigator' has a wrong offset!");
static_assert(offsetof(FBlockDamageEventData, Target) == 0x000010, "Member 'FBlockDamageEventData::Target' has a wrong offset!");
static_assert(offsetof(FBlockDamageEventData, AttackTags) == 0x000018, "Member 'FBlockDamageEventData::AttackTags' has a wrong offset!");
static_assert(offsetof(FBlockDamageEventData, DamageBlocked) == 0x000038, "Member 'FBlockDamageEventData::DamageBlocked' has a wrong offset!");
static_assert(offsetof(FBlockDamageEventData, EffectSpecHandle) == 0x000040, "Member 'FBlockDamageEventData::EffectSpecHandle' has a wrong offset!");

// ScriptStruct Hemingway.AITargetPriorityInfo
// 0x0050 (0x0050 - 0x0000)
struct FAITargetPriorityInfo final
{
public:
	struct FGameplayTagContainer                  TargetTags;                                        // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InvalidTags;                                       // 0x0020(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          bHasAllTags;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHostileTarget;                                  // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStickyTarget;                                   // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLOS;                                           // 0x0043(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreLOSIfMinimapVisible;                        // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITargetPriorityType                         AdditionalPriorityType;                            // 0x0045(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITargetRangeType                            TargetRangeType;                                   // 0x0046(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetRange;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAITargetPriorityInfo) == 0x000008, "Wrong alignment on FAITargetPriorityInfo");
static_assert(sizeof(FAITargetPriorityInfo) == 0x000050, "Wrong size on FAITargetPriorityInfo");
static_assert(offsetof(FAITargetPriorityInfo, TargetTags) == 0x000000, "Member 'FAITargetPriorityInfo::TargetTags' has a wrong offset!");
static_assert(offsetof(FAITargetPriorityInfo, InvalidTags) == 0x000020, "Member 'FAITargetPriorityInfo::InvalidTags' has a wrong offset!");
static_assert(offsetof(FAITargetPriorityInfo, bHasAllTags) == 0x000040, "Member 'FAITargetPriorityInfo::bHasAllTags' has a wrong offset!");
static_assert(offsetof(FAITargetPriorityInfo, bIsHostileTarget) == 0x000041, "Member 'FAITargetPriorityInfo::bIsHostileTarget' has a wrong offset!");
static_assert(offsetof(FAITargetPriorityInfo, bIsStickyTarget) == 0x000042, "Member 'FAITargetPriorityInfo::bIsStickyTarget' has a wrong offset!");
static_assert(offsetof(FAITargetPriorityInfo, bHasLOS) == 0x000043, "Member 'FAITargetPriorityInfo::bHasLOS' has a wrong offset!");
static_assert(offsetof(FAITargetPriorityInfo, bIgnoreLOSIfMinimapVisible) == 0x000044, "Member 'FAITargetPriorityInfo::bIgnoreLOSIfMinimapVisible' has a wrong offset!");
static_assert(offsetof(FAITargetPriorityInfo, AdditionalPriorityType) == 0x000045, "Member 'FAITargetPriorityInfo::AdditionalPriorityType' has a wrong offset!");
static_assert(offsetof(FAITargetPriorityInfo, TargetRangeType) == 0x000046, "Member 'FAITargetPriorityInfo::TargetRangeType' has a wrong offset!");
static_assert(offsetof(FAITargetPriorityInfo, TargetRange) == 0x000048, "Member 'FAITargetPriorityInfo::TargetRange' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilitySwapWindowInfo
// 0x0018 (0x0018 - 0x0000)
struct FHWAbilitySwapWindowInfo final
{
public:
	struct FTimerHandle                           Timer;                                             // 0x0000(0x0008)(RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAbilitySwapWindowInfo) == 0x000008, "Wrong alignment on FHWAbilitySwapWindowInfo");
static_assert(sizeof(FHWAbilitySwapWindowInfo) == 0x000018, "Wrong size on FHWAbilitySwapWindowInfo");
static_assert(offsetof(FHWAbilitySwapWindowInfo, Timer) == 0x000000, "Member 'FHWAbilitySwapWindowInfo::Timer' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapWindowInfo, Duration) == 0x000008, "Member 'FHWAbilitySwapWindowInfo::Duration' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapWindowInfo, StartTime) == 0x00000C, "Member 'FHWAbilitySwapWindowInfo::StartTime' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapWindowInfo, bIsActive) == 0x000010, "Member 'FHWAbilitySwapWindowInfo::bIsActive' has a wrong offset!");

// ScriptStruct Hemingway.HWIndividualPenaltyRange
// 0x000C (0x000C - 0x0000)
struct FHWIndividualPenaltyRange final
{
public:
	float                                         SRMinimum;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SRMaximum;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenaltyPercent;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWIndividualPenaltyRange) == 0x000004, "Wrong alignment on FHWIndividualPenaltyRange");
static_assert(sizeof(FHWIndividualPenaltyRange) == 0x00000C, "Wrong size on FHWIndividualPenaltyRange");
static_assert(offsetof(FHWIndividualPenaltyRange, SRMinimum) == 0x000000, "Member 'FHWIndividualPenaltyRange::SRMinimum' has a wrong offset!");
static_assert(offsetof(FHWIndividualPenaltyRange, SRMaximum) == 0x000004, "Member 'FHWIndividualPenaltyRange::SRMaximum' has a wrong offset!");
static_assert(offsetof(FHWIndividualPenaltyRange, PenaltyPercent) == 0x000008, "Member 'FHWIndividualPenaltyRange::PenaltyPercent' has a wrong offset!");

// ScriptStruct Hemingway.HWSkillRatingDivision
// 0x0048 (0x0048 - 0x0000)
struct FHWSkillRatingDivision final
{
public:
	class FText                                   DivisionDisplayName;                               // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DivisionIcon;                                      // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DivisionMinimum;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DivisionMaximum;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkillRatingDivision) == 0x000008, "Wrong alignment on FHWSkillRatingDivision");
static_assert(sizeof(FHWSkillRatingDivision) == 0x000048, "Wrong size on FHWSkillRatingDivision");
static_assert(offsetof(FHWSkillRatingDivision, DivisionDisplayName) == 0x000000, "Member 'FHWSkillRatingDivision::DivisionDisplayName' has a wrong offset!");
static_assert(offsetof(FHWSkillRatingDivision, DivisionIcon) == 0x000018, "Member 'FHWSkillRatingDivision::DivisionIcon' has a wrong offset!");
static_assert(offsetof(FHWSkillRatingDivision, DivisionMinimum) == 0x000040, "Member 'FHWSkillRatingDivision::DivisionMinimum' has a wrong offset!");
static_assert(offsetof(FHWSkillRatingDivision, DivisionMaximum) == 0x000044, "Member 'FHWSkillRatingDivision::DivisionMaximum' has a wrong offset!");

// ScriptStruct Hemingway.HWSkillRatingRank
// 0x0060 (0x0060 - 0x0000)
struct FHWSkillRatingRank final
{
public:
	class FText                                   RankDisplayName;                                   // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              RankIcon;                                          // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RankMinimum;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RankMaximum;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TopCut;                                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWSkillRatingDivision>         Divisions;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkillRatingRank) == 0x000008, "Wrong alignment on FHWSkillRatingRank");
static_assert(sizeof(FHWSkillRatingRank) == 0x000060, "Wrong size on FHWSkillRatingRank");
static_assert(offsetof(FHWSkillRatingRank, RankDisplayName) == 0x000000, "Member 'FHWSkillRatingRank::RankDisplayName' has a wrong offset!");
static_assert(offsetof(FHWSkillRatingRank, RankIcon) == 0x000018, "Member 'FHWSkillRatingRank::RankIcon' has a wrong offset!");
static_assert(offsetof(FHWSkillRatingRank, RankMinimum) == 0x000040, "Member 'FHWSkillRatingRank::RankMinimum' has a wrong offset!");
static_assert(offsetof(FHWSkillRatingRank, RankMaximum) == 0x000044, "Member 'FHWSkillRatingRank::RankMaximum' has a wrong offset!");
static_assert(offsetof(FHWSkillRatingRank, TopCut) == 0x000048, "Member 'FHWSkillRatingRank::TopCut' has a wrong offset!");
static_assert(offsetof(FHWSkillRatingRank, Divisions) == 0x000050, "Member 'FHWSkillRatingRank::Divisions' has a wrong offset!");

// ScriptStruct Hemingway.HWRoleAssignmentTeam
// 0x0018 (0x0018 - 0x0000)
struct FHWRoleAssignmentTeam final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWPersistentPlayerId>          Players;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWRoleAssignmentTeam) == 0x000008, "Wrong alignment on FHWRoleAssignmentTeam");
static_assert(sizeof(FHWRoleAssignmentTeam) == 0x000018, "Wrong size on FHWRoleAssignmentTeam");
static_assert(offsetof(FHWRoleAssignmentTeam, TeamId) == 0x000000, "Member 'FHWRoleAssignmentTeam::TeamId' has a wrong offset!");
static_assert(offsetof(FHWRoleAssignmentTeam, Players) == 0x000008, "Member 'FHWRoleAssignmentTeam::Players' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerLoadoutItemCollection
// 0x0010 (0x0010 - 0x0000)
struct FHWPlayerLoadoutItemCollection final
{
public:
	TArray<struct FRH_ItemId>                     LoadoutItems;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPlayerLoadoutItemCollection) == 0x000008, "Wrong alignment on FHWPlayerLoadoutItemCollection");
static_assert(sizeof(FHWPlayerLoadoutItemCollection) == 0x000010, "Wrong size on FHWPlayerLoadoutItemCollection");
static_assert(offsetof(FHWPlayerLoadoutItemCollection, LoadoutItems) == 0x000000, "Member 'FHWPlayerLoadoutItemCollection::LoadoutItems' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerLoadout
// 0x00B8 (0x00B8 - 0x0000)
struct FHWPlayerLoadout final
{
public:
	struct FRH_ItemId                             TitleItemId;                                       // 0x0000(0x0014)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_ItemId                             AvatarItemId;                                      // 0x0014(0x0014)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_ItemId                             GlobalEmoteItemId;                                 // 0x0028(0x0014)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_ItemId                             MusicPackItemId;                                   // 0x003C(0x0014)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_ItemId                             PlayerNameColorItemId;                             // 0x0050(0x0014)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EHWCollectionItemType, struct FHWPlayerLoadoutItemCollection> LoadoutItemMap;               // 0x0068(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPlayerLoadout) == 0x000008, "Wrong alignment on FHWPlayerLoadout");
static_assert(sizeof(FHWPlayerLoadout) == 0x0000B8, "Wrong size on FHWPlayerLoadout");
static_assert(offsetof(FHWPlayerLoadout, TitleItemId) == 0x000000, "Member 'FHWPlayerLoadout::TitleItemId' has a wrong offset!");
static_assert(offsetof(FHWPlayerLoadout, AvatarItemId) == 0x000014, "Member 'FHWPlayerLoadout::AvatarItemId' has a wrong offset!");
static_assert(offsetof(FHWPlayerLoadout, GlobalEmoteItemId) == 0x000028, "Member 'FHWPlayerLoadout::GlobalEmoteItemId' has a wrong offset!");
static_assert(offsetof(FHWPlayerLoadout, MusicPackItemId) == 0x00003C, "Member 'FHWPlayerLoadout::MusicPackItemId' has a wrong offset!");
static_assert(offsetof(FHWPlayerLoadout, PlayerNameColorItemId) == 0x000050, "Member 'FHWPlayerLoadout::PlayerNameColorItemId' has a wrong offset!");
static_assert(offsetof(FHWPlayerLoadout, LoadoutItemMap) == 0x000068, "Member 'FHWPlayerLoadout::LoadoutItemMap' has a wrong offset!");

// ScriptStruct Hemingway.HWAudioTrackPlayInfo
// 0x0024 (0x0024 - 0x0000)
struct FHWAudioTrackPlayInfo final
{
public:
	struct FAssetRequestKey                       AssetKey;                                          // 0x0000(0x001C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAudioTrackPlayInfo) == 0x000004, "Wrong alignment on FHWAudioTrackPlayInfo");
static_assert(sizeof(FHWAudioTrackPlayInfo) == 0x000024, "Wrong size on FHWAudioTrackPlayInfo");
static_assert(offsetof(FHWAudioTrackPlayInfo, AssetKey) == 0x000000, "Member 'FHWAudioTrackPlayInfo::AssetKey' has a wrong offset!");
static_assert(offsetof(FHWAudioTrackPlayInfo, FadeInTime) == 0x00001C, "Member 'FHWAudioTrackPlayInfo::FadeInTime' has a wrong offset!");
static_assert(offsetof(FHWAudioTrackPlayInfo, FadeOutTime) == 0x000020, "Member 'FHWAudioTrackPlayInfo::FadeOutTime' has a wrong offset!");

// ScriptStruct Hemingway.HWApparelTemplateFinder
// 0x0008 (0x0008 - 0x0000)
struct FHWApparelTemplateFinder final
{
public:
	class UHWApparelItem*                         Apparel;                                           // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHWApparelTemplateFinder) == 0x000008, "Wrong alignment on FHWApparelTemplateFinder");
static_assert(sizeof(FHWApparelTemplateFinder) == 0x000008, "Wrong size on FHWApparelTemplateFinder");
static_assert(offsetof(FHWApparelTemplateFinder, Apparel) == 0x000000, "Member 'FHWApparelTemplateFinder::Apparel' has a wrong offset!");

// ScriptStruct Hemingway.HWAllItemListGroup
// 0x0040 (0x0040 - 0x0000)
struct FHWAllItemListGroup final
{
public:
	bool                                          SortByPrimaryStatTag;                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SortingTag;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SortingTag2;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSortingTag2Additive;                            // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PrimaryStatSortingTag;                             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSortingTag2ForGodBuilder;                       // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemGroupLabel;                                    // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAllItemListGroup) == 0x000008, "Wrong alignment on FHWAllItemListGroup");
static_assert(sizeof(FHWAllItemListGroup) == 0x000040, "Wrong size on FHWAllItemListGroup");
static_assert(offsetof(FHWAllItemListGroup, SortByPrimaryStatTag) == 0x000000, "Member 'FHWAllItemListGroup::SortByPrimaryStatTag' has a wrong offset!");
static_assert(offsetof(FHWAllItemListGroup, SortingTag) == 0x000004, "Member 'FHWAllItemListGroup::SortingTag' has a wrong offset!");
static_assert(offsetof(FHWAllItemListGroup, SortingTag2) == 0x00000C, "Member 'FHWAllItemListGroup::SortingTag2' has a wrong offset!");
static_assert(offsetof(FHWAllItemListGroup, bIsSortingTag2Additive) == 0x000014, "Member 'FHWAllItemListGroup::bIsSortingTag2Additive' has a wrong offset!");
static_assert(offsetof(FHWAllItemListGroup, PrimaryStatSortingTag) == 0x000018, "Member 'FHWAllItemListGroup::PrimaryStatSortingTag' has a wrong offset!");
static_assert(offsetof(FHWAllItemListGroup, bIsSortingTag2ForGodBuilder) == 0x000020, "Member 'FHWAllItemListGroup::bIsSortingTag2ForGodBuilder' has a wrong offset!");
static_assert(offsetof(FHWAllItemListGroup, ItemGroupLabel) == 0x000028, "Member 'FHWAllItemListGroup::ItemGroupLabel' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilityRefireInfo
// 0x0020 (0x0020 - 0x0000)
struct FHWAbilityRefireInfo final
{
public:
	TWeakObjectPtr<class UObject>                 RefireObject;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 GenericFloats;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAbilityRefireInfo) == 0x000008, "Wrong alignment on FHWAbilityRefireInfo");
static_assert(sizeof(FHWAbilityRefireInfo) == 0x000020, "Wrong size on FHWAbilityRefireInfo");
static_assert(offsetof(FHWAbilityRefireInfo, RefireObject) == 0x000000, "Member 'FHWAbilityRefireInfo::RefireObject' has a wrong offset!");
static_assert(offsetof(FHWAbilityRefireInfo, AbilityLevel) == 0x000008, "Member 'FHWAbilityRefireInfo::AbilityLevel' has a wrong offset!");
static_assert(offsetof(FHWAbilityRefireInfo, GenericFloats) == 0x000010, "Member 'FHWAbilityRefireInfo::GenericFloats' has a wrong offset!");

// ScriptStruct Hemingway.HWPlatformCohort
// 0x0010 (0x0010 - 0x0000)
struct FHWPlatformCohort final
{
public:
	int32                                         Cohorts;                                           // 0x0000(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PC;                                                // 0x0004(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PS5;                                               // 0x0008(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XBox;                                              // 0x000C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPlatformCohort) == 0x000004, "Wrong alignment on FHWPlatformCohort");
static_assert(sizeof(FHWPlatformCohort) == 0x000010, "Wrong size on FHWPlatformCohort");
static_assert(offsetof(FHWPlatformCohort, Cohorts) == 0x000000, "Member 'FHWPlatformCohort::Cohorts' has a wrong offset!");
static_assert(offsetof(FHWPlatformCohort, PC) == 0x000004, "Member 'FHWPlatformCohort::PC' has a wrong offset!");
static_assert(offsetof(FHWPlatformCohort, PS5) == 0x000008, "Member 'FHWPlatformCohort::PS5' has a wrong offset!");
static_assert(offsetof(FHWPlatformCohort, XBox) == 0x00000C, "Member 'FHWPlatformCohort::XBox' has a wrong offset!");

// ScriptStruct Hemingway.HWMaterialOverlayData
// 0x0010 (0x0010 - 0x0000)
struct FHWMaterialOverlayData final
{
public:
	class UMaterialInterface*                     OverlayMaterial;                                   // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWMaterialOverlayData) == 0x000008, "Wrong alignment on FHWMaterialOverlayData");
static_assert(sizeof(FHWMaterialOverlayData) == 0x000010, "Wrong size on FHWMaterialOverlayData");
static_assert(offsetof(FHWMaterialOverlayData, OverlayMaterial) == 0x000000, "Member 'FHWMaterialOverlayData::OverlayMaterial' has a wrong offset!");
static_assert(offsetof(FHWMaterialOverlayData, Priority) == 0x000008, "Member 'FHWMaterialOverlayData::Priority' has a wrong offset!");
static_assert(offsetof(FHWMaterialOverlayData, ID) == 0x00000C, "Member 'FHWMaterialOverlayData::ID' has a wrong offset!");

// ScriptStruct Hemingway.HWAssignedRolesMapWrapper
// 0x0020 (0x0020 - 0x0000)
struct FHWAssignedRolesMapWrapper final
{
public:
	TArray<struct FHWPersistentPlayerId>          AssignedPlayerRoleKeys;                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECharacterRole>                        AssignedPlayerRoleValues;                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAssignedRolesMapWrapper) == 0x000008, "Wrong alignment on FHWAssignedRolesMapWrapper");
static_assert(sizeof(FHWAssignedRolesMapWrapper) == 0x000020, "Wrong size on FHWAssignedRolesMapWrapper");
static_assert(offsetof(FHWAssignedRolesMapWrapper, AssignedPlayerRoleKeys) == 0x000000, "Member 'FHWAssignedRolesMapWrapper::AssignedPlayerRoleKeys' has a wrong offset!");
static_assert(offsetof(FHWAssignedRolesMapWrapper, AssignedPlayerRoleValues) == 0x000010, "Member 'FHWAssignedRolesMapWrapper::AssignedPlayerRoleValues' has a wrong offset!");

// ScriptStruct Hemingway.HWCustomBotConfig_Single
// 0x0018 (0x0018 - 0x0000)
struct FHWCustomBotConfig_Single final
{
public:
	struct FRH_ItemId                             CharacterItemId;                                   // 0x0000(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWBotDifficulty                              Difficulty;                                        // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCustomBotConfig_Single) == 0x000004, "Wrong alignment on FHWCustomBotConfig_Single");
static_assert(sizeof(FHWCustomBotConfig_Single) == 0x000018, "Wrong size on FHWCustomBotConfig_Single");
static_assert(offsetof(FHWCustomBotConfig_Single, CharacterItemId) == 0x000000, "Member 'FHWCustomBotConfig_Single::CharacterItemId' has a wrong offset!");
static_assert(offsetof(FHWCustomBotConfig_Single, Difficulty) == 0x000014, "Member 'FHWCustomBotConfig_Single::Difficulty' has a wrong offset!");

// ScriptStruct Hemingway.HWCustomBotConfig_Team
// 0x0010 (0x0010 - 0x0000)
struct FHWCustomBotConfig_Team final
{
public:
	TArray<struct FHWCustomBotConfig_Single>      BotConfigs;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCustomBotConfig_Team) == 0x000008, "Wrong alignment on FHWCustomBotConfig_Team");
static_assert(sizeof(FHWCustomBotConfig_Team) == 0x000010, "Wrong size on FHWCustomBotConfig_Team");
static_assert(offsetof(FHWCustomBotConfig_Team, BotConfigs) == 0x000000, "Member 'FHWCustomBotConfig_Team::BotConfigs' has a wrong offset!");

// ScriptStruct Hemingway.HWGameplayCompositeAttribute
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FHWGameplayCompositeAttribute final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWGameplayCompositeAttribute) == 0x000008, "Wrong alignment on FHWGameplayCompositeAttribute");
static_assert(sizeof(FHWGameplayCompositeAttribute) == 0x000048, "Wrong size on FHWGameplayCompositeAttribute");

// ScriptStruct Hemingway.AssistEventData
// 0x0020 (0x0020 - 0x0000)
struct FAssistEventData final
{
public:
	class AActor*                                 AssistingActor;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OriginalKillerActor;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecentDamageTimestamp;                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssistEventData) == 0x000008, "Wrong alignment on FAssistEventData");
static_assert(sizeof(FAssistEventData) == 0x000020, "Wrong size on FAssistEventData");
static_assert(offsetof(FAssistEventData, AssistingActor) == 0x000000, "Member 'FAssistEventData::AssistingActor' has a wrong offset!");
static_assert(offsetof(FAssistEventData, OriginalKillerActor) == 0x000008, "Member 'FAssistEventData::OriginalKillerActor' has a wrong offset!");
static_assert(offsetof(FAssistEventData, TargetActor) == 0x000010, "Member 'FAssistEventData::TargetActor' has a wrong offset!");
static_assert(offsetof(FAssistEventData, RecentDamageTimestamp) == 0x000018, "Member 'FAssistEventData::RecentDamageTimestamp' has a wrong offset!");

// ScriptStruct Hemingway.HWFamiliarSpawnParams
// 0x0020 (0x0020 - 0x0000)
struct FHWFamiliarSpawnParams final
{
public:
	class UHWCharacterItem*                       FamiliarCharacterItemOverride;                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWSkinItem*                            FamiliarSkinItemOverride;                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            FamiliarControllerOverride;                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWFamiliarSpawnParams) == 0x000008, "Wrong alignment on FHWFamiliarSpawnParams");
static_assert(sizeof(FHWFamiliarSpawnParams) == 0x000020, "Wrong size on FHWFamiliarSpawnParams");
static_assert(offsetof(FHWFamiliarSpawnParams, FamiliarCharacterItemOverride) == 0x000000, "Member 'FHWFamiliarSpawnParams::FamiliarCharacterItemOverride' has a wrong offset!");
static_assert(offsetof(FHWFamiliarSpawnParams, FamiliarSkinItemOverride) == 0x000008, "Member 'FHWFamiliarSpawnParams::FamiliarSkinItemOverride' has a wrong offset!");
static_assert(offsetof(FHWFamiliarSpawnParams, FamiliarControllerOverride) == 0x000010, "Member 'FHWFamiliarSpawnParams::FamiliarControllerOverride' has a wrong offset!");

// ScriptStruct Hemingway.HWBackfillQueueInfo
// 0x0014 (0x0014 - 0x0000)
struct FHWBackfillQueueInfo final
{
public:
	int32                                         PlayersConnected;                                  // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayersInvited;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalSeats;                                        // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWBackfillState                              State;                                             // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RemainingStateTime;                                // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWBackfillQueueInfo) == 0x000004, "Wrong alignment on FHWBackfillQueueInfo");
static_assert(sizeof(FHWBackfillQueueInfo) == 0x000014, "Wrong size on FHWBackfillQueueInfo");
static_assert(offsetof(FHWBackfillQueueInfo, PlayersConnected) == 0x000000, "Member 'FHWBackfillQueueInfo::PlayersConnected' has a wrong offset!");
static_assert(offsetof(FHWBackfillQueueInfo, PlayersInvited) == 0x000004, "Member 'FHWBackfillQueueInfo::PlayersInvited' has a wrong offset!");
static_assert(offsetof(FHWBackfillQueueInfo, TotalSeats) == 0x000008, "Member 'FHWBackfillQueueInfo::TotalSeats' has a wrong offset!");
static_assert(offsetof(FHWBackfillQueueInfo, State) == 0x00000C, "Member 'FHWBackfillQueueInfo::State' has a wrong offset!");
static_assert(offsetof(FHWBackfillQueueInfo, RemainingStateTime) == 0x000010, "Member 'FHWBackfillQueueInfo::RemainingStateTime' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayCallSuggestion
// 0x0048 (0x0048 - 0x0000)
struct FHWPlayCallSuggestion final
{
public:
	bool                                          bIsValid;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    Play;                                              // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AHWPlayerState>          TargetPlayerState;                                 // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Path;                                              // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPlayCallSuggestion) == 0x000008, "Wrong alignment on FHWPlayCallSuggestion");
static_assert(sizeof(FHWPlayCallSuggestion) == 0x000048, "Wrong size on FHWPlayCallSuggestion");
static_assert(offsetof(FHWPlayCallSuggestion, bIsValid) == 0x000000, "Member 'FHWPlayCallSuggestion::bIsValid' has a wrong offset!");
static_assert(offsetof(FHWPlayCallSuggestion, Play) == 0x000008, "Member 'FHWPlayCallSuggestion::Play' has a wrong offset!");
static_assert(offsetof(FHWPlayCallSuggestion, TargetPlayerState) == 0x000018, "Member 'FHWPlayCallSuggestion::TargetPlayerState' has a wrong offset!");
static_assert(offsetof(FHWPlayCallSuggestion, TargetLocation) == 0x000020, "Member 'FHWPlayCallSuggestion::TargetLocation' has a wrong offset!");
static_assert(offsetof(FHWPlayCallSuggestion, Path) == 0x000038, "Member 'FHWPlayCallSuggestion::Path' has a wrong offset!");

// ScriptStruct Hemingway.HWTeamPlayer
// 0x00A0 (0x00A0 - 0x0000)
struct FHWTeamPlayer final
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0000(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWCharacterItem>        DraftedCharacterItem;                              // 0x0020(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWSkinItem>             DraftedSkinItem;                                   // 0x0048(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWEquipmentItem>        DraftedAspectItem;                                 // 0x0070(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterRole                                AssignedRole;                                      // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWBotDifficulty                              BotDifficulty;                                     // 0x0099(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWTeamPlayer) == 0x000008, "Wrong alignment on FHWTeamPlayer");
static_assert(sizeof(FHWTeamPlayer) == 0x0000A0, "Wrong size on FHWTeamPlayer");
static_assert(offsetof(FHWTeamPlayer, PlayerId) == 0x000000, "Member 'FHWTeamPlayer::PlayerId' has a wrong offset!");
static_assert(offsetof(FHWTeamPlayer, DraftedCharacterItem) == 0x000020, "Member 'FHWTeamPlayer::DraftedCharacterItem' has a wrong offset!");
static_assert(offsetof(FHWTeamPlayer, DraftedSkinItem) == 0x000048, "Member 'FHWTeamPlayer::DraftedSkinItem' has a wrong offset!");
static_assert(offsetof(FHWTeamPlayer, DraftedAspectItem) == 0x000070, "Member 'FHWTeamPlayer::DraftedAspectItem' has a wrong offset!");
static_assert(offsetof(FHWTeamPlayer, AssignedRole) == 0x000098, "Member 'FHWTeamPlayer::AssignedRole' has a wrong offset!");
static_assert(offsetof(FHWTeamPlayer, BotDifficulty) == 0x000099, "Member 'FHWTeamPlayer::BotDifficulty' has a wrong offset!");

// ScriptStruct Hemingway.HWChatEntry
// 0x0060 (0x0060 - 0x0000)
struct FHWChatEntry final
{
public:
	struct FGuid                                  SenderRHPlayerId;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PromptString;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FTextInfoBuffer;                                   // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWChatEntryType                              ChatType;                                          // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ChatTag;                                           // 0x0044(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         ExclusiveToTeam;                                   // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ExclusiveToPlayer;                                 // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWChatEntry) == 0x000008, "Wrong alignment on FHWChatEntry");
static_assert(sizeof(FHWChatEntry) == 0x000060, "Wrong size on FHWChatEntry");
static_assert(offsetof(FHWChatEntry, SenderRHPlayerId) == 0x000000, "Member 'FHWChatEntry::SenderRHPlayerId' has a wrong offset!");
static_assert(offsetof(FHWChatEntry, PromptString) == 0x000010, "Member 'FHWChatEntry::PromptString' has a wrong offset!");
static_assert(offsetof(FHWChatEntry, Message) == 0x000020, "Member 'FHWChatEntry::Message' has a wrong offset!");
static_assert(offsetof(FHWChatEntry, FTextInfoBuffer) == 0x000030, "Member 'FHWChatEntry::FTextInfoBuffer' has a wrong offset!");
static_assert(offsetof(FHWChatEntry, ChatType) == 0x000040, "Member 'FHWChatEntry::ChatType' has a wrong offset!");
static_assert(offsetof(FHWChatEntry, ChatTag) == 0x000044, "Member 'FHWChatEntry::ChatTag' has a wrong offset!");
static_assert(offsetof(FHWChatEntry, ExclusiveToTeam) == 0x00004C, "Member 'FHWChatEntry::ExclusiveToTeam' has a wrong offset!");
static_assert(offsetof(FHWChatEntry, ExclusiveToPlayer) == 0x000050, "Member 'FHWChatEntry::ExclusiveToPlayer' has a wrong offset!");

// ScriptStruct Hemingway.HWDisplayInfo
// 0x0030 (0x0030 - 0x0000)
struct FHWDisplayInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0004(0x0008)(BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AssociatedActor;                                   // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWDisplayInfoData*                     ContextData;                                       // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHidden;                                         // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWDisplayInfo) == 0x000008, "Wrong alignment on FHWDisplayInfo");
static_assert(sizeof(FHWDisplayInfo) == 0x000030, "Wrong size on FHWDisplayInfo");
static_assert(offsetof(FHWDisplayInfo, ID) == 0x000000, "Member 'FHWDisplayInfo::ID' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfo, DisplayInfoTag) == 0x000004, "Member 'FHWDisplayInfo::DisplayInfoTag' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfo, AssociatedActor) == 0x000010, "Member 'FHWDisplayInfo::AssociatedActor' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfo, LifeSpan) == 0x000018, "Member 'FHWDisplayInfo::LifeSpan' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfo, ContextData) == 0x000020, "Member 'FHWDisplayInfo::ContextData' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfo, bIsHidden) == 0x000028, "Member 'FHWDisplayInfo::bIsHidden' has a wrong offset!");

// ScriptStruct Hemingway.HWSpectateTargetIndexInfo
// 0x0008 (0x0008 - 0x0000)
struct FHWSpectateTargetIndexInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpectatingPlayer;                               // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWSpectateTargetIndexInfo) == 0x000004, "Wrong alignment on FHWSpectateTargetIndexInfo");
static_assert(sizeof(FHWSpectateTargetIndexInfo) == 0x000008, "Wrong size on FHWSpectateTargetIndexInfo");
static_assert(offsetof(FHWSpectateTargetIndexInfo, Index) == 0x000000, "Member 'FHWSpectateTargetIndexInfo::Index' has a wrong offset!");
static_assert(offsetof(FHWSpectateTargetIndexInfo, bIsSpectatingPlayer) == 0x000004, "Member 'FHWSpectateTargetIndexInfo::bIsSpectatingPlayer' has a wrong offset!");

// ScriptStruct Hemingway.HWTargetData_MultiHit
// 0x0010 (0x00D0 - 0x00C0)
struct FHWTargetData_MultiHit final : public FGameplayAbilityTargetData_ActorArray
{
public:
	TArray<struct FHitResult>                     Hits;                                              // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWTargetData_MultiHit) == 0x000010, "Wrong alignment on FHWTargetData_MultiHit");
static_assert(sizeof(FHWTargetData_MultiHit) == 0x0000D0, "Wrong size on FHWTargetData_MultiHit");
static_assert(offsetof(FHWTargetData_MultiHit, Hits) == 0x0000C0, "Member 'FHWTargetData_MultiHit::Hits' has a wrong offset!");

// ScriptStruct Hemingway.HWEventContext
// 0x0088 (0x0088 - 0x0000)
struct FHWEventContext final
{
public:
	struct FHWEventCharacter                      InstigatingCharacter;                              // 0x0000(0x003C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHWEventCharacter                      AffectedCharacter;                                 // 0x003C(0x003C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FHWEventCharacter>              AdditionalCharacters;                              // 0x0078(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEventContext) == 0x000008, "Wrong alignment on FHWEventContext");
static_assert(sizeof(FHWEventContext) == 0x000088, "Wrong size on FHWEventContext");
static_assert(offsetof(FHWEventContext, InstigatingCharacter) == 0x000000, "Member 'FHWEventContext::InstigatingCharacter' has a wrong offset!");
static_assert(offsetof(FHWEventContext, AffectedCharacter) == 0x00003C, "Member 'FHWEventContext::AffectedCharacter' has a wrong offset!");
static_assert(offsetof(FHWEventContext, AdditionalCharacters) == 0x000078, "Member 'FHWEventContext::AdditionalCharacters' has a wrong offset!");

// ScriptStruct Hemingway.HWBotAbilityData
// 0x000C (0x000C - 0x0000)
struct FHWBotAbilityData final
{
public:
	struct FGameplayTag                           EquipTag;                                          // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipSlot;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWBotAbilityData) == 0x000004, "Wrong alignment on FHWBotAbilityData");
static_assert(sizeof(FHWBotAbilityData) == 0x00000C, "Wrong size on FHWBotAbilityData");
static_assert(offsetof(FHWBotAbilityData, EquipTag) == 0x000000, "Member 'FHWBotAbilityData::EquipTag' has a wrong offset!");
static_assert(offsetof(FHWBotAbilityData, EquipSlot) == 0x000008, "Member 'FHWBotAbilityData::EquipSlot' has a wrong offset!");

// ScriptStruct Hemingway.HealEventData
// 0x003C (0x0040 - 0x0004)
struct FHealEventData final : public FHWCombatEvent_Base
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EffectTags;                                        // 0x0018(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         TargetHealth;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmountHealed;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHealEventData) == 0x000008, "Wrong alignment on FHealEventData");
static_assert(sizeof(FHealEventData) == 0x000040, "Wrong size on FHealEventData");
static_assert(offsetof(FHealEventData, Instigator) == 0x000008, "Member 'FHealEventData::Instigator' has a wrong offset!");
static_assert(offsetof(FHealEventData, Target) == 0x000010, "Member 'FHealEventData::Target' has a wrong offset!");
static_assert(offsetof(FHealEventData, EffectTags) == 0x000018, "Member 'FHealEventData::EffectTags' has a wrong offset!");
static_assert(offsetof(FHealEventData, TargetHealth) == 0x000038, "Member 'FHealEventData::TargetHealth' has a wrong offset!");
static_assert(offsetof(FHealEventData, AmountHealed) == 0x00003C, "Member 'FHealEventData::AmountHealed' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilitySet_GrantedHandles
// 0x0040 (0x0040 - 0x0000)
struct FHWAbilitySet_GrantedHandles final
{
public:
	TArray<struct FGameplayAbilitySpecHandle>     AbilitySpecHandles;                                // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    GameplayEffectHandles;                             // 0x0010(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAttributeSet*>                  GrantedAttributeSets;                              // 0x0020(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UHWEquipmentInstance>> GrantedEquipment;                             // 0x0030(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHWAbilitySet_GrantedHandles) == 0x000008, "Wrong alignment on FHWAbilitySet_GrantedHandles");
static_assert(sizeof(FHWAbilitySet_GrantedHandles) == 0x000040, "Wrong size on FHWAbilitySet_GrantedHandles");
static_assert(offsetof(FHWAbilitySet_GrantedHandles, AbilitySpecHandles) == 0x000000, "Member 'FHWAbilitySet_GrantedHandles::AbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(FHWAbilitySet_GrantedHandles, GameplayEffectHandles) == 0x000010, "Member 'FHWAbilitySet_GrantedHandles::GameplayEffectHandles' has a wrong offset!");
static_assert(offsetof(FHWAbilitySet_GrantedHandles, GrantedAttributeSets) == 0x000020, "Member 'FHWAbilitySet_GrantedHandles::GrantedAttributeSets' has a wrong offset!");
static_assert(offsetof(FHWAbilitySet_GrantedHandles, GrantedEquipment) == 0x000030, "Member 'FHWAbilitySet_GrantedHandles::GrantedEquipment' has a wrong offset!");

// ScriptStruct Hemingway.HWGamePhaseAppliedEffect
// 0x0060 (0x0060 - 0x0000)
struct FHWGamePhaseAppliedEffect final
{
public:
	int32                                         AppliedToTeam;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemovedOnPhaseEnd;                                // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySet*                          PhasePlayerModAbilities;                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FHWAbilitySet_GrantedHandles> PhaseGrantedModifierMap;                 // 0x0010(0x0050)(RepSkip, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWGamePhaseAppliedEffect) == 0x000008, "Wrong alignment on FHWGamePhaseAppliedEffect");
static_assert(sizeof(FHWGamePhaseAppliedEffect) == 0x000060, "Wrong size on FHWGamePhaseAppliedEffect");
static_assert(offsetof(FHWGamePhaseAppliedEffect, AppliedToTeam) == 0x000000, "Member 'FHWGamePhaseAppliedEffect::AppliedToTeam' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseAppliedEffect, bRemovedOnPhaseEnd) == 0x000004, "Member 'FHWGamePhaseAppliedEffect::bRemovedOnPhaseEnd' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseAppliedEffect, PhasePlayerModAbilities) == 0x000008, "Member 'FHWGamePhaseAppliedEffect::PhasePlayerModAbilities' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseAppliedEffect, PhaseGrantedModifierMap) == 0x000010, "Member 'FHWGamePhaseAppliedEffect::PhaseGrantedModifierMap' has a wrong offset!");

// ScriptStruct Hemingway.HWRolePreferenceData
// 0x0058 (0x0058 - 0x0000)
struct FHWRolePreferenceData final
{
public:
	TMap<ECharacterRole, int32>                   RolePreferences;                                   // 0x0000(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bRoleFill;                                         // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWRolePreferenceData) == 0x000008, "Wrong alignment on FHWRolePreferenceData");
static_assert(sizeof(FHWRolePreferenceData) == 0x000058, "Wrong size on FHWRolePreferenceData");
static_assert(offsetof(FHWRolePreferenceData, RolePreferences) == 0x000000, "Member 'FHWRolePreferenceData::RolePreferences' has a wrong offset!");
static_assert(offsetof(FHWRolePreferenceData, bRoleFill) == 0x000050, "Member 'FHWRolePreferenceData::bRoleFill' has a wrong offset!");

// ScriptStruct Hemingway.HWVoiceOverQueue
// 0x0028 (0x0028 - 0x0000)
struct FHWVoiceOverQueue final
{
public:
	struct FGameplayTag                           SkinKeyword;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventBehavior;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventAudience;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventAttachmentType;                               // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SkinningInstigatorActor;                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVoiceOverQueue) == 0x000008, "Wrong alignment on FHWVoiceOverQueue");
static_assert(sizeof(FHWVoiceOverQueue) == 0x000028, "Wrong size on FHWVoiceOverQueue");
static_assert(offsetof(FHWVoiceOverQueue, SkinKeyword) == 0x000000, "Member 'FHWVoiceOverQueue::SkinKeyword' has a wrong offset!");
static_assert(offsetof(FHWVoiceOverQueue, EventBehavior) == 0x000008, "Member 'FHWVoiceOverQueue::EventBehavior' has a wrong offset!");
static_assert(offsetof(FHWVoiceOverQueue, EventAudience) == 0x000010, "Member 'FHWVoiceOverQueue::EventAudience' has a wrong offset!");
static_assert(offsetof(FHWVoiceOverQueue, EventAttachmentType) == 0x000018, "Member 'FHWVoiceOverQueue::EventAttachmentType' has a wrong offset!");
static_assert(offsetof(FHWVoiceOverQueue, SkinningInstigatorActor) == 0x000020, "Member 'FHWVoiceOverQueue::SkinningInstigatorActor' has a wrong offset!");

// ScriptStruct Hemingway.QuestReplicatedEvent
// 0x003C (0x0048 - 0x000C)
struct FQuestReplicatedEvent final : public FFastArraySerializerItem
{
public:
	struct FRH_ItemId                             QuestItem;                                         // 0x000C(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PersistentProgress;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransientProgress;                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryProgress;                                 // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             LastProcessedQuestId;                              // 0x002C(0x0014)(RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastProcessedProgress;                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastProcessedTransientProgress;                    // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestReplicatedEvent) == 0x000004, "Wrong alignment on FQuestReplicatedEvent");
static_assert(sizeof(FQuestReplicatedEvent) == 0x000048, "Wrong size on FQuestReplicatedEvent");
static_assert(offsetof(FQuestReplicatedEvent, QuestItem) == 0x00000C, "Member 'FQuestReplicatedEvent::QuestItem' has a wrong offset!");
static_assert(offsetof(FQuestReplicatedEvent, PersistentProgress) == 0x000020, "Member 'FQuestReplicatedEvent::PersistentProgress' has a wrong offset!");
static_assert(offsetof(FQuestReplicatedEvent, TransientProgress) == 0x000024, "Member 'FQuestReplicatedEvent::TransientProgress' has a wrong offset!");
static_assert(offsetof(FQuestReplicatedEvent, InventoryProgress) == 0x000028, "Member 'FQuestReplicatedEvent::InventoryProgress' has a wrong offset!");
static_assert(offsetof(FQuestReplicatedEvent, LastProcessedQuestId) == 0x00002C, "Member 'FQuestReplicatedEvent::LastProcessedQuestId' has a wrong offset!");
static_assert(offsetof(FQuestReplicatedEvent, LastProcessedProgress) == 0x000040, "Member 'FQuestReplicatedEvent::LastProcessedProgress' has a wrong offset!");
static_assert(offsetof(FQuestReplicatedEvent, LastProcessedTransientProgress) == 0x000044, "Member 'FQuestReplicatedEvent::LastProcessedTransientProgress' has a wrong offset!");

// ScriptStruct Hemingway.QuestReplicatedEventList
// 0x0020 (0x0128 - 0x0108)
struct FQuestReplicatedEventList final : public FFastArraySerializer
{
public:
	TArray<struct FQuestReplicatedEvent>          FlashEvents;                                       // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         CurrentFlashIndex;                                 // 0x0118(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWPlayerController*                    OwningPlayerController;                            // 0x0120(0x0008)(ZeroConstructor, Transient, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FQuestReplicatedEventList) == 0x000008, "Wrong alignment on FQuestReplicatedEventList");
static_assert(sizeof(FQuestReplicatedEventList) == 0x000128, "Wrong size on FQuestReplicatedEventList");
static_assert(offsetof(FQuestReplicatedEventList, FlashEvents) == 0x000108, "Member 'FQuestReplicatedEventList::FlashEvents' has a wrong offset!");
static_assert(offsetof(FQuestReplicatedEventList, CurrentFlashIndex) == 0x000118, "Member 'FQuestReplicatedEventList::CurrentFlashIndex' has a wrong offset!");
static_assert(offsetof(FQuestReplicatedEventList, OwningPlayerController) == 0x000120, "Member 'FQuestReplicatedEventList::OwningPlayerController' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilityItemSet
// 0x0010 (0x0010 - 0x0000)
struct FHWAbilityItemSet final
{
public:
	TArray<struct FHWAbilityItemWithComboTag>     AbilitySet;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAbilityItemSet) == 0x000008, "Wrong alignment on FHWAbilityItemSet");
static_assert(sizeof(FHWAbilityItemSet) == 0x000010, "Wrong size on FHWAbilityItemSet");
static_assert(offsetof(FHWAbilityItemSet, AbilitySet) == 0x000000, "Member 'FHWAbilityItemSet::AbilitySet' has a wrong offset!");

// ScriptStruct Hemingway.HWRankData
// 0x0008 (0x0008 - 0x0000)
struct FHWRankData final
{
public:
	float                                         Mu;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sigma;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWRankData) == 0x000004, "Wrong alignment on FHWRankData");
static_assert(sizeof(FHWRankData) == 0x000008, "Wrong size on FHWRankData");
static_assert(offsetof(FHWRankData, Mu) == 0x000000, "Member 'FHWRankData::Mu' has a wrong offset!");
static_assert(offsetof(FHWRankData, Sigma) == 0x000004, "Member 'FHWRankData::Sigma' has a wrong offset!");

// ScriptStruct Hemingway.HWWallRunPathInfo
// 0x0120 (0x0120 - 0x0000)
struct FHWWallRunPathInfo final
{
public:
	bool                                          bFoundValidWallRunPath;                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        WallPathPoints;                                    // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WallTravelDirectionAngle;                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             LastWallHit;                                       // 0x0020(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                LastWallNormal;                                    // 0x0108(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWWallRunPathInfo) == 0x000008, "Wrong alignment on FHWWallRunPathInfo");
static_assert(sizeof(FHWWallRunPathInfo) == 0x000120, "Wrong size on FHWWallRunPathInfo");
static_assert(offsetof(FHWWallRunPathInfo, bFoundValidWallRunPath) == 0x000000, "Member 'FHWWallRunPathInfo::bFoundValidWallRunPath' has a wrong offset!");
static_assert(offsetof(FHWWallRunPathInfo, WallPathPoints) == 0x000008, "Member 'FHWWallRunPathInfo::WallPathPoints' has a wrong offset!");
static_assert(offsetof(FHWWallRunPathInfo, WallTravelDirectionAngle) == 0x000018, "Member 'FHWWallRunPathInfo::WallTravelDirectionAngle' has a wrong offset!");
static_assert(offsetof(FHWWallRunPathInfo, LastWallHit) == 0x000020, "Member 'FHWWallRunPathInfo::LastWallHit' has a wrong offset!");
static_assert(offsetof(FHWWallRunPathInfo, LastWallNormal) == 0x000108, "Member 'FHWWallRunPathInfo::LastWallNormal' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerMatchData
// 0x0078 (0x0078 - 0x0000)
struct FHWPlayerMatchData final
{
public:
	class FString                                 MatchID;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameModeInfoTag;                                   // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CharacterChoice;                                   // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerLevel;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerKills;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerDeaths;                                      // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerAssists;                                     // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalGold;                                         // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalPlayerDamage;                                 // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldPerMinute;                                     // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaneMinionDamage;                                  // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JungleMinionDamage;                                // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StructureDamage;                                   // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageTaken;                                       // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageMitigated;                                   // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelfHealing;                                       // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AllyHealing;                                       // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WardsPlaced;                                       // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              Duration;                                          // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Date;                                              // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPlayerMatchData) == 0x000008, "Wrong alignment on FHWPlayerMatchData");
static_assert(sizeof(FHWPlayerMatchData) == 0x000078, "Wrong size on FHWPlayerMatchData");
static_assert(offsetof(FHWPlayerMatchData, MatchID) == 0x000000, "Member 'FHWPlayerMatchData::MatchID' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, GameModeInfoTag) == 0x000010, "Member 'FHWPlayerMatchData::GameModeInfoTag' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, CharacterChoice) == 0x000018, "Member 'FHWPlayerMatchData::CharacterChoice' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, bResult) == 0x000020, "Member 'FHWPlayerMatchData::bResult' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, PlayerLevel) == 0x000024, "Member 'FHWPlayerMatchData::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, PlayerKills) == 0x000028, "Member 'FHWPlayerMatchData::PlayerKills' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, PlayerDeaths) == 0x00002C, "Member 'FHWPlayerMatchData::PlayerDeaths' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, PlayerAssists) == 0x000030, "Member 'FHWPlayerMatchData::PlayerAssists' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, TotalGold) == 0x000034, "Member 'FHWPlayerMatchData::TotalGold' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, TotalPlayerDamage) == 0x000038, "Member 'FHWPlayerMatchData::TotalPlayerDamage' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, GoldPerMinute) == 0x00003C, "Member 'FHWPlayerMatchData::GoldPerMinute' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, LaneMinionDamage) == 0x000040, "Member 'FHWPlayerMatchData::LaneMinionDamage' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, JungleMinionDamage) == 0x000044, "Member 'FHWPlayerMatchData::JungleMinionDamage' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, StructureDamage) == 0x000048, "Member 'FHWPlayerMatchData::StructureDamage' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, DamageTaken) == 0x00004C, "Member 'FHWPlayerMatchData::DamageTaken' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, DamageMitigated) == 0x000050, "Member 'FHWPlayerMatchData::DamageMitigated' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, SelfHealing) == 0x000054, "Member 'FHWPlayerMatchData::SelfHealing' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, AllyHealing) == 0x000058, "Member 'FHWPlayerMatchData::AllyHealing' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, WardsPlaced) == 0x00005C, "Member 'FHWPlayerMatchData::WardsPlaced' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, TeamId) == 0x000060, "Member 'FHWPlayerMatchData::TeamId' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, Duration) == 0x000068, "Member 'FHWPlayerMatchData::Duration' has a wrong offset!");
static_assert(offsetof(FHWPlayerMatchData, Date) == 0x000070, "Member 'FHWPlayerMatchData::Date' has a wrong offset!");

// ScriptStruct Hemingway.HWTransformPhase
// 0x0070 (0x0070 - 0x0000)
struct FHWTransformPhase final
{
public:
	struct FTransform                             TargetTransform;                                   // 0x0000(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWTransformPhase) == 0x000010, "Wrong alignment on FHWTransformPhase");
static_assert(sizeof(FHWTransformPhase) == 0x000070, "Wrong size on FHWTransformPhase");
static_assert(offsetof(FHWTransformPhase, TargetTransform) == 0x000000, "Member 'FHWTransformPhase::TargetTransform' has a wrong offset!");
static_assert(offsetof(FHWTransformPhase, Duration) == 0x000060, "Member 'FHWTransformPhase::Duration' has a wrong offset!");

// ScriptStruct Hemingway.HWAladdinWallRunPathClampInfo
// 0x0028 (0x0028 - 0x0000)
struct FHWAladdinWallRunPathClampInfo final
{
public:
	EHWAladdinWallRunClampBehavior                ClampBehavior;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinHeight;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHypotenus;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHypotenus;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterWallRunAngleThreshold;                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AngleMultiplierCurve;                              // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAladdinWallRunPathClampInfo) == 0x000008, "Wrong alignment on FHWAladdinWallRunPathClampInfo");
static_assert(sizeof(FHWAladdinWallRunPathClampInfo) == 0x000028, "Wrong size on FHWAladdinWallRunPathClampInfo");
static_assert(offsetof(FHWAladdinWallRunPathClampInfo, ClampBehavior) == 0x000000, "Member 'FHWAladdinWallRunPathClampInfo::ClampBehavior' has a wrong offset!");
static_assert(offsetof(FHWAladdinWallRunPathClampInfo, MinHeight) == 0x000004, "Member 'FHWAladdinWallRunPathClampInfo::MinHeight' has a wrong offset!");
static_assert(offsetof(FHWAladdinWallRunPathClampInfo, MaxHeight) == 0x000008, "Member 'FHWAladdinWallRunPathClampInfo::MaxHeight' has a wrong offset!");
static_assert(offsetof(FHWAladdinWallRunPathClampInfo, MinHypotenus) == 0x00000C, "Member 'FHWAladdinWallRunPathClampInfo::MinHypotenus' has a wrong offset!");
static_assert(offsetof(FHWAladdinWallRunPathClampInfo, MaxHypotenus) == 0x000010, "Member 'FHWAladdinWallRunPathClampInfo::MaxHypotenus' has a wrong offset!");
static_assert(offsetof(FHWAladdinWallRunPathClampInfo, MinDistance) == 0x000014, "Member 'FHWAladdinWallRunPathClampInfo::MinDistance' has a wrong offset!");
static_assert(offsetof(FHWAladdinWallRunPathClampInfo, MaxDistance) == 0x000018, "Member 'FHWAladdinWallRunPathClampInfo::MaxDistance' has a wrong offset!");
static_assert(offsetof(FHWAladdinWallRunPathClampInfo, CenterWallRunAngleThreshold) == 0x00001C, "Member 'FHWAladdinWallRunPathClampInfo::CenterWallRunAngleThreshold' has a wrong offset!");
static_assert(offsetof(FHWAladdinWallRunPathClampInfo, AngleMultiplierCurve) == 0x000020, "Member 'FHWAladdinWallRunPathClampInfo::AngleMultiplierCurve' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSGameplayEventTagConfig
// 0x0018 (0x0018 - 0x0000)
struct FHWVGSGameplayEventTagConfig final
{
public:
	struct FGameplayTag                           VGSGameplayEventTag;                               // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VGSPingTag;                                        // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VGSActionTag;                                      // 0x0010(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVGSGameplayEventTagConfig) == 0x000004, "Wrong alignment on FHWVGSGameplayEventTagConfig");
static_assert(sizeof(FHWVGSGameplayEventTagConfig) == 0x000018, "Wrong size on FHWVGSGameplayEventTagConfig");
static_assert(offsetof(FHWVGSGameplayEventTagConfig, VGSGameplayEventTag) == 0x000000, "Member 'FHWVGSGameplayEventTagConfig::VGSGameplayEventTag' has a wrong offset!");
static_assert(offsetof(FHWVGSGameplayEventTagConfig, VGSPingTag) == 0x000008, "Member 'FHWVGSGameplayEventTagConfig::VGSPingTag' has a wrong offset!");
static_assert(offsetof(FHWVGSGameplayEventTagConfig, VGSActionTag) == 0x000010, "Member 'FHWVGSGameplayEventTagConfig::VGSActionTag' has a wrong offset!");

// ScriptStruct Hemingway.HWCombatAdvantageParams
// 0x0038 (0x0038 - 0x0000)
struct FHWCombatAdvantageParams final
{
public:
	class AHWCharacter_Base*                      Source;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      Target;                                            // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCharacterDistance;                              // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMinionDistance;                                 // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGodsOnly;                                         // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalHealthPercentageDiffForAdvantage;             // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalHealthPercentageDiffForMassiveAdvantage;      // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowHealthPercentageThreshold;                      // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeToKillForAdvantage;                         // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinMinionCountForDisadvantage;                     // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinionDifferenceForMassiveAdvantage;               // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCombatAdvantageParams) == 0x000008, "Wrong alignment on FHWCombatAdvantageParams");
static_assert(sizeof(FHWCombatAdvantageParams) == 0x000038, "Wrong size on FHWCombatAdvantageParams");
static_assert(offsetof(FHWCombatAdvantageParams, Source) == 0x000000, "Member 'FHWCombatAdvantageParams::Source' has a wrong offset!");
static_assert(offsetof(FHWCombatAdvantageParams, Target) == 0x000008, "Member 'FHWCombatAdvantageParams::Target' has a wrong offset!");
static_assert(offsetof(FHWCombatAdvantageParams, MaxCharacterDistance) == 0x000010, "Member 'FHWCombatAdvantageParams::MaxCharacterDistance' has a wrong offset!");
static_assert(offsetof(FHWCombatAdvantageParams, MaxMinionDistance) == 0x000014, "Member 'FHWCombatAdvantageParams::MaxMinionDistance' has a wrong offset!");
static_assert(offsetof(FHWCombatAdvantageParams, bGodsOnly) == 0x000018, "Member 'FHWCombatAdvantageParams::bGodsOnly' has a wrong offset!");
static_assert(offsetof(FHWCombatAdvantageParams, TotalHealthPercentageDiffForAdvantage) == 0x00001C, "Member 'FHWCombatAdvantageParams::TotalHealthPercentageDiffForAdvantage' has a wrong offset!");
static_assert(offsetof(FHWCombatAdvantageParams, TotalHealthPercentageDiffForMassiveAdvantage) == 0x000020, "Member 'FHWCombatAdvantageParams::TotalHealthPercentageDiffForMassiveAdvantage' has a wrong offset!");
static_assert(offsetof(FHWCombatAdvantageParams, LowHealthPercentageThreshold) == 0x000024, "Member 'FHWCombatAdvantageParams::LowHealthPercentageThreshold' has a wrong offset!");
static_assert(offsetof(FHWCombatAdvantageParams, MaxTimeToKillForAdvantage) == 0x000028, "Member 'FHWCombatAdvantageParams::MaxTimeToKillForAdvantage' has a wrong offset!");
static_assert(offsetof(FHWCombatAdvantageParams, MinMinionCountForDisadvantage) == 0x00002C, "Member 'FHWCombatAdvantageParams::MinMinionCountForDisadvantage' has a wrong offset!");
static_assert(offsetof(FHWCombatAdvantageParams, MinionDifferenceForMassiveAdvantage) == 0x000030, "Member 'FHWCombatAdvantageParams::MinionDifferenceForMassiveAdvantage' has a wrong offset!");

// ScriptStruct Hemingway.HWLaneAggressionParams
// 0x0038 (0x0038 - 0x0000)
struct FHWLaneAggressionParams final
{
public:
	class AHWCharacter_Base*                      Source;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GodWeight;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionWeight;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleWeightByHealthPct;                           // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LaneId;                                            // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ImmunityTag;                                       // 0x0024(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStayOutOfEnemyTowerRange;                         // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnemyTowerRange;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWLaneAggressionParams) == 0x000008, "Wrong alignment on FHWLaneAggressionParams");
static_assert(sizeof(FHWLaneAggressionParams) == 0x000038, "Wrong size on FHWLaneAggressionParams");
static_assert(offsetof(FHWLaneAggressionParams, Source) == 0x000000, "Member 'FHWLaneAggressionParams::Source' has a wrong offset!");
static_assert(offsetof(FHWLaneAggressionParams, SearchRadius) == 0x000008, "Member 'FHWLaneAggressionParams::SearchRadius' has a wrong offset!");
static_assert(offsetof(FHWLaneAggressionParams, GodWeight) == 0x00000C, "Member 'FHWLaneAggressionParams::GodWeight' has a wrong offset!");
static_assert(offsetof(FHWLaneAggressionParams, MinionWeight) == 0x000010, "Member 'FHWLaneAggressionParams::MinionWeight' has a wrong offset!");
static_assert(offsetof(FHWLaneAggressionParams, bScaleWeightByHealthPct) == 0x000014, "Member 'FHWLaneAggressionParams::bScaleWeightByHealthPct' has a wrong offset!");
static_assert(offsetof(FHWLaneAggressionParams, LaneId) == 0x000018, "Member 'FHWLaneAggressionParams::LaneId' has a wrong offset!");
static_assert(offsetof(FHWLaneAggressionParams, Direction) == 0x000020, "Member 'FHWLaneAggressionParams::Direction' has a wrong offset!");
static_assert(offsetof(FHWLaneAggressionParams, ImmunityTag) == 0x000024, "Member 'FHWLaneAggressionParams::ImmunityTag' has a wrong offset!");
static_assert(offsetof(FHWLaneAggressionParams, bStayOutOfEnemyTowerRange) == 0x00002C, "Member 'FHWLaneAggressionParams::bStayOutOfEnemyTowerRange' has a wrong offset!");
static_assert(offsetof(FHWLaneAggressionParams, EnemyTowerRange) == 0x000030, "Member 'FHWLaneAggressionParams::EnemyTowerRange' has a wrong offset!");
static_assert(offsetof(FHWLaneAggressionParams, bDebug) == 0x000034, "Member 'FHWLaneAggressionParams::bDebug' has a wrong offset!");

// ScriptStruct Hemingway.HWAIDifficultyData
// 0x00C0 (0x00C0 - 0x0000)
struct FHWAIDifficultyData final
{
public:
	float                                         MaxDifficulty;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AggressiveAbilityFrequency;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowAbilityCombos;                                // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    Effects;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PlaysToDisable;                                    // 0x0020(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              PlayWeightPenalty;                                 // 0x0040(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilitiesToDisableByOption;                        // 0x0090(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MaxFocusFireOnPlayer;                              // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPlayerLevelForAggression;                       // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerThreatModifier;                              // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAIDifficultyData) == 0x000008, "Wrong alignment on FHWAIDifficultyData");
static_assert(sizeof(FHWAIDifficultyData) == 0x0000C0, "Wrong size on FHWAIDifficultyData");
static_assert(offsetof(FHWAIDifficultyData, MaxDifficulty) == 0x000000, "Member 'FHWAIDifficultyData::MaxDifficulty' has a wrong offset!");
static_assert(offsetof(FHWAIDifficultyData, AggressiveAbilityFrequency) == 0x000004, "Member 'FHWAIDifficultyData::AggressiveAbilityFrequency' has a wrong offset!");
static_assert(offsetof(FHWAIDifficultyData, AllowAbilityCombos) == 0x000008, "Member 'FHWAIDifficultyData::AllowAbilityCombos' has a wrong offset!");
static_assert(offsetof(FHWAIDifficultyData, Effects) == 0x000010, "Member 'FHWAIDifficultyData::Effects' has a wrong offset!");
static_assert(offsetof(FHWAIDifficultyData, PlaysToDisable) == 0x000020, "Member 'FHWAIDifficultyData::PlaysToDisable' has a wrong offset!");
static_assert(offsetof(FHWAIDifficultyData, PlayWeightPenalty) == 0x000040, "Member 'FHWAIDifficultyData::PlayWeightPenalty' has a wrong offset!");
static_assert(offsetof(FHWAIDifficultyData, AbilitiesToDisableByOption) == 0x000090, "Member 'FHWAIDifficultyData::AbilitiesToDisableByOption' has a wrong offset!");
static_assert(offsetof(FHWAIDifficultyData, MaxFocusFireOnPlayer) == 0x0000B0, "Member 'FHWAIDifficultyData::MaxFocusFireOnPlayer' has a wrong offset!");
static_assert(offsetof(FHWAIDifficultyData, MinPlayerLevelForAggression) == 0x0000B4, "Member 'FHWAIDifficultyData::MinPlayerLevelForAggression' has a wrong offset!");
static_assert(offsetof(FHWAIDifficultyData, PlayerThreatModifier) == 0x0000B8, "Member 'FHWAIDifficultyData::PlayerThreatModifier' has a wrong offset!");

// ScriptStruct Hemingway.HWAILearningData
// 0x0010 (0x0010 - 0x0000)
struct FHWAILearningData final
{
public:
	TArray<struct FHWAILearningSampleData>        Samples;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAILearningData) == 0x000008, "Wrong alignment on FHWAILearningData");
static_assert(sizeof(FHWAILearningData) == 0x000010, "Wrong size on FHWAILearningData");
static_assert(offsetof(FHWAILearningData, Samples) == 0x000000, "Member 'FHWAILearningData::Samples' has a wrong offset!");

// ScriptStruct Hemingway.AIPlayEntry
// 0x00F0 (0x00F8 - 0x0008)
struct FAIPlayEntry final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Art;                                               // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWAIPlayTargetDisplayType                    AIPlayTargetDisplayType;                           // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PingTag;                                           // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNPEPathIndicator;                             // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNPEDirectionIndicator;                        // 0x006D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNPEPlay;                                        // 0x006E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F[0x1];                                       // 0x006F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinPlayers;                                        // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomWeightMin;                                   // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomWeightMax;                                   // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAIPlayersOnly;                                    // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownTime;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CooldownId;                                        // 0x008C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EHWAIPlayGameStage, float>               GameStageWeightModifiers;                          // 0x0098(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlayId;                                            // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWAIPlayLogic>             AILogicClass;                                      // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIPlayEntry) == 0x000008, "Wrong alignment on FAIPlayEntry");
static_assert(sizeof(FAIPlayEntry) == 0x0000F8, "Wrong size on FAIPlayEntry");
static_assert(offsetof(FAIPlayEntry, Title) == 0x000008, "Member 'FAIPlayEntry::Title' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, Description) == 0x000020, "Member 'FAIPlayEntry::Description' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, Art) == 0x000038, "Member 'FAIPlayEntry::Art' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, AIPlayTargetDisplayType) == 0x000060, "Member 'FAIPlayEntry::AIPlayTargetDisplayType' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, PingTag) == 0x000064, "Member 'FAIPlayEntry::PingTag' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, bShowNPEPathIndicator) == 0x00006C, "Member 'FAIPlayEntry::bShowNPEPathIndicator' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, bShowNPEDirectionIndicator) == 0x00006D, "Member 'FAIPlayEntry::bShowNPEDirectionIndicator' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, bIsNPEPlay) == 0x00006E, "Member 'FAIPlayEntry::bIsNPEPlay' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, MinPlayers) == 0x000070, "Member 'FAIPlayEntry::MinPlayers' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, MaxPlayers) == 0x000074, "Member 'FAIPlayEntry::MaxPlayers' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, Weight) == 0x000078, "Member 'FAIPlayEntry::Weight' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, RandomWeightMin) == 0x00007C, "Member 'FAIPlayEntry::RandomWeightMin' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, RandomWeightMax) == 0x000080, "Member 'FAIPlayEntry::RandomWeightMax' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, bAIPlayersOnly) == 0x000084, "Member 'FAIPlayEntry::bAIPlayersOnly' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, CooldownTime) == 0x000088, "Member 'FAIPlayEntry::CooldownTime' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, CooldownId) == 0x00008C, "Member 'FAIPlayEntry::CooldownId' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, GameStageWeightModifiers) == 0x000098, "Member 'FAIPlayEntry::GameStageWeightModifiers' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, PlayId) == 0x0000E8, "Member 'FAIPlayEntry::PlayId' has a wrong offset!");
static_assert(offsetof(FAIPlayEntry, AILogicClass) == 0x0000F0, "Member 'FAIPlayEntry::AILogicClass' has a wrong offset!");

// ScriptStruct Hemingway.HWBotAbilityComboEntryData
// 0x0008 (0x0008 - 0x0000)
struct FHWBotAbilityComboEntryData final
{
public:
	int32                                         AbilityIndex;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDelayTillNext;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWBotAbilityComboEntryData) == 0x000004, "Wrong alignment on FHWBotAbilityComboEntryData");
static_assert(sizeof(FHWBotAbilityComboEntryData) == 0x000008, "Wrong size on FHWBotAbilityComboEntryData");
static_assert(offsetof(FHWBotAbilityComboEntryData, AbilityIndex) == 0x000000, "Member 'FHWBotAbilityComboEntryData::AbilityIndex' has a wrong offset!");
static_assert(offsetof(FHWBotAbilityComboEntryData, TimeDelayTillNext) == 0x000004, "Member 'FHWBotAbilityComboEntryData::TimeDelayTillNext' has a wrong offset!");

// ScriptStruct Hemingway.HWBotAbilityComboData
// 0x0010 (0x0010 - 0x0000)
struct FHWBotAbilityComboData final
{
public:
	TArray<struct FHWBotAbilityComboEntryData>    Entries;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWBotAbilityComboData) == 0x000008, "Wrong alignment on FHWBotAbilityComboData");
static_assert(sizeof(FHWBotAbilityComboData) == 0x000010, "Wrong size on FHWBotAbilityComboData");
static_assert(offsetof(FHWBotAbilityComboData, Entries) == 0x000000, "Member 'FHWBotAbilityComboData::Entries' has a wrong offset!");

// ScriptStruct Hemingway.HWAIBotConfig
// 0x00B0 (0x00B0 - 0x0000)
struct FHWAIBotConfig final
{
public:
	bool                                          bLandmarkRegister;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWCharacterItem*                       CharacterItem;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWSkinItem>             SkinItem;                                          // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           BehaviorTree;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWBotPropertiesDefinition> BotProperties;                                  // 0x0060(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PerceptionComponentOverride;                       // 0x0088(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAIBotConfig) == 0x000008, "Wrong alignment on FHWAIBotConfig");
static_assert(sizeof(FHWAIBotConfig) == 0x0000B0, "Wrong size on FHWAIBotConfig");
static_assert(offsetof(FHWAIBotConfig, bLandmarkRegister) == 0x000000, "Member 'FHWAIBotConfig::bLandmarkRegister' has a wrong offset!");
static_assert(offsetof(FHWAIBotConfig, CharacterItem) == 0x000008, "Member 'FHWAIBotConfig::CharacterItem' has a wrong offset!");
static_assert(offsetof(FHWAIBotConfig, SkinItem) == 0x000010, "Member 'FHWAIBotConfig::SkinItem' has a wrong offset!");
static_assert(offsetof(FHWAIBotConfig, BehaviorTree) == 0x000038, "Member 'FHWAIBotConfig::BehaviorTree' has a wrong offset!");
static_assert(offsetof(FHWAIBotConfig, BotProperties) == 0x000060, "Member 'FHWAIBotConfig::BotProperties' has a wrong offset!");
static_assert(offsetof(FHWAIBotConfig, PerceptionComponentOverride) == 0x000088, "Member 'FHWAIBotConfig::PerceptionComponentOverride' has a wrong offset!");

// ScriptStruct Hemingway.HWAIThreatHistoryData
// 0x0038 (0x0038 - 0x0000)
struct FHWAIThreatHistoryData final
{
public:
	TWeakObjectPtr<class AHWCharacter_Base>       Character;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastKnownLocation;                                 // 0x0008(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPerceivedTime;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatValue;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCurrentlySee;                                  // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCurrentlyHear;                                 // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CarryOverThreatValue;                              // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthTime;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAIThreatHistoryData) == 0x000008, "Wrong alignment on FHWAIThreatHistoryData");
static_assert(sizeof(FHWAIThreatHistoryData) == 0x000038, "Wrong size on FHWAIThreatHistoryData");
static_assert(offsetof(FHWAIThreatHistoryData, Character) == 0x000000, "Member 'FHWAIThreatHistoryData::Character' has a wrong offset!");
static_assert(offsetof(FHWAIThreatHistoryData, LastKnownLocation) == 0x000008, "Member 'FHWAIThreatHistoryData::LastKnownLocation' has a wrong offset!");
static_assert(offsetof(FHWAIThreatHistoryData, LastPerceivedTime) == 0x000020, "Member 'FHWAIThreatHistoryData::LastPerceivedTime' has a wrong offset!");
static_assert(offsetof(FHWAIThreatHistoryData, ThreatValue) == 0x000024, "Member 'FHWAIThreatHistoryData::ThreatValue' has a wrong offset!");
static_assert(offsetof(FHWAIThreatHistoryData, bCanCurrentlySee) == 0x000028, "Member 'FHWAIThreatHistoryData::bCanCurrentlySee' has a wrong offset!");
static_assert(offsetof(FHWAIThreatHistoryData, bCanCurrentlyHear) == 0x000029, "Member 'FHWAIThreatHistoryData::bCanCurrentlyHear' has a wrong offset!");
static_assert(offsetof(FHWAIThreatHistoryData, CarryOverThreatValue) == 0x00002C, "Member 'FHWAIThreatHistoryData::CarryOverThreatValue' has a wrong offset!");
static_assert(offsetof(FHWAIThreatHistoryData, StealthTime) == 0x000030, "Member 'FHWAIThreatHistoryData::StealthTime' has a wrong offset!");

// ScriptStruct Hemingway.HWAIThreatCalculation
// 0x0020 (0x0020 - 0x0000)
struct FHWAIThreatCalculation final
{
public:
	float                                         X0;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X1;                                                // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y0;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y1;                                                // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampY;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAIThreatCalculation) == 0x000008, "Wrong alignment on FHWAIThreatCalculation");
static_assert(sizeof(FHWAIThreatCalculation) == 0x000020, "Wrong size on FHWAIThreatCalculation");
static_assert(offsetof(FHWAIThreatCalculation, X0) == 0x000000, "Member 'FHWAIThreatCalculation::X0' has a wrong offset!");
static_assert(offsetof(FHWAIThreatCalculation, X1) == 0x000004, "Member 'FHWAIThreatCalculation::X1' has a wrong offset!");
static_assert(offsetof(FHWAIThreatCalculation, Y0) == 0x000008, "Member 'FHWAIThreatCalculation::Y0' has a wrong offset!");
static_assert(offsetof(FHWAIThreatCalculation, Y1) == 0x00000C, "Member 'FHWAIThreatCalculation::Y1' has a wrong offset!");
static_assert(offsetof(FHWAIThreatCalculation, Curve) == 0x000010, "Member 'FHWAIThreatCalculation::Curve' has a wrong offset!");
static_assert(offsetof(FHWAIThreatCalculation, bClampY) == 0x000018, "Member 'FHWAIThreatCalculation::bClampY' has a wrong offset!");

// ScriptStruct Hemingway.HWNotifyNiagaraUserParameters
// 0x0038 (0x0038 - 0x0000)
struct FHWNotifyNiagaraUserParameters final
{
public:
	EHWNiagaraVarType                             NiagaraVarType;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntValue;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorValue;                                        // 0x000C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Vector3Value;                                      // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWNotifyNiagaraUserParameters) == 0x000008, "Wrong alignment on FHWNotifyNiagaraUserParameters");
static_assert(sizeof(FHWNotifyNiagaraUserParameters) == 0x000038, "Wrong size on FHWNotifyNiagaraUserParameters");
static_assert(offsetof(FHWNotifyNiagaraUserParameters, NiagaraVarType) == 0x000000, "Member 'FHWNotifyNiagaraUserParameters::NiagaraVarType' has a wrong offset!");
static_assert(offsetof(FHWNotifyNiagaraUserParameters, BoolValue) == 0x000001, "Member 'FHWNotifyNiagaraUserParameters::BoolValue' has a wrong offset!");
static_assert(offsetof(FHWNotifyNiagaraUserParameters, IntValue) == 0x000004, "Member 'FHWNotifyNiagaraUserParameters::IntValue' has a wrong offset!");
static_assert(offsetof(FHWNotifyNiagaraUserParameters, FloatValue) == 0x000008, "Member 'FHWNotifyNiagaraUserParameters::FloatValue' has a wrong offset!");
static_assert(offsetof(FHWNotifyNiagaraUserParameters, ColorValue) == 0x00000C, "Member 'FHWNotifyNiagaraUserParameters::ColorValue' has a wrong offset!");
static_assert(offsetof(FHWNotifyNiagaraUserParameters, Vector3Value) == 0x000020, "Member 'FHWNotifyNiagaraUserParameters::Vector3Value' has a wrong offset!");

// ScriptStruct Hemingway.FactoryReplicatedMapState
// 0x0008 (0x0014 - 0x000C)
struct FFactoryReplicatedMapState final : public FFastArraySerializerItem
{
public:
	int32                                         TeamNumber;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFactoryMinimapState                          FactoryState;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeesRespawnTimer;                                 // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutOfSyncUntilViewed;                             // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFactoryReplicatedMapState) == 0x000004, "Wrong alignment on FFactoryReplicatedMapState");
static_assert(sizeof(FFactoryReplicatedMapState) == 0x000014, "Wrong size on FFactoryReplicatedMapState");
static_assert(offsetof(FFactoryReplicatedMapState, TeamNumber) == 0x00000C, "Member 'FFactoryReplicatedMapState::TeamNumber' has a wrong offset!");
static_assert(offsetof(FFactoryReplicatedMapState, FactoryState) == 0x000010, "Member 'FFactoryReplicatedMapState::FactoryState' has a wrong offset!");
static_assert(offsetof(FFactoryReplicatedMapState, bSeesRespawnTimer) == 0x000011, "Member 'FFactoryReplicatedMapState::bSeesRespawnTimer' has a wrong offset!");
static_assert(offsetof(FFactoryReplicatedMapState, bOutOfSyncUntilViewed) == 0x000012, "Member 'FFactoryReplicatedMapState::bOutOfSyncUntilViewed' has a wrong offset!");

// ScriptStruct Hemingway.TeamFactoryMapStateList
// 0x0018 (0x0120 - 0x0108)
struct FTeamFactoryMapStateList final : public FFastArraySerializer
{
public:
	class UHWBotFactory_VisibilityComponent*      OwningComp;                                        // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFactoryReplicatedMapState>     TeamMapStates;                                     // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamFactoryMapStateList) == 0x000008, "Wrong alignment on FTeamFactoryMapStateList");
static_assert(sizeof(FTeamFactoryMapStateList) == 0x000120, "Wrong size on FTeamFactoryMapStateList");
static_assert(offsetof(FTeamFactoryMapStateList, OwningComp) == 0x000108, "Member 'FTeamFactoryMapStateList::OwningComp' has a wrong offset!");
static_assert(offsetof(FTeamFactoryMapStateList, TeamMapStates) == 0x000110, "Member 'FTeamFactoryMapStateList::TeamMapStates' has a wrong offset!");

// ScriptStruct Hemingway.HWFindCombatPositionEffector
// 0x0010 (0x0010 - 0x0000)
struct FHWFindCombatPositionEffector final
{
public:
	class UHWVectorFieldFollowCalc*               Calculation;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWFindCombatPositionEffector) == 0x000008, "Wrong alignment on FHWFindCombatPositionEffector");
static_assert(sizeof(FHWFindCombatPositionEffector) == 0x000010, "Wrong size on FHWFindCombatPositionEffector");
static_assert(offsetof(FHWFindCombatPositionEffector, Calculation) == 0x000000, "Member 'FHWFindCombatPositionEffector::Calculation' has a wrong offset!");
static_assert(offsetof(FHWFindCombatPositionEffector, Weight) == 0x000008, "Member 'FHWFindCombatPositionEffector::Weight' has a wrong offset!");

// ScriptStruct Hemingway.AbilityDataPull
// 0x0048 (0x0048 - 0x0000)
struct FAbilityDataPull final
{
public:
	bool                                          bSetDefaultBoardValue;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWInventorySlot                       AbilitySlot;                                       // 0x0004(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0010(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityDataType                              InfoType;                                          // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultValue;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityDataPull) == 0x000008, "Wrong alignment on FAbilityDataPull");
static_assert(sizeof(FAbilityDataPull) == 0x000048, "Wrong size on FAbilityDataPull");
static_assert(offsetof(FAbilityDataPull, bSetDefaultBoardValue) == 0x000000, "Member 'FAbilityDataPull::bSetDefaultBoardValue' has a wrong offset!");
static_assert(offsetof(FAbilityDataPull, AbilitySlot) == 0x000004, "Member 'FAbilityDataPull::AbilitySlot' has a wrong offset!");
static_assert(offsetof(FAbilityDataPull, BlackboardKey) == 0x000010, "Member 'FAbilityDataPull::BlackboardKey' has a wrong offset!");
static_assert(offsetof(FAbilityDataPull, Level) == 0x000038, "Member 'FAbilityDataPull::Level' has a wrong offset!");
static_assert(offsetof(FAbilityDataPull, InfoType) == 0x00003C, "Member 'FAbilityDataPull::InfoType' has a wrong offset!");
static_assert(offsetof(FAbilityDataPull, DefaultValue) == 0x000040, "Member 'FAbilityDataPull::DefaultValue' has a wrong offset!");

// ScriptStruct Hemingway.HWMulanRopeTetherInfo
// 0x0030 (0x0030 - 0x0000)
struct FHWMulanRopeTetherInfo final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  TetherTarget;                                      // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWallTether;                                     // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WallTetherLocation;                                // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileId;                                      // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWMulanRopeTetherInfo) == 0x000008, "Wrong alignment on FHWMulanRopeTetherInfo");
static_assert(sizeof(FHWMulanRopeTetherInfo) == 0x000030, "Wrong size on FHWMulanRopeTetherInfo");
static_assert(offsetof(FHWMulanRopeTetherInfo, bIsEnabled) == 0x000000, "Member 'FHWMulanRopeTetherInfo::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FHWMulanRopeTetherInfo, TetherTarget) == 0x000004, "Member 'FHWMulanRopeTetherInfo::TetherTarget' has a wrong offset!");
static_assert(offsetof(FHWMulanRopeTetherInfo, bIsWallTether) == 0x00000C, "Member 'FHWMulanRopeTetherInfo::bIsWallTether' has a wrong offset!");
static_assert(offsetof(FHWMulanRopeTetherInfo, WallTetherLocation) == 0x000010, "Member 'FHWMulanRopeTetherInfo::WallTetherLocation' has a wrong offset!");
static_assert(offsetof(FHWMulanRopeTetherInfo, ProjectileId) == 0x000028, "Member 'FHWMulanRopeTetherInfo::ProjectileId' has a wrong offset!");

// ScriptStruct Hemingway.HWChatFilterPlayerCache
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FHWChatFilterPlayerCache final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWChatFilterPlayerCache) == 0x000008, "Wrong alignment on FHWChatFilterPlayerCache");
static_assert(sizeof(FHWChatFilterPlayerCache) == 0x000018, "Wrong size on FHWChatFilterPlayerCache");

// ScriptStruct Hemingway.HWChatFilterHttpReponseCategory
// 0x0018 (0x0018 - 0x0000)
struct FHWChatFilterHttpReponseCategory final
{
public:
	class FString                                 Category;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Severity;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWChatFilterHttpReponseCategory) == 0x000008, "Wrong alignment on FHWChatFilterHttpReponseCategory");
static_assert(sizeof(FHWChatFilterHttpReponseCategory) == 0x000018, "Wrong size on FHWChatFilterHttpReponseCategory");
static_assert(offsetof(FHWChatFilterHttpReponseCategory, Category) == 0x000000, "Member 'FHWChatFilterHttpReponseCategory::Category' has a wrong offset!");
static_assert(offsetof(FHWChatFilterHttpReponseCategory, Severity) == 0x000010, "Member 'FHWChatFilterHttpReponseCategory::Severity' has a wrong offset!");

// ScriptStruct Hemingway.HWChatFilterHttpReponseBlocklist
// 0x0030 (0x0030 - 0x0000)
struct FHWChatFilterHttpReponseBlocklist final
{
public:
	class FString                                 BlocklistName;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BlocklistItemId;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BlocklistItemText;                                 // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWChatFilterHttpReponseBlocklist) == 0x000008, "Wrong alignment on FHWChatFilterHttpReponseBlocklist");
static_assert(sizeof(FHWChatFilterHttpReponseBlocklist) == 0x000030, "Wrong size on FHWChatFilterHttpReponseBlocklist");
static_assert(offsetof(FHWChatFilterHttpReponseBlocklist, BlocklistName) == 0x000000, "Member 'FHWChatFilterHttpReponseBlocklist::BlocklistName' has a wrong offset!");
static_assert(offsetof(FHWChatFilterHttpReponseBlocklist, BlocklistItemId) == 0x000010, "Member 'FHWChatFilterHttpReponseBlocklist::BlocklistItemId' has a wrong offset!");
static_assert(offsetof(FHWChatFilterHttpReponseBlocklist, BlocklistItemText) == 0x000020, "Member 'FHWChatFilterHttpReponseBlocklist::BlocklistItemText' has a wrong offset!");

// ScriptStruct Hemingway.HWChatFilterHttpResponse
// 0x0020 (0x0020 - 0x0000)
struct FHWChatFilterHttpResponse final
{
public:
	TArray<struct FHWChatFilterHttpReponseBlocklist> BlocklistsMatch;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWChatFilterHttpReponseCategory> CategoriesAnalysis;                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWChatFilterHttpResponse) == 0x000008, "Wrong alignment on FHWChatFilterHttpResponse");
static_assert(sizeof(FHWChatFilterHttpResponse) == 0x000020, "Wrong size on FHWChatFilterHttpResponse");
static_assert(offsetof(FHWChatFilterHttpResponse, BlocklistsMatch) == 0x000000, "Member 'FHWChatFilterHttpResponse::BlocklistsMatch' has a wrong offset!");
static_assert(offsetof(FHWChatFilterHttpResponse, CategoriesAnalysis) == 0x000010, "Member 'FHWChatFilterHttpResponse::CategoriesAnalysis' has a wrong offset!");

// ScriptStruct Hemingway.HWChatActionTimestamp
// 0x0010 (0x0010 - 0x0000)
struct FHWChatActionTimestamp final
{
public:
	TArray<float>                                 ActionTimestamps;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWChatActionTimestamp) == 0x000008, "Wrong alignment on FHWChatActionTimestamp");
static_assert(sizeof(FHWChatActionTimestamp) == 0x000010, "Wrong size on FHWChatActionTimestamp");
static_assert(offsetof(FHWChatActionTimestamp, ActionTimestamps) == 0x000000, "Member 'FHWChatActionTimestamp::ActionTimestamps' has a wrong offset!");

// ScriptStruct Hemingway.HWSystemMessageRow
// 0x0058 (0x0060 - 0x0008)
struct FHWSystemMessageRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           MessageTag;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWSystemMessageConfig                 Config;                                            // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSystemMessageRow) == 0x000008, "Wrong alignment on FHWSystemMessageRow");
static_assert(sizeof(FHWSystemMessageRow) == 0x000060, "Wrong size on FHWSystemMessageRow");
static_assert(offsetof(FHWSystemMessageRow, MessageTag) == 0x000008, "Member 'FHWSystemMessageRow::MessageTag' has a wrong offset!");
static_assert(offsetof(FHWSystemMessageRow, Config) == 0x000010, "Member 'FHWSystemMessageRow::Config' has a wrong offset!");

// ScriptStruct Hemingway.HWAttributeModifierData
// 0x000C (0x000C - 0x0000)
struct FHWAttributeModifierData final
{
public:
	float                                         PreMultiplierAdditiveDelta;                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoefficientMultiplier;                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostMultiplierAdditiveDelta;                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAttributeModifierData) == 0x000004, "Wrong alignment on FHWAttributeModifierData");
static_assert(sizeof(FHWAttributeModifierData) == 0x00000C, "Wrong size on FHWAttributeModifierData");
static_assert(offsetof(FHWAttributeModifierData, PreMultiplierAdditiveDelta) == 0x000000, "Member 'FHWAttributeModifierData::PreMultiplierAdditiveDelta' has a wrong offset!");
static_assert(offsetof(FHWAttributeModifierData, CoefficientMultiplier) == 0x000004, "Member 'FHWAttributeModifierData::CoefficientMultiplier' has a wrong offset!");
static_assert(offsetof(FHWAttributeModifierData, PostMultiplierAdditiveDelta) == 0x000008, "Member 'FHWAttributeModifierData::PostMultiplierAdditiveDelta' has a wrong offset!");

// ScriptStruct Hemingway.HWAdjustAttributeEventEntry
// 0x0050 (0x0050 - 0x0000)
struct FHWAdjustAttributeEventEntry final
{
public:
	TMap<EHWAttributeModifierEnum, struct FHWAttributeModifierData> ModifierMap;                     // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAdjustAttributeEventEntry) == 0x000008, "Wrong alignment on FHWAdjustAttributeEventEntry");
static_assert(sizeof(FHWAdjustAttributeEventEntry) == 0x000050, "Wrong size on FHWAdjustAttributeEventEntry");
static_assert(offsetof(FHWAdjustAttributeEventEntry, ModifierMap) == 0x000000, "Member 'FHWAdjustAttributeEventEntry::ModifierMap' has a wrong offset!");

// ScriptStruct Hemingway.HWCombatLog_MessageEntry
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FHWCombatLog_MessageEntry final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCombatLog_MessageEntry) == 0x000008, "Wrong alignment on FHWCombatLog_MessageEntry");
static_assert(sizeof(FHWCombatLog_MessageEntry) == 0x000028, "Wrong size on FHWCombatLog_MessageEntry");

// ScriptStruct Hemingway.HWCombatLog_Entry
// 0x0040 (0x0040 - 0x0000)
struct FHWCombatLog_Entry
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              UtcTime;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EntryTypeName;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   LocalizedMsg;                                      // 0x0020(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         GameTime;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MsgId;                                             // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHWCombatLog_Entry) == 0x000008, "Wrong alignment on FHWCombatLog_Entry");
static_assert(sizeof(FHWCombatLog_Entry) == 0x000040, "Wrong size on FHWCombatLog_Entry");
static_assert(offsetof(FHWCombatLog_Entry, UtcTime) == 0x000008, "Member 'FHWCombatLog_Entry::UtcTime' has a wrong offset!");
static_assert(offsetof(FHWCombatLog_Entry, EntryTypeName) == 0x000010, "Member 'FHWCombatLog_Entry::EntryTypeName' has a wrong offset!");
static_assert(offsetof(FHWCombatLog_Entry, LocalizedMsg) == 0x000020, "Member 'FHWCombatLog_Entry::LocalizedMsg' has a wrong offset!");
static_assert(offsetof(FHWCombatLog_Entry, GameTime) == 0x000038, "Member 'FHWCombatLog_Entry::GameTime' has a wrong offset!");
static_assert(offsetof(FHWCombatLog_Entry, MsgId) == 0x00003C, "Member 'FHWCombatLog_Entry::MsgId' has a wrong offset!");

// ScriptStruct Hemingway.HWCombatLog_StartInfo
// 0x0010 (0x0050 - 0x0040)
struct FHWCombatLog_StartInfo final : public FHWCombatLog_Entry
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCombatLog_StartInfo) == 0x000008, "Wrong alignment on FHWCombatLog_StartInfo");
static_assert(sizeof(FHWCombatLog_StartInfo) == 0x000050, "Wrong size on FHWCombatLog_StartInfo");

// ScriptStruct Hemingway.HWCombatLog_CombatEventInfo
// 0x00B0 (0x00F0 - 0x0040)
struct FHWCombatLog_CombatEventInfo final : public FHWCombatLog_Entry
{
public:
	uint8                                         Pad_40[0xB0];                                      // 0x0040(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCombatLog_CombatEventInfo) == 0x000008, "Wrong alignment on FHWCombatLog_CombatEventInfo");
static_assert(sizeof(FHWCombatLog_CombatEventInfo) == 0x0000F0, "Wrong size on FHWCombatLog_CombatEventInfo");

// ScriptStruct Hemingway.HWCombatLog_ItemEventInfo
// 0x0058 (0x0098 - 0x0040)
struct FHWCombatLog_ItemEventInfo final : public FHWCombatLog_Entry
{
public:
	uint8                                         Pad_40[0x58];                                      // 0x0040(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCombatLog_ItemEventInfo) == 0x000008, "Wrong alignment on FHWCombatLog_ItemEventInfo");
static_assert(sizeof(FHWCombatLog_ItemEventInfo) == 0x000098, "Wrong size on FHWCombatLog_ItemEventInfo");

// ScriptStruct Hemingway.HWCombatLog_PlayerEventInfo
// 0x0050 (0x0090 - 0x0040)
struct FHWCombatLog_PlayerEventInfo final : public FHWCombatLog_Entry
{
public:
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCombatLog_PlayerEventInfo) == 0x000008, "Wrong alignment on FHWCombatLog_PlayerEventInfo");
static_assert(sizeof(FHWCombatLog_PlayerEventInfo) == 0x000090, "Wrong size on FHWCombatLog_PlayerEventInfo");

// ScriptStruct Hemingway.HWCombatLog_RewardEventInfo
// 0x00A0 (0x00E0 - 0x0040)
struct FHWCombatLog_RewardEventInfo final : public FHWCombatLog_Entry
{
public:
	uint8                                         Pad_40[0xA0];                                      // 0x0040(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCombatLog_RewardEventInfo) == 0x000008, "Wrong alignment on FHWCombatLog_RewardEventInfo");
static_assert(sizeof(FHWCombatLog_RewardEventInfo) == 0x0000E0, "Wrong size on FHWCombatLog_RewardEventInfo");

// ScriptStruct Hemingway.CritProbabilityPair
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FCritProbabilityPair final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCritProbabilityPair) == 0x000004, "Wrong alignment on FCritProbabilityPair");
static_assert(sizeof(FCritProbabilityPair) == 0x000008, "Wrong size on FCritProbabilityPair");

// ScriptStruct Hemingway.HWDraftPlayerIdInternal
// 0x0028 (0x0030 - 0x0008)
struct FHWDraftPlayerIdInternal final : public FDraftPlayerIdInternal
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0008(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOnlyASpectator;                                 // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWDraftPlayerIdInternal) == 0x000008, "Wrong alignment on FHWDraftPlayerIdInternal");
static_assert(sizeof(FHWDraftPlayerIdInternal) == 0x000030, "Wrong size on FHWDraftPlayerIdInternal");
static_assert(offsetof(FHWDraftPlayerIdInternal, PlayerId) == 0x000008, "Member 'FHWDraftPlayerIdInternal::PlayerId' has a wrong offset!");
static_assert(offsetof(FHWDraftPlayerIdInternal, bIsOnlyASpectator) == 0x000028, "Member 'FHWDraftPlayerIdInternal::bIsOnlyASpectator' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilitySwapPhase
// 0x0018 (0x0018 - 0x0000)
struct FHWAbilitySwapPhase final
{
public:
	class UHWEquipmentItem*                       SwapEquipmentItem;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwapAbilityDelay;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwapAbilityWindowDuration;                         // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwapAbilityAdditionalCooldownCost;                 // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAbilitySwapPhase) == 0x000008, "Wrong alignment on FHWAbilitySwapPhase");
static_assert(sizeof(FHWAbilitySwapPhase) == 0x000018, "Wrong size on FHWAbilitySwapPhase");
static_assert(offsetof(FHWAbilitySwapPhase, SwapEquipmentItem) == 0x000000, "Member 'FHWAbilitySwapPhase::SwapEquipmentItem' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapPhase, SwapAbilityDelay) == 0x000008, "Member 'FHWAbilitySwapPhase::SwapAbilityDelay' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapPhase, SwapAbilityWindowDuration) == 0x00000C, "Member 'FHWAbilitySwapPhase::SwapAbilityWindowDuration' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapPhase, SwapAbilityAdditionalCooldownCost) == 0x000010, "Member 'FHWAbilitySwapPhase::SwapAbilityAdditionalCooldownCost' has a wrong offset!");

// ScriptStruct Hemingway.HWEventConfig
// 0x0048 (0x0048 - 0x0000)
struct FHWEventConfig final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExcludedGameModeTags;                              // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeInQueue;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstInQueueDelayTime;                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWEventStompAssessorBase>  StompAssessorClass;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWEventHandlerBase>        EventHandlerClass;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEventConfig) == 0x000008, "Wrong alignment on FHWEventConfig");
static_assert(sizeof(FHWEventConfig) == 0x000048, "Wrong size on FHWEventConfig");
static_assert(offsetof(FHWEventConfig, EventTag) == 0x000000, "Member 'FHWEventConfig::EventTag' has a wrong offset!");
static_assert(offsetof(FHWEventConfig, ExcludedGameModeTags) == 0x000008, "Member 'FHWEventConfig::ExcludedGameModeTags' has a wrong offset!");
static_assert(offsetof(FHWEventConfig, Priority) == 0x000028, "Member 'FHWEventConfig::Priority' has a wrong offset!");
static_assert(offsetof(FHWEventConfig, MaxTimeInQueue) == 0x00002C, "Member 'FHWEventConfig::MaxTimeInQueue' has a wrong offset!");
static_assert(offsetof(FHWEventConfig, Duration) == 0x000030, "Member 'FHWEventConfig::Duration' has a wrong offset!");
static_assert(offsetof(FHWEventConfig, FirstInQueueDelayTime) == 0x000034, "Member 'FHWEventConfig::FirstInQueueDelayTime' has a wrong offset!");
static_assert(offsetof(FHWEventConfig, StompAssessorClass) == 0x000038, "Member 'FHWEventConfig::StompAssessorClass' has a wrong offset!");
static_assert(offsetof(FHWEventConfig, EventHandlerClass) == 0x000040, "Member 'FHWEventConfig::EventHandlerClass' has a wrong offset!");

// ScriptStruct Hemingway.HWDelayedEquipmentSwap
// 0x0028 (0x0028 - 0x0000)
struct FHWDelayedEquipmentSwap final
{
public:
	class UHWGameplayAbility_Enhanced*            AbilityInstanceDelayingSwap;                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       DelayedSwapInventorySlot1;                         // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       DelayedSwapInventorySlot2;                         // 0x0014(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhasesDelayingFor;                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWDelayedEquipmentSwap) == 0x000008, "Wrong alignment on FHWDelayedEquipmentSwap");
static_assert(sizeof(FHWDelayedEquipmentSwap) == 0x000028, "Wrong size on FHWDelayedEquipmentSwap");
static_assert(offsetof(FHWDelayedEquipmentSwap, AbilityInstanceDelayingSwap) == 0x000000, "Member 'FHWDelayedEquipmentSwap::AbilityInstanceDelayingSwap' has a wrong offset!");
static_assert(offsetof(FHWDelayedEquipmentSwap, DelayedSwapInventorySlot1) == 0x000008, "Member 'FHWDelayedEquipmentSwap::DelayedSwapInventorySlot1' has a wrong offset!");
static_assert(offsetof(FHWDelayedEquipmentSwap, DelayedSwapInventorySlot2) == 0x000014, "Member 'FHWDelayedEquipmentSwap::DelayedSwapInventorySlot2' has a wrong offset!");
static_assert(offsetof(FHWDelayedEquipmentSwap, PhasesDelayingFor) == 0x000020, "Member 'FHWDelayedEquipmentSwap::PhasesDelayingFor' has a wrong offset!");

// ScriptStruct Hemingway.HWEventConfigRow
// 0x0048 (0x0050 - 0x0008)
struct FHWEventConfigRow final : public FTableRowBase
{
public:
	struct FHWEventConfig                         EventConfig;                                       // 0x0008(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEventConfigRow) == 0x000008, "Wrong alignment on FHWEventConfigRow");
static_assert(sizeof(FHWEventConfigRow) == 0x000050, "Wrong size on FHWEventConfigRow");
static_assert(offsetof(FHWEventConfigRow, EventConfig) == 0x000008, "Member 'FHWEventConfigRow::EventConfig' has a wrong offset!");

// ScriptStruct Hemingway.HWEventBucketConfig
// 0x0038 (0x0038 - 0x0000)
struct FHWEventBucketConfig final
{
public:
	struct FGameplayTag                           BucketTag;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStompable;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              EventConfigDTSoftPtr;                              // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEventBucketConfig) == 0x000008, "Wrong alignment on FHWEventBucketConfig");
static_assert(sizeof(FHWEventBucketConfig) == 0x000038, "Wrong size on FHWEventBucketConfig");
static_assert(offsetof(FHWEventBucketConfig, BucketTag) == 0x000000, "Member 'FHWEventBucketConfig::BucketTag' has a wrong offset!");
static_assert(offsetof(FHWEventBucketConfig, Priority) == 0x000008, "Member 'FHWEventBucketConfig::Priority' has a wrong offset!");
static_assert(offsetof(FHWEventBucketConfig, bStompable) == 0x00000C, "Member 'FHWEventBucketConfig::bStompable' has a wrong offset!");
static_assert(offsetof(FHWEventBucketConfig, EventConfigDTSoftPtr) == 0x000010, "Member 'FHWEventBucketConfig::EventConfigDTSoftPtr' has a wrong offset!");

// ScriptStruct Hemingway.HWSkinnedMaterialInfo
// 0x0008 (0x0008 - 0x0000)
struct FHWSkinnedMaterialInfo final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkinnedMaterialInfo) == 0x000008, "Wrong alignment on FHWSkinnedMaterialInfo");
static_assert(sizeof(FHWSkinnedMaterialInfo) == 0x000008, "Wrong size on FHWSkinnedMaterialInfo");
static_assert(offsetof(FHWSkinnedMaterialInfo, Material) == 0x000000, "Member 'FHWSkinnedMaterialInfo::Material' has a wrong offset!");

// ScriptStruct Hemingway.HWEventBucketConfigRow
// 0x0038 (0x0040 - 0x0008)
struct FHWEventBucketConfigRow final : public FTableRowBase
{
public:
	struct FHWEventBucketConfig                   EventBucketConfig;                                 // 0x0008(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEventBucketConfigRow) == 0x000008, "Wrong alignment on FHWEventBucketConfigRow");
static_assert(sizeof(FHWEventBucketConfigRow) == 0x000040, "Wrong size on FHWEventBucketConfigRow");
static_assert(offsetof(FHWEventBucketConfigRow, EventBucketConfig) == 0x000008, "Member 'FHWEventBucketConfigRow::EventBucketConfig' has a wrong offset!");

// ScriptStruct Hemingway.PendingTradeRequest
// 0x0020 (0x0020 - 0x0000)
struct FPendingTradeRequest final
{
public:
	class AHWPlayerState*                         RequestingPlayer;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         TargetPlayer;                                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWTradeRequestType                           TradeType;                                         // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPendingTradeRequest) == 0x000008, "Wrong alignment on FPendingTradeRequest");
static_assert(sizeof(FPendingTradeRequest) == 0x000020, "Wrong size on FPendingTradeRequest");
static_assert(offsetof(FPendingTradeRequest, RequestingPlayer) == 0x000000, "Member 'FPendingTradeRequest::RequestingPlayer' has a wrong offset!");
static_assert(offsetof(FPendingTradeRequest, TargetPlayer) == 0x000008, "Member 'FPendingTradeRequest::TargetPlayer' has a wrong offset!");
static_assert(offsetof(FPendingTradeRequest, TradeType) == 0x000010, "Member 'FPendingTradeRequest::TradeType' has a wrong offset!");

// ScriptStruct Hemingway.HWSplineActiveState
// 0x0038 (0x0038 - 0x0000)
struct FHWSplineActiveState final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StartRotation;                                     // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWSplineActiveState) == 0x000008, "Wrong alignment on FHWSplineActiveState");
static_assert(sizeof(FHWSplineActiveState) == 0x000038, "Wrong size on FHWSplineActiveState");
static_assert(offsetof(FHWSplineActiveState, StartLocation) == 0x000000, "Member 'FHWSplineActiveState::StartLocation' has a wrong offset!");
static_assert(offsetof(FHWSplineActiveState, StartRotation) == 0x000018, "Member 'FHWSplineActiveState::StartRotation' has a wrong offset!");
static_assert(offsetof(FHWSplineActiveState, bActive) == 0x000030, "Member 'FHWSplineActiveState::bActive' has a wrong offset!");

// ScriptStruct Hemingway.HWReplicatedTeamBoosters
// 0x0020 (0x0020 - 0x0000)
struct FHWReplicatedTeamBoosters final
{
public:
	TArray<struct FGuid>                          Keys;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTagContainer>          Values;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWReplicatedTeamBoosters) == 0x000008, "Wrong alignment on FHWReplicatedTeamBoosters");
static_assert(sizeof(FHWReplicatedTeamBoosters) == 0x000020, "Wrong size on FHWReplicatedTeamBoosters");
static_assert(offsetof(FHWReplicatedTeamBoosters, Keys) == 0x000000, "Member 'FHWReplicatedTeamBoosters::Keys' has a wrong offset!");
static_assert(offsetof(FHWReplicatedTeamBoosters, Values) == 0x000010, "Member 'FHWReplicatedTeamBoosters::Values' has a wrong offset!");

// ScriptStruct Hemingway.HWReplicatedAppliedTeamBoosters
// 0x0020 (0x0020 - 0x0000)
struct FHWReplicatedAppliedTeamBoosters final
{
public:
	TArray<struct FGenericTeamId>                 Keys;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWReplicatedTeamBoosters>      Values;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWReplicatedAppliedTeamBoosters) == 0x000008, "Wrong alignment on FHWReplicatedAppliedTeamBoosters");
static_assert(sizeof(FHWReplicatedAppliedTeamBoosters) == 0x000020, "Wrong size on FHWReplicatedAppliedTeamBoosters");
static_assert(offsetof(FHWReplicatedAppliedTeamBoosters, Keys) == 0x000000, "Member 'FHWReplicatedAppliedTeamBoosters::Keys' has a wrong offset!");
static_assert(offsetof(FHWReplicatedAppliedTeamBoosters, Values) == 0x000010, "Member 'FHWReplicatedAppliedTeamBoosters::Values' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentLevelingRecord
// 0x0030 (0x0030 - 0x0000)
struct FHWEquipmentLevelingRecord final
{
public:
	TSoftObjectPtr<class UHWEquipmentItem>        Equipment;                                         // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWEquipmentLevelingRecord) == 0x000008, "Wrong alignment on FHWEquipmentLevelingRecord");
static_assert(sizeof(FHWEquipmentLevelingRecord) == 0x000030, "Wrong size on FHWEquipmentLevelingRecord");
static_assert(offsetof(FHWEquipmentLevelingRecord, Equipment) == 0x000000, "Member 'FHWEquipmentLevelingRecord::Equipment' has a wrong offset!");
static_assert(offsetof(FHWEquipmentLevelingRecord, Level) == 0x000028, "Member 'FHWEquipmentLevelingRecord::Level' has a wrong offset!");

// ScriptStruct Hemingway.HWTeamGrantedSkins
// 0x0010 (0x0018 - 0x0008)
struct FHWTeamGrantedSkins final : public FTableRowBase
{
public:
	TArray<class UHWSkinItem*>                    GrantedSkins;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWTeamGrantedSkins) == 0x000008, "Wrong alignment on FHWTeamGrantedSkins");
static_assert(sizeof(FHWTeamGrantedSkins) == 0x000018, "Wrong size on FHWTeamGrantedSkins");
static_assert(offsetof(FHWTeamGrantedSkins, GrantedSkins) == 0x000008, "Member 'FHWTeamGrantedSkins::GrantedSkins' has a wrong offset!");

// ScriptStruct Hemingway.HWReplicatedGrantedSkins
// 0x0020 (0x0020 - 0x0000)
struct FHWReplicatedGrantedSkins final
{
public:
	TArray<struct FGenericTeamId>                 Keys;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWTeamGrantedSkins>            Values;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWReplicatedGrantedSkins) == 0x000008, "Wrong alignment on FHWReplicatedGrantedSkins");
static_assert(sizeof(FHWReplicatedGrantedSkins) == 0x000020, "Wrong size on FHWReplicatedGrantedSkins");
static_assert(offsetof(FHWReplicatedGrantedSkins, Keys) == 0x000000, "Member 'FHWReplicatedGrantedSkins::Keys' has a wrong offset!");
static_assert(offsetof(FHWReplicatedGrantedSkins, Values) == 0x000010, "Member 'FHWReplicatedGrantedSkins::Values' has a wrong offset!");

// ScriptStruct Hemingway.HWSkinnedNiagaraInfo
// 0x0010 (0x0010 - 0x0000)
struct FHWSkinnedNiagaraInfo final
{
public:
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketOverride;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkinnedNiagaraInfo) == 0x000008, "Wrong alignment on FHWSkinnedNiagaraInfo");
static_assert(sizeof(FHWSkinnedNiagaraInfo) == 0x000010, "Wrong size on FHWSkinnedNiagaraInfo");
static_assert(offsetof(FHWSkinnedNiagaraInfo, NiagaraSystem) == 0x000000, "Member 'FHWSkinnedNiagaraInfo::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(FHWSkinnedNiagaraInfo, SocketOverride) == 0x000008, "Member 'FHWSkinnedNiagaraInfo::SocketOverride' has a wrong offset!");

// ScriptStruct Hemingway.HWGenericCollectionMappedData
// 0x0008 (0x0008 - 0x0000)
struct FHWGenericCollectionMappedData final
{
public:
	struct FGameplayTag                           MappedCharacterTag;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWGenericCollectionMappedData) == 0x000004, "Wrong alignment on FHWGenericCollectionMappedData");
static_assert(sizeof(FHWGenericCollectionMappedData) == 0x000008, "Wrong size on FHWGenericCollectionMappedData");
static_assert(offsetof(FHWGenericCollectionMappedData, MappedCharacterTag) == 0x000000, "Member 'FHWGenericCollectionMappedData::MappedCharacterTag' has a wrong offset!");

// ScriptStruct Hemingway.HWGenericCollectionRow
// 0x0078 (0x0080 - 0x0008)
struct FHWGenericCollectionRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UHWCollectionItem>       GenericCollectionItem;                             // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FRH_ItemId, struct FHWGenericCollectionMappedData> GenericMappedData;                // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWGenericCollectionRow) == 0x000008, "Wrong alignment on FHWGenericCollectionRow");
static_assert(sizeof(FHWGenericCollectionRow) == 0x000080, "Wrong size on FHWGenericCollectionRow");
static_assert(offsetof(FHWGenericCollectionRow, GenericCollectionItem) == 0x000008, "Member 'FHWGenericCollectionRow::GenericCollectionItem' has a wrong offset!");
static_assert(offsetof(FHWGenericCollectionRow, GenericMappedData) == 0x000030, "Member 'FHWGenericCollectionRow::GenericMappedData' has a wrong offset!");

// ScriptStruct Hemingway.HWApparelInstFinder
// 0x0008 (0x0008 - 0x0000)
struct FHWApparelInstFinder final
{
public:
	class UHWApparelItem*                         ApparelAsset;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHWApparelInstFinder) == 0x000008, "Wrong alignment on FHWApparelInstFinder");
static_assert(sizeof(FHWApparelInstFinder) == 0x000008, "Wrong size on FHWApparelInstFinder");
static_assert(offsetof(FHWApparelInstFinder, ApparelAsset) == 0x000000, "Member 'FHWApparelInstFinder::ApparelAsset' has a wrong offset!");

// ScriptStruct Hemingway.HWCharacter_GenericCollectionItems
// 0x0040 (0x0048 - 0x0008)
struct FHWCharacter_GenericCollectionItems final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UHWCollectionItem>       GenericCollectionItem;                             // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             OverrideId;                                        // 0x0030(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCharacter_GenericCollectionItems) == 0x000008, "Wrong alignment on FHWCharacter_GenericCollectionItems");
static_assert(sizeof(FHWCharacter_GenericCollectionItems) == 0x000048, "Wrong size on FHWCharacter_GenericCollectionItems");
static_assert(offsetof(FHWCharacter_GenericCollectionItems, GenericCollectionItem) == 0x000008, "Member 'FHWCharacter_GenericCollectionItems::GenericCollectionItem' has a wrong offset!");
static_assert(offsetof(FHWCharacter_GenericCollectionItems, OverrideId) == 0x000030, "Member 'FHWCharacter_GenericCollectionItems::OverrideId' has a wrong offset!");

// ScriptStruct Hemingway.HWGetGudReport
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FHWGetGudReport final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWGetGudReport) == 0x000004, "Wrong alignment on FHWGetGudReport");
static_assert(sizeof(FHWGetGudReport) == 0x000024, "Wrong size on FHWGetGudReport");

// ScriptStruct Hemingway.HWDataAssetInfo
// 0x0008 (0x0008 - 0x0000)
struct FHWDataAssetInfo final
{
public:
	class UDataAsset*                             DataAsset;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWDataAssetInfo) == 0x000008, "Wrong alignment on FHWDataAssetInfo");
static_assert(sizeof(FHWDataAssetInfo) == 0x000008, "Wrong size on FHWDataAssetInfo");
static_assert(offsetof(FHWDataAssetInfo, DataAsset) == 0x000000, "Member 'FHWDataAssetInfo::DataAsset' has a wrong offset!");

// ScriptStruct Hemingway.HWRecyclePool_AIControllers
// 0x0010 (0x0010 - 0x0000)
struct FHWRecyclePool_AIControllers final
{
public:
	TArray<class AHWAIController*>                AIControllers;                                     // 0x0000(0x0010)(ZeroConstructor, Transient, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWRecyclePool_AIControllers) == 0x000008, "Wrong alignment on FHWRecyclePool_AIControllers");
static_assert(sizeof(FHWRecyclePool_AIControllers) == 0x000010, "Wrong size on FHWRecyclePool_AIControllers");
static_assert(offsetof(FHWRecyclePool_AIControllers, AIControllers) == 0x000000, "Member 'FHWRecyclePool_AIControllers::AIControllers' has a wrong offset!");

// ScriptStruct Hemingway.HWRecyclePool_CharacterAbilitySystemActors
// 0x0010 (0x0010 - 0x0000)
struct FHWRecyclePool_CharacterAbilitySystemActors final
{
public:
	TArray<TWeakObjectPtr<class AHWCharacterAbilitySystemActor>> CharacterAbilitySystemActors;       // 0x0000(0x0010)(ZeroConstructor, Transient, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWRecyclePool_CharacterAbilitySystemActors) == 0x000008, "Wrong alignment on FHWRecyclePool_CharacterAbilitySystemActors");
static_assert(sizeof(FHWRecyclePool_CharacterAbilitySystemActors) == 0x000010, "Wrong size on FHWRecyclePool_CharacterAbilitySystemActors");
static_assert(offsetof(FHWRecyclePool_CharacterAbilitySystemActors, CharacterAbilitySystemActors) == 0x000000, "Member 'FHWRecyclePool_CharacterAbilitySystemActors::CharacterAbilitySystemActors' has a wrong offset!");

// ScriptStruct Hemingway.HWSkinnedSkeletalMeshInfo
// 0x0018 (0x0018 - 0x0000)
struct FHWSkinnedSkeletalMeshInfo final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          PhysicAsset;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimInstanceClass;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkinnedSkeletalMeshInfo) == 0x000008, "Wrong alignment on FHWSkinnedSkeletalMeshInfo");
static_assert(sizeof(FHWSkinnedSkeletalMeshInfo) == 0x000018, "Wrong size on FHWSkinnedSkeletalMeshInfo");
static_assert(offsetof(FHWSkinnedSkeletalMeshInfo, Mesh) == 0x000000, "Member 'FHWSkinnedSkeletalMeshInfo::Mesh' has a wrong offset!");
static_assert(offsetof(FHWSkinnedSkeletalMeshInfo, PhysicAsset) == 0x000008, "Member 'FHWSkinnedSkeletalMeshInfo::PhysicAsset' has a wrong offset!");
static_assert(offsetof(FHWSkinnedSkeletalMeshInfo, AnimInstanceClass) == 0x000010, "Member 'FHWSkinnedSkeletalMeshInfo::AnimInstanceClass' has a wrong offset!");

// ScriptStruct Hemingway.HWRecycledPool
// 0x0168 (0x0168 - 0x0000)
struct FHWRecycledPool final
{
public:
	bool                                          bIncreasePoolSizeAsNeeded;                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class AHWAIController>, int32> MaxControllerRecyclePoolSizeConfig;              // 0x0008(0x0050)(Edit, RepSkip, NativeAccessSpecifierPublic)
	TArray<class AHWAIController*>                Controllers;                                       // 0x0058(0x0010)(ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class AHWAIController>, struct FHWRecyclePool_AIControllers> ControllersMap;    // 0x0068(0x0050)(Transient, RepSkip, NativeAccessSpecifierPublic)
	TMap<class UHWCharacterItem*, int32>          MaxAbilitySystemActorRecyclePoolSizeConfig;        // 0x00B8(0x0050)(Edit, RepSkip, NativeAccessSpecifierPublic)
	TArray<class AHWCharacterAbilitySystemActor*> AbilitySystemActorsPool;                           // 0x0108(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TWeakObjectPtr<class UHWCharacterItem>, struct FHWRecyclePool_CharacterAbilitySystemActors> AbilitySystemActorMap; // 0x0118(0x0050)(Transient, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWRecycledPool) == 0x000008, "Wrong alignment on FHWRecycledPool");
static_assert(sizeof(FHWRecycledPool) == 0x000168, "Wrong size on FHWRecycledPool");
static_assert(offsetof(FHWRecycledPool, bIncreasePoolSizeAsNeeded) == 0x000000, "Member 'FHWRecycledPool::bIncreasePoolSizeAsNeeded' has a wrong offset!");
static_assert(offsetof(FHWRecycledPool, MaxControllerRecyclePoolSizeConfig) == 0x000008, "Member 'FHWRecycledPool::MaxControllerRecyclePoolSizeConfig' has a wrong offset!");
static_assert(offsetof(FHWRecycledPool, Controllers) == 0x000058, "Member 'FHWRecycledPool::Controllers' has a wrong offset!");
static_assert(offsetof(FHWRecycledPool, ControllersMap) == 0x000068, "Member 'FHWRecycledPool::ControllersMap' has a wrong offset!");
static_assert(offsetof(FHWRecycledPool, MaxAbilitySystemActorRecyclePoolSizeConfig) == 0x0000B8, "Member 'FHWRecycledPool::MaxAbilitySystemActorRecyclePoolSizeConfig' has a wrong offset!");
static_assert(offsetof(FHWRecycledPool, AbilitySystemActorsPool) == 0x000108, "Member 'FHWRecycledPool::AbilitySystemActorsPool' has a wrong offset!");
static_assert(offsetof(FHWRecycledPool, AbilitySystemActorMap) == 0x000118, "Member 'FHWRecycledPool::AbilitySystemActorMap' has a wrong offset!");

// ScriptStruct Hemingway.HWLeaderboardDataConfig
// 0x0088 (0x0088 - 0x0000)
struct FHWLeaderboardDataConfig final
{
public:
	TSoftObjectPtr<class UHWRankedConfig>         RankedConfigRef;                                   // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TabIcon;                                           // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LeaderboardName;                                   // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   StatHeaderName;                                    // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bShouldShowDivision;                               // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHaveTies;                                   // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWLeaderboardDataConfig) == 0x000008, "Wrong alignment on FHWLeaderboardDataConfig");
static_assert(sizeof(FHWLeaderboardDataConfig) == 0x000088, "Wrong size on FHWLeaderboardDataConfig");
static_assert(offsetof(FHWLeaderboardDataConfig, RankedConfigRef) == 0x000000, "Member 'FHWLeaderboardDataConfig::RankedConfigRef' has a wrong offset!");
static_assert(offsetof(FHWLeaderboardDataConfig, TabIcon) == 0x000028, "Member 'FHWLeaderboardDataConfig::TabIcon' has a wrong offset!");
static_assert(offsetof(FHWLeaderboardDataConfig, LeaderboardName) == 0x000050, "Member 'FHWLeaderboardDataConfig::LeaderboardName' has a wrong offset!");
static_assert(offsetof(FHWLeaderboardDataConfig, StatHeaderName) == 0x000068, "Member 'FHWLeaderboardDataConfig::StatHeaderName' has a wrong offset!");
static_assert(offsetof(FHWLeaderboardDataConfig, bShouldShowDivision) == 0x000080, "Member 'FHWLeaderboardDataConfig::bShouldShowDivision' has a wrong offset!");
static_assert(offsetof(FHWLeaderboardDataConfig, bShouldHaveTies) == 0x000081, "Member 'FHWLeaderboardDataConfig::bShouldHaveTies' has a wrong offset!");

// ScriptStruct Hemingway.HWAccoladeRecord
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FHWAccoladeRecord final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAccoladeRecord) == 0x000008, "Wrong alignment on FHWAccoladeRecord");
static_assert(sizeof(FHWAccoladeRecord) == 0x000010, "Wrong size on FHWAccoladeRecord");

// ScriptStruct Hemingway.HWTimeValueArray
// 0x0010 (0x0010 - 0x0000)
struct FHWTimeValueArray final
{
public:
	TArray<struct FVector2D>                      DataPoints;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWTimeValueArray) == 0x000008, "Wrong alignment on FHWTimeValueArray");
static_assert(sizeof(FHWTimeValueArray) == 0x000010, "Wrong size on FHWTimeValueArray");
static_assert(offsetof(FHWTimeValueArray, DataPoints) == 0x000000, "Member 'FHWTimeValueArray::DataPoints' has a wrong offset!");

// ScriptStruct Hemingway.HWCombatLogEvent
// 0x0060 (0x0060 - 0x0000)
struct FHWCombatLogEvent final
{
public:
	class FString                                 EventType;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SourcePlayer;                                      // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetPlayer;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemName;                                          // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemId;                                            // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCombatLogEvent) == 0x000008, "Wrong alignment on FHWCombatLogEvent");
static_assert(sizeof(FHWCombatLogEvent) == 0x000060, "Wrong size on FHWCombatLogEvent");
static_assert(offsetof(FHWCombatLogEvent, EventType) == 0x000000, "Member 'FHWCombatLogEvent::EventType' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEvent, Type) == 0x000010, "Member 'FHWCombatLogEvent::Type' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEvent, SourcePlayer) == 0x000020, "Member 'FHWCombatLogEvent::SourcePlayer' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEvent, TargetPlayer) == 0x000030, "Member 'FHWCombatLogEvent::TargetPlayer' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEvent, ItemName) == 0x000040, "Member 'FHWCombatLogEvent::ItemName' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEvent, ItemId) == 0x000050, "Member 'FHWCombatLogEvent::ItemId' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEvent, Value) == 0x000054, "Member 'FHWCombatLogEvent::Value' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEvent, Timestamp) == 0x000058, "Member 'FHWCombatLogEvent::Timestamp' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEvent, TeamId) == 0x00005C, "Member 'FHWCombatLogEvent::TeamId' has a wrong offset!");

// ScriptStruct Hemingway.HWPassiveGameplayTagEvent
// 0x000C (0x000C - 0x0000)
struct FHWPassiveGameplayTagEvent final
{
public:
	struct FGameplayTag                           EventGameplayTag;                                  // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stack;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPassiveGameplayTagEvent) == 0x000004, "Wrong alignment on FHWPassiveGameplayTagEvent");
static_assert(sizeof(FHWPassiveGameplayTagEvent) == 0x00000C, "Wrong size on FHWPassiveGameplayTagEvent");
static_assert(offsetof(FHWPassiveGameplayTagEvent, EventGameplayTag) == 0x000000, "Member 'FHWPassiveGameplayTagEvent::EventGameplayTag' has a wrong offset!");
static_assert(offsetof(FHWPassiveGameplayTagEvent, Stack) == 0x000008, "Member 'FHWPassiveGameplayTagEvent::Stack' has a wrong offset!");

// ScriptStruct Hemingway.HWCombatLogEventFilter
// 0x00A0 (0x00A0 - 0x0000)
struct FHWCombatLogEventFilter final
{
public:
	TArray<class FString>                         IncludeEventTypes;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExcludeEventTypes;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         IncludeTypes;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExcludeTypes;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         IncludeSources;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExcludeSources;                                    // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         IncludeTargets;                                    // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExcludeTargets;                                    // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 IncludeItemIds;                                    // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ExcludeItemIds;                                    // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCombatLogEventFilter) == 0x000008, "Wrong alignment on FHWCombatLogEventFilter");
static_assert(sizeof(FHWCombatLogEventFilter) == 0x0000A0, "Wrong size on FHWCombatLogEventFilter");
static_assert(offsetof(FHWCombatLogEventFilter, IncludeEventTypes) == 0x000000, "Member 'FHWCombatLogEventFilter::IncludeEventTypes' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEventFilter, ExcludeEventTypes) == 0x000010, "Member 'FHWCombatLogEventFilter::ExcludeEventTypes' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEventFilter, IncludeTypes) == 0x000020, "Member 'FHWCombatLogEventFilter::IncludeTypes' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEventFilter, ExcludeTypes) == 0x000030, "Member 'FHWCombatLogEventFilter::ExcludeTypes' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEventFilter, IncludeSources) == 0x000040, "Member 'FHWCombatLogEventFilter::IncludeSources' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEventFilter, ExcludeSources) == 0x000050, "Member 'FHWCombatLogEventFilter::ExcludeSources' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEventFilter, IncludeTargets) == 0x000060, "Member 'FHWCombatLogEventFilter::IncludeTargets' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEventFilter, ExcludeTargets) == 0x000070, "Member 'FHWCombatLogEventFilter::ExcludeTargets' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEventFilter, IncludeItemIds) == 0x000080, "Member 'FHWCombatLogEventFilter::IncludeItemIds' has a wrong offset!");
static_assert(offsetof(FHWCombatLogEventFilter, ExcludeItemIds) == 0x000090, "Member 'FHWCombatLogEventFilter::ExcludeItemIds' has a wrong offset!");

// ScriptStruct Hemingway.HWCombatLogTeamData
// 0x0020 (0x0020 - 0x0000)
struct FHWCombatLogTeamData final
{
public:
	TArray<class FString>                         OrderTeam;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ChaosTeam;                                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCombatLogTeamData) == 0x000008, "Wrong alignment on FHWCombatLogTeamData");
static_assert(sizeof(FHWCombatLogTeamData) == 0x000020, "Wrong size on FHWCombatLogTeamData");
static_assert(offsetof(FHWCombatLogTeamData, OrderTeam) == 0x000000, "Member 'FHWCombatLogTeamData::OrderTeam' has a wrong offset!");
static_assert(offsetof(FHWCombatLogTeamData, ChaosTeam) == 0x000010, "Member 'FHWCombatLogTeamData::ChaosTeam' has a wrong offset!");

// ScriptStruct Hemingway.HWDynamicSubLevelEntry
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FHWDynamicSubLevelEntry final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWDynamicSubLevelEntry) == 0x000008, "Wrong alignment on FHWDynamicSubLevelEntry");
static_assert(sizeof(FHWDynamicSubLevelEntry) == 0x000018, "Wrong size on FHWDynamicSubLevelEntry");

// ScriptStruct Hemingway.HWTeamBoosters
// 0x0050 (0x0058 - 0x0008)
struct FHWTeamBoosters final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x50];                                       // 0x0008(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWTeamBoosters) == 0x000008, "Wrong alignment on FHWTeamBoosters");
static_assert(sizeof(FHWTeamBoosters) == 0x000058, "Wrong size on FHWTeamBoosters");

// ScriptStruct Hemingway.HWBoosterTableRow
// 0x0028 (0x0030 - 0x0008)
struct FHWBoosterTableRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           BoosterTag;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWCollectionItem*                      BoosterItem;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             BoosterClaimId;                                    // 0x0018(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWBoosterClaimType                           BoosterClaimType;                                  // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFriendlyTeamOnly;                               // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleActive;                              // 0x002E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWBoosterTableRow) == 0x000008, "Wrong alignment on FHWBoosterTableRow");
static_assert(sizeof(FHWBoosterTableRow) == 0x000030, "Wrong size on FHWBoosterTableRow");
static_assert(offsetof(FHWBoosterTableRow, BoosterTag) == 0x000008, "Member 'FHWBoosterTableRow::BoosterTag' has a wrong offset!");
static_assert(offsetof(FHWBoosterTableRow, BoosterItem) == 0x000010, "Member 'FHWBoosterTableRow::BoosterItem' has a wrong offset!");
static_assert(offsetof(FHWBoosterTableRow, BoosterClaimId) == 0x000018, "Member 'FHWBoosterTableRow::BoosterClaimId' has a wrong offset!");
static_assert(offsetof(FHWBoosterTableRow, BoosterClaimType) == 0x00002C, "Member 'FHWBoosterTableRow::BoosterClaimType' has a wrong offset!");
static_assert(offsetof(FHWBoosterTableRow, bIsFriendlyTeamOnly) == 0x00002D, "Member 'FHWBoosterTableRow::bIsFriendlyTeamOnly' has a wrong offset!");
static_assert(offsetof(FHWBoosterTableRow, bAllowMultipleActive) == 0x00002E, "Member 'FHWBoosterTableRow::bAllowMultipleActive' has a wrong offset!");

// ScriptStruct Hemingway.CameraPitchLimitLerper
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FCameraPitchLimitLerper final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraPitchLimitLerper) == 0x000008, "Wrong alignment on FCameraPitchLimitLerper");
static_assert(sizeof(FCameraPitchLimitLerper) == 0x000030, "Wrong size on FCameraPitchLimitLerper");

// ScriptStruct Hemingway.HWPingActionTimestamp
// 0x0010 (0x0010 - 0x0000)
struct FHWPingActionTimestamp final
{
public:
	TArray<float>                                 ActionTimestamps;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPingActionTimestamp) == 0x000008, "Wrong alignment on FHWPingActionTimestamp");
static_assert(sizeof(FHWPingActionTimestamp) == 0x000010, "Wrong size on FHWPingActionTimestamp");
static_assert(offsetof(FHWPingActionTimestamp, ActionTimestamps) == 0x000000, "Member 'FHWPingActionTimestamp::ActionTimestamps' has a wrong offset!");

// ScriptStruct Hemingway.SlotTypeArrayInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSlotTypeArrayInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlotTypeArrayInfo) == 0x000004, "Wrong alignment on FSlotTypeArrayInfo");
static_assert(sizeof(FSlotTypeArrayInfo) == 0x000008, "Wrong size on FSlotTypeArrayInfo");

// ScriptStruct Hemingway.HWPingConfig
// 0x0028 (0x0028 - 0x0000)
struct FHWPingConfig final
{
public:
	TArray<class AHWPingWorldActor*>              ActorPool;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHWPingDisplayInfoConfig               DisplayInfoConfig;                                 // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPingConfig) == 0x000008, "Wrong alignment on FHWPingConfig");
static_assert(sizeof(FHWPingConfig) == 0x000028, "Wrong size on FHWPingConfig");
static_assert(offsetof(FHWPingConfig, ActorPool) == 0x000000, "Member 'FHWPingConfig::ActorPool' has a wrong offset!");
static_assert(offsetof(FHWPingConfig, DisplayInfoConfig) == 0x000010, "Member 'FHWPingConfig::DisplayInfoConfig' has a wrong offset!");

// ScriptStruct Hemingway.HWPingConfigRow
// 0x0028 (0x0030 - 0x0008)
struct FHWPingConfigRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           PingTag;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWPingDisplayInfoConfig               DisplayInfoConfig;                                 // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPingConfigRow) == 0x000008, "Wrong alignment on FHWPingConfigRow");
static_assert(sizeof(FHWPingConfigRow) == 0x000030, "Wrong size on FHWPingConfigRow");
static_assert(offsetof(FHWPingConfigRow, PingTag) == 0x000008, "Member 'FHWPingConfigRow::PingTag' has a wrong offset!");
static_assert(offsetof(FHWPingConfigRow, bIsEnabled) == 0x000010, "Member 'FHWPingConfigRow::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FHWPingConfigRow, DisplayInfoConfig) == 0x000018, "Member 'FHWPingConfigRow::DisplayInfoConfig' has a wrong offset!");

// ScriptStruct Hemingway.HWSkinTagTypeEntry
// 0x0010 (0x0010 - 0x0000)
struct FHWSkinTagTypeEntry final
{
public:
	struct FGameplayTag                           SkinTagType;                                       // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkinTagValue;                                      // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkinTagTypeEntry) == 0x000004, "Wrong alignment on FHWSkinTagTypeEntry");
static_assert(sizeof(FHWSkinTagTypeEntry) == 0x000010, "Wrong size on FHWSkinTagTypeEntry");
static_assert(offsetof(FHWSkinTagTypeEntry, SkinTagType) == 0x000000, "Member 'FHWSkinTagTypeEntry::SkinTagType' has a wrong offset!");
static_assert(offsetof(FHWSkinTagTypeEntry, SkinTagValue) == 0x000008, "Member 'FHWSkinTagTypeEntry::SkinTagValue' has a wrong offset!");

// ScriptStruct Hemingway.QuestEntry
// 0x0028 (0x0030 - 0x0008)
struct FQuestEntry : public FTableRowBase
{
public:
	TSoftObjectPtr<class UHWQuest>                QuestItem;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestEntry) == 0x000008, "Wrong alignment on FQuestEntry");
static_assert(sizeof(FQuestEntry) == 0x000030, "Wrong size on FQuestEntry");
static_assert(offsetof(FQuestEntry, QuestItem) == 0x000008, "Member 'FQuestEntry::QuestItem' has a wrong offset!");

// ScriptStruct Hemingway.GodQuestEntry
// 0x0080 (0x00B0 - 0x0030)
struct FGodQuestEntry final : public FQuestEntry
{
public:
	TSoftObjectPtr<class UHWCollectionItem>       CollectionItem;                                    // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresOwnershipToTrack;                         // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCollectionOwnershipId;                    // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_ItemId                             OwnershipItemId;                                   // 0x005C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideQuestProgressTracker;                     // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_LootId                             ProgressLootId;                                    // 0x0074(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             TrackingItemId;                                    // 0x0088(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideQuestRewards;                             // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRH_LootId>                     QuestRewards;                                      // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGodQuestEntry) == 0x000008, "Wrong alignment on FGodQuestEntry");
static_assert(sizeof(FGodQuestEntry) == 0x0000B0, "Wrong size on FGodQuestEntry");
static_assert(offsetof(FGodQuestEntry, CollectionItem) == 0x000030, "Member 'FGodQuestEntry::CollectionItem' has a wrong offset!");
static_assert(offsetof(FGodQuestEntry, bRequiresOwnershipToTrack) == 0x000058, "Member 'FGodQuestEntry::bRequiresOwnershipToTrack' has a wrong offset!");
static_assert(offsetof(FGodQuestEntry, bOverrideCollectionOwnershipId) == 0x000059, "Member 'FGodQuestEntry::bOverrideCollectionOwnershipId' has a wrong offset!");
static_assert(offsetof(FGodQuestEntry, OwnershipItemId) == 0x00005C, "Member 'FGodQuestEntry::OwnershipItemId' has a wrong offset!");
static_assert(offsetof(FGodQuestEntry, bOverrideQuestProgressTracker) == 0x000070, "Member 'FGodQuestEntry::bOverrideQuestProgressTracker' has a wrong offset!");
static_assert(offsetof(FGodQuestEntry, ProgressLootId) == 0x000074, "Member 'FGodQuestEntry::ProgressLootId' has a wrong offset!");
static_assert(offsetof(FGodQuestEntry, TrackingItemId) == 0x000088, "Member 'FGodQuestEntry::TrackingItemId' has a wrong offset!");
static_assert(offsetof(FGodQuestEntry, bOverrideQuestRewards) == 0x00009C, "Member 'FGodQuestEntry::bOverrideQuestRewards' has a wrong offset!");
static_assert(offsetof(FGodQuestEntry, QuestRewards) == 0x0000A0, "Member 'FGodQuestEntry::QuestRewards' has a wrong offset!");

// ScriptStruct Hemingway.ActiveShieldEntry
// 0x000C (0x0018 - 0x000C)
struct FActiveShieldEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWShieldInstance*                      ShieldInstance;                                    // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveShieldEntry) == 0x000008, "Wrong alignment on FActiveShieldEntry");
static_assert(sizeof(FActiveShieldEntry) == 0x000018, "Wrong size on FActiveShieldEntry");
static_assert(offsetof(FActiveShieldEntry, ShieldInstance) == 0x000010, "Member 'FActiveShieldEntry::ShieldInstance' has a wrong offset!");

// ScriptStruct Hemingway.HWQuestAttributeRequirements
// 0x01F0 (0x01F0 - 0x0000)
struct FHWQuestAttributeRequirements final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectQuery                   ModifierEffectQuery;                               // 0x0038(0x01B0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bShouldAwardCustomAmount;                          // 0x01E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x3];                                      // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomRewardAmount;                                // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWQuestAttributeRequirements) == 0x000008, "Wrong alignment on FHWQuestAttributeRequirements");
static_assert(sizeof(FHWQuestAttributeRequirements) == 0x0001F0, "Wrong size on FHWQuestAttributeRequirements");
static_assert(offsetof(FHWQuestAttributeRequirements, Attribute) == 0x000000, "Member 'FHWQuestAttributeRequirements::Attribute' has a wrong offset!");
static_assert(offsetof(FHWQuestAttributeRequirements, ModifierEffectQuery) == 0x000038, "Member 'FHWQuestAttributeRequirements::ModifierEffectQuery' has a wrong offset!");
static_assert(offsetof(FHWQuestAttributeRequirements, bShouldAwardCustomAmount) == 0x0001E8, "Member 'FHWQuestAttributeRequirements::bShouldAwardCustomAmount' has a wrong offset!");
static_assert(offsetof(FHWQuestAttributeRequirements, CustomRewardAmount) == 0x0001EC, "Member 'FHWQuestAttributeRequirements::CustomRewardAmount' has a wrong offset!");

// ScriptStruct Hemingway.HWTargetWithTagsApplied
// 0x0020 (0x0020 - 0x0000)
struct FHWTargetWithTagsApplied final
{
public:
	class AHWCharacter_Base*                      HitActor;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApplicationStartTime;                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x14];                                       // 0x000C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWTargetWithTagsApplied) == 0x000008, "Wrong alignment on FHWTargetWithTagsApplied");
static_assert(sizeof(FHWTargetWithTagsApplied) == 0x000020, "Wrong size on FHWTargetWithTagsApplied");
static_assert(offsetof(FHWTargetWithTagsApplied, HitActor) == 0x000000, "Member 'FHWTargetWithTagsApplied::HitActor' has a wrong offset!");
static_assert(offsetof(FHWTargetWithTagsApplied, ApplicationStartTime) == 0x000008, "Member 'FHWTargetWithTagsApplied::ApplicationStartTime' has a wrong offset!");

// ScriptStruct Hemingway.HWCosmeticInventoryEntry
// 0x0014 (0x0020 - 0x000C)
struct FHWCosmeticInventoryEntry final : public FFastArraySerializerItem
{
public:
	int32                                         SlotId;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHWCollectionItemType                         SlotType;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWCollectionItem*                      CosmeticItem;                                      // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHWCosmeticInventoryEntry) == 0x000008, "Wrong alignment on FHWCosmeticInventoryEntry");
static_assert(sizeof(FHWCosmeticInventoryEntry) == 0x000020, "Wrong size on FHWCosmeticInventoryEntry");
static_assert(offsetof(FHWCosmeticInventoryEntry, SlotId) == 0x00000C, "Member 'FHWCosmeticInventoryEntry::SlotId' has a wrong offset!");
static_assert(offsetof(FHWCosmeticInventoryEntry, SlotType) == 0x000010, "Member 'FHWCosmeticInventoryEntry::SlotType' has a wrong offset!");
static_assert(offsetof(FHWCosmeticInventoryEntry, CosmeticItem) == 0x000018, "Member 'FHWCosmeticInventoryEntry::CosmeticItem' has a wrong offset!");

// ScriptStruct Hemingway.HWQueueRankTypes
// 0x0060 (0x0068 - 0x0008)
struct FHWQueueRankTypes final : public FTableRowBase
{
public:
	class FString                                 BaseRankType;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FString>      RoleRankTypes;                                     // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWQueueRankTypes) == 0x000008, "Wrong alignment on FHWQueueRankTypes");
static_assert(sizeof(FHWQueueRankTypes) == 0x000068, "Wrong size on FHWQueueRankTypes");
static_assert(offsetof(FHWQueueRankTypes, BaseRankType) == 0x000008, "Member 'FHWQueueRankTypes::BaseRankType' has a wrong offset!");
static_assert(offsetof(FHWQueueRankTypes, RoleRankTypes) == 0x000018, "Member 'FHWQueueRankTypes::RoleRankTypes' has a wrong offset!");

// ScriptStruct Hemingway.HWSkillRatingDisparityRange
// 0x000C (0x000C - 0x0000)
struct FHWSkillRatingDisparityRange final
{
public:
	float                                         DisparityMinimum;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisparityMaximum;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenaltyPercent;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkillRatingDisparityRange) == 0x000004, "Wrong alignment on FHWSkillRatingDisparityRange");
static_assert(sizeof(FHWSkillRatingDisparityRange) == 0x00000C, "Wrong size on FHWSkillRatingDisparityRange");
static_assert(offsetof(FHWSkillRatingDisparityRange, DisparityMinimum) == 0x000000, "Member 'FHWSkillRatingDisparityRange::DisparityMinimum' has a wrong offset!");
static_assert(offsetof(FHWSkillRatingDisparityRange, DisparityMaximum) == 0x000004, "Member 'FHWSkillRatingDisparityRange::DisparityMaximum' has a wrong offset!");
static_assert(offsetof(FHWSkillRatingDisparityRange, PenaltyPercent) == 0x000008, "Member 'FHWSkillRatingDisparityRange::PenaltyPercent' has a wrong offset!");

// ScriptStruct Hemingway.HWPartyPenaltyRange
// 0x000C (0x000C - 0x0000)
struct FHWPartyPenaltyRange final
{
public:
	float                                         HighestSRMinimum;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighestSRMaximum;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenaltyPercent;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPartyPenaltyRange) == 0x000004, "Wrong alignment on FHWPartyPenaltyRange");
static_assert(sizeof(FHWPartyPenaltyRange) == 0x00000C, "Wrong size on FHWPartyPenaltyRange");
static_assert(offsetof(FHWPartyPenaltyRange, HighestSRMinimum) == 0x000000, "Member 'FHWPartyPenaltyRange::HighestSRMinimum' has a wrong offset!");
static_assert(offsetof(FHWPartyPenaltyRange, HighestSRMaximum) == 0x000004, "Member 'FHWPartyPenaltyRange::HighestSRMaximum' has a wrong offset!");
static_assert(offsetof(FHWPartyPenaltyRange, PenaltyPercent) == 0x000008, "Member 'FHWPartyPenaltyRange::PenaltyPercent' has a wrong offset!");

// ScriptStruct Hemingway.HWPartyPenaltyRanges
// 0x0010 (0x0010 - 0x0000)
struct FHWPartyPenaltyRanges final
{
public:
	TArray<struct FHWPartyPenaltyRange>           Ranges;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPartyPenaltyRanges) == 0x000008, "Wrong alignment on FHWPartyPenaltyRanges");
static_assert(sizeof(FHWPartyPenaltyRanges) == 0x000010, "Wrong size on FHWPartyPenaltyRanges");
static_assert(offsetof(FHWPartyPenaltyRanges, Ranges) == 0x000000, "Member 'FHWPartyPenaltyRanges::Ranges' has a wrong offset!");

// ScriptStruct Hemingway.HWIndividualPenaltyRanges
// 0x0010 (0x0010 - 0x0000)
struct FHWIndividualPenaltyRanges final
{
public:
	TArray<struct FHWIndividualPenaltyRange>      Ranges;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWIndividualPenaltyRanges) == 0x000008, "Wrong alignment on FHWIndividualPenaltyRanges");
static_assert(sizeof(FHWIndividualPenaltyRanges) == 0x000010, "Wrong size on FHWIndividualPenaltyRanges");
static_assert(offsetof(FHWIndividualPenaltyRanges, Ranges) == 0x000000, "Member 'FHWIndividualPenaltyRanges::Ranges' has a wrong offset!");

// ScriptStruct Hemingway.HWTeamPartySizes
// 0x0010 (0x0010 - 0x0000)
struct FHWTeamPartySizes final
{
public:
	TArray<int32>                                 TeamPartySizes;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWTeamPartySizes) == 0x000008, "Wrong alignment on FHWTeamPartySizes");
static_assert(sizeof(FHWTeamPartySizes) == 0x000010, "Wrong size on FHWTeamPartySizes");
static_assert(offsetof(FHWTeamPartySizes, TeamPartySizes) == 0x000000, "Member 'FHWTeamPartySizes::TeamPartySizes' has a wrong offset!");

// ScriptStruct Hemingway.HWDisplayInfoConfig
// 0x0018 (0x0018 - 0x0000)
struct FHWDisplayInfoConfig final
{
public:
	uint8                                         DisplayOnCharacterType;                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VisibilityRequired;                                // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideVisibilityRequiredForSpectator;            // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SpectatorVisibilityRequired;                       // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWDisplayInfoData*                     ContextData;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInstant;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWDisplayInfoConfig) == 0x000008, "Wrong alignment on FHWDisplayInfoConfig");
static_assert(sizeof(FHWDisplayInfoConfig) == 0x000018, "Wrong size on FHWDisplayInfoConfig");
static_assert(offsetof(FHWDisplayInfoConfig, DisplayOnCharacterType) == 0x000000, "Member 'FHWDisplayInfoConfig::DisplayOnCharacterType' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfoConfig, VisibilityRequired) == 0x000001, "Member 'FHWDisplayInfoConfig::VisibilityRequired' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfoConfig, OverrideVisibilityRequiredForSpectator) == 0x000002, "Member 'FHWDisplayInfoConfig::OverrideVisibilityRequiredForSpectator' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfoConfig, SpectatorVisibilityRequired) == 0x000003, "Member 'FHWDisplayInfoConfig::SpectatorVisibilityRequired' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfoConfig, LifeSpan) == 0x000004, "Member 'FHWDisplayInfoConfig::LifeSpan' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfoConfig, ContextData) == 0x000008, "Member 'FHWDisplayInfoConfig::ContextData' has a wrong offset!");
static_assert(offsetof(FHWDisplayInfoConfig, IsInstant) == 0x000010, "Member 'FHWDisplayInfoConfig::IsInstant' has a wrong offset!");

// ScriptStruct Hemingway.HWPendingDisplayInfoRequest
// 0x0028 (0x0028 - 0x0000)
struct FHWPendingDisplayInfoRequest final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWDisplayInfoConfig                   DisplayInfoConfig;                                 // 0x0008(0x0018)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsAddOperation;                                   // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWPendingDisplayInfoRequest) == 0x000008, "Wrong alignment on FHWPendingDisplayInfoRequest");
static_assert(sizeof(FHWPendingDisplayInfoRequest) == 0x000028, "Wrong size on FHWPendingDisplayInfoRequest");
static_assert(offsetof(FHWPendingDisplayInfoRequest, DisplayInfoTag) == 0x000000, "Member 'FHWPendingDisplayInfoRequest::DisplayInfoTag' has a wrong offset!");
static_assert(offsetof(FHWPendingDisplayInfoRequest, DisplayInfoConfig) == 0x000008, "Member 'FHWPendingDisplayInfoRequest::DisplayInfoConfig' has a wrong offset!");
static_assert(offsetof(FHWPendingDisplayInfoRequest, bIsAddOperation) == 0x000020, "Member 'FHWPendingDisplayInfoRequest::bIsAddOperation' has a wrong offset!");

// ScriptStruct Hemingway.PlayerSettingVersionChange
// 0x0020 (0x0020 - 0x0000)
struct FPlayerSettingVersionChange final
{
public:
	class FString                                 SettingKey;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PreviousDefaultValue;                              // 0x0010(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSettingVersionChange) == 0x000008, "Wrong alignment on FPlayerSettingVersionChange");
static_assert(sizeof(FPlayerSettingVersionChange) == 0x000020, "Wrong size on FPlayerSettingVersionChange");
static_assert(offsetof(FPlayerSettingVersionChange, SettingKey) == 0x000000, "Member 'FPlayerSettingVersionChange::SettingKey' has a wrong offset!");
static_assert(offsetof(FPlayerSettingVersionChange, PreviousDefaultValue) == 0x000010, "Member 'FPlayerSettingVersionChange::PreviousDefaultValue' has a wrong offset!");

// ScriptStruct Hemingway.KeybindVersionChange
// 0x0018 (0x0018 - 0x0000)
struct FKeybindVersionChange final
{
public:
	class FString                                 PreviousKey;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ContextTag;                                        // 0x0010(0x0008)(Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeybindVersionChange) == 0x000008, "Wrong alignment on FKeybindVersionChange");
static_assert(sizeof(FKeybindVersionChange) == 0x000018, "Wrong size on FKeybindVersionChange");
static_assert(offsetof(FKeybindVersionChange, PreviousKey) == 0x000000, "Member 'FKeybindVersionChange::PreviousKey' has a wrong offset!");
static_assert(offsetof(FKeybindVersionChange, ContextTag) == 0x000010, "Member 'FKeybindVersionChange::ContextTag' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentItem_ItemTooltip_Stat
// 0x0010 (0x0010 - 0x0000)
struct FHWEquipmentItem_ItemTooltip_Stat final
{
public:
	struct FGameplayTag                           StatTag;                                           // 0x0000(0x0008)(Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEquipmentItem_ItemTooltip_Stat) == 0x000004, "Wrong alignment on FHWEquipmentItem_ItemTooltip_Stat");
static_assert(sizeof(FHWEquipmentItem_ItemTooltip_Stat) == 0x000010, "Wrong size on FHWEquipmentItem_ItemTooltip_Stat");
static_assert(offsetof(FHWEquipmentItem_ItemTooltip_Stat, StatTag) == 0x000000, "Member 'FHWEquipmentItem_ItemTooltip_Stat::StatTag' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_ItemTooltip_Stat, bEnabled) == 0x000008, "Member 'FHWEquipmentItem_ItemTooltip_Stat::bEnabled' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_ItemTooltip_Stat, Value) == 0x00000C, "Member 'FHWEquipmentItem_ItemTooltip_Stat::Value' has a wrong offset!");

// ScriptStruct Hemingway.PlayerSettingsVersionData
// 0x0018 (0x0018 - 0x0000)
struct FPlayerSettingsVersionData final
{
public:
	int32                                         Version;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerSettingVersionChange>    Changes;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSettingsVersionData) == 0x000008, "Wrong alignment on FPlayerSettingsVersionData");
static_assert(sizeof(FPlayerSettingsVersionData) == 0x000018, "Wrong size on FPlayerSettingsVersionData");
static_assert(offsetof(FPlayerSettingsVersionData, Version) == 0x000000, "Member 'FPlayerSettingsVersionData::Version' has a wrong offset!");
static_assert(offsetof(FPlayerSettingsVersionData, Changes) == 0x000008, "Member 'FPlayerSettingsVersionData::Changes' has a wrong offset!");

// ScriptStruct Hemingway.KeybindsVersionData
// 0x0018 (0x0018 - 0x0000)
struct FKeybindsVersionData final
{
public:
	int32                                         Version;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKeybindVersionChange>          Changes;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeybindsVersionData) == 0x000008, "Wrong alignment on FKeybindsVersionData");
static_assert(sizeof(FKeybindsVersionData) == 0x000018, "Wrong size on FKeybindsVersionData");
static_assert(offsetof(FKeybindsVersionData, Version) == 0x000000, "Member 'FKeybindsVersionData::Version' has a wrong offset!");
static_assert(offsetof(FKeybindsVersionData, Changes) == 0x000008, "Member 'FKeybindsVersionData::Changes' has a wrong offset!");

// ScriptStruct Hemingway.HWRefireWindowInfo
// 0x0018 (0x0018 - 0x0000)
struct FHWRefireWindowInfo final
{
public:
	struct FTimerHandle                           RefireWindowTimer;                                 // 0x0000(0x0008)(RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefireWindowDuration;                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindowStartTime;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceId;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRefireWindowActive;                             // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWRefireWindowInfo) == 0x000008, "Wrong alignment on FHWRefireWindowInfo");
static_assert(sizeof(FHWRefireWindowInfo) == 0x000018, "Wrong size on FHWRefireWindowInfo");
static_assert(offsetof(FHWRefireWindowInfo, RefireWindowTimer) == 0x000000, "Member 'FHWRefireWindowInfo::RefireWindowTimer' has a wrong offset!");
static_assert(offsetof(FHWRefireWindowInfo, RefireWindowDuration) == 0x000008, "Member 'FHWRefireWindowInfo::RefireWindowDuration' has a wrong offset!");
static_assert(offsetof(FHWRefireWindowInfo, WindowStartTime) == 0x00000C, "Member 'FHWRefireWindowInfo::WindowStartTime' has a wrong offset!");
static_assert(offsetof(FHWRefireWindowInfo, InstanceId) == 0x000010, "Member 'FHWRefireWindowInfo::InstanceId' has a wrong offset!");
static_assert(offsetof(FHWRefireWindowInfo, bIsRefireWindowActive) == 0x000014, "Member 'FHWRefireWindowInfo::bIsRefireWindowActive' has a wrong offset!");

// ScriptStruct Hemingway.HWApparelInstanceTemplate
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FHWApparelInstanceTemplate final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWApparelInstanceTemplate) == 0x000008, "Wrong alignment on FHWApparelInstanceTemplate");
static_assert(sizeof(FHWApparelInstanceTemplate) == 0x000028, "Wrong size on FHWApparelInstanceTemplate");

// ScriptStruct Hemingway.HWTargetData_SplinePoint
// 0x0000 (0x0088 - 0x0088)
struct FHWTargetData_SplinePoint final : public FSplinePoint
{
};
static_assert(alignof(FHWTargetData_SplinePoint) == 0x000008, "Wrong alignment on FHWTargetData_SplinePoint");
static_assert(sizeof(FHWTargetData_SplinePoint) == 0x000088, "Wrong size on FHWTargetData_SplinePoint");

// ScriptStruct Hemingway.HWEquipmentItem_TooltipNamedValueScalingConfig
// 0x0018 (0x0018 - 0x0000)
struct FHWEquipmentItem_TooltipNamedValueScalingConfig final
{
public:
	struct FGameplayTag                           ScalingStatTag;                                    // 0x0000(0x0008)(Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Values;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEquipmentItem_TooltipNamedValueScalingConfig) == 0x000008, "Wrong alignment on FHWEquipmentItem_TooltipNamedValueScalingConfig");
static_assert(sizeof(FHWEquipmentItem_TooltipNamedValueScalingConfig) == 0x000018, "Wrong size on FHWEquipmentItem_TooltipNamedValueScalingConfig");
static_assert(offsetof(FHWEquipmentItem_TooltipNamedValueScalingConfig, ScalingStatTag) == 0x000000, "Member 'FHWEquipmentItem_TooltipNamedValueScalingConfig::ScalingStatTag' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_TooltipNamedValueScalingConfig, Values) == 0x000008, "Member 'FHWEquipmentItem_TooltipNamedValueScalingConfig::Values' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentItem_TooltipNamedValueScaling
// 0x0020 (0x0020 - 0x0000)
struct FHWEquipmentItem_TooltipNamedValueScaling final
{
public:
	class FString                                 ScalingName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWEquipmentItem_TooltipNamedValueScalingConfig> ScalingConfigs;                   // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEquipmentItem_TooltipNamedValueScaling) == 0x000008, "Wrong alignment on FHWEquipmentItem_TooltipNamedValueScaling");
static_assert(sizeof(FHWEquipmentItem_TooltipNamedValueScaling) == 0x000020, "Wrong size on FHWEquipmentItem_TooltipNamedValueScaling");
static_assert(offsetof(FHWEquipmentItem_TooltipNamedValueScaling, ScalingName) == 0x000000, "Member 'FHWEquipmentItem_TooltipNamedValueScaling::ScalingName' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_TooltipNamedValueScaling, ScalingConfigs) == 0x000010, "Member 'FHWEquipmentItem_TooltipNamedValueScaling::ScalingConfigs' has a wrong offset!");

// ScriptStruct Hemingway.HWTargetData_SplinePath
// 0x0018 (0x0020 - 0x0008)
struct FHWTargetData_SplinePath final : public FGameplayAbilityTargetData
{
public:
	class USplineComponent*                       SplinePath;                                        // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHWTargetData_SplinePoint>      PathPoints;                                        // 0x0010(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHWTargetData_SplinePath) == 0x000008, "Wrong alignment on FHWTargetData_SplinePath");
static_assert(sizeof(FHWTargetData_SplinePath) == 0x000020, "Wrong size on FHWTargetData_SplinePath");
static_assert(offsetof(FHWTargetData_SplinePath, SplinePath) == 0x000008, "Member 'FHWTargetData_SplinePath::SplinePath' has a wrong offset!");
static_assert(offsetof(FHWTargetData_SplinePath, PathPoints) == 0x000010, "Member 'FHWTargetData_SplinePath::PathPoints' has a wrong offset!");

// ScriptStruct Hemingway.HWTimeSeriesData
// 0x0030 (0x0030 - 0x0000)
struct FHWTimeSeriesData final
{
public:
	class FName                                   SeriesId;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SeriesName;                                        // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FKantanCartesianDatapoint>      DataPoints;                                        // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWTimeSeriesData) == 0x000008, "Wrong alignment on FHWTimeSeriesData");
static_assert(sizeof(FHWTimeSeriesData) == 0x000030, "Wrong size on FHWTimeSeriesData");
static_assert(offsetof(FHWTimeSeriesData, SeriesId) == 0x000000, "Member 'FHWTimeSeriesData::SeriesId' has a wrong offset!");
static_assert(offsetof(FHWTimeSeriesData, SeriesName) == 0x000008, "Member 'FHWTimeSeriesData::SeriesName' has a wrong offset!");
static_assert(offsetof(FHWTimeSeriesData, DataPoints) == 0x000020, "Member 'FHWTimeSeriesData::DataPoints' has a wrong offset!");

// ScriptStruct Hemingway.HWInventoryEntry
// 0x001C (0x0028 - 0x000C)
struct FHWInventoryEntry final : public FFastArraySerializerItem
{
public:
	struct FHWInventorySlot                       SlotId;                                            // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHWInventoryChangeReason                      InventoryUpdateReason;                             // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEquippingInProgress;                            // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUnEquippingInProgress;                          // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWInventoryEntry) == 0x000008, "Wrong alignment on FHWInventoryEntry");
static_assert(sizeof(FHWInventoryEntry) == 0x000028, "Wrong size on FHWInventoryEntry");
static_assert(offsetof(FHWInventoryEntry, SlotId) == 0x00000C, "Member 'FHWInventoryEntry::SlotId' has a wrong offset!");
static_assert(offsetof(FHWInventoryEntry, EquipmentInstance) == 0x000018, "Member 'FHWInventoryEntry::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(FHWInventoryEntry, InventoryUpdateReason) == 0x000020, "Member 'FHWInventoryEntry::InventoryUpdateReason' has a wrong offset!");
static_assert(offsetof(FHWInventoryEntry, bIsEquippingInProgress) == 0x000021, "Member 'FHWInventoryEntry::bIsEquippingInProgress' has a wrong offset!");
static_assert(offsetof(FHWInventoryEntry, bIsUnEquippingInProgress) == 0x000022, "Member 'FHWInventoryEntry::bIsUnEquippingInProgress' has a wrong offset!");

// ScriptStruct Hemingway.LevelGrid
// 0x0050 (0x0050 - 0x0000)
struct FLevelGrid final
{
public:
	struct FVector                                Min;                                               // 0x0000(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Max;                                               // 0x0018(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TileSize;                                          // 0x0030(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Width;                                             // 0x0048(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Height;                                            // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLevelGrid) == 0x000008, "Wrong alignment on FLevelGrid");
static_assert(sizeof(FLevelGrid) == 0x000050, "Wrong size on FLevelGrid");
static_assert(offsetof(FLevelGrid, Min) == 0x000000, "Member 'FLevelGrid::Min' has a wrong offset!");
static_assert(offsetof(FLevelGrid, Max) == 0x000018, "Member 'FLevelGrid::Max' has a wrong offset!");
static_assert(offsetof(FLevelGrid, TileSize) == 0x000030, "Member 'FLevelGrid::TileSize' has a wrong offset!");
static_assert(offsetof(FLevelGrid, Width) == 0x000048, "Member 'FLevelGrid::Width' has a wrong offset!");
static_assert(offsetof(FLevelGrid, Height) == 0x00004C, "Member 'FLevelGrid::Height' has a wrong offset!");

// ScriptStruct Hemingway.VectorFieldEffectorData
// 0x0038 (0x0038 - 0x0000)
struct FVectorFieldEffectorData final
{
public:
	bool                                          bIsLocationEffector;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWVectorFieldFollowCalc*               Calculation;                                       // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bObstacleAvoid;                                    // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVectorFieldEffectorData) == 0x000008, "Wrong alignment on FVectorFieldEffectorData");
static_assert(sizeof(FVectorFieldEffectorData) == 0x000038, "Wrong size on FVectorFieldEffectorData");
static_assert(offsetof(FVectorFieldEffectorData, bIsLocationEffector) == 0x000000, "Member 'FVectorFieldEffectorData::bIsLocationEffector' has a wrong offset!");
static_assert(offsetof(FVectorFieldEffectorData, Location) == 0x000008, "Member 'FVectorFieldEffectorData::Location' has a wrong offset!");
static_assert(offsetof(FVectorFieldEffectorData, Actor) == 0x000020, "Member 'FVectorFieldEffectorData::Actor' has a wrong offset!");
static_assert(offsetof(FVectorFieldEffectorData, Calculation) == 0x000028, "Member 'FVectorFieldEffectorData::Calculation' has a wrong offset!");
static_assert(offsetof(FVectorFieldEffectorData, Weight) == 0x000030, "Member 'FVectorFieldEffectorData::Weight' has a wrong offset!");
static_assert(offsetof(FVectorFieldEffectorData, bObstacleAvoid) == 0x000034, "Member 'FVectorFieldEffectorData::bObstacleAvoid' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentItem_AbilityTooltip_Description
// 0x0020 (0x0020 - 0x0000)
struct FHWEquipmentItem_AbilityTooltip_Description final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EHWEquipmentItemTooltip_DisplayPhase          DisplayPhase;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AppearsForDescriptionTypes;                        // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TalentDisplayMode;                                 // 0x001A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWEquipmentItem_AbilityTooltip_Description) == 0x000008, "Wrong alignment on FHWEquipmentItem_AbilityTooltip_Description");
static_assert(sizeof(FHWEquipmentItem_AbilityTooltip_Description) == 0x000020, "Wrong size on FHWEquipmentItem_AbilityTooltip_Description");
static_assert(offsetof(FHWEquipmentItem_AbilityTooltip_Description, Description) == 0x000000, "Member 'FHWEquipmentItem_AbilityTooltip_Description::Description' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_AbilityTooltip_Description, DisplayPhase) == 0x000018, "Member 'FHWEquipmentItem_AbilityTooltip_Description::DisplayPhase' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_AbilityTooltip_Description, AppearsForDescriptionTypes) == 0x000019, "Member 'FHWEquipmentItem_AbilityTooltip_Description::AppearsForDescriptionTypes' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_AbilityTooltip_Description, TalentDisplayMode) == 0x00001A, "Member 'FHWEquipmentItem_AbilityTooltip_Description::TalentDisplayMode' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSFloodProtectionData
// 0x000C (0x000C - 0x0000)
struct FHWVGSFloodProtectionData final
{
public:
	float                                         FloodProtectionTimeWindow;                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FloodProtectionMessageLimit;                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloodProtectionCooldownTime;                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVGSFloodProtectionData) == 0x000004, "Wrong alignment on FHWVGSFloodProtectionData");
static_assert(sizeof(FHWVGSFloodProtectionData) == 0x00000C, "Wrong size on FHWVGSFloodProtectionData");
static_assert(offsetof(FHWVGSFloodProtectionData, FloodProtectionTimeWindow) == 0x000000, "Member 'FHWVGSFloodProtectionData::FloodProtectionTimeWindow' has a wrong offset!");
static_assert(offsetof(FHWVGSFloodProtectionData, FloodProtectionMessageLimit) == 0x000004, "Member 'FHWVGSFloodProtectionData::FloodProtectionMessageLimit' has a wrong offset!");
static_assert(offsetof(FHWVGSFloodProtectionData, FloodProtectionCooldownTime) == 0x000008, "Member 'FHWVGSFloodProtectionData::FloodProtectionCooldownTime' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSActionTimestamps
// 0x0010 (0x0010 - 0x0000)
struct FHWVGSActionTimestamps final
{
public:
	TArray<float>                                 ActionTimestamps;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVGSActionTimestamps) == 0x000008, "Wrong alignment on FHWVGSActionTimestamps");
static_assert(sizeof(FHWVGSActionTimestamps) == 0x000010, "Wrong size on FHWVGSActionTimestamps");
static_assert(offsetof(FHWVGSActionTimestamps, ActionTimestamps) == 0x000000, "Member 'FHWVGSActionTimestamps::ActionTimestamps' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentItem_TooltipNamedValue
// 0x0020 (0x0020 - 0x0000)
struct FHWEquipmentItem_TooltipNamedValue final
{
public:
	class FString                                 ValueName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Values;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEquipmentItem_TooltipNamedValue) == 0x000008, "Wrong alignment on FHWEquipmentItem_TooltipNamedValue");
static_assert(sizeof(FHWEquipmentItem_TooltipNamedValue) == 0x000020, "Wrong size on FHWEquipmentItem_TooltipNamedValue");
static_assert(offsetof(FHWEquipmentItem_TooltipNamedValue, ValueName) == 0x000000, "Member 'FHWEquipmentItem_TooltipNamedValue::ValueName' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_TooltipNamedValue, Values) == 0x000010, "Member 'FHWEquipmentItem_TooltipNamedValue::Values' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSPlayerActionTimestampMap
// 0x0050 (0x0050 - 0x0000)
struct FHWVGSPlayerActionTimestampMap final
{
public:
	TMap<EHWVGSFloodProtectionType, struct FHWVGSActionTimestamps> ActionTimestamps;                 // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVGSPlayerActionTimestampMap) == 0x000008, "Wrong alignment on FHWVGSPlayerActionTimestampMap");
static_assert(sizeof(FHWVGSPlayerActionTimestampMap) == 0x000050, "Wrong size on FHWVGSPlayerActionTimestampMap");
static_assert(offsetof(FHWVGSPlayerActionTimestampMap, ActionTimestamps) == 0x000000, "Member 'FHWVGSPlayerActionTimestampMap::ActionTimestamps' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSPlayerFloodProtectionTimers
// 0x0050 (0x0050 - 0x0000)
struct FHWVGSPlayerFloodProtectionTimers final
{
public:
	TMap<EHWVGSFloodProtectionType, struct FTimerHandle> FloodProtectionTimers;                      // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVGSPlayerFloodProtectionTimers) == 0x000008, "Wrong alignment on FHWVGSPlayerFloodProtectionTimers");
static_assert(sizeof(FHWVGSPlayerFloodProtectionTimers) == 0x000050, "Wrong size on FHWVGSPlayerFloodProtectionTimers");
static_assert(offsetof(FHWVGSPlayerFloodProtectionTimers, FloodProtectionTimers) == 0x000000, "Member 'FHWVGSPlayerFloodProtectionTimers::FloodProtectionTimers' has a wrong offset!");

// ScriptStruct Hemingway.HWRecipeIngredientInfo
// 0x0030 (0x0030 - 0x0000)
struct FHWRecipeIngredientInfo final
{
public:
	TWeakObjectPtr<class UHWEquipmentItem>        Ingredient;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UHWEquipmentRecipe>      Recipe;                                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHWEquipmentInstance*>           IngredientsToUse;                                  // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWRecipeIngredientInfo) == 0x000008, "Wrong alignment on FHWRecipeIngredientInfo");
static_assert(sizeof(FHWRecipeIngredientInfo) == 0x000030, "Wrong size on FHWRecipeIngredientInfo");
static_assert(offsetof(FHWRecipeIngredientInfo, Ingredient) == 0x000000, "Member 'FHWRecipeIngredientInfo::Ingredient' has a wrong offset!");
static_assert(offsetof(FHWRecipeIngredientInfo, Recipe) == 0x000008, "Member 'FHWRecipeIngredientInfo::Recipe' has a wrong offset!");
static_assert(offsetof(FHWRecipeIngredientInfo, IngredientsToUse) == 0x000010, "Member 'FHWRecipeIngredientInfo::IngredientsToUse' has a wrong offset!");

// ScriptStruct Hemingway.HWVoiceOverEvent
// 0x0030 (0x0038 - 0x0008)
struct FHWVoiceOverEvent final : public FTableRowBase
{
public:
	struct FGameplayTag                           SkinKeyword;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Audience;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlayBehavior;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttachmentType;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToPlay;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DirectedEnemy;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVoiceOverEvent) == 0x000008, "Wrong alignment on FHWVoiceOverEvent");
static_assert(sizeof(FHWVoiceOverEvent) == 0x000038, "Wrong size on FHWVoiceOverEvent");
static_assert(offsetof(FHWVoiceOverEvent, SkinKeyword) == 0x000008, "Member 'FHWVoiceOverEvent::SkinKeyword' has a wrong offset!");
static_assert(offsetof(FHWVoiceOverEvent, Audience) == 0x000010, "Member 'FHWVoiceOverEvent::Audience' has a wrong offset!");
static_assert(offsetof(FHWVoiceOverEvent, PlayBehavior) == 0x000018, "Member 'FHWVoiceOverEvent::PlayBehavior' has a wrong offset!");
static_assert(offsetof(FHWVoiceOverEvent, AttachmentType) == 0x000020, "Member 'FHWVoiceOverEvent::AttachmentType' has a wrong offset!");
static_assert(offsetof(FHWVoiceOverEvent, Cooldown) == 0x000028, "Member 'FHWVoiceOverEvent::Cooldown' has a wrong offset!");
static_assert(offsetof(FHWVoiceOverEvent, ChanceToPlay) == 0x00002C, "Member 'FHWVoiceOverEvent::ChanceToPlay' has a wrong offset!");
static_assert(offsetof(FHWVoiceOverEvent, DirectedEnemy) == 0x000030, "Member 'FHWVoiceOverEvent::DirectedEnemy' has a wrong offset!");

// ScriptStruct Hemingway.HWVolumeEffectActiveEffectInfoHandle
// 0x0008 (0x0010 - 0x0008)
struct FHWVolumeEffectActiveEffectInfoHandle final : public FActiveGameplayEffectHandle
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWVolumeEffectActiveEffectInfoHandle) == 0x000004, "Wrong alignment on FHWVolumeEffectActiveEffectInfoHandle");
static_assert(sizeof(FHWVolumeEffectActiveEffectInfoHandle) == 0x000010, "Wrong size on FHWVolumeEffectActiveEffectInfoHandle");

// ScriptStruct Hemingway.HWOnSpawnFXActorParams
// 0x0060 (0x0060 - 0x0000)
struct FHWOnSpawnFXActorParams final
{
public:
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NiagaraSkinningKeyword;                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundSkinningKeyword;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWOnSpawnFXActorParams) == 0x000008, "Wrong alignment on FHWOnSpawnFXActorParams");
static_assert(sizeof(FHWOnSpawnFXActorParams) == 0x000060, "Wrong size on FHWOnSpawnFXActorParams");
static_assert(offsetof(FHWOnSpawnFXActorParams, NiagaraSystem) == 0x000000, "Member 'FHWOnSpawnFXActorParams::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(FHWOnSpawnFXActorParams, NiagaraSkinningKeyword) == 0x000008, "Member 'FHWOnSpawnFXActorParams::NiagaraSkinningKeyword' has a wrong offset!");
static_assert(offsetof(FHWOnSpawnFXActorParams, Sound) == 0x000010, "Member 'FHWOnSpawnFXActorParams::Sound' has a wrong offset!");
static_assert(offsetof(FHWOnSpawnFXActorParams, SoundSkinningKeyword) == 0x000018, "Member 'FHWOnSpawnFXActorParams::SoundSkinningKeyword' has a wrong offset!");
static_assert(offsetof(FHWOnSpawnFXActorParams, VolumeMultiplier) == 0x000020, "Member 'FHWOnSpawnFXActorParams::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(FHWOnSpawnFXActorParams, PitchMultiplier) == 0x000024, "Member 'FHWOnSpawnFXActorParams::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(FHWOnSpawnFXActorParams, bAttached) == 0x000028, "Member 'FHWOnSpawnFXActorParams::bAttached' has a wrong offset!");
static_assert(offsetof(FHWOnSpawnFXActorParams, LocationOffset) == 0x000030, "Member 'FHWOnSpawnFXActorParams::LocationOffset' has a wrong offset!");
static_assert(offsetof(FHWOnSpawnFXActorParams, RotationOffset) == 0x000048, "Member 'FHWOnSpawnFXActorParams::RotationOffset' has a wrong offset!");

// ScriptStruct Hemingway.WaypointSetPath
// 0x0010 (0x0010 - 0x0000)
struct FWaypointSetPath final
{
public:
	TArray<class AHWWaypoint*>                    PathPoints;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaypointSetPath) == 0x000008, "Wrong alignment on FWaypointSetPath");
static_assert(sizeof(FWaypointSetPath) == 0x000010, "Wrong size on FWaypointSetPath");
static_assert(offsetof(FWaypointSetPath, PathPoints) == 0x000000, "Member 'FWaypointSetPath::PathPoints' has a wrong offset!");

// ScriptStruct Hemingway.HWAimTargetingInfo
// 0x0080 (0x0080 - 0x0000)
struct FHWAimTargetingInfo final
{
public:
	class AHWTargeter*                            Targeter;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AvatarActor;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             AvatarActorTransform;                              // 0x0010(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPredicting;                                     // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAimTargetingInfo) == 0x000010, "Wrong alignment on FHWAimTargetingInfo");
static_assert(sizeof(FHWAimTargetingInfo) == 0x000080, "Wrong size on FHWAimTargetingInfo");
static_assert(offsetof(FHWAimTargetingInfo, Targeter) == 0x000000, "Member 'FHWAimTargetingInfo::Targeter' has a wrong offset!");
static_assert(offsetof(FHWAimTargetingInfo, AvatarActor) == 0x000008, "Member 'FHWAimTargetingInfo::AvatarActor' has a wrong offset!");
static_assert(offsetof(FHWAimTargetingInfo, AvatarActorTransform) == 0x000010, "Member 'FHWAimTargetingInfo::AvatarActorTransform' has a wrong offset!");
static_assert(offsetof(FHWAimTargetingInfo, bIsPredicting) == 0x000070, "Member 'FHWAimTargetingInfo::bIsPredicting' has a wrong offset!");

// ScriptStruct Hemingway.HWInventoryTransactionItem
// 0x0018 (0x0018 - 0x0000)
struct FHWInventoryTransactionItem final
{
public:
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       InventorySlot;                                     // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWInventoryTransactionItem) == 0x000008, "Wrong alignment on FHWInventoryTransactionItem");
static_assert(sizeof(FHWInventoryTransactionItem) == 0x000018, "Wrong size on FHWInventoryTransactionItem");
static_assert(offsetof(FHWInventoryTransactionItem, EquipmentInstance) == 0x000000, "Member 'FHWInventoryTransactionItem::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(FHWInventoryTransactionItem, InventorySlot) == 0x000008, "Member 'FHWInventoryTransactionItem::InventorySlot' has a wrong offset!");

// ScriptStruct Hemingway.HWCustomAimStruct
// 0x0010 (0x0010 - 0x0000)
struct FHWCustomAimStruct final
{
public:
	struct FGameplayTag                           ID;                                                // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityAimSettings*                  AimSettings;                                       // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCustomAimStruct) == 0x000008, "Wrong alignment on FHWCustomAimStruct");
static_assert(sizeof(FHWCustomAimStruct) == 0x000010, "Wrong size on FHWCustomAimStruct");
static_assert(offsetof(FHWCustomAimStruct, ID) == 0x000000, "Member 'FHWCustomAimStruct::ID' has a wrong offset!");
static_assert(offsetof(FHWCustomAimStruct, AimSettings) == 0x000008, "Member 'FHWCustomAimStruct::AimSettings' has a wrong offset!");

// ScriptStruct Hemingway.HWAttackTargetingInfo
// 0x0048 (0x0048 - 0x0000)
struct FHWAttackTargetingInfo final
{
public:
	class AHWTargeter*                            Targeter;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackID;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWGameplayAbility*                     AbilityInstance;                                   // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       AimDataHandle;                                     // 0x0018(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsPredicting;                                     // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAttackTargetingInfo) == 0x000008, "Wrong alignment on FHWAttackTargetingInfo");
static_assert(sizeof(FHWAttackTargetingInfo) == 0x000048, "Wrong size on FHWAttackTargetingInfo");
static_assert(offsetof(FHWAttackTargetingInfo, Targeter) == 0x000000, "Member 'FHWAttackTargetingInfo::Targeter' has a wrong offset!");
static_assert(offsetof(FHWAttackTargetingInfo, AttackID) == 0x000008, "Member 'FHWAttackTargetingInfo::AttackID' has a wrong offset!");
static_assert(offsetof(FHWAttackTargetingInfo, AbilityInstance) == 0x000010, "Member 'FHWAttackTargetingInfo::AbilityInstance' has a wrong offset!");
static_assert(offsetof(FHWAttackTargetingInfo, AimDataHandle) == 0x000018, "Member 'FHWAttackTargetingInfo::AimDataHandle' has a wrong offset!");
static_assert(offsetof(FHWAttackTargetingInfo, bIsPredicting) == 0x000040, "Member 'FHWAttackTargetingInfo::bIsPredicting' has a wrong offset!");

// ScriptStruct Hemingway.HWInventorySlotConfig
// 0x0028 (0x0030 - 0x0008)
struct FHWInventorySlotConfig final : public FTableRowBase
{
public:
	struct FGameplayTag                           SlotType;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AllowedEquipmentTypes;                             // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWInventorySlotConfig) == 0x000008, "Wrong alignment on FHWInventorySlotConfig");
static_assert(sizeof(FHWInventorySlotConfig) == 0x000030, "Wrong size on FHWInventorySlotConfig");
static_assert(offsetof(FHWInventorySlotConfig, SlotType) == 0x000008, "Member 'FHWInventorySlotConfig::SlotType' has a wrong offset!");
static_assert(offsetof(FHWInventorySlotConfig, AllowedEquipmentTypes) == 0x000010, "Member 'FHWInventorySlotConfig::AllowedEquipmentTypes' has a wrong offset!");

// ScriptStruct Hemingway.AbilityPhaseDurations
// 0x0018 (0x0018 - 0x0000)
struct FAbilityPhaseDurations final
{
public:
	float                                         TargetingPhaseDuration;                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildUpPhaseDuration;                              // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreFirePhaseDuration;                              // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirePhaseDuration;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostFirePhaseDuration;                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndingPhaseDuration;                               // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityPhaseDurations) == 0x000004, "Wrong alignment on FAbilityPhaseDurations");
static_assert(sizeof(FAbilityPhaseDurations) == 0x000018, "Wrong size on FAbilityPhaseDurations");
static_assert(offsetof(FAbilityPhaseDurations, TargetingPhaseDuration) == 0x000000, "Member 'FAbilityPhaseDurations::TargetingPhaseDuration' has a wrong offset!");
static_assert(offsetof(FAbilityPhaseDurations, BuildUpPhaseDuration) == 0x000004, "Member 'FAbilityPhaseDurations::BuildUpPhaseDuration' has a wrong offset!");
static_assert(offsetof(FAbilityPhaseDurations, PreFirePhaseDuration) == 0x000008, "Member 'FAbilityPhaseDurations::PreFirePhaseDuration' has a wrong offset!");
static_assert(offsetof(FAbilityPhaseDurations, FirePhaseDuration) == 0x00000C, "Member 'FAbilityPhaseDurations::FirePhaseDuration' has a wrong offset!");
static_assert(offsetof(FAbilityPhaseDurations, PostFirePhaseDuration) == 0x000010, "Member 'FAbilityPhaseDurations::PostFirePhaseDuration' has a wrong offset!");
static_assert(offsetof(FAbilityPhaseDurations, EndingPhaseDuration) == 0x000014, "Member 'FAbilityPhaseDurations::EndingPhaseDuration' has a wrong offset!");

// ScriptStruct Hemingway.HWBounceChainGameplayEffect
// 0x0068 (0x0068 - 0x0000)
struct FHWBounceChainGameplayEffect final
{
public:
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstHitMultiplier;                                // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BaseMagnitudeGameplayTag;                          // 0x000C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BaseMagnitudeRowName;                              // 0x0014(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PowerScalingGameplayTag;                           // 0x001C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PowerScalingRowName;                               // 0x0024(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     PowerScalingAttribute;                             // 0x0030(0x0038)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWBounceChainGameplayEffect) == 0x000008, "Wrong alignment on FHWBounceChainGameplayEffect");
static_assert(sizeof(FHWBounceChainGameplayEffect) == 0x000068, "Wrong size on FHWBounceChainGameplayEffect");
static_assert(offsetof(FHWBounceChainGameplayEffect, EffectClass) == 0x000000, "Member 'FHWBounceChainGameplayEffect::EffectClass' has a wrong offset!");
static_assert(offsetof(FHWBounceChainGameplayEffect, FirstHitMultiplier) == 0x000008, "Member 'FHWBounceChainGameplayEffect::FirstHitMultiplier' has a wrong offset!");
static_assert(offsetof(FHWBounceChainGameplayEffect, BaseMagnitudeGameplayTag) == 0x00000C, "Member 'FHWBounceChainGameplayEffect::BaseMagnitudeGameplayTag' has a wrong offset!");
static_assert(offsetof(FHWBounceChainGameplayEffect, BaseMagnitudeRowName) == 0x000014, "Member 'FHWBounceChainGameplayEffect::BaseMagnitudeRowName' has a wrong offset!");
static_assert(offsetof(FHWBounceChainGameplayEffect, PowerScalingGameplayTag) == 0x00001C, "Member 'FHWBounceChainGameplayEffect::PowerScalingGameplayTag' has a wrong offset!");
static_assert(offsetof(FHWBounceChainGameplayEffect, PowerScalingRowName) == 0x000024, "Member 'FHWBounceChainGameplayEffect::PowerScalingRowName' has a wrong offset!");
static_assert(offsetof(FHWBounceChainGameplayEffect, PowerScalingAttribute) == 0x000030, "Member 'FHWBounceChainGameplayEffect::PowerScalingAttribute' has a wrong offset!");

// ScriptStruct Hemingway.HWSeasonShopItemConfig
// 0x0050 (0x0050 - 0x0000)
struct FHWSeasonShopItemConfig final
{
public:
	int32                                         Page;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         X;                                                 // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefaultSelection;                                  // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LegacyItemId;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GuidItemId;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwnershipLegacyItemId;                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OwnershipGuidItemId;                               // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWPriceDisplayType                           PriceDisplayType;                                  // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWSeasonShopItemConfig) == 0x000008, "Wrong alignment on FHWSeasonShopItemConfig");
static_assert(sizeof(FHWSeasonShopItemConfig) == 0x000050, "Wrong size on FHWSeasonShopItemConfig");
static_assert(offsetof(FHWSeasonShopItemConfig, Page) == 0x000000, "Member 'FHWSeasonShopItemConfig::Page' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, X) == 0x000004, "Member 'FHWSeasonShopItemConfig::X' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, Y) == 0x000008, "Member 'FHWSeasonShopItemConfig::Y' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, Width) == 0x00000C, "Member 'FHWSeasonShopItemConfig::Width' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, Height) == 0x000010, "Member 'FHWSeasonShopItemConfig::Height' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, Quantity) == 0x000014, "Member 'FHWSeasonShopItemConfig::Quantity' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, DefaultSelection) == 0x000018, "Member 'FHWSeasonShopItemConfig::DefaultSelection' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, LegacyItemId) == 0x00001C, "Member 'FHWSeasonShopItemConfig::LegacyItemId' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, GuidItemId) == 0x000020, "Member 'FHWSeasonShopItemConfig::GuidItemId' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, OwnershipLegacyItemId) == 0x000030, "Member 'FHWSeasonShopItemConfig::OwnershipLegacyItemId' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, OwnershipGuidItemId) == 0x000038, "Member 'FHWSeasonShopItemConfig::OwnershipGuidItemId' has a wrong offset!");
static_assert(offsetof(FHWSeasonShopItemConfig, PriceDisplayType) == 0x000048, "Member 'FHWSeasonShopItemConfig::PriceDisplayType' has a wrong offset!");

// ScriptStruct Hemingway.AbilityFlowPhaseTransitionRule
// 0x0001 (0x0001 - 0x0000)
struct FAbilityFlowPhaseTransitionRule final
{
public:
	uint8                                         AllowedPhasesFlags;                                // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAbilityFlowPhaseTransitionRule) == 0x000001, "Wrong alignment on FAbilityFlowPhaseTransitionRule");
static_assert(sizeof(FAbilityFlowPhaseTransitionRule) == 0x000001, "Wrong size on FAbilityFlowPhaseTransitionRule");
static_assert(offsetof(FAbilityFlowPhaseTransitionRule, AllowedPhasesFlags) == 0x000000, "Member 'FAbilityFlowPhaseTransitionRule::AllowedPhasesFlags' has a wrong offset!");

// ScriptStruct Hemingway.AbilityPhaseBlockTagsContainer
// 0x00D0 (0x00D0 - 0x0000)
struct FAbilityPhaseBlockTagsContainer final
{
public:
	struct FGameplayTagContainer                  BlockTags;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GeneratedBlockTags;                                // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GeneratedTagsToRemove;                             // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseGeneratedBlockTags;                            // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInheritedTagContainer                 AdditionalAbilityPhaseBlockTags;                   // 0x0068(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         AbilityPhaseBlockFlags;                            // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityPhaseBlockTagsContainer) == 0x000008, "Wrong alignment on FAbilityPhaseBlockTagsContainer");
static_assert(sizeof(FAbilityPhaseBlockTagsContainer) == 0x0000D0, "Wrong size on FAbilityPhaseBlockTagsContainer");
static_assert(offsetof(FAbilityPhaseBlockTagsContainer, BlockTags) == 0x000000, "Member 'FAbilityPhaseBlockTagsContainer::BlockTags' has a wrong offset!");
static_assert(offsetof(FAbilityPhaseBlockTagsContainer, GeneratedBlockTags) == 0x000020, "Member 'FAbilityPhaseBlockTagsContainer::GeneratedBlockTags' has a wrong offset!");
static_assert(offsetof(FAbilityPhaseBlockTagsContainer, GeneratedTagsToRemove) == 0x000040, "Member 'FAbilityPhaseBlockTagsContainer::GeneratedTagsToRemove' has a wrong offset!");
static_assert(offsetof(FAbilityPhaseBlockTagsContainer, bUseGeneratedBlockTags) == 0x000060, "Member 'FAbilityPhaseBlockTagsContainer::bUseGeneratedBlockTags' has a wrong offset!");
static_assert(offsetof(FAbilityPhaseBlockTagsContainer, AdditionalAbilityPhaseBlockTags) == 0x000068, "Member 'FAbilityPhaseBlockTagsContainer::AdditionalAbilityPhaseBlockTags' has a wrong offset!");
static_assert(offsetof(FAbilityPhaseBlockTagsContainer, AbilityPhaseBlockFlags) == 0x0000C8, "Member 'FAbilityPhaseBlockTagsContainer::AbilityPhaseBlockFlags' has a wrong offset!");

// ScriptStruct Hemingway.HWFlightCameraInfluenceSpeedPercentages
// 0x0008 (0x0008 - 0x0000)
struct FHWFlightCameraInfluenceSpeedPercentages final
{
public:
	float                                         MinSpeedPercentage;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedPercentage;                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWFlightCameraInfluenceSpeedPercentages) == 0x000004, "Wrong alignment on FHWFlightCameraInfluenceSpeedPercentages");
static_assert(sizeof(FHWFlightCameraInfluenceSpeedPercentages) == 0x000008, "Wrong size on FHWFlightCameraInfluenceSpeedPercentages");
static_assert(offsetof(FHWFlightCameraInfluenceSpeedPercentages, MinSpeedPercentage) == 0x000000, "Member 'FHWFlightCameraInfluenceSpeedPercentages::MinSpeedPercentage' has a wrong offset!");
static_assert(offsetof(FHWFlightCameraInfluenceSpeedPercentages, MaxSpeedPercentage) == 0x000004, "Member 'FHWFlightCameraInfluenceSpeedPercentages::MaxSpeedPercentage' has a wrong offset!");

// ScriptStruct Hemingway.HWEffectGroupConfig
// 0x0010 (0x0010 - 0x0000)
struct FHWEffectGroupConfig final
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    Effects;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEffectGroupConfig) == 0x000008, "Wrong alignment on FHWEffectGroupConfig");
static_assert(sizeof(FHWEffectGroupConfig) == 0x000010, "Wrong size on FHWEffectGroupConfig");
static_assert(offsetof(FHWEffectGroupConfig, Effects) == 0x000000, "Member 'FHWEffectGroupConfig::Effects' has a wrong offset!");

// ScriptStruct Hemingway.HWHitResultsReference
// 0x0010 (0x0010 - 0x0000)
struct FHWHitResultsReference final
{
public:
	TArray<struct FHitResult>                     Hits;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWHitResultsReference) == 0x000008, "Wrong alignment on FHWHitResultsReference");
static_assert(sizeof(FHWHitResultsReference) == 0x000010, "Wrong size on FHWHitResultsReference");
static_assert(offsetof(FHWHitResultsReference, Hits) == 0x000000, "Member 'FHWHitResultsReference::Hits' has a wrong offset!");

// ScriptStruct Hemingway.HWTopTeamStat
// 0x0010 (0x0010 - 0x0000)
struct FHWTopTeamStat final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatNum;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWTopTeamStat) == 0x000008, "Wrong alignment on FHWTopTeamStat");
static_assert(sizeof(FHWTopTeamStat) == 0x000010, "Wrong size on FHWTopTeamStat");
static_assert(offsetof(FHWTopTeamStat, PlayerState) == 0x000000, "Member 'FHWTopTeamStat::PlayerState' has a wrong offset!");
static_assert(offsetof(FHWTopTeamStat, StatNum) == 0x000008, "Member 'FHWTopTeamStat::StatNum' has a wrong offset!");

// ScriptStruct Hemingway.HWPendingPhaseTranstionInfo
// 0x000C (0x000C - 0x0000)
struct FHWPendingPhaseTranstionInfo final
{
public:
	EAbilityFlowPhase                             AbilityPhase;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimingError;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPendingPhaseTranstionInfo) == 0x000004, "Wrong alignment on FHWPendingPhaseTranstionInfo");
static_assert(sizeof(FHWPendingPhaseTranstionInfo) == 0x00000C, "Wrong size on FHWPendingPhaseTranstionInfo");
static_assert(offsetof(FHWPendingPhaseTranstionInfo, AbilityPhase) == 0x000000, "Member 'FHWPendingPhaseTranstionInfo::AbilityPhase' has a wrong offset!");
static_assert(offsetof(FHWPendingPhaseTranstionInfo, TimingError) == 0x000004, "Member 'FHWPendingPhaseTranstionInfo::TimingError' has a wrong offset!");
static_assert(offsetof(FHWPendingPhaseTranstionInfo, Timestamp) == 0x000008, "Member 'FHWPendingPhaseTranstionInfo::Timestamp' has a wrong offset!");

// ScriptStruct Hemingway.DamageTypeAttributeInfo
// 0x0118 (0x0118 - 0x0000)
struct FDamageTypeAttributeInfo final
{
public:
	struct FGameplayAttribute                     AttackPower;                                       // 0x0000(0x0038)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     InhandAttackPower;                                 // 0x0038(0x0038)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Protection;                                        // 0x0070(0x0038)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     PercentPenetration;                                // 0x00A8(0x0038)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     FlatPenetration;                                   // 0x00E0(0x0038)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageTypeAttributeInfo) == 0x000008, "Wrong alignment on FDamageTypeAttributeInfo");
static_assert(sizeof(FDamageTypeAttributeInfo) == 0x000118, "Wrong size on FDamageTypeAttributeInfo");
static_assert(offsetof(FDamageTypeAttributeInfo, AttackPower) == 0x000000, "Member 'FDamageTypeAttributeInfo::AttackPower' has a wrong offset!");
static_assert(offsetof(FDamageTypeAttributeInfo, InhandAttackPower) == 0x000038, "Member 'FDamageTypeAttributeInfo::InhandAttackPower' has a wrong offset!");
static_assert(offsetof(FDamageTypeAttributeInfo, Protection) == 0x000070, "Member 'FDamageTypeAttributeInfo::Protection' has a wrong offset!");
static_assert(offsetof(FDamageTypeAttributeInfo, PercentPenetration) == 0x0000A8, "Member 'FDamageTypeAttributeInfo::PercentPenetration' has a wrong offset!");
static_assert(offsetof(FDamageTypeAttributeInfo, FlatPenetration) == 0x0000E0, "Member 'FDamageTypeAttributeInfo::FlatPenetration' has a wrong offset!");

// ScriptStruct Hemingway.HWForcedFiringEffectTrackingData
// 0x0014 (0x0014 - 0x0000)
struct FHWForcedFiringEffectTrackingData final
{
public:
	float                                         RefireTime;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToNextFire;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFiringCount;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentFiringCount;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForFirstForcedMovementTick;                   // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWForcedFiringEffectTrackingData) == 0x000004, "Wrong alignment on FHWForcedFiringEffectTrackingData");
static_assert(sizeof(FHWForcedFiringEffectTrackingData) == 0x000014, "Wrong size on FHWForcedFiringEffectTrackingData");
static_assert(offsetof(FHWForcedFiringEffectTrackingData, RefireTime) == 0x000000, "Member 'FHWForcedFiringEffectTrackingData::RefireTime' has a wrong offset!");
static_assert(offsetof(FHWForcedFiringEffectTrackingData, TimeToNextFire) == 0x000004, "Member 'FHWForcedFiringEffectTrackingData::TimeToNextFire' has a wrong offset!");
static_assert(offsetof(FHWForcedFiringEffectTrackingData, MaxFiringCount) == 0x000008, "Member 'FHWForcedFiringEffectTrackingData::MaxFiringCount' has a wrong offset!");
static_assert(offsetof(FHWForcedFiringEffectTrackingData, CurrentFiringCount) == 0x00000C, "Member 'FHWForcedFiringEffectTrackingData::CurrentFiringCount' has a wrong offset!");
static_assert(offsetof(FHWForcedFiringEffectTrackingData, bWaitForFirstForcedMovementTick) == 0x000010, "Member 'FHWForcedFiringEffectTrackingData::bWaitForFirstForcedMovementTick' has a wrong offset!");

// ScriptStruct Hemingway.HWDashEndInfo
// 0x0130 (0x0130 - 0x0000)
struct FHWDashEndInfo final
{
public:
	TWeakObjectPtr<class AActor>                  ActorDashStoppedOn;                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInterrupting;                                   // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DashId;                                            // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       StopOnCollisionHitsFromClient;                     // 0x0018(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bDidDashStopOnWorld;                               // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitDashStoppedOn;                                  // 0x0048(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWDashEndInfo) == 0x000008, "Wrong alignment on FHWDashEndInfo");
static_assert(sizeof(FHWDashEndInfo) == 0x000130, "Wrong size on FHWDashEndInfo");
static_assert(offsetof(FHWDashEndInfo, ActorDashStoppedOn) == 0x000000, "Member 'FHWDashEndInfo::ActorDashStoppedOn' has a wrong offset!");
static_assert(offsetof(FHWDashEndInfo, bIsInterrupting) == 0x000008, "Member 'FHWDashEndInfo::bIsInterrupting' has a wrong offset!");
static_assert(offsetof(FHWDashEndInfo, DashId) == 0x00000C, "Member 'FHWDashEndInfo::DashId' has a wrong offset!");
static_assert(offsetof(FHWDashEndInfo, StopOnCollisionHitsFromClient) == 0x000018, "Member 'FHWDashEndInfo::StopOnCollisionHitsFromClient' has a wrong offset!");
static_assert(offsetof(FHWDashEndInfo, bDidDashStopOnWorld) == 0x000040, "Member 'FHWDashEndInfo::bDidDashStopOnWorld' has a wrong offset!");
static_assert(offsetof(FHWDashEndInfo, HitDashStoppedOn) == 0x000048, "Member 'FHWDashEndInfo::HitDashStoppedOn' has a wrong offset!");

// ScriptStruct Hemingway.HWForceMovementEffectConfig
// 0x0018 (0x0018 - 0x0000)
struct FHWForceMovementEffectConfig final
{
public:
	EHWForcedCharacterMovementCategory            MovementCategory;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CategoryPrioritizationWeight;                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWForcedCharacterMovementBehavior            MovementBehavior;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomDirectionAngleThreshold;                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecalculateDirectionOnTick;                       // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSeperationDistance;                             // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWForceMovementEffectConfig) == 0x000004, "Wrong alignment on FHWForceMovementEffectConfig");
static_assert(sizeof(FHWForceMovementEffectConfig) == 0x000018, "Wrong size on FHWForceMovementEffectConfig");
static_assert(offsetof(FHWForceMovementEffectConfig, MovementCategory) == 0x000000, "Member 'FHWForceMovementEffectConfig::MovementCategory' has a wrong offset!");
static_assert(offsetof(FHWForceMovementEffectConfig, CategoryPrioritizationWeight) == 0x000004, "Member 'FHWForceMovementEffectConfig::CategoryPrioritizationWeight' has a wrong offset!");
static_assert(offsetof(FHWForceMovementEffectConfig, MovementBehavior) == 0x000008, "Member 'FHWForceMovementEffectConfig::MovementBehavior' has a wrong offset!");
static_assert(offsetof(FHWForceMovementEffectConfig, RandomDirectionAngleThreshold) == 0x00000C, "Member 'FHWForceMovementEffectConfig::RandomDirectionAngleThreshold' has a wrong offset!");
static_assert(offsetof(FHWForceMovementEffectConfig, bRecalculateDirectionOnTick) == 0x000010, "Member 'FHWForceMovementEffectConfig::bRecalculateDirectionOnTick' has a wrong offset!");
static_assert(offsetof(FHWForceMovementEffectConfig, MinSeperationDistance) == 0x000014, "Member 'FHWForceMovementEffectConfig::MinSeperationDistance' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentGrantSpecConfig
// 0x0040 (0x0040 - 0x0000)
struct FHWEquipmentGrantSpecConfig final
{
public:
	class UHWEquipmentItem*                       Equipment;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         Level;                                             // 0x0008(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGameplayEffectGrantedAbilityRemovePolicy     RemovalPolicy;                                     // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStoreInTemporaryEquipPointSlot;                   // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWInventorySlot                       EquipSlot;                                         // 0x0034(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHWEquipmentGrantSpecConfig) == 0x000008, "Wrong alignment on FHWEquipmentGrantSpecConfig");
static_assert(sizeof(FHWEquipmentGrantSpecConfig) == 0x000040, "Wrong size on FHWEquipmentGrantSpecConfig");
static_assert(offsetof(FHWEquipmentGrantSpecConfig, Equipment) == 0x000000, "Member 'FHWEquipmentGrantSpecConfig::Equipment' has a wrong offset!");
static_assert(offsetof(FHWEquipmentGrantSpecConfig, Level) == 0x000008, "Member 'FHWEquipmentGrantSpecConfig::Level' has a wrong offset!");
static_assert(offsetof(FHWEquipmentGrantSpecConfig, RemovalPolicy) == 0x000030, "Member 'FHWEquipmentGrantSpecConfig::RemovalPolicy' has a wrong offset!");
static_assert(offsetof(FHWEquipmentGrantSpecConfig, bStoreInTemporaryEquipPointSlot) == 0x000031, "Member 'FHWEquipmentGrantSpecConfig::bStoreInTemporaryEquipPointSlot' has a wrong offset!");
static_assert(offsetof(FHWEquipmentGrantSpecConfig, EquipSlot) == 0x000034, "Member 'FHWEquipmentGrantSpecConfig::EquipSlot' has a wrong offset!");

// ScriptStruct Hemingway.HWPawnMinimapState
// 0x0003 (0x0003 - 0x0000)
struct FHWPawnMinimapState final
{
public:
	uint8                                         PawnTeamTypeAndModifiers;                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PawnXLoc;                                          // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PawnYLoc;                                          // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPawnMinimapState) == 0x000001, "Wrong alignment on FHWPawnMinimapState");
static_assert(sizeof(FHWPawnMinimapState) == 0x000003, "Wrong size on FHWPawnMinimapState");
static_assert(offsetof(FHWPawnMinimapState, PawnTeamTypeAndModifiers) == 0x000000, "Member 'FHWPawnMinimapState::PawnTeamTypeAndModifiers' has a wrong offset!");
static_assert(offsetof(FHWPawnMinimapState, PawnXLoc) == 0x000001, "Member 'FHWPawnMinimapState::PawnXLoc' has a wrong offset!");
static_assert(offsetof(FHWPawnMinimapState, PawnYLoc) == 0x000002, "Member 'FHWPawnMinimapState::PawnYLoc' has a wrong offset!");

// ScriptStruct Hemingway.SimGameplayCueEvent
// 0x01C4 (0x01D0 - 0x000C)
struct FSimGameplayCueEvent final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CueTags;                                           // 0x0010(0x0020)(NativeAccessSpecifierPublic)
	EGameplayCueEvent                             CueEventType;                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHWAbilitySystemComponent> TargetASC;                                       // 0x0034(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         CuePredictionKey;                                  // 0x0040(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 CueParams;                                         // 0x0058(0x00D8)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecForRPC              RPCSpec;                                           // 0x0130(0x0080)(NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x01B0(0x0018)(NativeAccessSpecifierPublic)
	int32                                         LastProcessedReplicationKey;                       // 0x01C8(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimGameplayCueEvent) == 0x000008, "Wrong alignment on FSimGameplayCueEvent");
static_assert(sizeof(FSimGameplayCueEvent) == 0x0001D0, "Wrong size on FSimGameplayCueEvent");
static_assert(offsetof(FSimGameplayCueEvent, CueTags) == 0x000010, "Member 'FSimGameplayCueEvent::CueTags' has a wrong offset!");
static_assert(offsetof(FSimGameplayCueEvent, CueEventType) == 0x000030, "Member 'FSimGameplayCueEvent::CueEventType' has a wrong offset!");
static_assert(offsetof(FSimGameplayCueEvent, TargetASC) == 0x000034, "Member 'FSimGameplayCueEvent::TargetASC' has a wrong offset!");
static_assert(offsetof(FSimGameplayCueEvent, CuePredictionKey) == 0x000040, "Member 'FSimGameplayCueEvent::CuePredictionKey' has a wrong offset!");
static_assert(offsetof(FSimGameplayCueEvent, CueParams) == 0x000058, "Member 'FSimGameplayCueEvent::CueParams' has a wrong offset!");
static_assert(offsetof(FSimGameplayCueEvent, RPCSpec) == 0x000130, "Member 'FSimGameplayCueEvent::RPCSpec' has a wrong offset!");
static_assert(offsetof(FSimGameplayCueEvent, EffectContext) == 0x0001B0, "Member 'FSimGameplayCueEvent::EffectContext' has a wrong offset!");
static_assert(offsetof(FSimGameplayCueEvent, LastProcessedReplicationKey) == 0x0001C8, "Member 'FSimGameplayCueEvent::LastProcessedReplicationKey' has a wrong offset!");

// ScriptStruct Hemingway.SimGameplayCueEventList
// 0x0020 (0x0128 - 0x0108)
struct FSimGameplayCueEventList final : public FFastArraySerializer
{
public:
	TArray<struct FSimGameplayCueEvent>           FlashEvents;                                       // 0x0108(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         CurrentFlashIndex;                                 // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CachedMaxFlashEvents;                              // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHWCharacterAbilitySystemActor*         OwningABSActor;                                    // 0x0120(0x0008)(ZeroConstructor, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSimGameplayCueEventList) == 0x000008, "Wrong alignment on FSimGameplayCueEventList");
static_assert(sizeof(FSimGameplayCueEventList) == 0x000128, "Wrong size on FSimGameplayCueEventList");
static_assert(offsetof(FSimGameplayCueEventList, FlashEvents) == 0x000108, "Member 'FSimGameplayCueEventList::FlashEvents' has a wrong offset!");
static_assert(offsetof(FSimGameplayCueEventList, CurrentFlashIndex) == 0x000118, "Member 'FSimGameplayCueEventList::CurrentFlashIndex' has a wrong offset!");
static_assert(offsetof(FSimGameplayCueEventList, CachedMaxFlashEvents) == 0x00011C, "Member 'FSimGameplayCueEventList::CachedMaxFlashEvents' has a wrong offset!");
static_assert(offsetof(FSimGameplayCueEventList, OwningABSActor) == 0x000120, "Member 'FSimGameplayCueEventList::OwningABSActor' has a wrong offset!");

// ScriptStruct Hemingway.HWLocalPlayerPreferences
// 0x0018 (0x0018 - 0x0000)
struct FHWLocalPlayerPreferences final
{
public:
	bool                                          bGodPageAbilityDetailsExpanded;                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastSelectedQueueId;                               // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWLocalPlayerPreferences) == 0x000008, "Wrong alignment on FHWLocalPlayerPreferences");
static_assert(sizeof(FHWLocalPlayerPreferences) == 0x000018, "Wrong size on FHWLocalPlayerPreferences");
static_assert(offsetof(FHWLocalPlayerPreferences, bGodPageAbilityDetailsExpanded) == 0x000000, "Member 'FHWLocalPlayerPreferences::bGodPageAbilityDetailsExpanded' has a wrong offset!");
static_assert(offsetof(FHWLocalPlayerPreferences, LastSelectedQueueId) == 0x000008, "Member 'FHWLocalPlayerPreferences::LastSelectedQueueId' has a wrong offset!");

// ScriptStruct Hemingway.HWGameplayTargetDataFilter
// 0x01B0 (0x01D0 - 0x0020)
struct FHWGameplayTargetDataFilter : public FGameplayTargetDataFilter
{
public:
	bool                                          bIsFilterInitialized;                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTargetingFilter;                                // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0028(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               CharacterTypeRequirements;                         // 0x00B0(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bRequireVisibility;                                // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireLineOfSight;                               // 0x0139(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireTargetWithoutStealth;                      // 0x013A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireMapVisibility;                             // 0x013B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireGameplayVisibility;                        // 0x013C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetDataFilterTeam                         TeamFilter;                                        // 0x013D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTargetDeployables;                             // 0x013E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F[0x1];                                      // 0x013F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               DeployableTagRequirements;                         // 0x0140(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bCanTargetWards;                                   // 0x01C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTargetInvisibleWards;                          // 0x01C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTargetUntargetableActors;                      // 0x01CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTargetAllyGodDecoys;                           // 0x01CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireSamePlaneOfExistence;                      // 0x01CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CD[0x3];                                      // 0x01CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWGameplayTargetDataFilter) == 0x000008, "Wrong alignment on FHWGameplayTargetDataFilter");
static_assert(sizeof(FHWGameplayTargetDataFilter) == 0x0001D0, "Wrong size on FHWGameplayTargetDataFilter");
static_assert(offsetof(FHWGameplayTargetDataFilter, bIsFilterInitialized) == 0x000020, "Member 'FHWGameplayTargetDataFilter::bIsFilterInitialized' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bIsTargetingFilter) == 0x000021, "Member 'FHWGameplayTargetDataFilter::bIsTargetingFilter' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, TagRequirements) == 0x000028, "Member 'FHWGameplayTargetDataFilter::TagRequirements' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, CharacterTypeRequirements) == 0x0000B0, "Member 'FHWGameplayTargetDataFilter::CharacterTypeRequirements' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bRequireVisibility) == 0x000138, "Member 'FHWGameplayTargetDataFilter::bRequireVisibility' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bRequireLineOfSight) == 0x000139, "Member 'FHWGameplayTargetDataFilter::bRequireLineOfSight' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bRequireTargetWithoutStealth) == 0x00013A, "Member 'FHWGameplayTargetDataFilter::bRequireTargetWithoutStealth' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bRequireMapVisibility) == 0x00013B, "Member 'FHWGameplayTargetDataFilter::bRequireMapVisibility' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bRequireGameplayVisibility) == 0x00013C, "Member 'FHWGameplayTargetDataFilter::bRequireGameplayVisibility' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, TeamFilter) == 0x00013D, "Member 'FHWGameplayTargetDataFilter::TeamFilter' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bCanTargetDeployables) == 0x00013E, "Member 'FHWGameplayTargetDataFilter::bCanTargetDeployables' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, DeployableTagRequirements) == 0x000140, "Member 'FHWGameplayTargetDataFilter::DeployableTagRequirements' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bCanTargetWards) == 0x0001C8, "Member 'FHWGameplayTargetDataFilter::bCanTargetWards' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bCanTargetInvisibleWards) == 0x0001C9, "Member 'FHWGameplayTargetDataFilter::bCanTargetInvisibleWards' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bCanTargetUntargetableActors) == 0x0001CA, "Member 'FHWGameplayTargetDataFilter::bCanTargetUntargetableActors' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bCanTargetAllyGodDecoys) == 0x0001CB, "Member 'FHWGameplayTargetDataFilter::bCanTargetAllyGodDecoys' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter, bRequireSamePlaneOfExistence) == 0x0001CC, "Member 'FHWGameplayTargetDataFilter::bRequireSamePlaneOfExistence' has a wrong offset!");

// ScriptStruct Hemingway.HWGameplayTargetDataFilter_Stealth
// 0x0018 (0x01E8 - 0x01D0)
struct FHWGameplayTargetDataFilter_Stealth final : public FHWGameplayTargetDataFilter
{
public:
	uint8                                         StealthCategoryFlags;                              // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequiresSameFiringInstance;                       // 0x01D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequiresSameInstigator;                           // 0x01D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreVisibilitySharing;                          // 0x01D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x01D4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UGameplayEffect>         GameplayEffectDef;                                 // 0x01DC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWGameplayTargetDataFilter_Stealth) == 0x000008, "Wrong alignment on FHWGameplayTargetDataFilter_Stealth");
static_assert(sizeof(FHWGameplayTargetDataFilter_Stealth) == 0x0001E8, "Wrong size on FHWGameplayTargetDataFilter_Stealth");
static_assert(offsetof(FHWGameplayTargetDataFilter_Stealth, StealthCategoryFlags) == 0x0001D0, "Member 'FHWGameplayTargetDataFilter_Stealth::StealthCategoryFlags' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter_Stealth, bRequiresSameFiringInstance) == 0x0001D1, "Member 'FHWGameplayTargetDataFilter_Stealth::bRequiresSameFiringInstance' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter_Stealth, bRequiresSameInstigator) == 0x0001D2, "Member 'FHWGameplayTargetDataFilter_Stealth::bRequiresSameInstigator' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter_Stealth, bIgnoreVisibilitySharing) == 0x0001D3, "Member 'FHWGameplayTargetDataFilter_Stealth::bIgnoreVisibilitySharing' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter_Stealth, Instigator) == 0x0001D4, "Member 'FHWGameplayTargetDataFilter_Stealth::Instigator' has a wrong offset!");
static_assert(offsetof(FHWGameplayTargetDataFilter_Stealth, GameplayEffectDef) == 0x0001DC, "Member 'FHWGameplayTargetDataFilter_Stealth::GameplayEffectDef' has a wrong offset!");

// ScriptStruct Hemingway.HWFamiliarAttribute
// 0x0080 (0x0080 - 0x0000)
struct FHWFamiliarAttribute final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldInheritBasedOnMaxAttributePercent;          // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     AttributeMax;                                      // 0x0040(0x0038)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InheritanceCoefficent;                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWFamiliarAttribute) == 0x000008, "Wrong alignment on FHWFamiliarAttribute");
static_assert(sizeof(FHWFamiliarAttribute) == 0x000080, "Wrong size on FHWFamiliarAttribute");
static_assert(offsetof(FHWFamiliarAttribute, Attribute) == 0x000000, "Member 'FHWFamiliarAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(FHWFamiliarAttribute, bShouldInheritBasedOnMaxAttributePercent) == 0x000038, "Member 'FHWFamiliarAttribute::bShouldInheritBasedOnMaxAttributePercent' has a wrong offset!");
static_assert(offsetof(FHWFamiliarAttribute, AttributeMax) == 0x000040, "Member 'FHWFamiliarAttribute::AttributeMax' has a wrong offset!");
static_assert(offsetof(FHWFamiliarAttribute, InheritanceCoefficent) == 0x000078, "Member 'FHWFamiliarAttribute::InheritanceCoefficent' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilitySet_GameplayAbility
// 0x0018 (0x0018 - 0x0000)
struct FHWAbilitySet_GameplayAbility final
{
public:
	TSubclassOf<class UGameplayAbility>           Ability;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x000C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAbilitySet_GameplayAbility) == 0x000008, "Wrong alignment on FHWAbilitySet_GameplayAbility");
static_assert(sizeof(FHWAbilitySet_GameplayAbility) == 0x000018, "Wrong size on FHWAbilitySet_GameplayAbility");
static_assert(offsetof(FHWAbilitySet_GameplayAbility, Ability) == 0x000000, "Member 'FHWAbilitySet_GameplayAbility::Ability' has a wrong offset!");
static_assert(offsetof(FHWAbilitySet_GameplayAbility, AbilityLevel) == 0x000008, "Member 'FHWAbilitySet_GameplayAbility::AbilityLevel' has a wrong offset!");
static_assert(offsetof(FHWAbilitySet_GameplayAbility, InputTag) == 0x00000C, "Member 'FHWAbilitySet_GameplayAbility::InputTag' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilitySet_GameplayEffect
// 0x0010 (0x0010 - 0x0000)
struct FHWAbilitySet_GameplayEffect final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectLevel;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAbilitySet_GameplayEffect) == 0x000008, "Wrong alignment on FHWAbilitySet_GameplayEffect");
static_assert(sizeof(FHWAbilitySet_GameplayEffect) == 0x000010, "Wrong size on FHWAbilitySet_GameplayEffect");
static_assert(offsetof(FHWAbilitySet_GameplayEffect, GameplayEffect) == 0x000000, "Member 'FHWAbilitySet_GameplayEffect::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FHWAbilitySet_GameplayEffect, EffectLevel) == 0x000008, "Member 'FHWAbilitySet_GameplayEffect::EffectLevel' has a wrong offset!");

// ScriptStruct Hemingway.HWGamePhaseState
// 0x000C (0x000C - 0x0000)
struct FHWGamePhaseState final
{
public:
	EHWGameStatePhase                             GamePhase;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhaseStartTime;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseDuration;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWGamePhaseState) == 0x000004, "Wrong alignment on FHWGamePhaseState");
static_assert(sizeof(FHWGamePhaseState) == 0x00000C, "Wrong size on FHWGamePhaseState");
static_assert(offsetof(FHWGamePhaseState, GamePhase) == 0x000000, "Member 'FHWGamePhaseState::GamePhase' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseState, PhaseStartTime) == 0x000004, "Member 'FHWGamePhaseState::PhaseStartTime' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseState, PhaseDuration) == 0x000008, "Member 'FHWGamePhaseState::PhaseDuration' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilitySet_AttributeSet
// 0x0008 (0x0008 - 0x0000)
struct FHWAbilitySet_AttributeSet final
{
public:
	TSubclassOf<class UAttributeSet>              AttributeSet;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAbilitySet_AttributeSet) == 0x000008, "Wrong alignment on FHWAbilitySet_AttributeSet");
static_assert(sizeof(FHWAbilitySet_AttributeSet) == 0x000008, "Wrong size on FHWAbilitySet_AttributeSet");
static_assert(offsetof(FHWAbilitySet_AttributeSet, AttributeSet) == 0x000000, "Member 'FHWAbilitySet_AttributeSet::AttributeSet' has a wrong offset!");

// ScriptStruct Hemingway.HWDiminishingReturnsTracker
// 0x0010 (0x0010 - 0x0000)
struct FHWDiminishingReturnsTracker final
{
public:
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         WorldTimeApplied;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DR_Stacks;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWDiminishingReturnsTracker) == 0x000004, "Wrong alignment on FHWDiminishingReturnsTracker");
static_assert(sizeof(FHWDiminishingReturnsTracker) == 0x000010, "Wrong size on FHWDiminishingReturnsTracker");
static_assert(offsetof(FHWDiminishingReturnsTracker, FiringInstanceId) == 0x000000, "Member 'FHWDiminishingReturnsTracker::FiringInstanceId' has a wrong offset!");
static_assert(offsetof(FHWDiminishingReturnsTracker, WorldTimeApplied) == 0x000008, "Member 'FHWDiminishingReturnsTracker::WorldTimeApplied' has a wrong offset!");
static_assert(offsetof(FHWDiminishingReturnsTracker, DR_Stacks) == 0x00000C, "Member 'FHWDiminishingReturnsTracker::DR_Stacks' has a wrong offset!");

// ScriptStruct Hemingway.HWAssistCandidate
// 0x0010 (0x0010 - 0x0000)
struct FHWAssistCandidate final
{
public:
	class AHWCharacter_PlayableCharacter*         AssistingCharacter;                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecentDamageTimestamp;                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAssistCandidate) == 0x000008, "Wrong alignment on FHWAssistCandidate");
static_assert(sizeof(FHWAssistCandidate) == 0x000010, "Wrong size on FHWAssistCandidate");
static_assert(offsetof(FHWAssistCandidate, AssistingCharacter) == 0x000000, "Member 'FHWAssistCandidate::AssistingCharacter' has a wrong offset!");
static_assert(offsetof(FHWAssistCandidate, RecentDamageTimestamp) == 0x000008, "Member 'FHWAssistCandidate::RecentDamageTimestamp' has a wrong offset!");

// ScriptStruct Hemingway.HWForcedCharacterFiringInfo
// 0x0020 (0x0020 - 0x0000)
struct FHWForcedCharacterFiringInfo final
{
public:
	struct FActiveGameplayEffectHandle            ActiveEffectHandle;                                // 0x0000(0x0008)(BlueprintVisible, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWForcedCharacterFiringCategory              FiringCategory;                                    // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWForcedFiringEffectTrackingData      TrackingData;                                      // 0x000C(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWForcedCharacterFiringInfo) == 0x000004, "Wrong alignment on FHWForcedCharacterFiringInfo");
static_assert(sizeof(FHWForcedCharacterFiringInfo) == 0x000020, "Wrong size on FHWForcedCharacterFiringInfo");
static_assert(offsetof(FHWForcedCharacterFiringInfo, ActiveEffectHandle) == 0x000000, "Member 'FHWForcedCharacterFiringInfo::ActiveEffectHandle' has a wrong offset!");
static_assert(offsetof(FHWForcedCharacterFiringInfo, FiringCategory) == 0x000008, "Member 'FHWForcedCharacterFiringInfo::FiringCategory' has a wrong offset!");
static_assert(offsetof(FHWForcedCharacterFiringInfo, TrackingData) == 0x00000C, "Member 'FHWForcedCharacterFiringInfo::TrackingData' has a wrong offset!");

// ScriptStruct Hemingway.HWGameplayEffectContext
// 0x0060 (0x00E0 - 0x0080)
struct FHWGameplayEffectContext final : public FGameplayEffectContext
{
public:
	TWeakObjectPtr<class AActor>                  OriginalInstigator;                                // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAbilitySystemComponent> OriginalInstigatorAbilitySystemComponent;          // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  StatsInstigator;                                   // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAbilitySystemComponent> StatsInstigatorAbilitySystemComponent;             // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x00A0(0x0008)(RepSkip, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHWEquipmentInstance>    EquipmentInstance;                                 // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHWEquipmentItem>        OriginalEquipmentItem;                             // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProjectileEffectCauserInstanceId;                  // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetVector;                                      // 0x00C8(0x0018)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHWGameplayEffectContext) == 0x000008, "Wrong alignment on FHWGameplayEffectContext");
static_assert(sizeof(FHWGameplayEffectContext) == 0x0000E0, "Wrong size on FHWGameplayEffectContext");
static_assert(offsetof(FHWGameplayEffectContext, OriginalInstigator) == 0x000080, "Member 'FHWGameplayEffectContext::OriginalInstigator' has a wrong offset!");
static_assert(offsetof(FHWGameplayEffectContext, OriginalInstigatorAbilitySystemComponent) == 0x000088, "Member 'FHWGameplayEffectContext::OriginalInstigatorAbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(FHWGameplayEffectContext, StatsInstigator) == 0x000090, "Member 'FHWGameplayEffectContext::StatsInstigator' has a wrong offset!");
static_assert(offsetof(FHWGameplayEffectContext, StatsInstigatorAbilitySystemComponent) == 0x000098, "Member 'FHWGameplayEffectContext::StatsInstigatorAbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(FHWGameplayEffectContext, FiringInstanceId) == 0x0000A0, "Member 'FHWGameplayEffectContext::FiringInstanceId' has a wrong offset!");
static_assert(offsetof(FHWGameplayEffectContext, EquipmentInstance) == 0x0000A8, "Member 'FHWGameplayEffectContext::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(FHWGameplayEffectContext, OriginalEquipmentItem) == 0x0000B0, "Member 'FHWGameplayEffectContext::OriginalEquipmentItem' has a wrong offset!");
static_assert(offsetof(FHWGameplayEffectContext, ProjectileEffectCauserInstanceId) == 0x0000C0, "Member 'FHWGameplayEffectContext::ProjectileEffectCauserInstanceId' has a wrong offset!");
static_assert(offsetof(FHWGameplayEffectContext, TargetVector) == 0x0000C8, "Member 'FHWGameplayEffectContext::TargetVector' has a wrong offset!");

// ScriptStruct Hemingway.HWProjectileDeployableConfig
// 0x0010 (0x0010 - 0x0000)
struct FHWProjectileDeployableConfig final
{
public:
	class UHWAbilityAttackSettings_Deployable*    DeployableSettings;                                // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWProjectileSpawnDeployableTrigger           SpawnTrigger;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnOnGround;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectTargetVectorOnTravelPath;                  // 0x000A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWGroundTargetValidationType                 GroundValidationBehavior;                          // 0x000B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualCollisionRadius;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHWProjectileDeployableConfig) == 0x000008, "Wrong alignment on FHWProjectileDeployableConfig");
static_assert(sizeof(FHWProjectileDeployableConfig) == 0x000010, "Wrong size on FHWProjectileDeployableConfig");
static_assert(offsetof(FHWProjectileDeployableConfig, DeployableSettings) == 0x000000, "Member 'FHWProjectileDeployableConfig::DeployableSettings' has a wrong offset!");
static_assert(offsetof(FHWProjectileDeployableConfig, SpawnTrigger) == 0x000008, "Member 'FHWProjectileDeployableConfig::SpawnTrigger' has a wrong offset!");
static_assert(offsetof(FHWProjectileDeployableConfig, bSpawnOnGround) == 0x000009, "Member 'FHWProjectileDeployableConfig::bSpawnOnGround' has a wrong offset!");
static_assert(offsetof(FHWProjectileDeployableConfig, bProjectTargetVectorOnTravelPath) == 0x00000A, "Member 'FHWProjectileDeployableConfig::bProjectTargetVectorOnTravelPath' has a wrong offset!");
static_assert(offsetof(FHWProjectileDeployableConfig, GroundValidationBehavior) == 0x00000B, "Member 'FHWProjectileDeployableConfig::GroundValidationBehavior' has a wrong offset!");
static_assert(offsetof(FHWProjectileDeployableConfig, ManualCollisionRadius) == 0x00000C, "Member 'FHWProjectileDeployableConfig::ManualCollisionRadius' has a wrong offset!");

// ScriptStruct Hemingway.HWGameplayEffectTableRow
// 0x0008 (0x0010 - 0x0008)
struct FHWGameplayEffectTableRow final : public FTableRowBase
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWGameplayEffectTableRow) == 0x000008, "Wrong alignment on FHWGameplayEffectTableRow");
static_assert(sizeof(FHWGameplayEffectTableRow) == 0x000010, "Wrong size on FHWGameplayEffectTableRow");
static_assert(offsetof(FHWGameplayEffectTableRow, GameplayEffect) == 0x000008, "Member 'FHWGameplayEffectTableRow::GameplayEffect' has a wrong offset!");

// ScriptStruct Hemingway.PendingLoginDetails
// 0x0058 (0x0058 - 0x0000)
struct FPendingLoginDetails final
{
public:
	class URH_IpConnection*                       PlayerConnection;                                  // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ErrorMessage;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       UniqueID;                                          // 0x0018(0x0030)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPendingLoginDetails) == 0x000008, "Wrong alignment on FPendingLoginDetails");
static_assert(sizeof(FPendingLoginDetails) == 0x000058, "Wrong size on FPendingLoginDetails");
static_assert(offsetof(FPendingLoginDetails, PlayerConnection) == 0x000000, "Member 'FPendingLoginDetails::PlayerConnection' has a wrong offset!");
static_assert(offsetof(FPendingLoginDetails, ErrorMessage) == 0x000008, "Member 'FPendingLoginDetails::ErrorMessage' has a wrong offset!");
static_assert(offsetof(FPendingLoginDetails, UniqueID) == 0x000018, "Member 'FPendingLoginDetails::UniqueID' has a wrong offset!");

// ScriptStruct Hemingway.CircularWedgeTargetingData
// 0x0080 (0x0080 - 0x0000)
struct FCircularWedgeTargetingData final
{
public:
	float                                         Angle;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumRadius;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       AimData;                                           // 0x0010(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MaxTargetsAllowed;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTargetDataFilterHandle> PriorityFilters;                                  // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	ETargetingLocationPriorityBehavior            LocationPriorityBehavior;                          // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationPriorityRadiusThreshold;                   // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        AcceptableTargetFilter;                            // 0x0058(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCircularWedgeTargetingData) == 0x000008, "Wrong alignment on FCircularWedgeTargetingData");
static_assert(sizeof(FCircularWedgeTargetingData) == 0x000080, "Wrong size on FCircularWedgeTargetingData");
static_assert(offsetof(FCircularWedgeTargetingData, Angle) == 0x000000, "Member 'FCircularWedgeTargetingData::Angle' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, Radius) == 0x000004, "Member 'FCircularWedgeTargetingData::Radius' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, MinimumRadius) == 0x000008, "Member 'FCircularWedgeTargetingData::MinimumRadius' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, Height) == 0x00000C, "Member 'FCircularWedgeTargetingData::Height' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, AimData) == 0x000010, "Member 'FCircularWedgeTargetingData::AimData' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, MaxTargetsAllowed) == 0x000038, "Member 'FCircularWedgeTargetingData::MaxTargetsAllowed' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, PriorityFilters) == 0x000040, "Member 'FCircularWedgeTargetingData::PriorityFilters' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, LocationPriorityBehavior) == 0x000050, "Member 'FCircularWedgeTargetingData::LocationPriorityBehavior' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, LocationPriorityRadiusThreshold) == 0x000054, "Member 'FCircularWedgeTargetingData::LocationPriorityRadiusThreshold' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, AcceptableTargetFilter) == 0x000058, "Member 'FCircularWedgeTargetingData::AcceptableTargetFilter' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, ActorsToIgnore) == 0x000068, "Member 'FCircularWedgeTargetingData::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(FCircularWedgeTargetingData, bDrawDebug) == 0x000078, "Member 'FCircularWedgeTargetingData::bDrawDebug' has a wrong offset!");

// ScriptStruct Hemingway.HWPostProcessFloatCurve
// 0x0010 (0x0010 - 0x0000)
struct FHWPostProcessFloatCurve final
{
public:
	class UCurveFloat*                            FloatCurve;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FloatParameterName;                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPostProcessFloatCurve) == 0x000008, "Wrong alignment on FHWPostProcessFloatCurve");
static_assert(sizeof(FHWPostProcessFloatCurve) == 0x000010, "Wrong size on FHWPostProcessFloatCurve");
static_assert(offsetof(FHWPostProcessFloatCurve, FloatCurve) == 0x000000, "Member 'FHWPostProcessFloatCurve::FloatCurve' has a wrong offset!");
static_assert(offsetof(FHWPostProcessFloatCurve, FloatParameterName) == 0x000008, "Member 'FHWPostProcessFloatCurve::FloatParameterName' has a wrong offset!");

// ScriptStruct Hemingway.HWPostProcessColorCurve
// 0x0010 (0x0010 - 0x0000)
struct FHWPostProcessColorCurve final
{
public:
	class UCurveLinearColor*                      ColorCurve;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorParameterName;                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPostProcessColorCurve) == 0x000008, "Wrong alignment on FHWPostProcessColorCurve");
static_assert(sizeof(FHWPostProcessColorCurve) == 0x000010, "Wrong size on FHWPostProcessColorCurve");
static_assert(offsetof(FHWPostProcessColorCurve, ColorCurve) == 0x000000, "Member 'FHWPostProcessColorCurve::ColorCurve' has a wrong offset!");
static_assert(offsetof(FHWPostProcessColorCurve, ColorParameterName) == 0x000008, "Member 'FHWPostProcessColorCurve::ColorParameterName' has a wrong offset!");

// ScriptStruct Hemingway.HWSpecialEffect
// 0x0070 (0x0070 - 0x0000)
struct FHWSpecialEffect final
{
public:
	class FName                                   FXID;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalised;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectEndTime;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopStartTime;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopEndTime;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveOnForwardComplete;                          // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveOnReverseComplete;                          // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWPostProcessFloatCurve>       FloatCurves;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWPostProcessColorCurve>       ColorCurves;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWFXCurveComponent>        FXCurveClass;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       SkinningAssetKey;                                  // 0x0048(0x001C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                EffectAsset;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSpecialEffect) == 0x000008, "Wrong alignment on FHWSpecialEffect");
static_assert(sizeof(FHWSpecialEffect) == 0x000070, "Wrong size on FHWSpecialEffect");
static_assert(offsetof(FHWSpecialEffect, FXID) == 0x000000, "Member 'FHWSpecialEffect::FXID' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, bNormalised) == 0x000008, "Member 'FHWSpecialEffect::bNormalised' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, EffectEndTime) == 0x00000C, "Member 'FHWSpecialEffect::EffectEndTime' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, bLoop) == 0x000010, "Member 'FHWSpecialEffect::bLoop' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, LoopStartTime) == 0x000014, "Member 'FHWSpecialEffect::LoopStartTime' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, LoopEndTime) == 0x000018, "Member 'FHWSpecialEffect::LoopEndTime' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, bRemoveOnForwardComplete) == 0x00001C, "Member 'FHWSpecialEffect::bRemoveOnForwardComplete' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, bRemoveOnReverseComplete) == 0x00001D, "Member 'FHWSpecialEffect::bRemoveOnReverseComplete' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, FloatCurves) == 0x000020, "Member 'FHWSpecialEffect::FloatCurves' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, ColorCurves) == 0x000030, "Member 'FHWSpecialEffect::ColorCurves' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, FXCurveClass) == 0x000040, "Member 'FHWSpecialEffect::FXCurveClass' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, SkinningAssetKey) == 0x000048, "Member 'FHWSpecialEffect::SkinningAssetKey' has a wrong offset!");
static_assert(offsetof(FHWSpecialEffect, EffectAsset) == 0x000068, "Member 'FHWSpecialEffect::EffectAsset' has a wrong offset!");

// ScriptStruct Hemingway.LineAttackTargetingData
// 0x0078 (0x0078 - 0x0000)
struct FLineAttackTargetingData final
{
public:
	float                                         Width;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       AimData;                                           // 0x0008(0x0028)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	int32                                         AimIndex;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTargetsAllowed;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTargetDataFilterHandle> PriorityFilters;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	ETargetingLocationPriorityBehavior            LocationPriorityBehavior;                          // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationPriorityRadiusThreshold;                   // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        AcceptableTargetFilter;                            // 0x0050(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLineAttackTargetingData) == 0x000008, "Wrong alignment on FLineAttackTargetingData");
static_assert(sizeof(FLineAttackTargetingData) == 0x000078, "Wrong size on FLineAttackTargetingData");
static_assert(offsetof(FLineAttackTargetingData, Width) == 0x000000, "Member 'FLineAttackTargetingData::Width' has a wrong offset!");
static_assert(offsetof(FLineAttackTargetingData, Height) == 0x000004, "Member 'FLineAttackTargetingData::Height' has a wrong offset!");
static_assert(offsetof(FLineAttackTargetingData, AimData) == 0x000008, "Member 'FLineAttackTargetingData::AimData' has a wrong offset!");
static_assert(offsetof(FLineAttackTargetingData, AimIndex) == 0x000030, "Member 'FLineAttackTargetingData::AimIndex' has a wrong offset!");
static_assert(offsetof(FLineAttackTargetingData, MaxTargetsAllowed) == 0x000034, "Member 'FLineAttackTargetingData::MaxTargetsAllowed' has a wrong offset!");
static_assert(offsetof(FLineAttackTargetingData, PriorityFilters) == 0x000038, "Member 'FLineAttackTargetingData::PriorityFilters' has a wrong offset!");
static_assert(offsetof(FLineAttackTargetingData, LocationPriorityBehavior) == 0x000048, "Member 'FLineAttackTargetingData::LocationPriorityBehavior' has a wrong offset!");
static_assert(offsetof(FLineAttackTargetingData, LocationPriorityRadiusThreshold) == 0x00004C, "Member 'FLineAttackTargetingData::LocationPriorityRadiusThreshold' has a wrong offset!");
static_assert(offsetof(FLineAttackTargetingData, AcceptableTargetFilter) == 0x000050, "Member 'FLineAttackTargetingData::AcceptableTargetFilter' has a wrong offset!");
static_assert(offsetof(FLineAttackTargetingData, ActorsToIgnore) == 0x000060, "Member 'FLineAttackTargetingData::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(FLineAttackTargetingData, bDrawDebug) == 0x000070, "Member 'FLineAttackTargetingData::bDrawDebug' has a wrong offset!");

// ScriptStruct Hemingway.ProjectileAttackTargetingData
// 0x0078 (0x0078 - 0x0000)
struct FProjectileAttackTargetingData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       AimData;                                           // 0x0010(0x0028)(NativeAccessSpecifierPublic)
	int32                                         MaxTargetsAllowed;                                 // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTargetDataFilterHandle> PriorityFilters;                                  // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ETargetingLocationPriorityBehavior            LocationPriorityBehavior;                          // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationPriorityRadiusThreshold;                   // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        AcceptableTargetFilter;                            // 0x0058(0x0010)(NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileAttackTargetingData) == 0x000008, "Wrong alignment on FProjectileAttackTargetingData");
static_assert(sizeof(FProjectileAttackTargetingData) == 0x000078, "Wrong size on FProjectileAttackTargetingData");
static_assert(offsetof(FProjectileAttackTargetingData, AimData) == 0x000010, "Member 'FProjectileAttackTargetingData::AimData' has a wrong offset!");
static_assert(offsetof(FProjectileAttackTargetingData, MaxTargetsAllowed) == 0x000038, "Member 'FProjectileAttackTargetingData::MaxTargetsAllowed' has a wrong offset!");
static_assert(offsetof(FProjectileAttackTargetingData, PriorityFilters) == 0x000040, "Member 'FProjectileAttackTargetingData::PriorityFilters' has a wrong offset!");
static_assert(offsetof(FProjectileAttackTargetingData, LocationPriorityBehavior) == 0x000050, "Member 'FProjectileAttackTargetingData::LocationPriorityBehavior' has a wrong offset!");
static_assert(offsetof(FProjectileAttackTargetingData, LocationPriorityRadiusThreshold) == 0x000054, "Member 'FProjectileAttackTargetingData::LocationPriorityRadiusThreshold' has a wrong offset!");
static_assert(offsetof(FProjectileAttackTargetingData, AcceptableTargetFilter) == 0x000058, "Member 'FProjectileAttackTargetingData::AcceptableTargetFilter' has a wrong offset!");
static_assert(offsetof(FProjectileAttackTargetingData, ActorsToIgnore) == 0x000068, "Member 'FProjectileAttackTargetingData::ActorsToIgnore' has a wrong offset!");

// ScriptStruct Hemingway.HWBariBellPushInfo
// 0x0018 (0x0018 - 0x0000)
struct FHWBariBellPushInfo final
{
public:
	struct FVector                                PushDirection;                                     // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWBariBellPushInfo) == 0x000008, "Wrong alignment on FHWBariBellPushInfo");
static_assert(sizeof(FHWBariBellPushInfo) == 0x000018, "Wrong size on FHWBariBellPushInfo");
static_assert(offsetof(FHWBariBellPushInfo, PushDirection) == 0x000000, "Member 'FHWBariBellPushInfo::PushDirection' has a wrong offset!");

// ScriptStruct Hemingway.HWProjectileDestroyPredictionInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FHWProjectileDestroyPredictionInfo final
{
public:
	struct FHitResult                             DestroyHit;                                        // 0x0000(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EHWDestroyProjectileReason                    DestroyReason;                                     // 0x00E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWProjectileDestroyPredictionInfo) == 0x000008, "Wrong alignment on FHWProjectileDestroyPredictionInfo");
static_assert(sizeof(FHWProjectileDestroyPredictionInfo) == 0x0000F0, "Wrong size on FHWProjectileDestroyPredictionInfo");
static_assert(offsetof(FHWProjectileDestroyPredictionInfo, DestroyHit) == 0x000000, "Member 'FHWProjectileDestroyPredictionInfo::DestroyHit' has a wrong offset!");
static_assert(offsetof(FHWProjectileDestroyPredictionInfo, DestroyReason) == 0x0000E8, "Member 'FHWProjectileDestroyPredictionInfo::DestroyReason' has a wrong offset!");

// ScriptStruct Hemingway.HWTargetData_LocationInfo
// 0x0160 (0x02B0 - 0x0150)
struct FHWTargetData_LocationInfo final : public FGameplayAbilityTargetData_LocationInfo
{
public:
	bool                                          bIsValidAim;                                       // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStoreLastValidLocation;                           // 0x0151(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLastValidLocation;                             // 0x0152(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_153[0xD];                                      // 0x0153(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetData_LocationInfo LastValidLocation;                                // 0x0160(0x0150)(RepSkip, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHWTargetData_LocationInfo) == 0x000010, "Wrong alignment on FHWTargetData_LocationInfo");
static_assert(sizeof(FHWTargetData_LocationInfo) == 0x0002B0, "Wrong size on FHWTargetData_LocationInfo");
static_assert(offsetof(FHWTargetData_LocationInfo, bIsValidAim) == 0x000150, "Member 'FHWTargetData_LocationInfo::bIsValidAim' has a wrong offset!");
static_assert(offsetof(FHWTargetData_LocationInfo, bStoreLastValidLocation) == 0x000151, "Member 'FHWTargetData_LocationInfo::bStoreLastValidLocation' has a wrong offset!");
static_assert(offsetof(FHWTargetData_LocationInfo, bHasLastValidLocation) == 0x000152, "Member 'FHWTargetData_LocationInfo::bHasLastValidLocation' has a wrong offset!");
static_assert(offsetof(FHWTargetData_LocationInfo, LastValidLocation) == 0x000160, "Member 'FHWTargetData_LocationInfo::LastValidLocation' has a wrong offset!");

// ScriptStruct Hemingway.HWGamePhaseConfig
// 0x0058 (0x0058 - 0x0000)
struct FHWGamePhaseConfig final
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseDuration;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseStartTime;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhaseEndsMatch;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhaseCalculatesTeamPlacement;                     // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhaseAwardsDeserterPenalty;                       // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhaseSubmitsMatchData;                            // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhaseUploadsInstanceLog;                          // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhaseUpdatesRank;                                 // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhaseUpdatesRolePriority;                         // 0x0016(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhaseCachesParties;                               // 0x0017(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhaseReturnsToMainLobby;                          // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVGSInputBypassesChecks;                           // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TimeOutTriggersPhase;                              // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWGamePhaseAppliedEffect>      PhaseEffects;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWPhaseLogic>              PhaseLogicClass;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetMap;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncOnPlayersReady;                               // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWGamePhaseConfig) == 0x000008, "Wrong alignment on FHWGamePhaseConfig");
static_assert(sizeof(FHWGamePhaseConfig) == 0x000058, "Wrong size on FHWGamePhaseConfig");
static_assert(offsetof(FHWGamePhaseConfig, PhaseTag) == 0x000000, "Member 'FHWGamePhaseConfig::PhaseTag' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, PhaseDuration) == 0x000008, "Member 'FHWGamePhaseConfig::PhaseDuration' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, PhaseStartTime) == 0x00000C, "Member 'FHWGamePhaseConfig::PhaseStartTime' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bPhaseEndsMatch) == 0x000010, "Member 'FHWGamePhaseConfig::bPhaseEndsMatch' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bPhaseCalculatesTeamPlacement) == 0x000011, "Member 'FHWGamePhaseConfig::bPhaseCalculatesTeamPlacement' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bPhaseAwardsDeserterPenalty) == 0x000012, "Member 'FHWGamePhaseConfig::bPhaseAwardsDeserterPenalty' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bPhaseSubmitsMatchData) == 0x000013, "Member 'FHWGamePhaseConfig::bPhaseSubmitsMatchData' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bPhaseUploadsInstanceLog) == 0x000014, "Member 'FHWGamePhaseConfig::bPhaseUploadsInstanceLog' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bPhaseUpdatesRank) == 0x000015, "Member 'FHWGamePhaseConfig::bPhaseUpdatesRank' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bPhaseUpdatesRolePriority) == 0x000016, "Member 'FHWGamePhaseConfig::bPhaseUpdatesRolePriority' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bPhaseCachesParties) == 0x000017, "Member 'FHWGamePhaseConfig::bPhaseCachesParties' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bPhaseReturnsToMainLobby) == 0x000018, "Member 'FHWGamePhaseConfig::bPhaseReturnsToMainLobby' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bVGSInputBypassesChecks) == 0x000019, "Member 'FHWGamePhaseConfig::bVGSInputBypassesChecks' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, TimeOutTriggersPhase) == 0x00001C, "Member 'FHWGamePhaseConfig::TimeOutTriggersPhase' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, PhaseEffects) == 0x000028, "Member 'FHWGamePhaseConfig::PhaseEffects' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, PhaseLogicClass) == 0x000038, "Member 'FHWGamePhaseConfig::PhaseLogicClass' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, TargetMap) == 0x000040, "Member 'FHWGamePhaseConfig::TargetMap' has a wrong offset!");
static_assert(offsetof(FHWGamePhaseConfig, bSyncOnPlayersReady) == 0x000050, "Member 'FHWGamePhaseConfig::bSyncOnPlayersReady' has a wrong offset!");

// ScriptStruct Hemingway.HWTargetData_LockOn
// 0x0000 (0x0150 - 0x0150)
struct FHWTargetData_LockOn final : public FGameplayAbilityTargetData_LocationInfo
{
};
static_assert(alignof(FHWTargetData_LockOn) == 0x000010, "Wrong alignment on FHWTargetData_LockOn");
static_assert(sizeof(FHWTargetData_LockOn) == 0x000150, "Wrong size on FHWTargetData_LockOn");

// ScriptStruct Hemingway.HWSimulatedSpawnActorTaskItem
// 0x000C (0x0018 - 0x000C)
struct FHWSimulatedSpawnActorTaskItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_SimulatedSpawnActor*     SpawnActorTask;                                    // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSimulatedSpawnActorTaskItem) == 0x000008, "Wrong alignment on FHWSimulatedSpawnActorTaskItem");
static_assert(sizeof(FHWSimulatedSpawnActorTaskItem) == 0x000018, "Wrong size on FHWSimulatedSpawnActorTaskItem");
static_assert(offsetof(FHWSimulatedSpawnActorTaskItem, SpawnActorTask) == 0x000010, "Member 'FHWSimulatedSpawnActorTaskItem::SpawnActorTask' has a wrong offset!");

// ScriptStruct Hemingway.HWMaterialOverlayHandle
// 0x0004 (0x0004 - 0x0000)
struct FHWMaterialOverlayHandle final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWMaterialOverlayHandle) == 0x000004, "Wrong alignment on FHWMaterialOverlayHandle");
static_assert(sizeof(FHWMaterialOverlayHandle) == 0x000004, "Wrong size on FHWMaterialOverlayHandle");
static_assert(offsetof(FHWMaterialOverlayHandle, ID) == 0x000000, "Member 'FHWMaterialOverlayHandle::ID' has a wrong offset!");

// ScriptStruct Hemingway.HWMaterialOverlayInfo
// 0x0010 (0x0010 - 0x0000)
struct FHWMaterialOverlayInfo final
{
public:
	class UHWSkeletalMeshComponent*               MeshComponent;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWMaterialOverlayHandle               OverlayHandle;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWMaterialOverlayInfo) == 0x000008, "Wrong alignment on FHWMaterialOverlayInfo");
static_assert(sizeof(FHWMaterialOverlayInfo) == 0x000010, "Wrong size on FHWMaterialOverlayInfo");
static_assert(offsetof(FHWMaterialOverlayInfo, MeshComponent) == 0x000000, "Member 'FHWMaterialOverlayInfo::MeshComponent' has a wrong offset!");
static_assert(offsetof(FHWMaterialOverlayInfo, OverlayHandle) == 0x000008, "Member 'FHWMaterialOverlayInfo::OverlayHandle' has a wrong offset!");

// ScriptStruct Hemingway.HWSimulatedSpawnActorTaskList
// 0x0020 (0x0128 - 0x0108)
struct FHWSimulatedSpawnActorTaskList final : public FFastArraySerializer
{
public:
	TArray<struct FHWSimulatedSpawnActorTaskItem> Tasks;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         CurrentTaskIndex;                                  // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CachedMaxTasks;                                    // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHWAbilitySystemComponent*              OwningAbilitySystem;                               // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHWSimulatedSpawnActorTaskList) == 0x000008, "Wrong alignment on FHWSimulatedSpawnActorTaskList");
static_assert(sizeof(FHWSimulatedSpawnActorTaskList) == 0x000128, "Wrong size on FHWSimulatedSpawnActorTaskList");
static_assert(offsetof(FHWSimulatedSpawnActorTaskList, Tasks) == 0x000108, "Member 'FHWSimulatedSpawnActorTaskList::Tasks' has a wrong offset!");
static_assert(offsetof(FHWSimulatedSpawnActorTaskList, CurrentTaskIndex) == 0x000118, "Member 'FHWSimulatedSpawnActorTaskList::CurrentTaskIndex' has a wrong offset!");
static_assert(offsetof(FHWSimulatedSpawnActorTaskList, CachedMaxTasks) == 0x00011C, "Member 'FHWSimulatedSpawnActorTaskList::CachedMaxTasks' has a wrong offset!");
static_assert(offsetof(FHWSimulatedSpawnActorTaskList, OwningAbilitySystem) == 0x000120, "Member 'FHWSimulatedSpawnActorTaskList::OwningAbilitySystem' has a wrong offset!");

// ScriptStruct Hemingway.HWWaitForAttributeChangedConfig
// 0x00D0 (0x00D0 - 0x0000)
struct FHWWaitForAttributeChangedConfig final
{
public:
	struct FGameplayAttribute                     AttributeToListenFor;                              // 0x0000(0x0038)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0038(0x0088)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bListenForComparison;                              // 0x00C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaitAttributeChangeComparison                ComparisonType;                                    // 0x00C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComparisonValue;                                   // 0x00C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnce;                                      // 0x00C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWWaitForAttributeChangedConfig) == 0x000008, "Wrong alignment on FHWWaitForAttributeChangedConfig");
static_assert(sizeof(FHWWaitForAttributeChangedConfig) == 0x0000D0, "Wrong size on FHWWaitForAttributeChangedConfig");
static_assert(offsetof(FHWWaitForAttributeChangedConfig, AttributeToListenFor) == 0x000000, "Member 'FHWWaitForAttributeChangedConfig::AttributeToListenFor' has a wrong offset!");
static_assert(offsetof(FHWWaitForAttributeChangedConfig, TagRequirements) == 0x000038, "Member 'FHWWaitForAttributeChangedConfig::TagRequirements' has a wrong offset!");
static_assert(offsetof(FHWWaitForAttributeChangedConfig, bListenForComparison) == 0x0000C0, "Member 'FHWWaitForAttributeChangedConfig::bListenForComparison' has a wrong offset!");
static_assert(offsetof(FHWWaitForAttributeChangedConfig, ComparisonType) == 0x0000C1, "Member 'FHWWaitForAttributeChangedConfig::ComparisonType' has a wrong offset!");
static_assert(offsetof(FHWWaitForAttributeChangedConfig, ComparisonValue) == 0x0000C4, "Member 'FHWWaitForAttributeChangedConfig::ComparisonValue' has a wrong offset!");
static_assert(offsetof(FHWWaitForAttributeChangedConfig, bTriggerOnce) == 0x0000C8, "Member 'FHWWaitForAttributeChangedConfig::bTriggerOnce' has a wrong offset!");

// ScriptStruct Hemingway.HWMappingContextPreset
// 0x0038 (0x0038 - 0x0000)
struct FHWMappingContextPreset final
{
public:
	class UInputMappingContext*                   MappingContext;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LookupName;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsDefaultPreset;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWMappingContextPreset) == 0x000008, "Wrong alignment on FHWMappingContextPreset");
static_assert(sizeof(FHWMappingContextPreset) == 0x000038, "Wrong size on FHWMappingContextPreset");
static_assert(offsetof(FHWMappingContextPreset, MappingContext) == 0x000000, "Member 'FHWMappingContextPreset::MappingContext' has a wrong offset!");
static_assert(offsetof(FHWMappingContextPreset, LookupName) == 0x000008, "Member 'FHWMappingContextPreset::LookupName' has a wrong offset!");
static_assert(offsetof(FHWMappingContextPreset, DisplayName) == 0x000018, "Member 'FHWMappingContextPreset::DisplayName' has a wrong offset!");
static_assert(offsetof(FHWMappingContextPreset, bIsDefaultPreset) == 0x000030, "Member 'FHWMappingContextPreset::bIsDefaultPreset' has a wrong offset!");

// ScriptStruct Hemingway.FactoryBotEntry
// 0x00B0 (0x00B8 - 0x0008)
struct FFactoryBotEntry final : public FTableRowBase
{
public:
	struct FHWAIBotConfig                         botConfig;                                         // 0x0008(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactoryBotEntry) == 0x000008, "Wrong alignment on FFactoryBotEntry");
static_assert(sizeof(FFactoryBotEntry) == 0x0000B8, "Wrong size on FFactoryBotEntry");
static_assert(offsetof(FFactoryBotEntry, botConfig) == 0x000008, "Member 'FFactoryBotEntry::botConfig' has a wrong offset!");

// ScriptStruct Hemingway.FactorySpawnEntry
// 0x0018 (0x0018 - 0x0000)
struct FFactorySpawnEntry final
{
public:
	struct FDataTableRowHandle                    BotToSpawn;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumToSpawn;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnRewardOnDeath;                               // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFactorySpawnEntry) == 0x000008, "Wrong alignment on FFactorySpawnEntry");
static_assert(sizeof(FFactorySpawnEntry) == 0x000018, "Wrong size on FFactorySpawnEntry");
static_assert(offsetof(FFactorySpawnEntry, BotToSpawn) == 0x000000, "Member 'FFactorySpawnEntry::BotToSpawn' has a wrong offset!");
static_assert(offsetof(FFactorySpawnEntry, NumToSpawn) == 0x000010, "Member 'FFactorySpawnEntry::NumToSpawn' has a wrong offset!");
static_assert(offsetof(FFactorySpawnEntry, bSpawnRewardOnDeath) == 0x000014, "Member 'FFactorySpawnEntry::bSpawnRewardOnDeath' has a wrong offset!");

// ScriptStruct Hemingway.HWEffectsGrantingVisionForIndividualEntry
// 0x0064 (0x0070 - 0x000C)
struct FHWEffectsGrantingVisionForIndividualEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWVisibilityComponent*                 VisibilityComponentGrantingVisionTo;               // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasValidEffectGrantingVision;                     // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGameplayAbilitySpecHandle>       AbilityGrantingVisionHandles;                      // 0x0020(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHWEffectsGrantingVisionForIndividualEntry) == 0x000008, "Wrong alignment on FHWEffectsGrantingVisionForIndividualEntry");
static_assert(sizeof(FHWEffectsGrantingVisionForIndividualEntry) == 0x000070, "Wrong size on FHWEffectsGrantingVisionForIndividualEntry");
static_assert(offsetof(FHWEffectsGrantingVisionForIndividualEntry, VisibilityComponentGrantingVisionTo) == 0x000010, "Member 'FHWEffectsGrantingVisionForIndividualEntry::VisibilityComponentGrantingVisionTo' has a wrong offset!");
static_assert(offsetof(FHWEffectsGrantingVisionForIndividualEntry, bHasValidEffectGrantingVision) == 0x000018, "Member 'FHWEffectsGrantingVisionForIndividualEntry::bHasValidEffectGrantingVision' has a wrong offset!");
static_assert(offsetof(FHWEffectsGrantingVisionForIndividualEntry, AbilityGrantingVisionHandles) == 0x000020, "Member 'FHWEffectsGrantingVisionForIndividualEntry::AbilityGrantingVisionHandles' has a wrong offset!");

// ScriptStruct Hemingway.FactorySpawnWaveInfo
// 0x0020 (0x0028 - 0x0008)
struct FFactorySpawnWaveInfo final : public FTableRowBase
{
public:
	TArray<struct FFactorySpawnEntry>             BotsToSpawn;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RespawnDelayPerBot;                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AHWAISquadManager>          SquadManagerBP;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactorySpawnWaveInfo) == 0x000008, "Wrong alignment on FFactorySpawnWaveInfo");
static_assert(sizeof(FFactorySpawnWaveInfo) == 0x000028, "Wrong size on FFactorySpawnWaveInfo");
static_assert(offsetof(FFactorySpawnWaveInfo, BotsToSpawn) == 0x000008, "Member 'FFactorySpawnWaveInfo::BotsToSpawn' has a wrong offset!");
static_assert(offsetof(FFactorySpawnWaveInfo, RespawnDelayPerBot) == 0x000018, "Member 'FFactorySpawnWaveInfo::RespawnDelayPerBot' has a wrong offset!");
static_assert(offsetof(FFactorySpawnWaveInfo, SquadManagerBP) == 0x000020, "Member 'FFactorySpawnWaveInfo::SquadManagerBP' has a wrong offset!");

// ScriptStruct Hemingway.FactorySpawnWaveTimeInfo
// 0x0008 (0x0008 - 0x0000)
struct FFactorySpawnWaveTimeInfo final
{
public:
	float                                         ExpectedWaveSpawnTime;                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentWaveSpawnDelay;                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactorySpawnWaveTimeInfo) == 0x000004, "Wrong alignment on FFactorySpawnWaveTimeInfo");
static_assert(sizeof(FFactorySpawnWaveTimeInfo) == 0x000008, "Wrong size on FFactorySpawnWaveTimeInfo");
static_assert(offsetof(FFactorySpawnWaveTimeInfo, ExpectedWaveSpawnTime) == 0x000000, "Member 'FFactorySpawnWaveTimeInfo::ExpectedWaveSpawnTime' has a wrong offset!");
static_assert(offsetof(FFactorySpawnWaveTimeInfo, CurrentWaveSpawnDelay) == 0x000004, "Member 'FFactorySpawnWaveTimeInfo::CurrentWaveSpawnDelay' has a wrong offset!");

// ScriptStruct Hemingway.HWSkeletalMeshRef
// 0x0020 (0x0020 - 0x0000)
struct FHWSkeletalMeshRef final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          SkelMesh;                                          // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 AnimInstanceClassRef;                              // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWSkeletalMeshRef) == 0x000008, "Wrong alignment on FHWSkeletalMeshRef");
static_assert(sizeof(FHWSkeletalMeshRef) == 0x000020, "Wrong size on FHWSkeletalMeshRef");
static_assert(offsetof(FHWSkeletalMeshRef, SkelMesh) == 0x000008, "Member 'FHWSkeletalMeshRef::SkelMesh' has a wrong offset!");
static_assert(offsetof(FHWSkeletalMeshRef, AnimInstanceClassRef) == 0x000010, "Member 'FHWSkeletalMeshRef::AnimInstanceClassRef' has a wrong offset!");

// ScriptStruct Hemingway.FactorySpawnQueueInfo
// 0x0098 (0x0098 - 0x0000)
struct FFactorySpawnQueueInfo final
{
public:
	bool                                          bUseSpawnWaveTable;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UDataTable*>  SpawnWaveTables;                                   // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FFactorySpawnWaveInfo>          waveInfos;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EFactorySpawnQueueWaveSelectionMethod         eWaveSelectionMethod;                              // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         fTimePerSpawnWave;                                 // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaveSpawnTimeIncludedInWaveDelay;                 // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWBotFactory*                          FactoryOwner;                                      // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFactorySpawnQueueInfo) == 0x000008, "Wrong alignment on FFactorySpawnQueueInfo");
static_assert(sizeof(FFactorySpawnQueueInfo) == 0x000098, "Wrong size on FFactorySpawnQueueInfo");
static_assert(offsetof(FFactorySpawnQueueInfo, bUseSpawnWaveTable) == 0x000000, "Member 'FFactorySpawnQueueInfo::bUseSpawnWaveTable' has a wrong offset!");
static_assert(offsetof(FFactorySpawnQueueInfo, SpawnWaveTables) == 0x000008, "Member 'FFactorySpawnQueueInfo::SpawnWaveTables' has a wrong offset!");
static_assert(offsetof(FFactorySpawnQueueInfo, waveInfos) == 0x000058, "Member 'FFactorySpawnQueueInfo::waveInfos' has a wrong offset!");
static_assert(offsetof(FFactorySpawnQueueInfo, eWaveSelectionMethod) == 0x000068, "Member 'FFactorySpawnQueueInfo::eWaveSelectionMethod' has a wrong offset!");
static_assert(offsetof(FFactorySpawnQueueInfo, fTimePerSpawnWave) == 0x00006C, "Member 'FFactorySpawnQueueInfo::fTimePerSpawnWave' has a wrong offset!");
static_assert(offsetof(FFactorySpawnQueueInfo, bWaveSpawnTimeIncludedInWaveDelay) == 0x000070, "Member 'FFactorySpawnQueueInfo::bWaveSpawnTimeIncludedInWaveDelay' has a wrong offset!");
static_assert(offsetof(FFactorySpawnQueueInfo, FactoryOwner) == 0x000078, "Member 'FFactorySpawnQueueInfo::FactoryOwner' has a wrong offset!");

// ScriptStruct Hemingway.FactoryRewardInfo
// 0x0018 (0x0018 - 0x0000)
struct FFactoryRewardInfo final
{
public:
	EFactoryRewardType                            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFactoryRewardTrigger                         Trigger;                                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFactoryRewardTarget                          Target;                                            // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AHWDeployable_Buff>         BuffReward;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectReward;                              // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactoryRewardInfo) == 0x000008, "Wrong alignment on FFactoryRewardInfo");
static_assert(sizeof(FFactoryRewardInfo) == 0x000018, "Wrong size on FFactoryRewardInfo");
static_assert(offsetof(FFactoryRewardInfo, Type) == 0x000000, "Member 'FFactoryRewardInfo::Type' has a wrong offset!");
static_assert(offsetof(FFactoryRewardInfo, Trigger) == 0x000001, "Member 'FFactoryRewardInfo::Trigger' has a wrong offset!");
static_assert(offsetof(FFactoryRewardInfo, Target) == 0x000002, "Member 'FFactoryRewardInfo::Target' has a wrong offset!");
static_assert(offsetof(FFactoryRewardInfo, BuffReward) == 0x000008, "Member 'FFactoryRewardInfo::BuffReward' has a wrong offset!");
static_assert(offsetof(FFactoryRewardInfo, GameplayEffectReward) == 0x000010, "Member 'FFactoryRewardInfo::GameplayEffectReward' has a wrong offset!");

// ScriptStruct Hemingway.HWSwapActionState
// 0x0028 (0x0028 - 0x0000)
struct FHWSwapActionState final
{
public:
	class UInputAction*                           SwapAction;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWSwapActionState) == 0x000008, "Wrong alignment on FHWSwapActionState");
static_assert(sizeof(FHWSwapActionState) == 0x000028, "Wrong size on FHWSwapActionState");
static_assert(offsetof(FHWSwapActionState, SwapAction) == 0x000000, "Member 'FHWSwapActionState::SwapAction' has a wrong offset!");

// ScriptStruct Hemingway.FactorySpawnedActorInfo
// 0x0010 (0x0010 - 0x0000)
struct FFactorySpawnedActorInfo final
{
public:
	class AHWWaypoint*                            LaneIdentifyingWaypoint;                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    LaneDirection;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFactorySpawnedActorInfo) == 0x000008, "Wrong alignment on FFactorySpawnedActorInfo");
static_assert(sizeof(FFactorySpawnedActorInfo) == 0x000010, "Wrong size on FFactorySpawnedActorInfo");
static_assert(offsetof(FFactorySpawnedActorInfo, LaneIdentifyingWaypoint) == 0x000000, "Member 'FFactorySpawnedActorInfo::LaneIdentifyingWaypoint' has a wrong offset!");
static_assert(offsetof(FFactorySpawnedActorInfo, LaneDirection) == 0x000008, "Member 'FFactorySpawnedActorInfo::LaneDirection' has a wrong offset!");

// ScriptStruct Hemingway.FactorCachedSpawnRequest
// 0x0070 (0x0070 - 0x0000)
struct FFactorCachedSpawnRequest final
{
public:
	TSubclassOf<class AHWCharacter_Base>          BotClass;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactorCachedSpawnRequest) == 0x000010, "Wrong alignment on FFactorCachedSpawnRequest");
static_assert(sizeof(FFactorCachedSpawnRequest) == 0x000070, "Wrong size on FFactorCachedSpawnRequest");
static_assert(offsetof(FFactorCachedSpawnRequest, BotClass) == 0x000000, "Member 'FFactorCachedSpawnRequest::BotClass' has a wrong offset!");
static_assert(offsetof(FFactorCachedSpawnRequest, SpawnTransform) == 0x000010, "Member 'FFactorCachedSpawnRequest::SpawnTransform' has a wrong offset!");

// ScriptStruct Hemingway.HWQuestTierConfig
// 0x0088 (0x0088 - 0x0000)
struct FHWQuestTierConfig final
{
public:
	int32                                         QuestStepCount;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AchievementLink;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SettingTrackerName;                                // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             CompletionReward;                                  // 0x0028(0x0014)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             ClientClaimItem;                                   // 0x003C(0x0014)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             ClientClaimLoot;                                   // 0x0050(0x0014)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresItem;                                     // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_ItemId                             RequiredItem;                                      // 0x0068(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredItemCount;                                 // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExactMatch;                                     // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepeatingQuest;                                   // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWQuestTierConfig) == 0x000008, "Wrong alignment on FHWQuestTierConfig");
static_assert(sizeof(FHWQuestTierConfig) == 0x000088, "Wrong size on FHWQuestTierConfig");
static_assert(offsetof(FHWQuestTierConfig, QuestStepCount) == 0x000000, "Member 'FHWQuestTierConfig::QuestStepCount' has a wrong offset!");
static_assert(offsetof(FHWQuestTierConfig, AchievementLink) == 0x000008, "Member 'FHWQuestTierConfig::AchievementLink' has a wrong offset!");
static_assert(offsetof(FHWQuestTierConfig, SettingTrackerName) == 0x000018, "Member 'FHWQuestTierConfig::SettingTrackerName' has a wrong offset!");
static_assert(offsetof(FHWQuestTierConfig, CompletionReward) == 0x000028, "Member 'FHWQuestTierConfig::CompletionReward' has a wrong offset!");
static_assert(offsetof(FHWQuestTierConfig, ClientClaimItem) == 0x00003C, "Member 'FHWQuestTierConfig::ClientClaimItem' has a wrong offset!");
static_assert(offsetof(FHWQuestTierConfig, ClientClaimLoot) == 0x000050, "Member 'FHWQuestTierConfig::ClientClaimLoot' has a wrong offset!");
static_assert(offsetof(FHWQuestTierConfig, bRequiresItem) == 0x000064, "Member 'FHWQuestTierConfig::bRequiresItem' has a wrong offset!");
static_assert(offsetof(FHWQuestTierConfig, RequiredItem) == 0x000068, "Member 'FHWQuestTierConfig::RequiredItem' has a wrong offset!");
static_assert(offsetof(FHWQuestTierConfig, RequiredItemCount) == 0x00007C, "Member 'FHWQuestTierConfig::RequiredItemCount' has a wrong offset!");
static_assert(offsetof(FHWQuestTierConfig, bIsExactMatch) == 0x000080, "Member 'FHWQuestTierConfig::bIsExactMatch' has a wrong offset!");
static_assert(offsetof(FHWQuestTierConfig, bRepeatingQuest) == 0x000081, "Member 'FHWQuestTierConfig::bRepeatingQuest' has a wrong offset!");

// ScriptStruct Hemingway.HWApparelSoftDataTableInfo
// 0x0078 (0x0078 - 0x0000)
struct FHWApparelSoftDataTableInfo final
{
public:
	TSoftObjectPtr<class UDataTable>              DataTable;                                         // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TablePriority;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      SkinTagQuery;                                      // 0x0030(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWApparelSoftDataTableInfo) == 0x000008, "Wrong alignment on FHWApparelSoftDataTableInfo");
static_assert(sizeof(FHWApparelSoftDataTableInfo) == 0x000078, "Wrong size on FHWApparelSoftDataTableInfo");
static_assert(offsetof(FHWApparelSoftDataTableInfo, DataTable) == 0x000000, "Member 'FHWApparelSoftDataTableInfo::DataTable' has a wrong offset!");
static_assert(offsetof(FHWApparelSoftDataTableInfo, TablePriority) == 0x000028, "Member 'FHWApparelSoftDataTableInfo::TablePriority' has a wrong offset!");
static_assert(offsetof(FHWApparelSoftDataTableInfo, SkinTagQuery) == 0x000030, "Member 'FHWApparelSoftDataTableInfo::SkinTagQuery' has a wrong offset!");

// ScriptStruct Hemingway.HWAppliedApparelKey
// 0x0004 (0x0004 - 0x0000)
struct FHWAppliedApparelKey final
{
public:
	uint32                                        ID;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHWAppliedApparelKey) == 0x000004, "Wrong alignment on FHWAppliedApparelKey");
static_assert(sizeof(FHWAppliedApparelKey) == 0x000004, "Wrong size on FHWAppliedApparelKey");
static_assert(offsetof(FHWAppliedApparelKey, ID) == 0x000000, "Member 'FHWAppliedApparelKey::ID' has a wrong offset!");

// ScriptStruct Hemingway.HWMappingContextCustomPreset
// 0x0048 (0x0048 - 0x0000)
struct FHWMappingContextCustomPreset final
{
public:
	struct FHWMappingContextPreset                Preset;                                            // 0x0000(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 CopiedFromPresetName;                              // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWMappingContextCustomPreset) == 0x000008, "Wrong alignment on FHWMappingContextCustomPreset");
static_assert(sizeof(FHWMappingContextCustomPreset) == 0x000048, "Wrong size on FHWMappingContextCustomPreset");
static_assert(offsetof(FHWMappingContextCustomPreset, Preset) == 0x000000, "Member 'FHWMappingContextCustomPreset::Preset' has a wrong offset!");
static_assert(offsetof(FHWMappingContextCustomPreset, CopiedFromPresetName) == 0x000038, "Member 'FHWMappingContextCustomPreset::CopiedFromPresetName' has a wrong offset!");

// ScriptStruct Hemingway.HWMappingContextData
// 0x00A8 (0x00A8 - 0x0000)
struct FHWMappingContextData final
{
public:
	bool                                          bAllowRebinds;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPermanentContext;                               // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoUpdateMutableOnRebind;                        // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RebindDisplayPriority;                             // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInputAction*>                   MappableActions;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FHWMappingContextPreset>        DefaultPresets;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHWMappingContextCustomPreset          CustomPreset;                                      // 0x0048(0x0048)(Transient, NativeAccessSpecifierPublic)
	class FString                                 ActivePreset;                                      // 0x0090(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   MutableInputMappingContext;                        // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWMappingContextData) == 0x000008, "Wrong alignment on FHWMappingContextData");
static_assert(sizeof(FHWMappingContextData) == 0x0000A8, "Wrong size on FHWMappingContextData");
static_assert(offsetof(FHWMappingContextData, bAllowRebinds) == 0x000000, "Member 'FHWMappingContextData::bAllowRebinds' has a wrong offset!");
static_assert(offsetof(FHWMappingContextData, bIsPermanentContext) == 0x000001, "Member 'FHWMappingContextData::bIsPermanentContext' has a wrong offset!");
static_assert(offsetof(FHWMappingContextData, bAutoUpdateMutableOnRebind) == 0x000002, "Member 'FHWMappingContextData::bAutoUpdateMutableOnRebind' has a wrong offset!");
static_assert(offsetof(FHWMappingContextData, DisplayName) == 0x000008, "Member 'FHWMappingContextData::DisplayName' has a wrong offset!");
static_assert(offsetof(FHWMappingContextData, Priority) == 0x000020, "Member 'FHWMappingContextData::Priority' has a wrong offset!");
static_assert(offsetof(FHWMappingContextData, RebindDisplayPriority) == 0x000024, "Member 'FHWMappingContextData::RebindDisplayPriority' has a wrong offset!");
static_assert(offsetof(FHWMappingContextData, MappableActions) == 0x000028, "Member 'FHWMappingContextData::MappableActions' has a wrong offset!");
static_assert(offsetof(FHWMappingContextData, DefaultPresets) == 0x000038, "Member 'FHWMappingContextData::DefaultPresets' has a wrong offset!");
static_assert(offsetof(FHWMappingContextData, CustomPreset) == 0x000048, "Member 'FHWMappingContextData::CustomPreset' has a wrong offset!");
static_assert(offsetof(FHWMappingContextData, ActivePreset) == 0x000090, "Member 'FHWMappingContextData::ActivePreset' has a wrong offset!");
static_assert(offsetof(FHWMappingContextData, MutableInputMappingContext) == 0x0000A0, "Member 'FHWMappingContextData::MutableInputMappingContext' has a wrong offset!");

// ScriptStruct Hemingway.HWAppliedApparelKeyGenerator
// 0x0004 (0x0004 - 0x0000)
struct FHWAppliedApparelKeyGenerator final
{
public:
	uint32                                        NextKey;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHWAppliedApparelKeyGenerator) == 0x000004, "Wrong alignment on FHWAppliedApparelKeyGenerator");
static_assert(sizeof(FHWAppliedApparelKeyGenerator) == 0x000004, "Wrong size on FHWAppliedApparelKeyGenerator");
static_assert(offsetof(FHWAppliedApparelKeyGenerator, NextKey) == 0x000000, "Member 'FHWAppliedApparelKeyGenerator::NextKey' has a wrong offset!");

// ScriptStruct Hemingway.HWDraftOrderTask
// 0x0010 (0x0018 - 0x0008)
struct FHWDraftOrderTask final : public FTableRowBase
{
public:
	int32                                         TeamId;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDraftTaskType                                TaskType;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TaskTime;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaskTimeInCustoms;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWDraftOrderTask) == 0x000008, "Wrong alignment on FHWDraftOrderTask");
static_assert(sizeof(FHWDraftOrderTask) == 0x000018, "Wrong size on FHWDraftOrderTask");
static_assert(offsetof(FHWDraftOrderTask, TeamId) == 0x000008, "Member 'FHWDraftOrderTask::TeamId' has a wrong offset!");
static_assert(offsetof(FHWDraftOrderTask, TaskType) == 0x00000C, "Member 'FHWDraftOrderTask::TaskType' has a wrong offset!");
static_assert(offsetof(FHWDraftOrderTask, TaskTime) == 0x000010, "Member 'FHWDraftOrderTask::TaskTime' has a wrong offset!");
static_assert(offsetof(FHWDraftOrderTask, TaskTimeInCustoms) == 0x000014, "Member 'FHWDraftOrderTask::TaskTimeInCustoms' has a wrong offset!");

// ScriptStruct Hemingway.HWRemoveBlockRuleRow
// 0x0028 (0x0030 - 0x0008)
struct FHWRemoveBlockRuleRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           TypeTag;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockTagsToRemove;                                 // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWRemoveBlockRuleRow) == 0x000008, "Wrong alignment on FHWRemoveBlockRuleRow");
static_assert(sizeof(FHWRemoveBlockRuleRow) == 0x000030, "Wrong size on FHWRemoveBlockRuleRow");
static_assert(offsetof(FHWRemoveBlockRuleRow, TypeTag) == 0x000008, "Member 'FHWRemoveBlockRuleRow::TypeTag' has a wrong offset!");
static_assert(offsetof(FHWRemoveBlockRuleRow, BlockTagsToRemove) == 0x000010, "Member 'FHWRemoveBlockRuleRow::BlockTagsToRemove' has a wrong offset!");

// ScriptStruct Hemingway.HWAutoSkillEquipmentLevelEntry
// 0x0030 (0x0030 - 0x0000)
struct FHWAutoSkillEquipmentLevelEntry final
{
public:
	TSoftObjectPtr<class UHWEquipmentItem>        EquipmentToLevel;                                  // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredLevel;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAutoSkillEquipmentLevelEntry) == 0x000008, "Wrong alignment on FHWAutoSkillEquipmentLevelEntry");
static_assert(sizeof(FHWAutoSkillEquipmentLevelEntry) == 0x000030, "Wrong size on FHWAutoSkillEquipmentLevelEntry");
static_assert(offsetof(FHWAutoSkillEquipmentLevelEntry, EquipmentToLevel) == 0x000000, "Member 'FHWAutoSkillEquipmentLevelEntry::EquipmentToLevel' has a wrong offset!");
static_assert(offsetof(FHWAutoSkillEquipmentLevelEntry, DesiredLevel) == 0x000028, "Member 'FHWAutoSkillEquipmentLevelEntry::DesiredLevel' has a wrong offset!");

// ScriptStruct Hemingway.HWAutoSkillCharacterLevelEntry
// 0x0010 (0x0010 - 0x0000)
struct FHWAutoSkillCharacterLevelEntry final
{
public:
	TArray<struct FHWAutoSkillEquipmentLevelEntry> EquipmentLevelingEntries;                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAutoSkillCharacterLevelEntry) == 0x000008, "Wrong alignment on FHWAutoSkillCharacterLevelEntry");
static_assert(sizeof(FHWAutoSkillCharacterLevelEntry) == 0x000010, "Wrong size on FHWAutoSkillCharacterLevelEntry");
static_assert(offsetof(FHWAutoSkillCharacterLevelEntry, EquipmentLevelingEntries) == 0x000000, "Member 'FHWAutoSkillCharacterLevelEntry::EquipmentLevelingEntries' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSMenuTagToGameplayEventTag
// 0x0018 (0x0018 - 0x0000)
struct FHWVGSMenuTagToGameplayEventTag final
{
public:
	struct FGameplayTag                           KBMMenuIdTag;                                      // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GamepadMenuIdTag;                                  // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayEventTag;                                  // 0x0010(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVGSMenuTagToGameplayEventTag) == 0x000004, "Wrong alignment on FHWVGSMenuTagToGameplayEventTag");
static_assert(sizeof(FHWVGSMenuTagToGameplayEventTag) == 0x000018, "Wrong size on FHWVGSMenuTagToGameplayEventTag");
static_assert(offsetof(FHWVGSMenuTagToGameplayEventTag, KBMMenuIdTag) == 0x000000, "Member 'FHWVGSMenuTagToGameplayEventTag::KBMMenuIdTag' has a wrong offset!");
static_assert(offsetof(FHWVGSMenuTagToGameplayEventTag, GamepadMenuIdTag) == 0x000008, "Member 'FHWVGSMenuTagToGameplayEventTag::GamepadMenuIdTag' has a wrong offset!");
static_assert(offsetof(FHWVGSMenuTagToGameplayEventTag, GameplayEventTag) == 0x000010, "Member 'FHWVGSMenuTagToGameplayEventTag::GameplayEventTag' has a wrong offset!");

// ScriptStruct Hemingway.CharacterRoleInfo
// 0x0008 (0x0008 - 0x0000)
struct FCharacterRoleInfo final
{
public:
	ECharacterRole                                Role;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RolePercent;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterRoleInfo) == 0x000004, "Wrong alignment on FCharacterRoleInfo");
static_assert(sizeof(FCharacterRoleInfo) == 0x000008, "Wrong size on FCharacterRoleInfo");
static_assert(offsetof(FCharacterRoleInfo, Role) == 0x000000, "Member 'FCharacterRoleInfo::Role' has a wrong offset!");
static_assert(offsetof(FCharacterRoleInfo, RolePercent) == 0x000004, "Member 'FCharacterRoleInfo::RolePercent' has a wrong offset!");

// ScriptStruct Hemingway.HWCharacterCollectionInfo
// 0x0014 (0x0014 - 0x0000)
struct FHWCharacterCollectionInfo final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCharacterCollectionInfo) == 0x000004, "Wrong alignment on FHWCharacterCollectionInfo");
static_assert(sizeof(FHWCharacterCollectionInfo) == 0x000014, "Wrong size on FHWCharacterCollectionInfo");
static_assert(offsetof(FHWCharacterCollectionInfo, ItemId) == 0x000000, "Member 'FHWCharacterCollectionInfo::ItemId' has a wrong offset!");

// ScriptStruct Hemingway.HWDiminishingReturnThresholdInfo
// 0x0008 (0x0008 - 0x0000)
struct FHWDiminishingReturnThresholdInfo final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWDiminishingReturnThresholdInfo) == 0x000004, "Wrong alignment on FHWDiminishingReturnThresholdInfo");
static_assert(sizeof(FHWDiminishingReturnThresholdInfo) == 0x000008, "Wrong size on FHWDiminishingReturnThresholdInfo");
static_assert(offsetof(FHWDiminishingReturnThresholdInfo, Threshold) == 0x000000, "Member 'FHWDiminishingReturnThresholdInfo::Threshold' has a wrong offset!");
static_assert(offsetof(FHWDiminishingReturnThresholdInfo, Multiplier) == 0x000004, "Member 'FHWDiminishingReturnThresholdInfo::Multiplier' has a wrong offset!");

// ScriptStruct Hemingway.HWCollectionDescriptionData
// 0x0030 (0x0030 - 0x0000)
struct FHWCollectionDescriptionData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCollectionDescriptionData) == 0x000008, "Wrong alignment on FHWCollectionDescriptionData");
static_assert(sizeof(FHWCollectionDescriptionData) == 0x000030, "Wrong size on FHWCollectionDescriptionData");
static_assert(offsetof(FHWCollectionDescriptionData, Title) == 0x000000, "Member 'FHWCollectionDescriptionData::Title' has a wrong offset!");
static_assert(offsetof(FHWCollectionDescriptionData, Description) == 0x000018, "Member 'FHWCollectionDescriptionData::Description' has a wrong offset!");

// ScriptStruct Hemingway.HWPriorityQueueDashNode
// 0x0008 (0x0008 - 0x0000)
struct FHWPriorityQueueDashNode final
{
public:
	class UHWGameplayDash*                        DashElement;                                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPriorityQueueDashNode) == 0x000008, "Wrong alignment on FHWPriorityQueueDashNode");
static_assert(sizeof(FHWPriorityQueueDashNode) == 0x000008, "Wrong size on FHWPriorityQueueDashNode");
static_assert(offsetof(FHWPriorityQueueDashNode, DashElement) == 0x000000, "Member 'FHWPriorityQueueDashNode::DashElement' has a wrong offset!");

// ScriptStruct Hemingway.HWForcedCharacterMovementInfo
// 0x0050 (0x0050 - 0x0000)
struct FHWForcedCharacterMovementInfo final
{
public:
	struct FActiveGameplayEffectHandle            ActiveEffectHandle;                                // 0x0000(0x0008)(BlueprintVisible, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWForceMovementEffectConfig           MoveConfig;                                        // 0x0008(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	struct FVector                                InitialMoveDirection;                              // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWForcedCharacterMovementInfo) == 0x000008, "Wrong alignment on FHWForcedCharacterMovementInfo");
static_assert(sizeof(FHWForcedCharacterMovementInfo) == 0x000050, "Wrong size on FHWForcedCharacterMovementInfo");
static_assert(offsetof(FHWForcedCharacterMovementInfo, ActiveEffectHandle) == 0x000000, "Member 'FHWForcedCharacterMovementInfo::ActiveEffectHandle' has a wrong offset!");
static_assert(offsetof(FHWForcedCharacterMovementInfo, MoveConfig) == 0x000008, "Member 'FHWForcedCharacterMovementInfo::MoveConfig' has a wrong offset!");
static_assert(offsetof(FHWForcedCharacterMovementInfo, EffectContextHandle) == 0x000020, "Member 'FHWForcedCharacterMovementInfo::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(FHWForcedCharacterMovementInfo, InitialMoveDirection) == 0x000038, "Member 'FHWForcedCharacterMovementInfo::InitialMoveDirection' has a wrong offset!");

// ScriptStruct Hemingway.HWLevelInfo
// 0x0014 (0x0014 - 0x0000)
struct FHWLevelInfo final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpPoints;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLevelStartPoint;                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLevelEndPoint;                              // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsComplete;                                       // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWLevelInfo) == 0x000004, "Wrong alignment on FHWLevelInfo");
static_assert(sizeof(FHWLevelInfo) == 0x000014, "Wrong size on FHWLevelInfo");
static_assert(offsetof(FHWLevelInfo, Level) == 0x000000, "Member 'FHWLevelInfo::Level' has a wrong offset!");
static_assert(offsetof(FHWLevelInfo, XpPoints) == 0x000004, "Member 'FHWLevelInfo::XpPoints' has a wrong offset!");
static_assert(offsetof(FHWLevelInfo, CurrentLevelStartPoint) == 0x000008, "Member 'FHWLevelInfo::CurrentLevelStartPoint' has a wrong offset!");
static_assert(offsetof(FHWLevelInfo, CurrentLevelEndPoint) == 0x00000C, "Member 'FHWLevelInfo::CurrentLevelEndPoint' has a wrong offset!");
static_assert(offsetof(FHWLevelInfo, bIsComplete) == 0x000010, "Member 'FHWLevelInfo::bIsComplete' has a wrong offset!");

// ScriptStruct Hemingway.HWEndCustomMovementRules
// 0x000C (0x000C - 0x0000)
struct FHWEndCustomMovementRules final
{
public:
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenBehavior                           EndTweenBehavior;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldInterruptFlight;                            // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndFlightReason                            EndFlightReason;                                   // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndFlightBehavior                          EndFlightBehavior;                                 // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndGrabReason                              EndGrabReason;                                     // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndGrabBehavior                            EndGrabBehavior;                                   // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInterruptingDash;                               // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldStartNextQueueDash;                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldInterruptLevitate;                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndLevitationReason                        EndLevitationReason;                               // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndLevitationBehavior                      EndLevitationBehabior;                             // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEndCustomMovementRules) == 0x000001, "Wrong alignment on FHWEndCustomMovementRules");
static_assert(sizeof(FHWEndCustomMovementRules) == 0x00000C, "Wrong size on FHWEndCustomMovementRules");
static_assert(offsetof(FHWEndCustomMovementRules, EndTweenReason) == 0x000000, "Member 'FHWEndCustomMovementRules::EndTweenReason' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, EndTweenBehavior) == 0x000001, "Member 'FHWEndCustomMovementRules::EndTweenBehavior' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, bShouldInterruptFlight) == 0x000002, "Member 'FHWEndCustomMovementRules::bShouldInterruptFlight' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, EndFlightReason) == 0x000003, "Member 'FHWEndCustomMovementRules::EndFlightReason' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, EndFlightBehavior) == 0x000004, "Member 'FHWEndCustomMovementRules::EndFlightBehavior' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, EndGrabReason) == 0x000005, "Member 'FHWEndCustomMovementRules::EndGrabReason' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, EndGrabBehavior) == 0x000006, "Member 'FHWEndCustomMovementRules::EndGrabBehavior' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, bIsInterruptingDash) == 0x000007, "Member 'FHWEndCustomMovementRules::bIsInterruptingDash' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, bShouldStartNextQueueDash) == 0x000008, "Member 'FHWEndCustomMovementRules::bShouldStartNextQueueDash' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, bShouldInterruptLevitate) == 0x000009, "Member 'FHWEndCustomMovementRules::bShouldInterruptLevitate' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, EndLevitationReason) == 0x00000A, "Member 'FHWEndCustomMovementRules::EndLevitationReason' has a wrong offset!");
static_assert(offsetof(FHWEndCustomMovementRules, EndLevitationBehabior) == 0x00000B, "Member 'FHWEndCustomMovementRules::EndLevitationBehabior' has a wrong offset!");

// ScriptStruct Hemingway.HWTweenEndEvent
// 0x000C (0x000C - 0x0000)
struct FHWTweenEndEvent final
{
public:
	struct FGameplayTag                           TweenId;                                           // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWTweenEndEvent) == 0x000004, "Wrong alignment on FHWTweenEndEvent");
static_assert(sizeof(FHWTweenEndEvent) == 0x00000C, "Wrong size on FHWTweenEndEvent");
static_assert(offsetof(FHWTweenEndEvent, TweenId) == 0x000000, "Member 'FHWTweenEndEvent::TweenId' has a wrong offset!");
static_assert(offsetof(FHWTweenEndEvent, EndTweenReason) == 0x000008, "Member 'FHWTweenEndEvent::EndTweenReason' has a wrong offset!");

// ScriptStruct Hemingway.HWSkinTagCharacterLevelEntry
// 0x000C (0x000C - 0x0000)
struct FHWSkinTagCharacterLevelEntry final
{
public:
	int32                                         CharacterLevelRequirement;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkinTagValue;                                      // 0x0004(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkinTagCharacterLevelEntry) == 0x000004, "Wrong alignment on FHWSkinTagCharacterLevelEntry");
static_assert(sizeof(FHWSkinTagCharacterLevelEntry) == 0x00000C, "Wrong size on FHWSkinTagCharacterLevelEntry");
static_assert(offsetof(FHWSkinTagCharacterLevelEntry, CharacterLevelRequirement) == 0x000000, "Member 'FHWSkinTagCharacterLevelEntry::CharacterLevelRequirement' has a wrong offset!");
static_assert(offsetof(FHWSkinTagCharacterLevelEntry, SkinTagValue) == 0x000004, "Member 'FHWSkinTagCharacterLevelEntry::SkinTagValue' has a wrong offset!");

// ScriptStruct Hemingway.HWPreviousDashInfo
// 0x0028 (0x0028 - 0x0000)
struct FHWPreviousDashInfo final
{
public:
	struct FGameplayTag                           DashId;                                            // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         PredictionKey;                                     // 0x0010(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPreviousDashInfo) == 0x000008, "Wrong alignment on FHWPreviousDashInfo");
static_assert(sizeof(FHWPreviousDashInfo) == 0x000028, "Wrong size on FHWPreviousDashInfo");
static_assert(offsetof(FHWPreviousDashInfo, DashId) == 0x000000, "Member 'FHWPreviousDashInfo::DashId' has a wrong offset!");
static_assert(offsetof(FHWPreviousDashInfo, Instigator) == 0x000008, "Member 'FHWPreviousDashInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FHWPreviousDashInfo, PredictionKey) == 0x000010, "Member 'FHWPreviousDashInfo::PredictionKey' has a wrong offset!");

// ScriptStruct Hemingway.HWMovementSpeedOverTimeMove
// 0x0030 (0x0030 - 0x0000)
struct FHWMovementSpeedOverTimeMove final
{
public:
	class FName                                   InstanceName;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousTime;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedOverTimeModifier;                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProcessAsSlow;                                    // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStrafeBackpedalImmunity;                          // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MovementSpeedOverTimeCurve;                        // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWMovementSpeedOverTimeMove) == 0x000008, "Wrong alignment on FHWMovementSpeedOverTimeMove");
static_assert(sizeof(FHWMovementSpeedOverTimeMove) == 0x000030, "Wrong size on FHWMovementSpeedOverTimeMove");
static_assert(offsetof(FHWMovementSpeedOverTimeMove, InstanceName) == 0x000000, "Member 'FHWMovementSpeedOverTimeMove::InstanceName' has a wrong offset!");
static_assert(offsetof(FHWMovementSpeedOverTimeMove, Duration) == 0x000008, "Member 'FHWMovementSpeedOverTimeMove::Duration' has a wrong offset!");
static_assert(offsetof(FHWMovementSpeedOverTimeMove, PreviousTime) == 0x00000C, "Member 'FHWMovementSpeedOverTimeMove::PreviousTime' has a wrong offset!");
static_assert(offsetof(FHWMovementSpeedOverTimeMove, CurrentTime) == 0x000010, "Member 'FHWMovementSpeedOverTimeMove::CurrentTime' has a wrong offset!");
static_assert(offsetof(FHWMovementSpeedOverTimeMove, MovementSpeedOverTimeModifier) == 0x000014, "Member 'FHWMovementSpeedOverTimeMove::MovementSpeedOverTimeModifier' has a wrong offset!");
static_assert(offsetof(FHWMovementSpeedOverTimeMove, bProcessAsSlow) == 0x000018, "Member 'FHWMovementSpeedOverTimeMove::bProcessAsSlow' has a wrong offset!");
static_assert(offsetof(FHWMovementSpeedOverTimeMove, bStrafeBackpedalImmunity) == 0x000019, "Member 'FHWMovementSpeedOverTimeMove::bStrafeBackpedalImmunity' has a wrong offset!");
static_assert(offsetof(FHWMovementSpeedOverTimeMove, MovementSpeedOverTimeCurve) == 0x000020, "Member 'FHWMovementSpeedOverTimeMove::MovementSpeedOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FHWMovementSpeedOverTimeMove, bActive) == 0x000028, "Member 'FHWMovementSpeedOverTimeMove::bActive' has a wrong offset!");

// ScriptStruct Hemingway.HWInstanceInfo_MatchData
// 0x0008 (0x0008 - 0x0000)
struct FHWInstanceInfo_MatchData final
{
public:
	struct FGameplayTag                           GamePhaseTag;                                      // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWInstanceInfo_MatchData) == 0x000004, "Wrong alignment on FHWInstanceInfo_MatchData");
static_assert(sizeof(FHWInstanceInfo_MatchData) == 0x000008, "Wrong size on FHWInstanceInfo_MatchData");
static_assert(offsetof(FHWInstanceInfo_MatchData, GamePhaseTag) == 0x000000, "Member 'FHWInstanceInfo_MatchData::GamePhaseTag' has a wrong offset!");

// ScriptStruct Hemingway.HWLastValidGroundLocationForPoE
// 0x0020 (0x0020 - 0x0000)
struct FHWLastValidGroundLocationForPoE final
{
public:
	struct FGameplayTag                           PlaneOfExistence;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastValidGroundLocation;                           // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWLastValidGroundLocationForPoE) == 0x000008, "Wrong alignment on FHWLastValidGroundLocationForPoE");
static_assert(sizeof(FHWLastValidGroundLocationForPoE) == 0x000020, "Wrong size on FHWLastValidGroundLocationForPoE");
static_assert(offsetof(FHWLastValidGroundLocationForPoE, PlaneOfExistence) == 0x000000, "Member 'FHWLastValidGroundLocationForPoE::PlaneOfExistence' has a wrong offset!");
static_assert(offsetof(FHWLastValidGroundLocationForPoE, LastValidGroundLocation) == 0x000008, "Member 'FHWLastValidGroundLocationForPoE::LastValidGroundLocation' has a wrong offset!");

// ScriptStruct Hemingway.RootMotionSource_MovementSpeedOverTime
// 0x0010 (0x00F0 - 0x00E0)
struct FRootMotionSource_MovementSpeedOverTime final : public FRootMotionSource
{
public:
	bool                                          bProcessAsSlow;                                    // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStrafeBackpedalImmunity;                          // 0x00D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MovementSpeedOverTimeCurve;                        // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootMotionSource_MovementSpeedOverTime) == 0x000010, "Wrong alignment on FRootMotionSource_MovementSpeedOverTime");
static_assert(sizeof(FRootMotionSource_MovementSpeedOverTime) == 0x0000F0, "Wrong size on FRootMotionSource_MovementSpeedOverTime");
static_assert(offsetof(FRootMotionSource_MovementSpeedOverTime, bProcessAsSlow) == 0x0000D8, "Member 'FRootMotionSource_MovementSpeedOverTime::bProcessAsSlow' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_MovementSpeedOverTime, bStrafeBackpedalImmunity) == 0x0000D9, "Member 'FRootMotionSource_MovementSpeedOverTime::bStrafeBackpedalImmunity' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_MovementSpeedOverTime, MovementSpeedOverTimeCurve) == 0x0000E0, "Member 'FRootMotionSource_MovementSpeedOverTime::MovementSpeedOverTimeCurve' has a wrong offset!");

// ScriptStruct Hemingway.PlayerActiveQuests
// 0x0030 (0x0030 - 0x0000)
struct FPlayerActiveQuests final
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0000(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHWActiveQuest*>                 ActiveQuestList;                                   // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerActiveQuests) == 0x000008, "Wrong alignment on FPlayerActiveQuests");
static_assert(sizeof(FPlayerActiveQuests) == 0x000030, "Wrong size on FPlayerActiveQuests");
static_assert(offsetof(FPlayerActiveQuests, PlayerId) == 0x000000, "Member 'FPlayerActiveQuests::PlayerId' has a wrong offset!");
static_assert(offsetof(FPlayerActiveQuests, ActiveQuestList) == 0x000020, "Member 'FPlayerActiveQuests::ActiveQuestList' has a wrong offset!");

// ScriptStruct Hemingway.HWMontageInfo
// 0x0018 (0x0018 - 0x0000)
struct FHWMontageInfo final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPlayRate;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartingMontageSection;                            // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinuePlayingMontagePastAbilityEnd;             // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinuePlayingMontagePastAbilityCancel;          // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWMontageInfo) == 0x000008, "Wrong alignment on FHWMontageInfo");
static_assert(sizeof(FHWMontageInfo) == 0x000018, "Wrong size on FHWMontageInfo");
static_assert(offsetof(FHWMontageInfo, Montage) == 0x000000, "Member 'FHWMontageInfo::Montage' has a wrong offset!");
static_assert(offsetof(FHWMontageInfo, DefaultPlayRate) == 0x000008, "Member 'FHWMontageInfo::DefaultPlayRate' has a wrong offset!");
static_assert(offsetof(FHWMontageInfo, StartingMontageSection) == 0x00000C, "Member 'FHWMontageInfo::StartingMontageSection' has a wrong offset!");
static_assert(offsetof(FHWMontageInfo, bContinuePlayingMontagePastAbilityEnd) == 0x000014, "Member 'FHWMontageInfo::bContinuePlayingMontagePastAbilityEnd' has a wrong offset!");
static_assert(offsetof(FHWMontageInfo, bContinuePlayingMontagePastAbilityCancel) == 0x000015, "Member 'FHWMontageInfo::bContinuePlayingMontagePastAbilityCancel' has a wrong offset!");

// ScriptStruct Hemingway.HWSkinnedStaticMeshInfo
// 0x0008 (0x0008 - 0x0000)
struct FHWSkinnedStaticMeshInfo final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkinnedStaticMeshInfo) == 0x000008, "Wrong alignment on FHWSkinnedStaticMeshInfo");
static_assert(sizeof(FHWSkinnedStaticMeshInfo) == 0x000008, "Wrong size on FHWSkinnedStaticMeshInfo");
static_assert(offsetof(FHWSkinnedStaticMeshInfo, Mesh) == 0x000000, "Member 'FHWSkinnedStaticMeshInfo::Mesh' has a wrong offset!");

// ScriptStruct Hemingway.HWSkinnedMetaSoundInfo
// 0x0008 (0x0008 - 0x0000)
struct FHWSkinnedMetaSoundInfo final
{
public:
	class UMetaSoundSource*                       MetaSoundSource;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkinnedMetaSoundInfo) == 0x000008, "Wrong alignment on FHWSkinnedMetaSoundInfo");
static_assert(sizeof(FHWSkinnedMetaSoundInfo) == 0x000008, "Wrong size on FHWSkinnedMetaSoundInfo");
static_assert(offsetof(FHWSkinnedMetaSoundInfo, MetaSoundSource) == 0x000000, "Member 'FHWSkinnedMetaSoundInfo::MetaSoundSource' has a wrong offset!");

// ScriptStruct Hemingway.HWWorldInfo
// 0x0008 (0x0008 - 0x0000)
struct FHWWorldInfo final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWWorldInfo) == 0x000008, "Wrong alignment on FHWWorldInfo");
static_assert(sizeof(FHWWorldInfo) == 0x000008, "Wrong size on FHWWorldInfo");
static_assert(offsetof(FHWWorldInfo, World) == 0x000000, "Member 'FHWWorldInfo::World' has a wrong offset!");

// ScriptStruct Hemingway.GameplayTagFloatPair
// 0x000C (0x000C - 0x0000)
struct FGameplayTagFloatPair final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagFloatPair) == 0x000004, "Wrong alignment on FGameplayTagFloatPair");
static_assert(sizeof(FGameplayTagFloatPair) == 0x00000C, "Wrong size on FGameplayTagFloatPair");
static_assert(offsetof(FGameplayTagFloatPair, Tag) == 0x000000, "Member 'FGameplayTagFloatPair::Tag' has a wrong offset!");
static_assert(offsetof(FGameplayTagFloatPair, Value) == 0x000008, "Member 'FGameplayTagFloatPair::Value' has a wrong offset!");

// ScriptStruct Hemingway.HWCameraLockInfo
// 0x0028 (0x0028 - 0x0000)
struct FHWCameraLockInfo final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawAngleThreshold;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAngleThreshold;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurrentCharacterRotationAsOriginRotation;      // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               OriginRotation;                                    // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCameraLockInfo) == 0x000008, "Wrong alignment on FHWCameraLockInfo");
static_assert(sizeof(FHWCameraLockInfo) == 0x000028, "Wrong size on FHWCameraLockInfo");
static_assert(offsetof(FHWCameraLockInfo, bIsEnabled) == 0x000000, "Member 'FHWCameraLockInfo::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FHWCameraLockInfo, YawAngleThreshold) == 0x000004, "Member 'FHWCameraLockInfo::YawAngleThreshold' has a wrong offset!");
static_assert(offsetof(FHWCameraLockInfo, PitchAngleThreshold) == 0x000008, "Member 'FHWCameraLockInfo::PitchAngleThreshold' has a wrong offset!");
static_assert(offsetof(FHWCameraLockInfo, bUseCurrentCharacterRotationAsOriginRotation) == 0x00000C, "Member 'FHWCameraLockInfo::bUseCurrentCharacterRotationAsOriginRotation' has a wrong offset!");
static_assert(offsetof(FHWCameraLockInfo, OriginRotation) == 0x000010, "Member 'FHWCameraLockInfo::OriginRotation' has a wrong offset!");

// ScriptStruct Hemingway.HWAnnouncementRecord
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FHWAnnouncementRecord final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAnnouncementRecord) == 0x000008, "Wrong alignment on FHWAnnouncementRecord");
static_assert(sizeof(FHWAnnouncementRecord) == 0x000010, "Wrong size on FHWAnnouncementRecord");

// ScriptStruct Hemingway.HWDynamicSubLevelHandle
// 0x0010 (0x0010 - 0x0000)
struct FHWDynamicSubLevelHandle final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWDynamicSubLevelComponent*            OwningComponent;                                   // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWDynamicSubLevelHandle) == 0x000008, "Wrong alignment on FHWDynamicSubLevelHandle");
static_assert(sizeof(FHWDynamicSubLevelHandle) == 0x000010, "Wrong size on FHWDynamicSubLevelHandle");
static_assert(offsetof(FHWDynamicSubLevelHandle, LevelName) == 0x000000, "Member 'FHWDynamicSubLevelHandle::LevelName' has a wrong offset!");
static_assert(offsetof(FHWDynamicSubLevelHandle, OwningComponent) == 0x000008, "Member 'FHWDynamicSubLevelHandle::OwningComponent' has a wrong offset!");

// ScriptStruct Hemingway.HWCosmeticLoadoutInfo
// 0x0018 (0x0018 - 0x0000)
struct FHWCosmeticLoadoutInfo final
{
public:
	struct FPrimaryAssetId                        AssetId;                                           // 0x0000(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWCollectionItemType                         CosmeticType;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotId;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCosmeticLoadoutInfo) == 0x000004, "Wrong alignment on FHWCosmeticLoadoutInfo");
static_assert(sizeof(FHWCosmeticLoadoutInfo) == 0x000018, "Wrong size on FHWCosmeticLoadoutInfo");
static_assert(offsetof(FHWCosmeticLoadoutInfo, AssetId) == 0x000000, "Member 'FHWCosmeticLoadoutInfo::AssetId' has a wrong offset!");
static_assert(offsetof(FHWCosmeticLoadoutInfo, CosmeticType) == 0x000010, "Member 'FHWCosmeticLoadoutInfo::CosmeticType' has a wrong offset!");
static_assert(offsetof(FHWCosmeticLoadoutInfo, SlotId) == 0x000014, "Member 'FHWCosmeticLoadoutInfo::SlotId' has a wrong offset!");

// ScriptStruct Hemingway.HWCosmeticLoadoutInventory
// 0x0068 (0x0170 - 0x0108)
struct FHWCosmeticLoadoutInventory final : public FFastArraySerializer
{
public:
	TArray<struct FHWCosmeticInventoryEntry>      Entries;                                           // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<EHWCollectionItemType, struct FSlotTypeArrayInfo> SlotTypeInfoMap;                          // 0x0118(0x0050)(RepSkip, NativeAccessSpecifierPrivate)
	class UHWLoadoutComponent*                    OwnerComponent;                                    // 0x0168(0x0008)(ExportObject, ZeroConstructor, InstancedReference, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHWCosmeticLoadoutInventory) == 0x000008, "Wrong alignment on FHWCosmeticLoadoutInventory");
static_assert(sizeof(FHWCosmeticLoadoutInventory) == 0x000170, "Wrong size on FHWCosmeticLoadoutInventory");
static_assert(offsetof(FHWCosmeticLoadoutInventory, Entries) == 0x000108, "Member 'FHWCosmeticLoadoutInventory::Entries' has a wrong offset!");
static_assert(offsetof(FHWCosmeticLoadoutInventory, SlotTypeInfoMap) == 0x000118, "Member 'FHWCosmeticLoadoutInventory::SlotTypeInfoMap' has a wrong offset!");
static_assert(offsetof(FHWCosmeticLoadoutInventory, OwnerComponent) == 0x000168, "Member 'FHWCosmeticLoadoutInventory::OwnerComponent' has a wrong offset!");

// ScriptStruct Hemingway.HWPassiveMeterLargePipData
// 0x0020 (0x0020 - 0x0000)
struct FHWPassiveMeterLargePipData final
{
public:
	class FString                                 DisplayString;                                     // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayNumber;                                     // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                DisplayObject;                                     // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPassiveMeterLargePipData) == 0x000008, "Wrong alignment on FHWPassiveMeterLargePipData");
static_assert(sizeof(FHWPassiveMeterLargePipData) == 0x000020, "Wrong size on FHWPassiveMeterLargePipData");
static_assert(offsetof(FHWPassiveMeterLargePipData, DisplayString) == 0x000000, "Member 'FHWPassiveMeterLargePipData::DisplayString' has a wrong offset!");
static_assert(offsetof(FHWPassiveMeterLargePipData, DisplayNumber) == 0x000010, "Member 'FHWPassiveMeterLargePipData::DisplayNumber' has a wrong offset!");
static_assert(offsetof(FHWPassiveMeterLargePipData, DisplayObject) == 0x000018, "Member 'FHWPassiveMeterLargePipData::DisplayObject' has a wrong offset!");

// ScriptStruct Hemingway.HWPassiveMeterDataField
// 0x0020 (0x0020 - 0x0000)
struct FHWPassiveMeterDataField final
{
public:
	struct FGameplayTag                           FieldTag;                                          // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntegerValue;                                      // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntegerValue2;                                     // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue2;                                       // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DataObject;                                        // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPassiveMeterDataField) == 0x000008, "Wrong alignment on FHWPassiveMeterDataField");
static_assert(sizeof(FHWPassiveMeterDataField) == 0x000020, "Wrong size on FHWPassiveMeterDataField");
static_assert(offsetof(FHWPassiveMeterDataField, FieldTag) == 0x000000, "Member 'FHWPassiveMeterDataField::FieldTag' has a wrong offset!");
static_assert(offsetof(FHWPassiveMeterDataField, IntegerValue) == 0x000008, "Member 'FHWPassiveMeterDataField::IntegerValue' has a wrong offset!");
static_assert(offsetof(FHWPassiveMeterDataField, IntegerValue2) == 0x00000C, "Member 'FHWPassiveMeterDataField::IntegerValue2' has a wrong offset!");
static_assert(offsetof(FHWPassiveMeterDataField, FloatValue) == 0x000010, "Member 'FHWPassiveMeterDataField::FloatValue' has a wrong offset!");
static_assert(offsetof(FHWPassiveMeterDataField, FloatValue2) == 0x000014, "Member 'FHWPassiveMeterDataField::FloatValue2' has a wrong offset!");
static_assert(offsetof(FHWPassiveMeterDataField, DataObject) == 0x000018, "Member 'FHWPassiveMeterDataField::DataObject' has a wrong offset!");

// ScriptStruct Hemingway.HWActiveShieldList
// 0x0010 (0x0118 - 0x0108)
struct FHWActiveShieldList final : public FFastArraySerializer
{
public:
	TArray<struct FActiveShieldEntry>             Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWActiveShieldList) == 0x000008, "Wrong alignment on FHWActiveShieldList");
static_assert(sizeof(FHWActiveShieldList) == 0x000118, "Wrong size on FHWActiveShieldList");
static_assert(offsetof(FHWActiveShieldList, Items) == 0x000108, "Member 'FHWActiveShieldList::Items' has a wrong offset!");

// ScriptStruct Hemingway.HWGameplayParameterRow
// 0x0010 (0x0018 - 0x0008)
struct FHWGameplayParameterRow final : public FTableRowBase
{
public:
	class FName                                   GameplayParameterName;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayParameterType                        GameplayParameterType;                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWGameplayParameterRow) == 0x000008, "Wrong alignment on FHWGameplayParameterRow");
static_assert(sizeof(FHWGameplayParameterRow) == 0x000018, "Wrong size on FHWGameplayParameterRow");
static_assert(offsetof(FHWGameplayParameterRow, GameplayParameterName) == 0x000008, "Member 'FHWGameplayParameterRow::GameplayParameterName' has a wrong offset!");
static_assert(offsetof(FHWGameplayParameterRow, GameplayParameterType) == 0x000010, "Member 'FHWGameplayParameterRow::GameplayParameterType' has a wrong offset!");

// ScriptStruct Hemingway.HWEffectsGrantingVisionForTeam
// 0x0058 (0x0058 - 0x0000)
struct FHWEffectsGrantingVisionForTeam final
{
public:
	struct FGenericTeamId                         TeamGrantingVisionTo;                              // 0x0000(0x0001)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGameplayAbilitySpecHandle>       AbilityGrantingVisionHandles;                      // 0x0008(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHWEffectsGrantingVisionForTeam) == 0x000008, "Wrong alignment on FHWEffectsGrantingVisionForTeam");
static_assert(sizeof(FHWEffectsGrantingVisionForTeam) == 0x000058, "Wrong size on FHWEffectsGrantingVisionForTeam");
static_assert(offsetof(FHWEffectsGrantingVisionForTeam, TeamGrantingVisionTo) == 0x000000, "Member 'FHWEffectsGrantingVisionForTeam::TeamGrantingVisionTo' has a wrong offset!");
static_assert(offsetof(FHWEffectsGrantingVisionForTeam, AbilityGrantingVisionHandles) == 0x000008, "Member 'FHWEffectsGrantingVisionForTeam::AbilityGrantingVisionHandles' has a wrong offset!");

// ScriptStruct Hemingway.HWEffectsGrantingVisionForIndividualList
// 0x0010 (0x0118 - 0x0108)
struct FHWEffectsGrantingVisionForIndividualList final : public FFastArraySerializer
{
public:
	TArray<struct FHWEffectsGrantingVisionForIndividualEntry> Items;                                 // 0x0108(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEffectsGrantingVisionForIndividualList) == 0x000008, "Wrong alignment on FHWEffectsGrantingVisionForIndividualList");
static_assert(sizeof(FHWEffectsGrantingVisionForIndividualList) == 0x000118, "Wrong size on FHWEffectsGrantingVisionForIndividualList");
static_assert(offsetof(FHWEffectsGrantingVisionForIndividualList, Items) == 0x000108, "Member 'FHWEffectsGrantingVisionForIndividualList::Items' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilitySwapInfo
// 0x0040 (0x0040 - 0x0000)
struct FHWAbilitySwapInfo final
{
public:
	TWeakObjectPtr<class UObject>                 SwapObject;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWEquipmentItem*                       SwapEquipmentItem1;                                // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWEquipmentItem*                       SwapEquipmentItem2;                                // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       SwapAbilitySlot1;                                  // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       SwapAbilitySlot2;                                  // 0x0024(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwapDelayTime;                                     // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwapWindowTime;                                    // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWAbilitySwapInfo) == 0x000008, "Wrong alignment on FHWAbilitySwapInfo");
static_assert(sizeof(FHWAbilitySwapInfo) == 0x000040, "Wrong size on FHWAbilitySwapInfo");
static_assert(offsetof(FHWAbilitySwapInfo, SwapObject) == 0x000000, "Member 'FHWAbilitySwapInfo::SwapObject' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapInfo, SwapEquipmentItem1) == 0x000008, "Member 'FHWAbilitySwapInfo::SwapEquipmentItem1' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapInfo, SwapEquipmentItem2) == 0x000010, "Member 'FHWAbilitySwapInfo::SwapEquipmentItem2' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapInfo, SwapAbilitySlot1) == 0x000018, "Member 'FHWAbilitySwapInfo::SwapAbilitySlot1' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapInfo, SwapAbilitySlot2) == 0x000024, "Member 'FHWAbilitySwapInfo::SwapAbilitySlot2' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapInfo, SwapDelayTime) == 0x000030, "Member 'FHWAbilitySwapInfo::SwapDelayTime' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapInfo, SwapWindowTime) == 0x000034, "Member 'FHWAbilitySwapInfo::SwapWindowTime' has a wrong offset!");
static_assert(offsetof(FHWAbilitySwapInfo, AbilityLevel) == 0x000038, "Member 'FHWAbilitySwapInfo::AbilityLevel' has a wrong offset!");

// ScriptStruct Hemingway.HWFiringInstanceTracker
// 0x0028 (0x0028 - 0x0000)
struct FHWFiringInstanceTracker final
{
public:
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilitySystemComponent> TargetASC;                                         // 0x000C(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWFiringInstanceTracker) == 0x000008, "Wrong alignment on FHWFiringInstanceTracker");
static_assert(sizeof(FHWFiringInstanceTracker) == 0x000028, "Wrong size on FHWFiringInstanceTracker");
static_assert(offsetof(FHWFiringInstanceTracker, FiringInstanceId) == 0x000000, "Member 'FHWFiringInstanceTracker::FiringInstanceId' has a wrong offset!");
static_assert(offsetof(FHWFiringInstanceTracker, Timestamp) == 0x000008, "Member 'FHWFiringInstanceTracker::Timestamp' has a wrong offset!");
static_assert(offsetof(FHWFiringInstanceTracker, TargetASC) == 0x00000C, "Member 'FHWFiringInstanceTracker::TargetASC' has a wrong offset!");
static_assert(offsetof(FHWFiringInstanceTracker, EffectClass) == 0x000018, "Member 'FHWFiringInstanceTracker::EffectClass' has a wrong offset!");
static_assert(offsetof(FHWFiringInstanceTracker, Count) == 0x000020, "Member 'FHWFiringInstanceTracker::Count' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentInfo_EffectInfo
// 0x0008 (0x0008 - 0x0000)
struct FHWEquipmentInfo_EffectInfo final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEquipmentInfo_EffectInfo) == 0x000008, "Wrong alignment on FHWEquipmentInfo_EffectInfo");
static_assert(sizeof(FHWEquipmentInfo_EffectInfo) == 0x000008, "Wrong size on FHWEquipmentInfo_EffectInfo");
static_assert(offsetof(FHWEquipmentInfo_EffectInfo, GameplayEffect) == 0x000000, "Member 'FHWEquipmentInfo_EffectInfo::GameplayEffect' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentItem_TooltipNamedFormula
// 0x0020 (0x0020 - 0x0000)
struct FHWEquipmentItem_TooltipNamedFormula final
{
public:
	class FString                                 FormulaName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Formula;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEquipmentItem_TooltipNamedFormula) == 0x000008, "Wrong alignment on FHWEquipmentItem_TooltipNamedFormula");
static_assert(sizeof(FHWEquipmentItem_TooltipNamedFormula) == 0x000020, "Wrong size on FHWEquipmentItem_TooltipNamedFormula");
static_assert(offsetof(FHWEquipmentItem_TooltipNamedFormula, FormulaName) == 0x000000, "Member 'FHWEquipmentItem_TooltipNamedFormula::FormulaName' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_TooltipNamedFormula, Formula) == 0x000010, "Member 'FHWEquipmentItem_TooltipNamedFormula::Formula' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentItem_ItemTooltip_Ability
// 0x0070 (0x0070 - 0x0000)
struct FHWEquipmentItem_ItemTooltip_Ability final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SimplifiedDescription;                             // 0x0010(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DetailedDescription;                               // 0x0028(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHWEquipmentItem_TooltipNamedValue> NamedValues;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHWEquipmentItem_TooltipNamedFormula> NamedFormulas;                               // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHWEquipmentItem_TooltipNamedValueScaling> NamedValueScalings;                     // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEquipmentItem_ItemTooltip_Ability) == 0x000008, "Wrong alignment on FHWEquipmentItem_ItemTooltip_Ability");
static_assert(sizeof(FHWEquipmentItem_ItemTooltip_Ability) == 0x000070, "Wrong size on FHWEquipmentItem_ItemTooltip_Ability");
static_assert(offsetof(FHWEquipmentItem_ItemTooltip_Ability, AbilityTag) == 0x000000, "Member 'FHWEquipmentItem_ItemTooltip_Ability::AbilityTag' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_ItemTooltip_Ability, bEnabled) == 0x000008, "Member 'FHWEquipmentItem_ItemTooltip_Ability::bEnabled' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_ItemTooltip_Ability, SimplifiedDescription) == 0x000010, "Member 'FHWEquipmentItem_ItemTooltip_Ability::SimplifiedDescription' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_ItemTooltip_Ability, DetailedDescription) == 0x000028, "Member 'FHWEquipmentItem_ItemTooltip_Ability::DetailedDescription' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_ItemTooltip_Ability, NamedValues) == 0x000040, "Member 'FHWEquipmentItem_ItemTooltip_Ability::NamedValues' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_ItemTooltip_Ability, NamedFormulas) == 0x000050, "Member 'FHWEquipmentItem_ItemTooltip_Ability::NamedFormulas' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_ItemTooltip_Ability, NamedValueScalings) == 0x000060, "Member 'FHWEquipmentItem_ItemTooltip_Ability::NamedValueScalings' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentItem_AbilityTooltip_Detail
// 0x0038 (0x0038 - 0x0000)
struct FHWEquipmentItem_AbilityTooltip_Detail final
{
public:
	EHWEquipmentItemTooltip_DisplayMode           DisplayMode;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEquipmentItemTooltip_DetailType            DetailLineType;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TalentDisplayMode;                                 // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           KeywordTag;                                        // 0x0004(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LineText;                                          // 0x0010(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 ValueName;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEquipmentItem_AbilityTooltip_Detail) == 0x000008, "Wrong alignment on FHWEquipmentItem_AbilityTooltip_Detail");
static_assert(sizeof(FHWEquipmentItem_AbilityTooltip_Detail) == 0x000038, "Wrong size on FHWEquipmentItem_AbilityTooltip_Detail");
static_assert(offsetof(FHWEquipmentItem_AbilityTooltip_Detail, DisplayMode) == 0x000000, "Member 'FHWEquipmentItem_AbilityTooltip_Detail::DisplayMode' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_AbilityTooltip_Detail, DetailLineType) == 0x000001, "Member 'FHWEquipmentItem_AbilityTooltip_Detail::DetailLineType' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_AbilityTooltip_Detail, TalentDisplayMode) == 0x000002, "Member 'FHWEquipmentItem_AbilityTooltip_Detail::TalentDisplayMode' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_AbilityTooltip_Detail, KeywordTag) == 0x000004, "Member 'FHWEquipmentItem_AbilityTooltip_Detail::KeywordTag' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_AbilityTooltip_Detail, LineText) == 0x000010, "Member 'FHWEquipmentItem_AbilityTooltip_Detail::LineText' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItem_AbilityTooltip_Detail, ValueName) == 0x000028, "Member 'FHWEquipmentItem_AbilityTooltip_Detail::ValueName' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentSpec
// 0x0020 (0x0020 - 0x0000)
struct FHWEquipmentSpec final
{
public:
	class UHWEquipmentItem*                       Equipment;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       DesiredInventorySlot;                              // 0x0008(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelOverride;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            GrantedByEffectHandle;                             // 0x0018(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEquipmentSpec) == 0x000008, "Wrong alignment on FHWEquipmentSpec");
static_assert(sizeof(FHWEquipmentSpec) == 0x000020, "Wrong size on FHWEquipmentSpec");
static_assert(offsetof(FHWEquipmentSpec, Equipment) == 0x000000, "Member 'FHWEquipmentSpec::Equipment' has a wrong offset!");
static_assert(offsetof(FHWEquipmentSpec, DesiredInventorySlot) == 0x000008, "Member 'FHWEquipmentSpec::DesiredInventorySlot' has a wrong offset!");
static_assert(offsetof(FHWEquipmentSpec, LevelOverride) == 0x000014, "Member 'FHWEquipmentSpec::LevelOverride' has a wrong offset!");
static_assert(offsetof(FHWEquipmentSpec, GrantedByEffectHandle) == 0x000018, "Member 'FHWEquipmentSpec::GrantedByEffectHandle' has a wrong offset!");

// ScriptStruct Hemingway.HWCanCraftInfo
// 0x0080 (0x0080 - 0x0000)
struct FHWCanCraftInfo final
{
public:
	bool                                          bCanCraft;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EHWCraftingFailureReason>              FailureReasons;                                    // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UHWEquipmentInstance*>           AllIngredientsToUse;                               // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UHWEquipmentItem*>               AllMissingIngredients;                             // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MissingIngredientCost;                             // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWRecipeIngredientInfo                IngredientInfo;                                    // 0x0040(0x0030)(NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       InventorySlotToUse;                                // 0x0070(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCanCraftInfo) == 0x000008, "Wrong alignment on FHWCanCraftInfo");
static_assert(sizeof(FHWCanCraftInfo) == 0x000080, "Wrong size on FHWCanCraftInfo");
static_assert(offsetof(FHWCanCraftInfo, bCanCraft) == 0x000000, "Member 'FHWCanCraftInfo::bCanCraft' has a wrong offset!");
static_assert(offsetof(FHWCanCraftInfo, FailureReasons) == 0x000008, "Member 'FHWCanCraftInfo::FailureReasons' has a wrong offset!");
static_assert(offsetof(FHWCanCraftInfo, AllIngredientsToUse) == 0x000018, "Member 'FHWCanCraftInfo::AllIngredientsToUse' has a wrong offset!");
static_assert(offsetof(FHWCanCraftInfo, AllMissingIngredients) == 0x000028, "Member 'FHWCanCraftInfo::AllMissingIngredients' has a wrong offset!");
static_assert(offsetof(FHWCanCraftInfo, MissingIngredientCost) == 0x000038, "Member 'FHWCanCraftInfo::MissingIngredientCost' has a wrong offset!");
static_assert(offsetof(FHWCanCraftInfo, IngredientInfo) == 0x000040, "Member 'FHWCanCraftInfo::IngredientInfo' has a wrong offset!");
static_assert(offsetof(FHWCanCraftInfo, InventorySlotToUse) == 0x000070, "Member 'FHWCanCraftInfo::InventorySlotToUse' has a wrong offset!");

// ScriptStruct Hemingway.HWInventoryList
// 0x0068 (0x0170 - 0x0108)
struct FHWInventoryList final : public FFastArraySerializer
{
public:
	TArray<struct FHWInventoryEntry>              Entries;                                           // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FSlotTypeArrayInfo> SlotTypeInfoMap;                            // 0x0118(0x0050)(RepSkip, NativeAccessSpecifierPrivate)
	class UHWInventoryManagerComponent*           OwnerComponent;                                    // 0x0168(0x0008)(ExportObject, ZeroConstructor, InstancedReference, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHWInventoryList) == 0x000008, "Wrong alignment on FHWInventoryList");
static_assert(sizeof(FHWInventoryList) == 0x000170, "Wrong size on FHWInventoryList");
static_assert(offsetof(FHWInventoryList, Entries) == 0x000108, "Member 'FHWInventoryList::Entries' has a wrong offset!");
static_assert(offsetof(FHWInventoryList, SlotTypeInfoMap) == 0x000118, "Member 'FHWInventoryList::SlotTypeInfoMap' has a wrong offset!");
static_assert(offsetof(FHWInventoryList, OwnerComponent) == 0x000168, "Member 'FHWInventoryList::OwnerComponent' has a wrong offset!");

// ScriptStruct Hemingway.HWInventoryTransaction
// 0x0048 (0x0048 - 0x0000)
struct FHWInventoryTransaction final
{
public:
	EHWInventoryTransactionType                   TransactionType;                                   // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWInventoryModifierType                      ModifierType;                                      // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWInventoryTransactionItem>    DestroyedEquipmentInstances;                       // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWInventoryTransactionItem>    AddedEquipmentInstances;                           // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHWInventoryTransactionItem            InstigatingTransactionItem;                        // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GoldDelta;                                         // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWInventoryTransaction) == 0x000008, "Wrong alignment on FHWInventoryTransaction");
static_assert(sizeof(FHWInventoryTransaction) == 0x000048, "Wrong size on FHWInventoryTransaction");
static_assert(offsetof(FHWInventoryTransaction, TransactionType) == 0x000000, "Member 'FHWInventoryTransaction::TransactionType' has a wrong offset!");
static_assert(offsetof(FHWInventoryTransaction, ModifierType) == 0x000001, "Member 'FHWInventoryTransaction::ModifierType' has a wrong offset!");
static_assert(offsetof(FHWInventoryTransaction, DestroyedEquipmentInstances) == 0x000008, "Member 'FHWInventoryTransaction::DestroyedEquipmentInstances' has a wrong offset!");
static_assert(offsetof(FHWInventoryTransaction, AddedEquipmentInstances) == 0x000018, "Member 'FHWInventoryTransaction::AddedEquipmentInstances' has a wrong offset!");
static_assert(offsetof(FHWInventoryTransaction, InstigatingTransactionItem) == 0x000028, "Member 'FHWInventoryTransaction::InstigatingTransactionItem' has a wrong offset!");
static_assert(offsetof(FHWInventoryTransaction, GoldDelta) == 0x000040, "Member 'FHWInventoryTransaction::GoldDelta' has a wrong offset!");

// ScriptStruct Hemingway.HWActiveItemInput
// 0x000C (0x000C - 0x0000)
struct FHWActiveItemInput final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x4];                                        // 0x0008(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWActiveItemInput) == 0x000004, "Wrong alignment on FHWActiveItemInput");
static_assert(sizeof(FHWActiveItemInput) == 0x00000C, "Wrong size on FHWActiveItemInput");
static_assert(offsetof(FHWActiveItemInput, InputTag) == 0x000000, "Member 'FHWActiveItemInput::InputTag' has a wrong offset!");

// ScriptStruct Hemingway.HWEventInstanceData
// 0x0098 (0x0098 - 0x0000)
struct FHWEventInstanceData final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventContext                        Context;                                           // 0x0008(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         TimeAdded;                                         // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWEventInstanceData) == 0x000008, "Wrong alignment on FHWEventInstanceData");
static_assert(sizeof(FHWEventInstanceData) == 0x000098, "Wrong size on FHWEventInstanceData");
static_assert(offsetof(FHWEventInstanceData, EventTag) == 0x000000, "Member 'FHWEventInstanceData::EventTag' has a wrong offset!");
static_assert(offsetof(FHWEventInstanceData, Context) == 0x000008, "Member 'FHWEventInstanceData::Context' has a wrong offset!");
static_assert(offsetof(FHWEventInstanceData, TimeAdded) == 0x000090, "Member 'FHWEventInstanceData::TimeAdded' has a wrong offset!");

// ScriptStruct Hemingway.HWDeployableRepositionData
// 0x0038 (0x0038 - 0x0000)
struct FHWDeployableRepositionData final
{
public:
	struct FVector                                OldLocation;                                       // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewLocation;                                       // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttachedActor;                                     // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWDeployableRepositionData) == 0x000008, "Wrong alignment on FHWDeployableRepositionData");
static_assert(sizeof(FHWDeployableRepositionData) == 0x000038, "Wrong size on FHWDeployableRepositionData");
static_assert(offsetof(FHWDeployableRepositionData, OldLocation) == 0x000000, "Member 'FHWDeployableRepositionData::OldLocation' has a wrong offset!");
static_assert(offsetof(FHWDeployableRepositionData, NewLocation) == 0x000018, "Member 'FHWDeployableRepositionData::NewLocation' has a wrong offset!");
static_assert(offsetof(FHWDeployableRepositionData, AttachedActor) == 0x000030, "Member 'FHWDeployableRepositionData::AttachedActor' has a wrong offset!");

// ScriptStruct Hemingway.HWDeployableWallPushActorInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FHWDeployableWallPushActorInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWDeployableWallPushActorInfo) == 0x000008, "Wrong alignment on FHWDeployableWallPushActorInfo");
static_assert(sizeof(FHWDeployableWallPushActorInfo) == 0x000020, "Wrong size on FHWDeployableWallPushActorInfo");

// ScriptStruct Hemingway.HWFlightMoveSpeedValues
// 0x000C (0x000C - 0x0000)
struct FHWFlightMoveSpeedValues final
{
public:
	float                                         ForwardMoveSpeedValue;                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackpedalMoveSpeedValue;                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeMoveSpeedValue;                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWFlightMoveSpeedValues) == 0x000004, "Wrong alignment on FHWFlightMoveSpeedValues");
static_assert(sizeof(FHWFlightMoveSpeedValues) == 0x00000C, "Wrong size on FHWFlightMoveSpeedValues");
static_assert(offsetof(FHWFlightMoveSpeedValues, ForwardMoveSpeedValue) == 0x000000, "Member 'FHWFlightMoveSpeedValues::ForwardMoveSpeedValue' has a wrong offset!");
static_assert(offsetof(FHWFlightMoveSpeedValues, BackpedalMoveSpeedValue) == 0x000004, "Member 'FHWFlightMoveSpeedValues::BackpedalMoveSpeedValue' has a wrong offset!");
static_assert(offsetof(FHWFlightMoveSpeedValues, StrafeMoveSpeedValue) == 0x000008, "Member 'FHWFlightMoveSpeedValues::StrafeMoveSpeedValue' has a wrong offset!");

// ScriptStruct Hemingway.HWGrabInfo
// 0x0028 (0x0028 - 0x0000)
struct FHWGrabInfo final
{
public:
	class AHWCharacter_Base*                      Source;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      Target;                                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      Instigator;                                        // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       InstigatingAbility;                                // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationOverride;                                  // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetCCImmune;                                 // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWGrabInfo) == 0x000008, "Wrong alignment on FHWGrabInfo");
static_assert(sizeof(FHWGrabInfo) == 0x000028, "Wrong size on FHWGrabInfo");
static_assert(offsetof(FHWGrabInfo, Source) == 0x000000, "Member 'FHWGrabInfo::Source' has a wrong offset!");
static_assert(offsetof(FHWGrabInfo, Target) == 0x000008, "Member 'FHWGrabInfo::Target' has a wrong offset!");
static_assert(offsetof(FHWGrabInfo, Instigator) == 0x000010, "Member 'FHWGrabInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FHWGrabInfo, InstigatingAbility) == 0x000018, "Member 'FHWGrabInfo::InstigatingAbility' has a wrong offset!");
static_assert(offsetof(FHWGrabInfo, DurationOverride) == 0x000020, "Member 'FHWGrabInfo::DurationOverride' has a wrong offset!");
static_assert(offsetof(FHWGrabInfo, bIsTargetCCImmune) == 0x000024, "Member 'FHWGrabInfo::bIsTargetCCImmune' has a wrong offset!");

// ScriptStruct Hemingway.HWProjectileTargetCollisionSettings
// 0x001C (0x001C - 0x0000)
struct FHWProjectileTargetCollisionSettings final
{
public:
	EHWProjectileTargetCollisionType              CollisionType;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SphereRadius;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CapsuleRadius;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CapsuleHalfHeight;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector3f                              BoxHalfExtent;                                     // 0x0010(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHWProjectileTargetCollisionSettings) == 0x000004, "Wrong alignment on FHWProjectileTargetCollisionSettings");
static_assert(sizeof(FHWProjectileTargetCollisionSettings) == 0x00001C, "Wrong size on FHWProjectileTargetCollisionSettings");
static_assert(offsetof(FHWProjectileTargetCollisionSettings, CollisionType) == 0x000000, "Member 'FHWProjectileTargetCollisionSettings::CollisionType' has a wrong offset!");
static_assert(offsetof(FHWProjectileTargetCollisionSettings, SphereRadius) == 0x000004, "Member 'FHWProjectileTargetCollisionSettings::SphereRadius' has a wrong offset!");
static_assert(offsetof(FHWProjectileTargetCollisionSettings, CapsuleRadius) == 0x000008, "Member 'FHWProjectileTargetCollisionSettings::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(FHWProjectileTargetCollisionSettings, CapsuleHalfHeight) == 0x00000C, "Member 'FHWProjectileTargetCollisionSettings::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FHWProjectileTargetCollisionSettings, BoxHalfExtent) == 0x000010, "Member 'FHWProjectileTargetCollisionSettings::BoxHalfExtent' has a wrong offset!");

// ScriptStruct Hemingway.RHPlayerMuteFlags
// 0x0004 (0x0004 - 0x0000)
struct FRHPlayerMuteFlags final
{
public:
	bool                                          bIsVoiceMuted;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTextMuted;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVGSMuted;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPingsMuted;                                     // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRHPlayerMuteFlags) == 0x000001, "Wrong alignment on FRHPlayerMuteFlags");
static_assert(sizeof(FRHPlayerMuteFlags) == 0x000004, "Wrong size on FRHPlayerMuteFlags");
static_assert(offsetof(FRHPlayerMuteFlags, bIsVoiceMuted) == 0x000000, "Member 'FRHPlayerMuteFlags::bIsVoiceMuted' has a wrong offset!");
static_assert(offsetof(FRHPlayerMuteFlags, bIsTextMuted) == 0x000001, "Member 'FRHPlayerMuteFlags::bIsTextMuted' has a wrong offset!");
static_assert(offsetof(FRHPlayerMuteFlags, bIsVGSMuted) == 0x000002, "Member 'FRHPlayerMuteFlags::bIsVGSMuted' has a wrong offset!");
static_assert(offsetof(FRHPlayerMuteFlags, bIsPingsMuted) == 0x000003, "Member 'FRHPlayerMuteFlags::bIsPingsMuted' has a wrong offset!");

// ScriptStruct Hemingway.HWRespawnData
// 0x0028 (0x0028 - 0x0000)
struct FHWRespawnData final
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0000(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           RespawnTimerHandle;                                // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWRespawnData) == 0x000008, "Wrong alignment on FHWRespawnData");
static_assert(sizeof(FHWRespawnData) == 0x000028, "Wrong size on FHWRespawnData");
static_assert(offsetof(FHWRespawnData, PlayerId) == 0x000000, "Member 'FHWRespawnData::PlayerId' has a wrong offset!");
static_assert(offsetof(FHWRespawnData, RespawnTimerHandle) == 0x000020, "Member 'FHWRespawnData::RespawnTimerHandle' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerProfile
// 0x0008 (0x0030 - 0x0028)
struct FHWPlayerProfile final : public FRHPlayerProfile
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0028(0x0001)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWPlayerProfile) == 0x000008, "Wrong alignment on FHWPlayerProfile");
static_assert(sizeof(FHWPlayerProfile) == 0x000030, "Wrong size on FHWPlayerProfile");
static_assert(offsetof(FHWPlayerProfile, TeamId) == 0x000028, "Member 'FHWPlayerProfile::TeamId' has a wrong offset!");

// ScriptStruct Hemingway.ItemTagFloatPair
// 0x000C (0x000C - 0x0000)
struct FItemTagFloatPair final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTagFloatPair) == 0x000004, "Wrong alignment on FItemTagFloatPair");
static_assert(sizeof(FItemTagFloatPair) == 0x00000C, "Wrong size on FItemTagFloatPair");
static_assert(offsetof(FItemTagFloatPair, Tag) == 0x000000, "Member 'FItemTagFloatPair::Tag' has a wrong offset!");
static_assert(offsetof(FItemTagFloatPair, Value) == 0x000008, "Member 'FItemTagFloatPair::Value' has a wrong offset!");

// ScriptStruct Hemingway.HWPartyMembers
// 0x0010 (0x0010 - 0x0000)
struct FHWPartyMembers final
{
public:
	TArray<struct FRHAPI_SessionPlayer>           PartyMembers;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPartyMembers) == 0x000008, "Wrong alignment on FHWPartyMembers");
static_assert(sizeof(FHWPartyMembers) == 0x000010, "Wrong size on FHWPartyMembers");
static_assert(offsetof(FHWPartyMembers, PartyMembers) == 0x000000, "Member 'FHWPartyMembers::PartyMembers' has a wrong offset!");

// ScriptStruct Hemingway.HWApolloA04HitchHikerInfo
// 0x0030 (0x0030 - 0x0000)
struct FHWApolloA04HitchHikerInfo final
{
public:
	TWeakObjectPtr<class AHWCharacter_Base>       HitchHiker;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PickUpLocation;                                    // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_GameplayGrab*            ChariotGrab;                                       // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWApolloA04HitchHikerInfo) == 0x000008, "Wrong alignment on FHWApolloA04HitchHikerInfo");
static_assert(sizeof(FHWApolloA04HitchHikerInfo) == 0x000030, "Wrong size on FHWApolloA04HitchHikerInfo");
static_assert(offsetof(FHWApolloA04HitchHikerInfo, HitchHiker) == 0x000000, "Member 'FHWApolloA04HitchHikerInfo::HitchHiker' has a wrong offset!");
static_assert(offsetof(FHWApolloA04HitchHikerInfo, PickUpLocation) == 0x000008, "Member 'FHWApolloA04HitchHikerInfo::PickUpLocation' has a wrong offset!");
static_assert(offsetof(FHWApolloA04HitchHikerInfo, Index) == 0x000020, "Member 'FHWApolloA04HitchHikerInfo::Index' has a wrong offset!");
static_assert(offsetof(FHWApolloA04HitchHikerInfo, ChariotGrab) == 0x000028, "Member 'FHWApolloA04HitchHikerInfo::ChariotGrab' has a wrong offset!");

// ScriptStruct Hemingway.HWBariBellRecallInfo
// 0x0010 (0x0010 - 0x0000)
struct FHWBariBellRecallInfo final
{
public:
	class USceneComponent*                        RecallTargetComponent;                             // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToRecall;                                      // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecallStartTime;                                   // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWBariBellRecallInfo) == 0x000008, "Wrong alignment on FHWBariBellRecallInfo");
static_assert(sizeof(FHWBariBellRecallInfo) == 0x000010, "Wrong size on FHWBariBellRecallInfo");
static_assert(offsetof(FHWBariBellRecallInfo, RecallTargetComponent) == 0x000000, "Member 'FHWBariBellRecallInfo::RecallTargetComponent' has a wrong offset!");
static_assert(offsetof(FHWBariBellRecallInfo, TimeToRecall) == 0x000008, "Member 'FHWBariBellRecallInfo::TimeToRecall' has a wrong offset!");
static_assert(offsetof(FHWBariBellRecallInfo, RecallStartTime) == 0x00000C, "Member 'FHWBariBellRecallInfo::RecallStartTime' has a wrong offset!");

// ScriptStruct Hemingway.HWMulanGrappleInfo
// 0x00F8 (0x00F8 - 0x0000)
struct FHWMulanGrappleInfo final
{
public:
	class AHWCharacter_Base*                      TargetCharacter;                                   // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsWallGrapple;                                    // 0x00F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWMulanGrappleInfo) == 0x000008, "Wrong alignment on FHWMulanGrappleInfo");
static_assert(sizeof(FHWMulanGrappleInfo) == 0x0000F8, "Wrong size on FHWMulanGrappleInfo");
static_assert(offsetof(FHWMulanGrappleInfo, TargetCharacter) == 0x000000, "Member 'FHWMulanGrappleInfo::TargetCharacter' has a wrong offset!");
static_assert(offsetof(FHWMulanGrappleInfo, Hit) == 0x000008, "Member 'FHWMulanGrappleInfo::Hit' has a wrong offset!");
static_assert(offsetof(FHWMulanGrappleInfo, bIsWallGrapple) == 0x0000F0, "Member 'FHWMulanGrappleInfo::bIsWallGrapple' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilityCancelTagRequirement
// 0x0040 (0x0040 - 0x0000)
struct FHWAbilityCancelTagRequirement final
{
public:
	struct FGameplayTagContainer                  HasAnyTags;                                        // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  WithoutTags;                                       // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAbilityCancelTagRequirement) == 0x000008, "Wrong alignment on FHWAbilityCancelTagRequirement");
static_assert(sizeof(FHWAbilityCancelTagRequirement) == 0x000040, "Wrong size on FHWAbilityCancelTagRequirement");
static_assert(offsetof(FHWAbilityCancelTagRequirement, HasAnyTags) == 0x000000, "Member 'FHWAbilityCancelTagRequirement::HasAnyTags' has a wrong offset!");
static_assert(offsetof(FHWAbilityCancelTagRequirement, WithoutTags) == 0x000020, "Member 'FHWAbilityCancelTagRequirement::WithoutTags' has a wrong offset!");

// ScriptStruct Hemingway.HWAbilityBlockCancelAbilityRuleRow
// 0x0048 (0x0050 - 0x0008)
struct FHWAbilityBlockCancelAbilityRuleRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockTags;                                         // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CancelTags;                                        // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAbilityBlockCancelAbilityRuleRow) == 0x000008, "Wrong alignment on FHWAbilityBlockCancelAbilityRuleRow");
static_assert(sizeof(FHWAbilityBlockCancelAbilityRuleRow) == 0x000050, "Wrong size on FHWAbilityBlockCancelAbilityRuleRow");
static_assert(offsetof(FHWAbilityBlockCancelAbilityRuleRow, AbilityTag) == 0x000008, "Member 'FHWAbilityBlockCancelAbilityRuleRow::AbilityTag' has a wrong offset!");
static_assert(offsetof(FHWAbilityBlockCancelAbilityRuleRow, BlockTags) == 0x000010, "Member 'FHWAbilityBlockCancelAbilityRuleRow::BlockTags' has a wrong offset!");
static_assert(offsetof(FHWAbilityBlockCancelAbilityRuleRow, CancelTags) == 0x000030, "Member 'FHWAbilityBlockCancelAbilityRuleRow::CancelTags' has a wrong offset!");

// ScriptStruct Hemingway.HWTagBlockCancelAbilityRuleRow
// 0x0068 (0x0070 - 0x0008)
struct FHWTagBlockCancelAbilityRuleRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           TagTrigger;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockTags;                                         // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHWAbilityCancelTagRequirement         CancelTags;                                        // 0x0030(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWTagBlockCancelAbilityRuleRow) == 0x000008, "Wrong alignment on FHWTagBlockCancelAbilityRuleRow");
static_assert(sizeof(FHWTagBlockCancelAbilityRuleRow) == 0x000070, "Wrong size on FHWTagBlockCancelAbilityRuleRow");
static_assert(offsetof(FHWTagBlockCancelAbilityRuleRow, TagTrigger) == 0x000008, "Member 'FHWTagBlockCancelAbilityRuleRow::TagTrigger' has a wrong offset!");
static_assert(offsetof(FHWTagBlockCancelAbilityRuleRow, BlockTags) == 0x000010, "Member 'FHWTagBlockCancelAbilityRuleRow::BlockTags' has a wrong offset!");
static_assert(offsetof(FHWTagBlockCancelAbilityRuleRow, CancelTags) == 0x000030, "Member 'FHWTagBlockCancelAbilityRuleRow::CancelTags' has a wrong offset!");

// ScriptStruct Hemingway.HWStealthRevealRuleRow
// 0x0098 (0x00A0 - 0x0008)
struct FHWStealthRevealRuleRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           RevealRuleTag;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               RuleActivationTagRequirements;                     // 0x0010(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OnlyRevealIfObserverAppliedTag;                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWStealthRevealRuleRow) == 0x000008, "Wrong alignment on FHWStealthRevealRuleRow");
static_assert(sizeof(FHWStealthRevealRuleRow) == 0x0000A0, "Wrong size on FHWStealthRevealRuleRow");
static_assert(offsetof(FHWStealthRevealRuleRow, RevealRuleTag) == 0x000008, "Member 'FHWStealthRevealRuleRow::RevealRuleTag' has a wrong offset!");
static_assert(offsetof(FHWStealthRevealRuleRow, RuleActivationTagRequirements) == 0x000010, "Member 'FHWStealthRevealRuleRow::RuleActivationTagRequirements' has a wrong offset!");
static_assert(offsetof(FHWStealthRevealRuleRow, OnlyRevealIfObserverAppliedTag) == 0x000098, "Member 'FHWStealthRevealRuleRow::OnlyRevealIfObserverAppliedTag' has a wrong offset!");

// ScriptStruct Hemingway.HWInputAction
// 0x0010 (0x0010 - 0x0000)
struct FHWInputAction final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWInputAction) == 0x000008, "Wrong alignment on FHWInputAction");
static_assert(sizeof(FHWInputAction) == 0x000010, "Wrong size on FHWInputAction");
static_assert(offsetof(FHWInputAction, InputAction) == 0x000000, "Member 'FHWInputAction::InputAction' has a wrong offset!");
static_assert(offsetof(FHWInputAction, InputTag) == 0x000008, "Member 'FHWInputAction::InputTag' has a wrong offset!");

// ScriptStruct Hemingway.HWMappingContextTableRow
// 0x00E0 (0x00E8 - 0x0008)
struct FHWMappingContextTableRow final : public FTableRowBase
{
public:
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           MappingContextTag;                                 // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWMappingContextData                  MappingContextData;                                // 0x0018(0x00A8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CustomPresetDisplayName;                           // 0x00C0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 CustomPresetLookupName;                            // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWMappingContextTableRow) == 0x000008, "Wrong alignment on FHWMappingContextTableRow");
static_assert(sizeof(FHWMappingContextTableRow) == 0x0000E8, "Wrong size on FHWMappingContextTableRow");
static_assert(offsetof(FHWMappingContextTableRow, bEnabled) == 0x000008, "Member 'FHWMappingContextTableRow::bEnabled' has a wrong offset!");
static_assert(offsetof(FHWMappingContextTableRow, MappingContextTag) == 0x00000C, "Member 'FHWMappingContextTableRow::MappingContextTag' has a wrong offset!");
static_assert(offsetof(FHWMappingContextTableRow, MappingContextData) == 0x000018, "Member 'FHWMappingContextTableRow::MappingContextData' has a wrong offset!");
static_assert(offsetof(FHWMappingContextTableRow, CustomPresetDisplayName) == 0x0000C0, "Member 'FHWMappingContextTableRow::CustomPresetDisplayName' has a wrong offset!");
static_assert(offsetof(FHWMappingContextTableRow, CustomPresetLookupName) == 0x0000D8, "Member 'FHWMappingContextTableRow::CustomPresetLookupName' has a wrong offset!");

// ScriptStruct Hemingway.HWCosmeticMaterialSet
// 0x0010 (0x0010 - 0x0000)
struct FHWCosmeticMaterialSet final
{
public:
	TArray<TSoftObjectPtr<class UMaterialInterface>> Materials;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCosmeticMaterialSet) == 0x000008, "Wrong alignment on FHWCosmeticMaterialSet");
static_assert(sizeof(FHWCosmeticMaterialSet) == 0x000010, "Wrong size on FHWCosmeticMaterialSet");
static_assert(offsetof(FHWCosmeticMaterialSet, Materials) == 0x000000, "Member 'FHWCosmeticMaterialSet::Materials' has a wrong offset!");

// ScriptStruct Hemingway.SpectateTargetInfo
// 0x0048 (0x0048 - 0x0000)
struct FSpectateTargetInfo final
{
public:
	TWeakObjectPtr<class AHWPlayerState>          Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrigCameraFOV;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrigCameraSpringArmLength;                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OrigCameraLagEnabled;                              // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OrigCameraRotationLagEnabled;                      // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OrigCameraTargetOffset;                            // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastValidPosition;                                 // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpectateTargetInfo) == 0x000008, "Wrong alignment on FSpectateTargetInfo");
static_assert(sizeof(FSpectateTargetInfo) == 0x000048, "Wrong size on FSpectateTargetInfo");
static_assert(offsetof(FSpectateTargetInfo, Target) == 0x000000, "Member 'FSpectateTargetInfo::Target' has a wrong offset!");
static_assert(offsetof(FSpectateTargetInfo, OrigCameraFOV) == 0x000008, "Member 'FSpectateTargetInfo::OrigCameraFOV' has a wrong offset!");
static_assert(offsetof(FSpectateTargetInfo, OrigCameraSpringArmLength) == 0x00000C, "Member 'FSpectateTargetInfo::OrigCameraSpringArmLength' has a wrong offset!");
static_assert(offsetof(FSpectateTargetInfo, OrigCameraLagEnabled) == 0x000010, "Member 'FSpectateTargetInfo::OrigCameraLagEnabled' has a wrong offset!");
static_assert(offsetof(FSpectateTargetInfo, OrigCameraRotationLagEnabled) == 0x000011, "Member 'FSpectateTargetInfo::OrigCameraRotationLagEnabled' has a wrong offset!");
static_assert(offsetof(FSpectateTargetInfo, OrigCameraTargetOffset) == 0x000018, "Member 'FSpectateTargetInfo::OrigCameraTargetOffset' has a wrong offset!");
static_assert(offsetof(FSpectateTargetInfo, LastValidPosition) == 0x000030, "Member 'FSpectateTargetInfo::LastValidPosition' has a wrong offset!");

// ScriptStruct Hemingway.QuestContainer
// 0x0010 (0x0010 - 0x0000)
struct FQuestContainer final
{
public:
	TArray<class UHWQuest*>                       QuestList;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestContainer) == 0x000008, "Wrong alignment on FQuestContainer");
static_assert(sizeof(FQuestContainer) == 0x000010, "Wrong size on FQuestContainer");
static_assert(offsetof(FQuestContainer, QuestList) == 0x000000, "Member 'FQuestContainer::QuestList' has a wrong offset!");

// ScriptStruct Hemingway.PlayerQuestPendingInventory
// 0x0010 (0x0010 - 0x0000)
struct FPlayerQuestPendingInventory final
{
public:
	TArray<class URH_PlayerOrderEntry*>           PlayerOrder;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerQuestPendingInventory) == 0x000008, "Wrong alignment on FPlayerQuestPendingInventory");
static_assert(sizeof(FPlayerQuestPendingInventory) == 0x000010, "Wrong size on FPlayerQuestPendingInventory");
static_assert(offsetof(FPlayerQuestPendingInventory, PlayerOrder) == 0x000000, "Member 'FPlayerQuestPendingInventory::PlayerOrder' has a wrong offset!");

// ScriptStruct Hemingway.HWEventParameterPair
// 0x0020 (0x0020 - 0x0000)
struct FHWEventParameterPair final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWEventParameterPair) == 0x000008, "Wrong alignment on FHWEventParameterPair");
static_assert(sizeof(FHWEventParameterPair) == 0x000020, "Wrong size on FHWEventParameterPair");
static_assert(offsetof(FHWEventParameterPair, Key) == 0x000000, "Member 'FHWEventParameterPair::Key' has a wrong offset!");
static_assert(offsetof(FHWEventParameterPair, Value) == 0x000010, "Member 'FHWEventParameterPair::Value' has a wrong offset!");

// ScriptStruct Hemingway.HWInstanceInfo_PlayerDataList
// 0x00A0 (0x00A0 - 0x0000)
struct FHWInstanceInfo_PlayerDataList final
{
public:
	TMap<struct FGuid, struct FHWInstanceInfo_PlayerData> Players;                                   // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FHWInstanceInfo_PlayerData> Bots;                                      // 0x0050(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWInstanceInfo_PlayerDataList) == 0x000008, "Wrong alignment on FHWInstanceInfo_PlayerDataList");
static_assert(sizeof(FHWInstanceInfo_PlayerDataList) == 0x0000A0, "Wrong size on FHWInstanceInfo_PlayerDataList");
static_assert(offsetof(FHWInstanceInfo_PlayerDataList, Players) == 0x000000, "Member 'FHWInstanceInfo_PlayerDataList::Players' has a wrong offset!");
static_assert(offsetof(FHWInstanceInfo_PlayerDataList, Bots) == 0x000050, "Member 'FHWInstanceInfo_PlayerDataList::Bots' has a wrong offset!");

// ScriptStruct Hemingway.HWCustomBotConfig_Game
// 0x0050 (0x0050 - 0x0000)
struct FHWCustomBotConfig_Game final
{
public:
	TMap<int32, struct FHWCustomBotConfig_Team>   TeamNumToTeamBotConfigs;                           // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCustomBotConfig_Game) == 0x000008, "Wrong alignment on FHWCustomBotConfig_Game");
static_assert(sizeof(FHWCustomBotConfig_Game) == 0x000050, "Wrong size on FHWCustomBotConfig_Game");
static_assert(offsetof(FHWCustomBotConfig_Game, TeamNumToTeamBotConfigs) == 0x000000, "Member 'FHWCustomBotConfig_Game::TeamNumToTeamBotConfigs' has a wrong offset!");

// ScriptStruct Hemingway.HWSkinTagAbilityEntry
// 0x0014 (0x0014 - 0x0000)
struct FHWSkinTagAbilityEntry final
{
public:
	struct FHWInventorySlot                       InventorySlot;                                     // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkinTagValue;                                      // 0x000C(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSkinTagAbilityEntry) == 0x000004, "Wrong alignment on FHWSkinTagAbilityEntry");
static_assert(sizeof(FHWSkinTagAbilityEntry) == 0x000014, "Wrong size on FHWSkinTagAbilityEntry");
static_assert(offsetof(FHWSkinTagAbilityEntry, InventorySlot) == 0x000000, "Member 'FHWSkinTagAbilityEntry::InventorySlot' has a wrong offset!");
static_assert(offsetof(FHWSkinTagAbilityEntry, SkinTagValue) == 0x00000C, "Member 'FHWSkinTagAbilityEntry::SkinTagValue' has a wrong offset!");

// ScriptStruct Hemingway.HWStatTracker
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FHWStatTracker final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWStatTracker) == 0x000004, "Wrong alignment on FHWStatTracker");
static_assert(sizeof(FHWStatTracker) == 0x00000C, "Wrong size on FHWStatTracker");

// ScriptStruct Hemingway.HWAudioClassConfig
// 0x0010 (0x0018 - 0x0008)
struct FHWAudioClassConfig final : public FTableRowBase
{
public:
	class USoundMix*                              SoundMix;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                            SoundClass;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAudioClassConfig) == 0x000008, "Wrong alignment on FHWAudioClassConfig");
static_assert(sizeof(FHWAudioClassConfig) == 0x000018, "Wrong size on FHWAudioClassConfig");
static_assert(offsetof(FHWAudioClassConfig, SoundMix) == 0x000008, "Member 'FHWAudioClassConfig::SoundMix' has a wrong offset!");
static_assert(offsetof(FHWAudioClassConfig, SoundClass) == 0x000010, "Member 'FHWAudioClassConfig::SoundClass' has a wrong offset!");

// ScriptStruct Hemingway.HWVolumeLoweringMap
// 0x0010 (0x0018 - 0x0008)
struct FHWVolumeLoweringMap final : public FTableRowBase
{
public:
	class USoundMix*                              SoundMix;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumSounds;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumSounds;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVolumeLoweringMap) == 0x000008, "Wrong alignment on FHWVolumeLoweringMap");
static_assert(sizeof(FHWVolumeLoweringMap) == 0x000018, "Wrong size on FHWVolumeLoweringMap");
static_assert(offsetof(FHWVolumeLoweringMap, SoundMix) == 0x000008, "Member 'FHWVolumeLoweringMap::SoundMix' has a wrong offset!");
static_assert(offsetof(FHWVolumeLoweringMap, MinimumSounds) == 0x000010, "Member 'FHWVolumeLoweringMap::MinimumSounds' has a wrong offset!");
static_assert(offsetof(FHWVolumeLoweringMap, MaximumSounds) == 0x000014, "Member 'FHWVolumeLoweringMap::MaximumSounds' has a wrong offset!");

// ScriptStruct Hemingway.HWVOConfigRow
// 0x0030 (0x0038 - 0x0008)
struct FHWVOConfigRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           VOTag;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMetaSoundSource>        VOMetaSoundSource;                                 // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVOConfigRow) == 0x000008, "Wrong alignment on FHWVOConfigRow");
static_assert(sizeof(FHWVOConfigRow) == 0x000038, "Wrong size on FHWVOConfigRow");
static_assert(offsetof(FHWVOConfigRow, VOTag) == 0x000008, "Member 'FHWVOConfigRow::VOTag' has a wrong offset!");
static_assert(offsetof(FHWVOConfigRow, VOMetaSoundSource) == 0x000010, "Member 'FHWVOConfigRow::VOMetaSoundSource' has a wrong offset!");

// ScriptStruct Hemingway.HWAudioStingerPlayInfo
// 0x002C (0x002C - 0x0000)
struct FHWAudioStingerPlayInfo final
{
public:
	struct FAssetRequestKey                       AssetKey;                                          // 0x0000(0x001C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldFadeOutMusicTrack;                          // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MusicTrackFadeOutTime;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAudioStingerPlayInfo) == 0x000004, "Wrong alignment on FHWAudioStingerPlayInfo");
static_assert(sizeof(FHWAudioStingerPlayInfo) == 0x00002C, "Wrong size on FHWAudioStingerPlayInfo");
static_assert(offsetof(FHWAudioStingerPlayInfo, AssetKey) == 0x000000, "Member 'FHWAudioStingerPlayInfo::AssetKey' has a wrong offset!");
static_assert(offsetof(FHWAudioStingerPlayInfo, FadeInTime) == 0x00001C, "Member 'FHWAudioStingerPlayInfo::FadeInTime' has a wrong offset!");
static_assert(offsetof(FHWAudioStingerPlayInfo, FadeOutTime) == 0x000020, "Member 'FHWAudioStingerPlayInfo::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FHWAudioStingerPlayInfo, bShouldFadeOutMusicTrack) == 0x000024, "Member 'FHWAudioStingerPlayInfo::bShouldFadeOutMusicTrack' has a wrong offset!");
static_assert(offsetof(FHWAudioStingerPlayInfo, MusicTrackFadeOutTime) == 0x000028, "Member 'FHWAudioStingerPlayInfo::MusicTrackFadeOutTime' has a wrong offset!");

// ScriptStruct Hemingway.HWCallToActionItemHandlerMap
// 0x0058 (0x0058 - 0x0000)
struct FHWCallToActionItemHandlerMap final
{
public:
	class UHWCallToActionItemHandler*             ItemHandler;                                       // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<struct FRH_ItemId>                       MappedItems;                                       // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCallToActionItemHandlerMap) == 0x000008, "Wrong alignment on FHWCallToActionItemHandlerMap");
static_assert(sizeof(FHWCallToActionItemHandlerMap) == 0x000058, "Wrong size on FHWCallToActionItemHandlerMap");
static_assert(offsetof(FHWCallToActionItemHandlerMap, ItemHandler) == 0x000000, "Member 'FHWCallToActionItemHandlerMap::ItemHandler' has a wrong offset!");
static_assert(offsetof(FHWCallToActionItemHandlerMap, MappedItems) == 0x000008, "Member 'FHWCallToActionItemHandlerMap::MappedItems' has a wrong offset!");

// ScriptStruct Hemingway.HWCallToActionLootConfigMap
// 0x0068 (0x0068 - 0x0000)
struct FHWCallToActionLootConfigMap final
{
public:
	TArray<EHWCallToActionAffixPath>              PathSuffix;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<struct FRH_LootId>                       MappedLoots;                                       // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseSortOrderAsAmount;                             // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWCallToActionLootConfigMap) == 0x000008, "Wrong alignment on FHWCallToActionLootConfigMap");
static_assert(sizeof(FHWCallToActionLootConfigMap) == 0x000068, "Wrong size on FHWCallToActionLootConfigMap");
static_assert(offsetof(FHWCallToActionLootConfigMap, PathSuffix) == 0x000000, "Member 'FHWCallToActionLootConfigMap::PathSuffix' has a wrong offset!");
static_assert(offsetof(FHWCallToActionLootConfigMap, MappedLoots) == 0x000010, "Member 'FHWCallToActionLootConfigMap::MappedLoots' has a wrong offset!");
static_assert(offsetof(FHWCallToActionLootConfigMap, bUseSortOrderAsAmount) == 0x000060, "Member 'FHWCallToActionLootConfigMap::bUseSortOrderAsAmount' has a wrong offset!");

// ScriptStruct Hemingway.HWItemStoreItemInfo
// 0x0038 (0x0038 - 0x0000)
struct FHWItemStoreItemInfo final
{
public:
	TSoftObjectPtr<class UHWEquipmentItem>        Item;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemPrice;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SellPrice;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnique;                                          // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCraft;                                         // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWItemStoreItemInfo) == 0x000008, "Wrong alignment on FHWItemStoreItemInfo");
static_assert(sizeof(FHWItemStoreItemInfo) == 0x000038, "Wrong size on FHWItemStoreItemInfo");
static_assert(offsetof(FHWItemStoreItemInfo, Item) == 0x000000, "Member 'FHWItemStoreItemInfo::Item' has a wrong offset!");
static_assert(offsetof(FHWItemStoreItemInfo, ItemPrice) == 0x000028, "Member 'FHWItemStoreItemInfo::ItemPrice' has a wrong offset!");
static_assert(offsetof(FHWItemStoreItemInfo, SellPrice) == 0x00002C, "Member 'FHWItemStoreItemInfo::SellPrice' has a wrong offset!");
static_assert(offsetof(FHWItemStoreItemInfo, IsOwned) == 0x000030, "Member 'FHWItemStoreItemInfo::IsOwned' has a wrong offset!");
static_assert(offsetof(FHWItemStoreItemInfo, IsUnique) == 0x000031, "Member 'FHWItemStoreItemInfo::IsUnique' has a wrong offset!");
static_assert(offsetof(FHWItemStoreItemInfo, bCanCraft) == 0x000032, "Member 'FHWItemStoreItemInfo::bCanCraft' has a wrong offset!");

// ScriptStruct Hemingway.HWCategoryItems
// 0x0048 (0x0048 - 0x0000)
struct FHWCategoryItems final
{
public:
	TArray<class UItemInfoContainer*>             ItemInfoContainers;                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0010(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Label;                                             // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWCategoryItems) == 0x000008, "Wrong alignment on FHWCategoryItems");
static_assert(sizeof(FHWCategoryItems) == 0x000048, "Wrong size on FHWCategoryItems");
static_assert(offsetof(FHWCategoryItems, ItemInfoContainers) == 0x000000, "Member 'FHWCategoryItems::ItemInfoContainers' has a wrong offset!");
static_assert(offsetof(FHWCategoryItems, TagContainer) == 0x000010, "Member 'FHWCategoryItems::TagContainer' has a wrong offset!");
static_assert(offsetof(FHWCategoryItems, Label) == 0x000030, "Member 'FHWCategoryItems::Label' has a wrong offset!");

// ScriptStruct Hemingway.HWMajorCategoryItems
// 0x0010 (0x0010 - 0x0000)
struct FHWMajorCategoryItems final
{
public:
	TArray<struct FHWCategoryItems>               Categories;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWMajorCategoryItems) == 0x000008, "Wrong alignment on FHWMajorCategoryItems");
static_assert(sizeof(FHWMajorCategoryItems) == 0x000010, "Wrong size on FHWMajorCategoryItems");
static_assert(offsetof(FHWMajorCategoryItems, Categories) == 0x000000, "Member 'FHWMajorCategoryItems::Categories' has a wrong offset!");

// ScriptStruct Hemingway.HWMajorCategoryContainer
// 0x0060 (0x0060 - 0x0000)
struct FHWMajorCategoryContainer final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer2;                                     // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Label;                                             // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bRecommendedOnly;                                  // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWMajorCategoryContainer) == 0x000008, "Wrong alignment on FHWMajorCategoryContainer");
static_assert(sizeof(FHWMajorCategoryContainer) == 0x000060, "Wrong size on FHWMajorCategoryContainer");
static_assert(offsetof(FHWMajorCategoryContainer, TagContainer) == 0x000000, "Member 'FHWMajorCategoryContainer::TagContainer' has a wrong offset!");
static_assert(offsetof(FHWMajorCategoryContainer, TagContainer2) == 0x000020, "Member 'FHWMajorCategoryContainer::TagContainer2' has a wrong offset!");
static_assert(offsetof(FHWMajorCategoryContainer, Label) == 0x000040, "Member 'FHWMajorCategoryContainer::Label' has a wrong offset!");
static_assert(offsetof(FHWMajorCategoryContainer, bRecommendedOnly) == 0x000058, "Member 'FHWMajorCategoryContainer::bRecommendedOnly' has a wrong offset!");

// ScriptStruct Hemingway.HWMajorCategoryFilters
// 0x0028 (0x0028 - 0x0000)
struct FHWMajorCategoryFilters final
{
public:
	TArray<struct FHWMajorCategoryContainer>      Categories;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   Label;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWMajorCategoryFilters) == 0x000008, "Wrong alignment on FHWMajorCategoryFilters");
static_assert(sizeof(FHWMajorCategoryFilters) == 0x000028, "Wrong size on FHWMajorCategoryFilters");
static_assert(offsetof(FHWMajorCategoryFilters, Categories) == 0x000000, "Member 'FHWMajorCategoryFilters::Categories' has a wrong offset!");
static_assert(offsetof(FHWMajorCategoryFilters, Label) == 0x000010, "Member 'FHWMajorCategoryFilters::Label' has a wrong offset!");

// ScriptStruct Hemingway.HWAllItemListFilter
// 0x0028 (0x0028 - 0x0000)
struct FHWAllItemListFilter final
{
public:
	bool                                          bIsDivider;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExclusive;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SortingTag;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DisplayDataTag;                                    // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           TextSearchStrings;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAllItemListFilter) == 0x000008, "Wrong alignment on FHWAllItemListFilter");
static_assert(sizeof(FHWAllItemListFilter) == 0x000028, "Wrong size on FHWAllItemListFilter");
static_assert(offsetof(FHWAllItemListFilter, bIsDivider) == 0x000000, "Member 'FHWAllItemListFilter::bIsDivider' has a wrong offset!");
static_assert(offsetof(FHWAllItemListFilter, bIsExclusive) == 0x000001, "Member 'FHWAllItemListFilter::bIsExclusive' has a wrong offset!");
static_assert(offsetof(FHWAllItemListFilter, SortingTag) == 0x000004, "Member 'FHWAllItemListFilter::SortingTag' has a wrong offset!");
static_assert(offsetof(FHWAllItemListFilter, DisplayDataTag) == 0x00000C, "Member 'FHWAllItemListFilter::DisplayDataTag' has a wrong offset!");
static_assert(offsetof(FHWAllItemListFilter, TextSearchStrings) == 0x000018, "Member 'FHWAllItemListFilter::TextSearchStrings' has a wrong offset!");

// ScriptStruct Hemingway.HWAllItemListRoleFilters
// 0x0028 (0x0028 - 0x0000)
struct FHWAllItemListRoleFilters final
{
public:
	bool                                          IsGlobalFilter;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SortingTag;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DisplayDataTag;                                    // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWAllItemListGroup>            CategorySortingOverride;                           // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWAllItemListRoleFilters) == 0x000008, "Wrong alignment on FHWAllItemListRoleFilters");
static_assert(sizeof(FHWAllItemListRoleFilters) == 0x000028, "Wrong size on FHWAllItemListRoleFilters");
static_assert(offsetof(FHWAllItemListRoleFilters, IsGlobalFilter) == 0x000000, "Member 'FHWAllItemListRoleFilters::IsGlobalFilter' has a wrong offset!");
static_assert(offsetof(FHWAllItemListRoleFilters, SortingTag) == 0x000004, "Member 'FHWAllItemListRoleFilters::SortingTag' has a wrong offset!");
static_assert(offsetof(FHWAllItemListRoleFilters, DisplayDataTag) == 0x00000C, "Member 'FHWAllItemListRoleFilters::DisplayDataTag' has a wrong offset!");
static_assert(offsetof(FHWAllItemListRoleFilters, CategorySortingOverride) == 0x000018, "Member 'FHWAllItemListRoleFilters::CategorySortingOverride' has a wrong offset!");

// ScriptStruct Hemingway.HWItemStoreConfigRow
// 0x0050 (0x0058 - 0x0008)
struct FHWItemStoreConfigRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UHWEquipmentItem>        Item;                                              // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideFromAllItemsList;                             // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSellItem;                                      // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ExcludedGameModes;                                 // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWItemStoreConfigRow) == 0x000008, "Wrong alignment on FHWItemStoreConfigRow");
static_assert(sizeof(FHWItemStoreConfigRow) == 0x000058, "Wrong size on FHWItemStoreConfigRow");
static_assert(offsetof(FHWItemStoreConfigRow, Item) == 0x000008, "Member 'FHWItemStoreConfigRow::Item' has a wrong offset!");
static_assert(offsetof(FHWItemStoreConfigRow, bHideFromAllItemsList) == 0x000030, "Member 'FHWItemStoreConfigRow::bHideFromAllItemsList' has a wrong offset!");
static_assert(offsetof(FHWItemStoreConfigRow, bCanSellItem) == 0x000031, "Member 'FHWItemStoreConfigRow::bCanSellItem' has a wrong offset!");
static_assert(offsetof(FHWItemStoreConfigRow, ExcludedGameModes) == 0x000038, "Member 'FHWItemStoreConfigRow::ExcludedGameModes' has a wrong offset!");

// ScriptStruct Hemingway.HWEquipmentItemCraftingInfo
// 0x0018 (0x0018 - 0x0000)
struct FHWEquipmentItemCraftingInfo final
{
public:
	TArray<struct FPrimaryAssetId>                BuildsIntoList;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCanSellItem;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWEquipmentItemCraftingInfo) == 0x000008, "Wrong alignment on FHWEquipmentItemCraftingInfo");
static_assert(sizeof(FHWEquipmentItemCraftingInfo) == 0x000018, "Wrong size on FHWEquipmentItemCraftingInfo");
static_assert(offsetof(FHWEquipmentItemCraftingInfo, BuildsIntoList) == 0x000000, "Member 'FHWEquipmentItemCraftingInfo::BuildsIntoList' has a wrong offset!");
static_assert(offsetof(FHWEquipmentItemCraftingInfo, bCanSellItem) == 0x000010, "Member 'FHWEquipmentItemCraftingInfo::bCanSellItem' has a wrong offset!");

// ScriptStruct Hemingway.HWDynamicItemStoreConfigRow
// 0x0038 (0x0040 - 0x0008)
struct FHWDynamicItemStoreConfigRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UHWEquipmentItem>        DynamicItem;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicItemAvailabilityRestriction           AvailabilityRestriction;                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AvailabilityDuration;                              // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSellItem;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWDynamicItemStoreConfigRow) == 0x000008, "Wrong alignment on FHWDynamicItemStoreConfigRow");
static_assert(sizeof(FHWDynamicItemStoreConfigRow) == 0x000040, "Wrong size on FHWDynamicItemStoreConfigRow");
static_assert(offsetof(FHWDynamicItemStoreConfigRow, DynamicItem) == 0x000008, "Member 'FHWDynamicItemStoreConfigRow::DynamicItem' has a wrong offset!");
static_assert(offsetof(FHWDynamicItemStoreConfigRow, AvailabilityRestriction) == 0x000030, "Member 'FHWDynamicItemStoreConfigRow::AvailabilityRestriction' has a wrong offset!");
static_assert(offsetof(FHWDynamicItemStoreConfigRow, AvailabilityDuration) == 0x000034, "Member 'FHWDynamicItemStoreConfigRow::AvailabilityDuration' has a wrong offset!");
static_assert(offsetof(FHWDynamicItemStoreConfigRow, bCanSellItem) == 0x000038, "Member 'FHWDynamicItemStoreConfigRow::bCanSellItem' has a wrong offset!");

// ScriptStruct Hemingway.HWGameModeInfo
// 0x00F0 (0x00F8 - 0x0008)
struct FHWGameModeInfo final : public FTableRowBase
{
public:
	struct FGameplayTag                           InfoTag;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AltName;                                           // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MapPath;                                           // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHWGameMode>                GameModeOverride;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWDraftRules>              DraftRules;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWRankedConfig>         RankedConfig;                                      // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BackgroundImage;                                   // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustomLobbyMode;                                // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDevMode;                                        // 0x00E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPlayerRoles;                                   // 0x00EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EB[0x1];                                       // 0x00EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TranstionInfoTag;                                  // 0x00EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowQuestsInCustomMatches;                       // 0x00F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWGameModeInfo) == 0x000008, "Wrong alignment on FHWGameModeInfo");
static_assert(sizeof(FHWGameModeInfo) == 0x0000F8, "Wrong size on FHWGameModeInfo");
static_assert(offsetof(FHWGameModeInfo, InfoTag) == 0x000008, "Member 'FHWGameModeInfo::InfoTag' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, Name) == 0x000010, "Member 'FHWGameModeInfo::Name' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, AltName) == 0x000028, "Member 'FHWGameModeInfo::AltName' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, MapPath) == 0x000040, "Member 'FHWGameModeInfo::MapPath' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, GameModeOverride) == 0x000060, "Member 'FHWGameModeInfo::GameModeOverride' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, DraftRules) == 0x000068, "Member 'FHWGameModeInfo::DraftRules' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, RankedConfig) == 0x000070, "Member 'FHWGameModeInfo::RankedConfig' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, Icon) == 0x000098, "Member 'FHWGameModeInfo::Icon' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, BackgroundImage) == 0x0000C0, "Member 'FHWGameModeInfo::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, bIsCustomLobbyMode) == 0x0000E8, "Member 'FHWGameModeInfo::bIsCustomLobbyMode' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, bIsDevMode) == 0x0000E9, "Member 'FHWGameModeInfo::bIsDevMode' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, bHasPlayerRoles) == 0x0000EA, "Member 'FHWGameModeInfo::bHasPlayerRoles' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, TranstionInfoTag) == 0x0000EC, "Member 'FHWGameModeInfo::TranstionInfoTag' has a wrong offset!");
static_assert(offsetof(FHWGameModeInfo, bAllowQuestsInCustomMatches) == 0x0000F4, "Member 'FHWGameModeInfo::bAllowQuestsInCustomMatches' has a wrong offset!");

// ScriptStruct Hemingway.HWGodBuildSearchSortParams
// 0x0002 (0x0002 - 0x0000)
struct FHWGodBuildSearchSortParams final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWGodBuildSearchSortParams) == 0x000001, "Wrong alignment on FHWGodBuildSearchSortParams");
static_assert(sizeof(FHWGodBuildSearchSortParams) == 0x000002, "Wrong size on FHWGodBuildSearchSortParams");

// ScriptStruct Hemingway.HWGodBuildSearchParams
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FHWGodBuildSearchParams final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWGodBuildSearchParams) == 0x000008, "Wrong alignment on FHWGodBuildSearchParams");
static_assert(sizeof(FHWGodBuildSearchParams) == 0x000080, "Wrong size on FHWGodBuildSearchParams");

// ScriptStruct Hemingway.HWComingSoonGodRow
// 0x0028 (0x0030 - 0x0008)
struct FHWComingSoonGodRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UHWCharacterItem>        CharacterItem;                                     // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWComingSoonGodRow) == 0x000008, "Wrong alignment on FHWComingSoonGodRow");
static_assert(sizeof(FHWComingSoonGodRow) == 0x000030, "Wrong size on FHWComingSoonGodRow");
static_assert(offsetof(FHWComingSoonGodRow, CharacterItem) == 0x000008, "Member 'FHWComingSoonGodRow::CharacterItem' has a wrong offset!");

// ScriptStruct Hemingway.HWLeaderboardDataContainer
// 0x0010 (0x0010 - 0x0000)
struct FHWLeaderboardDataContainer final
{
public:
	TArray<class UHWLeaderboardEntry*>            Entries;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWLeaderboardDataContainer) == 0x000008, "Wrong alignment on FHWLeaderboardDataContainer");
static_assert(sizeof(FHWLeaderboardDataContainer) == 0x000010, "Wrong size on FHWLeaderboardDataContainer");
static_assert(offsetof(FHWLeaderboardDataContainer, Entries) == 0x000000, "Member 'FHWLeaderboardDataContainer::Entries' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerBotRHIdRow
// 0x0040 (0x0048 - 0x0008)
struct FHWPlayerBotRHIdRow final : public FTableRowBase
{
public:
	class FString                                 Guid;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLiveId;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTagFilter;                                 // 0x0020(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         UsableIn;                                          // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWPlayerBotRHIdRow) == 0x000008, "Wrong alignment on FHWPlayerBotRHIdRow");
static_assert(sizeof(FHWPlayerBotRHIdRow) == 0x000048, "Wrong size on FHWPlayerBotRHIdRow");
static_assert(offsetof(FHWPlayerBotRHIdRow, Guid) == 0x000008, "Member 'FHWPlayerBotRHIdRow::Guid' has a wrong offset!");
static_assert(offsetof(FHWPlayerBotRHIdRow, bIsLiveId) == 0x000018, "Member 'FHWPlayerBotRHIdRow::bIsLiveId' has a wrong offset!");
static_assert(offsetof(FHWPlayerBotRHIdRow, GameplayTagFilter) == 0x000020, "Member 'FHWPlayerBotRHIdRow::GameplayTagFilter' has a wrong offset!");
static_assert(offsetof(FHWPlayerBotRHIdRow, UsableIn) == 0x000040, "Member 'FHWPlayerBotRHIdRow::UsableIn' has a wrong offset!");

// ScriptStruct Hemingway.HWTeamPlayersSnapshot
// 0x0058 (0x0058 - 0x0000)
struct FHWTeamPlayersSnapshot final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FHWPersistentPlayerId, struct FHWTeamPlayer> TeamPlayers;                            // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWTeamPlayersSnapshot) == 0x000008, "Wrong alignment on FHWTeamPlayersSnapshot");
static_assert(sizeof(FHWTeamPlayersSnapshot) == 0x000058, "Wrong size on FHWTeamPlayersSnapshot");
static_assert(offsetof(FHWTeamPlayersSnapshot, TeamId) == 0x000000, "Member 'FHWTeamPlayersSnapshot::TeamId' has a wrong offset!");
static_assert(offsetof(FHWTeamPlayersSnapshot, TeamPlayers) == 0x000008, "Member 'FHWTeamPlayersSnapshot::TeamPlayers' has a wrong offset!");

// ScriptStruct Hemingway.HWChatLogAzureResults
// 0x0010 (0x0010 - 0x0000)
struct FHWChatLogAzureResults final
{
public:
	TArray<struct FHWChatLogAzureResult>          AzureResults;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWChatLogAzureResults) == 0x000008, "Wrong alignment on FHWChatLogAzureResults");
static_assert(sizeof(FHWChatLogAzureResults) == 0x000010, "Wrong size on FHWChatLogAzureResults");
static_assert(offsetof(FHWChatLogAzureResults, AzureResults) == 0x000000, "Member 'FHWChatLogAzureResults::AzureResults' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerData
// 0x0028 (0x0028 - 0x0000)
struct FHWPlayerData final
{
public:
	int64                                         LastSeenOrderTime;                                 // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRH_ItemId>                     FavoriteGodItemIds;                                // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SelectedQueueId;                                   // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPlayerData) == 0x000008, "Wrong alignment on FHWPlayerData");
static_assert(sizeof(FHWPlayerData) == 0x000028, "Wrong size on FHWPlayerData");
static_assert(offsetof(FHWPlayerData, LastSeenOrderTime) == 0x000000, "Member 'FHWPlayerData::LastSeenOrderTime' has a wrong offset!");
static_assert(offsetof(FHWPlayerData, FavoriteGodItemIds) == 0x000008, "Member 'FHWPlayerData::FavoriteGodItemIds' has a wrong offset!");
static_assert(offsetof(FHWPlayerData, SelectedQueueId) == 0x000018, "Member 'FHWPlayerData::SelectedQueueId' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerSettingsKeybinds_Rebind
// 0x0028 (0x0028 - 0x0000)
struct FHWPlayerSettingsKeybinds_Rebind final
{
public:
	class FString                                 MappableName;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyRebinds;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MappingIndex;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWPlayerSettingsKeybinds_Rebind) == 0x000008, "Wrong alignment on FHWPlayerSettingsKeybinds_Rebind");
static_assert(sizeof(FHWPlayerSettingsKeybinds_Rebind) == 0x000028, "Wrong size on FHWPlayerSettingsKeybinds_Rebind");
static_assert(offsetof(FHWPlayerSettingsKeybinds_Rebind, MappableName) == 0x000000, "Member 'FHWPlayerSettingsKeybinds_Rebind::MappableName' has a wrong offset!");
static_assert(offsetof(FHWPlayerSettingsKeybinds_Rebind, KeyRebinds) == 0x000010, "Member 'FHWPlayerSettingsKeybinds_Rebind::KeyRebinds' has a wrong offset!");
static_assert(offsetof(FHWPlayerSettingsKeybinds_Rebind, MappingIndex) == 0x000020, "Member 'FHWPlayerSettingsKeybinds_Rebind::MappingIndex' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerSettingsKeybinds_CustomPreset
// 0x0040 (0x0040 - 0x0000)
struct FHWPlayerSettingsKeybinds_CustomPreset final
{
public:
	class FString                                 CustomPresetName;                                  // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginalPresetName;                                // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWPlayerSettingsKeybinds_Rebind> KeyRebinds;                                      // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWPlayerSettingsKeybinds_Rebind> KeyRemovals;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPlayerSettingsKeybinds_CustomPreset) == 0x000008, "Wrong alignment on FHWPlayerSettingsKeybinds_CustomPreset");
static_assert(sizeof(FHWPlayerSettingsKeybinds_CustomPreset) == 0x000040, "Wrong size on FHWPlayerSettingsKeybinds_CustomPreset");
static_assert(offsetof(FHWPlayerSettingsKeybinds_CustomPreset, CustomPresetName) == 0x000000, "Member 'FHWPlayerSettingsKeybinds_CustomPreset::CustomPresetName' has a wrong offset!");
static_assert(offsetof(FHWPlayerSettingsKeybinds_CustomPreset, OriginalPresetName) == 0x000010, "Member 'FHWPlayerSettingsKeybinds_CustomPreset::OriginalPresetName' has a wrong offset!");
static_assert(offsetof(FHWPlayerSettingsKeybinds_CustomPreset, KeyRebinds) == 0x000020, "Member 'FHWPlayerSettingsKeybinds_CustomPreset::KeyRebinds' has a wrong offset!");
static_assert(offsetof(FHWPlayerSettingsKeybinds_CustomPreset, KeyRemovals) == 0x000030, "Member 'FHWPlayerSettingsKeybinds_CustomPreset::KeyRemovals' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerSettingsKeybinds_ContextEntry
// 0x0028 (0x0028 - 0x0000)
struct FHWPlayerSettingsKeybinds_ContextEntry final
{
public:
	struct FGameplayTag                           MappingContextTag;                                 // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActivePreset;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWPlayerSettingsKeybinds_CustomPreset> CustomPresets;                             // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPlayerSettingsKeybinds_ContextEntry) == 0x000008, "Wrong alignment on FHWPlayerSettingsKeybinds_ContextEntry");
static_assert(sizeof(FHWPlayerSettingsKeybinds_ContextEntry) == 0x000028, "Wrong size on FHWPlayerSettingsKeybinds_ContextEntry");
static_assert(offsetof(FHWPlayerSettingsKeybinds_ContextEntry, MappingContextTag) == 0x000000, "Member 'FHWPlayerSettingsKeybinds_ContextEntry::MappingContextTag' has a wrong offset!");
static_assert(offsetof(FHWPlayerSettingsKeybinds_ContextEntry, ActivePreset) == 0x000008, "Member 'FHWPlayerSettingsKeybinds_ContextEntry::ActivePreset' has a wrong offset!");
static_assert(offsetof(FHWPlayerSettingsKeybinds_ContextEntry, CustomPresets) == 0x000018, "Member 'FHWPlayerSettingsKeybinds_ContextEntry::CustomPresets' has a wrong offset!");

// ScriptStruct Hemingway.HWPlayerSettingsKeybinds_Contexts
// 0x0010 (0x0010 - 0x0000)
struct FHWPlayerSettingsKeybinds_Contexts final
{
public:
	TArray<struct FHWPlayerSettingsKeybinds_ContextEntry> ContextEntries;                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWPlayerSettingsKeybinds_Contexts) == 0x000008, "Wrong alignment on FHWPlayerSettingsKeybinds_Contexts");
static_assert(sizeof(FHWPlayerSettingsKeybinds_Contexts) == 0x000010, "Wrong size on FHWPlayerSettingsKeybinds_Contexts");
static_assert(offsetof(FHWPlayerSettingsKeybinds_Contexts, ContextEntries) == 0x000000, "Member 'FHWPlayerSettingsKeybinds_Contexts::ContextEntries' has a wrong offset!");

// ScriptStruct Hemingway.HWSettingDelegateStruct
// 0x0020 (0x0020 - 0x0000)
struct FHWSettingDelegateStruct final
{
public:
	TDelegate<void()>                             SettingApplied;                                    // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             SettingSaved;                                      // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWSettingDelegateStruct) == 0x000004, "Wrong alignment on FHWSettingDelegateStruct");
static_assert(sizeof(FHWSettingDelegateStruct) == 0x000020, "Wrong size on FHWSettingDelegateStruct");
static_assert(offsetof(FHWSettingDelegateStruct, SettingApplied) == 0x000000, "Member 'FHWSettingDelegateStruct::SettingApplied' has a wrong offset!");
static_assert(offsetof(FHWSettingDelegateStruct, SettingSaved) == 0x000010, "Member 'FHWSettingDelegateStruct::SettingSaved' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSConditionalData
// 0x0068 (0x0070 - 0x0008)
struct FHWVGSConditionalData : public FTableRowBase
{
public:
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AllowedIfAllTrue;                                  // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AllowedIfAnyTrue;                                  // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockedIfAnyTrue;                                  // 0x0050(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVGSConditionalData) == 0x000008, "Wrong alignment on FHWVGSConditionalData");
static_assert(sizeof(FHWVGSConditionalData) == 0x000070, "Wrong size on FHWVGSConditionalData");
static_assert(offsetof(FHWVGSConditionalData, bEnabled) == 0x000008, "Member 'FHWVGSConditionalData::bEnabled' has a wrong offset!");
static_assert(offsetof(FHWVGSConditionalData, AllowedIfAllTrue) == 0x000010, "Member 'FHWVGSConditionalData::AllowedIfAllTrue' has a wrong offset!");
static_assert(offsetof(FHWVGSConditionalData, AllowedIfAnyTrue) == 0x000030, "Member 'FHWVGSConditionalData::AllowedIfAnyTrue' has a wrong offset!");
static_assert(offsetof(FHWVGSConditionalData, BlockedIfAnyTrue) == 0x000050, "Member 'FHWVGSConditionalData::BlockedIfAnyTrue' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSNodeBase
// 0x0020 (0x0090 - 0x0070)
struct FHWVGSNodeBase : public FHWVGSConditionalData
{
public:
	struct FGameplayTag                           ID;                                                // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LabelText;                                         // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVGSNodeBase) == 0x000008, "Wrong alignment on FHWVGSNodeBase");
static_assert(sizeof(FHWVGSNodeBase) == 0x000090, "Wrong size on FHWVGSNodeBase");
static_assert(offsetof(FHWVGSNodeBase, ID) == 0x000070, "Member 'FHWVGSNodeBase::ID' has a wrong offset!");
static_assert(offsetof(FHWVGSNodeBase, LabelText) == 0x000078, "Member 'FHWVGSNodeBase::LabelText' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSActionRow
// 0x00E0 (0x0170 - 0x0090)
struct FHWVGSActionRow final : public FHWVGSNodeBase
{
public:
	class FText                                   OutputText;                                        // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       AppendSlotCooldown;                                // 0x00A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OutputEmote;                                       // 0x00B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OutputGameplayCue;                                 // 0x00BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireEmoteItemOwnership;                        // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockIfEmoteItemMissing;                           // 0x00C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseQuestForGCQuantity;                            // 0x00C6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFindQuestTierFromTable;                           // 0x00C7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemLookupForGCQuantity;                           // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWQuest>                QuestLookupForGCQuantity;                          // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AudioAudience;                                     // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWVGSFloodProtectionType                     FloodProtectionType;                               // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AspectTags;                                        // 0x0108(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShouldAttemptAutoPing;                            // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AutoPingTags;                                      // 0x0130(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ETeamAttitude                                 TeamRelationshipRequirement;                       // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PingDisplayType;                                   // 0x0154(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x14];                                     // 0x015C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWVGSActionRow) == 0x000008, "Wrong alignment on FHWVGSActionRow");
static_assert(sizeof(FHWVGSActionRow) == 0x000170, "Wrong size on FHWVGSActionRow");
static_assert(offsetof(FHWVGSActionRow, OutputText) == 0x000090, "Member 'FHWVGSActionRow::OutputText' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, AppendSlotCooldown) == 0x0000A8, "Member 'FHWVGSActionRow::AppendSlotCooldown' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, OutputEmote) == 0x0000B4, "Member 'FHWVGSActionRow::OutputEmote' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, OutputGameplayCue) == 0x0000BC, "Member 'FHWVGSActionRow::OutputGameplayCue' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, bRequireEmoteItemOwnership) == 0x0000C4, "Member 'FHWVGSActionRow::bRequireEmoteItemOwnership' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, bLockIfEmoteItemMissing) == 0x0000C5, "Member 'FHWVGSActionRow::bLockIfEmoteItemMissing' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, bUseQuestForGCQuantity) == 0x0000C6, "Member 'FHWVGSActionRow::bUseQuestForGCQuantity' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, bFindQuestTierFromTable) == 0x0000C7, "Member 'FHWVGSActionRow::bFindQuestTierFromTable' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, ItemLookupForGCQuantity) == 0x0000C8, "Member 'FHWVGSActionRow::ItemLookupForGCQuantity' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, QuestLookupForGCQuantity) == 0x0000D0, "Member 'FHWVGSActionRow::QuestLookupForGCQuantity' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, AudioAudience) == 0x0000F8, "Member 'FHWVGSActionRow::AudioAudience' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, FloodProtectionType) == 0x000100, "Member 'FHWVGSActionRow::FloodProtectionType' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, AspectTags) == 0x000108, "Member 'FHWVGSActionRow::AspectTags' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, bShouldAttemptAutoPing) == 0x000128, "Member 'FHWVGSActionRow::bShouldAttemptAutoPing' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, AutoPingTags) == 0x000130, "Member 'FHWVGSActionRow::AutoPingTags' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, TeamRelationshipRequirement) == 0x000150, "Member 'FHWVGSActionRow::TeamRelationshipRequirement' has a wrong offset!");
static_assert(offsetof(FHWVGSActionRow, PingDisplayType) == 0x000154, "Member 'FHWVGSActionRow::PingDisplayType' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSMenuChoice
// 0x0018 (0x0088 - 0x0070)
struct FHWVGSMenuChoice final : public FHWVGSConditionalData
{
public:
	struct FGameplayTag                           Button;                                            // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Target;                                            // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWVGSMenuChoice) == 0x000008, "Wrong alignment on FHWVGSMenuChoice");
static_assert(sizeof(FHWVGSMenuChoice) == 0x000088, "Wrong size on FHWVGSMenuChoice");
static_assert(offsetof(FHWVGSMenuChoice, Button) == 0x000070, "Member 'FHWVGSMenuChoice::Button' has a wrong offset!");
static_assert(offsetof(FHWVGSMenuChoice, Target) == 0x000078, "Member 'FHWVGSMenuChoice::Target' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSMenuNodeRow
// 0x0018 (0x00A8 - 0x0090)
struct FHWVGSMenuNodeRow final : public FHWVGSNodeBase
{
public:
	TArray<struct FHWVGSMenuChoice>               Children;                                          // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWVGSMenuNodeRow) == 0x000008, "Wrong alignment on FHWVGSMenuNodeRow");
static_assert(sizeof(FHWVGSMenuNodeRow) == 0x0000A8, "Wrong size on FHWVGSMenuNodeRow");
static_assert(offsetof(FHWVGSMenuNodeRow, Children) == 0x000090, "Member 'FHWVGSMenuNodeRow::Children' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSUIEntry
// 0x0038 (0x0038 - 0x0000)
struct FHWVGSUIEntry final
{
public:
	struct FGameplayTag                           Button;                                            // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Target;                                            // 0x0008(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Label;                                             // 0x0010(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsAction;                                         // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHWCollectionItem>       LoadoutItem;                                       // 0x002C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHWVGSUIEntry) == 0x000008, "Wrong alignment on FHWVGSUIEntry");
static_assert(sizeof(FHWVGSUIEntry) == 0x000038, "Wrong size on FHWVGSUIEntry");
static_assert(offsetof(FHWVGSUIEntry, Button) == 0x000000, "Member 'FHWVGSUIEntry::Button' has a wrong offset!");
static_assert(offsetof(FHWVGSUIEntry, Target) == 0x000008, "Member 'FHWVGSUIEntry::Target' has a wrong offset!");
static_assert(offsetof(FHWVGSUIEntry, Label) == 0x000010, "Member 'FHWVGSUIEntry::Label' has a wrong offset!");
static_assert(offsetof(FHWVGSUIEntry, bIsAction) == 0x000028, "Member 'FHWVGSUIEntry::bIsAction' has a wrong offset!");
static_assert(offsetof(FHWVGSUIEntry, bIsEnabled) == 0x000029, "Member 'FHWVGSUIEntry::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FHWVGSUIEntry, LoadoutItem) == 0x00002C, "Member 'FHWVGSUIEntry::LoadoutItem' has a wrong offset!");

// ScriptStruct Hemingway.HWVGSEmoteOwnershipData
// 0x0050 (0x0050 - 0x0000)
struct FHWVGSEmoteOwnershipData final
{
public:
	TMap<struct FGameplayTag, bool>               EmoteOwnershipStatuses;                            // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHWVGSEmoteOwnershipData) == 0x000008, "Wrong alignment on FHWVGSEmoteOwnershipData");
static_assert(sizeof(FHWVGSEmoteOwnershipData) == 0x000050, "Wrong size on FHWVGSEmoteOwnershipData");
static_assert(offsetof(FHWVGSEmoteOwnershipData, EmoteOwnershipStatuses) == 0x000000, "Member 'FHWVGSEmoteOwnershipData::EmoteOwnershipStatuses' has a wrong offset!");

// ScriptStruct Hemingway.SimProjectileFlashEvent
// 0x0044 (0x0050 - 0x000C)
struct FSimProjectileFlashEvent final : public FFastArraySerializerItem
{
public:
	int32                                         SimProjectileId;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESimProjectileFlashEventType                  FlashEventType;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  GenericActor;                                      // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GenericVector1;                                    // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GenericVector2;                                    // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimProjectileFlashEvent) == 0x000008, "Wrong alignment on FSimProjectileFlashEvent");
static_assert(sizeof(FSimProjectileFlashEvent) == 0x000050, "Wrong size on FSimProjectileFlashEvent");
static_assert(offsetof(FSimProjectileFlashEvent, SimProjectileId) == 0x00000C, "Member 'FSimProjectileFlashEvent::SimProjectileId' has a wrong offset!");
static_assert(offsetof(FSimProjectileFlashEvent, FlashEventType) == 0x000010, "Member 'FSimProjectileFlashEvent::FlashEventType' has a wrong offset!");
static_assert(offsetof(FSimProjectileFlashEvent, GenericActor) == 0x000014, "Member 'FSimProjectileFlashEvent::GenericActor' has a wrong offset!");
static_assert(offsetof(FSimProjectileFlashEvent, GenericVector1) == 0x000020, "Member 'FSimProjectileFlashEvent::GenericVector1' has a wrong offset!");
static_assert(offsetof(FSimProjectileFlashEvent, GenericVector2) == 0x000038, "Member 'FSimProjectileFlashEvent::GenericVector2' has a wrong offset!");

// ScriptStruct Hemingway.SimProjectileFlashEventList
// 0x0020 (0x0128 - 0x0108)
struct FSimProjectileFlashEventList final : public FFastArraySerializer
{
public:
	TArray<struct FSimProjectileFlashEvent>       FlashEvents;                                       // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         CurrentFlashIndex;                                 // 0x0118(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CachedMaxFlashEvents;                              // 0x011C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHWPlayerController*                    OwningController;                                  // 0x0120(0x0008)(ZeroConstructor, Transient, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSimProjectileFlashEventList) == 0x000008, "Wrong alignment on FSimProjectileFlashEventList");
static_assert(sizeof(FSimProjectileFlashEventList) == 0x000128, "Wrong size on FSimProjectileFlashEventList");
static_assert(offsetof(FSimProjectileFlashEventList, FlashEvents) == 0x000108, "Member 'FSimProjectileFlashEventList::FlashEvents' has a wrong offset!");
static_assert(offsetof(FSimProjectileFlashEventList, CurrentFlashIndex) == 0x000118, "Member 'FSimProjectileFlashEventList::CurrentFlashIndex' has a wrong offset!");
static_assert(offsetof(FSimProjectileFlashEventList, CachedMaxFlashEvents) == 0x00011C, "Member 'FSimProjectileFlashEventList::CachedMaxFlashEvents' has a wrong offset!");
static_assert(offsetof(FSimProjectileFlashEventList, OwningController) == 0x000120, "Member 'FSimProjectileFlashEventList::OwningController' has a wrong offset!");

}

