#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hemingway

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Hemingway_structs.hpp"
#include "SkinnableAnimNotifies_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "RallyHereAPI_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "InputCore_structs.hpp"
#include "SkinnableAnimGraphRuntime_classes.hpp"
#include "DataTableSkinsCommon_structs.hpp"
#include "DataTableSkinsCommon_classes.hpp"
#include "BanPickDraftCommon_structs.hpp"
#include "BanPickDraftCommon_classes.hpp"
#include "RallyHereStart_structs.hpp"
#include "RallyHereStart_classes.hpp"
#include "HiRezNetTools_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "RallyHereIntegration_structs.hpp"
#include "RallyHereIntegration_classes.hpp"
#include "HiRezAutomation_classes.hpp"
#include "GeometryCollectionEngine_classes.hpp"
#include "UMG_classes.hpp"
#include "CommonInput_structs.hpp"
#include "NetCore_structs.hpp"
#include "Niagara_structs.hpp"
#include "Niagara_classes.hpp"


namespace SDK
{

// Class Hemingway.HWCharacter_AnimInstBase
// 0x0220 (0x05D0 - 0x03B0)
#pragma pack(push, 0x1)
class alignas(0x10) UHWCharacter_AnimInstBase : public USkinnedAnimInstance
{
public:
	class AActor*                                 OwningActor;                                       // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      Character;                                         // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWAnimStatusEffectState                      StatusEffect;                                      // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStunned;                                        // 0x03B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMesmerized;                                     // 0x03BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRooted;                                         // 0x03BB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsKnockBack;                                      // 0x03BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSilence;                                        // 0x03BD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFeared;                                         // 0x03BE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTaunted;                                        // 0x03BF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSlowed;                                         // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInAbility;                                        // 0x03C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbilityTurnEnabled;                               // 0x03C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWAnimVisualEffectState                      VisualEffect;                                      // 0x03C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFallingEffect;                                  // 0x03C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C5[0x3];                                      // 0x03C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlayerVelocity;                                    // 0x03C8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccelDirection;                                    // 0x03E0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x03F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFalling;                                         // 0x03F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isFallingUp;                                       // 0x03FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWRunDirection                               RunDirection;                                      // 0x03FB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            CharacterMovement;                                 // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeed;                                     // 0x0408(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementDirection;                                 // 0x040C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocalDirectionAngleDeltaCutOff;                    // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ActorRotation;                                     // 0x0418(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x18];                                     // 0x0430(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredComponentYaw;                               // 0x0448(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnimateTurnInPlace;                                // 0x044C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnInPLaceInProgress;                            // 0x044D(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAnimationToggle;                              // 0x044E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44F[0x1];                                      // 0x044F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceTurnValue;                              // 0x0450(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTurnInPlaceThreshold;                       // 0x0454(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWAnimTurninPLace                            LastTurnInPlaceAnimationVariant;                   // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_459[0x3];                                      // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceMinThreshold;                           // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPLaceMaxOffset;                              // 0x0460(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceRetriggerMinThreshold;                  // 0x0464(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefireTurnAnimationThreshold;                      // 0x0468(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceRecoverySpeedWithAccerleration;         // 0x046C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceRecoverySpeed90;                        // 0x0470(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceRecoverySpeed180;                       // 0x0474(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AppliedTurnInPlaceRotator;                         // 0x0478(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               WorldTurnInPlaceRotator;                           // 0x0490(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExceededTurnInPlaceThreshold;                     // 0x04A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A9[0x11];                                     // 0x04A9(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	EHWAnimTurnInPlaceType                        TurnInPlaceType;                                   // 0x04BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BB[0x1];                                      // 0x04BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloatTurnSpeed;                                    // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WantForwardFloatTurnSpeed;                         // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentDesiredTurnInPlaceYawOffset;                // 0x04C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CacheCurrentDesiredTurnInPlaceYawOffset;           // 0x04C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AimArrayRotator;                                   // 0x04D0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinPitchAngle;                                     // 0x04E8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchAngle;                                     // 0x04EC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PreviousCachedAimRotation;                         // 0x04F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               CachedAimRotation;                                 // 0x0508(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MovingLandingTimeToBlendOut;                       // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactionTotalTime;                              // 0x0524(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitReactionHealthPercMax;                          // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHit;                                            // 0x052C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52D[0x7];                                      // 0x052D(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitReactionTypeThreshold;                          // 0x0534(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveLinearColor*                      HitReactionCurveOverTime;                          // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitDirectionRight;                                 // 0x0540(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitDirectionForward;                               // 0x0544(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitAlpha;                                          // 0x0548(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWHitReaction                                HitReactionState;                                  // 0x054C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54D[0x53];                                     // 0x054D(0x0053)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagBlueprintPropertyMap       GameplayTagPropertyMap;                            // 0x05A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bContinueAbilityOnPrefireInterupt;                 // 0x05C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C1[0x7];                                      // 0x05C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_AnimEvent01();
	void BP_AnimEvent02();
	void BP_AnimEvent03();
	void DetermineSkinnedFiringMontageTag(const struct FGameplayTag& SourceIdTag);
	float GetJumpMovingTime();
	void OnCharacterASCUpdated(class UHWAbilitySystemComponent* UpdatedASC, class UHWAbilitySystemComponent* OldAbilitySystem);
	void OnMovementModeUpdated(class ACharacter* NewCharacter, const EMovementMode PrevMovementMode, const uint8 PreviousCustomMode);
	void OnStatusTagsUpdated(const struct FGameplayTag& UpdatedStatusTag, int32 NewStackCount);
	void TryToTriggerTurnInPlaceAnimation(EHWAnimTurninPLace AnimationVariant, float DelayTime);

	EMovementMode GetCharacterMovementMode() const;
	struct FGameplayTag GetSkinnedFiringMontageTag(const struct FGameplayTag& SourceIdTag, const struct FGameplayTag& OriginalFiringMontageTag) const;
	struct FGameplayTag GetSkinnedTargetingMontageTag(const struct FGameplayTag& SourceIdTag, const struct FGameplayTag& OriginalTargetingMontageTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_AnimInstBase">();
	}
	static class UHWCharacter_AnimInstBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCharacter_AnimInstBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UHWCharacter_AnimInstBase) == 0x000010, "Wrong alignment on UHWCharacter_AnimInstBase");
static_assert(sizeof(UHWCharacter_AnimInstBase) == 0x0005D0, "Wrong size on UHWCharacter_AnimInstBase");
static_assert(offsetof(UHWCharacter_AnimInstBase, OwningActor) == 0x0003A8, "Member 'UHWCharacter_AnimInstBase::OwningActor' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, Character) == 0x0003B0, "Member 'UHWCharacter_AnimInstBase::Character' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, StatusEffect) == 0x0003B8, "Member 'UHWCharacter_AnimInstBase::StatusEffect' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsStunned) == 0x0003B9, "Member 'UHWCharacter_AnimInstBase::bIsStunned' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsMesmerized) == 0x0003BA, "Member 'UHWCharacter_AnimInstBase::bIsMesmerized' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsRooted) == 0x0003BB, "Member 'UHWCharacter_AnimInstBase::bIsRooted' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsKnockBack) == 0x0003BC, "Member 'UHWCharacter_AnimInstBase::bIsKnockBack' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsSilence) == 0x0003BD, "Member 'UHWCharacter_AnimInstBase::bIsSilence' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsFeared) == 0x0003BE, "Member 'UHWCharacter_AnimInstBase::bIsFeared' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsTaunted) == 0x0003BF, "Member 'UHWCharacter_AnimInstBase::bIsTaunted' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsSlowed) == 0x0003C0, "Member 'UHWCharacter_AnimInstBase::bIsSlowed' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bInAbility) == 0x0003C1, "Member 'UHWCharacter_AnimInstBase::bInAbility' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bAbilityTurnEnabled) == 0x0003C2, "Member 'UHWCharacter_AnimInstBase::bAbilityTurnEnabled' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, VisualEffect) == 0x0003C3, "Member 'UHWCharacter_AnimInstBase::VisualEffect' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsFallingEffect) == 0x0003C4, "Member 'UHWCharacter_AnimInstBase::bIsFallingEffect' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, PlayerVelocity) == 0x0003C8, "Member 'UHWCharacter_AnimInstBase::PlayerVelocity' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, AccelDirection) == 0x0003E0, "Member 'UHWCharacter_AnimInstBase::AccelDirection' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsMoving) == 0x0003F8, "Member 'UHWCharacter_AnimInstBase::bIsMoving' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, IsFalling) == 0x0003F9, "Member 'UHWCharacter_AnimInstBase::IsFalling' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, isFallingUp) == 0x0003FA, "Member 'UHWCharacter_AnimInstBase::isFallingUp' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, RunDirection) == 0x0003FB, "Member 'UHWCharacter_AnimInstBase::RunDirection' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, CharacterMovement) == 0x000400, "Member 'UHWCharacter_AnimInstBase::CharacterMovement' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, MovementSpeed) == 0x000408, "Member 'UHWCharacter_AnimInstBase::MovementSpeed' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, MovementDirection) == 0x00040C, "Member 'UHWCharacter_AnimInstBase::MovementDirection' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, LocalDirectionAngleDeltaCutOff) == 0x000410, "Member 'UHWCharacter_AnimInstBase::LocalDirectionAngleDeltaCutOff' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, ActorRotation) == 0x000418, "Member 'UHWCharacter_AnimInstBase::ActorRotation' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, DesiredComponentYaw) == 0x000448, "Member 'UHWCharacter_AnimInstBase::DesiredComponentYaw' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, AnimateTurnInPlace) == 0x00044C, "Member 'UHWCharacter_AnimInstBase::AnimateTurnInPlace' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bTurnInPLaceInProgress) == 0x00044D, "Member 'UHWCharacter_AnimInstBase::bTurnInPLaceInProgress' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bTurnAnimationToggle) == 0x00044E, "Member 'UHWCharacter_AnimInstBase::bTurnAnimationToggle' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, TurnInPlaceTurnValue) == 0x000450, "Member 'UHWCharacter_AnimInstBase::TurnInPlaceTurnValue' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, CurrentTurnInPlaceThreshold) == 0x000454, "Member 'UHWCharacter_AnimInstBase::CurrentTurnInPlaceThreshold' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, LastTurnInPlaceAnimationVariant) == 0x000458, "Member 'UHWCharacter_AnimInstBase::LastTurnInPlaceAnimationVariant' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, TurnInPlaceMinThreshold) == 0x00045C, "Member 'UHWCharacter_AnimInstBase::TurnInPlaceMinThreshold' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, TurnInPLaceMaxOffset) == 0x000460, "Member 'UHWCharacter_AnimInstBase::TurnInPLaceMaxOffset' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, TurnInPlaceRetriggerMinThreshold) == 0x000464, "Member 'UHWCharacter_AnimInstBase::TurnInPlaceRetriggerMinThreshold' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, RefireTurnAnimationThreshold) == 0x000468, "Member 'UHWCharacter_AnimInstBase::RefireTurnAnimationThreshold' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, TurnInPlaceRecoverySpeedWithAccerleration) == 0x00046C, "Member 'UHWCharacter_AnimInstBase::TurnInPlaceRecoverySpeedWithAccerleration' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, TurnInPlaceRecoverySpeed90) == 0x000470, "Member 'UHWCharacter_AnimInstBase::TurnInPlaceRecoverySpeed90' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, TurnInPlaceRecoverySpeed180) == 0x000474, "Member 'UHWCharacter_AnimInstBase::TurnInPlaceRecoverySpeed180' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, AppliedTurnInPlaceRotator) == 0x000478, "Member 'UHWCharacter_AnimInstBase::AppliedTurnInPlaceRotator' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, WorldTurnInPlaceRotator) == 0x000490, "Member 'UHWCharacter_AnimInstBase::WorldTurnInPlaceRotator' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bExceededTurnInPlaceThreshold) == 0x0004A8, "Member 'UHWCharacter_AnimInstBase::bExceededTurnInPlaceThreshold' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, TurnInPlaceType) == 0x0004BA, "Member 'UHWCharacter_AnimInstBase::TurnInPlaceType' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, FloatTurnSpeed) == 0x0004BC, "Member 'UHWCharacter_AnimInstBase::FloatTurnSpeed' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, WantForwardFloatTurnSpeed) == 0x0004C0, "Member 'UHWCharacter_AnimInstBase::WantForwardFloatTurnSpeed' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, CurrentDesiredTurnInPlaceYawOffset) == 0x0004C4, "Member 'UHWCharacter_AnimInstBase::CurrentDesiredTurnInPlaceYawOffset' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, CacheCurrentDesiredTurnInPlaceYawOffset) == 0x0004C8, "Member 'UHWCharacter_AnimInstBase::CacheCurrentDesiredTurnInPlaceYawOffset' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, AimArrayRotator) == 0x0004D0, "Member 'UHWCharacter_AnimInstBase::AimArrayRotator' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, MinPitchAngle) == 0x0004E8, "Member 'UHWCharacter_AnimInstBase::MinPitchAngle' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, MaxPitchAngle) == 0x0004EC, "Member 'UHWCharacter_AnimInstBase::MaxPitchAngle' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, PreviousCachedAimRotation) == 0x0004F0, "Member 'UHWCharacter_AnimInstBase::PreviousCachedAimRotation' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, CachedAimRotation) == 0x000508, "Member 'UHWCharacter_AnimInstBase::CachedAimRotation' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, MovingLandingTimeToBlendOut) == 0x000520, "Member 'UHWCharacter_AnimInstBase::MovingLandingTimeToBlendOut' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, HitReactionTotalTime) == 0x000524, "Member 'UHWCharacter_AnimInstBase::HitReactionTotalTime' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, HitReactionHealthPercMax) == 0x000528, "Member 'UHWCharacter_AnimInstBase::HitReactionHealthPercMax' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bIsHit) == 0x00052C, "Member 'UHWCharacter_AnimInstBase::bIsHit' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, HitReactionTypeThreshold) == 0x000534, "Member 'UHWCharacter_AnimInstBase::HitReactionTypeThreshold' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, HitReactionCurveOverTime) == 0x000538, "Member 'UHWCharacter_AnimInstBase::HitReactionCurveOverTime' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, HitDirectionRight) == 0x000540, "Member 'UHWCharacter_AnimInstBase::HitDirectionRight' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, HitDirectionForward) == 0x000544, "Member 'UHWCharacter_AnimInstBase::HitDirectionForward' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, HitAlpha) == 0x000548, "Member 'UHWCharacter_AnimInstBase::HitAlpha' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, HitReactionState) == 0x00054C, "Member 'UHWCharacter_AnimInstBase::HitReactionState' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, GameplayTagPropertyMap) == 0x0005A0, "Member 'UHWCharacter_AnimInstBase::GameplayTagPropertyMap' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstBase, bContinueAbilityOnPrefireInterupt) == 0x0005C0, "Member 'UHWCharacter_AnimInstBase::bContinueAbilityOnPrefireInterupt' has a wrong offset!");

// Class Hemingway.HWAbilityAimSettings
// 0x0040 (0x0068 - 0x0028)
class UHWAbilityAimSettings : public UObject
{
public:
	bool                                          bCheckForValidAim;                                 // 0x0028(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PositionOffset;                                    // 0x0030(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               AimDirectionOffset;                                // 0x0048(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseClientCachedAim;                               // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseClientCachedTargetList;                        // 0x0061(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseControllerRotation;                            // 0x0062(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSourceActorRotation;                           // 0x0063(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOffsetAimByLastValidHeight;                       // 0x0064(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldAdjustStartAimToGround;                     // 0x0065(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalcAim(const struct FHWAimTargetingInfo& AimTargetingInfo, struct FGameplayAbilityTargetDataHandle& TargetingAimHandle) const;
	struct FRotator GetAimDirectionOffset() const;
	struct FVector GetPositionOffset() const;
	bool ShouldAdjustStartAimToGround() const;
	bool ShouldOffsetAimByLastValidHeight() const;
	bool ShouldUseClientCachedAim() const;
	bool ShouldUseClientCachedTargetList() const;
	bool ShouldUseControllerRotation() const;
	bool ShouldUseSourceActorRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSettings">();
	}
	static class UHWAbilityAimSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSettings>();
	}
};
static_assert(alignof(UHWAbilityAimSettings) == 0x000008, "Wrong alignment on UHWAbilityAimSettings");
static_assert(sizeof(UHWAbilityAimSettings) == 0x000068, "Wrong size on UHWAbilityAimSettings");
static_assert(offsetof(UHWAbilityAimSettings, bCheckForValidAim) == 0x000028, "Member 'UHWAbilityAimSettings::bCheckForValidAim' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings, PositionOffset) == 0x000030, "Member 'UHWAbilityAimSettings::PositionOffset' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings, AimDirectionOffset) == 0x000048, "Member 'UHWAbilityAimSettings::AimDirectionOffset' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings, bUseClientCachedAim) == 0x000060, "Member 'UHWAbilityAimSettings::bUseClientCachedAim' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings, bUseClientCachedTargetList) == 0x000061, "Member 'UHWAbilityAimSettings::bUseClientCachedTargetList' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings, bUseControllerRotation) == 0x000062, "Member 'UHWAbilityAimSettings::bUseControllerRotation' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings, bUseSourceActorRotation) == 0x000063, "Member 'UHWAbilityAimSettings::bUseSourceActorRotation' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings, bOffsetAimByLastValidHeight) == 0x000064, "Member 'UHWAbilityAimSettings::bOffsetAimByLastValidHeight' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings, bShouldAdjustStartAimToGround) == 0x000065, "Member 'UHWAbilityAimSettings::bShouldAdjustStartAimToGround' has a wrong offset!");

// Class Hemingway.HWAbilityAimSettings_EightWayMovement
// 0x0008 (0x0070 - 0x0068)
class UHWAbilityAimSettings_EightWayMovement final : public UHWAbilityAimSettings
{
public:
	float                                         MaxRange;                                          // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetMaxRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSettings_EightWayMovement">();
	}
	static class UHWAbilityAimSettings_EightWayMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSettings_EightWayMovement>();
	}
};
static_assert(alignof(UHWAbilityAimSettings_EightWayMovement) == 0x000008, "Wrong alignment on UHWAbilityAimSettings_EightWayMovement");
static_assert(sizeof(UHWAbilityAimSettings_EightWayMovement) == 0x000070, "Wrong size on UHWAbilityAimSettings_EightWayMovement");
static_assert(offsetof(UHWAbilityAimSettings_EightWayMovement, MaxRange) == 0x000068, "Member 'UHWAbilityAimSettings_EightWayMovement::MaxRange' has a wrong offset!");

// Class Hemingway.HWCameraModifier
// 0x0000 (0x0048 - 0x0048)
class UHWCameraModifier : public UCameraModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCameraModifier">();
	}
	static class UHWCameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCameraModifier>();
	}
};
static_assert(alignof(UHWCameraModifier) == 0x000008, "Wrong alignment on UHWCameraModifier");
static_assert(sizeof(UHWCameraModifier) == 0x000048, "Wrong size on UHWCameraModifier");

// Class Hemingway.HWCameraModifier_ZoomOverride
// 0x0018 (0x0060 - 0x0048)
class UHWCameraModifier_ZoomOverride final : public UHWCameraModifier
{
public:
	float                                         ZoomMinOverride;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomMaxOverride;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCameraModifier_ZoomOverride">();
	}
	static class UHWCameraModifier_ZoomOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCameraModifier_ZoomOverride>();
	}
};
static_assert(alignof(UHWCameraModifier_ZoomOverride) == 0x000008, "Wrong alignment on UHWCameraModifier_ZoomOverride");
static_assert(sizeof(UHWCameraModifier_ZoomOverride) == 0x000060, "Wrong size on UHWCameraModifier_ZoomOverride");
static_assert(offsetof(UHWCameraModifier_ZoomOverride, ZoomMinOverride) == 0x000048, "Member 'UHWCameraModifier_ZoomOverride::ZoomMinOverride' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_ZoomOverride, ZoomMaxOverride) == 0x000050, "Member 'UHWCameraModifier_ZoomOverride::ZoomMaxOverride' has a wrong offset!");

// Class Hemingway.HWAbilityAimSettings_Self
// 0x0010 (0x0078 - 0x0068)
class UHWAbilityAimSettings_Self : public UHWAbilityAimSettings
{
public:
	bool                                          bPlaceAtGround;                                    // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWGroundTargetValidationType                 GroundPlacementValidationType;                     // 0x0069(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimFromCharacterMeshSocket;                       // 0x006A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x1];                                       // 0x006B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x006C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualCollisionRadius;                             // 0x0074(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetManualCollisionRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSettings_Self">();
	}
	static class UHWAbilityAimSettings_Self* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSettings_Self>();
	}
};
static_assert(alignof(UHWAbilityAimSettings_Self) == 0x000008, "Wrong alignment on UHWAbilityAimSettings_Self");
static_assert(sizeof(UHWAbilityAimSettings_Self) == 0x000078, "Wrong size on UHWAbilityAimSettings_Self");
static_assert(offsetof(UHWAbilityAimSettings_Self, bPlaceAtGround) == 0x000068, "Member 'UHWAbilityAimSettings_Self::bPlaceAtGround' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_Self, GroundPlacementValidationType) == 0x000069, "Member 'UHWAbilityAimSettings_Self::GroundPlacementValidationType' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_Self, bAimFromCharacterMeshSocket) == 0x00006A, "Member 'UHWAbilityAimSettings_Self::bAimFromCharacterMeshSocket' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_Self, SocketName) == 0x00006C, "Member 'UHWAbilityAimSettings_Self::SocketName' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_Self, ManualCollisionRadius) == 0x000074, "Member 'UHWAbilityAimSettings_Self::ManualCollisionRadius' has a wrong offset!");

// Class Hemingway.HWAbilityAimSetting_FromAttackHit
// 0x0008 (0x0080 - 0x0078)
class UHWAbilityAimSetting_FromAttackHit final : public UHWAbilityAimSettings_Self
{
public:
	struct FGameplayTag                           SourceAttackId;                                    // 0x0078(0x0008)(Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSetting_FromAttackHit">();
	}
	static class UHWAbilityAimSetting_FromAttackHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSetting_FromAttackHit>();
	}
};
static_assert(alignof(UHWAbilityAimSetting_FromAttackHit) == 0x000008, "Wrong alignment on UHWAbilityAimSetting_FromAttackHit");
static_assert(sizeof(UHWAbilityAimSetting_FromAttackHit) == 0x000080, "Wrong size on UHWAbilityAimSetting_FromAttackHit");
static_assert(offsetof(UHWAbilityAimSetting_FromAttackHit, SourceAttackId) == 0x000078, "Member 'UHWAbilityAimSetting_FromAttackHit::SourceAttackId' has a wrong offset!");

// Class Hemingway.HWBTTask_PullAbilityInfo
// 0x0010 (0x0080 - 0x0070)
class UHWBTTask_PullAbilityInfo final : public UBTTaskNode
{
public:
	TArray<struct FAbilityDataPull>               InfoToPull;                                        // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_PullAbilityInfo">();
	}
	static class UHWBTTask_PullAbilityInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_PullAbilityInfo>();
	}
};
static_assert(alignof(UHWBTTask_PullAbilityInfo) == 0x000008, "Wrong alignment on UHWBTTask_PullAbilityInfo");
static_assert(sizeof(UHWBTTask_PullAbilityInfo) == 0x000080, "Wrong size on UHWBTTask_PullAbilityInfo");
static_assert(offsetof(UHWBTTask_PullAbilityInfo, InfoToPull) == 0x000070, "Member 'UHWBTTask_PullAbilityInfo::InfoToPull' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings
// 0x0228 (0x0250 - 0x0028)
class UHWAbilityAttackSettings : public UObject
{
public:
	uint8                                         Pad_28[0x1];                                       // 0x0028(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldHighlightTargets;                           // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckForValidTarget;                              // 0x002A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePreviousAttackHitTargets;                   // 0x002B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWGameplayTargetDataFilter            AcceptableTargetFilter;                            // 0x0030(0x01D0)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FHWEffectGroupConfig> EffectGroupConfigs;                       // 0x0200(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	struct FGameplayTargetDataFilterHandle GetAcceptableTargetFilter(class AActor* Avatar, const bool bIsPredicting) const;
	EAbilityAttackType GetAttackType() const;
	void GetEffectsForGroups(const struct FGameplayTagContainer& EffectGroupTags, TArray<TSubclassOf<class UGameplayEffect>>* OutEffects) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings">();
	}
	static class UHWAbilityAttackSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings");
static_assert(sizeof(UHWAbilityAttackSettings) == 0x000250, "Wrong size on UHWAbilityAttackSettings");
static_assert(offsetof(UHWAbilityAttackSettings, bShouldHighlightTargets) == 0x000029, "Member 'UHWAbilityAttackSettings::bShouldHighlightTargets' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings, bCheckForValidTarget) == 0x00002A, "Member 'UHWAbilityAttackSettings::bCheckForValidTarget' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings, bIgnorePreviousAttackHitTargets) == 0x00002B, "Member 'UHWAbilityAttackSettings::bIgnorePreviousAttackHitTargets' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings, AcceptableTargetFilter) == 0x000030, "Member 'UHWAbilityAttackSettings::AcceptableTargetFilter' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings, EffectGroupConfigs) == 0x000200, "Member 'UHWAbilityAttackSettings::EffectGroupConfigs' has a wrong offset!");

// Class Hemingway.HWOrderSubsystem
// 0x0000 (0x00C8 - 0x00C8)
class UHWOrderSubsystem final : public URHOrderSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWOrderSubsystem">();
	}
	static class UHWOrderSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWOrderSubsystem>();
	}
};
static_assert(alignof(UHWOrderSubsystem) == 0x000008, "Wrong alignment on UHWOrderSubsystem");
static_assert(sizeof(UHWOrderSubsystem) == 0x0000C8, "Wrong size on UHWOrderSubsystem");

// Class Hemingway.HWAbilityAttackSettings_Collision
// 0x0220 (0x0470 - 0x0250)
#pragma pack(push, 0x1)
class alignas(0x10) UHWAbilityAttackSettings_Collision : public UHWAbilityAttackSettings
{
public:
	TSubclassOf<class UHWAbilityCollisionProxy>   CollisionClass;                                    // 0x0250(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RehitPeriod;                                       // 0x0258(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CollisionTransform;                                // 0x0260(0x0060)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            MeshCollision;                                     // 0x02C0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityCollisionType                         AbilityCollisionType;                              // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBodyInstance                          AbilityCollision;                                  // 0x02D0(0x0190)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UHWAbilityAttackSettings_InstantShape*  HighlightingAttackSettings;                        // 0x0460(0x0008)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Collision">();
	}
	static class UHWAbilityAttackSettings_Collision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Collision>();
	}
};
#pragma pack(pop)
static_assert(alignof(UHWAbilityAttackSettings_Collision) == 0x000010, "Wrong alignment on UHWAbilityAttackSettings_Collision");
static_assert(sizeof(UHWAbilityAttackSettings_Collision) == 0x000470, "Wrong size on UHWAbilityAttackSettings_Collision");
static_assert(offsetof(UHWAbilityAttackSettings_Collision, CollisionClass) == 0x000250, "Member 'UHWAbilityAttackSettings_Collision::CollisionClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Collision, RehitPeriod) == 0x000258, "Member 'UHWAbilityAttackSettings_Collision::RehitPeriod' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Collision, CollisionTransform) == 0x000260, "Member 'UHWAbilityAttackSettings_Collision::CollisionTransform' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Collision, MeshCollision) == 0x0002C0, "Member 'UHWAbilityAttackSettings_Collision::MeshCollision' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Collision, AbilityCollisionType) == 0x0002C8, "Member 'UHWAbilityAttackSettings_Collision::AbilityCollisionType' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Collision, AbilityCollision) == 0x0002D0, "Member 'UHWAbilityAttackSettings_Collision::AbilityCollision' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Collision, HighlightingAttackSettings) == 0x000460, "Member 'UHWAbilityAttackSettings_Collision::HighlightingAttackSettings' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_ChangingCollision
// 0x0010 (0x0480 - 0x0470)
class UHWAbilityAttackSettings_ChangingCollision final : public UHWAbilityAttackSettings_Collision
{
public:
	TArray<struct FHWTransformPhase>              TransformList;                                     // 0x0468(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_ChangingCollision">();
	}
	static class UHWAbilityAttackSettings_ChangingCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_ChangingCollision>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_ChangingCollision) == 0x000010, "Wrong alignment on UHWAbilityAttackSettings_ChangingCollision");
static_assert(sizeof(UHWAbilityAttackSettings_ChangingCollision) == 0x000480, "Wrong size on UHWAbilityAttackSettings_ChangingCollision");
static_assert(offsetof(UHWAbilityAttackSettings_ChangingCollision, TransformList) == 0x000468, "Member 'UHWAbilityAttackSettings_ChangingCollision::TransformList' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_Dummy
// 0x0000 (0x0250 - 0x0250)
class UHWAbilityAttackSettings_Dummy final : public UHWAbilityAttackSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Dummy">();
	}
	static class UHWAbilityAttackSettings_Dummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Dummy>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Dummy) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_Dummy");
static_assert(sizeof(UHWAbilityAttackSettings_Dummy) == 0x000250, "Wrong size on UHWAbilityAttackSettings_Dummy");

// Class Hemingway.HWCharacter_Base
// 0x0CC0 (0x1340 - 0x0680)
#pragma pack(push, 0x1)
class alignas(0x10) AHWCharacter_Base : public ACharacter
{
public:
	uint8                                         Pad_678[0x40];                                     // 0x0678(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWCharacter_Base* OwnerCharacter, class AHWPlayerState* NewPlayerState)> OnPlayerStateChanged; // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C8[0x8];                                      // 0x06C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWAbilitySystemComponent* AbilitySystem, class UHWAbilitySystemComponent* OldAbilitySystem)> OnAbilitySystemUpdatedDelegate; // 0x06D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E0[0x8];                                      // 0x06E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWCharacterAbilitySystemActor*         AbilitySystemActor;                                // 0x06E8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F0[0x8];                                      // 0x06F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AHWCharacter_Base>, float> AssistTrackingDamageTimeStamps;             // 0x06F8(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_748[0x8];                                      // 0x0748(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitReactionWorldForgivenessOffset;                 // 0x0750(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultCritEffectiveness;                          // 0x0754(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultLifeStealEffectiveness;                     // 0x0758(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75C[0x4];                                      // 0x075C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTagFloatPair>          LifeStealEffectivenessOverrides;                   // 0x0760(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWShieldManagerComponent* ShieldManagerComponent)> ShieldManagerComponentUpdated; // 0x0770(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWShieldManagerComponent*              ShieldManagerComponent;                            // 0x0780(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAssetRequestKey                       IntroMontageKey;                                   // 0x0788(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A4[0x4];                                      // 0x07A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnIntroMontageFinishedDelegate;                    // 0x07A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         IntroTiming;                                       // 0x07B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayIntroMontageCutoffTime;                        // 0x07BC(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWCharacter_Base* Character)> OnCharacterDestroyedOrRecycled; // 0x07C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCharacterRevivedDelegate;                        // 0x07D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bUsesDeathMontage;                                 // 0x07E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRagdollDeath;                                  // 0x07E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E2[0x2];                                      // 0x07E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAssetRequestKey                       DeathMontageKey;                                   // 0x07E4(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDead;                                           // 0x0800(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRagDollSetting;                                   // 0x0801(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_802[0x2];                                      // 0x0802(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeAfterDeath;                                    // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimeAfterDeathTimer;                               // 0x0808(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          DeathViewers;                                      // 0x0810(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DeathCueTag;                                       // 0x0820(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyOnDeath;                                   // 0x0828(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_829[0x3];                                      // 0x0829(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  CachedKiller;                                      // 0x082C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            ReviveImmunityHandle;                              // 0x0834(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_83C[0x4];                                      // 0x083C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RespawnTransform;                                  // 0x0840(0x0060)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCurrentlyRespawning;                            // 0x08A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A1[0x7];                                      // 0x08A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        LastRespawnFrame;                                  // 0x08A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWVisibilityComponent* VisibilityComponent)> VisibilityComponentUpdated; // 0x08B0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          bEnableMeshFadingOnVisibilityChanged;              // 0x08C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C1[0x7];                                      // 0x08C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     MeshFadeTimeline;                                  // 0x08C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MeshFadeInOpacityCurve;                            // 0x08D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MeshFadeOutOpacityCurve;                           // 0x08D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMeshFadingIn;                                   // 0x08E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMeshFadingOut;                                  // 0x08E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E2[0x6];                                      // 0x08E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWBotFactory*                          FactoryOwner;                                      // 0x08E8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWDisplayInfoComponent*                DisplayInfoComponent;                              // 0x08F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWDisplayInfoComponent>    DisplayInfoComponentClass;                         // 0x08F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FHWCollisionState& NewCollisionState)> OnCollisionStateChanged; // 0x0900(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IgnoreBlockingByTags;                              // 0x0910(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWCollisionState>              CollisionStack;                                    // 0x0930(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FHWCollisionState                      CurrentCollisionState;                             // 0x0940(0x003C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_97C[0xC];                                      // 0x097C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class USkinObjectManagerComponent*            SkinsManagerComponent;                             // 0x0988(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_990[0x8];                                      // 0x0990(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFirstApparelApplicationSuccess;                   // 0x0998(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_999[0x7];                                      // 0x0999(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWApparelComponent*                    ApparelComponent;                                  // 0x09A0(0x0008)(Edit, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              ApparelApplicationFinished;                        // 0x09A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWApparelComponent* ApparelComponent)> ApparelComponentUpdated; // 0x09B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SkinTagContainer;                                  // 0x09C8(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E8[0x28];                                     // 0x09E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UHWFXCurveComponent*> ActiveFXCurveComponents;                           // 0x0A10(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FPostProcessSettings                   BlendableSettings;                                 // 0x0A60(0x06F0)(Transient, Protected, NativeAccessSpecifierProtected)
	class UCameraModifier*                        BlendableCameraMod;                                // 0x1150(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NotPersistentFXTag;                                // 0x1158(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsIntoxicated;                                    // 0x1160(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1161[0x3];                                     // 0x1161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntoxicatedEffectStartTime;                        // 0x1164(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntoxicatedEffectDuration;                         // 0x1168(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IntoxicatedOrder;                                  // 0x116C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 IntoxicationKnots;                                 // 0x1170(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 IntoxicationStrafeChangeTimes;                     // 0x1180(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      IntoxicationRotatorControl;                        // 0x1190(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         IntoxicatedStrafeStartDirection;                   // 0x11A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A4[0x4];                                     // 0x11A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AHWDeployable_Wall>> OverlappingDeployableWalls;                     // 0x11A8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWCharacter_Base* TeleportedCharacter, const struct FVector& TeleportLocation)> OnCharacterTeleportedDelegate; // 0x11B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C8[0x40];                                    // 0x11C8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWAbilityCollisionProxy_PushPull*> OverlappingPushPullCollisionProxies;            // 0x1208(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWCharacter_Base* OwnerCharacter)> OnCharacterMinimapStateUpdated; // 0x1218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EHWMinimapType                                MinimapType;                                       // 0x1228(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MinimapModifiers;                                  // 0x1229(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_122A[0x6];                                     // 0x122A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnDeathMontageFinishedDelegate;                    // 0x1230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	double                                        MaxCameraPitch;                                    // 0x1240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MinCameraPitch;                                    // 0x1248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWCameraLockInfo                      CameraLockInfo;                                    // 0x1250(0x0028)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1278[0x30];                                    // 0x1278(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IsAnimJumpingCount;                                // 0x12A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12AC[0x14];                                    // 0x12AC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CapsuleGroundReticleDecalMeshComponent;            // 0x12C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CapsuleGroundReticleInnerRadiusKey;                // 0x12C8(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleGroundReticleInnerRadius;                   // 0x12D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CapsuleGroundReticleOuterRadiusKey;                // 0x12D4(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleGroundReticleOuterRadius;                   // 0x12DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CapsuleGroundReticleIsHighlightedKey;              // 0x12E0(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CapsuleGroundReticleIsFriendlyKey;                 // 0x12E8(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               CapsuleGroundReticleDecalMID;                      // 0x12F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHightlighted;                                   // 0x12F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12F9[0x7];                                     // 0x12F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        GroundAttachPoint;                                 // 0x1300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1308[0x8];                                     // 0x1308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugSocketName;                                   // 0x1310(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWCharacter_Base* Character, const bool bCanSpectate)> OnCanSpectateStatusChangedDelegate; // 0x1320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bCanSpectate;                                      // 0x1330(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1331[0x7];                                     // 0x1331(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMinimapModifier(EHWMinimapModifier Modifier);
	void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
	void ApplyBotControl(const struct FVector& InputVector);
	bool DidJustTeleport();
	void GetCameraPitchLimits(double* PitchMin, double* PitchMax);
	const struct FVector GetCurrentTeleportEndLocation();
	const struct FVector GetCurrentTeleportStartLocation();
	void GetUserSettings();
	void HandelTagUpdated_UseControllerRotationYaw(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleAbilitySystemUpdated(class UHWAbilitySystemComponent* NewAbilitySystem, class UHWAbilitySystemComponent* OldAbilitySystem);
	void HandleOnNewSkinTagAsset(TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset);
	void HandleOnSkinTagAssetRemoved(TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove);
	void HandleTagUpdated_AbilityBuffering(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_FreezeSkeleton(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_IgnoreControlRotation(const struct FGameplayTag& Tag, int32 Count);
	void HandleTagUpdated_IgnoreLookInput(const struct FGameplayTag& Tag, int32 Count);
	void HandleTagUpdated_IgnoreMoveInput(const struct FGameplayTag& Tag, int32 Count);
	void HandleTagUpdated_Intoxicate(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_IsInFountain(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_Knockback(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_Mesmerize(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_NoSpectatingAllowed(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_Rooted(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_Stun(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_TargetLock(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_TypeGod(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void MeshFadeTimelineFinished();
	void MeshFadeTimelineUpdate(const float FadeScalar);
	void Multicast_SetEnableCollision(const bool bEnable);
	void OnBroadcastHitReaction(const struct FVector& DamageDirection, float DamageMagnitude);
	void OnDeath();
	void OnHighlightedStatusChanged(const bool bIsHighlighted);
	void OnRep_AbilitySystemActor(class AHWCharacterAbilitySystemActor* PreviousAbilitySystemActor);
	void OnRep_ApparelComponent();
	void OnRep_CameraLockInfo();
	void OnRep_CanSpectate();
	void OnRep_CollisionStack();
	void OnRep_FactoryOwner();
	void OnRep_IsAnimJumpingCount();
	void OnRep_IsDead();
	void OnRep_MinimapModifiersUpdated();
	void OnRep_MinimapTypeUpdated();
	void OnRep_PlayIntroMontageCutoffTime();
	void OnRep_RespawnTransform();
	void OnRep_ShieldManagerComponent();
	void OnRep_SkinTagContainerChanged();
	void OnRespawned();
	void OnSpawned();
	void OnTeamUpdated(class AHWCharacterAbilitySystemActor* OwningAbilitySystemActor, class AHWTeamState* InTeamState);
	void OnTeleportTrackingFinished();
	void OnTimeAfterDeathExpired();
	struct FAssetRequestKey OverrideDeathMontage(const struct FAssetRequestKey& MontageKey);
	void PlayDeathMontage();
	void PlayIntroMontage();
	bool PopCollisionState(const struct FHWCollisionState& CollisionStateData);
	void PushCollisionState(const struct FHWCollisionState& CollisionStateData);
	void RemoveBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject);
	void RemoveMinimapModifier(EHWMinimapModifier Modifier);
	void RemoveSpecialFXCurve(class FName InFXID);
	void ResetMeshFadeValueAfterMeshSwap(bool bMeshSwapped);
	void ResetSpecialFXTime(class FName InFXID);
	void ReverseSpecialFX(class FName InFXID);
	void SetCameraLock(const bool bEnable, const struct FRotator& LockOrigin, const float YawAngleThreshold, const float PitchAngleThreshold, const bool bUseCurrentCharacterRotationAsOriginRotation);
	void SetCameraPitchLimits(double PitchMin, double PitchMax);
	void SetCameraPitchLimitsWithLerp(double PitchMin, double PitchMax, float LerpTime);
	void SetFactoryOwner(class AHWBotFactory* factory);
	void SetLocalTeamColor(class AHWCharacterAbilitySystemActor* OwningAbilitySystemActor, class AHWTeamState* InTeamState);
	void SetToBaseCollisionState(const bool bReturnToWalking, const bool bCheckDeath);
	bool ShouldPreventCustomMovementFromInstigator(const class AHWCharacter_Base* MovementInstigator, const bool bApplyEffectsAndCosts);
	class UHWFXCurveComponent* StartHWSpecialEffect(const struct FHWSpecialEffect& Effect, float PlayRate, bool bRestart);
	void StopBotControllerMovement();
	void StopSpecialFX(class FName InFXID);
	void Suicide();
	void SwapSkinTags(const struct FGameplayTag& NewSkinTag, const struct FGameplayTag& OldSkinTag);
	void TeleportToLocation(const struct FVector& TargetLocation, struct FHitResult* SweepHitResult, const bool bPreserveZHeight, const bool bSweep);
	bool TeleportToStartSpot();
	void TeleportToTransform(const struct FTransform& TargetTransform, struct FHitResult* SweepHitResult, const bool bPreserveZHeight, const bool bSweep);
	void TestCheat(const bool bSetActive, const int32 testInt);
	void UpdateCanSpectateStatus();

	bool CanBeHardDisplaced() const;
	bool CanBePulled() const;
	bool DidRespawnThisTick() const;
	struct FHWCollisionState GenerateBaseCollisionState() const;
	class UAbilitySystemComponent* GetAbilitySystemComponent() const;
	class UHWApparelComponent* GetApparelComponent() const;
	class UMultiSkinObject* GetApparelSkinObjectByName(const class FName& InSkinObjectName) const;
	float GetCapsuleHalfHeight(const bool bScaled) const;
	float GetCapsuleRadius(const bool bScaled) const;
	class AHWCharacterAbilitySystemActor* GetCharacterAbilitySystemActor() const;
	float GetCharacterLevel() const;
	class UMultiSkinObject* GetCharacterMeshApparelSkinObject() const;
	const class UHWSkinItem* GetCurrentSkin() const;
	class AActor* GetCurrentTargetActor() const;
	int32 GetDamageCountFromSource(const class AHWCharacter_Base* Source, const float MaxTimeRange) const;
	int32 GetDamageSourceCountInTimeframe(const float Timeframe, bool bGodsOnly) const;
	class UHWDisplayInfoComponent* GetDisplayInfoComponent() const;
	class AHWBotFactory* GetFactoryOwner() const;
	struct FHWActiveFamiliarHandle GetFamiliarHandle() const;
	class UHWFXCurveComponent* GetFXCurveComponentByFXID(class FName InFXID) const;
	float GetGold() const;
	float GetHealth() const;
	float GetHealthPercentage() const;
	class UHWAbilitySystemComponent* GetHWAbilitySystemComponent() const;
	class AHWPlayerState* GetHWPlayerState() const;
	float GetInhandProjectileSpeedModifierPercent() const;
	class UHWInventoryManagerComponent* GetInventoryManager() const;
	struct FVector GetLastValidGroundLocation(const struct FGameplayTag& PlaneOfExistence) const;
	float GetMana() const;
	float GetManaPercentage() const;
	double GetMaxCameraPitch() const;
	float GetMaxHealth() const;
	float GetMaxMana() const;
	double GetMinCameraPitch() const;
	EHWMinimapType GetMinimapType() const;
	class AHWCharacter_Base* GetMostRecentDamageSourceInTimeframe(const float Timeframe, const float Range, bool bGodsOnly) const;
	class UHWShieldManagerComponent* GetShieldManagerComponent() const;
	bool HasApparelBeenAppliedAtLeastOnce() const;
	bool HasBeenDamagedInTimeframe(const float Timeframe, bool bGodsOnly) const;
	bool HasMinimapModifier(EHWMinimapModifier Modifier) const;
	bool HasValidGroundLocation() const;
	bool IsAGod() const;
	bool IsAJungleBoss() const;
	bool IsAJungleMonster() const;
	bool IsAMinion() const;
	bool IsAStructure() const;
	bool IsATitan() const;
	bool IsCloneFamiliar() const;
	bool IsFamiliar() const;
	bool IsGodDecoy() const;
	bool IsHardRooted() const;
	bool IsImmobilized() const;
	bool IsMesmerized() const;
	bool IsRespawning() const;
	bool IsSkinningReady() const;
	bool IsStunned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Base">();
	}
	static class AHWCharacter_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Base>();
	}
};
#pragma pack(pop)
static_assert(alignof(AHWCharacter_Base) == 0x000010, "Wrong alignment on AHWCharacter_Base");
static_assert(sizeof(AHWCharacter_Base) == 0x001340, "Wrong size on AHWCharacter_Base");
static_assert(offsetof(AHWCharacter_Base, OnPlayerStateChanged) == 0x0006B8, "Member 'AHWCharacter_Base::OnPlayerStateChanged' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OnAbilitySystemUpdatedDelegate) == 0x0006D0, "Member 'AHWCharacter_Base::OnAbilitySystemUpdatedDelegate' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, AbilitySystemActor) == 0x0006E8, "Member 'AHWCharacter_Base::AbilitySystemActor' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, AssistTrackingDamageTimeStamps) == 0x0006F8, "Member 'AHWCharacter_Base::AssistTrackingDamageTimeStamps' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, HitReactionWorldForgivenessOffset) == 0x000750, "Member 'AHWCharacter_Base::HitReactionWorldForgivenessOffset' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, DefaultCritEffectiveness) == 0x000754, "Member 'AHWCharacter_Base::DefaultCritEffectiveness' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, DefaultLifeStealEffectiveness) == 0x000758, "Member 'AHWCharacter_Base::DefaultLifeStealEffectiveness' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, LifeStealEffectivenessOverrides) == 0x000760, "Member 'AHWCharacter_Base::LifeStealEffectivenessOverrides' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, ShieldManagerComponentUpdated) == 0x000770, "Member 'AHWCharacter_Base::ShieldManagerComponentUpdated' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, ShieldManagerComponent) == 0x000780, "Member 'AHWCharacter_Base::ShieldManagerComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IntroMontageKey) == 0x000788, "Member 'AHWCharacter_Base::IntroMontageKey' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OnIntroMontageFinishedDelegate) == 0x0007A8, "Member 'AHWCharacter_Base::OnIntroMontageFinishedDelegate' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IntroTiming) == 0x0007B8, "Member 'AHWCharacter_Base::IntroTiming' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, PlayIntroMontageCutoffTime) == 0x0007BC, "Member 'AHWCharacter_Base::PlayIntroMontageCutoffTime' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OnCharacterDestroyedOrRecycled) == 0x0007C0, "Member 'AHWCharacter_Base::OnCharacterDestroyedOrRecycled' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OnCharacterRevivedDelegate) == 0x0007D0, "Member 'AHWCharacter_Base::OnCharacterRevivedDelegate' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bUsesDeathMontage) == 0x0007E0, "Member 'AHWCharacter_Base::bUsesDeathMontage' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bUseRagdollDeath) == 0x0007E1, "Member 'AHWCharacter_Base::bUseRagdollDeath' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, DeathMontageKey) == 0x0007E4, "Member 'AHWCharacter_Base::DeathMontageKey' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bIsDead) == 0x000800, "Member 'AHWCharacter_Base::bIsDead' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bRagDollSetting) == 0x000801, "Member 'AHWCharacter_Base::bRagDollSetting' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, TimeAfterDeath) == 0x000804, "Member 'AHWCharacter_Base::TimeAfterDeath' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, TimeAfterDeathTimer) == 0x000808, "Member 'AHWCharacter_Base::TimeAfterDeathTimer' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, DeathViewers) == 0x000810, "Member 'AHWCharacter_Base::DeathViewers' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, DeathCueTag) == 0x000820, "Member 'AHWCharacter_Base::DeathCueTag' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bDestroyOnDeath) == 0x000828, "Member 'AHWCharacter_Base::bDestroyOnDeath' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CachedKiller) == 0x00082C, "Member 'AHWCharacter_Base::CachedKiller' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, ReviveImmunityHandle) == 0x000834, "Member 'AHWCharacter_Base::ReviveImmunityHandle' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, RespawnTransform) == 0x000840, "Member 'AHWCharacter_Base::RespawnTransform' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bIsCurrentlyRespawning) == 0x0008A0, "Member 'AHWCharacter_Base::bIsCurrentlyRespawning' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, LastRespawnFrame) == 0x0008A8, "Member 'AHWCharacter_Base::LastRespawnFrame' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, VisibilityComponentUpdated) == 0x0008B0, "Member 'AHWCharacter_Base::VisibilityComponentUpdated' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bEnableMeshFadingOnVisibilityChanged) == 0x0008C0, "Member 'AHWCharacter_Base::bEnableMeshFadingOnVisibilityChanged' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, MeshFadeTimeline) == 0x0008C8, "Member 'AHWCharacter_Base::MeshFadeTimeline' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, MeshFadeInOpacityCurve) == 0x0008D0, "Member 'AHWCharacter_Base::MeshFadeInOpacityCurve' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, MeshFadeOutOpacityCurve) == 0x0008D8, "Member 'AHWCharacter_Base::MeshFadeOutOpacityCurve' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bIsMeshFadingIn) == 0x0008E0, "Member 'AHWCharacter_Base::bIsMeshFadingIn' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bIsMeshFadingOut) == 0x0008E1, "Member 'AHWCharacter_Base::bIsMeshFadingOut' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, FactoryOwner) == 0x0008E8, "Member 'AHWCharacter_Base::FactoryOwner' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, DisplayInfoComponent) == 0x0008F0, "Member 'AHWCharacter_Base::DisplayInfoComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, DisplayInfoComponentClass) == 0x0008F8, "Member 'AHWCharacter_Base::DisplayInfoComponentClass' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OnCollisionStateChanged) == 0x000900, "Member 'AHWCharacter_Base::OnCollisionStateChanged' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IgnoreBlockingByTags) == 0x000910, "Member 'AHWCharacter_Base::IgnoreBlockingByTags' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CollisionStack) == 0x000930, "Member 'AHWCharacter_Base::CollisionStack' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CurrentCollisionState) == 0x000940, "Member 'AHWCharacter_Base::CurrentCollisionState' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, SkinsManagerComponent) == 0x000988, "Member 'AHWCharacter_Base::SkinsManagerComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bFirstApparelApplicationSuccess) == 0x000998, "Member 'AHWCharacter_Base::bFirstApparelApplicationSuccess' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, ApparelComponent) == 0x0009A0, "Member 'AHWCharacter_Base::ApparelComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, ApparelApplicationFinished) == 0x0009A8, "Member 'AHWCharacter_Base::ApparelApplicationFinished' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, ApparelComponentUpdated) == 0x0009B8, "Member 'AHWCharacter_Base::ApparelComponentUpdated' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, SkinTagContainer) == 0x0009C8, "Member 'AHWCharacter_Base::SkinTagContainer' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, ActiveFXCurveComponents) == 0x000A10, "Member 'AHWCharacter_Base::ActiveFXCurveComponents' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, BlendableSettings) == 0x000A60, "Member 'AHWCharacter_Base::BlendableSettings' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, BlendableCameraMod) == 0x001150, "Member 'AHWCharacter_Base::BlendableCameraMod' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, NotPersistentFXTag) == 0x001158, "Member 'AHWCharacter_Base::NotPersistentFXTag' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bIsIntoxicated) == 0x001160, "Member 'AHWCharacter_Base::bIsIntoxicated' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IntoxicatedEffectStartTime) == 0x001164, "Member 'AHWCharacter_Base::IntoxicatedEffectStartTime' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IntoxicatedEffectDuration) == 0x001168, "Member 'AHWCharacter_Base::IntoxicatedEffectDuration' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IntoxicatedOrder) == 0x00116C, "Member 'AHWCharacter_Base::IntoxicatedOrder' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IntoxicationKnots) == 0x001170, "Member 'AHWCharacter_Base::IntoxicationKnots' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IntoxicationStrafeChangeTimes) == 0x001180, "Member 'AHWCharacter_Base::IntoxicationStrafeChangeTimes' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IntoxicationRotatorControl) == 0x001190, "Member 'AHWCharacter_Base::IntoxicationRotatorControl' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IntoxicatedStrafeStartDirection) == 0x0011A0, "Member 'AHWCharacter_Base::IntoxicatedStrafeStartDirection' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OverlappingDeployableWalls) == 0x0011A8, "Member 'AHWCharacter_Base::OverlappingDeployableWalls' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OnCharacterTeleportedDelegate) == 0x0011B8, "Member 'AHWCharacter_Base::OnCharacterTeleportedDelegate' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OverlappingPushPullCollisionProxies) == 0x001208, "Member 'AHWCharacter_Base::OverlappingPushPullCollisionProxies' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OnCharacterMinimapStateUpdated) == 0x001218, "Member 'AHWCharacter_Base::OnCharacterMinimapStateUpdated' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, MinimapType) == 0x001228, "Member 'AHWCharacter_Base::MinimapType' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, MinimapModifiers) == 0x001229, "Member 'AHWCharacter_Base::MinimapModifiers' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OnDeathMontageFinishedDelegate) == 0x001230, "Member 'AHWCharacter_Base::OnDeathMontageFinishedDelegate' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, MaxCameraPitch) == 0x001240, "Member 'AHWCharacter_Base::MaxCameraPitch' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, MinCameraPitch) == 0x001248, "Member 'AHWCharacter_Base::MinCameraPitch' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CameraLockInfo) == 0x001250, "Member 'AHWCharacter_Base::CameraLockInfo' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, IsAnimJumpingCount) == 0x0012A8, "Member 'AHWCharacter_Base::IsAnimJumpingCount' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CapsuleGroundReticleDecalMeshComponent) == 0x0012C0, "Member 'AHWCharacter_Base::CapsuleGroundReticleDecalMeshComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CapsuleGroundReticleInnerRadiusKey) == 0x0012C8, "Member 'AHWCharacter_Base::CapsuleGroundReticleInnerRadiusKey' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CapsuleGroundReticleInnerRadius) == 0x0012D0, "Member 'AHWCharacter_Base::CapsuleGroundReticleInnerRadius' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CapsuleGroundReticleOuterRadiusKey) == 0x0012D4, "Member 'AHWCharacter_Base::CapsuleGroundReticleOuterRadiusKey' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CapsuleGroundReticleOuterRadius) == 0x0012DC, "Member 'AHWCharacter_Base::CapsuleGroundReticleOuterRadius' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CapsuleGroundReticleIsHighlightedKey) == 0x0012E0, "Member 'AHWCharacter_Base::CapsuleGroundReticleIsHighlightedKey' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CapsuleGroundReticleIsFriendlyKey) == 0x0012E8, "Member 'AHWCharacter_Base::CapsuleGroundReticleIsFriendlyKey' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, CapsuleGroundReticleDecalMID) == 0x0012F0, "Member 'AHWCharacter_Base::CapsuleGroundReticleDecalMID' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bIsHightlighted) == 0x0012F8, "Member 'AHWCharacter_Base::bIsHightlighted' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, GroundAttachPoint) == 0x001300, "Member 'AHWCharacter_Base::GroundAttachPoint' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, DebugSocketName) == 0x001310, "Member 'AHWCharacter_Base::DebugSocketName' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, OnCanSpectateStatusChangedDelegate) == 0x001320, "Member 'AHWCharacter_Base::OnCanSpectateStatusChangedDelegate' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Base, bCanSpectate) == 0x001330, "Member 'AHWCharacter_Base::bCanSpectate' has a wrong offset!");

// Class Hemingway.HWCharacter_PlayableCharacter
// 0x00A0 (0x13E0 - 0x1340)
class AHWCharacter_PlayableCharacter : public AHWCharacter_Base
{
public:
	uint8                                         Pad_1338[0x8];                                     // 0x1338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWInputConfig*                         CharacterInputConfig;                              // 0x1340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint32>                                BoundInputHandles;                                 // 0x1348(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1358[0x28];                                    // 0x1358(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWSpringArmComponent*                  CameraSpringArm;                                   // 0x1380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       Camera;                                            // 0x1388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartingCameraZ;                                   // 0x1390(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1394[0x14];                                    // 0x1394(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseKillAssistEligibilityDurationOverrides;        // 0x13A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13A9[0x3];                                     // 0x13A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GodKillAssistEligibilityDurationOverride;          // 0x13AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPCKillAssistEligibilityDurationOverride;          // 0x13B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseKillAssistRangeOverride;                       // 0x13B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B5[0x3];                                     // 0x13B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillAssistRangeOverride;                           // 0x13B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoRunEnabled;                                   // 0x13BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13BD[0x23];                                    // 0x13BD(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleTagUpdated_DisableCameraCollision(const struct FGameplayTag& Tag, int32 Count);
	void Input_JumpPressed(const struct FInputActionValue& InputActionValue);
	void Input_JumpReleased(const struct FInputActionValue& InputActionValue);
	void Input_Look(const struct FInputActionValue& InputActionValue);
	void Input_Move(const struct FInputActionValue& InputActionValue);

	float GetEffectiveKillAssistRange() const;
	float GetGodKillAssistEligibilityDuration() const;
	float GetNPCKillAssistEligibilityDuration() const;
	class UHWSpringArmComponent* GetSpringArmComponent() const;
	float GetStartingCameraZ() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_PlayableCharacter">();
	}
	static class AHWCharacter_PlayableCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_PlayableCharacter>();
	}
};
static_assert(alignof(AHWCharacter_PlayableCharacter) == 0x000010, "Wrong alignment on AHWCharacter_PlayableCharacter");
static_assert(sizeof(AHWCharacter_PlayableCharacter) == 0x0013E0, "Wrong size on AHWCharacter_PlayableCharacter");
static_assert(offsetof(AHWCharacter_PlayableCharacter, CharacterInputConfig) == 0x001340, "Member 'AHWCharacter_PlayableCharacter::CharacterInputConfig' has a wrong offset!");
static_assert(offsetof(AHWCharacter_PlayableCharacter, BoundInputHandles) == 0x001348, "Member 'AHWCharacter_PlayableCharacter::BoundInputHandles' has a wrong offset!");
static_assert(offsetof(AHWCharacter_PlayableCharacter, CameraSpringArm) == 0x001380, "Member 'AHWCharacter_PlayableCharacter::CameraSpringArm' has a wrong offset!");
static_assert(offsetof(AHWCharacter_PlayableCharacter, Camera) == 0x001388, "Member 'AHWCharacter_PlayableCharacter::Camera' has a wrong offset!");
static_assert(offsetof(AHWCharacter_PlayableCharacter, StartingCameraZ) == 0x001390, "Member 'AHWCharacter_PlayableCharacter::StartingCameraZ' has a wrong offset!");
static_assert(offsetof(AHWCharacter_PlayableCharacter, bUseKillAssistEligibilityDurationOverrides) == 0x0013A8, "Member 'AHWCharacter_PlayableCharacter::bUseKillAssistEligibilityDurationOverrides' has a wrong offset!");
static_assert(offsetof(AHWCharacter_PlayableCharacter, GodKillAssistEligibilityDurationOverride) == 0x0013AC, "Member 'AHWCharacter_PlayableCharacter::GodKillAssistEligibilityDurationOverride' has a wrong offset!");
static_assert(offsetof(AHWCharacter_PlayableCharacter, NPCKillAssistEligibilityDurationOverride) == 0x0013B0, "Member 'AHWCharacter_PlayableCharacter::NPCKillAssistEligibilityDurationOverride' has a wrong offset!");
static_assert(offsetof(AHWCharacter_PlayableCharacter, bUseKillAssistRangeOverride) == 0x0013B4, "Member 'AHWCharacter_PlayableCharacter::bUseKillAssistRangeOverride' has a wrong offset!");
static_assert(offsetof(AHWCharacter_PlayableCharacter, KillAssistRangeOverride) == 0x0013B8, "Member 'AHWCharacter_PlayableCharacter::KillAssistRangeOverride' has a wrong offset!");
static_assert(offsetof(AHWCharacter_PlayableCharacter, bAutoRunEnabled) == 0x0013BC, "Member 'AHWCharacter_PlayableCharacter::bAutoRunEnabled' has a wrong offset!");

// Class Hemingway.HWCharacter_Smite_God
// 0x0060 (0x1440 - 0x13E0)
class AHWCharacter_Smite_God : public AHWCharacter_PlayableCharacter
{
public:
	class UDecalComponent*                        AOGroundDecal;                                     // 0x13E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOGroundDecalSizeMultiplier;                       // 0x13E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13EC[0x4];                                     // 0x13EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     DamageFeedbackTimeline;                            // 0x13F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DamageFeedbackOpacityCurve;                        // 0x13F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DamageEnemyMaterial;                               // 0x1400(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DamageSelfMaterial;                                // 0x1408(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     AOGroundMaterial;                                  // 0x1410(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MIDEnemyDamage;                                    // 0x1418(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MIDSelfDamage;                                     // 0x1420(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWMaterialOverlayHandle               DamageOverlayHandle;                               // 0x1428(0x0004)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_142C[0x4];                                     // 0x142C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWVoiceComponent*                      VoiceComponent;                                    // 0x1430(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowHealthVoiceThreshold;                           // 0x1438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_143C[0x4];                                     // 0x143C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateCharacterDamagedFeedbackMaterialOverlay(const float Duration, const float MaterialIntensity);
	void DamageFeedbackTimelineFinished();
	void DamageFeedbackTimelineUpdate(float Value);
	void HandleTagUpdated_InCombat(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void TriggerLocalVoiceEvent(const struct FGameplayTag& VoiceEvent);
	void TriggerVoiceEvent(const struct FGameplayTag& VoiceEvent, const struct FGameplayTag& AudienceOverride);

	class UHWVoiceComponent* GetVoiceComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Smite_God">();
	}
	static class AHWCharacter_Smite_God* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Smite_God>();
	}
};
static_assert(alignof(AHWCharacter_Smite_God) == 0x000010, "Wrong alignment on AHWCharacter_Smite_God");
static_assert(sizeof(AHWCharacter_Smite_God) == 0x001440, "Wrong size on AHWCharacter_Smite_God");
static_assert(offsetof(AHWCharacter_Smite_God, AOGroundDecal) == 0x0013E0, "Member 'AHWCharacter_Smite_God::AOGroundDecal' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, AOGroundDecalSizeMultiplier) == 0x0013E8, "Member 'AHWCharacter_Smite_God::AOGroundDecalSizeMultiplier' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, DamageFeedbackTimeline) == 0x0013F0, "Member 'AHWCharacter_Smite_God::DamageFeedbackTimeline' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, DamageFeedbackOpacityCurve) == 0x0013F8, "Member 'AHWCharacter_Smite_God::DamageFeedbackOpacityCurve' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, DamageEnemyMaterial) == 0x001400, "Member 'AHWCharacter_Smite_God::DamageEnemyMaterial' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, DamageSelfMaterial) == 0x001408, "Member 'AHWCharacter_Smite_God::DamageSelfMaterial' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, AOGroundMaterial) == 0x001410, "Member 'AHWCharacter_Smite_God::AOGroundMaterial' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, MIDEnemyDamage) == 0x001418, "Member 'AHWCharacter_Smite_God::MIDEnemyDamage' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, MIDSelfDamage) == 0x001420, "Member 'AHWCharacter_Smite_God::MIDSelfDamage' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, DamageOverlayHandle) == 0x001428, "Member 'AHWCharacter_Smite_God::DamageOverlayHandle' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, VoiceComponent) == 0x001430, "Member 'AHWCharacter_Smite_God::VoiceComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Smite_God, LowHealthVoiceThreshold) == 0x001438, "Member 'AHWCharacter_Smite_God::LowHealthVoiceThreshold' has a wrong offset!");

// Class Hemingway.HWCharacter_Morrigan
// 0x0000 (0x1440 - 0x1440)
class AHWCharacter_Morrigan final : public AHWCharacter_Smite_God
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Morrigan">();
	}
	static class AHWCharacter_Morrigan* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Morrigan>();
	}
};
static_assert(alignof(AHWCharacter_Morrigan) == 0x000010, "Wrong alignment on AHWCharacter_Morrigan");
static_assert(sizeof(AHWCharacter_Morrigan) == 0x001440, "Wrong size on AHWCharacter_Morrigan");

// Class Hemingway.HWAbilityAttackSettings_RadialSweep
// 0x0000 (0x0470 - 0x0470)
class UHWAbilityAttackSettings_RadialSweep final : public UHWAbilityAttackSettings_Collision
{
public:
	float                                         RotationRate;                                      // 0x0468(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFollowActorRotation;                           // 0x046C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_RadialSweep">();
	}
	static class UHWAbilityAttackSettings_RadialSweep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_RadialSweep>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_RadialSweep) == 0x000010, "Wrong alignment on UHWAbilityAttackSettings_RadialSweep");
static_assert(sizeof(UHWAbilityAttackSettings_RadialSweep) == 0x000470, "Wrong size on UHWAbilityAttackSettings_RadialSweep");
static_assert(offsetof(UHWAbilityAttackSettings_RadialSweep, RotationRate) == 0x000468, "Member 'UHWAbilityAttackSettings_RadialSweep::RotationRate' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_RadialSweep, bUseFollowActorRotation) == 0x00046C, "Member 'UHWAbilityAttackSettings_RadialSweep::bUseFollowActorRotation' has a wrong offset!");

// Class Hemingway.HWStoreSubsystem
// 0x0258 (0x0548 - 0x02F0)
class UHWStoreSubsystem final : public URHStoreSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnIsReadyForQueries;                               // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVendorsLoaded;                                   // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AdditionalStoreVendorIds;                          // 0x0318(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnDisplayedEmptyStoreMessage;                      // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x1];                                      // 0x0338(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWPlatformBool                        bIsCurrencyPurchaseEnabled;                        // 0x0339(0x0003)(Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              GenericCollectionItemSoftPtr;                      // 0x0340(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GenericCollectionItemTable;                        // 0x0368(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x18];                                     // 0x0370(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class URHCurrency>             LegacyCurrencyItemSoftPtr;                         // 0x0388(0x0028)(BlueprintVisible, BlueprintReadOnly, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URHCurrency*                            LegacyCurrencyItem;                                // 0x03B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FRH_ItemId, class URHCurrency*>   OtherCurrencies;                                   // 0x03B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class URHCurrency>>     DynamicDisplayCurrencies;                          // 0x0408(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x50];                                     // 0x0418(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWPlatformBool                        bArePurchasesWithCurrencyEnabled;                  // 0x0468(0x0003)(Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHWPlatformBool                        bArePortalOffersEnabled;                           // 0x046B(0x0003)(Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_46E[0x2];                                      // 0x046E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWHasEnoughCurrencyHelper*>     HasEnoughCurrencyHelpers;                          // 0x0470(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UHWGetAvailablePricesHelper*>    GetAvailablePriceHelpers;                          // 0x0480(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FRH_ItemId                             FounderOwnershipItemId;                            // 0x0490(0x0014)(BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_ItemId                             DeluxeOwnershipItemId;                             // 0x04A4(0x0014)(BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_ItemId                             UltimateOwnershipItemId;                           // 0x04B8(0x0014)(BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CrossPlatformVoucherVendorId;                      // 0x04CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FRH_ItemId, struct FRH_LootId>    PrismBundleUpsells;                                // 0x04D0(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FRH_ItemId                             VIPOwnershipItemId;                                // 0x0520(0x0014)(BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_LootId                             VIPOwnershipLootId;                                // 0x0534(0x0014)(BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddDynamicDisplayCurrency(TSoftObjectPtr<class URHCurrency> CURRENCY);
	void ClearDynamicDisplayCurrencies();
	void GetPriceForDisplay(class URHStoreItem* StoreItem, const class URH_PlayerInfo* PlayerInfo, TDelegate<void(const class URHStoreItemPrice* ItemPrice, const struct FGameplayTag& PriceGroupTag)> Callback);
	class URHStoreItem* GetVIPStoreItem();
	void RemoveDynamicDisplayCurrency(TSoftObjectPtr<class URHCurrency> CURRENCY);
	void ShowEmptyStoreMessage();

	EHWCurrencyType CurrencyIdToType(const struct FRH_ItemId& CurrencyId) const;
	struct FRH_ItemId CurrencyTypeToId(EHWCurrencyType CurrencyType) const;
	bool GetArePurchasesWithCurrencyEnabled() const;
	struct FDateTime GetCachedPlayerVIPOwnershipExpiration(const class URH_PlayerInfo* PlayerInfo) const;
	EHWVIPOwnershipLevel GetCachedPlayerVIPOwnershipLevel(const class URH_PlayerInfo* PlayerInfo) const;
	class URHCurrency* GetCurrencyById(const struct FRH_ItemId& ItemId) const;
	class URHCurrency* GetCurrencyByType(EHWCurrencyType CurrencyType) const;
	const TArray<TSoftObjectPtr<class URHCurrency>> GetDynamicDisplayCurrencies() const;
	TSoftObjectPtr<class UHWCollectionItem> GetGenericCollectionItemById(const struct FRH_ItemId& ItemId, struct FHWGenericCollectionMappedData* OutMappedData) const;
	class URHCurrency* GetLegacyCurrencyItem() const;
	EHWFoundersOwnershipLevel GetPlayerFoundersOwnershipLevel(const class URH_PlayerInfo* PlayerInfo) const;
	struct FRH_LootId GetPrismBundleUpsell(const struct FRH_ItemId& BaseSkinId) const;
	class URHStorePurchaseRequest* GetPurchaseRequestDataForItem(const class UHWInventoryItem* Item) const;
	TSoftObjectPtr<class URHCurrency> GetSoftCurrencyById(const struct FRH_ItemId& ItemId) const;
	class URHStoreItem* GetStoreItemBySKU(const class FString& Sku) const;
	bool IsReadyForQueries() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWStoreSubsystem">();
	}
	static class UHWStoreSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWStoreSubsystem>();
	}
};
static_assert(alignof(UHWStoreSubsystem) == 0x000008, "Wrong alignment on UHWStoreSubsystem");
static_assert(sizeof(UHWStoreSubsystem) == 0x000548, "Wrong size on UHWStoreSubsystem");
static_assert(offsetof(UHWStoreSubsystem, OnIsReadyForQueries) == 0x0002F0, "Member 'UHWStoreSubsystem::OnIsReadyForQueries' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, OnVendorsLoaded) == 0x000300, "Member 'UHWStoreSubsystem::OnVendorsLoaded' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, AdditionalStoreVendorIds) == 0x000318, "Member 'UHWStoreSubsystem::AdditionalStoreVendorIds' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, OnDisplayedEmptyStoreMessage) == 0x000328, "Member 'UHWStoreSubsystem::OnDisplayedEmptyStoreMessage' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, bIsCurrencyPurchaseEnabled) == 0x000339, "Member 'UHWStoreSubsystem::bIsCurrencyPurchaseEnabled' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, GenericCollectionItemSoftPtr) == 0x000340, "Member 'UHWStoreSubsystem::GenericCollectionItemSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, GenericCollectionItemTable) == 0x000368, "Member 'UHWStoreSubsystem::GenericCollectionItemTable' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, LegacyCurrencyItemSoftPtr) == 0x000388, "Member 'UHWStoreSubsystem::LegacyCurrencyItemSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, LegacyCurrencyItem) == 0x0003B0, "Member 'UHWStoreSubsystem::LegacyCurrencyItem' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, OtherCurrencies) == 0x0003B8, "Member 'UHWStoreSubsystem::OtherCurrencies' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, DynamicDisplayCurrencies) == 0x000408, "Member 'UHWStoreSubsystem::DynamicDisplayCurrencies' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, bArePurchasesWithCurrencyEnabled) == 0x000468, "Member 'UHWStoreSubsystem::bArePurchasesWithCurrencyEnabled' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, bArePortalOffersEnabled) == 0x00046B, "Member 'UHWStoreSubsystem::bArePortalOffersEnabled' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, HasEnoughCurrencyHelpers) == 0x000470, "Member 'UHWStoreSubsystem::HasEnoughCurrencyHelpers' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, GetAvailablePriceHelpers) == 0x000480, "Member 'UHWStoreSubsystem::GetAvailablePriceHelpers' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, FounderOwnershipItemId) == 0x000490, "Member 'UHWStoreSubsystem::FounderOwnershipItemId' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, DeluxeOwnershipItemId) == 0x0004A4, "Member 'UHWStoreSubsystem::DeluxeOwnershipItemId' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, UltimateOwnershipItemId) == 0x0004B8, "Member 'UHWStoreSubsystem::UltimateOwnershipItemId' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, CrossPlatformVoucherVendorId) == 0x0004CC, "Member 'UHWStoreSubsystem::CrossPlatformVoucherVendorId' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, PrismBundleUpsells) == 0x0004D0, "Member 'UHWStoreSubsystem::PrismBundleUpsells' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, VIPOwnershipItemId) == 0x000520, "Member 'UHWStoreSubsystem::VIPOwnershipItemId' has a wrong offset!");
static_assert(offsetof(UHWStoreSubsystem, VIPOwnershipLootId) == 0x000534, "Member 'UHWStoreSubsystem::VIPOwnershipLootId' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_Custom
// 0x0000 (0x0250 - 0x0250)
class UHWAbilityAttackSettings_Custom : public UHWAbilityAttackSettings
{
public:
	void BP_CalcHighlightingTargetList(const struct FHWAttackTargetingInfo& TargetingInfo, struct FGameplayAbilityTargetDataHandle& TargetListDataHandle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Custom">();
	}
	static class UHWAbilityAttackSettings_Custom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Custom>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Custom) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_Custom");
static_assert(sizeof(UHWAbilityAttackSettings_Custom) == 0x000250, "Wrong size on UHWAbilityAttackSettings_Custom");

// Class Hemingway.HWAbilityCollisionProxy
// 0x0410 (0x0A40 - 0x0630)
#pragma pack(push, 0x1)
class alignas(0x10) UHWAbilityCollisionProxy : public UStaticMeshComponent
{
public:
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCollisionInitiated;                               // 0x0630(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_631[0x17];                                     // 0x0631(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWAbilityTask_FireAttack* AttackTask, const struct FHWAbilityAttackInstance& AbilityAttack, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, const struct FGameplayTagContainer& HitTags)> OnAttemptAbilityHit; // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilityTask_FireAttack* AttackTask, const struct FGameplayTagContainer& UnHitTags, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle)> OnRemoveAbilityHit; // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHWGameplayTargetDataFilter            AcceptableCollisionFilter;                         // 0x0668(0x01D0)(Net, NativeAccessSpecifierPublic)
	bool                                          bUseAttachedActorCollisionFilterOverride;          // 0x0838(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_839[0x7];                                      // 0x0839(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWGameplayTargetDataFilter            AttachedActorCollisionFilterOverride;              // 0x0840(0x01D0)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_A10[0x18];                                     // 0x0A10(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHWAbilityTask_FireAttack> AttackTask;                                      // 0x0A28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A30[0x8];                                      // 0x0A30(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearProxyTouchListRehitTimes();
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void RemoveActorFromProxyTouchList(const class AActor* TargetActor);
	bool ShouldUseBaseCollisionFollow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityCollisionProxy">();
	}
	static class UHWAbilityCollisionProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityCollisionProxy>();
	}
};
#pragma pack(pop)
static_assert(alignof(UHWAbilityCollisionProxy) == 0x000010, "Wrong alignment on UHWAbilityCollisionProxy");
static_assert(sizeof(UHWAbilityCollisionProxy) == 0x000A40, "Wrong size on UHWAbilityCollisionProxy");
static_assert(offsetof(UHWAbilityCollisionProxy, bCollisionInitiated) == 0x000630, "Member 'UHWAbilityCollisionProxy::bCollisionInitiated' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy, OnAttemptAbilityHit) == 0x000648, "Member 'UHWAbilityCollisionProxy::OnAttemptAbilityHit' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy, OnRemoveAbilityHit) == 0x000658, "Member 'UHWAbilityCollisionProxy::OnRemoveAbilityHit' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy, AcceptableCollisionFilter) == 0x000668, "Member 'UHWAbilityCollisionProxy::AcceptableCollisionFilter' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy, bUseAttachedActorCollisionFilterOverride) == 0x000838, "Member 'UHWAbilityCollisionProxy::bUseAttachedActorCollisionFilterOverride' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy, AttachedActorCollisionFilterOverride) == 0x000840, "Member 'UHWAbilityCollisionProxy::AttachedActorCollisionFilterOverride' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy, AttackTask) == 0x000A28, "Member 'UHWAbilityCollisionProxy::AttackTask' has a wrong offset!");

// Class Hemingway.HWAbilityCollisionProxy_PushPull
// 0x02A0 (0x0CE0 - 0x0A40)
class UHWAbilityCollisionProxy_PushPull : public UHWAbilityCollisionProxy
{
public:
	EHWPushPullForceMode                          ForceMode;                                         // 0x0A38(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWForceDirectionBehavior                     ForceDirectionBehavior;                            // 0x0A39(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A3A[0x6];                                      // 0x0A3A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWGameplayTargetDataFilter            OngoingPushPullTagRequirements;                    // 0x0A40(0x01D0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         MovementForceSpeed;                                // 0x0C10(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C14[0x4];                                      // 0x0C14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MovementForceSpeedCurve;                           // 0x0C18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterVelocityAdjustmentFactorPercent;          // 0x0C20(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C24[0x4];                                      // 0x0C24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CharacterVelocityAdjustmentFactorPercentCurve;     // 0x0C28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldAffectDashes;                               // 0x0C30(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRootIgnoreCharacterBlocking;                      // 0x0C31(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C32[0x6];                                      // 0x0C32(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OriginOffset;                                      // 0x0C38(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FixedDirection;                                    // 0x0C50(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldFollowAvatarActor;                          // 0x0C68(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMovementForceActive;                              // 0x0C69(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C6A[0x2];                                      // 0x0C6A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CreatedTimestamp;                                  // 0x0C6C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class AActor>, struct FVector> OverlappingActors;                            // 0x0C70(0x0050)(Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWCharacter_Base>       CharacterOwner;                                    // 0x0CC0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAppendOwningCharacterCollisionToRadius;           // 0x0CC8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC9[0x3];                                      // 0x0CC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InnerCenterRadius;                                 // 0x0CCC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseOriginOffset;                                  // 0x0CD0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD1[0x3];                                      // 0x0CD1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PushDirectionXZeroTolerance;                       // 0x0CD4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PushDirectionXScalefactor;                         // 0x0CD8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CDC[0x4];                                      // 0x0CDC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcCharacterVelocityAdjustmentFactorPercent() const;
	float CalcMovementForceSpeed() const;
	bool CanPushOrPullOverlappingActors() const;
	struct FVector GetPullLocation() const;
	struct FVector GetPushDirection(const class AActor* OverlappedActor) const;
	bool IsUsingAdjustmentFactorCurve() const;
	bool IsUsingSpeedCurve() const;
	bool ShouldPushOrPullActor(const class AActor* Other) const;
	bool ShouldTrackOverlappedActor(const class AActor* Other) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityCollisionProxy_PushPull">();
	}
	static class UHWAbilityCollisionProxy_PushPull* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityCollisionProxy_PushPull>();
	}
};
static_assert(alignof(UHWAbilityCollisionProxy_PushPull) == 0x000010, "Wrong alignment on UHWAbilityCollisionProxy_PushPull");
static_assert(sizeof(UHWAbilityCollisionProxy_PushPull) == 0x000CE0, "Wrong size on UHWAbilityCollisionProxy_PushPull");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, ForceMode) == 0x000A38, "Member 'UHWAbilityCollisionProxy_PushPull::ForceMode' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, ForceDirectionBehavior) == 0x000A39, "Member 'UHWAbilityCollisionProxy_PushPull::ForceDirectionBehavior' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, OngoingPushPullTagRequirements) == 0x000A40, "Member 'UHWAbilityCollisionProxy_PushPull::OngoingPushPullTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, MovementForceSpeed) == 0x000C10, "Member 'UHWAbilityCollisionProxy_PushPull::MovementForceSpeed' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, MovementForceSpeedCurve) == 0x000C18, "Member 'UHWAbilityCollisionProxy_PushPull::MovementForceSpeedCurve' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, CharacterVelocityAdjustmentFactorPercent) == 0x000C20, "Member 'UHWAbilityCollisionProxy_PushPull::CharacterVelocityAdjustmentFactorPercent' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, CharacterVelocityAdjustmentFactorPercentCurve) == 0x000C28, "Member 'UHWAbilityCollisionProxy_PushPull::CharacterVelocityAdjustmentFactorPercentCurve' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, bShouldAffectDashes) == 0x000C30, "Member 'UHWAbilityCollisionProxy_PushPull::bShouldAffectDashes' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, bRootIgnoreCharacterBlocking) == 0x000C31, "Member 'UHWAbilityCollisionProxy_PushPull::bRootIgnoreCharacterBlocking' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, OriginOffset) == 0x000C38, "Member 'UHWAbilityCollisionProxy_PushPull::OriginOffset' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, FixedDirection) == 0x000C50, "Member 'UHWAbilityCollisionProxy_PushPull::FixedDirection' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, bShouldFollowAvatarActor) == 0x000C68, "Member 'UHWAbilityCollisionProxy_PushPull::bShouldFollowAvatarActor' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, bMovementForceActive) == 0x000C69, "Member 'UHWAbilityCollisionProxy_PushPull::bMovementForceActive' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, CreatedTimestamp) == 0x000C6C, "Member 'UHWAbilityCollisionProxy_PushPull::CreatedTimestamp' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, OverlappingActors) == 0x000C70, "Member 'UHWAbilityCollisionProxy_PushPull::OverlappingActors' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, CharacterOwner) == 0x000CC0, "Member 'UHWAbilityCollisionProxy_PushPull::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, bAppendOwningCharacterCollisionToRadius) == 0x000CC8, "Member 'UHWAbilityCollisionProxy_PushPull::bAppendOwningCharacterCollisionToRadius' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, InnerCenterRadius) == 0x000CCC, "Member 'UHWAbilityCollisionProxy_PushPull::InnerCenterRadius' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, bUseOriginOffset) == 0x000CD0, "Member 'UHWAbilityCollisionProxy_PushPull::bUseOriginOffset' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, PushDirectionXZeroTolerance) == 0x000CD4, "Member 'UHWAbilityCollisionProxy_PushPull::PushDirectionXZeroTolerance' has a wrong offset!");
static_assert(offsetof(UHWAbilityCollisionProxy_PushPull, PushDirectionXScalefactor) == 0x000CD8, "Member 'UHWAbilityCollisionProxy_PushPull::PushDirectionXScalefactor' has a wrong offset!");

// Class Hemingway.HWAbilityTaskListenerInterface
// 0x0000 (0x0000 - 0x0000)
class IHWAbilityTaskListenerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTaskListenerInterface">();
	}
	static class IHWAbilityTaskListenerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWAbilityTaskListenerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWAbilityTaskListenerInterface) == 0x000001, "Wrong alignment on IHWAbilityTaskListenerInterface");
static_assert(sizeof(IHWAbilityTaskListenerInterface) == 0x000001, "Wrong size on IHWAbilityTaskListenerInterface");

// Class Hemingway.HWPostProcessComponent
// 0x0010 (0x09C0 - 0x09B0)
class UHWPostProcessComponent final : public UPostProcessComponent
{
public:
	TScriptInterface<class IHWInterface_Skinnable> OwnerInterfaceSkinnable;                          // 0x09B0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PerformSkinUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPostProcessComponent">();
	}
	static class UHWPostProcessComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPostProcessComponent>();
	}
};
static_assert(alignof(UHWPostProcessComponent) == 0x000010, "Wrong alignment on UHWPostProcessComponent");
static_assert(sizeof(UHWPostProcessComponent) == 0x0009C0, "Wrong size on UHWPostProcessComponent");
static_assert(offsetof(UHWPostProcessComponent, OwnerInterfaceSkinnable) == 0x0009B0, "Member 'UHWPostProcessComponent::OwnerInterfaceSkinnable' has a wrong offset!");

// Class Hemingway.HWAbilityTask_Blueprintable
// 0x0008 (0x0088 - 0x0080)
class UHWAbilityTask_Blueprintable final : public UAbilityTask
{
public:
	bool                                          bShouldTick;                                       // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_Blueprintable* ActivateBlueprintAbilityTask(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class UHWAbilityTask_Blueprintable> TaskClass);

	void BP_OnActivated();
	void BP_OnDeactivated(const bool bWasDeactivatedDueToAbilityEnding);
	void BP_TickTask(const float DeltaTime);

	bool BP_IsForRemoteClient() const;
	bool BP_IsLocallyControlled() const;
	bool BP_IsPredictingClient() const;
	class UHWGameplayAbility* GetOwningHWAbility() const;
	class UHWAbilitySystemComponent* GetOwningHWAbilitySystemComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Blueprintable">();
	}
	static class UHWAbilityTask_Blueprintable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Blueprintable>();
	}
};
static_assert(alignof(UHWAbilityTask_Blueprintable) == 0x000008, "Wrong alignment on UHWAbilityTask_Blueprintable");
static_assert(sizeof(UHWAbilityTask_Blueprintable) == 0x000088, "Wrong size on UHWAbilityTask_Blueprintable");
static_assert(offsetof(UHWAbilityTask_Blueprintable, bShouldTick) == 0x000080, "Member 'UHWAbilityTask_Blueprintable::bShouldTick' has a wrong offset!");

// Class Hemingway.HWCharacter_Hercules
// 0x0040 (0x1480 - 0x1440)
class AHWCharacter_Hercules final : public AHWCharacter_Smite_God
{
public:
	TSubclassOf<class AHWSkeletalMeshActor>       BoulderMeshClass;                                  // 0x1440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWSkeletalMeshActor*                   BoulderMeshActor;                                  // 0x1448(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BoulderSocketName;                                 // 0x1450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BoulderMeshScale;                                  // 0x1458(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoulderZOffsetScalarBasedOnMeshScale;              // 0x1470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1474[0xC];                                     // 0x1474(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ToggleBoulderMeshVisibility(const bool bVisible);

	struct FVector GetBoulderMeshScale() const;
	class FName GetBoulderSocketName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Hercules">();
	}
	static class AHWCharacter_Hercules* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Hercules>();
	}
};
static_assert(alignof(AHWCharacter_Hercules) == 0x000010, "Wrong alignment on AHWCharacter_Hercules");
static_assert(sizeof(AHWCharacter_Hercules) == 0x001480, "Wrong size on AHWCharacter_Hercules");
static_assert(offsetof(AHWCharacter_Hercules, BoulderMeshClass) == 0x001440, "Member 'AHWCharacter_Hercules::BoulderMeshClass' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Hercules, BoulderMeshActor) == 0x001448, "Member 'AHWCharacter_Hercules::BoulderMeshActor' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Hercules, BoulderSocketName) == 0x001450, "Member 'AHWCharacter_Hercules::BoulderSocketName' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Hercules, BoulderMeshScale) == 0x001458, "Member 'AHWCharacter_Hercules::BoulderMeshScale' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Hercules, BoulderZOffsetScalarBasedOnMeshScale) == 0x001470, "Member 'AHWCharacter_Hercules::BoulderZOffsetScalarBasedOnMeshScale' has a wrong offset!");

// Class Hemingway.HWAbilityTask_GameplayLevitate
// 0x00E8 (0x0168 - 0x0080)
class UHWAbilityTask_GameplayLevitate final : public UAbilityTask
{
public:
	bool                                          bEndLevitationOnAbilityEnd;                        // 0x0080(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndLevitationOnTaskEnd;                           // 0x0081(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWAbilityTask_GameplayLevitate* AbilityTask, class UHWGameplayLevitate* LevitationInstance)> OnLevitationStartedDelegate; // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilityTask_GameplayLevitate* AbilityTask, class UHWGameplayLevitate* LevitationInstance)> OnAscentStartedDelegate; // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilityTask_GameplayLevitate* AbilityTask, class UHWGameplayLevitate* LevitationInstance)> OnAscentEndedDelegate; // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilityTask_GameplayLevitate* AbilityTask, class UHWGameplayLevitate* LevitationInstance)> OnHoverStartedDelegate; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilityTask_GameplayLevitate* AbilityTask, class UHWGameplayLevitate* LevitationInstance)> OnHoverEndedDelegate; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilityTask_GameplayLevitate* AbilityTask, class UHWGameplayLevitate* LevitationInstance)> OnDescentStartedDelegate; // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilityTask_GameplayLevitate* AbilityTask, class UHWGameplayLevitate* LevitationInstance)> OnDescentEndedDelegate; // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilityTask_GameplayLevitate* AbilityTask, class UHWGameplayLevitate* LevitationInstance)> OnLevitationEndedDelegate; // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilityTask_GameplayLevitate* AbilityTask, class UHWGameplayLevitate* LevitationInstance)> OnLevitationCleansedDelegate; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UHWGameplayLevitate*>            LevitationInstances;                               // 0x0118(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayLevitate>        LevitationClass;                                   // 0x0128(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayAbility*                       LevitationInstigatingAbility;                      // 0x0130(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacter_Base*                      LevitationInstigator;                              // 0x0138(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacter_Base*                      LevitationSource;                                  // 0x0140(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHWCharacter_Base*>              LevitationTargets;                                 // 0x0148(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitGameplayEffectRemoved* WaitForCleanseTask;                                // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UHWAbilityTask_GameplayLevitate* PerformGameplayLevitateOnTarget(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class UHWGameplayLevitate> Levitation, class AHWCharacter_Base* LevitationSource_0, class AHWCharacter_Base* LevitationTarget);

	void OnAscentEnded(class UHWGameplayLevitate* LevitationInstance);
	void OnAscentStarted(class UHWGameplayLevitate* LevitationInstance);
	void OnDescentEnded(class UHWGameplayLevitate* LevitationInstance);
	void OnDescentStarted(class UHWGameplayLevitate* LevitationInstance);
	void OnHoverEnded(class UHWGameplayLevitate* LevitationInstance);
	void OnHoverStarted(class UHWGameplayLevitate* LevitationInstance);
	void OnLevitateCleansed(const struct FGameplayEffectRemovalInfo& GameplayEffectRemovalInfo);
	void OnLevitationEnded(class UHWGameplayLevitate* Levitation, const EHWEndLevitationReason EndLevitationReason);
	void OnLevitationStarted(class UHWGameplayLevitate* LevitationInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_GameplayLevitate">();
	}
	static class UHWAbilityTask_GameplayLevitate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_GameplayLevitate>();
	}
};
static_assert(alignof(UHWAbilityTask_GameplayLevitate) == 0x000008, "Wrong alignment on UHWAbilityTask_GameplayLevitate");
static_assert(sizeof(UHWAbilityTask_GameplayLevitate) == 0x000168, "Wrong size on UHWAbilityTask_GameplayLevitate");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, bEndLevitationOnAbilityEnd) == 0x000080, "Member 'UHWAbilityTask_GameplayLevitate::bEndLevitationOnAbilityEnd' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, bEndLevitationOnTaskEnd) == 0x000081, "Member 'UHWAbilityTask_GameplayLevitate::bEndLevitationOnTaskEnd' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, OnLevitationStartedDelegate) == 0x000088, "Member 'UHWAbilityTask_GameplayLevitate::OnLevitationStartedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, OnAscentStartedDelegate) == 0x000098, "Member 'UHWAbilityTask_GameplayLevitate::OnAscentStartedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, OnAscentEndedDelegate) == 0x0000A8, "Member 'UHWAbilityTask_GameplayLevitate::OnAscentEndedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, OnHoverStartedDelegate) == 0x0000B8, "Member 'UHWAbilityTask_GameplayLevitate::OnHoverStartedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, OnHoverEndedDelegate) == 0x0000C8, "Member 'UHWAbilityTask_GameplayLevitate::OnHoverEndedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, OnDescentStartedDelegate) == 0x0000D8, "Member 'UHWAbilityTask_GameplayLevitate::OnDescentStartedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, OnDescentEndedDelegate) == 0x0000E8, "Member 'UHWAbilityTask_GameplayLevitate::OnDescentEndedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, OnLevitationEndedDelegate) == 0x0000F8, "Member 'UHWAbilityTask_GameplayLevitate::OnLevitationEndedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, OnLevitationCleansedDelegate) == 0x000108, "Member 'UHWAbilityTask_GameplayLevitate::OnLevitationCleansedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, LevitationInstances) == 0x000118, "Member 'UHWAbilityTask_GameplayLevitate::LevitationInstances' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, LevitationClass) == 0x000128, "Member 'UHWAbilityTask_GameplayLevitate::LevitationClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, LevitationInstigatingAbility) == 0x000130, "Member 'UHWAbilityTask_GameplayLevitate::LevitationInstigatingAbility' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, LevitationInstigator) == 0x000138, "Member 'UHWAbilityTask_GameplayLevitate::LevitationInstigator' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, LevitationSource) == 0x000140, "Member 'UHWAbilityTask_GameplayLevitate::LevitationSource' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, LevitationTargets) == 0x000148, "Member 'UHWAbilityTask_GameplayLevitate::LevitationTargets' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayLevitate, WaitForCleanseTask) == 0x000160, "Member 'UHWAbilityTask_GameplayLevitate::WaitForCleanseTask' has a wrong offset!");

// Class Hemingway.HWAbilityTask_WaitCastStyleInput
// 0x0048 (0x00C8 - 0x0080)
class UHWAbilityTask_WaitCastStyleInput final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const float InputHeldTime, const bool bInputReleased)> OnConfirmed; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const float InputHeldTime, const bool bInputReleased)> OnCancelled; // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWGameplayAbility*                     OwningHWAbility;                                   // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityCastStyle                             InputCastStyle;                                    // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitInputPress*            WaitAbilityInputPressTask;                         // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitInputRelease*          WaitAbilityInputReleaseTask;                       // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_WaitCastStyleInput* WaitForAblityCastInput(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const EAbilityCastStyle CastStyle, const bool bPreventAbilityInputFromConfirming);

	void OnAbilityInputPressed(const float TimeWaited);
	void OnAbilityInputReleased(const float TimeHeld);
	void OnAbilitySystemCancelledInputPressed();
	void OnAbilitySystemConfirmedInputPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_WaitCastStyleInput">();
	}
	static class UHWAbilityTask_WaitCastStyleInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_WaitCastStyleInput>();
	}
};
static_assert(alignof(UHWAbilityTask_WaitCastStyleInput) == 0x000008, "Wrong alignment on UHWAbilityTask_WaitCastStyleInput");
static_assert(sizeof(UHWAbilityTask_WaitCastStyleInput) == 0x0000C8, "Wrong size on UHWAbilityTask_WaitCastStyleInput");
static_assert(offsetof(UHWAbilityTask_WaitCastStyleInput, OnConfirmed) == 0x000080, "Member 'UHWAbilityTask_WaitCastStyleInput::OnConfirmed' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitCastStyleInput, OnCancelled) == 0x000090, "Member 'UHWAbilityTask_WaitCastStyleInput::OnCancelled' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitCastStyleInput, OwningHWAbility) == 0x0000A0, "Member 'UHWAbilityTask_WaitCastStyleInput::OwningHWAbility' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitCastStyleInput, InputCastStyle) == 0x0000A8, "Member 'UHWAbilityTask_WaitCastStyleInput::InputCastStyle' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitCastStyleInput, WaitAbilityInputPressTask) == 0x0000B0, "Member 'UHWAbilityTask_WaitCastStyleInput::WaitAbilityInputPressTask' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitCastStyleInput, WaitAbilityInputReleaseTask) == 0x0000B8, "Member 'UHWAbilityTask_WaitCastStyleInput::WaitAbilityInputReleaseTask' has a wrong offset!");

// Class Hemingway.HWActorComponent
// 0x0000 (0x00A0 - 0x00A0)
class UHWActorComponent : public UActorComponent
{
public:
	bool HasAuthority() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWActorComponent">();
	}
	static class UHWActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWActorComponent>();
	}
};
static_assert(alignof(UHWActorComponent) == 0x000008, "Wrong alignment on UHWActorComponent");
static_assert(sizeof(UHWActorComponent) == 0x0000A0, "Wrong size on UHWActorComponent");

// Class Hemingway.HWDeployableDestructionComponent
// 0x0000 (0x00A0 - 0x00A0)
class UHWDeployableDestructionComponent final : public UHWActorComponent
{
public:
	void OnComponentOverlaps(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployableDestructionComponent">();
	}
	static class UHWDeployableDestructionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDeployableDestructionComponent>();
	}
};
static_assert(alignof(UHWDeployableDestructionComponent) == 0x000008, "Wrong alignment on UHWDeployableDestructionComponent");
static_assert(sizeof(UHWDeployableDestructionComponent) == 0x0000A0, "Wrong size on UHWDeployableDestructionComponent");

// Class Hemingway.HWAbilityTask_WaitForTargeterValidationChange
// 0x0020 (0x00A0 - 0x0080)
class UHWAbilityTask_WaitForTargeterValidationChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class AHWTargeter* Targeter, const struct FGameplayTag& AttackID, const bool bIsValid)> OnTargeterValidationChangeDel; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_WaitForTargeterValidationChange* WaitForTargetDataValidationChange(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FGameplayTag& AttackID, const bool bListenOnce);

	void OnTargeterValidationChanged(class AHWTargeter* Targeter, const struct FGameplayTag& InAttackId, const bool bValid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_WaitForTargeterValidationChange">();
	}
	static class UHWAbilityTask_WaitForTargeterValidationChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_WaitForTargeterValidationChange>();
	}
};
static_assert(alignof(UHWAbilityTask_WaitForTargeterValidationChange) == 0x000008, "Wrong alignment on UHWAbilityTask_WaitForTargeterValidationChange");
static_assert(sizeof(UHWAbilityTask_WaitForTargeterValidationChange) == 0x0000A0, "Wrong size on UHWAbilityTask_WaitForTargeterValidationChange");
static_assert(offsetof(UHWAbilityTask_WaitForTargeterValidationChange, OnTargeterValidationChangeDel) == 0x000080, "Member 'UHWAbilityTask_WaitForTargeterValidationChange::OnTargeterValidationChangeDel' has a wrong offset!");

// Class Hemingway.HWSpectatorPawn
// 0x0018 (0x0360 - 0x0348)
class AHWSpectatorPawn final : public ASpectatorPawn
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWDisplayInfoComponent*                DisplayInfoComponent;                              // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWDisplayInfoComponent>    DisplayInfoComponentClass;                         // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSpectatorPawn">();
	}
	static class AHWSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWSpectatorPawn>();
	}
};
static_assert(alignof(AHWSpectatorPawn) == 0x000008, "Wrong alignment on AHWSpectatorPawn");
static_assert(sizeof(AHWSpectatorPawn) == 0x000360, "Wrong size on AHWSpectatorPawn");
static_assert(offsetof(AHWSpectatorPawn, DisplayInfoComponent) == 0x000350, "Member 'AHWSpectatorPawn::DisplayInfoComponent' has a wrong offset!");
static_assert(offsetof(AHWSpectatorPawn, DisplayInfoComponentClass) == 0x000358, "Member 'AHWSpectatorPawn::DisplayInfoComponentClass' has a wrong offset!");

// Class Hemingway.HWGameplayAbility
// 0x03C0 (0x09C0 - 0x0600)
class UHWGameplayAbility : public UGameplayAbility
{
public:
	struct FGameplayTag                           AbilityIdTag;                                      // 0x0600(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, TSubclassOf<class UHWAbilityLevelConfig>> LevelConfigMap;                            // 0x0610(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bShouldCancelAbilityOnLevelUp;                     // 0x0660(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeUseAtLevelZero;                              // 0x0661(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_662[0x6];                                      // 0x0662(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	EHWAbilityActivationPolicy                    ActivationPolicy;                                  // 0x0668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelOtherTargetingAbilitiesOnActivation;        // 0x0669(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseGeneratedActivationBlockedTags;                // 0x066A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66B[0x5];                                      // 0x066B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GeneratedActivationBlockedTags;                    // 0x0670(0x0020)(Edit, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GeneratedActivationBlockedTagsToRemove;            // 0x0690(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UHWAbilityTask_PhasedMontage*           CurrentMontageTask;                                // 0x06B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseGeneratedCancelTags;                            // 0x06B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B9[0x7];                                      // 0x06B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GeneratedAbilityCancelTags;                        // 0x06C0(0x0020)(Edit, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GeneratedAbilityCancelTagsToRemove;                // 0x06E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_700[0x128];                                    // 0x0700(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlockTagsWhileMontageInactive;                     // 0x0828(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_848[0x8];                                      // 0x0848(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWAnimState_BlockActions*>      ActiveBlockActionNotifyStates;                     // 0x0850(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  CachedAITarget;                                    // 0x0860(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseGrantedEffectContext;                    // 0x0868(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_869[0x1];                                      // 0x0869(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsPassiveTargetingEnabled;                        // 0x086A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEnterPassiveTargetingWhenInactive;          // 0x086B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldConfirmTargetingIfConfirmInputIsHeld;       // 0x086C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_86D[0x3];                                      // 0x086D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         TargetsHit;                                        // 0x0870(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            IsChannelingEffectClass;                           // 0x0880(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            IsChannelingEffectHandle;                          // 0x0888(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_890[0x128];                                    // 0x0890(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInterruptsPostFireWhenBuffered;                   // 0x09B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBuffered;                                       // 0x09B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9BA[0x6];                                      // 0x09BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBlockedAbilityTags(const struct FGameplayTagContainer& InTags, class UHWAbilitySystemComponent* OwningAbilitySystem);
	void AddDynamicGameplayTagsToAvatar(const struct FGameplayTagContainer& InTags, class UHWAbilitySystemComponent* OwningAbilitySystem);
	void ApplyGameplayEffectGroupsToSelf(const struct FGameplayTagContainer& EffectGroupTags, const struct FGameplayTag& CurrentAttackId, TArray<struct FActiveGameplayEffectHandle>* OutActiveEffectHandles);
	void ApplyGameplayEffectGroupsToTarget(const struct FGameplayTagContainer& EffectGroupTags, const struct FGameplayTag& CurrentAttackId, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, TArray<struct FActiveGameplayEffectHandle>* OutActiveEffectHandles);
	void ApplyGameplayEffectGroupToSelf(const struct FGameplayTag& EffectGroupTag, const struct FGameplayTag& CurrentAttackId, TArray<struct FActiveGameplayEffectHandle>* OutActiveEffectHandles);
	void ApplyGameplayEffectGroupToTarget(const struct FGameplayTag& EffectGroupTag, const struct FGameplayTag& CurrentAttackId, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, TArray<struct FActiveGameplayEffectHandle>* OutActiveEffectHandles);
	void BP_PostAbilityActivationLogic(const struct FGameplayEventData& EventData);
	void HandleMontagePhaseBehavior(const struct FGameplayTag& PhaseTag, const struct FGameplayEventData& Payload, const EMontagePhaseNotifyEvent PhaseEventType, float Duration);
	void OnCooldownCommited();
	void OnCostsCommited();
	void ProcessAbilitySwappedPersistentState(const class FString& PreviousState);
	void RemoveBlockedAbilityTags(const struct FGameplayTagContainer& InTags, const int32 CountToRemove, class UHWAbilitySystemComponent* OwningAbilitySystem);
	void RemoveDynamicGameplayTagsFromAvatar(const struct FGameplayTagContainer& InTags, const int32 CountToRemove, class UHWAbilitySystemComponent* OwningAbilitySystem);
	int32 RemoveGameplayEffectGroupFromSelf(const struct FGameplayTag& EffectGroupTag, const struct FGameplayTag& AttackID);
	int32 RemoveGameplayEffectGroupsFromSelf(const struct FGameplayTagContainer& EffectGroupTags, const struct FGameplayTag& AttackID);
	int32 RemoveGameplayEffectGroupsFromTarget(const struct FGameplayTagContainer& EffectGroupTags, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, const struct FGameplayTag& AttackID);
	void TriggerAbilityRefire();
	void UpdateIsChannelingStatus();

	bool BP_CheckCost(const struct FGameplayAbilitySpecHandle& Handle, const struct FGameplayAbilityActorInfo& ActorInfo, struct FGameplayTagContainer& OptionalRelevantTags, const bool bCanConsumeCosts) const;
	struct FGameplayTagContainer BP_GetCooldownTags() const;
	void BP_GetCooldownTimeRemainingAndDuration(const struct FGameplayAbilityActorInfo& ActorInfo, float& OutTimeRemaining, float& OutDuration) const;
	bool BP_IsActive() const;
	bool BP_IsForRemoteClient() const;
	bool BP_IsPredictingClient() const;
	struct FGameplayEffectContextHandle BP_MakeEffectContext() const;
	struct FGameplayEffectContextHandle BP_MakeEffectContext_FromGrantedEffect() const;
	bool CanAbilityBeUseAtLevel(const int32 Level) const;
	bool CanAbilityLevelUp(const struct FGameplayAbilitySpecHandle& AbilityHandle, class UHWAbilitySystemComponent* OwningASC) const;
	bool CanConfirmTargeting(const struct FGameplayAbilityTargetDataHandle& TargetingData, const bool bTargetingExpiring) const;
	bool CanHighlightTargets() const;
	bool CanSetAbilityLevelTo(const int32 DesiredLevel, const struct FGameplayAbilitySpecHandle& AbilityHandle, class UHWAbilitySystemComponent* OwningASC) const;
	bool GetAbilityHandleFromAvatarBySlot(const struct FHWInventorySlot& Slot, struct FGameplayAbilitySpecHandle* outHandle) const;
	const struct FGameplayTag GetAbilityId() const;
	float GetAbilityLevelAsFloat() const;
	int32 GetAbilityLevelFromAvatarBySlot(const struct FHWInventorySlot& Slot) const;
	class FString GetAbilitySwappedPersistentState() const;
	struct FGameplayTagContainer GetAllActivationBlockedTags(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayAbilityActorInfo& ActorInfo) const;
	struct FGameplayTagContainer GetAllCancelTags(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayAbilityActorInfo& ActorInfo) const;
	class AActor* GetCachedAITarget() const;
	class AHWCharacter_Base* GetCharacterAvatarFromActorInfo() const;
	struct FHWAbilityFiringInstanceId GetCurrentFiringInstanceId() const;
	const class UHWAbilityLevelConfig* GetCurrentLevelConfig() const;
	class UHWEquipmentComponent* GetEquipmentComponentByClass(TSubclassOf<class UHWEquipmentComponent> ComponentClass, const struct FGameplayTag& ID) const;
	class UHWEquipmentInstance* GetEquipmentInstance() const;
	const class UHWEquipmentItem* GetEquipmentItem() const;
	struct FActiveGameplayEffectHandle GetGrantedByActiveGameplayEffectHandle() const;
	class UHWAbilitySystemComponent* GetHWAbilitySystemComponentFromActorInfo() const;
	class UHWInventoryManagerComponent* GetInventoryManagerFromActorInfo() const;
	const class UHWAbilityLevelConfig* GetLevelConfig(const int32 Level) const;
	float GetMaxLevel() const;
	TArray<class AActor*> GetTargetsHitArray() const;
	bool IsAbilityEnding() const;
	bool IsAChannelingAbility() const;
	bool IsAvatarAIControlled() const;
	bool IsChanneling() const;
	bool IsOwnerNetAuthority() const;
	bool IsPlayingMontage() const;
	bool IsPredictingOrStandaloneClient() const;
	bool IsRunningOnDedicatedServer() const;
	bool IsRunningOnStandalone() const;
	bool ShouldCancelAbilityOnLevelUp() const;
	bool ShouldIncrementFiringInstanceId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayAbility">();
	}
	static class UHWGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayAbility>();
	}
};
static_assert(alignof(UHWGameplayAbility) == 0x000008, "Wrong alignment on UHWGameplayAbility");
static_assert(sizeof(UHWGameplayAbility) == 0x0009C0, "Wrong size on UHWGameplayAbility");
static_assert(offsetof(UHWGameplayAbility, AbilityIdTag) == 0x000600, "Member 'UHWGameplayAbility::AbilityIdTag' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, LevelConfigMap) == 0x000610, "Member 'UHWGameplayAbility::LevelConfigMap' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, bShouldCancelAbilityOnLevelUp) == 0x000660, "Member 'UHWGameplayAbility::bShouldCancelAbilityOnLevelUp' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, bCanBeUseAtLevelZero) == 0x000661, "Member 'UHWGameplayAbility::bCanBeUseAtLevelZero' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, ActivationPolicy) == 0x000668, "Member 'UHWGameplayAbility::ActivationPolicy' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, bCancelOtherTargetingAbilitiesOnActivation) == 0x000669, "Member 'UHWGameplayAbility::bCancelOtherTargetingAbilitiesOnActivation' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, bUseGeneratedActivationBlockedTags) == 0x00066A, "Member 'UHWGameplayAbility::bUseGeneratedActivationBlockedTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, GeneratedActivationBlockedTags) == 0x000670, "Member 'UHWGameplayAbility::GeneratedActivationBlockedTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, GeneratedActivationBlockedTagsToRemove) == 0x000690, "Member 'UHWGameplayAbility::GeneratedActivationBlockedTagsToRemove' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, CurrentMontageTask) == 0x0006B0, "Member 'UHWGameplayAbility::CurrentMontageTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, UseGeneratedCancelTags) == 0x0006B8, "Member 'UHWGameplayAbility::UseGeneratedCancelTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, GeneratedAbilityCancelTags) == 0x0006C0, "Member 'UHWGameplayAbility::GeneratedAbilityCancelTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, GeneratedAbilityCancelTagsToRemove) == 0x0006E0, "Member 'UHWGameplayAbility::GeneratedAbilityCancelTagsToRemove' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, BlockTagsWhileMontageInactive) == 0x000828, "Member 'UHWGameplayAbility::BlockTagsWhileMontageInactive' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, ActiveBlockActionNotifyStates) == 0x000850, "Member 'UHWGameplayAbility::ActiveBlockActionNotifyStates' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, CachedAITarget) == 0x000860, "Member 'UHWGameplayAbility::CachedAITarget' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, bShouldUseGrantedEffectContext) == 0x000868, "Member 'UHWGameplayAbility::bShouldUseGrantedEffectContext' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, bIsPassiveTargetingEnabled) == 0x00086A, "Member 'UHWGameplayAbility::bIsPassiveTargetingEnabled' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, bShouldEnterPassiveTargetingWhenInactive) == 0x00086B, "Member 'UHWGameplayAbility::bShouldEnterPassiveTargetingWhenInactive' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, bShouldConfirmTargetingIfConfirmInputIsHeld) == 0x00086C, "Member 'UHWGameplayAbility::bShouldConfirmTargetingIfConfirmInputIsHeld' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, TargetsHit) == 0x000870, "Member 'UHWGameplayAbility::TargetsHit' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, IsChannelingEffectClass) == 0x000880, "Member 'UHWGameplayAbility::IsChannelingEffectClass' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, IsChannelingEffectHandle) == 0x000888, "Member 'UHWGameplayAbility::IsChannelingEffectHandle' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, bInterruptsPostFireWhenBuffered) == 0x0009B8, "Member 'UHWGameplayAbility::bInterruptsPostFireWhenBuffered' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility, bIsBuffered) == 0x0009B9, "Member 'UHWGameplayAbility::bIsBuffered' has a wrong offset!");

// Class Hemingway.HWCharacter_NPC
// 0x00B0 (0x13F0 - 0x1340)
#pragma pack(push, 0x1)
class alignas(0x10) AHWCharacter_NPC : public AHWCharacter_Base
{
public:
	float                                         MovementComponentTickRateOverride;                 // 0x1338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHibernating;                                    // 0x133C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSpawnCached;                                    // 0x133D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_133E[0x12];                                    // 0x133E(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelevancyDistanceUpdateTime;                       // 0x1350(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RelevancyDistanceUpdateFrequency;                  // 0x1354(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RelevancyDistanceFlatBuffer;                       // 0x1358(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNPCAlwaysNetRelevantToSpectator;                  // 0x135C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_135D[0xB];                                     // 0x135D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRegisterOnBlackboardTargetChangeNotify;           // 0x1368(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1369[0x7];                                     // 0x1369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            AggroEffect;                                       // 0x1370(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AggroEffectLevel;                                  // 0x1378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SquadIndex;                                        // 0x137C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWAISquadManager>       SquadManager;                                      // 0x1380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntersectionBufferDistance;                        // 0x1388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntersectionPushSpeed;                             // 0x138C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowAntiSquadmateIntersection;                   // 0x1390(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1391[0x3];                                     // 0x1391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AHWCharacter_NPC>        PushPartner;                                       // 0x1394(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139C[0x4];                                     // 0x139C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpreadLocation;                                    // 0x13A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasSpreadLocation;                                // 0x13B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanCatchUpToSquad;                                // 0x13B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBehindSquad;                                    // 0x13BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13BB[0x5];                                     // 0x13BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssetRequestKey>               ArenaPortalOutroMontageKeys;                       // 0x13C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldBroadcastDamageEvents;                      // 0x13D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D1[0x3];                                     // 0x13D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeGapBetweenDamageBroadcasts;                    // 0x13D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AccoladeTagForDamageEvent;                         // 0x13D8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E0[0x8];                                     // 0x13E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyTargetAgrroEffect();
	void BP_OnBlackboardTargetChange(const class UBlackboardComponent* Blackboard);
	void ClearSpreadLocation();
	void ClientPlayArenaPortalOutro();
	void EnterHibernation(float tickRate);
	void LeaveHibernation();
	void ProcessPotentialTargetList(TArray<class AHWCharacter_Base*>& PotentialTargetList);
	void SetCanCatchUpToSquad(bool bCanCatchUp);
	void SetIsBehindSquad(bool bIsBehind);
	void SetSpreadLocation(const struct FVector& InSpreadLocation);
	void ToggleAntiSquadmateIntersection(bool bOn);

	bool CanCatchUpToSquad() const;
	bool CanPerformSquadTactics() const;
	bool CanSpreadOut() const;
	struct FVector GetSpreadLocation() const;
	bool HasSpreadLocation() const;
	bool IsBehindSquad() const;
	bool IsHibernating() const;
	bool IsSpawnCached() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_NPC">();
	}
	static class AHWCharacter_NPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_NPC>();
	}
};
#pragma pack(pop)
static_assert(alignof(AHWCharacter_NPC) == 0x000010, "Wrong alignment on AHWCharacter_NPC");
static_assert(sizeof(AHWCharacter_NPC) == 0x0013F0, "Wrong size on AHWCharacter_NPC");
static_assert(offsetof(AHWCharacter_NPC, MovementComponentTickRateOverride) == 0x001338, "Member 'AHWCharacter_NPC::MovementComponentTickRateOverride' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, bIsHibernating) == 0x00133C, "Member 'AHWCharacter_NPC::bIsHibernating' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, bIsSpawnCached) == 0x00133D, "Member 'AHWCharacter_NPC::bIsSpawnCached' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, RelevancyDistanceUpdateTime) == 0x001350, "Member 'AHWCharacter_NPC::RelevancyDistanceUpdateTime' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, RelevancyDistanceUpdateFrequency) == 0x001354, "Member 'AHWCharacter_NPC::RelevancyDistanceUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, RelevancyDistanceFlatBuffer) == 0x001358, "Member 'AHWCharacter_NPC::RelevancyDistanceFlatBuffer' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, bNPCAlwaysNetRelevantToSpectator) == 0x00135C, "Member 'AHWCharacter_NPC::bNPCAlwaysNetRelevantToSpectator' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, bRegisterOnBlackboardTargetChangeNotify) == 0x001368, "Member 'AHWCharacter_NPC::bRegisterOnBlackboardTargetChangeNotify' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, AggroEffect) == 0x001370, "Member 'AHWCharacter_NPC::AggroEffect' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, AggroEffectLevel) == 0x001378, "Member 'AHWCharacter_NPC::AggroEffectLevel' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, SquadIndex) == 0x00137C, "Member 'AHWCharacter_NPC::SquadIndex' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, SquadManager) == 0x001380, "Member 'AHWCharacter_NPC::SquadManager' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, IntersectionBufferDistance) == 0x001388, "Member 'AHWCharacter_NPC::IntersectionBufferDistance' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, IntersectionPushSpeed) == 0x00138C, "Member 'AHWCharacter_NPC::IntersectionPushSpeed' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, bAllowAntiSquadmateIntersection) == 0x001390, "Member 'AHWCharacter_NPC::bAllowAntiSquadmateIntersection' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, PushPartner) == 0x001394, "Member 'AHWCharacter_NPC::PushPartner' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, SpreadLocation) == 0x0013A0, "Member 'AHWCharacter_NPC::SpreadLocation' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, bHasSpreadLocation) == 0x0013B8, "Member 'AHWCharacter_NPC::bHasSpreadLocation' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, bCanCatchUpToSquad) == 0x0013B9, "Member 'AHWCharacter_NPC::bCanCatchUpToSquad' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, bIsBehindSquad) == 0x0013BA, "Member 'AHWCharacter_NPC::bIsBehindSquad' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, ArenaPortalOutroMontageKeys) == 0x0013C0, "Member 'AHWCharacter_NPC::ArenaPortalOutroMontageKeys' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, bShouldBroadcastDamageEvents) == 0x0013D0, "Member 'AHWCharacter_NPC::bShouldBroadcastDamageEvents' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, TimeGapBetweenDamageBroadcasts) == 0x0013D4, "Member 'AHWCharacter_NPC::TimeGapBetweenDamageBroadcasts' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC, AccoladeTagForDamageEvent) == 0x0013D8, "Member 'AHWCharacter_NPC::AccoladeTagForDamageEvent' has a wrong offset!");

// Class Hemingway.HWCharacter_NPC_Minion
// 0x0000 (0x13F0 - 0x13F0)
class AHWCharacter_NPC_Minion final : public AHWCharacter_NPC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_NPC_Minion">();
	}
	static class AHWCharacter_NPC_Minion* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_NPC_Minion>();
	}
};
static_assert(alignof(AHWCharacter_NPC_Minion) == 0x000010, "Wrong alignment on AHWCharacter_NPC_Minion");
static_assert(sizeof(AHWCharacter_NPC_Minion) == 0x0013F0, "Wrong size on AHWCharacter_NPC_Minion");

// Class Hemingway.HWGameplayAbility_Enhanced
// 0x03A0 (0x0D60 - 0x09C0)
class UHWGameplayAbility_Enhanced : public UHWGameplayAbility
{
public:
	float                                         AbilityRepeatActivationLockoutTime;                // 0x09C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbilityInputActivationLockoutTime;                 // 0x09C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityTask_AbilityPhaseTransition*  CurrentPhaseTranstitionTask;                       // 0x09C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilitySystemComponent* AbilitySystem, const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& AbilityTags, const EAbilityFlowPhase PrevPhase, const EAbilityFlowPhase NextPhase)> OnAbilityPhaseChangeStartedDel; // 0x09D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         UseLevelConfigForPhaseTimersFlags;                 // 0x09E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityFlowPhase                             AbilityPhase;                                      // 0x09E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E2[0x6];                                      // 0x09E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAbilityFlowPhase, struct FAbilityFlowPhaseTransitionRule> AbilityPhaseTransitionRules;     // 0x09E8(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A38[0x68];                                     // 0x0A38(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityPhaseBlockTagsContainer        AbilityPhaseBlockTags;                             // 0x0AA0(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EAbilityCommitPolicyType                      CostCommitPolicy;                                  // 0x0B70(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B71[0x7];                                      // 0x0B71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CostCommitAttackId;                                // 0x0B78(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bCostCommitsEveryFire;                             // 0x0B98(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasCommittedCost;                                 // 0x0B99(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityCommitPolicyType                      CooldownWillCommitPolicy;                          // 0x0B9A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9B[0x5];                                      // 0x0B9B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CooldownWillCommitAttackId;                        // 0x0BA0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC0[0x1];                                      // 0x0BC0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EAbilityCommitPolicyType                      CooldownCommitPolicy;                              // 0x0BC1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC2[0x6];                                      // 0x0BC2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CooldownCommitAttackId;                            // 0x0BC8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasCommitedCooldown;                              // 0x0BE8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityCastStyle                             OverrideCastStyle;                                 // 0x0BE9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         SupportedCastStylesFlags;                          // 0x0BEA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasGamepadSpecificCastStyles;                     // 0x0BEB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         GamepadSupportedCastStylesFlags;                   // 0x0BEC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BED[0x3];                                      // 0x0BED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitCastStyleInput*      WaitCastStyleInputTask;                            // 0x0BF0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF8[0x8];                                      // 0x0BF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AHWReticle>>         TargeterReticles;                                  // 0x0C00(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class AHWTargeter>                TargeterClass;                                     // 0x0C10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityTask_WaitTargetData*          TargetingTask;                                     // 0x0C18(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWTargeter*                            CurrentTargeterActor;                              // 0x0C20(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AttacksToTargetDuringTargetingPhase;               // 0x0C28(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableServerSimulatedTargeting;                   // 0x0C48(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAllowedToManuallyCancelTargeting;               // 0x0C49(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4A[0x2];                                      // 0x0C4A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetingConfirmationLockoutTime;                  // 0x0C4C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C50[0xC];                                      // 0x0C50(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAttemptToConfirmTargetingOnTargetingPhaseExpired; // 0x0C5C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityFlowPhase                             CachedMaxHighlightPhase;                           // 0x0C5D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityCastStyle                             CachedMaxHighlightphaseForCastStyle;               // 0x0C5E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C5F[0x1];                                      // 0x0C5F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetingStartedTimeStamp;                         // 0x0C60(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C64[0x4];                                      // 0x0C64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_PhasedMontage*           TargetingMontageTask;                              // 0x0C68(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFiringMontageAsTargetingMontage;               // 0x0C70(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEndAbilityIfTargetingMontageEnds;           // 0x0C71(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttemptToConfirmTargetingOnTargetingMontageEnded; // 0x0C72(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C73[0x1];                                      // 0x0C73(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SectionToPlayOnConfirm;                            // 0x0C74(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SectionToPlayOnCancelled;                          // 0x0C7C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C84[0x4];                                      // 0x0C84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       CurrentFiringTargetData;                           // 0x0C88(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EAbilityFlowPhase                             PhaseToTransitionToOnTargetingConfirmed;           // 0x0CB0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanCancelWhileFiring;                             // 0x0CB1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CB2[0x6];                                      // 0x0CB2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitCancel*                WaitWhileFiringCancelTask;                         // 0x0CB8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CancelWhileFiringRestartDelay;                     // 0x0CC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC4[0x14];                                     // 0x0CC4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AbilityFireShouldResetInhandAttackChain;           // 0x0CD8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD9[0x7];                                      // 0x0CD9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_PhasedMontage*           FiringMontageTask;                                 // 0x0CE0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkinnable;                                        // 0x0CE8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CE9[0x7];                                      // 0x0CE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UHWAbilityTask_FireAttack*> ActiveFireAttackTasks;               // 0x0CF0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bWantsToReviewTargetList;                          // 0x0D40(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D41[0x3];                                      // 0x0D41(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ContinousFireLockoutTime;                          // 0x0D44(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldAllowContinousFire;                         // 0x0D48(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D49[0x7];                                      // 0x0D49(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_ListenForContinousFireState* ContinousFireTask;                             // 0x0D50(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         ChannelingAbilityPhaseFlags;                       // 0x0D58(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D59[0x7];                                      // 0x0D59(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FGameplayTag AbilityPhaseEnumToTag(const EAbilityFlowPhase Phase);
	static EAbilityFlowPhase AbilityPhaseTagToEnum(const struct FGameplayTag& PhaseTag);

	void AttemptAbilityAttackHit(class UHWAbilityTask_FireAttack* AttackTask, const struct FHWAbilityAttackInstance& Attack, const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTagContainer& HitTags);
	void BP_AdjustTargetActorSettings(class AHWTargeter* Targeter);
	void BP_OnPreFirePhaseEnded();
	void BP_OnTargetingCancelled(const struct FGameplayAbilityTargetDataHandle& TargetingData);
	void BP_OnTargetingConfirmed(const struct FGameplayAbilityTargetDataHandle& TargetingData);
	void BP_OnTargetingStarted();
	class AActor* CalcHomingTargetForProjectileAttack(const struct FGameplayTag& AttackID);
	void CancelTargeting();
	void ClearFiringMontageListeners();
	void ClearTargetingMontageListeners();
	void ConfirmTargeting(const bool bEndTargetingTask);
	void CurrentFiringDataUpdated(const struct FGameplayAbilityTargetDataHandle& NewFiringTargetData);
	void EndAbilityEndingPhase();
	void EndTargeting(const bool bWasCancelled);
	const class UHWCharacterItem* FamiliarSpawnParamsOverrideCharacter();
	const class AController* FamiliarSpawnParamsOverrideController();
	const class UHWSkinItem* FamiliarSpawnParamsOverrideSkin();
	void FireCustomAttack(class UHWAbilityTask_FireAttack* AttackTask, const struct FHWAbilityAttackInstance& Attack, const class UHWAbilityAttackSettings_Custom* AttackSettings, const struct FGameplayAbilityTargetDataHandle& AimData, const struct FGameplayAbilityTargetDataHandle& TargetList);
	void ManagePendingAttackTargets(struct FHWHitResultsReference& HitArray, struct FHWHitResultsReference* OutHitArray);
	void ModifyTargetingHighlightListForAttack(const struct FHWAttackTargetingInfo& TargetingInfo, struct FGameplayAbilityTargetDataHandle& TargetListDataHandle);
	void OnAbilityAttackProgressedEvent(const int32 AttackID, const int32 AttackEventID);
	void OnAbilityPhaseChangeStarted(const EAbilityFlowPhase PrevPhase, const EAbilityFlowPhase NextPhase);
	void OnAttackEnded(class UHWAbilityTask_FireAttack* AttackTask, const struct FHWAbilityAttackInstance& Attack);
	void OnAttackFired(class UHWAbilityTask_FireAttack* AttackTask, const struct FHWAbilityAttackInstance& Attack, struct FGameplayAbilityTargetDataHandle& TargetListHandle);
	void OnAttackStarted(class UHWAbilityTask_FireAttack* AttackTask, const struct FHWAbilityAttackInstance& Attack);
	void OnBuildUpPhaseEnded();
	void OnBuildUpPhaseStarted();
	void OnCancelWhileFiringInputPressed();
	void OnCastStyleCancelled(const float TimeElapsed, const bool bInputReleased);
	void OnCastStyleConfirmed(const float TimeElapsed, const bool bInputReleased);
	void OnDeployableBeginSpawning(class AHWDeployable* SpawnedDeployable, const class UHWAbilityAttackSettings_Deployable* DeployableAttackSettings);
	void OnDeployableSpawned(class AHWDeployable* SpawnedDeployable, const class UHWAbilityAttackSettings_Deployable* DeployableAttackSettings);
	void OnFamiliarSpawned(const struct FHWActiveFamiliarHandle& FamiliarHandle, class UHWFamiliarManagerComponent* FamiliarManager, const class UHWAbilityAttackSettings_SpawnFamiliar* FamiliarAttackSettings);
	void OnFirePhaseStarted();
	void OnFiringMontageEnded(const struct FGameplayTag& PhaseTag, const float PhaseDuration, class UHWAbilityTask_PhasedMontage* MontageTask);
	void OnFiringMontagePhaseEnded(const struct FGameplayTag& PhaseTag, const float PhaseDuration, class UHWAbilityTask_PhasedMontage* MontageTask);
	void OnFiringMontagePhaseStarted(const struct FGameplayTag& PhaseTag, const float PhaseDuration, class UHWAbilityTask_PhasedMontage* MontageTask);
	void OnPostFirePhaseStarted();
	void OnPreFirePhaseStarted();
	void OnProjectileBeginSpawning(class AHWProjectile* SpawnedProjectile, const class UHWAbilityAttackSettings_Projectile* ProjectileAttackSettings);
	void OnProjectileSpawned(class AHWProjectile* SpawnedProjectile, const class UHWAbilityAttackSettings_Projectile* ProjectileAttackSettings);
	void OnSpawnedProjectileHitTarget(class AHWProjectile* SpawnedProjectile, class AActor* HitTarget);
	void OnTargeterValidationChanged(const bool bValid);
	void OnTargetingAbilityPhaseTimerEnd();
	void OnTargetingCancelled(const struct FGameplayAbilityTargetDataHandle& TargetingData);
	void OnTargetingConfirmationLockoutExpired();
	void OnTargetingConfirmed(const struct FGameplayAbilityTargetDataHandle& TargetingData);
	void OnTargetingMontageEnded(const struct FGameplayTag& PhaseTag, const float PhaseDuration, class UHWAbilityTask_PhasedMontage* MontageTask);
	void OnTargetingMontagePhaseEnded(const struct FGameplayTag& PhaseTag, const float PhaseDuration, class UHWAbilityTask_PhasedMontage* MontageTask);
	void OnTargetingMontagePhaseStarted(const struct FGameplayTag& PhaseTag, const float PhaseDuration, class UHWAbilityTask_PhasedMontage* MontageTask);
	bool OverrideAbilityPhaseTransition(const EAbilityFlowPhase PrevPhase, const EAbilityFlowPhase NextPhase);
	void PlayFiringMontage(const bool bRestartActiveFiringMontage);
	void PlayTargetingMontage(const bool bRestartActiveTargetingMontage);
	void PreTargetingStarted();
	void RemoveAbilityAttackHit(class UHWAbilityTask_FireAttack* AttackTask, const struct FGameplayTagContainer& HitTags, const struct FGameplayAbilityTargetDataHandle& TargetData);
	void SetAttacksToTargetDuringTargetingPhase(const struct FGameplayTagContainer& TargetAttacks);
	void SetProjectileSpawnCustomData(class UHWAbilityTask_SpawnProjectile* SpawnTask);
	void SetShouldUseLevelConfigForPhaseTiming(const EAbilityFlowPhase Phase, bool bShouldUseLevelConfig);
	void SetupFiringMontageListeners();
	void SetupTargetingMontageListeners();
	void SetupWaitWhileFiringCancelTask();
	bool ShouldAllowCancellationWhileFiring();
	void StartAbilityEndingPhase();
	void StopFiringAbility(bool bIsCanceling);
	void StopTargetingMontage(const bool bWasCancelled);
	void ToggleIgnoreControlRotationSimulated(const bool bShouldIgnoreControlRotation);
	void ToggleIgnoreMovementInputSimulated(const bool bShouldIgnoreMovementInput);
	bool TransitionToAbilityPhase(EAbilityFlowPhase PhaseToEnter, const float TimingError, const bool bForceToClients);
	void TriggerCustomFireAbilityLogic();
	struct FGameplayAbilityTargetDataHandle UpdateFiringAimDataForAttack(const struct FGameplayTag& AttackID);
	void ValidatedAttemptAbilityAttackHit(class UHWAbilityTask_FireAttack* AttackTask, const struct FHWAbilityAttackInstance& Attack, const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTagContainer& HitTags);
	bool WantsToOverrideFamiliarSpawnParams();

	bool CanBeCancelledByAnotherFiringAbility() const;
	bool CanCancelWhileFiring() const;
	bool CanRestartFiring() const;
	bool CanTransitionToPhase(const EAbilityFlowPhase DesiredPhase) const;
	EAbilityFlowPhase GetAbilityPhase() const;
	float GetAbilityPhaseDuration(const EAbilityFlowPhase CurrentAbilityPhase) const;
	float GetAbilityPhaseDurationScale(const EAbilityFlowPhase CurrentAbilityPhase) const;
	class UHWAbilityTask_FireAttack* GetActiveAttackTaskById(const struct FGameplayTag& AttackIdToGet) const;
	float GetCachedFiringAbilityPhaseDuration(const EAbilityFlowPhase Phase) const;
	EAbilityCastStyle GetCastStyle() const;
	struct FGameplayAbilityTargetDataHandle GetCurrentFiringTargetData() const;
	struct FHWMontageInfo GetFiringMontageInfo() const;
	float GetFiringMontagePlayRate() const;
	class FName GetFiringMontageStartingSection() const;
	struct FGameplayTag GetFiringMontageTag() const;
	EAbilityCastStyle GetOverrideCastStyle(const class AActor* Avatar) const;
	struct FHWMontageInfo GetTargetingMontageInfo() const;
	float GetTargetingMontagePlayRate() const;
	class FName GetTargetingMontageStartingSection() const;
	struct FGameplayTag GetTargetingMontageTag() const;
	float GetTargetingTimeElapsed() const;
	bool IsCastStyleSupported(const EAbilityCastStyle CastStyleToCheck, const bool bIsUsingGamepad) const;
	bool IsContinousFireAbility() const;
	bool IsFiring() const;
	bool IsInAbilityPhase(const EAbilityFlowPhase Phase) const;
	bool IsInBuildUp() const;
	bool IsInstantFireAbility() const;
	bool ShouldUseLevelConfigForPhaseTiming(const EAbilityFlowPhase Phase) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayAbility_Enhanced">();
	}
	static class UHWGameplayAbility_Enhanced* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayAbility_Enhanced>();
	}
};
static_assert(alignof(UHWGameplayAbility_Enhanced) == 0x000008, "Wrong alignment on UHWGameplayAbility_Enhanced");
static_assert(sizeof(UHWGameplayAbility_Enhanced) == 0x000D60, "Wrong size on UHWGameplayAbility_Enhanced");
static_assert(offsetof(UHWGameplayAbility_Enhanced, AbilityRepeatActivationLockoutTime) == 0x0009C0, "Member 'UHWGameplayAbility_Enhanced::AbilityRepeatActivationLockoutTime' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, AbilityInputActivationLockoutTime) == 0x0009C4, "Member 'UHWGameplayAbility_Enhanced::AbilityInputActivationLockoutTime' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CurrentPhaseTranstitionTask) == 0x0009C8, "Member 'UHWGameplayAbility_Enhanced::CurrentPhaseTranstitionTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, OnAbilityPhaseChangeStartedDel) == 0x0009D0, "Member 'UHWGameplayAbility_Enhanced::OnAbilityPhaseChangeStartedDel' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, UseLevelConfigForPhaseTimersFlags) == 0x0009E0, "Member 'UHWGameplayAbility_Enhanced::UseLevelConfigForPhaseTimersFlags' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, AbilityPhase) == 0x0009E1, "Member 'UHWGameplayAbility_Enhanced::AbilityPhase' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, AbilityPhaseTransitionRules) == 0x0009E8, "Member 'UHWGameplayAbility_Enhanced::AbilityPhaseTransitionRules' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, AbilityPhaseBlockTags) == 0x000AA0, "Member 'UHWGameplayAbility_Enhanced::AbilityPhaseBlockTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CostCommitPolicy) == 0x000B70, "Member 'UHWGameplayAbility_Enhanced::CostCommitPolicy' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CostCommitAttackId) == 0x000B78, "Member 'UHWGameplayAbility_Enhanced::CostCommitAttackId' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bCostCommitsEveryFire) == 0x000B98, "Member 'UHWGameplayAbility_Enhanced::bCostCommitsEveryFire' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bHasCommittedCost) == 0x000B99, "Member 'UHWGameplayAbility_Enhanced::bHasCommittedCost' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CooldownWillCommitPolicy) == 0x000B9A, "Member 'UHWGameplayAbility_Enhanced::CooldownWillCommitPolicy' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CooldownWillCommitAttackId) == 0x000BA0, "Member 'UHWGameplayAbility_Enhanced::CooldownWillCommitAttackId' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CooldownCommitPolicy) == 0x000BC1, "Member 'UHWGameplayAbility_Enhanced::CooldownCommitPolicy' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CooldownCommitAttackId) == 0x000BC8, "Member 'UHWGameplayAbility_Enhanced::CooldownCommitAttackId' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bHasCommitedCooldown) == 0x000BE8, "Member 'UHWGameplayAbility_Enhanced::bHasCommitedCooldown' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, OverrideCastStyle) == 0x000BE9, "Member 'UHWGameplayAbility_Enhanced::OverrideCastStyle' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, SupportedCastStylesFlags) == 0x000BEA, "Member 'UHWGameplayAbility_Enhanced::SupportedCastStylesFlags' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bHasGamepadSpecificCastStyles) == 0x000BEB, "Member 'UHWGameplayAbility_Enhanced::bHasGamepadSpecificCastStyles' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, GamepadSupportedCastStylesFlags) == 0x000BEC, "Member 'UHWGameplayAbility_Enhanced::GamepadSupportedCastStylesFlags' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, WaitCastStyleInputTask) == 0x000BF0, "Member 'UHWGameplayAbility_Enhanced::WaitCastStyleInputTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, TargeterReticles) == 0x000C00, "Member 'UHWGameplayAbility_Enhanced::TargeterReticles' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, TargeterClass) == 0x000C10, "Member 'UHWGameplayAbility_Enhanced::TargeterClass' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, TargetingTask) == 0x000C18, "Member 'UHWGameplayAbility_Enhanced::TargetingTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CurrentTargeterActor) == 0x000C20, "Member 'UHWGameplayAbility_Enhanced::CurrentTargeterActor' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, AttacksToTargetDuringTargetingPhase) == 0x000C28, "Member 'UHWGameplayAbility_Enhanced::AttacksToTargetDuringTargetingPhase' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bEnableServerSimulatedTargeting) == 0x000C48, "Member 'UHWGameplayAbility_Enhanced::bEnableServerSimulatedTargeting' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bIsAllowedToManuallyCancelTargeting) == 0x000C49, "Member 'UHWGameplayAbility_Enhanced::bIsAllowedToManuallyCancelTargeting' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, TargetingConfirmationLockoutTime) == 0x000C4C, "Member 'UHWGameplayAbility_Enhanced::TargetingConfirmationLockoutTime' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bAttemptToConfirmTargetingOnTargetingPhaseExpired) == 0x000C5C, "Member 'UHWGameplayAbility_Enhanced::bAttemptToConfirmTargetingOnTargetingPhaseExpired' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CachedMaxHighlightPhase) == 0x000C5D, "Member 'UHWGameplayAbility_Enhanced::CachedMaxHighlightPhase' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CachedMaxHighlightphaseForCastStyle) == 0x000C5E, "Member 'UHWGameplayAbility_Enhanced::CachedMaxHighlightphaseForCastStyle' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, TargetingStartedTimeStamp) == 0x000C60, "Member 'UHWGameplayAbility_Enhanced::TargetingStartedTimeStamp' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, TargetingMontageTask) == 0x000C68, "Member 'UHWGameplayAbility_Enhanced::TargetingMontageTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bUseFiringMontageAsTargetingMontage) == 0x000C70, "Member 'UHWGameplayAbility_Enhanced::bUseFiringMontageAsTargetingMontage' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bShouldEndAbilityIfTargetingMontageEnds) == 0x000C71, "Member 'UHWGameplayAbility_Enhanced::bShouldEndAbilityIfTargetingMontageEnds' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bAttemptToConfirmTargetingOnTargetingMontageEnded) == 0x000C72, "Member 'UHWGameplayAbility_Enhanced::bAttemptToConfirmTargetingOnTargetingMontageEnded' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, SectionToPlayOnConfirm) == 0x000C74, "Member 'UHWGameplayAbility_Enhanced::SectionToPlayOnConfirm' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, SectionToPlayOnCancelled) == 0x000C7C, "Member 'UHWGameplayAbility_Enhanced::SectionToPlayOnCancelled' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CurrentFiringTargetData) == 0x000C88, "Member 'UHWGameplayAbility_Enhanced::CurrentFiringTargetData' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, PhaseToTransitionToOnTargetingConfirmed) == 0x000CB0, "Member 'UHWGameplayAbility_Enhanced::PhaseToTransitionToOnTargetingConfirmed' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bCanCancelWhileFiring) == 0x000CB1, "Member 'UHWGameplayAbility_Enhanced::bCanCancelWhileFiring' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, WaitWhileFiringCancelTask) == 0x000CB8, "Member 'UHWGameplayAbility_Enhanced::WaitWhileFiringCancelTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, CancelWhileFiringRestartDelay) == 0x000CC0, "Member 'UHWGameplayAbility_Enhanced::CancelWhileFiringRestartDelay' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, AbilityFireShouldResetInhandAttackChain) == 0x000CD8, "Member 'UHWGameplayAbility_Enhanced::AbilityFireShouldResetInhandAttackChain' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, FiringMontageTask) == 0x000CE0, "Member 'UHWGameplayAbility_Enhanced::FiringMontageTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bSkinnable) == 0x000CE8, "Member 'UHWGameplayAbility_Enhanced::bSkinnable' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, ActiveFireAttackTasks) == 0x000CF0, "Member 'UHWGameplayAbility_Enhanced::ActiveFireAttackTasks' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bWantsToReviewTargetList) == 0x000D40, "Member 'UHWGameplayAbility_Enhanced::bWantsToReviewTargetList' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, ContinousFireLockoutTime) == 0x000D44, "Member 'UHWGameplayAbility_Enhanced::ContinousFireLockoutTime' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, bShouldAllowContinousFire) == 0x000D48, "Member 'UHWGameplayAbility_Enhanced::bShouldAllowContinousFire' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, ContinousFireTask) == 0x000D50, "Member 'UHWGameplayAbility_Enhanced::ContinousFireTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Enhanced, ChannelingAbilityPhaseFlags) == 0x000D58, "Member 'UHWGameplayAbility_Enhanced::ChannelingAbilityPhaseFlags' has a wrong offset!");

// Class Hemingway.HWAbility_Agni_A04
// 0x0008 (0x0D68 - 0x0D60)
class UHWAbility_Agni_A04 final : public UHWGameplayAbility_Enhanced
{
public:
	bool                                          bUserRequestedCancelTargeting;                     // 0x0D60(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D61[0x7];                                      // 0x0D61(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ShouldAllowTransitionBackToTargetingPhase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Agni_A04">();
	}
	static class UHWAbility_Agni_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Agni_A04>();
	}
};
static_assert(alignof(UHWAbility_Agni_A04) == 0x000008, "Wrong alignment on UHWAbility_Agni_A04");
static_assert(sizeof(UHWAbility_Agni_A04) == 0x000D68, "Wrong size on UHWAbility_Agni_A04");
static_assert(offsetof(UHWAbility_Agni_A04, bUserRequestedCancelTargeting) == 0x000D60, "Member 'UHWAbility_Agni_A04::bUserRequestedCancelTargeting' has a wrong offset!");

// Class Hemingway.HWCharacter_CerberusSoul
// 0x0010 (0x1400 - 0x13F0)
class AHWCharacter_CerberusSoul final : public AHWCharacter_NPC
{
public:
	class AHWCharacter_Base*                      SoulOwner;                                         // 0x13E8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentMeshOverrideIndex;                          // 0x13F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F4[0x4];                                     // 0x13F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     SoulMaterial;                                      // 0x13F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_SoulOwner();
	void SetSoulOwner(class AHWCharacter_Base* NewOwner);

	class AHWCharacter_Base* GetSoulOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_CerberusSoul">();
	}
	static class AHWCharacter_CerberusSoul* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_CerberusSoul>();
	}
};
static_assert(alignof(AHWCharacter_CerberusSoul) == 0x000010, "Wrong alignment on AHWCharacter_CerberusSoul");
static_assert(sizeof(AHWCharacter_CerberusSoul) == 0x001400, "Wrong size on AHWCharacter_CerberusSoul");
static_assert(offsetof(AHWCharacter_CerberusSoul, SoulOwner) == 0x0013E8, "Member 'AHWCharacter_CerberusSoul::SoulOwner' has a wrong offset!");
static_assert(offsetof(AHWCharacter_CerberusSoul, CurrentMeshOverrideIndex) == 0x0013F0, "Member 'AHWCharacter_CerberusSoul::CurrentMeshOverrideIndex' has a wrong offset!");
static_assert(offsetof(AHWCharacter_CerberusSoul, SoulMaterial) == 0x0013F8, "Member 'AHWCharacter_CerberusSoul::SoulMaterial' has a wrong offset!");

// Class Hemingway.HWAbility_Aladdin_A03
// 0x0128 (0x0E88 - 0x0D60)
class UHWAbility_Aladdin_A03 final : public UHWGameplayAbility_Enhanced
{
public:
	bool                                          bIsInGenieForm;                                    // 0x0D60(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D61[0x7];                                      // 0x0D61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWWallRunPathInfo                     WallRunPathInfo;                                   // 0x0D68(0x0120)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static float ClampWallRunAngle(const float InitialImpactAngle, const float CurrentHeight, const struct FHWAladdinWallRunPathClampInfo& ClampSettings);
	static struct FHWWallRunPathInfo GenerateWallRunPath(class AHWCharacter_Base* Aladdin, const struct FHitResult& InitialWallHit, const struct FHWAladdinWallRunPathClampInfo& ClampSettings, const bool bDrawDebug, const float DebugPersistTime);

	void OnRep_WallRunPathInfo();
	void SetWallRunPathInfo(struct FHWWallRunPathInfo& PathInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Aladdin_A03">();
	}
	static class UHWAbility_Aladdin_A03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Aladdin_A03>();
	}
};
static_assert(alignof(UHWAbility_Aladdin_A03) == 0x000008, "Wrong alignment on UHWAbility_Aladdin_A03");
static_assert(sizeof(UHWAbility_Aladdin_A03) == 0x000E88, "Wrong size on UHWAbility_Aladdin_A03");
static_assert(offsetof(UHWAbility_Aladdin_A03, bIsInGenieForm) == 0x000D60, "Member 'UHWAbility_Aladdin_A03::bIsInGenieForm' has a wrong offset!");
static_assert(offsetof(UHWAbility_Aladdin_A03, WallRunPathInfo) == 0x000D68, "Member 'UHWAbility_Aladdin_A03::WallRunPathInfo' has a wrong offset!");

// Class Hemingway.HWAttributeSet_Core
// 0x0110 (0x0140 - 0x0030)
class UHWAttributeSet_Core : public UAttributeSet
{
public:
	TArray<struct FHWGameplayCompositeAttribute>  CompositeAttributes;                               // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttributeData                 Health;                                            // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealth;                                         // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealthBase;                                     // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealthItem;                                     // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealthPerTime;                                     // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealthPerTimeBase;                                 // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealthPerTimeItem;                                 // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 KillerXPReward;                                    // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 TeamXPReward;                                      // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 KillerGoldReward;                                  // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 TeamGoldReward;                                    // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MinimapRangePercentModifier;                       // 0x00F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MinimapRangeFlatModifier;                          // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MinimapRevealRangePercentModifier;                 // 0x0118(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MinimapRevealRangeFlatModifier;                    // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	bool                                          bImmuneFromDamage;                                 // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Health(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealthPerTime(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealthPerTimeBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealthPerTimeItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealth(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealthBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealthItem(const struct FGameplayAttributeData& OldValue);

	bool IsDebugImmuneFromDamage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Core">();
	}
	static class UHWAttributeSet_Core* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Core>();
	}
};
static_assert(alignof(UHWAttributeSet_Core) == 0x000008, "Wrong alignment on UHWAttributeSet_Core");
static_assert(sizeof(UHWAttributeSet_Core) == 0x000140, "Wrong size on UHWAttributeSet_Core");
static_assert(offsetof(UHWAttributeSet_Core, CompositeAttributes) == 0x000030, "Member 'UHWAttributeSet_Core::CompositeAttributes' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, Health) == 0x000048, "Member 'UHWAttributeSet_Core::Health' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, MaxHealth) == 0x000058, "Member 'UHWAttributeSet_Core::MaxHealth' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, MaxHealthBase) == 0x000068, "Member 'UHWAttributeSet_Core::MaxHealthBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, MaxHealthItem) == 0x000078, "Member 'UHWAttributeSet_Core::MaxHealthItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, HealthPerTime) == 0x000088, "Member 'UHWAttributeSet_Core::HealthPerTime' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, HealthPerTimeBase) == 0x000098, "Member 'UHWAttributeSet_Core::HealthPerTimeBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, HealthPerTimeItem) == 0x0000A8, "Member 'UHWAttributeSet_Core::HealthPerTimeItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, KillerXPReward) == 0x0000B8, "Member 'UHWAttributeSet_Core::KillerXPReward' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, TeamXPReward) == 0x0000C8, "Member 'UHWAttributeSet_Core::TeamXPReward' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, KillerGoldReward) == 0x0000D8, "Member 'UHWAttributeSet_Core::KillerGoldReward' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, TeamGoldReward) == 0x0000E8, "Member 'UHWAttributeSet_Core::TeamGoldReward' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, MinimapRangePercentModifier) == 0x0000F8, "Member 'UHWAttributeSet_Core::MinimapRangePercentModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, MinimapRangeFlatModifier) == 0x000108, "Member 'UHWAttributeSet_Core::MinimapRangeFlatModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, MinimapRevealRangePercentModifier) == 0x000118, "Member 'UHWAttributeSet_Core::MinimapRevealRangePercentModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, MinimapRevealRangeFlatModifier) == 0x000128, "Member 'UHWAttributeSet_Core::MinimapRevealRangeFlatModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Core, bImmuneFromDamage) == 0x000138, "Member 'UHWAttributeSet_Core::bImmuneFromDamage' has a wrong offset!");

// Class Hemingway.HWAttributeSet_Character_Base
// 0x0650 (0x0790 - 0x0140)
class UHWAttributeSet_Character_Base : public UHWAttributeSet_Core
{
public:
	struct FGameplayAttributeData                 Level;                                             // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SkillPoint;                                        // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 XP;                                                // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 XPPerTime;                                         // 0x0170(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 XPPercentModifier;                                 // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 XPFlatModifier;                                    // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Mana;                                              // 0x01A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxMana;                                           // 0x01B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxManaBase;                                       // 0x01C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxManaItem;                                       // 0x01D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ManaPerTime;                                       // 0x01E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ManaPerTimeBase;                                   // 0x01F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ManaPerTimeItem;                                   // 0x0200(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Gold;                                              // 0x0210(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 GoldPerTime;                                       // 0x0220(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 GroundSpeedForwardPercent;                         // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 GroundSpeedBackpedalPercent;                       // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 GroundSpeedStrafePercent;                          // 0x0250(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 InhandMoveSpeedPenaltyPercent;                     // 0x0260(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BaseMovementSpeedModifierPercent;                  // 0x0270(0x0010)(Net, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MovementSpeedDiminishingReturnPercent;             // 0x0280(0x0010)(Net, NativeAccessSpecifierPublic)
	float                                         MaxInhandMoveSpeedPenalty;                         // 0x0290(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttributeData                 AttackSpeed;                                       // 0x0298(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BaseAttackSpeed;                                   // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HitReactionPercent;                                // 0x02B8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPower;                                     // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPowerBase;                                 // 0x02D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPowerItem;                                 // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPower;                                      // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPowerBase;                                  // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPowerItem;                                  // 0x0318(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 InhandPower;                                       // 0x0328(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 InhandPowerBase;                                   // 0x0338(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 InhandPowerItem;                                   // 0x0348(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPenetrationFlat;                           // 0x0358(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPenetrationFlatBase;                       // 0x0368(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPenetrationFlatItem;                       // 0x0378(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPenetrationFlat;                            // 0x0388(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPenetrationFlatBase;                        // 0x0398(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPenetrationFlatItem;                        // 0x03A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPenetrationPercent;                        // 0x03B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPenetrationPercentBase;                    // 0x03C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPenetrationPercentItem;                    // 0x03D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPenetrationPercent;                         // 0x03E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPenetrationPercentBase;                     // 0x03F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPenetrationPercentItem;                     // 0x0408(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalProtection;                                // 0x0418(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalProtectionBase;                            // 0x0428(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalProtectionItem;                            // 0x0438(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalProtection;                                 // 0x0448(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalProtectionBase;                             // 0x0458(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalProtectionItem;                             // 0x0468(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LifeStealPercent;                                  // 0x0478(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LifeStealPercentBase;                              // 0x0488(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LifeStealPercentItem;                              // 0x0498(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageDealtPercentModifier;                        // 0x04A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageDealtPercentModifierBase;                    // 0x04B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageDealtPercentModifierItem;                    // 0x04C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageDealtFlatModifier;                           // 0x04D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageDealtFlatModifierBase;                       // 0x04E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageDealtFlatModifierItem;                       // 0x04F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageTakenPercentModifier;                        // 0x0508(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageTakenPercentModifierBase;                    // 0x0518(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageTakenPercentModifierItem;                    // 0x0528(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageTakenFlatModifier;                           // 0x0538(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageTakenFlatModifierBase;                       // 0x0548(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageTakenFlatModifierItem;                       // 0x0558(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealingDealtPercentModifier;                       // 0x0568(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealingDealtPercentModifierBase;                   // 0x0578(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealingDealtPercentModifierItem;                   // 0x0588(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealingTakenPercentModifier;                       // 0x0598(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealingTakenPercentModifierBase;                   // 0x05A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealingTakenPercentModifierItem;                   // 0x05B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CritChancePercent;                                 // 0x05C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CritChancePercentBase;                             // 0x05D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CritChancePercentItem;                             // 0x05E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CooldownRate;                                      // 0x05F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CooldownRateBase;                                  // 0x0608(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CooldownRateItem;                                  // 0x0618(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AbilityCostReductionPercent;                       // 0x0628(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AbilityCostReductionPercentBase;                   // 0x0638(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AbilityCostReductionPercentItem;                   // 0x0648(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 InhandProjectileSpeedModifierPercent;              // 0x0658(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 VisionRangePercentModifier;                        // 0x0668(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 VisionRangeFlatModifier;                           // 0x0678(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RevealRangePercentModifier;                        // 0x0688(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RevealRangeFlatModifier;                           // 0x0698(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IntoxicatedOrder;                                  // 0x06A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IntoxicatedInterval;                               // 0x06B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IntoxicatedAccelerationForce;                      // 0x06C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IntoxicatedMinStrafeDuration;                      // 0x06D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IntoxicatedMaxStrafeDuration;                      // 0x06E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IntoxicatedMaxYawRotation;                         // 0x06F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IntoxicatedMaxPitchRotation;                       // 0x0708(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CrowdControlReductionFlat;                         // 0x0718(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CrowdControlReductionFlatBase;                     // 0x0728(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CrowdControlReductionFlatItem;                     // 0x0738(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CrowdControlReductionPercent;                      // 0x0748(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CrowdControlReductionPercentBase;                  // 0x0758(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CrowdControlReductionPercentItem;                  // 0x0768(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CrowdControlReductionPercentFromDR;                // 0x0778(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         MaxCrowdControlReductionPercentage;                // 0x0788(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78C[0x4];                                      // 0x078C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AbilityCostReductionPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_AbilityCostReductionPercentBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_AbilityCostReductionPercentItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_AttackSpeed(const struct FGameplayAttributeData& OldValue);
	void OnRep_BaseAttackSpeed(const struct FGameplayAttributeData& OldValue);
	void OnRep_CooldownRate(const struct FGameplayAttributeData& OldValue);
	void OnRep_CooldownRateBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_CooldownRateItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_CritChancePercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_CritChancePercentBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_CritChancePercentItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_CrowdControlReductionFlat(const struct FGameplayAttributeData& OldValue);
	void OnRep_CrowdControlReductionFlatBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_CrowdControlReductionFlatItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_CrowdControlReductionPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_CrowdControlReductionPercentBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_CrowdControlReductionPercentFromDR(const struct FGameplayAttributeData& OldValue);
	void OnRep_CrowdControlReductionPercentItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageDealtFlatModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageDealtFlatModifierBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageDealtFlatModifierItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageDealtPercentModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageDealtPercentModifierBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageDealtPercentModifierItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageTakenFlatModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageTakenFlatModifierBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageTakenFlatModifierItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageTakenPercentModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageTakenPercentModifierBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_DamageTakenPercentModifierItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_Gold(const struct FGameplayAttributeData& OldValue);
	void OnRep_GoldPerTime(const struct FGameplayAttributeData& OldValue);
	void OnRep_GroundSpeedBackpedalPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_GroundSpeedForwardPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_GroundSpeedStrafePercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealingDealtPercentModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealingDealtPercentModifierBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealingDealtPercentModifierItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealingTakenPercentModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealingTakenPercentModifierBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_HealingTakenPercentModifierItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_InhandMoveSpeedPenaltyPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_InhandPower(const struct FGameplayAttributeData& OldValue);
	void OnRep_InhandPowerBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_InhandPowerItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_InhandProjectileSpeedModifierPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_IntoxicatedAccelerationForce(const struct FGameplayAttributeData& OldValue);
	void OnRep_IntoxicatedInterval(const struct FGameplayAttributeData& OldValue);
	void OnRep_IntoxicatedMaxPitchRotation(const struct FGameplayAttributeData& OldValue);
	void OnRep_IntoxicatedMaxStrafeDuration(const struct FGameplayAttributeData& OldValue);
	void OnRep_IntoxicatedMaxYawRotation(const struct FGameplayAttributeData& OldValue);
	void OnRep_IntoxicatedMinStrafeDuration(const struct FGameplayAttributeData& OldValue);
	void OnRep_IntoxicatedOrder(const struct FGameplayAttributeData& OldValue);
	void OnRep_Level(const struct FGameplayAttributeData& OldValue);
	void OnRep_LifeStealPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_LifeStealPercentBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_LifeStealPercentItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalPenetrationFlat(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalPenetrationFlatBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalPenetrationFlatItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalPenetrationPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalPenetrationPercentBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalPenetrationPercentItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalPower(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalPowerBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalPowerItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalProtection(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalProtectionBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MagicalProtectionItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_Mana(const struct FGameplayAttributeData& OldValue);
	void OnRep_ManaPerTime(const struct FGameplayAttributeData& OldValue);
	void OnRep_ManaPerTimeBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_ManaPerTimeItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxMana(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxManaBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_MaxManaItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalPenetrationFlat(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalPenetrationFlatBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalPenetrationFlatItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalPenetrationPercent(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalPenetrationPercentBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalPenetrationPercentItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalPower(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalPowerBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalPowerItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalProtection(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalProtectionBase(const struct FGameplayAttributeData& OldValue);
	void OnRep_PhysicalProtectionItem(const struct FGameplayAttributeData& OldValue);
	void OnRep_RevealRangeFlatModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_RevealRangePercentModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_SkillPoint(const struct FGameplayAttributeData& OldValue);
	void OnRep_VisionRangeFlatModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_VisionRangePercentModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_XP(const struct FGameplayAttributeData& OldValue);
	void OnRep_XPFlatModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_XPPercentModifier(const struct FGameplayAttributeData& OldValue);
	void OnRep_XPPerTime(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Character_Base">();
	}
	static class UHWAttributeSet_Character_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Character_Base>();
	}
};
static_assert(alignof(UHWAttributeSet_Character_Base) == 0x000008, "Wrong alignment on UHWAttributeSet_Character_Base");
static_assert(sizeof(UHWAttributeSet_Character_Base) == 0x000790, "Wrong size on UHWAttributeSet_Character_Base");
static_assert(offsetof(UHWAttributeSet_Character_Base, Level) == 0x000140, "Member 'UHWAttributeSet_Character_Base::Level' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, SkillPoint) == 0x000150, "Member 'UHWAttributeSet_Character_Base::SkillPoint' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, XP) == 0x000160, "Member 'UHWAttributeSet_Character_Base::XP' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, XPPerTime) == 0x000170, "Member 'UHWAttributeSet_Character_Base::XPPerTime' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, XPPercentModifier) == 0x000180, "Member 'UHWAttributeSet_Character_Base::XPPercentModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, XPFlatModifier) == 0x000190, "Member 'UHWAttributeSet_Character_Base::XPFlatModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, Mana) == 0x0001A0, "Member 'UHWAttributeSet_Character_Base::Mana' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MaxMana) == 0x0001B0, "Member 'UHWAttributeSet_Character_Base::MaxMana' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MaxManaBase) == 0x0001C0, "Member 'UHWAttributeSet_Character_Base::MaxManaBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MaxManaItem) == 0x0001D0, "Member 'UHWAttributeSet_Character_Base::MaxManaItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, ManaPerTime) == 0x0001E0, "Member 'UHWAttributeSet_Character_Base::ManaPerTime' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, ManaPerTimeBase) == 0x0001F0, "Member 'UHWAttributeSet_Character_Base::ManaPerTimeBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, ManaPerTimeItem) == 0x000200, "Member 'UHWAttributeSet_Character_Base::ManaPerTimeItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, Gold) == 0x000210, "Member 'UHWAttributeSet_Character_Base::Gold' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, GoldPerTime) == 0x000220, "Member 'UHWAttributeSet_Character_Base::GoldPerTime' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, GroundSpeedForwardPercent) == 0x000230, "Member 'UHWAttributeSet_Character_Base::GroundSpeedForwardPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, GroundSpeedBackpedalPercent) == 0x000240, "Member 'UHWAttributeSet_Character_Base::GroundSpeedBackpedalPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, GroundSpeedStrafePercent) == 0x000250, "Member 'UHWAttributeSet_Character_Base::GroundSpeedStrafePercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, InhandMoveSpeedPenaltyPercent) == 0x000260, "Member 'UHWAttributeSet_Character_Base::InhandMoveSpeedPenaltyPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, BaseMovementSpeedModifierPercent) == 0x000270, "Member 'UHWAttributeSet_Character_Base::BaseMovementSpeedModifierPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MovementSpeedDiminishingReturnPercent) == 0x000280, "Member 'UHWAttributeSet_Character_Base::MovementSpeedDiminishingReturnPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MaxInhandMoveSpeedPenalty) == 0x000290, "Member 'UHWAttributeSet_Character_Base::MaxInhandMoveSpeedPenalty' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, AttackSpeed) == 0x000298, "Member 'UHWAttributeSet_Character_Base::AttackSpeed' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, BaseAttackSpeed) == 0x0002A8, "Member 'UHWAttributeSet_Character_Base::BaseAttackSpeed' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, HitReactionPercent) == 0x0002B8, "Member 'UHWAttributeSet_Character_Base::HitReactionPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalPower) == 0x0002C8, "Member 'UHWAttributeSet_Character_Base::PhysicalPower' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalPowerBase) == 0x0002D8, "Member 'UHWAttributeSet_Character_Base::PhysicalPowerBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalPowerItem) == 0x0002E8, "Member 'UHWAttributeSet_Character_Base::PhysicalPowerItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalPower) == 0x0002F8, "Member 'UHWAttributeSet_Character_Base::MagicalPower' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalPowerBase) == 0x000308, "Member 'UHWAttributeSet_Character_Base::MagicalPowerBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalPowerItem) == 0x000318, "Member 'UHWAttributeSet_Character_Base::MagicalPowerItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, InhandPower) == 0x000328, "Member 'UHWAttributeSet_Character_Base::InhandPower' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, InhandPowerBase) == 0x000338, "Member 'UHWAttributeSet_Character_Base::InhandPowerBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, InhandPowerItem) == 0x000348, "Member 'UHWAttributeSet_Character_Base::InhandPowerItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalPenetrationFlat) == 0x000358, "Member 'UHWAttributeSet_Character_Base::PhysicalPenetrationFlat' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalPenetrationFlatBase) == 0x000368, "Member 'UHWAttributeSet_Character_Base::PhysicalPenetrationFlatBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalPenetrationFlatItem) == 0x000378, "Member 'UHWAttributeSet_Character_Base::PhysicalPenetrationFlatItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalPenetrationFlat) == 0x000388, "Member 'UHWAttributeSet_Character_Base::MagicalPenetrationFlat' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalPenetrationFlatBase) == 0x000398, "Member 'UHWAttributeSet_Character_Base::MagicalPenetrationFlatBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalPenetrationFlatItem) == 0x0003A8, "Member 'UHWAttributeSet_Character_Base::MagicalPenetrationFlatItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalPenetrationPercent) == 0x0003B8, "Member 'UHWAttributeSet_Character_Base::PhysicalPenetrationPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalPenetrationPercentBase) == 0x0003C8, "Member 'UHWAttributeSet_Character_Base::PhysicalPenetrationPercentBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalPenetrationPercentItem) == 0x0003D8, "Member 'UHWAttributeSet_Character_Base::PhysicalPenetrationPercentItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalPenetrationPercent) == 0x0003E8, "Member 'UHWAttributeSet_Character_Base::MagicalPenetrationPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalPenetrationPercentBase) == 0x0003F8, "Member 'UHWAttributeSet_Character_Base::MagicalPenetrationPercentBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalPenetrationPercentItem) == 0x000408, "Member 'UHWAttributeSet_Character_Base::MagicalPenetrationPercentItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalProtection) == 0x000418, "Member 'UHWAttributeSet_Character_Base::PhysicalProtection' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalProtectionBase) == 0x000428, "Member 'UHWAttributeSet_Character_Base::PhysicalProtectionBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, PhysicalProtectionItem) == 0x000438, "Member 'UHWAttributeSet_Character_Base::PhysicalProtectionItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalProtection) == 0x000448, "Member 'UHWAttributeSet_Character_Base::MagicalProtection' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalProtectionBase) == 0x000458, "Member 'UHWAttributeSet_Character_Base::MagicalProtectionBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MagicalProtectionItem) == 0x000468, "Member 'UHWAttributeSet_Character_Base::MagicalProtectionItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, LifeStealPercent) == 0x000478, "Member 'UHWAttributeSet_Character_Base::LifeStealPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, LifeStealPercentBase) == 0x000488, "Member 'UHWAttributeSet_Character_Base::LifeStealPercentBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, LifeStealPercentItem) == 0x000498, "Member 'UHWAttributeSet_Character_Base::LifeStealPercentItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageDealtPercentModifier) == 0x0004A8, "Member 'UHWAttributeSet_Character_Base::DamageDealtPercentModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageDealtPercentModifierBase) == 0x0004B8, "Member 'UHWAttributeSet_Character_Base::DamageDealtPercentModifierBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageDealtPercentModifierItem) == 0x0004C8, "Member 'UHWAttributeSet_Character_Base::DamageDealtPercentModifierItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageDealtFlatModifier) == 0x0004D8, "Member 'UHWAttributeSet_Character_Base::DamageDealtFlatModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageDealtFlatModifierBase) == 0x0004E8, "Member 'UHWAttributeSet_Character_Base::DamageDealtFlatModifierBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageDealtFlatModifierItem) == 0x0004F8, "Member 'UHWAttributeSet_Character_Base::DamageDealtFlatModifierItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageTakenPercentModifier) == 0x000508, "Member 'UHWAttributeSet_Character_Base::DamageTakenPercentModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageTakenPercentModifierBase) == 0x000518, "Member 'UHWAttributeSet_Character_Base::DamageTakenPercentModifierBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageTakenPercentModifierItem) == 0x000528, "Member 'UHWAttributeSet_Character_Base::DamageTakenPercentModifierItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageTakenFlatModifier) == 0x000538, "Member 'UHWAttributeSet_Character_Base::DamageTakenFlatModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageTakenFlatModifierBase) == 0x000548, "Member 'UHWAttributeSet_Character_Base::DamageTakenFlatModifierBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, DamageTakenFlatModifierItem) == 0x000558, "Member 'UHWAttributeSet_Character_Base::DamageTakenFlatModifierItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, HealingDealtPercentModifier) == 0x000568, "Member 'UHWAttributeSet_Character_Base::HealingDealtPercentModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, HealingDealtPercentModifierBase) == 0x000578, "Member 'UHWAttributeSet_Character_Base::HealingDealtPercentModifierBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, HealingDealtPercentModifierItem) == 0x000588, "Member 'UHWAttributeSet_Character_Base::HealingDealtPercentModifierItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, HealingTakenPercentModifier) == 0x000598, "Member 'UHWAttributeSet_Character_Base::HealingTakenPercentModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, HealingTakenPercentModifierBase) == 0x0005A8, "Member 'UHWAttributeSet_Character_Base::HealingTakenPercentModifierBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, HealingTakenPercentModifierItem) == 0x0005B8, "Member 'UHWAttributeSet_Character_Base::HealingTakenPercentModifierItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CritChancePercent) == 0x0005C8, "Member 'UHWAttributeSet_Character_Base::CritChancePercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CritChancePercentBase) == 0x0005D8, "Member 'UHWAttributeSet_Character_Base::CritChancePercentBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CritChancePercentItem) == 0x0005E8, "Member 'UHWAttributeSet_Character_Base::CritChancePercentItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CooldownRate) == 0x0005F8, "Member 'UHWAttributeSet_Character_Base::CooldownRate' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CooldownRateBase) == 0x000608, "Member 'UHWAttributeSet_Character_Base::CooldownRateBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CooldownRateItem) == 0x000618, "Member 'UHWAttributeSet_Character_Base::CooldownRateItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, AbilityCostReductionPercent) == 0x000628, "Member 'UHWAttributeSet_Character_Base::AbilityCostReductionPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, AbilityCostReductionPercentBase) == 0x000638, "Member 'UHWAttributeSet_Character_Base::AbilityCostReductionPercentBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, AbilityCostReductionPercentItem) == 0x000648, "Member 'UHWAttributeSet_Character_Base::AbilityCostReductionPercentItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, InhandProjectileSpeedModifierPercent) == 0x000658, "Member 'UHWAttributeSet_Character_Base::InhandProjectileSpeedModifierPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, VisionRangePercentModifier) == 0x000668, "Member 'UHWAttributeSet_Character_Base::VisionRangePercentModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, VisionRangeFlatModifier) == 0x000678, "Member 'UHWAttributeSet_Character_Base::VisionRangeFlatModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, RevealRangePercentModifier) == 0x000688, "Member 'UHWAttributeSet_Character_Base::RevealRangePercentModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, RevealRangeFlatModifier) == 0x000698, "Member 'UHWAttributeSet_Character_Base::RevealRangeFlatModifier' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, IntoxicatedOrder) == 0x0006A8, "Member 'UHWAttributeSet_Character_Base::IntoxicatedOrder' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, IntoxicatedInterval) == 0x0006B8, "Member 'UHWAttributeSet_Character_Base::IntoxicatedInterval' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, IntoxicatedAccelerationForce) == 0x0006C8, "Member 'UHWAttributeSet_Character_Base::IntoxicatedAccelerationForce' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, IntoxicatedMinStrafeDuration) == 0x0006D8, "Member 'UHWAttributeSet_Character_Base::IntoxicatedMinStrafeDuration' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, IntoxicatedMaxStrafeDuration) == 0x0006E8, "Member 'UHWAttributeSet_Character_Base::IntoxicatedMaxStrafeDuration' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, IntoxicatedMaxYawRotation) == 0x0006F8, "Member 'UHWAttributeSet_Character_Base::IntoxicatedMaxYawRotation' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, IntoxicatedMaxPitchRotation) == 0x000708, "Member 'UHWAttributeSet_Character_Base::IntoxicatedMaxPitchRotation' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CrowdControlReductionFlat) == 0x000718, "Member 'UHWAttributeSet_Character_Base::CrowdControlReductionFlat' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CrowdControlReductionFlatBase) == 0x000728, "Member 'UHWAttributeSet_Character_Base::CrowdControlReductionFlatBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CrowdControlReductionFlatItem) == 0x000738, "Member 'UHWAttributeSet_Character_Base::CrowdControlReductionFlatItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CrowdControlReductionPercent) == 0x000748, "Member 'UHWAttributeSet_Character_Base::CrowdControlReductionPercent' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CrowdControlReductionPercentBase) == 0x000758, "Member 'UHWAttributeSet_Character_Base::CrowdControlReductionPercentBase' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CrowdControlReductionPercentItem) == 0x000768, "Member 'UHWAttributeSet_Character_Base::CrowdControlReductionPercentItem' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, CrowdControlReductionPercentFromDR) == 0x000778, "Member 'UHWAttributeSet_Character_Base::CrowdControlReductionPercentFromDR' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Character_Base, MaxCrowdControlReductionPercentage) == 0x000788, "Member 'UHWAttributeSet_Character_Base::MaxCrowdControlReductionPercentage' has a wrong offset!");

// Class Hemingway.HWAttributeSet_God
// 0x0018 (0x07A8 - 0x0790)
class UHWAttributeSet_God : public UHWAttributeSet_Character_Base
{
public:
	struct FGameplayAttributeData                 Hysteria;                                          // 0x0790(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         MaxHysteria;                                       // 0x07A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HysteriaThreshold;                                 // 0x07A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRep_Hysteria(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_God">();
	}
	static class UHWAttributeSet_God* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_God>();
	}
};
static_assert(alignof(UHWAttributeSet_God) == 0x000008, "Wrong alignment on UHWAttributeSet_God");
static_assert(sizeof(UHWAttributeSet_God) == 0x0007A8, "Wrong size on UHWAttributeSet_God");
static_assert(offsetof(UHWAttributeSet_God, Hysteria) == 0x000790, "Member 'UHWAttributeSet_God::Hysteria' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_God, MaxHysteria) == 0x0007A0, "Member 'UHWAttributeSet_God::MaxHysteria' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_God, HysteriaThreshold) == 0x0007A4, "Member 'UHWAttributeSet_God::HysteriaThreshold' has a wrong offset!");

// Class Hemingway.HWAttributeSet_Poseidon
// 0x0018 (0x07C0 - 0x07A8)
class UHWAttributeSet_Poseidon final : public UHWAttributeSet_God
{
public:
	struct FGameplayAttributeData                 Tide;                                              // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         MaxTide;                                           // 0x07B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Tide(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Poseidon">();
	}
	static class UHWAttributeSet_Poseidon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Poseidon>();
	}
};
static_assert(alignof(UHWAttributeSet_Poseidon) == 0x000008, "Wrong alignment on UHWAttributeSet_Poseidon");
static_assert(sizeof(UHWAttributeSet_Poseidon) == 0x0007C0, "Wrong size on UHWAttributeSet_Poseidon");
static_assert(offsetof(UHWAttributeSet_Poseidon, Tide) == 0x0007A8, "Member 'UHWAttributeSet_Poseidon::Tide' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Poseidon, MaxTide) == 0x0007B8, "Member 'UHWAttributeSet_Poseidon::MaxTide' has a wrong offset!");

// Class Hemingway.HWAbility_Amaterasu_A02
// 0x00A0 (0x0E00 - 0x0D60)
class UHWAbility_Amaterasu_A02 final : public UHWGameplayAbility_Enhanced
{
public:
	TSubclassOf<class UGameplayEffect>            AmaA02BuffEffectClass;                             // 0x0D60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D68[0x18];                                     // 0x0D68(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RefireDelay;                                       // 0x0D80(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ChargeTargeterGameplayCueTag;                      // 0x0D84(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StoredDamage;                                      // 0x0D8C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StoredDamageModifier;                              // 0x0D90(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StoredDealtDamageModifier;                         // 0x0D94(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalDamageAdjustmentMultiplier;                   // 0x0D98(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MirrorGlowAmount;                                  // 0x0D9C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MirrorMaxGlowRadius;                               // 0x0DA0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA4[0x4];                                      // 0x0DA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DealtDamageTrackedAbilities;                       // 0x0DA8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DamageTakenTrackedAbilities;                       // 0x0DC8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           A03FiringMontage;                                  // 0x0DE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           A04FiringMontage;                                  // 0x0DF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayFiringMontage;                                // 0x0DF8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DF9[0x7];                                      // 0x0DF9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnPawnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void HandleRefireDelayEnd();
	void HandleTagUpdated_AmaA02RefireEnabled(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void OnAdjustBaseDamageToTarget(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseDamageValue);
	void OnRep_PlayFiringMontage();
	void SetPlayFiringMontage(bool bValue);
	void StoreDamage(const struct FDamageEventData& DamageEventData);
	void StoreDealtDamage(const struct FDamageEventData& DamageEventData);
	void TriggerAutoRefire();
	void UpdateStoredDamageAttribute();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Amaterasu_A02">();
	}
	static class UHWAbility_Amaterasu_A02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Amaterasu_A02>();
	}
};
static_assert(alignof(UHWAbility_Amaterasu_A02) == 0x000008, "Wrong alignment on UHWAbility_Amaterasu_A02");
static_assert(sizeof(UHWAbility_Amaterasu_A02) == 0x000E00, "Wrong size on UHWAbility_Amaterasu_A02");
static_assert(offsetof(UHWAbility_Amaterasu_A02, AmaA02BuffEffectClass) == 0x000D60, "Member 'UHWAbility_Amaterasu_A02::AmaA02BuffEffectClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, RefireDelay) == 0x000D80, "Member 'UHWAbility_Amaterasu_A02::RefireDelay' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, ChargeTargeterGameplayCueTag) == 0x000D84, "Member 'UHWAbility_Amaterasu_A02::ChargeTargeterGameplayCueTag' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, StoredDamage) == 0x000D8C, "Member 'UHWAbility_Amaterasu_A02::StoredDamage' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, StoredDamageModifier) == 0x000D90, "Member 'UHWAbility_Amaterasu_A02::StoredDamageModifier' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, StoredDealtDamageModifier) == 0x000D94, "Member 'UHWAbility_Amaterasu_A02::StoredDealtDamageModifier' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, FinalDamageAdjustmentMultiplier) == 0x000D98, "Member 'UHWAbility_Amaterasu_A02::FinalDamageAdjustmentMultiplier' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, MirrorGlowAmount) == 0x000D9C, "Member 'UHWAbility_Amaterasu_A02::MirrorGlowAmount' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, MirrorMaxGlowRadius) == 0x000DA0, "Member 'UHWAbility_Amaterasu_A02::MirrorMaxGlowRadius' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, DealtDamageTrackedAbilities) == 0x000DA8, "Member 'UHWAbility_Amaterasu_A02::DealtDamageTrackedAbilities' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, DamageTakenTrackedAbilities) == 0x000DC8, "Member 'UHWAbility_Amaterasu_A02::DamageTakenTrackedAbilities' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, A03FiringMontage) == 0x000DE8, "Member 'UHWAbility_Amaterasu_A02::A03FiringMontage' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, A04FiringMontage) == 0x000DF0, "Member 'UHWAbility_Amaterasu_A02::A04FiringMontage' has a wrong offset!");
static_assert(offsetof(UHWAbility_Amaterasu_A02, bPlayFiringMontage) == 0x000DF8, "Member 'UHWAbility_Amaterasu_A02::bPlayFiringMontage' has a wrong offset!");

// Class Hemingway.HWChatManager
// 0x0230 (0x04C8 - 0x0298)
class AHWChatManager final : public AInfo
{
public:
	TMulticastInlineDelegate<void(const struct FHWChatEntry& ChatEntry)> OnChatEntryReceived;        // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AHWPlayerController>     LocalPlayerController;                             // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerChatEnabledPC;                            // 0x02B0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerChatEnabledXBox;                          // 0x02B1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerChatEnabledPS5;                           // 0x02B2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerChatEnabledServer;                        // 0x02B3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWPlayerChatMode                             ChatMode;                                          // 0x02B4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FHWSystemMessageConfig> SystemMessageTagToConfig;               // 0x02B8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class APlayerState>, struct FHWChatActionTimestamp> ActionTimestamps;        // 0x0308(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class APlayerState>, struct FTimerHandle> FloodTimerHandles;                 // 0x0358(0x0050)(Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldServerFilterPlayerChat;                     // 0x03A8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SubscriptionKey;                                   // 0x03B0(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EndPointURL;                                       // 0x03C0(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, int32>                    SeverityThresholds;                                // 0x03D0(0x0050)(Config, Protected, NativeAccessSpecifierProtected)
	int32                                         DefaultSeverityThreshold;                          // 0x0420(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWChatFilterHttpRequest               FilterHttpRequest;                                 // 0x0428(0x0048)(Config, Protected, NativeAccessSpecifierProtected)
	float                                         PlayerTextConcatenateTime;                         // 0x0470(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsChatConcatenationEnabled;                       // 0x0474(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_475[0x53];                                     // 0x0475(0x0053)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SendPlayerChatEntry(const struct FHWChatEntry& ChatEntry);
	void UpdatePlayerChatMode();

	bool IsPlayerChatEnabled() const;
	void MulticastSendChatEntry(const struct FHWChatEntry& ChatEntry) const;
	void SendChatEntry(const struct FHWChatEntry& ChatEntry) const;
	void SendSystemMessageEntry(const struct FGameplayTag& MessageTag, const struct FGenericTeamId& ExclusiveToTeam, const struct FGuid& ExclusiveToPlayer, const class UObject* MessageContext) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWChatManager">();
	}
	static class AHWChatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWChatManager>();
	}
};
static_assert(alignof(AHWChatManager) == 0x000008, "Wrong alignment on AHWChatManager");
static_assert(sizeof(AHWChatManager) == 0x0004C8, "Wrong size on AHWChatManager");
static_assert(offsetof(AHWChatManager, OnChatEntryReceived) == 0x000298, "Member 'AHWChatManager::OnChatEntryReceived' has a wrong offset!");
static_assert(offsetof(AHWChatManager, LocalPlayerController) == 0x0002A8, "Member 'AHWChatManager::LocalPlayerController' has a wrong offset!");
static_assert(offsetof(AHWChatManager, bIsPlayerChatEnabledPC) == 0x0002B0, "Member 'AHWChatManager::bIsPlayerChatEnabledPC' has a wrong offset!");
static_assert(offsetof(AHWChatManager, bIsPlayerChatEnabledXBox) == 0x0002B1, "Member 'AHWChatManager::bIsPlayerChatEnabledXBox' has a wrong offset!");
static_assert(offsetof(AHWChatManager, bIsPlayerChatEnabledPS5) == 0x0002B2, "Member 'AHWChatManager::bIsPlayerChatEnabledPS5' has a wrong offset!");
static_assert(offsetof(AHWChatManager, bIsPlayerChatEnabledServer) == 0x0002B3, "Member 'AHWChatManager::bIsPlayerChatEnabledServer' has a wrong offset!");
static_assert(offsetof(AHWChatManager, ChatMode) == 0x0002B4, "Member 'AHWChatManager::ChatMode' has a wrong offset!");
static_assert(offsetof(AHWChatManager, SystemMessageTagToConfig) == 0x0002B8, "Member 'AHWChatManager::SystemMessageTagToConfig' has a wrong offset!");
static_assert(offsetof(AHWChatManager, ActionTimestamps) == 0x000308, "Member 'AHWChatManager::ActionTimestamps' has a wrong offset!");
static_assert(offsetof(AHWChatManager, FloodTimerHandles) == 0x000358, "Member 'AHWChatManager::FloodTimerHandles' has a wrong offset!");
static_assert(offsetof(AHWChatManager, bShouldServerFilterPlayerChat) == 0x0003A8, "Member 'AHWChatManager::bShouldServerFilterPlayerChat' has a wrong offset!");
static_assert(offsetof(AHWChatManager, SubscriptionKey) == 0x0003B0, "Member 'AHWChatManager::SubscriptionKey' has a wrong offset!");
static_assert(offsetof(AHWChatManager, EndPointURL) == 0x0003C0, "Member 'AHWChatManager::EndPointURL' has a wrong offset!");
static_assert(offsetof(AHWChatManager, SeverityThresholds) == 0x0003D0, "Member 'AHWChatManager::SeverityThresholds' has a wrong offset!");
static_assert(offsetof(AHWChatManager, DefaultSeverityThreshold) == 0x000420, "Member 'AHWChatManager::DefaultSeverityThreshold' has a wrong offset!");
static_assert(offsetof(AHWChatManager, FilterHttpRequest) == 0x000428, "Member 'AHWChatManager::FilterHttpRequest' has a wrong offset!");
static_assert(offsetof(AHWChatManager, PlayerTextConcatenateTime) == 0x000470, "Member 'AHWChatManager::PlayerTextConcatenateTime' has a wrong offset!");
static_assert(offsetof(AHWChatManager, bIsChatConcatenationEnabled) == 0x000474, "Member 'AHWChatManager::bIsChatConcatenationEnabled' has a wrong offset!");

// Class Hemingway.HWAbility_Ares_A01
// 0x0000 (0x0D60 - 0x0D60)
class UHWAbility_Ares_A01 final : public UHWGameplayAbility_Enhanced
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Ares_A01">();
	}
	static class UHWAbility_Ares_A01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Ares_A01>();
	}
};
static_assert(alignof(UHWAbility_Ares_A01) == 0x000008, "Wrong alignment on UHWAbility_Ares_A01");
static_assert(sizeof(UHWAbility_Ares_A01) == 0x000D60, "Wrong size on UHWAbility_Ares_A01");

// Class Hemingway.HWAbility_Bari_A02
// 0x0008 (0x0D68 - 0x0D60)
class UHWAbility_Bari_A02 final : public UHWGameplayAbility_Enhanced
{
public:
	uint8                                         Pad_D60[0x8];                                      // 0x0D60(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Bari_A02">();
	}
	static class UHWAbility_Bari_A02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Bari_A02>();
	}
};
static_assert(alignof(UHWAbility_Bari_A02) == 0x000008, "Wrong alignment on UHWAbility_Bari_A02");
static_assert(sizeof(UHWAbility_Bari_A02) == 0x000D68, "Wrong size on UHWAbility_Bari_A02");

// Class Hemingway.HWDisplayInfoData
// 0x0000 (0x0028 - 0x0028)
class UHWDisplayInfoData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDisplayInfoData">();
	}
	static class UHWDisplayInfoData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDisplayInfoData>();
	}
};
static_assert(alignof(UHWDisplayInfoData) == 0x000008, "Wrong alignment on UHWDisplayInfoData");
static_assert(sizeof(UHWDisplayInfoData) == 0x000028, "Wrong size on UHWDisplayInfoData");

// Class Hemingway.HWInteractDisplayInfoData
// 0x0018 (0x0040 - 0x0028)
class UHWInteractDisplayInfoData final : public UHWDisplayInfoData
{
public:
	struct FVector                                Offset;                                            // 0x0028(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInteractDisplayInfoData">();
	}
	static class UHWInteractDisplayInfoData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInteractDisplayInfoData>();
	}
};
static_assert(alignof(UHWInteractDisplayInfoData) == 0x000008, "Wrong alignment on UHWInteractDisplayInfoData");
static_assert(sizeof(UHWInteractDisplayInfoData) == 0x000040, "Wrong size on UHWInteractDisplayInfoData");
static_assert(offsetof(UHWInteractDisplayInfoData, Offset) == 0x000028, "Member 'UHWInteractDisplayInfoData::Offset' has a wrong offset!");

// Class Hemingway.HWAbility_Bari_B01
// 0x0008 (0x0D68 - 0x0D60)
class UHWAbility_Bari_B01 final : public UHWGameplayAbility_Enhanced
{
public:
	class AHWDeployable*                          SpawnedBellDeployable;                             // 0x0D60(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Bari_B01">();
	}
	static class UHWAbility_Bari_B01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Bari_B01>();
	}
};
static_assert(alignof(UHWAbility_Bari_B01) == 0x000008, "Wrong alignment on UHWAbility_Bari_B01");
static_assert(sizeof(UHWAbility_Bari_B01) == 0x000D68, "Wrong size on UHWAbility_Bari_B01");
static_assert(offsetof(UHWAbility_Bari_B01, SpawnedBellDeployable) == 0x000D60, "Member 'UHWAbility_Bari_B01::SpawnedBellDeployable' has a wrong offset!");

// Class Hemingway.HWDeployable
// 0x0230 (0x04C8 - 0x0298)
class AHWDeployable : public AActor
{
public:
	uint8                                         Pad_298[0x30];                                     // 0x0298(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bActivateAbilityOnSpawn;                           // 0x02C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnOwnerReplicated;                                 // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHWDeployableRepositionData            RepositionData;                                    // 0x02E0(0x0038)(BlueprintVisible, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeployableLevel;                                   // 0x0318(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultDeployableLevel;                            // 0x031C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDefaultDeployableLevel;                        // 0x0320(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0xF];                                      // 0x0321(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySystem_Deployable*            AbilitySystem;                                     // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilitySet*                          AbilitySet;                                        // 0x0338(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacterAbilitySystemActor*         OriginalInstigatorAbilitySystem;                   // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x40];                                     // 0x0348(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    AdditionalEffectToCacheSpecs;                      // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UHWAbilityCollisionProxy*               AbilityCollisionProxy;                             // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x03A0(0x0018)(NativeAccessSpecifierPublic)
	EAbilityFlowPhase                             CurrentVisualPhase;                                // 0x03B8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeferredVisualUpdateTillBeginPlay;                // 0x03B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BA[0x2];                                      // 0x03BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeAfterDeath;                                    // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDead;                                           // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DeathTimer;                                        // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyOnInstigatorDeath;                         // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyOnOwnerDeath;                              // 0x03D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D2[0x76];                                     // 0x03D2(0x0076)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DeployableAssetTags;                               // 0x0448(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DeployableId;                                      // 0x0468(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DeployableType;                                    // 0x0470(0x0008)(Edit, DisableEditOnInstance, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UHWEquipmentItem>        OriginalEquipmentItem;                             // 0x0478(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxDeployableCount;                                // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementRange;                                     // 0x04A4(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LobGroundTargetLocation;                           // 0x04A8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x4];                                      // 0x04C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRegisterAsGodBotDangerZone;                       // 0x04C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C5[0x3];                                      // 0x04C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateBuildUpVisuals();
	void ActivateDeathVisuals();
	void ActivateFiringVisuals();
	void ActivatePrefireVisuals();
	void BP_PostInitialized();
	void DeactivateBuildUpVisuals();
	void DeactivateFiringVisuals();
	void DeactivatePrefireVisuals();
	void HandleTagUpdated_InstigatorDied(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void HandleTagUpdated_OwnerDied(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void OnRep_CurrentVisualPhase(EAbilityFlowPhase OldPhase);
	void OnRep_IsDead();
	void OnRep_RepositionData(const struct FHWDeployableRepositionData& OldRepositionData);
	void OnRepositionDataReceived();
	void SetDeployableLevel(float Level);
	void SetDeployablePhase(EAbilityFlowPhase Phase);
	void SetSkinnedData();
	void StartDestroy(bool bSkipTimeAfterDeath);

	void CalcHighlightingTargetList(const struct FHWAttackTargetingInfo& TargetingInfo, struct FGameplayAbilityTargetDataHandle& TargetListDataHandle) const;
	class UAbilitySystemComponent* GetAbilitySystemComponent() const;
	class UHWApparelComponent* GetApparelComponent() const;
	const class UHWSkinItem* GetCurrentSkin() const;
	float GetDeployableLevel() const;
	struct FGameplayTag GetDeployableType() const;
	struct FHWAbilityFiringInstanceId GetFiringInstanceId() const;
	class UHWAbilitySystemComponent* GetHWAbilitySystemComponent() const;
	bool IsSkinningReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable">();
	}
	static class AHWDeployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable>();
	}
};
static_assert(alignof(AHWDeployable) == 0x000008, "Wrong alignment on AHWDeployable");
static_assert(sizeof(AHWDeployable) == 0x0004C8, "Wrong size on AHWDeployable");
static_assert(offsetof(AHWDeployable, bActivateAbilityOnSpawn) == 0x0002C8, "Member 'AHWDeployable::bActivateAbilityOnSpawn' has a wrong offset!");
static_assert(offsetof(AHWDeployable, OnOwnerReplicated) == 0x0002D0, "Member 'AHWDeployable::OnOwnerReplicated' has a wrong offset!");
static_assert(offsetof(AHWDeployable, RepositionData) == 0x0002E0, "Member 'AHWDeployable::RepositionData' has a wrong offset!");
static_assert(offsetof(AHWDeployable, DeployableLevel) == 0x000318, "Member 'AHWDeployable::DeployableLevel' has a wrong offset!");
static_assert(offsetof(AHWDeployable, DefaultDeployableLevel) == 0x00031C, "Member 'AHWDeployable::DefaultDeployableLevel' has a wrong offset!");
static_assert(offsetof(AHWDeployable, bUseDefaultDeployableLevel) == 0x000320, "Member 'AHWDeployable::bUseDefaultDeployableLevel' has a wrong offset!");
static_assert(offsetof(AHWDeployable, AbilitySystem) == 0x000330, "Member 'AHWDeployable::AbilitySystem' has a wrong offset!");
static_assert(offsetof(AHWDeployable, AbilitySet) == 0x000338, "Member 'AHWDeployable::AbilitySet' has a wrong offset!");
static_assert(offsetof(AHWDeployable, OriginalInstigatorAbilitySystem) == 0x000340, "Member 'AHWDeployable::OriginalInstigatorAbilitySystem' has a wrong offset!");
static_assert(offsetof(AHWDeployable, AdditionalEffectToCacheSpecs) == 0x000388, "Member 'AHWDeployable::AdditionalEffectToCacheSpecs' has a wrong offset!");
static_assert(offsetof(AHWDeployable, AbilityCollisionProxy) == 0x000398, "Member 'AHWDeployable::AbilityCollisionProxy' has a wrong offset!");
static_assert(offsetof(AHWDeployable, EffectContextHandle) == 0x0003A0, "Member 'AHWDeployable::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(AHWDeployable, CurrentVisualPhase) == 0x0003B8, "Member 'AHWDeployable::CurrentVisualPhase' has a wrong offset!");
static_assert(offsetof(AHWDeployable, bDeferredVisualUpdateTillBeginPlay) == 0x0003B9, "Member 'AHWDeployable::bDeferredVisualUpdateTillBeginPlay' has a wrong offset!");
static_assert(offsetof(AHWDeployable, TimeAfterDeath) == 0x0003BC, "Member 'AHWDeployable::TimeAfterDeath' has a wrong offset!");
static_assert(offsetof(AHWDeployable, bIsDead) == 0x0003C0, "Member 'AHWDeployable::bIsDead' has a wrong offset!");
static_assert(offsetof(AHWDeployable, DeathTimer) == 0x0003C8, "Member 'AHWDeployable::DeathTimer' has a wrong offset!");
static_assert(offsetof(AHWDeployable, bDestroyOnInstigatorDeath) == 0x0003D0, "Member 'AHWDeployable::bDestroyOnInstigatorDeath' has a wrong offset!");
static_assert(offsetof(AHWDeployable, bDestroyOnOwnerDeath) == 0x0003D1, "Member 'AHWDeployable::bDestroyOnOwnerDeath' has a wrong offset!");
static_assert(offsetof(AHWDeployable, DeployableAssetTags) == 0x000448, "Member 'AHWDeployable::DeployableAssetTags' has a wrong offset!");
static_assert(offsetof(AHWDeployable, DeployableId) == 0x000468, "Member 'AHWDeployable::DeployableId' has a wrong offset!");
static_assert(offsetof(AHWDeployable, DeployableType) == 0x000470, "Member 'AHWDeployable::DeployableType' has a wrong offset!");
static_assert(offsetof(AHWDeployable, OriginalEquipmentItem) == 0x000478, "Member 'AHWDeployable::OriginalEquipmentItem' has a wrong offset!");
static_assert(offsetof(AHWDeployable, MaxDeployableCount) == 0x0004A0, "Member 'AHWDeployable::MaxDeployableCount' has a wrong offset!");
static_assert(offsetof(AHWDeployable, MovementRange) == 0x0004A4, "Member 'AHWDeployable::MovementRange' has a wrong offset!");
static_assert(offsetof(AHWDeployable, LobGroundTargetLocation) == 0x0004A8, "Member 'AHWDeployable::LobGroundTargetLocation' has a wrong offset!");
static_assert(offsetof(AHWDeployable, bRegisterAsGodBotDangerZone) == 0x0004C4, "Member 'AHWDeployable::bRegisterAsGodBotDangerZone' has a wrong offset!");

// Class Hemingway.HWDeployable_Sol_A01
// 0x0008 (0x04D0 - 0x04C8)
class AHWDeployable_Sol_A01 final : public AHWDeployable
{
public:
	float                                         SolSphereAttackMaxRadiusMultiplier;                // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SolHeatAlpha;                                      // 0x04CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BP_UpdateHeatRingVFXRadius();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Sol_A01">();
	}
	static class AHWDeployable_Sol_A01* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Sol_A01>();
	}
};
static_assert(alignof(AHWDeployable_Sol_A01) == 0x000008, "Wrong alignment on AHWDeployable_Sol_A01");
static_assert(sizeof(AHWDeployable_Sol_A01) == 0x0004D0, "Wrong size on AHWDeployable_Sol_A01");
static_assert(offsetof(AHWDeployable_Sol_A01, SolSphereAttackMaxRadiusMultiplier) == 0x0004C8, "Member 'AHWDeployable_Sol_A01::SolSphereAttackMaxRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Sol_A01, SolHeatAlpha) == 0x0004CC, "Member 'AHWDeployable_Sol_A01::SolHeatAlpha' has a wrong offset!");

// Class Hemingway.HWAbility_Passive
// 0x0010 (0x0D70 - 0x0D60)
class UHWAbility_Passive : public UHWGameplayAbility_Enhanced
{
public:
	bool                                          bDisablePassiveWhileDead;                          // 0x0D60(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D61[0x7];                                      // 0x0D61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_WaitGameplayEffectRemoved* WaitCooldownRemoved;                               // 0x0D68(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CleanupListeners();
	void OnInternalCooldownRemoved(const struct FGameplayEffectRemovalInfo& GameplayEffectRemovalInfo);
	void SetupListeners();

	bool IsInternalCooldownActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Passive">();
	}
	static class UHWAbility_Passive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Passive>();
	}
};
static_assert(alignof(UHWAbility_Passive) == 0x000008, "Wrong alignment on UHWAbility_Passive");
static_assert(sizeof(UHWAbility_Passive) == 0x000D70, "Wrong size on UHWAbility_Passive");
static_assert(offsetof(UHWAbility_Passive, bDisablePassiveWhileDead) == 0x000D60, "Member 'UHWAbility_Passive::bDisablePassiveWhileDead' has a wrong offset!");
static_assert(offsetof(UHWAbility_Passive, WaitCooldownRemoved) == 0x000D68, "Member 'UHWAbility_Passive::WaitCooldownRemoved' has a wrong offset!");

// Class Hemingway.HWDeployable_Buff
// 0x0030 (0x04F8 - 0x04C8)
class AHWDeployable_Buff final : public AHWDeployable
{
public:
	class UCapsuleComponent*                      CollisionComponent;                                // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BuffEffectToGive;                                  // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 BuffMesh;                                          // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              BuffActiveMIC;                                     // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              BuffInactiveMIC;                                   // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               BuffFX;                                            // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool ApplyBuffToTarget(class AHWCharacter_Base* Target);

	bool CanApplyBuffToTarget(const class AHWCharacter_Base* Target) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Buff">();
	}
	static class AHWDeployable_Buff* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Buff>();
	}
};
static_assert(alignof(AHWDeployable_Buff) == 0x000008, "Wrong alignment on AHWDeployable_Buff");
static_assert(sizeof(AHWDeployable_Buff) == 0x0004F8, "Wrong size on AHWDeployable_Buff");
static_assert(offsetof(AHWDeployable_Buff, CollisionComponent) == 0x0004C8, "Member 'AHWDeployable_Buff::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Buff, BuffEffectToGive) == 0x0004D0, "Member 'AHWDeployable_Buff::BuffEffectToGive' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Buff, BuffMesh) == 0x0004D8, "Member 'AHWDeployable_Buff::BuffMesh' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Buff, BuffActiveMIC) == 0x0004E0, "Member 'AHWDeployable_Buff::BuffActiveMIC' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Buff, BuffInactiveMIC) == 0x0004E8, "Member 'AHWDeployable_Buff::BuffInactiveMIC' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Buff, BuffFX) == 0x0004F0, "Member 'AHWDeployable_Buff::BuffFX' has a wrong offset!");

// Class Hemingway.HWAbility_Cabrakan_EmpoweredA01_Listener
// 0x0000 (0x0D70 - 0x0D70)
class UHWAbility_Cabrakan_EmpoweredA01_Listener final : public UHWAbility_Passive
{
public:
	struct FGameplayEffectContextHandle ConfigureCustomEnhancedA01Context();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Cabrakan_EmpoweredA01_Listener">();
	}
	static class UHWAbility_Cabrakan_EmpoweredA01_Listener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Cabrakan_EmpoweredA01_Listener>();
	}
};
static_assert(alignof(UHWAbility_Cabrakan_EmpoweredA01_Listener) == 0x000008, "Wrong alignment on UHWAbility_Cabrakan_EmpoweredA01_Listener");
static_assert(sizeof(UHWAbility_Cabrakan_EmpoweredA01_Listener) == 0x000D70, "Wrong size on UHWAbility_Cabrakan_EmpoweredA01_Listener");

// Class Hemingway.HWAbility_Leap
// 0x0028 (0x0D88 - 0x0D60)
class UHWAbility_Leap : public UHWGameplayAbility_Enhanced
{
public:
	TSubclassOf<class UHWGameplayTween>           LeapTweenClass;                                    // 0x0D60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           LeapAttackId;                                      // 0x0D68(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHWActor_SpecialFX>         LeapLandFXActorClass;                              // 0x0D70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManuallyActivateLeap;                             // 0x0D78(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D79[0x3];                                      // 0x0D79(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeapLandFXDuration;                                // 0x0D7C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayAnimMontageOnLeapStart;                       // 0x0D80(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeapActivated;                                    // 0x0D81(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D82[0x6];                                      // 0x0D82(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateLeap();
	void OnLeapEnded(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget, const EHWEndTweenReason EndTweenReason);
	void OnLeapStarted(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Leap">();
	}
	static class UHWAbility_Leap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Leap>();
	}
};
static_assert(alignof(UHWAbility_Leap) == 0x000008, "Wrong alignment on UHWAbility_Leap");
static_assert(sizeof(UHWAbility_Leap) == 0x000D88, "Wrong size on UHWAbility_Leap");
static_assert(offsetof(UHWAbility_Leap, LeapTweenClass) == 0x000D60, "Member 'UHWAbility_Leap::LeapTweenClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_Leap, LeapAttackId) == 0x000D68, "Member 'UHWAbility_Leap::LeapAttackId' has a wrong offset!");
static_assert(offsetof(UHWAbility_Leap, LeapLandFXActorClass) == 0x000D70, "Member 'UHWAbility_Leap::LeapLandFXActorClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_Leap, bManuallyActivateLeap) == 0x000D78, "Member 'UHWAbility_Leap::bManuallyActivateLeap' has a wrong offset!");
static_assert(offsetof(UHWAbility_Leap, LeapLandFXDuration) == 0x000D7C, "Member 'UHWAbility_Leap::LeapLandFXDuration' has a wrong offset!");
static_assert(offsetof(UHWAbility_Leap, bPlayAnimMontageOnLeapStart) == 0x000D80, "Member 'UHWAbility_Leap::bPlayAnimMontageOnLeapStart' has a wrong offset!");
static_assert(offsetof(UHWAbility_Leap, bLeapActivated) == 0x000D81, "Member 'UHWAbility_Leap::bLeapActivated' has a wrong offset!");

// Class Hemingway.HWCharacter_NPC_Familiar
// 0x0000 (0x13F0 - 0x13F0)
class AHWCharacter_NPC_Familiar : public AHWCharacter_NPC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_NPC_Familiar">();
	}
	static class AHWCharacter_NPC_Familiar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_NPC_Familiar>();
	}
};
static_assert(alignof(AHWCharacter_NPC_Familiar) == 0x000010, "Wrong alignment on AHWCharacter_NPC_Familiar");
static_assert(sizeof(AHWCharacter_NPC_Familiar) == 0x0013F0, "Wrong size on AHWCharacter_NPC_Familiar");

// Class Hemingway.HWCharacter_NPC_Vulcan_Thumper
// 0x0000 (0x13F0 - 0x13F0)
class AHWCharacter_NPC_Vulcan_Thumper final : public AHWCharacter_NPC_Familiar
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_NPC_Vulcan_Thumper">();
	}
	static class AHWCharacter_NPC_Vulcan_Thumper* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_NPC_Vulcan_Thumper>();
	}
};
static_assert(alignof(AHWCharacter_NPC_Vulcan_Thumper) == 0x000010, "Wrong alignment on AHWCharacter_NPC_Vulcan_Thumper");
static_assert(sizeof(AHWCharacter_NPC_Vulcan_Thumper) == 0x0013F0, "Wrong size on AHWCharacter_NPC_Vulcan_Thumper");

// Class Hemingway.HWAbility_CerberusA03
// 0x0008 (0x0D90 - 0x0D88)
class UHWAbility_CerberusA03 final : public UHWAbility_Leap
{
public:
	class AHWCharacter_Base*                      CurrentTargetActor;                                // 0x0D88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_CerberusA03">();
	}
	static class UHWAbility_CerberusA03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_CerberusA03>();
	}
};
static_assert(alignof(UHWAbility_CerberusA03) == 0x000008, "Wrong alignment on UHWAbility_CerberusA03");
static_assert(sizeof(UHWAbility_CerberusA03) == 0x000D90, "Wrong size on UHWAbility_CerberusA03");
static_assert(offsetof(UHWAbility_CerberusA03, CurrentTargetActor) == 0x000D88, "Member 'UHWAbility_CerberusA03::CurrentTargetActor' has a wrong offset!");

// Class Hemingway.HWAbility_Thanatos_Passive
// 0x0010 (0x0D80 - 0x0D70)
class UHWAbility_Thanatos_Passive final : public UHWAbility_Passive
{
public:
	float                                         DefaultExecuteThreshold;                           // 0x0D70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D74[0x4];                                      // 0x0D74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveTable*                            ThanatosUltimateCurveTable;                        // 0x0D78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetExecuteThresholdByAbilityLevel(const int32 AbilityLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Thanatos_Passive">();
	}
	static class UHWAbility_Thanatos_Passive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Thanatos_Passive>();
	}
};
static_assert(alignof(UHWAbility_Thanatos_Passive) == 0x000008, "Wrong alignment on UHWAbility_Thanatos_Passive");
static_assert(sizeof(UHWAbility_Thanatos_Passive) == 0x000D80, "Wrong size on UHWAbility_Thanatos_Passive");
static_assert(offsetof(UHWAbility_Thanatos_Passive, DefaultExecuteThreshold) == 0x000D70, "Member 'UHWAbility_Thanatos_Passive::DefaultExecuteThreshold' has a wrong offset!");
static_assert(offsetof(UHWAbility_Thanatos_Passive, ThanatosUltimateCurveTable) == 0x000D78, "Member 'UHWAbility_Thanatos_Passive::ThanatosUltimateCurveTable' has a wrong offset!");

// Class Hemingway.HWAbility_CurrencyDeathFx
// 0x0008 (0x09C8 - 0x09C0)
class UHWAbility_CurrencyDeathFx final : public UHWGameplayAbility
{
public:
	struct FGameplayTag                           CurrencyDeathBurstCue;                             // 0x09C0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_CurrencyDeathFx">();
	}
	static class UHWAbility_CurrencyDeathFx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_CurrencyDeathFx>();
	}
};
static_assert(alignof(UHWAbility_CurrencyDeathFx) == 0x000008, "Wrong alignment on UHWAbility_CurrencyDeathFx");
static_assert(sizeof(UHWAbility_CurrencyDeathFx) == 0x0009C8, "Wrong size on UHWAbility_CurrencyDeathFx");
static_assert(offsetof(UHWAbility_CurrencyDeathFx, CurrencyDeathBurstCue) == 0x0009C0, "Member 'UHWAbility_CurrencyDeathFx::CurrencyDeathBurstCue' has a wrong offset!");

// Class Hemingway.HWDeserterSubsystem
// 0x0030 (0x0060 - 0x0030)
class UHWDeserterSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<struct FGuid>                          AppliedDeserters;                                  // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSingleDeserterSystemEnabled;                      // 0x0040(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasAppliedAnyDeserters;                           // 0x0041(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  PrimaryDeserter;                                   // 0x0044(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMatchInDesertedState;                             // 0x0054(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrimaryDeserterThreshold;                          // 0x0058(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetDeserterList(TArray<struct FGuid>* DeserterList);
	void GetPrimaryDeserter(struct FGuid* DeserterId);
	float GetPrimaryDeserterThreshold();
	bool HasMatchBeenDeserted();
	bool IsSingleDeserterSystemEnabled();
	void MarkAsPrimaryDeserter(const struct FGuid& PlayerUuid);

	bool GetHasAppliedAnyDeserters() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeserterSubsystem">();
	}
	static class UHWDeserterSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDeserterSubsystem>();
	}
};
static_assert(alignof(UHWDeserterSubsystem) == 0x000008, "Wrong alignment on UHWDeserterSubsystem");
static_assert(sizeof(UHWDeserterSubsystem) == 0x000060, "Wrong size on UHWDeserterSubsystem");
static_assert(offsetof(UHWDeserterSubsystem, AppliedDeserters) == 0x000030, "Member 'UHWDeserterSubsystem::AppliedDeserters' has a wrong offset!");
static_assert(offsetof(UHWDeserterSubsystem, bSingleDeserterSystemEnabled) == 0x000040, "Member 'UHWDeserterSubsystem::bSingleDeserterSystemEnabled' has a wrong offset!");
static_assert(offsetof(UHWDeserterSubsystem, bHasAppliedAnyDeserters) == 0x000041, "Member 'UHWDeserterSubsystem::bHasAppliedAnyDeserters' has a wrong offset!");
static_assert(offsetof(UHWDeserterSubsystem, PrimaryDeserter) == 0x000044, "Member 'UHWDeserterSubsystem::PrimaryDeserter' has a wrong offset!");
static_assert(offsetof(UHWDeserterSubsystem, bMatchInDesertedState) == 0x000054, "Member 'UHWDeserterSubsystem::bMatchInDesertedState' has a wrong offset!");
static_assert(offsetof(UHWDeserterSubsystem, PrimaryDeserterThreshold) == 0x000058, "Member 'UHWDeserterSubsystem::PrimaryDeserterThreshold' has a wrong offset!");

// Class Hemingway.HWAbility_Danzaburou_A04
// 0x0018 (0x0D78 - 0x0D60)
class UHWAbility_Danzaburou_A04 final : public UHWGameplayAbility_Enhanced
{
public:
	bool                                          bShouldTransformIntoRocket;                        // 0x0D60(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D61[0x3];                                      // 0x0D61(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ExplosionAttackIdTag;                              // 0x0D64(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ExplosionCueTag;                                   // 0x0D6C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D74[0x4];                                      // 0x0D74(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireAoeExplosion();

	class AActor* GetRocketHomingTarget(const struct FGameplayAbilityTargetDataHandle& AimData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Danzaburou_A04">();
	}
	static class UHWAbility_Danzaburou_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Danzaburou_A04>();
	}
};
static_assert(alignof(UHWAbility_Danzaburou_A04) == 0x000008, "Wrong alignment on UHWAbility_Danzaburou_A04");
static_assert(sizeof(UHWAbility_Danzaburou_A04) == 0x000D78, "Wrong size on UHWAbility_Danzaburou_A04");
static_assert(offsetof(UHWAbility_Danzaburou_A04, bShouldTransformIntoRocket) == 0x000D60, "Member 'UHWAbility_Danzaburou_A04::bShouldTransformIntoRocket' has a wrong offset!");
static_assert(offsetof(UHWAbility_Danzaburou_A04, ExplosionAttackIdTag) == 0x000D64, "Member 'UHWAbility_Danzaburou_A04::ExplosionAttackIdTag' has a wrong offset!");
static_assert(offsetof(UHWAbility_Danzaburou_A04, ExplosionCueTag) == 0x000D6C, "Member 'UHWAbility_Danzaburou_A04::ExplosionCueTag' has a wrong offset!");

// Class Hemingway.HWAbility_GroundTargetHelper
// 0x0000 (0x0D70 - 0x0D70)
class UHWAbility_GroundTargetHelper final : public UHWAbility_Passive
{
public:
	void BP_OnDistanceLineIndicatorSettingUpdated();
	void BP_OnGroundTargetIndicatorSettingUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_GroundTargetHelper">();
	}
	static class UHWAbility_GroundTargetHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_GroundTargetHelper>();
	}
};
static_assert(alignof(UHWAbility_GroundTargetHelper) == 0x000008, "Wrong alignment on UHWAbility_GroundTargetHelper");
static_assert(sizeof(UHWAbility_GroundTargetHelper) == 0x000D70, "Wrong size on UHWAbility_GroundTargetHelper");

// Class Hemingway.HWDraftRules
// 0x0070 (0x0108 - 0x0098)
class UHWDraftRules : public UDraftRules
{
public:
	struct FGameplayTagQuery                      AICharacterSelectionQuery;                         // 0x0098(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDirectlyAddCharactersToLoadouts;                  // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceSkinSelectOnChangeCharacter;                 // 0x00E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRandomCharacterConsidersRole;                     // 0x00E2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeserterPenaltyForNullPick;                       // 0x00E3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldStorePlayerLoadouts;                        // 0x00E4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E5[0x23];                                      // 0x00E5(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FDraftPlayerIdHandle ConvertToDraftPlayerIdHandle(const struct FHWPersistentPlayerId& InPlayerId);
	static struct FHWPersistentPlayerId ConvertToHWPlayerId(const struct FDraftPlayerIdHandle& InDraftPlayerId);

	bool IsValidRandomBotChoice(const struct FDraftChoice& InDraftChoice, const struct FDraftTask& InDraftTask, class ADraftAuthority* InDraftAuthority);
	bool IsValidRandomPlayerChoice(const struct FDraftChoice& InDraftChoice, const struct FDraftTask& InDraftTask, class ADraftAuthority* InDraftAuthority);

	void HandleGodLoadoutReceived(bool bSuccess, const struct FRH_PlayerSettingsDataWrapper& SettingsWrapper, TWeakObjectPtr<class ADraftAuthority> InDraftAuthority, const struct FHWPersistentPlayerId& PlayerId, const class UHWCharacterItem* CharacterItem) const;
	void HandlePlayerLoadoutReceived(bool bSuccess, const struct FRH_PlayerSettingsDataWrapper& SettingsWrapper, TWeakObjectPtr<class ADraftAuthority> InDraftAuthority, const struct FHWPersistentPlayerId& PlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDraftRules">();
	}
	static class UHWDraftRules* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDraftRules>();
	}
};
static_assert(alignof(UHWDraftRules) == 0x000008, "Wrong alignment on UHWDraftRules");
static_assert(sizeof(UHWDraftRules) == 0x000108, "Wrong size on UHWDraftRules");
static_assert(offsetof(UHWDraftRules, AICharacterSelectionQuery) == 0x000098, "Member 'UHWDraftRules::AICharacterSelectionQuery' has a wrong offset!");
static_assert(offsetof(UHWDraftRules, bDirectlyAddCharactersToLoadouts) == 0x0000E0, "Member 'UHWDraftRules::bDirectlyAddCharactersToLoadouts' has a wrong offset!");
static_assert(offsetof(UHWDraftRules, bForceSkinSelectOnChangeCharacter) == 0x0000E1, "Member 'UHWDraftRules::bForceSkinSelectOnChangeCharacter' has a wrong offset!");
static_assert(offsetof(UHWDraftRules, bRandomCharacterConsidersRole) == 0x0000E2, "Member 'UHWDraftRules::bRandomCharacterConsidersRole' has a wrong offset!");
static_assert(offsetof(UHWDraftRules, bDeserterPenaltyForNullPick) == 0x0000E3, "Member 'UHWDraftRules::bDeserterPenaltyForNullPick' has a wrong offset!");
static_assert(offsetof(UHWDraftRules, bShouldStorePlayerLoadouts) == 0x0000E4, "Member 'UHWDraftRules::bShouldStorePlayerLoadouts' has a wrong offset!");

// Class Hemingway.HWDraftRules_Ranked
// 0x0018 (0x0120 - 0x0108)
class UHWDraftRules_Ranked : public UHWDraftRules
{
public:
	float                                         PostBanPhaseWaitTime;                              // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostPickPhaseWaitTime;                             // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWDraftOrderTask>              DraftTaskOrder;                                    // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDraftRules_Ranked">();
	}
	static class UHWDraftRules_Ranked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDraftRules_Ranked>();
	}
};
static_assert(alignof(UHWDraftRules_Ranked) == 0x000008, "Wrong alignment on UHWDraftRules_Ranked");
static_assert(sizeof(UHWDraftRules_Ranked) == 0x000120, "Wrong size on UHWDraftRules_Ranked");
static_assert(offsetof(UHWDraftRules_Ranked, PostBanPhaseWaitTime) == 0x000108, "Member 'UHWDraftRules_Ranked::PostBanPhaseWaitTime' has a wrong offset!");
static_assert(offsetof(UHWDraftRules_Ranked, PostPickPhaseWaitTime) == 0x00010C, "Member 'UHWDraftRules_Ranked::PostPickPhaseWaitTime' has a wrong offset!");
static_assert(offsetof(UHWDraftRules_Ranked, DraftTaskOrder) == 0x000110, "Member 'UHWDraftRules_Ranked::DraftTaskOrder' has a wrong offset!");

// Class Hemingway.HWDraftRules_Duel
// 0x0008 (0x0128 - 0x0120)
class UHWDraftRules_Duel : public UHWDraftRules_Ranked
{
public:
	float                                         TimeToPick;                                        // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToPickInCustoms;                               // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDraftRules_Duel">();
	}
	static class UHWDraftRules_Duel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDraftRules_Duel>();
	}
};
static_assert(alignof(UHWDraftRules_Duel) == 0x000008, "Wrong alignment on UHWDraftRules_Duel");
static_assert(sizeof(UHWDraftRules_Duel) == 0x000128, "Wrong size on UHWDraftRules_Duel");
static_assert(offsetof(UHWDraftRules_Duel, TimeToPick) == 0x000120, "Member 'UHWDraftRules_Duel::TimeToPick' has a wrong offset!");
static_assert(offsetof(UHWDraftRules_Duel, TimeToPickInCustoms) == 0x000124, "Member 'UHWDraftRules_Duel::TimeToPickInCustoms' has a wrong offset!");

// Class Hemingway.HWAbility_Levitate
// 0x0020 (0x0D80 - 0x0D60)
class UHWAbility_Levitate final : public UHWGameplayAbility_Enhanced
{
public:
	class AHWCharacter_Base*                      LevitatingCharacter;                               // 0x0D60(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWCharacterMovementComponent*          LevitatingCharacterMovementComponent;              // 0x0D68(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitGameplayEvent*         EarlyEndTriggerTask;                               // 0x0D70(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityTask_GameplayLevitate*        LevitateTask;                                      // 0x0D78(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleEarlyEndTrigger(const struct FGameplayEventData& Payload);
	void OnLevitationEnded(EHWEndLevitationReason EndLevitationReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Levitate">();
	}
	static class UHWAbility_Levitate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Levitate>();
	}
};
static_assert(alignof(UHWAbility_Levitate) == 0x000008, "Wrong alignment on UHWAbility_Levitate");
static_assert(sizeof(UHWAbility_Levitate) == 0x000D80, "Wrong size on UHWAbility_Levitate");
static_assert(offsetof(UHWAbility_Levitate, LevitatingCharacter) == 0x000D60, "Member 'UHWAbility_Levitate::LevitatingCharacter' has a wrong offset!");
static_assert(offsetof(UHWAbility_Levitate, LevitatingCharacterMovementComponent) == 0x000D68, "Member 'UHWAbility_Levitate::LevitatingCharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UHWAbility_Levitate, EarlyEndTriggerTask) == 0x000D70, "Member 'UHWAbility_Levitate::EarlyEndTriggerTask' has a wrong offset!");
static_assert(offsetof(UHWAbility_Levitate, LevitateTask) == 0x000D78, "Member 'UHWAbility_Levitate::LevitateTask' has a wrong offset!");

// Class Hemingway.HWLibrary_Core
// 0x0000 (0x0028 - 0x0028)
class UHWLibrary_Core final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector AdjustLocationToGround(const class UObject* WorldContextObject, const struct FVector& Location);
	static void BP_TraceBookmark(const class FString& Message);
	static void ClearAndInvalidateTimerHandleWithWorldContext(const class UObject* WorldContextObject, struct FTimerHandle& Handle);
	static struct FGameplayTargetDataFilterHandle CloneHWTargetDataFilter(const struct FGameplayTargetDataFilterHandle& FilterHandle, class AActor* NewAvatar);
	static struct FVector ConstrainCameraLocation(const class UObject* WorldContextObject, class AActor* SourceActor, const struct FVector& CameraLocation, const struct FVector& FocusLocation, ECollisionChannel ProbeChannel, float ProbeSize);
	static void ConvertSocketWorldToParentSpace(const struct FVector& ParentLocation, const struct FRotator& ParentRotation, const class USkeletalMeshComponent* Mesh, const class FName& SocketName, struct FVector* OutOffset, struct FRotator* OutRotation);
	static float CumulativeDistributionFunction(float X, float Mu, float Sigma);
	static bool DoesActorHaveLineOfSightOfLocation(const class AActor* TargetActor, const struct FVector& EndLocation, const TArray<class AActor*>& IgnoreActors);
	static bool EqualEqual_FGenericTeamId(const struct FGenericTeamId& A, const struct FGenericTeamId& B);
	static bool EqualEqual_FHWAbilityFiringInstanceId(const struct FHWAbilityFiringInstanceId& A, const struct FHWAbilityFiringInstanceId& B);
	static bool EqualEqual_FHWActiveFamiliarHandle(const struct FHWActiveFamiliarHandle& A, const struct FHWActiveFamiliarHandle& B);
	static bool EqualEqual_FHWActiveFamiliarInfo(const struct FHWActiveFamiliarInfo& A, const struct FHWActiveFamiliarInfo& B);
	static bool EqualEqual_FHWPersistentPlayerId(const struct FHWPersistentPlayerId& A, const struct FHWPersistentPlayerId& B);
	static float ErrorFunction(float X);
	static bool FindEdgeOfWorldGeometryCheck(const class UObject* WorldContextObject, const struct FVector& TraceOrigin, const struct FVector& TraceDirection, const float Range, const struct FVector& Extent, const class FName ProfileName, const class AActor* SourceActor, struct FVector* OutEdgeLocation, const bool bShouldFindSpotClosestFromTraceOrigin, const bool bShowDebug);
	static struct FVector FindNearestValidGroundLocation(const class UObject* WorldContextObject, const struct FVector& StartLocation, const struct FVector& EndLocation, const float MinDistance, const bool bCheckInsideCollision, const class AActor* ActorToCheck, const class AActor* ActorToIgnoreCollision);
	static bool FindWorldImpact(const class UObject* WorldContextObject, const struct FVector& StartTrace, const struct FVector& EndTrace, const struct FVector& CollisionExtents, const class AActor* TraceActor, struct FHitResult* OutWorldImpact, const class FName CollisionProfileOverride, const struct FGenericTeamId& TeamOverride);
	static struct FGameplayAbilitySpecHandle GetAbilitySpecFromAbilityFiringInstanceId(const struct FHWAbilityFiringInstanceId& FiringInstanceId);
	static ETeamAttitude GetActorAttitudeTowardsLocalPlayer(const class UObject* WorldContextObject, class AActor* InActor);
	static EHWSmiteTeamId GetActorGameTeam(const class UObject* WorldContextObject, const class AActor* InActor);
	static float GetAngleBetweenTwoVectors(const struct FVector& A, const struct FVector& B);
	static TSoftObjectPtr<class USoundBase> GetAnnouncerCueFromAnnouncerPack(const class UObject* WorldContextObject, const class UHWAnnouncerPackItem* AnnouncerPack, const struct FAssetRequestKey& AssetKey);
	static TSoftObjectPtr<class USoundBase> GetAnnouncerCueFromLocalPlayerAnnouncerPack(const class UObject* WorldContextObject, const struct FAssetRequestKey& AssetKey);
	static bool GetBooleanAppSetting(const class UObject* WorldContextObject, const struct FGameplayTag& SettingTag, bool* bOutSettingValue);
	static bool GetBooleanGameUserSetting(const class UObject* WorldContextObject, class FName SettingName, bool* bOutSettingValue);
	static struct FGameplayTag GetBotGameplayTagForRole(ECharacterRole Role);
	static bool GetCachedGodMasteryLevelInfoForPlayer(class UObject* WorldContextObject, const class UHWCharacterItem* GodItem, const class URH_PlayerInfo* PlayerInfo, struct FHWLevelInfo* OutLevelInfo);
	static struct FGameplayTagContainer GetCapturedTargetTagsFromEffectSpecHandle(const struct FGameplayEffectSpecHandle& EffectSpecHandle);
	static struct FGameplayTag GetCollectionTagFromType(EHWCollectionItemType CollectionType);
	static EHWConsoleType GetConsoleType();
	static int32 GetDraftLobbyTeamIndexForPlayer(const class ADraftReplicatedActor* InDraftActor, const class AHWPlayerState* PlayerState);
	static struct FGameplayTag GetFirstMatchingTag(const struct FGameplayTagContainer& Container, const struct FGameplayTag& TagToMatch, bool bExactMatch);
	static bool GetFloatGameUserSetting(const class UObject* WorldContextObject, class FName SettingName, float* bOutSettingValue);
	static bool GetGameModeInfo(const class UObject* WorldContextObject, struct FHWGameModeInfo* GameModeInfo, bool bUseDefaultGameModeInfoTag);
	static struct FGameplayEffectContextHandle GetGameplayEffectContext(const struct FGameplayEffectSpec& GameplayEffectSpec);
	static struct FGameplayTag GetGameplayTagForRole(ECharacterRole Role);
	static EHWSmiteTeamId GetGameTeamFromGenericTeamId(const class UObject* WorldContextObject, const struct FGenericTeamId& InTeamId);
	static EHWSmiteTeamId GetGameTeamFromRHTeamId(int32 RHTeamId);
	static struct FGenericTeamId GetGenericTeamId(const class AActor* TeamMemberActor);
	static void GetGodMasteryLevelForPlayer(class UObject* WorldContextObject, const class UHWCharacterItem* GodItem, const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(const class UHWCharacterItem* Character, const class URH_PlayerInfo* InPlayerInfo, int32 Level, float LevelProgressPercent)>& Delegate);
	static class UHWGodSubsystem* GetGodSubsystem(const class UObject* WorldContextObject);
	static class UHWGameInstance* GetHWGameInstance(const class UObject* WorldContextObject);
	static class AHWGameMode* GetHWGameMode(const class UObject* WorldContextObject);
	static class AHWGameState* GetHWGameState(const class UObject* WorldContextObject);
	static class AHWGameState* GetHWGameStateWithManualWorldContext(const class UObject* WorldContextObject);
	static class UHWTagManager* GetHWTagManager(const class UObject* WorldContextObject);
	static bool GetIntegerAppSetting(const class UObject* WorldContextObject, const struct FGameplayTag& SettingTag, int32* OutSettingValue);
	static bool GetIntegerGameUserSetting(const class UObject* WorldContextObject, class FName SettingName, int32* OutSettingValue);
	static class APlayerController* GetLocalPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex);
	static TSoftObjectPtr<class UMetaSoundSource> GetMusicCueFromLocalPlayerMusicPack(const class UObject* WorldContextObject, const struct FAssetRequestKey& AssetKey);
	static TSoftObjectPtr<class UMetaSoundSource> GetMusicCueFromMusicPack(const class UObject* WorldContextObject, const class UHWMusicPackItem* MusicPack, const struct FAssetRequestKey& AssetKey);
	static class FString GetNPCType(const class AHWCharacter_NPC* NPCCharacter);
	static struct FGameplayTag GetObjectFirstMatchingTag(const class UObject* ObjectToCheck, const struct FGameplayTag& Tag);
	static int32 GetPlayerCohort(class URH_PlayerInfo* PlayerInfo, int32 NumCohorts);
	static class FString GetPlayerFacingGameVersion(const class UObject* WorldContextObject);
	static bool GetPlayerNameFromDraftTask(const class ADraftReplicatedActor* InDraftActor, const struct FDraftTask& DraftTask, class FString* OutName);
	static bool GetReflexAvailable();
	static TArray<struct FRH_ItemId> GetRewardsForQuestTier(class UObject* WorldContextObject, const class UHWQuest* Quest, const class UHWCharacterItem* CharacterItem, const int32& QuestTier);
	static int32 GetRHTeamIdFromGameTeamId(int32 GameTeamId);
	static ECharacterRole GetRoleForGameplayTag(const struct FGameplayTag& RoleTag);
	static class FName GetSimpleTagName(const struct FGameplayTag& Tag);
	static TSoftObjectPtr<class UHWInventoryItem> GetSoftInventoryItemFromItemId(const struct FRH_ItemId& InItemId);
	static TSoftObjectPtr<class UHWInventoryItem> GetSoftInventoryItemFromLootId(const struct FRH_LootId& InLootId);
	static bool GetStringAppSetting(const class UObject* WorldContextObject, const struct FGameplayTag& SettingTag, class FString* OutSettingValue);
	static bool GetStringArrayAppSetting(const class UObject* WorldContextObject, const struct FGameplayTag& SettingTag, TArray<class FString>* OutSettingValues, const class FString& Delimiter);
	static class FString GetStringFromFiringInstance(const struct FHWAbilityFiringInstanceId& FiringInstanceId);
	static ETeamAttitude GetTeamAttitudeTowards(const class AActor* TeamMemberActor, const class AActor* OtherActor);
	static class AHWTeamState* GetTeamState(const class UObject* WorldContextObject, const struct FGenericTeamId& TeamId);
	static float GetWorldTimeStamp(const class UObject* WorldContextObject);
	static void HW_PlaySoftSound2D(const class UObject* WorldContextObject, TSoftObjectPtr<class USoundBase> SoftSound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, const class AActor* OwningActor, bool bIsUISound);
	static void HW_PlaySound2D(const class AActor* SkinningInstigatorActor, class USoundBase* Sound, const struct FAssetRequestKey& SkinningKey, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, const class AActor* OwningActor, bool bIsUISound);
	static void HW_PlaySoundAtLocation(const class AActor* SkinningInstigatorActor, class USoundBase* Sound, const struct FAssetRequestKey& SkinningKey, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, const class AActor* OwningActor, const class UInitialActiveSoundParams* InitialParams);
	static void HW_SetUnfocusedVolumeMultiplier(const float InVolumeMultiplier);
	static class UNiagaraComponent* HW_SpawnNiagaraSystemAtLocation(const class AActor* SkinningInstigatorActor, class UNiagaraSystem* SystemTemplate, const struct FAssetRequestKey& SkinningKey, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bAutoDestroy, bool bAutoActivate, ENCPoolMethod PoolingMethod, bool bPreCullCheck);
	static class UNiagaraComponent* HW_SpawnNiagaraSystemAttached(const class AActor* SkinningInstigatorActor, class UNiagaraSystem* SystemTemplate, const struct FAssetRequestKey& SkinningKey, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bAutoDestroy, bool bAutoActivate, ENCPoolMethod PoolingMethod, bool bPreCullCheck);
	static class UAudioComponent* HW_SpawnSoundAtLocation(const class AActor* SkinningInstigatorActor, class USoundBase* Sound, const struct FAssetRequestKey& SkinningKey, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	static class UAudioComponent* HW_SpawnSoundAttached(const class AActor* SkinningInstigatorActor, class USoundBase* Sound, const struct FAssetRequestKey& SkinningKey, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	static bool IsBot_FHWPersistentPlayerId(const struct FHWPersistentPlayerId& PlayerId);
	static bool IsDLSSAvailable();
	static bool IsDLSSFrameGenAvailable();
	static bool IsGameplayTagRequirementMet(const class UObject* ObjectToCheck, const struct FGameplayTagRequirements& TagRequirements);
	static bool IsGameplayTagRequirementMetForTags(const struct FGameplayTagContainer& TagsToCheck, const struct FGameplayTagRequirements& TagRequirements);
	static bool IsHuman_FHWPersistentPlayerId(const struct FHWPersistentPlayerId& PlayerId);
	static bool IsValid_FHWPersistentPlayerId(const struct FHWPersistentPlayerId& PlayerId);
	static bool IsValidWorldHit(const struct FHitResult& HitToCheck, const class AActor* TraceActor, const struct FGenericTeamId& TeamOverride);
	static struct FAssetRequestKey MakeAssetRequestKeyUsingKeyword(const class FName Keyword);
	static struct FGameplayTargetDataFilterHandle MakeHWTargetDataFilterHandle(const struct FHWGameplayTargetDataFilter& Filter, class AActor* Avatar);
	static bool NotEqual_FGenericTeamId(const struct FGenericTeamId& A, const struct FGenericTeamId& B);
	static bool NotEqual_FHWAbilityFiringInstanceId(const struct FHWAbilityFiringInstanceId& A, const struct FHWAbilityFiringInstanceId& B);
	static bool NotEqual_FHWActiveFamiliarHandle(const struct FHWActiveFamiliarHandle& A, const struct FHWActiveFamiliarHandle& B);
	static bool NotEqual_FHWActiveFamiliarInfo(const struct FHWActiveFamiliarInfo& A, const struct FHWActiveFamiliarInfo& B);
	static bool NotEqual_FHWPersistentPlayerId(const struct FHWPersistentPlayerId& A, const struct FHWPersistentPlayerId& B);
	static void ParseMatchData(const struct FRHAPI_MatchPlayerWithMatch& PlayerMatchData, struct FHWPlayerMatchData* OutPlayerMatchData);
	static void ParsePlayerData(const struct FRHAPI_MatchPlayerResponse& PlayerMatchData, const struct FTimespan& Duration, struct FHWPlayerMatchData* OutMatchData);
	static void ParsePlayerDataFromFullMatch(const struct FRHAPI_MatchWithPlayers& MatchData, const struct FGuid& RHPlayerUuid, struct FHWPlayerMatchData* OutPlayerMatchData);
	static void RegisterToBooleanAppSettingUpdates(const class UObject* WorldContextObject, const struct FGameplayTag& SettingTag, TDelegate<void(const struct FGameplayTag& AppSettingTag, bool bValue)> Callback, bool bFireInitialState, bool bValueIfNotFound);
	static void RegisterToIntegerAppSettingUpdates(const class UObject* WorldContextObject, const struct FGameplayTag& SettingTag, TDelegate<void(const struct FGameplayTag& AppSettingTag, int32 Value)> Callback, bool bFireInitialState, int32 ValueIfNotFound);
	static void RegisterToStringAppSettingUpdates(const class UObject* WorldContextObject, const struct FGameplayTag& SettingTag, TDelegate<void(const struct FGameplayTag& AppSettingTag, const class FString& Value)> Callback, bool bFireInitialState);
	static void RegisterToStringArrayAppSettingUpdates(const class UObject* WorldContextObject, const struct FGameplayTag& SettingTag, TDelegate<void(const struct FGameplayTag& AppSettingTag, const TArray<class FString>& Values)> Callback, bool bFireInitialState, const class FString& Delimiter);
	static void ReturnToMainLobby(const class UObject* WorldContextObject);
	static void SetGenericTeamId(class AActor* TeamMemberActor, const struct FGenericTeamId& TeamId);
	static void SetReflexMode(const EHWNvidiaReflexMode Mode);
	static bool SortActiveDraftPlayers(const TArray<struct FDraftTask>& DraftTasks, const struct FHWPersistentPlayerId& LHS, const struct FHWPersistentPlayerId& RHS);
	static void UnregisterToAppSettingUpdates(const class UObject* WorldContextObject);
	static bool ValidateGroundLocation(const class UObject* WorldContextObject, const struct FVector& Origin, const struct FRotator& Orientation, const struct FVector& CollisionExtents, const class AActor* SourceActor, const bool bIsCapsule);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLibrary_Core">();
	}
	static class UHWLibrary_Core* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLibrary_Core>();
	}
};
static_assert(alignof(UHWLibrary_Core) == 0x000008, "Wrong alignment on UHWLibrary_Core");
static_assert(sizeof(UHWLibrary_Core) == 0x000028, "Wrong size on UHWLibrary_Core");

// Class Hemingway.HWAbility_Mordred_PassiveCharge
// 0x0018 (0x0D78 - 0x0D60)
class UHWAbility_Mordred_PassiveCharge final : public UHWGameplayAbility_Enhanced
{
public:
	uint8                                         Pad_D60[0x8];                                      // 0x0D60(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveTable*                            CooldownCurveTable;                                // 0x0D68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D70[0x8];                                      // 0x0D70(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Mordred_PassiveCharge">();
	}
	static class UHWAbility_Mordred_PassiveCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Mordred_PassiveCharge>();
	}
};
static_assert(alignof(UHWAbility_Mordred_PassiveCharge) == 0x000008, "Wrong alignment on UHWAbility_Mordred_PassiveCharge");
static_assert(sizeof(UHWAbility_Mordred_PassiveCharge) == 0x000D78, "Wrong size on UHWAbility_Mordred_PassiveCharge");
static_assert(offsetof(UHWAbility_Mordred_PassiveCharge, CooldownCurveTable) == 0x000D68, "Member 'UHWAbility_Mordred_PassiveCharge::CooldownCurveTable' has a wrong offset!");

// Class Hemingway.HWAbilityDisplayInfoData
// 0x0008 (0x0030 - 0x0028)
class UHWAbilityDisplayInfoData : public UHWDisplayInfoData
{
public:
	class UHWGameplayAbility*                     GameplayAbility;                                   // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityDisplayInfoData">();
	}
	static class UHWAbilityDisplayInfoData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityDisplayInfoData>();
	}
};
static_assert(alignof(UHWAbilityDisplayInfoData) == 0x000008, "Wrong alignment on UHWAbilityDisplayInfoData");
static_assert(sizeof(UHWAbilityDisplayInfoData) == 0x000030, "Wrong size on UHWAbilityDisplayInfoData");
static_assert(offsetof(UHWAbilityDisplayInfoData, GameplayAbility) == 0x000028, "Member 'UHWAbilityDisplayInfoData::GameplayAbility' has a wrong offset!");

// Class Hemingway.HWRadialPlayerSelectorInfoData
// 0x0010 (0x0040 - 0x0030)
class UHWRadialPlayerSelectorInfoData final : public UHWAbilityDisplayInfoData
{
public:
	struct FGameplayTargetDataFilterHandle        AcceptableTargetFilter;                            // 0x0030(0x0010)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWRadialPlayerSelectorInfoData">();
	}
	static class UHWRadialPlayerSelectorInfoData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWRadialPlayerSelectorInfoData>();
	}
};
static_assert(alignof(UHWRadialPlayerSelectorInfoData) == 0x000008, "Wrong alignment on UHWRadialPlayerSelectorInfoData");
static_assert(sizeof(UHWRadialPlayerSelectorInfoData) == 0x000040, "Wrong size on UHWRadialPlayerSelectorInfoData");
static_assert(offsetof(UHWRadialPlayerSelectorInfoData, AcceptableTargetFilter) == 0x000030, "Member 'UHWRadialPlayerSelectorInfoData::AcceptableTargetFilter' has a wrong offset!");

// Class Hemingway.HWAbility_EscalatingDamageOnTarget
// 0x00B0 (0x0E10 - 0x0D60)
class UHWAbility_EscalatingDamageOnTarget : public UHWGameplayAbility_Enhanced
{
public:
	bool                                          bEnableDamageScaling;                              // 0x0D60(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D61[0x3];                                      // 0x0D61(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageScalingPerConsecutiveHitMult;                // 0x0D64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class UAbilitySystemComponent>, uint8> CurrentHitTargets;                    // 0x0D68(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class UAbilitySystemComponent>, uint8> LastHitTargets;                       // 0x0DB8(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E08[0x8];                                      // 0x0E08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAdjustDamageToTarget(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseDamage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_EscalatingDamageOnTarget">();
	}
	static class UHWAbility_EscalatingDamageOnTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_EscalatingDamageOnTarget>();
	}
};
static_assert(alignof(UHWAbility_EscalatingDamageOnTarget) == 0x000008, "Wrong alignment on UHWAbility_EscalatingDamageOnTarget");
static_assert(sizeof(UHWAbility_EscalatingDamageOnTarget) == 0x000E10, "Wrong size on UHWAbility_EscalatingDamageOnTarget");
static_assert(offsetof(UHWAbility_EscalatingDamageOnTarget, bEnableDamageScaling) == 0x000D60, "Member 'UHWAbility_EscalatingDamageOnTarget::bEnableDamageScaling' has a wrong offset!");
static_assert(offsetof(UHWAbility_EscalatingDamageOnTarget, DamageScalingPerConsecutiveHitMult) == 0x000D64, "Member 'UHWAbility_EscalatingDamageOnTarget::DamageScalingPerConsecutiveHitMult' has a wrong offset!");
static_assert(offsetof(UHWAbility_EscalatingDamageOnTarget, CurrentHitTargets) == 0x000D68, "Member 'UHWAbility_EscalatingDamageOnTarget::CurrentHitTargets' has a wrong offset!");
static_assert(offsetof(UHWAbility_EscalatingDamageOnTarget, LastHitTargets) == 0x000DB8, "Member 'UHWAbility_EscalatingDamageOnTarget::LastHitTargets' has a wrong offset!");

// Class Hemingway.HWAbility_Inhand
// 0x0048 (0x0E58 - 0x0E10)
class UHWAbility_Inhand : public UHWAbility_EscalatingDamageOnTarget
{
public:
	struct FGameplayTagContainer                  InhandChainAttackIndexTags;                        // 0x0E10(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         CurrentInhandAttackChainIndex;                     // 0x0E30(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NextInhandAttackChainIndex;                        // 0x0E31(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E32[0x6];                                      // 0x0E32(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            InhandResetTimerEffect;                            // 0x0E38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           InhandResetDurationConfigTag;                      // 0x0E40(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InhandResetTime;                                   // 0x0E48(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            InhandResetTimerEffectHandle;                      // 0x0E4C(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInhandSlowApplied;                              // 0x0E54(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E55[0x3];                                      // 0x0E55(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyInhandResetEffect();
	void BP_OnInhandResetTimerCompleted(const struct FGameplayEffectRemovalInfo& RemovalInfo);
	void IncrementInhandAttackChain();
	void OnAttackChainTimerTagUpdated(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void OnInhandResetTimerCompleted(const struct FGameplayEffectRemovalInfo& RemovalInfo);
	void ResetInhandAttackChain();
	void UpdateTargetingForInhandAttackChain(int32 nChainIndex);

	uint8 GetCurrentInhandAttackChainIndex() const;
	struct FGameplayTag GetCurrentInhandAttackChainTag() const;
	uint8 GetMaxInhandAttackChainIndex() const;
	bool IsAttackChainActive() const;
	bool ShouldIncrementInhandChainAttack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Inhand">();
	}
	static class UHWAbility_Inhand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Inhand>();
	}
};
static_assert(alignof(UHWAbility_Inhand) == 0x000008, "Wrong alignment on UHWAbility_Inhand");
static_assert(sizeof(UHWAbility_Inhand) == 0x000E58, "Wrong size on UHWAbility_Inhand");
static_assert(offsetof(UHWAbility_Inhand, InhandChainAttackIndexTags) == 0x000E10, "Member 'UHWAbility_Inhand::InhandChainAttackIndexTags' has a wrong offset!");
static_assert(offsetof(UHWAbility_Inhand, CurrentInhandAttackChainIndex) == 0x000E30, "Member 'UHWAbility_Inhand::CurrentInhandAttackChainIndex' has a wrong offset!");
static_assert(offsetof(UHWAbility_Inhand, NextInhandAttackChainIndex) == 0x000E31, "Member 'UHWAbility_Inhand::NextInhandAttackChainIndex' has a wrong offset!");
static_assert(offsetof(UHWAbility_Inhand, InhandResetTimerEffect) == 0x000E38, "Member 'UHWAbility_Inhand::InhandResetTimerEffect' has a wrong offset!");
static_assert(offsetof(UHWAbility_Inhand, InhandResetDurationConfigTag) == 0x000E40, "Member 'UHWAbility_Inhand::InhandResetDurationConfigTag' has a wrong offset!");
static_assert(offsetof(UHWAbility_Inhand, InhandResetTime) == 0x000E48, "Member 'UHWAbility_Inhand::InhandResetTime' has a wrong offset!");
static_assert(offsetof(UHWAbility_Inhand, InhandResetTimerEffectHandle) == 0x000E4C, "Member 'UHWAbility_Inhand::InhandResetTimerEffectHandle' has a wrong offset!");
static_assert(offsetof(UHWAbility_Inhand, bIsInhandSlowApplied) == 0x000E54, "Member 'UHWAbility_Inhand::bIsInhandSlowApplied' has a wrong offset!");

// Class Hemingway.HWDeployable_Wall
// 0x0080 (0x0548 - 0x04C8)
class AHWDeployable_Wall : public AHWDeployable
{
public:
	class UShapeComponent*                        CollisionComponent;                                // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWWallPushCollisionComponent*          WallPushoutCollisionComponent;                     // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          CurrentWallOverlappingActors;                      // 0x04E0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bPushOverlappingActors;                            // 0x04F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F1[0x7];                                      // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AActor>, struct FHWDeployableWallPushActorInfo> OverlappingPushActors; // 0x04F8(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlapWithWall(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void OnBeginOverlapWithWallPushoutCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapWithWall(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnEndOverlapWithWallPushoutCollision(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	bool CanPushOverlappingActors() const;
	bool ShouldPushActor(const class AActor* Other) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Wall">();
	}
	static class AHWDeployable_Wall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Wall>();
	}
};
static_assert(alignof(AHWDeployable_Wall) == 0x000008, "Wrong alignment on AHWDeployable_Wall");
static_assert(sizeof(AHWDeployable_Wall) == 0x000548, "Wrong size on AHWDeployable_Wall");
static_assert(offsetof(AHWDeployable_Wall, CollisionComponent) == 0x0004C8, "Member 'AHWDeployable_Wall::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Wall, WallPushoutCollisionComponent) == 0x0004D0, "Member 'AHWDeployable_Wall::WallPushoutCollisionComponent' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Wall, CurrentWallOverlappingActors) == 0x0004E0, "Member 'AHWDeployable_Wall::CurrentWallOverlappingActors' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Wall, bPushOverlappingActors) == 0x0004F0, "Member 'AHWDeployable_Wall::bPushOverlappingActors' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Wall, OverlappingPushActors) == 0x0004F8, "Member 'AHWDeployable_Wall::OverlappingPushActors' has a wrong offset!");

// Class Hemingway.HWAbility_Pele_Inhand
// 0x0000 (0x0E58 - 0x0E58)
class UHWAbility_Pele_Inhand final : public UHWAbility_Inhand
{
public:
	void OnConeAttackTagUpdated(const struct FGameplayTag& CallbackTag, int32 NewCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Pele_Inhand">();
	}
	static class UHWAbility_Pele_Inhand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Pele_Inhand>();
	}
};
static_assert(alignof(UHWAbility_Pele_Inhand) == 0x000008, "Wrong alignment on UHWAbility_Pele_Inhand");
static_assert(sizeof(UHWAbility_Pele_Inhand) == 0x000E58, "Wrong size on UHWAbility_Pele_Inhand");

// Class Hemingway.HWLocalPlayerLoadoutSubsystem
// 0x0188 (0x01B8 - 0x0030)
class UHWLocalPlayerLoadoutSubsystem final : public ULocalPlayerSubsystem
{
public:
	struct FHWPlayerLoadout                       PlayerLoadout;                                     // 0x0030(0x00B8)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FRH_ItemId, struct FHWGodLoadout> GodLoadouts;                                       // 0x00E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FRH_ItemId                             DefaultMusicPackItemId;                            // 0x0138(0x0014)(Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRH_ItemId                             DefaultAnnouncerPackItemId;                        // 0x014C(0x0014)(Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FHWPlayerLoadout& PlayerLoadout)> OnLocalPlayerLoadoutUpdated; // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UHWCharacterItem* CharacterItem, const struct FHWGodLoadout& GodLoadout)> OnLocalPlayerGodLoadoutUpdated; // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLocalPlayerGodLoadoutsLoaded;                    // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UHWCharacterItem* CharacterItem, const struct FGuid& BuildGuid)> OnLocalPlayerPinnedBuildUpdated; // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetEquippedBadgesForGod(const class UHWCharacterItem* GodItem, TArray<class UHWCollectionItem*>* OutBadgeItems);
	class UHWSkinItem* GetEquippedSkinForGod(const class UHWCharacterItem* GodItem);
	void GetEquippedTrackersForGod(const class UHWCharacterItem* GodItem, TArray<class UHWCollectionItem*>* OutTrackerItems);
	bool GetGodLoadout(const class UHWCharacterItem* GodItem, struct FHWGodLoadout* OutLoadout, bool bCreateIfMissing);
	class UHWCollectionItem* GetPlayerLoadoutItem(const EHWCollectionItemType ItemType, const int32 SlotIndex);
	const struct FRH_ItemId GetPlayerLoadoutItemId(const EHWCollectionItemType ItemType, const int32 SlotIndex);

	bool AreLocalGodLoadoutsLoaded() const;
	const struct FHWPlayerLoadout GetPlayerLoadout() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLocalPlayerLoadoutSubsystem">();
	}
	static class UHWLocalPlayerLoadoutSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLocalPlayerLoadoutSubsystem>();
	}
};
static_assert(alignof(UHWLocalPlayerLoadoutSubsystem) == 0x000008, "Wrong alignment on UHWLocalPlayerLoadoutSubsystem");
static_assert(sizeof(UHWLocalPlayerLoadoutSubsystem) == 0x0001B8, "Wrong size on UHWLocalPlayerLoadoutSubsystem");
static_assert(offsetof(UHWLocalPlayerLoadoutSubsystem, PlayerLoadout) == 0x000030, "Member 'UHWLocalPlayerLoadoutSubsystem::PlayerLoadout' has a wrong offset!");
static_assert(offsetof(UHWLocalPlayerLoadoutSubsystem, GodLoadouts) == 0x0000E8, "Member 'UHWLocalPlayerLoadoutSubsystem::GodLoadouts' has a wrong offset!");
static_assert(offsetof(UHWLocalPlayerLoadoutSubsystem, DefaultMusicPackItemId) == 0x000138, "Member 'UHWLocalPlayerLoadoutSubsystem::DefaultMusicPackItemId' has a wrong offset!");
static_assert(offsetof(UHWLocalPlayerLoadoutSubsystem, DefaultAnnouncerPackItemId) == 0x00014C, "Member 'UHWLocalPlayerLoadoutSubsystem::DefaultAnnouncerPackItemId' has a wrong offset!");
static_assert(offsetof(UHWLocalPlayerLoadoutSubsystem, OnLocalPlayerLoadoutUpdated) == 0x000170, "Member 'UHWLocalPlayerLoadoutSubsystem::OnLocalPlayerLoadoutUpdated' has a wrong offset!");
static_assert(offsetof(UHWLocalPlayerLoadoutSubsystem, OnLocalPlayerGodLoadoutUpdated) == 0x000180, "Member 'UHWLocalPlayerLoadoutSubsystem::OnLocalPlayerGodLoadoutUpdated' has a wrong offset!");
static_assert(offsetof(UHWLocalPlayerLoadoutSubsystem, OnLocalPlayerGodLoadoutsLoaded) == 0x000190, "Member 'UHWLocalPlayerLoadoutSubsystem::OnLocalPlayerGodLoadoutsLoaded' has a wrong offset!");
static_assert(offsetof(UHWLocalPlayerLoadoutSubsystem, OnLocalPlayerPinnedBuildUpdated) == 0x0001A0, "Member 'UHWLocalPlayerLoadoutSubsystem::OnLocalPlayerPinnedBuildUpdated' has a wrong offset!");

// Class Hemingway.HWAbility_Rama_Inhand
// 0x0000 (0x0E58 - 0x0E58)
class UHWAbility_Rama_Inhand final : public UHWAbility_Inhand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Rama_Inhand">();
	}
	static class UHWAbility_Rama_Inhand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Rama_Inhand>();
	}
};
static_assert(alignof(UHWAbility_Rama_Inhand) == 0x000008, "Wrong alignment on UHWAbility_Rama_Inhand");
static_assert(sizeof(UHWAbility_Rama_Inhand) == 0x000E58, "Wrong size on UHWAbility_Rama_Inhand");

// Class Hemingway.HWLeaderboardConfig
// 0x0010 (0x0040 - 0x0030)
class UHWLeaderboardConfig final : public UDataAsset
{
public:
	TArray<struct FHWLeaderboardDataConfig>       LeaderboardDataConfigs;                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLeaderboardConfig">();
	}
	static class UHWLeaderboardConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLeaderboardConfig>();
	}
};
static_assert(alignof(UHWLeaderboardConfig) == 0x000008, "Wrong alignment on UHWLeaderboardConfig");
static_assert(sizeof(UHWLeaderboardConfig) == 0x000040, "Wrong size on UHWLeaderboardConfig");
static_assert(offsetof(UHWLeaderboardConfig, LeaderboardDataConfigs) == 0x000030, "Member 'UHWLeaderboardConfig::LeaderboardDataConfigs' has a wrong offset!");

// Class Hemingway.HWAbility_Rama_Talent1_Listener
// 0x0020 (0x0D90 - 0x0D70)
class UHWAbility_Rama_Talent1_Listener final : public UHWAbility_Passive
{
public:
	uint8                                         Pad_D70[0x20];                                     // 0x0D70(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEquipmentSlotChanged(class UHWInventoryManagerComponent* InventoryManager, class UHWEquipmentInstance* EquipmentInstance, const struct FHWInventorySlot& Slot, const EHWInventoryChangeReason InventoryChangeReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Rama_Talent1_Listener">();
	}
	static class UHWAbility_Rama_Talent1_Listener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Rama_Talent1_Listener>();
	}
};
static_assert(alignof(UHWAbility_Rama_Talent1_Listener) == 0x000008, "Wrong alignment on UHWAbility_Rama_Talent1_Listener");
static_assert(sizeof(UHWAbility_Rama_Talent1_Listener) == 0x000D90, "Wrong size on UHWAbility_Rama_Talent1_Listener");

// Class Hemingway.HWAbility_Susano_A03_Refire
// 0x0000 (0x0D60 - 0x0D60)
class UHWAbility_Susano_A03_Refire final : public UHWGameplayAbility_Enhanced
{
public:
	bool FindSafeTeleportSpot(const class AActor* TestActor, struct FVector& PlaceLocation, const struct FRotator& PlaceRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Susano_A03_Refire">();
	}
	static class UHWAbility_Susano_A03_Refire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Susano_A03_Refire>();
	}
};
static_assert(alignof(UHWAbility_Susano_A03_Refire) == 0x000008, "Wrong alignment on UHWAbility_Susano_A03_Refire");
static_assert(sizeof(UHWAbility_Susano_A03_Refire) == 0x000D60, "Wrong size on UHWAbility_Susano_A03_Refire");

// Class Hemingway.HWEquipmentComponentSettings
// 0x0018 (0x0040 - 0x0028)
class UHWEquipmentComponentSettings : public UObject
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0028(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWEquipmentComponent>      ComponentClass;                                    // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMultipleOfThisComponentAllowed;                 // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsMultipleSupported() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponentSettings">();
	}
	static class UHWEquipmentComponentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponentSettings>();
	}
};
static_assert(alignof(UHWEquipmentComponentSettings) == 0x000008, "Wrong alignment on UHWEquipmentComponentSettings");
static_assert(sizeof(UHWEquipmentComponentSettings) == 0x000040, "Wrong size on UHWEquipmentComponentSettings");
static_assert(offsetof(UHWEquipmentComponentSettings, IdTag) == 0x000028, "Member 'UHWEquipmentComponentSettings::IdTag' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings, ComponentClass) == 0x000030, "Member 'UHWEquipmentComponentSettings::ComponentClass' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings, bIsMultipleOfThisComponentAllowed) == 0x000038, "Member 'UHWEquipmentComponentSettings::bIsMultipleOfThisComponentAllowed' has a wrong offset!");

// Class Hemingway.HWEquipmentComponentSettings_ChildEquipment
// 0x0010 (0x0050 - 0x0040)
class UHWEquipmentComponentSettings_ChildEquipment final : public UHWEquipmentComponentSettings
{
public:
	class UHWEquipmentItem*                       ParentEquipmentItem;                               // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseParentFiringInstanceId;                        // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForwardLevelingToParent;                          // 0x0049(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponentSettings_ChildEquipment">();
	}
	static class UHWEquipmentComponentSettings_ChildEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponentSettings_ChildEquipment>();
	}
};
static_assert(alignof(UHWEquipmentComponentSettings_ChildEquipment) == 0x000008, "Wrong alignment on UHWEquipmentComponentSettings_ChildEquipment");
static_assert(sizeof(UHWEquipmentComponentSettings_ChildEquipment) == 0x000050, "Wrong size on UHWEquipmentComponentSettings_ChildEquipment");
static_assert(offsetof(UHWEquipmentComponentSettings_ChildEquipment, ParentEquipmentItem) == 0x000040, "Member 'UHWEquipmentComponentSettings_ChildEquipment::ParentEquipmentItem' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_ChildEquipment, bUseParentFiringInstanceId) == 0x000048, "Member 'UHWEquipmentComponentSettings_ChildEquipment::bUseParentFiringInstanceId' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_ChildEquipment, bForwardLevelingToParent) == 0x000049, "Member 'UHWEquipmentComponentSettings_ChildEquipment::bForwardLevelingToParent' has a wrong offset!");

// Class Hemingway.HWAbility_Susano_A04
// 0x0020 (0x0D80 - 0x0D60)
class UHWAbility_Susano_A04 final : public UHWGameplayAbility_Enhanced
{
public:
	float                                         EffectProgress;                                    // 0x0D60(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScalingRate;                                       // 0x0D64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinChargeMultiplier;                               // 0x0D68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxChargeMultiplier;                               // 0x0D6C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWDeployable*                          SpawnedDeployable;                                 // 0x0D70(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BlockRefireOnServer;                               // 0x0D78(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D79[0x7];                                      // 0x0D79(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAdjustDamageToTarget(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseDamageValue);
	void OnDeath(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, float RespawnTimerDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Susano_A04">();
	}
	static class UHWAbility_Susano_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Susano_A04>();
	}
};
static_assert(alignof(UHWAbility_Susano_A04) == 0x000008, "Wrong alignment on UHWAbility_Susano_A04");
static_assert(sizeof(UHWAbility_Susano_A04) == 0x000D80, "Wrong size on UHWAbility_Susano_A04");
static_assert(offsetof(UHWAbility_Susano_A04, EffectProgress) == 0x000D60, "Member 'UHWAbility_Susano_A04::EffectProgress' has a wrong offset!");
static_assert(offsetof(UHWAbility_Susano_A04, ScalingRate) == 0x000D64, "Member 'UHWAbility_Susano_A04::ScalingRate' has a wrong offset!");
static_assert(offsetof(UHWAbility_Susano_A04, MinChargeMultiplier) == 0x000D68, "Member 'UHWAbility_Susano_A04::MinChargeMultiplier' has a wrong offset!");
static_assert(offsetof(UHWAbility_Susano_A04, MaxChargeMultiplier) == 0x000D6C, "Member 'UHWAbility_Susano_A04::MaxChargeMultiplier' has a wrong offset!");
static_assert(offsetof(UHWAbility_Susano_A04, SpawnedDeployable) == 0x000D70, "Member 'UHWAbility_Susano_A04::SpawnedDeployable' has a wrong offset!");
static_assert(offsetof(UHWAbility_Susano_A04, BlockRefireOnServer) == 0x000D78, "Member 'UHWAbility_Susano_A04::BlockRefireOnServer' has a wrong offset!");

// Class Hemingway.HWSettingsInfo_Generic
// 0x0008 (0x0190 - 0x0188)
class UHWSettingsInfo_Generic : public URHSettingsInfoBase
{
public:
	int32                                         Version;                                           // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSettingApplied();
	void OnSettingSaved();

	int32 GetVersion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSettingsInfo_Generic">();
	}
	static class UHWSettingsInfo_Generic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSettingsInfo_Generic>();
	}
};
static_assert(alignof(UHWSettingsInfo_Generic) == 0x000008, "Wrong alignment on UHWSettingsInfo_Generic");
static_assert(sizeof(UHWSettingsInfo_Generic) == 0x000190, "Wrong size on UHWSettingsInfo_Generic");
static_assert(offsetof(UHWSettingsInfo_Generic, Version) == 0x000188, "Member 'UHWSettingsInfo_Generic::Version' has a wrong offset!");

// Class Hemingway.HWAbility_VGS
// 0x0038 (0x0D98 - 0x0D60)
class UHWAbility_VGS final : public UHWGameplayAbility_Enhanced
{
public:
	class UAbilityTask_WaitGameplayEvent*         CancelTask;                                        // 0x0D60(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D68[0x10];                                     // 0x0D68(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWVGSGameplayEventTagConfig>   VGSGameplayEventConfigs;                           // 0x0D78(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UAbilityTask_WaitGameplayEvent*> VGSAbilityTasks;                                   // 0x0D88(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void HandleAbilityTaskReceived(const struct FGameplayEventData& Payload);
	void HandleCancelTaskReceived(const struct FGameplayEventData& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_VGS">();
	}
	static class UHWAbility_VGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_VGS>();
	}
};
static_assert(alignof(UHWAbility_VGS) == 0x000008, "Wrong alignment on UHWAbility_VGS");
static_assert(sizeof(UHWAbility_VGS) == 0x000D98, "Wrong size on UHWAbility_VGS");
static_assert(offsetof(UHWAbility_VGS, CancelTask) == 0x000D60, "Member 'UHWAbility_VGS::CancelTask' has a wrong offset!");
static_assert(offsetof(UHWAbility_VGS, VGSGameplayEventConfigs) == 0x000D78, "Member 'UHWAbility_VGS::VGSGameplayEventConfigs' has a wrong offset!");
static_assert(offsetof(UHWAbility_VGS, VGSAbilityTasks) == 0x000D88, "Member 'UHWAbility_VGS::VGSAbilityTasks' has a wrong offset!");

// Class Hemingway.HWBoosterSubsystem
// 0x0140 (0x0170 - 0x0030)
class UHWBoosterSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             BoosterTablePtr;                                   // 0x0050(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGenericTeamId, struct FHWTeamBoosters> AppliedTeamBoosters;                         // 0x0058(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FGenericTeamId, struct FGameplayTagContainer> ClaimedTeamBoosters;                   // 0x00A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              BoosterTableSoftPtr;                               // 0x00F8(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGenericTeamId, struct FHWTeamGrantedSkins> TeamGrantedSkinItems;                    // 0x0120(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ApplyBooster(const struct FGuid& PlayerId, const struct FGameplayTag& BoosterTag, const struct FGenericTeamId& TeamId);
	void HandleSoftTableLoaded();
	void UpdateAppliedTeamBoosters(const TMap<struct FGenericTeamId, struct FHWTeamBoosters>& InAppliedTeamBoosters);
	void UpdateGrantedSkins(const TMap<struct FGenericTeamId, struct FHWTeamGrantedSkins>& InGrantedSkinItems);

	bool GetBoosterConfig(const struct FGameplayTag& BoosterTag, struct FHWBoosterTableRow* OutBoosterConfig) const;
	bool IsSkinGrantedByBooster(const class UHWSkinItem* SkinItem, const struct FGenericTeamId& TeamId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBoosterSubsystem">();
	}
	static class UHWBoosterSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBoosterSubsystem>();
	}
};
static_assert(alignof(UHWBoosterSubsystem) == 0x000008, "Wrong alignment on UHWBoosterSubsystem");
static_assert(sizeof(UHWBoosterSubsystem) == 0x000170, "Wrong size on UHWBoosterSubsystem");
static_assert(offsetof(UHWBoosterSubsystem, BoosterTablePtr) == 0x000050, "Member 'UHWBoosterSubsystem::BoosterTablePtr' has a wrong offset!");
static_assert(offsetof(UHWBoosterSubsystem, AppliedTeamBoosters) == 0x000058, "Member 'UHWBoosterSubsystem::AppliedTeamBoosters' has a wrong offset!");
static_assert(offsetof(UHWBoosterSubsystem, ClaimedTeamBoosters) == 0x0000A8, "Member 'UHWBoosterSubsystem::ClaimedTeamBoosters' has a wrong offset!");
static_assert(offsetof(UHWBoosterSubsystem, BoosterTableSoftPtr) == 0x0000F8, "Member 'UHWBoosterSubsystem::BoosterTableSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWBoosterSubsystem, TeamGrantedSkinItems) == 0x000120, "Member 'UHWBoosterSubsystem::TeamGrantedSkinItems' has a wrong offset!");

// Class Hemingway.HWAbility_Yemoja_PSV
// 0x0008 (0x0D78 - 0x0D70)
class UHWAbility_Yemoja_PSV final : public UHWAbility_Passive
{
public:
	float                                         ResetCachedEffectIdDuration;                       // 0x0D70(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CachedEffectId;                                    // 0x0D74(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnYemojaCooldownAdjusted(const struct FGameplayEffectSpec& EffectSpec, const struct FGameplayEffectSpec& EffectBeingModified, const float InCooldownMultiplier, const float InCooldownFlatDelta);
	void RegisterCooldownReductionDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Yemoja_PSV">();
	}
	static class UHWAbility_Yemoja_PSV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Yemoja_PSV>();
	}
};
static_assert(alignof(UHWAbility_Yemoja_PSV) == 0x000008, "Wrong alignment on UHWAbility_Yemoja_PSV");
static_assert(sizeof(UHWAbility_Yemoja_PSV) == 0x000D78, "Wrong size on UHWAbility_Yemoja_PSV");
static_assert(offsetof(UHWAbility_Yemoja_PSV, ResetCachedEffectIdDuration) == 0x000D70, "Member 'UHWAbility_Yemoja_PSV::ResetCachedEffectIdDuration' has a wrong offset!");
static_assert(offsetof(UHWAbility_Yemoja_PSV, CachedEffectId) == 0x000D74, "Member 'UHWAbility_Yemoja_PSV::CachedEffectId' has a wrong offset!");

// Class Hemingway.HWACP_DynamicTransform
// 0x0090 (0x0AD0 - 0x0A40)
class UHWACP_DynamicTransform final : public UHWAbilityCollisionProxy
{
public:
	bool                                          bTransformListLocationsRelativeToOwner;            // 0x0A38(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransformListRotationsRelativeToOwner;            // 0x0A39(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransformListScalesRelativeToOwner;               // 0x0A3A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3B[0x95];                                     // 0x0A3B(0x0095)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWACP_DynamicTransform">();
	}
	static class UHWACP_DynamicTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWACP_DynamicTransform>();
	}
};
static_assert(alignof(UHWACP_DynamicTransform) == 0x000010, "Wrong alignment on UHWACP_DynamicTransform");
static_assert(sizeof(UHWACP_DynamicTransform) == 0x000AD0, "Wrong size on UHWACP_DynamicTransform");
static_assert(offsetof(UHWACP_DynamicTransform, bTransformListLocationsRelativeToOwner) == 0x000A38, "Member 'UHWACP_DynamicTransform::bTransformListLocationsRelativeToOwner' has a wrong offset!");
static_assert(offsetof(UHWACP_DynamicTransform, bTransformListRotationsRelativeToOwner) == 0x000A39, "Member 'UHWACP_DynamicTransform::bTransformListRotationsRelativeToOwner' has a wrong offset!");
static_assert(offsetof(UHWACP_DynamicTransform, bTransformListScalesRelativeToOwner) == 0x000A3A, "Member 'UHWACP_DynamicTransform::bTransformListScalesRelativeToOwner' has a wrong offset!");

// Class Hemingway.HWInterface_Visibility
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_Visibility final
{
public:
	void AbilityAddVisibilityData(class UVisibilityData* NewVisibilityData, const struct FGameplayAbilitySpecHandle& AbilitySpecHandle);
	void AbilityRemoveVisibilityData(class UVisibilityData* OldVisibilityData);
	void SetVisibility(const bool bNewVisible, const EHWVisibilityType VisibilityType);

	void GetLineOfSightOrigin(struct FVector* OutOrigin, const bool bUseCameraLocation) const;
	class UHWVisibilityComponent* GetVisibilityComponent() const;
	bool IsValidForMinimap() const;
	class UHWAbilitySystemComponent* VisGetAbilitySystemComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_Visibility">();
	}
	static class IHWInterface_Visibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_Visibility>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_Visibility) == 0x000001, "Wrong alignment on IHWInterface_Visibility");
static_assert(sizeof(IHWInterface_Visibility) == 0x000001, "Wrong size on IHWInterface_Visibility");

// Class Hemingway.HWACP_RadialSweep
// 0x0040 (0x0A80 - 0x0A40)
class UHWACP_RadialSweep final : public UHWAbilityCollisionProxy
{
public:
	uint8                                         Pad_A38[0x48];                                     // 0x0A38(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWACP_RadialSweep">();
	}
	static class UHWACP_RadialSweep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWACP_RadialSweep>();
	}
};
static_assert(alignof(UHWACP_RadialSweep) == 0x000010, "Wrong alignment on UHWACP_RadialSweep");
static_assert(sizeof(UHWACP_RadialSweep) == 0x000A80, "Wrong size on UHWACP_RadialSweep");

// Class Hemingway.HWVGSManager
// 0x0240 (0x04D8 - 0x0298)
class AHWVGSManager final : public AInfo
{
public:
	TSoftObjectPtr<class UDataTable>              MenuNodeTableSoftPtr;                              // 0x0298(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              ActionTableSoftPtr;                                // 0x02C0(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AHWPlayerState>          LocalPlayerState;                                  // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x50];                                     // 0x0300(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGameplayTag& MenuId)> CurrentVGSMenuIdUpdated;       // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& ActionId)> InvokeVGSAction;             // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWInputConfig*                         VGSInputConfig;                                    // 0x0370(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UInputMappingContext*> MenuInputContexts;                        // 0x0378(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKey>                           PressedKeysToWatch;                                // 0x03C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VGSInputContextPriority;                           // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class APlayerState>, struct FHWVGSPlayerActionTimestampMap> ActionTimestamps; // 0x03E8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class APlayerState>, struct FHWVGSPlayerFloodProtectionTimers> FloodTimerHandles; // 0x0438(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, struct FHWVGSEmoteOwnershipData> EmoteItemOwnership;                          // 0x0488(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void AttemptPlayEmote(const struct FHWVGSActionRow& Action, class AHWPlayerState* PlayerState, bool bShouldPlayOnRemoteClients);
	int32 GetItemQuantityForGC(const struct FHWVGSActionRow& Action, class AHWPlayerState* PlayerState);
	int32 GetQuestQuantityForGC(const struct FHWVGSActionRow& Action, class AHWPlayerState* PlayerState);
	void HandlePostKeyHandled(const struct FKey& Key, EInputEvent InputEvent);
	bool IsEmoteItemOwnershipRequired(const struct FHWVGSActionRow& Action);
	void OnCollectionItemLoaded(const struct FHWVGSActionRow& Action, class AHWPlayerState* PlayerState, const struct FRH_ItemId& ItemId, TSoftObjectPtr<class UHWCollectionItem> CollectionItem, bool bShouldPlayOnRemoteClients);
	void TriggerAction(const struct FGameplayTag& ActionId, class AActor* Sender);

	void MulticastSendVGS(class AActor* Sender, const struct FGameplayTag& VgsEntry) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVGSManager">();
	}
	static class AHWVGSManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWVGSManager>();
	}
};
static_assert(alignof(AHWVGSManager) == 0x000008, "Wrong alignment on AHWVGSManager");
static_assert(sizeof(AHWVGSManager) == 0x0004D8, "Wrong size on AHWVGSManager");
static_assert(offsetof(AHWVGSManager, MenuNodeTableSoftPtr) == 0x000298, "Member 'AHWVGSManager::MenuNodeTableSoftPtr' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, ActionTableSoftPtr) == 0x0002C0, "Member 'AHWVGSManager::ActionTableSoftPtr' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, LocalPlayerState) == 0x0002F8, "Member 'AHWVGSManager::LocalPlayerState' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, CurrentVGSMenuIdUpdated) == 0x000350, "Member 'AHWVGSManager::CurrentVGSMenuIdUpdated' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, InvokeVGSAction) == 0x000360, "Member 'AHWVGSManager::InvokeVGSAction' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, VGSInputConfig) == 0x000370, "Member 'AHWVGSManager::VGSInputConfig' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, MenuInputContexts) == 0x000378, "Member 'AHWVGSManager::MenuInputContexts' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, PressedKeysToWatch) == 0x0003C8, "Member 'AHWVGSManager::PressedKeysToWatch' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, VGSInputContextPriority) == 0x0003E0, "Member 'AHWVGSManager::VGSInputContextPriority' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, ActionTimestamps) == 0x0003E8, "Member 'AHWVGSManager::ActionTimestamps' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, FloodTimerHandles) == 0x000438, "Member 'AHWVGSManager::FloodTimerHandles' has a wrong offset!");
static_assert(offsetof(AHWVGSManager, EmoteItemOwnership) == 0x000488, "Member 'AHWVGSManager::EmoteItemOwnership' has a wrong offset!");

// Class Hemingway.HWEquipmentComponentSettings_AbilitySwap
// 0x0020 (0x0060 - 0x0040)
class UHWEquipmentComponentSettings_AbilitySwap final : public UHWEquipmentComponentSettings
{
public:
	EHWAbilitySwapBehavior                        AbilitySwapBehavior;                               // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWAbilitySwapPhase>            AbilitySwapPhases;                                 // 0x0048(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           InputTagOverride;                                  // 0x0058(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	EHWAbilitySwapBehavior GetAbilitySwapBehavior() const;
	struct FGameplayTag GetInputTagOverride() const;
	int32 GetNumPhases() const;
	float GetSwapAbilityAdditionalCooldownCost(const int32 PhaseIndex) const;
	float GetSwapAbilityDelay(const int32 PhaseIndex) const;
	float GetSwapAbilityWindowDuration(const int32 PhaseIndex) const;
	const class UHWEquipmentItem* GetSwapEquipmentItem(const int32 PhaseIndex) const;
	bool IsValidPhaseIndex(const int32 PhaseIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponentSettings_AbilitySwap">();
	}
	static class UHWEquipmentComponentSettings_AbilitySwap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponentSettings_AbilitySwap>();
	}
};
static_assert(alignof(UHWEquipmentComponentSettings_AbilitySwap) == 0x000008, "Wrong alignment on UHWEquipmentComponentSettings_AbilitySwap");
static_assert(sizeof(UHWEquipmentComponentSettings_AbilitySwap) == 0x000060, "Wrong size on UHWEquipmentComponentSettings_AbilitySwap");
static_assert(offsetof(UHWEquipmentComponentSettings_AbilitySwap, AbilitySwapBehavior) == 0x000040, "Member 'UHWEquipmentComponentSettings_AbilitySwap::AbilitySwapBehavior' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_AbilitySwap, AbilitySwapPhases) == 0x000048, "Member 'UHWEquipmentComponentSettings_AbilitySwap::AbilitySwapPhases' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_AbilitySwap, InputTagOverride) == 0x000058, "Member 'UHWEquipmentComponentSettings_AbilitySwap::InputTagOverride' has a wrong offset!");

// Class Hemingway.HWAIBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UHWAIBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyObstacleAvoidanceToVectorField(class UObject* WorldContextObject, const struct FHWObstacleAvoidanceParams& avoidanceParams);
	static void AssignBotToNearestLane(const class AHWCharacter_Base* SourceCharacter, const TArray<class FName>& Lanes, const struct FGameplayTag& ImmunityTag);
	static void CalculateAimPointWithPrediction(const class AHWCharacter_Base* SourceCharacter, const class AHWCharacter_Base* TargetCharacter, const struct FGameplayTag& abilityEquipPoint, int32 abilitySlotIndex, struct FVector* outAimFromPoint, struct FVector* outAimToPoint);
	static void CalculateAimPointWithPredictionByLevelConfig(const class AHWCharacter_Base* SourceCharacter, const class AHWCharacter_Base* TargetCharacter, const class UHWAbilityLevelConfig* levelConfig, struct FVector* outAimFromPoint, struct FVector* outAimToPoint);
	static struct FVector CalculateBestLaneWaitLocation(const class AHWCharacter_Base* SourceCharacter, class FName LaneId, EWaypointPathDirectionType Direction, float Aggression, const struct FGameplayTag& ImmunityTag);
	static struct FVector CalculateBestLaningLocation(const struct FHWLaneAggressionParams& inParams);
	static EHWAdvantageTypes CalculateCombatAdvantage(const struct FHWCombatAdvantageParams& inParams);
	static void ClearNavigationAvoidanceGroupsToAvoidMask(const class AHWCharacter_Base* Character);
	static float ComputeGodBackToBaseWeight(const class AHWCharacter_Base* Source, float healthWeight, float manaWeight);
	static bool DoesCharacterMatchRole(const class AHWCharacter_Base* Character, const ECharacterRole RoleToCheck);
	static bool DoesFactoryHaveLivingBots(class AHWBotFactory* factory);
	static bool DoesLaneExist(const class AHWCharacter_Base* SourceCharacter, class FName LaneId);
	static void FilterByTeam(TArray<class AActor*>& Actors, const struct FGenericTeamId& matchTeam);
	static class AHWWaypoint* FindLaneWaypoint(const class AHWCharacter_Base* SourceCharacter, class FName LaneId);
	static void GetAllFactoriesByLane(const class AHWCharacter_Base* SourceCharacter, class FName LaneId, const struct FGameplayTagRequirements& TagRequirements, TArray<class AHWBotFactory*>* outFactories);
	static void GetAlliesWithinRange(const class AHWCharacter_Base* SourceCharacter, float Radius, const struct FGameplayTagContainer& tagsToIgnore, TArray<class AHWCharacter_Base*>* outTargets);
	static int32 GetAllyCountThatAreFocusedOnTarget(const class AHWCharacter_Base* SourceCharacter, const class AHWCharacter_Base* TargetCharacter, bool bIncludeSource);
	static int32 GetAllyCountWithinRange(const class AHWCharacter_Base* SourceCharacter, float Radius, const struct FGameplayTagContainer& tagsToIgnore);
	static int32 GetAverageTeamLevel(const class AHWTeamState* Team);
	static class AHWBotFactory* GetBestJungleObjective(const class AHWCharacter_Base* SourceCharacter, TArray<class AHWBotFactory*>& jungleFactories);
	static bool GetCharactersInRadius(class UObject* WorldContextObject, const struct FVector& Location, float Radius, class AActor* ignoreActor, TArray<class AActor*>* outCharacters);
	static class AHWCharacter_Base* GetClosestAllyWithinRange(const class AHWCharacter_Base* SourceCharacter, float Range, const struct FGameplayTagContainer& tagsToIgnore);
	static class AHWCharacter_Base* GetClosestTeamStructure(const class AHWCharacter_Base* SourceCharacter, bool bOpposing, float* outDistance);
	static int32 GetDefeatedLaneCount(const class AHWCharacter_Base* Character, const TArray<class FName>& Lanes, const struct FGameplayTag& ImmunityTag);
	static float GetDistanceAlongLane(const class AHWCharacter_Base* SourceCharacter, class FName LaneId, EWaypointPathDirectionType Direction);
	static float GetDistancePercentageAlongLane(const class AHWCharacter_Base* SourceCharacter, class FName LaneId, EWaypointPathDirectionType Direction);
	static void GetEnemiesWithinRange(const class AHWCharacter_Base* SourceCharacter, float Radius, const struct FGameplayTagContainer& tagsToIgnore, TArray<class AHWCharacter_Base*>* outTargets);
	static int32 GetEnemyCountWithinRange(const class AHWCharacter_Base* SourceCharacter, float Radius, const struct FGameplayTagContainer& tagsToIgnore);
	static class AActor* GetFurthestLaneObjective(const class AHWCharacter_Base* SourceCharacter, class FName LaneId);
	static float GetGodBotInhandRange(const class AHWCharacter_Base* SourceCharacter);
	static class FName GetNearestLaneID(const class AHWCharacter_Base* SourceCharacter, const TArray<class FName>& Lanes, const struct FGameplayTag& ImmunityTag);
	static class AActor* GetNearestLaneObjectiveToEscapeTo(const class AHWCharacter_Base* SourceCharacter);
	static class AActor* GetNextLaneObjectiveToAttack(const class AHWCharacter_Base* SourceCharacter, class FName LaneId, const struct FGameplayTag& ImmunityTag);
	static class AActor* GetNextLaneObjectiveToDefend(const class AHWCharacter_Base* SourceCharacter, class FName LaneId, const struct FGameplayTag& ImmunityTag);
	static class AHWTeamState* GetOpposingTeamState(const class AHWCharacter_Base* SourceCharacter);
	static class AHWTeamState* GetOpposingTeamStateByTeam(const class AHWTeamState* Team);
	static ECharacterRole GetRoleForCharacter(const class AHWCharacter_Base* Character);
	static float GetStructureInhandRange(const class AHWCharacter_Base* SourceStructure);
	static int32 GetTeamNumbersAdvantage(const class AHWTeamState* Team);
	static int32 GetTeamPhoenixCount(const class AHWTeamState* TeamState);
	static int32 GetTeamPhoenixCountByCharacter(const class AHWCharacter_Base* TargetCharacter);
	static class AHWTeamState* GetTeamState(const class AHWCharacter_Base* SourceCharacter);
	static bool GetWorldGeoInRadius(class UObject* WorldContextObject, const struct FVector& Location, float Radius, TArray<struct FHitResult>* outHitResults);
	static bool HaveMinionsSpawnedForLane(const class AHWCharacter_Base* SourceCharacter, class FName LaneId);
	static bool IsAbilityFiring(const class AHWCharacter_Base* SourceCharacter, const struct FGameplayTag& EquipTag, const int32 EquipSlot);
	static bool IsAnyGodInRange(class UObject* WorldContextObject, const struct FVector& Location, float Range);
	static bool IsAnyOffhandFiring(const class AHWCharacter_Base* SourceCharacter, bool bChannelingOnly);
	static bool IsCharacterJungleRole(const class AHWCharacter_Base* Character);
	static bool IsCharacterProtectedByTower(const class AHWCharacter_Base* TargetCharacter, float Buffer);
	static bool IsCharacterSoloRole(const class AHWCharacter_Base* Character);
	static bool IsCharacterSupportRole(const class AHWCharacter_Base* Character);
	static bool IsCharacterUntargetable(const class AHWCharacter_Base* Character);
	static bool IsCharacterWithinAnyLaningArea(const class AHWCharacter_Base* Character, const TArray<class FName>& Lanes, EWaypointPathDirectionType Direction, float MaxDistanceFromLane);
	static bool IsCharacterWithinLaningArea(const class AHWCharacter_Base* Character, class FName LaneId, EWaypointPathDirectionType Direction, float MaxDistanceFromLane);
	static bool IsGodBotAheadOfWave(const class AHWCharacter_Base* SourceCharacter, class AHWWaypoint* LaneWaypoint, float AheadByAmount);
	static bool IsLocationInCharacterAttackRange(const class AHWCharacter_Base* Character, const struct FVector& Location, const float Buffer);
	static bool IsLocationProtectedByOpposingTower(const class AHWTeamState* AttackingTeam, const struct FVector& Location, float Buffer);
	static bool IsLocationProtectedByTower(const class AHWTeamState* ProtectingTeam, const struct FVector& Location, float Buffer);
	static bool IsTargetProtectedByTower(const class AHWCharacter_Base* AttackingCharacter, const class AHWCharacter_Base* TargetCharacter);
	static void ManageCharacterLane(const struct FHWManageCharacterLaneParams& LaneParams);
	static int32 PickRandomIndexFromWeightedSet(const TArray<float>& Weights);
	static void PostNPEProgressPointEvent(class UObject* WorldContextObject, class FString& ProgressPoint);
	static void PostNPEProgressPointEventWithTag(class UObject* WorldContextObject, const struct FGameplayTag& ProgressPoint);
	static void RemoveComponentFromNavigation(class UPrimitiveComponent* Comp);
	static bool RequestGameplayTagFromName(class FName InName, struct FGameplayTag* outTag);
	static void SetNavigationAvoidanceGroupsToAvoidMask_AllGods(const class AHWCharacter_Base* Character);
	static void SetNavigationAvoidanceGroupsToAvoidMask_AllGodsEnemyMinions(const class AHWCharacter_Base* Character);
	static void SetNavigationAvoidanceGroupsToAvoidMask_AllyGodsEnemyMinions(const class AHWCharacter_Base* Character);
	static bool ShouldGodBackToBase(const class AHWCharacter_Base* Source, float healthThreshold, float manaThreshold);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIBlueprintLibrary">();
	}
	static class UHWAIBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIBlueprintLibrary>();
	}
};
static_assert(alignof(UHWAIBlueprintLibrary) == 0x000008, "Wrong alignment on UHWAIBlueprintLibrary");
static_assert(sizeof(UHWAIBlueprintLibrary) == 0x000028, "Wrong size on UHWAIBlueprintLibrary");

// Class Hemingway.HWAIController
// 0x0178 (0x0538 - 0x03C0)
class AHWAIController : public AAIController
{
public:
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWCharacterAbilitySystemActor*         AbilitySystemActor;                                // 0x03D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AController* Controller, const struct FGenericTeamId& TeamId)> OnTeamChangedDelegate; // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWAIController* Controller)> OnCurrentThreatChangedDel;     // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ThreatUpdateRate;                                  // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetectionRange;                                    // 0x03FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHWAIThreatHistoryData>         ThreatHistory;                                     // 0x0400(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentThreatIndex;                                // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastThreatUpdateTime;                              // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastThreatChangeTime;                              // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAIThreatEvaluator*                   CurrentThreatEvaluator;                            // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockCurrentThreat;                                // 0x0428(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutgoingDamagePerSecond;                           // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IncomingDamagePerSecond;                           // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfDPSWindows;                                // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 IncomingDPSWindows;                                // 0x0438(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         OutgoingDamageAccumulator;                         // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IncomingDamageAccumulator;                         // 0x044C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastDamagePerSecondUpdateTime;                     // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalOutgoingDamage;                               // 0x0454(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalOutgoingDamageCount;                          // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalIncomingDamage;                               // 0x045C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalIncomingDamageCount;                          // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDPSTracking;                                // 0x0464(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_465[0x3];                                      // 0x0465(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamagePerSecondUpdateRate;                         // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWWaypointSet*                         WaypointSet;                                       // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWWaypoint>             StartingWaypoint;                                  // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StartWaypointLaneID;                               // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TeamRole;                                          // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWaypointPathDirectionType                    LaneDirection;                                     // 0x0490(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_491[0x3];                                      // 0x0491(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CurrentPlay;                                       // 0x0494(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  CurrentPlayActor;                                  // 0x049C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CombatPositioningTags;                             // 0x04A8(0x0020)(Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	float                                         LastAggressiveAbilityUsageTime;                    // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAIGoal*                              GoalRoot;                                          // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFocusOnPlayActor;                                 // 0x04D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            ActiveAbilityUsageCooldowns;                       // 0x04E0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint64                                        GoalSystemLockFrame;                               // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetLastDamageTakenWorldTime();
	void InitializeBotComponents(const class AHWBotFactory* factory, const struct FHWAIBotConfig& botConfig);
	void InitializePerception(TSubclassOf<class UHWAIPerceptionComponent> PerceptionComponentClass);
	void LockGoalSystemForFrame();
	void OnCharacterDamaged(const struct FDamageEventData& DamageEventData);
	void OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);
	void ResetAverageDamageCounters();
	void SetCurrentThreatEvaluator(class UHWAIThreatEvaluator* inEvaluator);
	void ToggleFocusOnPlayActor(bool bOn);
	void ToggleLockCurrentThreat(bool bOn);

	bool AreThereCredibleThreatsWithinRange(float Range) const;
	bool CanSeeHostileTarget(const class AActor* InActor, bool bIncludeMiniMap) const;
	class AHWCharacterAbilitySystemActor* GetAbilitySystemActor() const;
	void GetAllThreats(bool bIncludeCurrentThreat, TArray<class AHWCharacter_Base*>* outThreats) const;
	float GetAverageIncomingDamage() const;
	float GetAverageOutgoingDamage() const;
	struct FVector GetAvgThreatLocation() const;
	class UBehaviorTreeComponent* GetBehaviorTreeComponent() const;
	class AHWCharacter_Base* GetCurrentThreat() const;
	struct FVector GetCurrentThreatLastKnownLocation() const;
	int32 GetGankAbleThreatCount(float Range, bool bHasSight) const;
	float GetGodThreatAvgHealthPct(const float MaxDistance) const;
	int32 GetGodThreatCount(const float MaxDistance) const;
	float GetGodThreatTotalHealthPct(const float MaxDistance) const;
	int32 GetHostileThreatCount(bool bOnlyWithinAttackRange, float MaxDamagedByTime, bool bGodOnly) const;
	float GetIncomingDamagePerSecond() const;
	EWaypointPathDirectionType GetLaneDirection() const;
	class FName GetLaneID() const;
	int32 GetMinionThreatAggroCount() const;
	int32 GetMinionThreatCount(const float MaxDistance) const;
	class AHWCharacter_Base* GetNearestStructureThreat() const;
	class AHWCharacter_Base* GetNearestThreat(bool bGodOnly) const;
	float GetOutgoingDamagePerSecond() const;
	struct FGameplayTag GetTeamRole() const;
	bool IsAHostileThreat(const class AHWCharacter_Base* Threat, float MaxDamagedByTime) const;
	bool IsCurrentThreatGankable(float Range) const;
	bool IsCurrentThreatLocked() const;
	bool IsGoalSystemLocked() const;
	bool IsGodThreatAvailable(const float MaxDistance) const;
	bool IsHostileThreatAvailable(bool bOnlyWithinAttackRange, float MaxDamagedByTime, bool bGodOnly) const;
	bool IsThreat(const class AActor* InActor, int32* OutIndex) const;
	bool IsThreatGankable(const class AHWCharacter_Base* Threat, float Range) const;
	float PredictNextIncomingDamageAmount() const;
	float PredictNextOutgoingDamageAmount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIController">();
	}
	static class AHWAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWAIController>();
	}
};
static_assert(alignof(AHWAIController) == 0x000008, "Wrong alignment on AHWAIController");
static_assert(sizeof(AHWAIController) == 0x000538, "Wrong size on AHWAIController");
static_assert(offsetof(AHWAIController, AbilitySystemActor) == 0x0003D0, "Member 'AHWAIController::AbilitySystemActor' has a wrong offset!");
static_assert(offsetof(AHWAIController, OnTeamChangedDelegate) == 0x0003D8, "Member 'AHWAIController::OnTeamChangedDelegate' has a wrong offset!");
static_assert(offsetof(AHWAIController, OnCurrentThreatChangedDel) == 0x0003E8, "Member 'AHWAIController::OnCurrentThreatChangedDel' has a wrong offset!");
static_assert(offsetof(AHWAIController, ThreatUpdateRate) == 0x0003F8, "Member 'AHWAIController::ThreatUpdateRate' has a wrong offset!");
static_assert(offsetof(AHWAIController, DetectionRange) == 0x0003FC, "Member 'AHWAIController::DetectionRange' has a wrong offset!");
static_assert(offsetof(AHWAIController, ThreatHistory) == 0x000400, "Member 'AHWAIController::ThreatHistory' has a wrong offset!");
static_assert(offsetof(AHWAIController, CurrentThreatIndex) == 0x000410, "Member 'AHWAIController::CurrentThreatIndex' has a wrong offset!");
static_assert(offsetof(AHWAIController, LastThreatUpdateTime) == 0x000414, "Member 'AHWAIController::LastThreatUpdateTime' has a wrong offset!");
static_assert(offsetof(AHWAIController, LastThreatChangeTime) == 0x000418, "Member 'AHWAIController::LastThreatChangeTime' has a wrong offset!");
static_assert(offsetof(AHWAIController, CurrentThreatEvaluator) == 0x000420, "Member 'AHWAIController::CurrentThreatEvaluator' has a wrong offset!");
static_assert(offsetof(AHWAIController, bLockCurrentThreat) == 0x000428, "Member 'AHWAIController::bLockCurrentThreat' has a wrong offset!");
static_assert(offsetof(AHWAIController, OutgoingDamagePerSecond) == 0x00042C, "Member 'AHWAIController::OutgoingDamagePerSecond' has a wrong offset!");
static_assert(offsetof(AHWAIController, IncomingDamagePerSecond) == 0x000430, "Member 'AHWAIController::IncomingDamagePerSecond' has a wrong offset!");
static_assert(offsetof(AHWAIController, NumberOfDPSWindows) == 0x000434, "Member 'AHWAIController::NumberOfDPSWindows' has a wrong offset!");
static_assert(offsetof(AHWAIController, IncomingDPSWindows) == 0x000438, "Member 'AHWAIController::IncomingDPSWindows' has a wrong offset!");
static_assert(offsetof(AHWAIController, OutgoingDamageAccumulator) == 0x000448, "Member 'AHWAIController::OutgoingDamageAccumulator' has a wrong offset!");
static_assert(offsetof(AHWAIController, IncomingDamageAccumulator) == 0x00044C, "Member 'AHWAIController::IncomingDamageAccumulator' has a wrong offset!");
static_assert(offsetof(AHWAIController, LastDamagePerSecondUpdateTime) == 0x000450, "Member 'AHWAIController::LastDamagePerSecondUpdateTime' has a wrong offset!");
static_assert(offsetof(AHWAIController, TotalOutgoingDamage) == 0x000454, "Member 'AHWAIController::TotalOutgoingDamage' has a wrong offset!");
static_assert(offsetof(AHWAIController, TotalOutgoingDamageCount) == 0x000458, "Member 'AHWAIController::TotalOutgoingDamageCount' has a wrong offset!");
static_assert(offsetof(AHWAIController, TotalIncomingDamage) == 0x00045C, "Member 'AHWAIController::TotalIncomingDamage' has a wrong offset!");
static_assert(offsetof(AHWAIController, TotalIncomingDamageCount) == 0x000460, "Member 'AHWAIController::TotalIncomingDamageCount' has a wrong offset!");
static_assert(offsetof(AHWAIController, bEnableDPSTracking) == 0x000464, "Member 'AHWAIController::bEnableDPSTracking' has a wrong offset!");
static_assert(offsetof(AHWAIController, DamagePerSecondUpdateRate) == 0x000468, "Member 'AHWAIController::DamagePerSecondUpdateRate' has a wrong offset!");
static_assert(offsetof(AHWAIController, WaypointSet) == 0x000470, "Member 'AHWAIController::WaypointSet' has a wrong offset!");
static_assert(offsetof(AHWAIController, StartingWaypoint) == 0x000478, "Member 'AHWAIController::StartingWaypoint' has a wrong offset!");
static_assert(offsetof(AHWAIController, StartWaypointLaneID) == 0x000480, "Member 'AHWAIController::StartWaypointLaneID' has a wrong offset!");
static_assert(offsetof(AHWAIController, TeamRole) == 0x000488, "Member 'AHWAIController::TeamRole' has a wrong offset!");
static_assert(offsetof(AHWAIController, LaneDirection) == 0x000490, "Member 'AHWAIController::LaneDirection' has a wrong offset!");
static_assert(offsetof(AHWAIController, CurrentPlay) == 0x000494, "Member 'AHWAIController::CurrentPlay' has a wrong offset!");
static_assert(offsetof(AHWAIController, CurrentPlayActor) == 0x00049C, "Member 'AHWAIController::CurrentPlayActor' has a wrong offset!");
static_assert(offsetof(AHWAIController, CombatPositioningTags) == 0x0004A8, "Member 'AHWAIController::CombatPositioningTags' has a wrong offset!");
static_assert(offsetof(AHWAIController, LastAggressiveAbilityUsageTime) == 0x0004C8, "Member 'AHWAIController::LastAggressiveAbilityUsageTime' has a wrong offset!");
static_assert(offsetof(AHWAIController, GoalRoot) == 0x0004D0, "Member 'AHWAIController::GoalRoot' has a wrong offset!");
static_assert(offsetof(AHWAIController, bFocusOnPlayActor) == 0x0004D8, "Member 'AHWAIController::bFocusOnPlayActor' has a wrong offset!");
static_assert(offsetof(AHWAIController, ActiveAbilityUsageCooldowns) == 0x0004E0, "Member 'AHWAIController::ActiveAbilityUsageCooldowns' has a wrong offset!");
static_assert(offsetof(AHWAIController, GoalSystemLockFrame) == 0x000530, "Member 'AHWAIController::GoalSystemLockFrame' has a wrong offset!");

// Class Hemingway.HWShopVendorVolume
// 0x0008 (0x02A0 - 0x0298)
class AHWShopVendorVolume : public AActor
{
public:
	bool                                          bOnlyActivateOnRespawn;                            // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlappedCharacterAbilitySystemChanged(class UHWAbilitySystemComponent* NewAbilitySystem, class UHWAbilitySystemComponent* OldAbilitySystem);

	bool CanShopActivateFor(class AHWCharacter_Base* NewTouchingCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWShopVendorVolume">();
	}
	static class AHWShopVendorVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWShopVendorVolume>();
	}
};
static_assert(alignof(AHWShopVendorVolume) == 0x000008, "Wrong alignment on AHWShopVendorVolume");
static_assert(sizeof(AHWShopVendorVolume) == 0x0002A0, "Wrong size on AHWShopVendorVolume");
static_assert(offsetof(AHWShopVendorVolume, bOnlyActivateOnRespawn) == 0x000298, "Member 'AHWShopVendorVolume::bOnlyActivateOnRespawn' has a wrong offset!");

// Class Hemingway.HWFountain
// 0x0010 (0x02B0 - 0x02A0)
class AHWFountain : public AHWShopVendorVolume
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OwningTeam;                                        // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleTeamsUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWFountain">();
	}
	static class AHWFountain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWFountain>();
	}
};
static_assert(alignof(AHWFountain) == 0x000008, "Wrong alignment on AHWFountain");
static_assert(sizeof(AHWFountain) == 0x0002B0, "Wrong size on AHWFountain");
static_assert(offsetof(AHWFountain, OwningTeam) == 0x0002A8, "Member 'AHWFountain::OwningTeam' has a wrong offset!");

// Class Hemingway.HWAIController_Player
// 0x0000 (0x0538 - 0x0538)
class AHWAIController_Player final : public AHWAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIController_Player">();
	}
	static class AHWAIController_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWAIController_Player>();
	}
};
static_assert(alignof(AHWAIController_Player) == 0x000008, "Wrong alignment on AHWAIController_Player");
static_assert(sizeof(AHWAIController_Player) == 0x000538, "Wrong size on AHWAIController_Player");

// Class Hemingway.HWEffectVolumeTrackingInfo
// 0x0018 (0x0040 - 0x0028)
class UHWEffectVolumeTrackingInfo final : public UObject
{
public:
	TArray<struct FHWVolumeEffectActiveEffectInfoHandle> ActiveVolumeEffectInfoHandleList;           // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  TrackedActor;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEffectVolumeTrackingInfo">();
	}
	static class UHWEffectVolumeTrackingInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEffectVolumeTrackingInfo>();
	}
};
static_assert(alignof(UHWEffectVolumeTrackingInfo) == 0x000008, "Wrong alignment on UHWEffectVolumeTrackingInfo");
static_assert(sizeof(UHWEffectVolumeTrackingInfo) == 0x000040, "Wrong size on UHWEffectVolumeTrackingInfo");
static_assert(offsetof(UHWEffectVolumeTrackingInfo, ActiveVolumeEffectInfoHandleList) == 0x000028, "Member 'UHWEffectVolumeTrackingInfo::ActiveVolumeEffectInfoHandleList' has a wrong offset!");
static_assert(offsetof(UHWEffectVolumeTrackingInfo, TrackedActor) == 0x000038, "Member 'UHWEffectVolumeTrackingInfo::TrackedActor' has a wrong offset!");

// Class Hemingway.HWAIDifficultyConfig
// 0x0020 (0x0050 - 0x0030)
class UHWAIDifficultyConfig final : public UDataAsset
{
public:
	float                                         MaxXPLeadForDifficultyScaling;                     // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxGoldLeadForDifficultyScaling;                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxKDALeadForDifficultyScaling;                    // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAvoidDangerousDeployables;                        // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWAIDifficultyData>            DataByDifficulty;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	int32 GetMaxFocusFireOnPlayer(const float DifficultyScale) const;
	int32 GetMinPlayerLevelForAggression(const float DifficultyScale) const;
	float GetPlayerThreatModifier(const float DifficultyScale) const;
	float GetPlayWeightPenalty(const float DifficultyScale, const struct FGameplayTag& PlayTag) const;
	bool IsPlayDisabled(const float DifficultyScale, const struct FGameplayTag& PlayTag) const;
	bool ShouldAllowAbility(const float DifficultyScale, const struct FGameplayTagContainer& Tags) const;
	bool ShouldAllowAbilityCombos(const float DifficultyScale) const;
	bool ShouldAllowAggressiveAbilityUsage(const float DifficultyScale, const float TimeSinceLastAggressiveAbilityUsage) const;
	bool ShouldAvoidDangerousDeployables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIDifficultyConfig">();
	}
	static class UHWAIDifficultyConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIDifficultyConfig>();
	}
};
static_assert(alignof(UHWAIDifficultyConfig) == 0x000008, "Wrong alignment on UHWAIDifficultyConfig");
static_assert(sizeof(UHWAIDifficultyConfig) == 0x000050, "Wrong size on UHWAIDifficultyConfig");
static_assert(offsetof(UHWAIDifficultyConfig, MaxXPLeadForDifficultyScaling) == 0x000030, "Member 'UHWAIDifficultyConfig::MaxXPLeadForDifficultyScaling' has a wrong offset!");
static_assert(offsetof(UHWAIDifficultyConfig, MaxGoldLeadForDifficultyScaling) == 0x000034, "Member 'UHWAIDifficultyConfig::MaxGoldLeadForDifficultyScaling' has a wrong offset!");
static_assert(offsetof(UHWAIDifficultyConfig, MaxKDALeadForDifficultyScaling) == 0x000038, "Member 'UHWAIDifficultyConfig::MaxKDALeadForDifficultyScaling' has a wrong offset!");
static_assert(offsetof(UHWAIDifficultyConfig, bAvoidDangerousDeployables) == 0x00003C, "Member 'UHWAIDifficultyConfig::bAvoidDangerousDeployables' has a wrong offset!");
static_assert(offsetof(UHWAIDifficultyConfig, DataByDifficulty) == 0x000040, "Member 'UHWAIDifficultyConfig::DataByDifficulty' has a wrong offset!");

// Class Hemingway.HWEquipmentComponentSettings_Mulan_Evolution
// 0x00C0 (0x0100 - 0x0040)
class UHWEquipmentComponentSettings_Mulan_Evolution final : public UHWEquipmentComponentSettings
{
public:
	TMap<EHWMulanEvolutionState, float>           EvolutionThresholds;                               // 0x0040(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EHWMulanEvolutionState, struct FGameplayTag> EvolutionIcons;                                // 0x0090(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWGameplayEffect>          Evolution1StatusEffectClass;                       // 0x00E0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWGameplayEffect>          Evolution3StatsEffectClass;                        // 0x00E8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           UltAttackToGainXPFrom;                             // 0x00F0(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonGodXpPercentReduction;                          // 0x00F8(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetNonGodXpPercentReduction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponentSettings_Mulan_Evolution">();
	}
	static class UHWEquipmentComponentSettings_Mulan_Evolution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponentSettings_Mulan_Evolution>();
	}
};
static_assert(alignof(UHWEquipmentComponentSettings_Mulan_Evolution) == 0x000008, "Wrong alignment on UHWEquipmentComponentSettings_Mulan_Evolution");
static_assert(sizeof(UHWEquipmentComponentSettings_Mulan_Evolution) == 0x000100, "Wrong size on UHWEquipmentComponentSettings_Mulan_Evolution");
static_assert(offsetof(UHWEquipmentComponentSettings_Mulan_Evolution, EvolutionThresholds) == 0x000040, "Member 'UHWEquipmentComponentSettings_Mulan_Evolution::EvolutionThresholds' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Mulan_Evolution, EvolutionIcons) == 0x000090, "Member 'UHWEquipmentComponentSettings_Mulan_Evolution::EvolutionIcons' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Mulan_Evolution, Evolution1StatusEffectClass) == 0x0000E0, "Member 'UHWEquipmentComponentSettings_Mulan_Evolution::Evolution1StatusEffectClass' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Mulan_Evolution, Evolution3StatsEffectClass) == 0x0000E8, "Member 'UHWEquipmentComponentSettings_Mulan_Evolution::Evolution3StatsEffectClass' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Mulan_Evolution, UltAttackToGainXPFrom) == 0x0000F0, "Member 'UHWEquipmentComponentSettings_Mulan_Evolution::UltAttackToGainXPFrom' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Mulan_Evolution, NonGodXpPercentReduction) == 0x0000F8, "Member 'UHWEquipmentComponentSettings_Mulan_Evolution::NonGodXpPercentReduction' has a wrong offset!");

// Class Hemingway.HWAIGoal
// 0x00C0 (0x00E8 - 0x0028)
class UHWAIGoal : public UObject
{
public:
	float                                         BaseWeight;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinActiveTime;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UHWAIGoal>>          SubGoals;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bExecuteSubGoalsAsSteps;                           // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAIThreatEvaluator*                   ThreatEvaluator;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RulesOfFire;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RulesOfEngagement;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAddCharacterCustomGoals;                          // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CombatPositioningTags;                             // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWAIController>         Controller;                                        // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(EHWAIGoalStatus Status)>       CompletedDel;                                      // 0x0098(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHWAIGoal*>                      SubGoalInstances;                                  // 0x00A8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(EHWAIGoalStatus Status)>       SubGoalCompletedDel;                               // 0x00B8(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GoalActiveTime;                                    // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentStepIndex;                                  // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DebugText;                                         // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWAIGoalStatus                               CurrentStatus;                                     // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BailOnCurrentPlay();
	float CalculateWeight(class AHWAIController* InController);
	bool CheckPreconditionsBP(class AHWAIController* InController);
	void ClearBlackboardVariable(class FName VarName);
	void CollectDebugText(class FString* outDebugText, int32 TabsCount);
	void EndGoal(EHWAIGoalStatus Status, bool bTriggerCompletedDel);
	void EndGoalBP();
	void OnSubGoalCompleted(EHWAIGoalStatus Status);
	void SetActorBlackboardVariable(class FName VarName, class AActor* InValue);
	void SetBoolBlackboardVariable(class FName VarName, bool InValue);
	void SetEnumBlackboardVariable(class FName VarName, uint8 InValue);
	void SetFloatBlackboardVariable(class FName VarName, float InValue);
	void SetIntBlackboardVariable(class FName VarName, int32 InValue);
	void SetNameBlackboardVariable(class FName VarName, class FName InValue);
	void SetVectorBlackboardVariable(class FName VarName, const struct FVector& InValue);
	class AActor* SpawnDebugDisplayActor(class UClass* debugActorClass);
	void StartGoalBP();
	void TickGoalBP();
	void ToggleDebugDisplay(bool bOn);
	void UpdateDebugText();

	float CalculateMaxETAForPlayParticipants(const class AHWAIController* InController, float ArrivalDistance) const;
	class AActor* GetActorBlackboardVariable(class FName VarName) const;
	bool GetBoolBlackboardVariable(class FName VarName) const;
	class AHWCharacter_Base* GetCharacter() const;
	float GetCurrentFrameTime() const;
	struct FGameplayTag GetCurrentPlayStateTag(const class AHWCharacter_Base* SourceCharacter) const;
	uint8 GetEnumBlackboardVariable(class FName VarName) const;
	float GetFloatBlackboardVariable(class FName VarName) const;
	class AHWGameMode* GetGameMode() const;
	class AHWGameState* GetGameState() const;
	int32 GetIntBlackboardVariable(class FName VarName) const;
	class FName GetNameBlackboardVariable(class FName VarName) const;
	class AHWPlayerState* GetPlayerState() const;
	void GetPlayParticipants(TArray<class AHWCharacter_Base*>* OutParticipants) const;
	float GetTimeInGoal() const;
	float GetTimeInPlay() const;
	struct FVector GetVectorBlackboardVariable(class FName VarName) const;
	bool IsCloseEnoughToPlayActor(const class AHWAIController* InController, const class AHWCharacter_Base* Character, float ArrivalDistance) const;
	bool IsCurrentPlayStateEqualTo(const class AHWCharacter_Base* SourceCharacter, const struct FGameplayTag& Tag) const;
	bool IsInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIGoal">();
	}
	static class UHWAIGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIGoal>();
	}
};
static_assert(alignof(UHWAIGoal) == 0x000008, "Wrong alignment on UHWAIGoal");
static_assert(sizeof(UHWAIGoal) == 0x0000E8, "Wrong size on UHWAIGoal");
static_assert(offsetof(UHWAIGoal, BaseWeight) == 0x000028, "Member 'UHWAIGoal::BaseWeight' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, MinActiveTime) == 0x00002C, "Member 'UHWAIGoal::MinActiveTime' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, BehaviorTree) == 0x000030, "Member 'UHWAIGoal::BehaviorTree' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, SubGoals) == 0x000038, "Member 'UHWAIGoal::SubGoals' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, bExecuteSubGoalsAsSteps) == 0x000048, "Member 'UHWAIGoal::bExecuteSubGoalsAsSteps' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, ThreatEvaluator) == 0x000050, "Member 'UHWAIGoal::ThreatEvaluator' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, RulesOfFire) == 0x000058, "Member 'UHWAIGoal::RulesOfFire' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, RulesOfEngagement) == 0x000060, "Member 'UHWAIGoal::RulesOfEngagement' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, bAddCharacterCustomGoals) == 0x000068, "Member 'UHWAIGoal::bAddCharacterCustomGoals' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, CombatPositioningTags) == 0x000070, "Member 'UHWAIGoal::CombatPositioningTags' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, Controller) == 0x000090, "Member 'UHWAIGoal::Controller' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, CompletedDel) == 0x000098, "Member 'UHWAIGoal::CompletedDel' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, SubGoalInstances) == 0x0000A8, "Member 'UHWAIGoal::SubGoalInstances' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, SubGoalCompletedDel) == 0x0000B8, "Member 'UHWAIGoal::SubGoalCompletedDel' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, GoalActiveTime) == 0x0000C8, "Member 'UHWAIGoal::GoalActiveTime' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, CurrentStepIndex) == 0x0000CC, "Member 'UHWAIGoal::CurrentStepIndex' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, DebugText) == 0x0000D0, "Member 'UHWAIGoal::DebugText' has a wrong offset!");
static_assert(offsetof(UHWAIGoal, CurrentStatus) == 0x0000E0, "Member 'UHWAIGoal::CurrentStatus' has a wrong offset!");

// Class Hemingway.HWAILearningRecorder
// 0x0050 (0x0078 - 0x0028)
class UHWAILearningRecorder final : public USaveGame
{
public:
	float                                         SampleInterval;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSaveToJSON;                                       // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPrettyPrintJson;                                  // 0x002D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LearningDataFileName;                              // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NearbyRadius;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNearbyCount;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SaveSlotName;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SaveUserIndex;                                     // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAsyncSave;                                        // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWAILearningData                      LearningData;                                      // 0x0060(0x0010)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRecordingTimer();
	void StartRecording();
	void StopRecording();

	void GetAgentSamples(TArray<struct FHWAILearningAgentData>* OutAllSamples) const;
	void GetSamples(TArray<struct FHWAILearningSampleData>* OutAllSamples) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAILearningRecorder">();
	}
	static class UHWAILearningRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAILearningRecorder>();
	}
};
static_assert(alignof(UHWAILearningRecorder) == 0x000008, "Wrong alignment on UHWAILearningRecorder");
static_assert(sizeof(UHWAILearningRecorder) == 0x000078, "Wrong size on UHWAILearningRecorder");
static_assert(offsetof(UHWAILearningRecorder, SampleInterval) == 0x000028, "Member 'UHWAILearningRecorder::SampleInterval' has a wrong offset!");
static_assert(offsetof(UHWAILearningRecorder, bSaveToJSON) == 0x00002C, "Member 'UHWAILearningRecorder::bSaveToJSON' has a wrong offset!");
static_assert(offsetof(UHWAILearningRecorder, bPrettyPrintJson) == 0x00002D, "Member 'UHWAILearningRecorder::bPrettyPrintJson' has a wrong offset!");
static_assert(offsetof(UHWAILearningRecorder, LearningDataFileName) == 0x000030, "Member 'UHWAILearningRecorder::LearningDataFileName' has a wrong offset!");
static_assert(offsetof(UHWAILearningRecorder, NearbyRadius) == 0x000040, "Member 'UHWAILearningRecorder::NearbyRadius' has a wrong offset!");
static_assert(offsetof(UHWAILearningRecorder, MaxNearbyCount) == 0x000044, "Member 'UHWAILearningRecorder::MaxNearbyCount' has a wrong offset!");
static_assert(offsetof(UHWAILearningRecorder, SaveSlotName) == 0x000048, "Member 'UHWAILearningRecorder::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UHWAILearningRecorder, SaveUserIndex) == 0x000058, "Member 'UHWAILearningRecorder::SaveUserIndex' has a wrong offset!");
static_assert(offsetof(UHWAILearningRecorder, bAsyncSave) == 0x00005C, "Member 'UHWAILearningRecorder::bAsyncSave' has a wrong offset!");
static_assert(offsetof(UHWAILearningRecorder, LearningData) == 0x000060, "Member 'UHWAILearningRecorder::LearningData' has a wrong offset!");

// Class Hemingway.HWEnvQueryTest_CombatPositioning
// 0x0110 (0x0308 - 0x01F8)
class UHWEnvQueryTest_CombatPositioning final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x01F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              WithinIdealAttackRangeScore;                       // 0x0200(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              WithinEnemyAttackRangeScore;                       // 0x0238(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              NearAllyDistance;                                  // 0x0270(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              NearAllyScore;                                     // 0x02A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x28];                                     // 0x02E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEnvQueryTest_CombatPositioning">();
	}
	static class UHWEnvQueryTest_CombatPositioning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEnvQueryTest_CombatPositioning>();
	}
};
static_assert(alignof(UHWEnvQueryTest_CombatPositioning) == 0x000008, "Wrong alignment on UHWEnvQueryTest_CombatPositioning");
static_assert(sizeof(UHWEnvQueryTest_CombatPositioning) == 0x000308, "Wrong size on UHWEnvQueryTest_CombatPositioning");
static_assert(offsetof(UHWEnvQueryTest_CombatPositioning, Context) == 0x0001F8, "Member 'UHWEnvQueryTest_CombatPositioning::Context' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryTest_CombatPositioning, WithinIdealAttackRangeScore) == 0x000200, "Member 'UHWEnvQueryTest_CombatPositioning::WithinIdealAttackRangeScore' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryTest_CombatPositioning, WithinEnemyAttackRangeScore) == 0x000238, "Member 'UHWEnvQueryTest_CombatPositioning::WithinEnemyAttackRangeScore' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryTest_CombatPositioning, NearAllyDistance) == 0x000270, "Member 'UHWEnvQueryTest_CombatPositioning::NearAllyDistance' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryTest_CombatPositioning, NearAllyScore) == 0x0002A8, "Member 'UHWEnvQueryTest_CombatPositioning::NearAllyScore' has a wrong offset!");

// Class Hemingway.HWAILearningRecorderBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UHWAILearningRecorderBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void LoadAILearningRecordingFromJson(const class FString& LearningDataFileName, TArray<struct FHWAILearningAgentData>* OutAllSamples);
	static void LoadAILearningRecordingFromSlot(const class FString& SaveSlotName, int32 UserIndex, TArray<struct FHWAILearningAgentData>* OutAllSamples);
	static void LoadAILearningRecordingFromSlotWithTimeStamps(const class FString& SaveSlotName, int32 UserIndex, TArray<struct FHWAILearningSampleData>* OutAllSamples);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAILearningRecorderBlueprintLibrary">();
	}
	static class UHWAILearningRecorderBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAILearningRecorderBlueprintLibrary>();
	}
};
static_assert(alignof(UHWAILearningRecorderBlueprintLibrary) == 0x000008, "Wrong alignment on UHWAILearningRecorderBlueprintLibrary");
static_assert(sizeof(UHWAILearningRecorderBlueprintLibrary) == 0x000028, "Wrong size on UHWAILearningRecorderBlueprintLibrary");

// Class Hemingway.HWAbilityAimSettings_LockOn
// 0x01F8 (0x0260 - 0x0068)
class UHWAbilityAimSettings_LockOn : public UHWAbilityAimSettings
{
public:
	EHWAimSettingLockOnCalcBehavior               LockOnCalcBehavior;                                // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityAimSettings*                  LockOnAimSettings;                                 // 0x0070(0x0008)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityAttackSettings_InstantShape*  LockOnShapeAttackSettings;                         // 0x0078(0x0008)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         GlobalLockOnTargetTypeFlags;                       // 0x0080(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityAttackSettings_Wedge*         GlobalLockOnWedgeAttackSettings;                   // 0x0088(0x0008)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWGameplayTargetDataFilter            AcceptableTargetFilter;                            // 0x0090(0x01D0)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSettings_LockOn">();
	}
	static class UHWAbilityAimSettings_LockOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSettings_LockOn>();
	}
};
static_assert(alignof(UHWAbilityAimSettings_LockOn) == 0x000008, "Wrong alignment on UHWAbilityAimSettings_LockOn");
static_assert(sizeof(UHWAbilityAimSettings_LockOn) == 0x000260, "Wrong size on UHWAbilityAimSettings_LockOn");
static_assert(offsetof(UHWAbilityAimSettings_LockOn, LockOnCalcBehavior) == 0x000068, "Member 'UHWAbilityAimSettings_LockOn::LockOnCalcBehavior' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_LockOn, LockOnAimSettings) == 0x000070, "Member 'UHWAbilityAimSettings_LockOn::LockOnAimSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_LockOn, LockOnShapeAttackSettings) == 0x000078, "Member 'UHWAbilityAimSettings_LockOn::LockOnShapeAttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_LockOn, GlobalLockOnTargetTypeFlags) == 0x000080, "Member 'UHWAbilityAimSettings_LockOn::GlobalLockOnTargetTypeFlags' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_LockOn, GlobalLockOnWedgeAttackSettings) == 0x000088, "Member 'UHWAbilityAimSettings_LockOn::GlobalLockOnWedgeAttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_LockOn, AcceptableTargetFilter) == 0x000090, "Member 'UHWAbilityAimSettings_LockOn::AcceptableTargetFilter' has a wrong offset!");

// Class Hemingway.HWEventHandlerBase
// 0x0000 (0x0028 - 0x0028)
class UHWEventHandlerBase : public UObject
{
public:
	void OnEventEnd(const struct FHWEventConfig& EventConfig);
	void OnEventStart(const struct FHWEventConfig& EventConfig, const struct FHWEventContext& EventContext);

	bool ShouldOverrideDuration(const struct FHWEventConfig& EventConfig, const struct FHWEventContext& EventContext, float* OutDuration) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEventHandlerBase">();
	}
	static class UHWEventHandlerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEventHandlerBase>();
	}
};
static_assert(alignof(UHWEventHandlerBase) == 0x000008, "Wrong alignment on UHWEventHandlerBase");
static_assert(sizeof(UHWEventHandlerBase) == 0x000028, "Wrong size on UHWEventHandlerBase");

// Class Hemingway.HWAimSettings_Danzaburou_A04
// 0x0000 (0x0260 - 0x0260)
class UHWAimSettings_Danzaburou_A04 final : public UHWAbilityAimSettings_LockOn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAimSettings_Danzaburou_A04">();
	}
	static class UHWAimSettings_Danzaburou_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAimSettings_Danzaburou_A04>();
	}
};
static_assert(alignof(UHWAimSettings_Danzaburou_A04) == 0x000008, "Wrong alignment on UHWAimSettings_Danzaburou_A04");
static_assert(sizeof(UHWAimSettings_Danzaburou_A04) == 0x000260, "Wrong size on UHWAimSettings_Danzaburou_A04");

// Class Hemingway.HWAIPerceptionComponent
// 0x0008 (0x0198 - 0x0190)
class UHWAIPerceptionComponent : public UAIPerceptionComponent
{
public:
	class FName                                   IdTag;                                             // 0x0190(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FName GetIdTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPerceptionComponent">();
	}
	static class UHWAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPerceptionComponent>();
	}
};
static_assert(alignof(UHWAIPerceptionComponent) == 0x000008, "Wrong alignment on UHWAIPerceptionComponent");
static_assert(sizeof(UHWAIPerceptionComponent) == 0x000198, "Wrong size on UHWAIPerceptionComponent");
static_assert(offsetof(UHWAIPerceptionComponent, IdTag) == 0x000190, "Member 'UHWAIPerceptionComponent::IdTag' has a wrong offset!");

// Class Hemingway.HWGameplayCueNotify_Actor
// 0x0050 (0x0368 - 0x0318)
class AHWGameplayCueNotify_Actor : public AGameplayCueNotify_Actor
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldVisibilityComponentManageCue;               // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0xB];                                      // 0x0321(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bGroundCue;                                        // 0x032C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWFriendlyEnemyReferenceActorChoice          FriendlyEnemyReferenceActorChoice;                 // 0x032D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32E[0x2];                                      // 0x032E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMeshComponent*>                 RuntimeCreatedMeshComponents;                      // 0x0330(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EventTags;                                         // 0x0340(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnGameplayEventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	void HandleLocalOwnerVisibilityComponentUpdated(class UHWVisibilityComponent* VisibilityComponent);
	void HandleLocalOwnerVisibilityUpdated(class UHWVisibilityComponent* VisibilityComponent);
	void SetSkinnedData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_Actor">();
	}
	static class AHWGameplayCueNotify_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameplayCueNotify_Actor>();
	}
};
static_assert(alignof(AHWGameplayCueNotify_Actor) == 0x000008, "Wrong alignment on AHWGameplayCueNotify_Actor");
static_assert(sizeof(AHWGameplayCueNotify_Actor) == 0x000368, "Wrong size on AHWGameplayCueNotify_Actor");
static_assert(offsetof(AHWGameplayCueNotify_Actor, bShouldVisibilityComponentManageCue) == 0x000320, "Member 'AHWGameplayCueNotify_Actor::bShouldVisibilityComponentManageCue' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Actor, bGroundCue) == 0x00032C, "Member 'AHWGameplayCueNotify_Actor::bGroundCue' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Actor, FriendlyEnemyReferenceActorChoice) == 0x00032D, "Member 'AHWGameplayCueNotify_Actor::FriendlyEnemyReferenceActorChoice' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Actor, RuntimeCreatedMeshComponents) == 0x000330, "Member 'AHWGameplayCueNotify_Actor::RuntimeCreatedMeshComponents' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Actor, EventTags) == 0x000340, "Member 'AHWGameplayCueNotify_Actor::EventTags' has a wrong offset!");

// Class Hemingway.HWGameplayCueNotify_MapTeleport
// 0x0048 (0x03B0 - 0x0368)
class AHWGameplayCueNotify_MapTeleport : public AHWGameplayCueNotify_Actor
{
public:
	class USkeletalMesh*                          DefaultMeshToApply;                                // 0x0368(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 AnimInstanceClassRef;                              // 0x0370(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MeshAssetLookupName;                               // 0x0378(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x30];                                     // 0x0380(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_MapTeleport">();
	}
	static class AHWGameplayCueNotify_MapTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameplayCueNotify_MapTeleport>();
	}
};
static_assert(alignof(AHWGameplayCueNotify_MapTeleport) == 0x000008, "Wrong alignment on AHWGameplayCueNotify_MapTeleport");
static_assert(sizeof(AHWGameplayCueNotify_MapTeleport) == 0x0003B0, "Wrong size on AHWGameplayCueNotify_MapTeleport");
static_assert(offsetof(AHWGameplayCueNotify_MapTeleport, DefaultMeshToApply) == 0x000368, "Member 'AHWGameplayCueNotify_MapTeleport::DefaultMeshToApply' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_MapTeleport, AnimInstanceClassRef) == 0x000370, "Member 'AHWGameplayCueNotify_MapTeleport::AnimInstanceClassRef' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_MapTeleport, MeshAssetLookupName) == 0x000378, "Member 'AHWGameplayCueNotify_MapTeleport::MeshAssetLookupName' has a wrong offset!");

// Class Hemingway.HWGameplayEffect
// 0x0018 (0x0AB8 - 0x0AA0)
class UHWGameplayEffect : public UGameplayEffect
{
public:
	EHWEffectApplicationPolicy                    ApplicationPolicy;                                 // 0x0AA0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA1[0x3];                                      // 0x0AA1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ApplicationTag;                                    // 0x0AA4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyInhibitSameInstigatorEffects;                 // 0x0AAC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AAD[0x3];                                      // 0x0AAD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           KeywordTag;                                        // 0x0AB0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 BP_GetStackLimitCount();

	EHWEffectApplicationPolicy GetApplicationPolicy() const;
	float GetApplicationStrength(const struct FGameplayEffectSpec& RelevantSpec) const;
	struct FGameplayTag GetApplicationTag() const;
	struct FGameplayTag GetKeywordTag() const;
	bool ShouldOnlyInhibitSameInstigatorEffects() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect">();
	}
	static class UHWGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect>();
	}
};
static_assert(alignof(UHWGameplayEffect) == 0x000008, "Wrong alignment on UHWGameplayEffect");
static_assert(sizeof(UHWGameplayEffect) == 0x000AB8, "Wrong size on UHWGameplayEffect");
static_assert(offsetof(UHWGameplayEffect, ApplicationPolicy) == 0x000AA0, "Member 'UHWGameplayEffect::ApplicationPolicy' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect, ApplicationTag) == 0x000AA4, "Member 'UHWGameplayEffect::ApplicationTag' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect, bOnlyInhibitSameInstigatorEffects) == 0x000AAC, "Member 'UHWGameplayEffect::bOnlyInhibitSameInstigatorEffects' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect, KeywordTag) == 0x000AB0, "Member 'UHWGameplayEffect::KeywordTag' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Undying
// 0x0008 (0x0AC0 - 0x0AB8)
class UHWGameplayEffect_Undying final : public UHWGameplayEffect
{
public:
	EUndyingThresholdType                         UndyingHealthThresholdType;                        // 0x0AB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB9[0x3];                                      // 0x0AB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UndyingHealthThresholdValue;                       // 0x0ABC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Undying">();
	}
	static class UHWGameplayEffect_Undying* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Undying>();
	}
};
static_assert(alignof(UHWGameplayEffect_Undying) == 0x000008, "Wrong alignment on UHWGameplayEffect_Undying");
static_assert(sizeof(UHWGameplayEffect_Undying) == 0x000AC0, "Wrong size on UHWGameplayEffect_Undying");
static_assert(offsetof(UHWGameplayEffect_Undying, UndyingHealthThresholdType) == 0x000AB8, "Member 'UHWGameplayEffect_Undying::UndyingHealthThresholdType' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Undying, UndyingHealthThresholdValue) == 0x000ABC, "Member 'UHWGameplayEffect_Undying::UndyingHealthThresholdValue' has a wrong offset!");

// Class Hemingway.HWAIPlayLogic
// 0x0040 (0x0068 - 0x0028)
class UHWAIPlayLogic : public UObject
{
public:
	TArray<TWeakObjectPtr<class AHWCharacter_Base>> Participants;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvalidatePlay;                                   // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinExecutionTime;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  AssociatedActor;                                   // 0x0044(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    Handle;                                            // 0x0050(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CurrentPlayState;                                  // 0x0060(0x0008)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InvalidatePlay();

	class AActor* GetAssociatedActor() const;
	struct FGameplayTag GetCurrentPlayState() const;
	struct FDataTableRowHandle GetHandle() const;
	float GetMinExecutionTime() const;
	void GetParticipants(TArray<class AHWCharacter_Base*>* OutParticipants) const;
	float GetPlayTime() const;
	bool HasParticipantsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic">();
	}
	static class UHWAIPlayLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic>();
	}
};
static_assert(alignof(UHWAIPlayLogic) == 0x000008, "Wrong alignment on UHWAIPlayLogic");
static_assert(sizeof(UHWAIPlayLogic) == 0x000068, "Wrong size on UHWAIPlayLogic");
static_assert(offsetof(UHWAIPlayLogic, Participants) == 0x000028, "Member 'UHWAIPlayLogic::Participants' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic, StartTime) == 0x000038, "Member 'UHWAIPlayLogic::StartTime' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic, bInvalidatePlay) == 0x00003C, "Member 'UHWAIPlayLogic::bInvalidatePlay' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic, MinExecutionTime) == 0x000040, "Member 'UHWAIPlayLogic::MinExecutionTime' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic, AssociatedActor) == 0x000044, "Member 'UHWAIPlayLogic::AssociatedActor' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic, Handle) == 0x000050, "Member 'UHWAIPlayLogic::Handle' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic, CurrentPlayState) == 0x000060, "Member 'UHWAIPlayLogic::CurrentPlayState' has a wrong offset!");

// Class Hemingway.HWAIPlayLogic_GankCharacter
// 0x0030 (0x0098 - 0x0068)
class UHWAIPlayLogic_GankCharacter : public UHWAIPlayLogic
{
public:
	float                                         MinHealthPercentForGanker;                         // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinHealthPercentForGankee;                         // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthPercentWeight;                               // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceFromGankee;                             // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TooCloseToTowerDistance;                           // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TooCloseToTowerWeight;                             // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloseToAllyDistance;                               // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloseToAllyWeight;                                 // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TowerSafetyRange;                                  // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinGankeeLevel;                                    // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasRolledForTowerDive;                            // 0x0090(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDiveTower;                                        // 0x0091(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_GankCharacter">();
	}
	static class UHWAIPlayLogic_GankCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_GankCharacter>();
	}
};
static_assert(alignof(UHWAIPlayLogic_GankCharacter) == 0x000008, "Wrong alignment on UHWAIPlayLogic_GankCharacter");
static_assert(sizeof(UHWAIPlayLogic_GankCharacter) == 0x000098, "Wrong size on UHWAIPlayLogic_GankCharacter");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, MinHealthPercentForGanker) == 0x000068, "Member 'UHWAIPlayLogic_GankCharacter::MinHealthPercentForGanker' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, MinHealthPercentForGankee) == 0x00006C, "Member 'UHWAIPlayLogic_GankCharacter::MinHealthPercentForGankee' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, HealthPercentWeight) == 0x000070, "Member 'UHWAIPlayLogic_GankCharacter::HealthPercentWeight' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, MaxDistanceFromGankee) == 0x000074, "Member 'UHWAIPlayLogic_GankCharacter::MaxDistanceFromGankee' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, TooCloseToTowerDistance) == 0x000078, "Member 'UHWAIPlayLogic_GankCharacter::TooCloseToTowerDistance' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, TooCloseToTowerWeight) == 0x00007C, "Member 'UHWAIPlayLogic_GankCharacter::TooCloseToTowerWeight' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, CloseToAllyDistance) == 0x000080, "Member 'UHWAIPlayLogic_GankCharacter::CloseToAllyDistance' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, CloseToAllyWeight) == 0x000084, "Member 'UHWAIPlayLogic_GankCharacter::CloseToAllyWeight' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, TowerSafetyRange) == 0x000088, "Member 'UHWAIPlayLogic_GankCharacter::TowerSafetyRange' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, MinGankeeLevel) == 0x00008C, "Member 'UHWAIPlayLogic_GankCharacter::MinGankeeLevel' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, bHasRolledForTowerDive) == 0x000090, "Member 'UHWAIPlayLogic_GankCharacter::bHasRolledForTowerDive' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_GankCharacter, bDiveTower) == 0x000091, "Member 'UHWAIPlayLogic_GankCharacter::bDiveTower' has a wrong offset!");

// Class Hemingway.HWGameMode
// 0x0A38 (0x0EC0 - 0x0488)
class AHWGameMode : public ARHGameModeBase
{
public:
	TSubclassOf<class AHUD>                       SpectatorHUDClass;                                 // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GameModeTypeTag;                                   // 0x04A0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x70];                                     // 0x04A8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FHWPartyMembers>   ActivePartiesInMatch;                              // 0x0518(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bHasCachedMatchmakingProfileId;                    // 0x0568(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           UploadInstanceLogsWithPhase;                       // 0x056C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_574[0xC];                                      // 0x0574(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           NetworkedGameSessionStartPhase;                    // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           LocalPlayStartPhase;                               // 0x0588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHWGamePhaseConfig>             PhaseList;                                         // 0x0590(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         ShutdownOnEmptyDelay;                              // 0x05A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A4[0xC];                                      // 0x05A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWPersistentPlayerId>          LockedPhaseRulePlayers;                            // 0x05B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TransitionInfoTag;                                 // 0x05C0(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUploadLogsWithMatchEndInfo;                       // 0x05C8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUploadInstanceLog;                                // 0x05C9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUploadCombatLog;                                  // 0x05CA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUploadStatsLog;                                   // 0x05CB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CombatLogFilePrefix;                               // 0x05D0(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CombatLogFileExtension;                            // 0x05E0(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 StatsLogFilePrefix;                                // 0x05F0(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 StatsLogFileExtension;                             // 0x0600(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DiagnosticsFilePrefix;                             // 0x0610(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DiagnosticsFileExtension;                          // 0x0620(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ChatLogFilePrefix;                                 // 0x0630(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ChatLogFileExtension;                              // 0x0640(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FDamageEventData& KillEventData)> OnPlayerDiedDelegate; // 0x0650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            OnKilledReward;                                    // 0x0660(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bModeShouldGrantFirstBloodBonus;                   // 0x0668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_669[0x7];                                      // 0x0669(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AwardLastHitGoldNPCTags;                           // 0x0670(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            OnKilledTeamReward;                                // 0x0690(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FVector2D>   LowestXPConfigMap;                                 // 0x0698(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 DeserterPenalties;                                 // 0x06E8(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	float                                         DeserterResetHours;                                // 0x06F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6FC[0x4];                                      // 0x06FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeserterId;                                        // 0x0700(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           PrimaryDeserterCheckHandle;                        // 0x0710(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillAssistRange;                                   // 0x0718(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GodKillAssistEligibilityDuration;                  // 0x071C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPCKillAssistEligibilityDuration;                  // 0x0720(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_724[0x4];                                      // 0x0724(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AHWRespawnManager>          RespawnManagerClass;                               // 0x0728(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWRespawnManager*                      RespawnManager;                                    // 0x0730(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_738[0x70];                                     // 0x0738(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWCharacterItem*                       DefaultCharacter;                                  // 0x07A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FHWPersistentPlayerId, class AHWPlayerStart*> PlayerIdToSpawnPointMap;               // 0x07B0(0x0050)(Protected, NativeAccessSpecifierProtected)
	bool                                          bHoldingPlayerLogins;                              // 0x0800(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_801[0x7];                                      // 0x0801(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPendingLoginDetails>           PendingPlayerLogins;                               // 0x0808(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FString                                 LobbyConnectionStatus;                             // 0x0818(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SeamlessTravelPreviousCount;                       // 0x0828(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumConnectedPlayerAtSeamlessTravel;                // 0x082C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPrespawnedPlayerPicks;                            // 0x0830(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopConnectionStateUpdates;                       // 0x0831(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_832[0x2];                                      // 0x0832(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LobbySelectLoadTimeout;                            // 0x0834(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_838[0x10];                                     // 0x0838(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           BotDifficultyTag;                                  // 0x0848(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHWGodBotMapSetupData*>          OrderGodBots;                                      // 0x0850(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UHWGodBotMapSetupData*>          ChaosGodBots;                                      // 0x0860(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDataTableRowHandle>            AIGodBotFriendlyPlays;                             // 0x0870(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDataTableRowHandle>            AIGodBotOpposingPlays;                             // 0x0880(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AHWPlayCallSuggestionManager> PlayCallManagerClass;                            // 0x0890(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOptInToPlayCallManager;                           // 0x0898(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_899[0x7];                                      // 0x0899(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         GodBotFakePlayerNames;                             // 0x08A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWAIGoal>                  GodBotGoalTreeRootClass;                           // 0x08B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWAIGoal>                  AIBotTakeoverGoalTree;                             // 0x08B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWAIPerceptionComponent>   AIBotTakeoverPerceptionComponent;                  // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnGodBots;                                     // 0x08C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C9[0x3];                                      // 0x08C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxOrderGodBotsToSpawn;                            // 0x08CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxChaosGodBotsToSpawn;                            // 0x08D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D4[0x4];                                      // 0x08D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWAIDifficultyConfig*>          GodBotDifficultyConfigs;                           // 0x08D8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentOrderGodBotDifficulty;                      // 0x08E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentChaosGodBotDifficulty;                      // 0x08EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 ChosenFakeGodBotNames;                             // 0x08F0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class UHWAIPlayCaller*                        OrderPlayCaller;                                   // 0x0900(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAIPlayCaller*                        ChaosPlayCaller;                                   // 0x0908(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EHWBotDifficulty, class UHWAIDifficultyConfig*> DifficultyConfigMap;                        // 0x0910(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         OrderRestrictedDynamicFillGodBots;                 // 0x0960(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         ChaosRestrictedDynamicFillGodBots;                 // 0x0970(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDisconnectAIBotWhenAPlayerDisconnects;            // 0x0980(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWantsSpawnBotsOnBeginPlay;                        // 0x0981(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_982[0x6];                                      // 0x0982(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     OrderGodBotNavigationFilter;                       // 0x0988(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     ChaosGodBotNavigationFilter;                       // 0x0990(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   OrderGodBotDangerZoneNavArea;                      // 0x0998(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   ChaosGodBotDangerZoneNavArea;                      // 0x09A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   NeutralGodBotDangerZoneNavArea;                    // 0x09A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySet*                          PlayerModifiersAbilitySet;                         // 0x09B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AHWPlayerState*, struct FHWAbilitySet_GrantedHandles> GrantedPlayerModifierMap;       // 0x09B8(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         TeamIdOrder;                                       // 0x0A08(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamIdChaos;                                       // 0x0A0C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamIdNeutral;                                     // 0x0A10(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamIdSpectator;                                   // 0x0A14(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamCount;                                         // 0x0A18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEditorGenerateReplay;                       // 0x0A1C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoBuildSelectorEnabled;                         // 0x0A1D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1E[0x2];                                      // 0x0A1E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              ItemStoreDataTable;                                // 0x0A20(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWEquipmentItemSortingConfig*          ItemStoreSortingData;                              // 0x0A48(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultItemResalePercentage;                       // 0x0A50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A54[0x4];                                      // 0x0A54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemTagFloatPair>              ItemResalePercentageOverrides;                     // 0x0A58(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsInitiallySpawningCharacters;                    // 0x0A68(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasPassedInitialClientLoading;                    // 0x0A69(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A6A[0x6];                                      // 0x0A6A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FGameplayTag>              KillCountToKillstreakAccoladeTagMap;               // 0x0A70(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGameplayTag> NPCTypeToNPCKillAccoladeTagMap;                   // 0x0AC0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           GameModeInfoTag;                                   // 0x0B10(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWDraftRules>              CharacterDraftRules;                               // 0x0B18(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWDraftAuthority*                      DraftAuthority;                                    // 0x0B20(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWSkinSelectRules>         SkinSelectRules;                                   // 0x0B28(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalSkinSelectionTime;                       // 0x0B30(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndOfDraftTime;                                    // 0x0B34(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndOfDraftTimeRanked;                              // 0x0B38(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoSkinSelect;                                     // 0x0B3C(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B3D[0x3];                                      // 0x0B3D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FDraftPlayerIdHandle, class AHWSkinSelectAuthority*> SkinSelectAuthorities;          // 0x0B40(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bBlockAttemptToEndSkinSelectPhase;                 // 0x0B90(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B91[0x3];                                      // 0x0B91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StatsSnapshotFrequencySeconds;                     // 0x0B94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           StartStatsWithPhase;                               // 0x0B98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SubmitMatchDataWithPhase;                          // 0x0BA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           EndGetGudWithPhase;                                // 0x0BA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB0[0x8];                                      // 0x0BB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SurrenderAllowedGamePhasesInMatchMadeGame;         // 0x0BB8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SurrenderAllowedGamePhasesInCustomGame;            // 0x0BD8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         SurrenderTimeLimit;                                // 0x0BF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinGameTimeBeforeSurrender;                        // 0x0BFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinGameTimeForEarlySurrender;                      // 0x0C00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisconnectThresholdForEarlySurrender;              // 0x0C04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EarlySurrenderLossPrevention;                      // 0x0C08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EarlySurrenderDisconnectPenalty;                   // 0x0C0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EarlySurrenderWinLimit;                            // 0x0C10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownTimeBetweenSurrenderAttempts;              // 0x0C14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EarlySurrenderTeam;                                // 0x0C18(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1C[0x4];                                      // 0x0C1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  PauseAllowedGamePhasesInMatchMadeGame;             // 0x0C20(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  PauseAllowedGamePhasesInCustomGame;                // 0x0C40(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         PauseTimeLimit;                                    // 0x0C60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PauseVoteTimeLimit;                                // 0x0C64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinGameTimeBeforePause;                            // 0x0C68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownTimeBetweenPauseAttempts;                  // 0x0C6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UnpauseDelay;                                      // 0x0C70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSuccessfulPausesInMatchmadeGame;                // 0x0C74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSuccessfulPausesInCustom;                       // 0x0C78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C7C[0x4];                                      // 0x0C7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWTeamState*                           PausingTeam;                                       // 0x0C80(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C88[0x40];                                     // 0x0C88(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              SystemMessageDTSoftPtr;                            // 0x0CC8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  QuestFlags;                                        // 0x0CF0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           StartQuestsWithPhase;                              // 0x0D10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SubmitsQuestsWithPhase;                            // 0x0D18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableQuestsInAllMatches;                         // 0x0D20(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldCalculateTrueSkill;                         // 0x0D21(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D22[0x16];                                     // 0x0D22(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWRankedConfig>         RankedConfig;                                      // 0x0D38(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCalculateSkillRating;                       // 0x0D60(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D61[0x7];                                      // 0x0D61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWRoleConfig>           RoleConfig;                                        // 0x0D68(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimapSize;                                       // 0x0D90(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D94[0x4];                                      // 0x0D94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UWorld>                  LumenLightingSubLevel;                             // 0x0D98(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  NoLumenLightingSubLevel;                           // 0x0DC0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableTextChatFloodProtection;                    // 0x0DE8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE9[0x3];                                      // 0x0DE9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextChatFloodProtectionTimeWindow;                 // 0x0DEC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TextChatFloodProtectionMessageLimit;               // 0x0DF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TextChatFloodProtectionCooldownTime;               // 0x0DF4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableVGSFloodProtection;                         // 0x0DF8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DF9[0x7];                                      // 0x0DF9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EHWVGSFloodProtectionType, struct FHWVGSFloodProtectionData> FloodProtectionData;           // 0x0E00(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnablePingFloodProtection;                        // 0x0E50(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E51[0x3];                                      // 0x0E51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PingFloodProtectionTimeWindow;                     // 0x0E54(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PingFloodProtectionMessageLimit;                   // 0x0E58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PingFloodProtectionCooldownTime;                   // 0x0E5C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentlyTrackingPlayerBehaviors;                 // 0x0E60(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E61[0x3];                                      // 0x0E61(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AFKDurationThreshold;                              // 0x0E64(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AFKWarningThreshold;                               // 0x0E68(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasAlreadyLoggedSessionData;                      // 0x0E6C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E6D[0x3];                                      // 0x0E6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           CharacterInGameMaterialCollection;                 // 0x0E70(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayerXPForNPEBoost;                            // 0x0E78(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPEBoostReceiptId;                                 // 0x0E7C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPEBoostReceiptLootId;                             // 0x0E80(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNPEBoostsPerPlayer;                             // 0x0E84(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        NPEBoostAbilityPath;                               // 0x0E88(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA8[0x10];                                     // 0x0EA8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySet*                          NPEBoostAbilitySet;                                // 0x0EB8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddNPEBoostsToPlayer(class AHWPlayerController* TrackedPlayerController);
	void AddPhaseRulesToNewTeamMember(class AHWPlayerState* NewMember);
	void ApplyGameModeModifiersToPlayer(class AHWPlayerState* PlayerState);
	void BroadcastConnectionStates();
	void BroadcastMatchComposition();
	void CacheMatchmadeProfileId();
	void CaptureMatchSnapshot();
	void CheckForAddingNPEBoosts();
	void CombatLogRewards(class AHWCharacter_Base* RewardSource, class AHWCharacter_Base* RewardTarget, uint8 EventType, int32 Quantity, uint8 RewardType);
	void DeactivatePhaseRulesFromOldTeamMember(class AHWPlayerState* OldMember);
	bool DoesPlayerMeetNPEBoostCriteria(class AHWPlayerController* TrackedPlayerController);
	void DynamicallySelectGodBotCharacters();
	void EndMatchOnSurrender(const class AHWTeamState* TeamState);
	void FillTeamsWithAIPlayers();
	float GetRespawnDelayTime(class AHWPlayerState* PlayerState);
	void GoToMatchPhase(const struct FGameplayTag& NextPhaseTag);
	void HandleKillCreditDeath(class AHWCharacter_Base* KilledCharacter, class AHWCharacter_Base* Killer, const TArray<struct FHWAssistCandidate>& AssistingTeamMembers);
	void InitializePlayerBehaviorTracking();
	bool IsMatchmadeQueue();
	bool IsShopUnrestrictedForStartup();
	void LockPhaseRulesDuringTransferFor(const struct FHWPersistentPlayerId& TransferringPlayerId);
	void LogRHSessionData();
	bool ModeSupportsQuests();
	void PendingLoginDisconnected(class URH_IpConnection* Connection);
	void PlayerStateChangedClientLoadStatus();
	void RemoveGameModeModifiersFromAllPlayers();
	void RemoveGameModeModifiersFromPlayer(class AHWPlayerState* PlayerState);
	void RestartPlayerWithCharacter(class AController* ControllerToRestart, const class UHWCharacterItem* CharacterToGive, const class UHWSkinItem* SkinToGive, class AActor* StartSpot, const bool bFullyResetCharacter);
	void SendMatchCompositionToPlayer(class UNetConnection* Connection, const struct FHWInstanceInfo_PlayerDataList& PlayerDataList);
	void SessionDataChangeTriggered();
	void SetCurrentMatchPhaseDuration(float NewPhaseDuration);
	void SetGameModeFinishedWaitingOnLoadScreens(bool bFinishedWaiting);
	void UnlockPhaseRulesAfterTransferFor(const struct FHWPersistentPlayerId& TransferringPlayerId);
	bool WantsToInitializePlayerBehaviorTracking();

	float ApplyNpcAssistGoldFormula(const float BaseValue, const int32 ContributorCount) const;
	float ApplyNpcAssistXpFormula(const float BaseValue, const int32 ContributorCount) const;
	float ApplyNpcKillGoldFormula(const float BaseValue, const int32 ContributorCount) const;
	float ApplyNpcKillXpFormula(const float BaseValue, const int32 ContributorCount) const;
	float CalcPlayerAssistGoldReward(class AHWCharacter_PlayableCharacter* VictimPlayer, class AHWCharacter_Base* AssistingPlayer, const int32 AssisterCount) const;
	float CalcPlayerAssistXpReward(class AHWCharacter_PlayableCharacter* VictimPlayer, class AHWCharacter_Base* AssistingPlayer, const int32 AssisterCount) const;
	float CalcPlayerKillGoldReward(class AHWCharacter_PlayableCharacter* VictimPlayer, class AHWCharacter_Base* KillerPlayer, const bool bApplyFirstBloodBonus) const;
	float CalcPlayerKillXpReward(class AHWCharacter_PlayableCharacter* VictimPlayer, class AHWCharacter_Base* KillerPlayer) const;
	bool CurrentlyTrackingPlayerBehaviors() const;
	bool DoesNPCAwardLastHitGold(const class UHWAbilitySystemComponent* KilledNPCASC) const;
	class UHWAIPlayCaller* GetChaosPlayCaller() const;
	struct FGenericTeamId GetChaosTeamId() const;
	struct FGameplayTag GetCurrentMatchPhaseTag() const;
	struct FGameplayTag GetGameModeTypeTag() const;
	class UHWAIDifficultyConfig* GetGodBotDifficultyConfig(const struct FGenericTeamId& Team) const;
	class UHWAIDifficultyConfig* GetGodBotDifficultyConfigForOpposingTeam(const struct FGenericTeamId& Team) const;
	struct FGenericTeamId GetNeutralTeamId() const;
	float GetNpcLastHitGoldMultiplier() const;
	bool GetOpposingTeamIds(const struct FGenericTeamId& TeamId, TArray<struct FGenericTeamId>* OpposingTeamIds) const;
	class UHWAIPlayCaller* GetOrderPlayCaller() const;
	struct FGenericTeamId GetOrderTeamId() const;
	class UHWAIPlayCaller* GetPlayCaller(const struct FGenericTeamId& TeamId) const;
	const class UHWAbilitySet* GetPlayerModifiersAbilitySet() const;
	struct FGameplayTag GetTransitionInfoTag() const;
	bool IsANPCTeam(int32 TeamId) const;
	bool IsAPlayerTeam(int32 TeamId) const;
	bool IsASpectatorTeam(int32 TeamId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameMode">();
	}
	static class AHWGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameMode>();
	}
};
static_assert(alignof(AHWGameMode) == 0x000008, "Wrong alignment on AHWGameMode");
static_assert(sizeof(AHWGameMode) == 0x000EC0, "Wrong size on AHWGameMode");
static_assert(offsetof(AHWGameMode, SpectatorHUDClass) == 0x000488, "Member 'AHWGameMode::SpectatorHUDClass' has a wrong offset!");
static_assert(offsetof(AHWGameMode, GameModeTypeTag) == 0x0004A0, "Member 'AHWGameMode::GameModeTypeTag' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ActivePartiesInMatch) == 0x000518, "Member 'AHWGameMode::ActivePartiesInMatch' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bHasCachedMatchmakingProfileId) == 0x000568, "Member 'AHWGameMode::bHasCachedMatchmakingProfileId' has a wrong offset!");
static_assert(offsetof(AHWGameMode, UploadInstanceLogsWithPhase) == 0x00056C, "Member 'AHWGameMode::UploadInstanceLogsWithPhase' has a wrong offset!");
static_assert(offsetof(AHWGameMode, NetworkedGameSessionStartPhase) == 0x000580, "Member 'AHWGameMode::NetworkedGameSessionStartPhase' has a wrong offset!");
static_assert(offsetof(AHWGameMode, LocalPlayStartPhase) == 0x000588, "Member 'AHWGameMode::LocalPlayStartPhase' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PhaseList) == 0x000590, "Member 'AHWGameMode::PhaseList' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ShutdownOnEmptyDelay) == 0x0005A0, "Member 'AHWGameMode::ShutdownOnEmptyDelay' has a wrong offset!");
static_assert(offsetof(AHWGameMode, LockedPhaseRulePlayers) == 0x0005B0, "Member 'AHWGameMode::LockedPhaseRulePlayers' has a wrong offset!");
static_assert(offsetof(AHWGameMode, TransitionInfoTag) == 0x0005C0, "Member 'AHWGameMode::TransitionInfoTag' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bUploadLogsWithMatchEndInfo) == 0x0005C8, "Member 'AHWGameMode::bUploadLogsWithMatchEndInfo' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bUploadInstanceLog) == 0x0005C9, "Member 'AHWGameMode::bUploadInstanceLog' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bUploadCombatLog) == 0x0005CA, "Member 'AHWGameMode::bUploadCombatLog' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bUploadStatsLog) == 0x0005CB, "Member 'AHWGameMode::bUploadStatsLog' has a wrong offset!");
static_assert(offsetof(AHWGameMode, CombatLogFilePrefix) == 0x0005D0, "Member 'AHWGameMode::CombatLogFilePrefix' has a wrong offset!");
static_assert(offsetof(AHWGameMode, CombatLogFileExtension) == 0x0005E0, "Member 'AHWGameMode::CombatLogFileExtension' has a wrong offset!");
static_assert(offsetof(AHWGameMode, StatsLogFilePrefix) == 0x0005F0, "Member 'AHWGameMode::StatsLogFilePrefix' has a wrong offset!");
static_assert(offsetof(AHWGameMode, StatsLogFileExtension) == 0x000600, "Member 'AHWGameMode::StatsLogFileExtension' has a wrong offset!");
static_assert(offsetof(AHWGameMode, DiagnosticsFilePrefix) == 0x000610, "Member 'AHWGameMode::DiagnosticsFilePrefix' has a wrong offset!");
static_assert(offsetof(AHWGameMode, DiagnosticsFileExtension) == 0x000620, "Member 'AHWGameMode::DiagnosticsFileExtension' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ChatLogFilePrefix) == 0x000630, "Member 'AHWGameMode::ChatLogFilePrefix' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ChatLogFileExtension) == 0x000640, "Member 'AHWGameMode::ChatLogFileExtension' has a wrong offset!");
static_assert(offsetof(AHWGameMode, OnPlayerDiedDelegate) == 0x000650, "Member 'AHWGameMode::OnPlayerDiedDelegate' has a wrong offset!");
static_assert(offsetof(AHWGameMode, OnKilledReward) == 0x000660, "Member 'AHWGameMode::OnKilledReward' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bModeShouldGrantFirstBloodBonus) == 0x000668, "Member 'AHWGameMode::bModeShouldGrantFirstBloodBonus' has a wrong offset!");
static_assert(offsetof(AHWGameMode, AwardLastHitGoldNPCTags) == 0x000670, "Member 'AHWGameMode::AwardLastHitGoldNPCTags' has a wrong offset!");
static_assert(offsetof(AHWGameMode, OnKilledTeamReward) == 0x000690, "Member 'AHWGameMode::OnKilledTeamReward' has a wrong offset!");
static_assert(offsetof(AHWGameMode, LowestXPConfigMap) == 0x000698, "Member 'AHWGameMode::LowestXPConfigMap' has a wrong offset!");
static_assert(offsetof(AHWGameMode, DeserterPenalties) == 0x0006E8, "Member 'AHWGameMode::DeserterPenalties' has a wrong offset!");
static_assert(offsetof(AHWGameMode, DeserterResetHours) == 0x0006F8, "Member 'AHWGameMode::DeserterResetHours' has a wrong offset!");
static_assert(offsetof(AHWGameMode, DeserterId) == 0x000700, "Member 'AHWGameMode::DeserterId' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PrimaryDeserterCheckHandle) == 0x000710, "Member 'AHWGameMode::PrimaryDeserterCheckHandle' has a wrong offset!");
static_assert(offsetof(AHWGameMode, KillAssistRange) == 0x000718, "Member 'AHWGameMode::KillAssistRange' has a wrong offset!");
static_assert(offsetof(AHWGameMode, GodKillAssistEligibilityDuration) == 0x00071C, "Member 'AHWGameMode::GodKillAssistEligibilityDuration' has a wrong offset!");
static_assert(offsetof(AHWGameMode, NPCKillAssistEligibilityDuration) == 0x000720, "Member 'AHWGameMode::NPCKillAssistEligibilityDuration' has a wrong offset!");
static_assert(offsetof(AHWGameMode, RespawnManagerClass) == 0x000728, "Member 'AHWGameMode::RespawnManagerClass' has a wrong offset!");
static_assert(offsetof(AHWGameMode, RespawnManager) == 0x000730, "Member 'AHWGameMode::RespawnManager' has a wrong offset!");
static_assert(offsetof(AHWGameMode, DefaultCharacter) == 0x0007A8, "Member 'AHWGameMode::DefaultCharacter' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PlayerIdToSpawnPointMap) == 0x0007B0, "Member 'AHWGameMode::PlayerIdToSpawnPointMap' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bHoldingPlayerLogins) == 0x000800, "Member 'AHWGameMode::bHoldingPlayerLogins' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PendingPlayerLogins) == 0x000808, "Member 'AHWGameMode::PendingPlayerLogins' has a wrong offset!");
static_assert(offsetof(AHWGameMode, LobbyConnectionStatus) == 0x000818, "Member 'AHWGameMode::LobbyConnectionStatus' has a wrong offset!");
static_assert(offsetof(AHWGameMode, SeamlessTravelPreviousCount) == 0x000828, "Member 'AHWGameMode::SeamlessTravelPreviousCount' has a wrong offset!");
static_assert(offsetof(AHWGameMode, NumConnectedPlayerAtSeamlessTravel) == 0x00082C, "Member 'AHWGameMode::NumConnectedPlayerAtSeamlessTravel' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bPrespawnedPlayerPicks) == 0x000830, "Member 'AHWGameMode::bPrespawnedPlayerPicks' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bStopConnectionStateUpdates) == 0x000831, "Member 'AHWGameMode::bStopConnectionStateUpdates' has a wrong offset!");
static_assert(offsetof(AHWGameMode, LobbySelectLoadTimeout) == 0x000834, "Member 'AHWGameMode::LobbySelectLoadTimeout' has a wrong offset!");
static_assert(offsetof(AHWGameMode, BotDifficultyTag) == 0x000848, "Member 'AHWGameMode::BotDifficultyTag' has a wrong offset!");
static_assert(offsetof(AHWGameMode, OrderGodBots) == 0x000850, "Member 'AHWGameMode::OrderGodBots' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ChaosGodBots) == 0x000860, "Member 'AHWGameMode::ChaosGodBots' has a wrong offset!");
static_assert(offsetof(AHWGameMode, AIGodBotFriendlyPlays) == 0x000870, "Member 'AHWGameMode::AIGodBotFriendlyPlays' has a wrong offset!");
static_assert(offsetof(AHWGameMode, AIGodBotOpposingPlays) == 0x000880, "Member 'AHWGameMode::AIGodBotOpposingPlays' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PlayCallManagerClass) == 0x000890, "Member 'AHWGameMode::PlayCallManagerClass' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bOptInToPlayCallManager) == 0x000898, "Member 'AHWGameMode::bOptInToPlayCallManager' has a wrong offset!");
static_assert(offsetof(AHWGameMode, GodBotFakePlayerNames) == 0x0008A0, "Member 'AHWGameMode::GodBotFakePlayerNames' has a wrong offset!");
static_assert(offsetof(AHWGameMode, GodBotGoalTreeRootClass) == 0x0008B0, "Member 'AHWGameMode::GodBotGoalTreeRootClass' has a wrong offset!");
static_assert(offsetof(AHWGameMode, AIBotTakeoverGoalTree) == 0x0008B8, "Member 'AHWGameMode::AIBotTakeoverGoalTree' has a wrong offset!");
static_assert(offsetof(AHWGameMode, AIBotTakeoverPerceptionComponent) == 0x0008C0, "Member 'AHWGameMode::AIBotTakeoverPerceptionComponent' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bSpawnGodBots) == 0x0008C8, "Member 'AHWGameMode::bSpawnGodBots' has a wrong offset!");
static_assert(offsetof(AHWGameMode, MaxOrderGodBotsToSpawn) == 0x0008CC, "Member 'AHWGameMode::MaxOrderGodBotsToSpawn' has a wrong offset!");
static_assert(offsetof(AHWGameMode, MaxChaosGodBotsToSpawn) == 0x0008D0, "Member 'AHWGameMode::MaxChaosGodBotsToSpawn' has a wrong offset!");
static_assert(offsetof(AHWGameMode, GodBotDifficultyConfigs) == 0x0008D8, "Member 'AHWGameMode::GodBotDifficultyConfigs' has a wrong offset!");
static_assert(offsetof(AHWGameMode, CurrentOrderGodBotDifficulty) == 0x0008E8, "Member 'AHWGameMode::CurrentOrderGodBotDifficulty' has a wrong offset!");
static_assert(offsetof(AHWGameMode, CurrentChaosGodBotDifficulty) == 0x0008EC, "Member 'AHWGameMode::CurrentChaosGodBotDifficulty' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ChosenFakeGodBotNames) == 0x0008F0, "Member 'AHWGameMode::ChosenFakeGodBotNames' has a wrong offset!");
static_assert(offsetof(AHWGameMode, OrderPlayCaller) == 0x000900, "Member 'AHWGameMode::OrderPlayCaller' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ChaosPlayCaller) == 0x000908, "Member 'AHWGameMode::ChaosPlayCaller' has a wrong offset!");
static_assert(offsetof(AHWGameMode, DifficultyConfigMap) == 0x000910, "Member 'AHWGameMode::DifficultyConfigMap' has a wrong offset!");
static_assert(offsetof(AHWGameMode, OrderRestrictedDynamicFillGodBots) == 0x000960, "Member 'AHWGameMode::OrderRestrictedDynamicFillGodBots' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ChaosRestrictedDynamicFillGodBots) == 0x000970, "Member 'AHWGameMode::ChaosRestrictedDynamicFillGodBots' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bDisconnectAIBotWhenAPlayerDisconnects) == 0x000980, "Member 'AHWGameMode::bDisconnectAIBotWhenAPlayerDisconnects' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bWantsSpawnBotsOnBeginPlay) == 0x000981, "Member 'AHWGameMode::bWantsSpawnBotsOnBeginPlay' has a wrong offset!");
static_assert(offsetof(AHWGameMode, OrderGodBotNavigationFilter) == 0x000988, "Member 'AHWGameMode::OrderGodBotNavigationFilter' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ChaosGodBotNavigationFilter) == 0x000990, "Member 'AHWGameMode::ChaosGodBotNavigationFilter' has a wrong offset!");
static_assert(offsetof(AHWGameMode, OrderGodBotDangerZoneNavArea) == 0x000998, "Member 'AHWGameMode::OrderGodBotDangerZoneNavArea' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ChaosGodBotDangerZoneNavArea) == 0x0009A0, "Member 'AHWGameMode::ChaosGodBotDangerZoneNavArea' has a wrong offset!");
static_assert(offsetof(AHWGameMode, NeutralGodBotDangerZoneNavArea) == 0x0009A8, "Member 'AHWGameMode::NeutralGodBotDangerZoneNavArea' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PlayerModifiersAbilitySet) == 0x0009B0, "Member 'AHWGameMode::PlayerModifiersAbilitySet' has a wrong offset!");
static_assert(offsetof(AHWGameMode, GrantedPlayerModifierMap) == 0x0009B8, "Member 'AHWGameMode::GrantedPlayerModifierMap' has a wrong offset!");
static_assert(offsetof(AHWGameMode, TeamIdOrder) == 0x000A08, "Member 'AHWGameMode::TeamIdOrder' has a wrong offset!");
static_assert(offsetof(AHWGameMode, TeamIdChaos) == 0x000A0C, "Member 'AHWGameMode::TeamIdChaos' has a wrong offset!");
static_assert(offsetof(AHWGameMode, TeamIdNeutral) == 0x000A10, "Member 'AHWGameMode::TeamIdNeutral' has a wrong offset!");
static_assert(offsetof(AHWGameMode, TeamIdSpectator) == 0x000A14, "Member 'AHWGameMode::TeamIdSpectator' has a wrong offset!");
static_assert(offsetof(AHWGameMode, TeamCount) == 0x000A18, "Member 'AHWGameMode::TeamCount' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bShouldEditorGenerateReplay) == 0x000A1C, "Member 'AHWGameMode::bShouldEditorGenerateReplay' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bAutoBuildSelectorEnabled) == 0x000A1D, "Member 'AHWGameMode::bAutoBuildSelectorEnabled' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ItemStoreDataTable) == 0x000A20, "Member 'AHWGameMode::ItemStoreDataTable' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ItemStoreSortingData) == 0x000A48, "Member 'AHWGameMode::ItemStoreSortingData' has a wrong offset!");
static_assert(offsetof(AHWGameMode, DefaultItemResalePercentage) == 0x000A50, "Member 'AHWGameMode::DefaultItemResalePercentage' has a wrong offset!");
static_assert(offsetof(AHWGameMode, ItemResalePercentageOverrides) == 0x000A58, "Member 'AHWGameMode::ItemResalePercentageOverrides' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bIsInitiallySpawningCharacters) == 0x000A68, "Member 'AHWGameMode::bIsInitiallySpawningCharacters' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bHasPassedInitialClientLoading) == 0x000A69, "Member 'AHWGameMode::bHasPassedInitialClientLoading' has a wrong offset!");
static_assert(offsetof(AHWGameMode, KillCountToKillstreakAccoladeTagMap) == 0x000A70, "Member 'AHWGameMode::KillCountToKillstreakAccoladeTagMap' has a wrong offset!");
static_assert(offsetof(AHWGameMode, NPCTypeToNPCKillAccoladeTagMap) == 0x000AC0, "Member 'AHWGameMode::NPCTypeToNPCKillAccoladeTagMap' has a wrong offset!");
static_assert(offsetof(AHWGameMode, GameModeInfoTag) == 0x000B10, "Member 'AHWGameMode::GameModeInfoTag' has a wrong offset!");
static_assert(offsetof(AHWGameMode, CharacterDraftRules) == 0x000B18, "Member 'AHWGameMode::CharacterDraftRules' has a wrong offset!");
static_assert(offsetof(AHWGameMode, DraftAuthority) == 0x000B20, "Member 'AHWGameMode::DraftAuthority' has a wrong offset!");
static_assert(offsetof(AHWGameMode, SkinSelectRules) == 0x000B28, "Member 'AHWGameMode::SkinSelectRules' has a wrong offset!");
static_assert(offsetof(AHWGameMode, AdditionalSkinSelectionTime) == 0x000B30, "Member 'AHWGameMode::AdditionalSkinSelectionTime' has a wrong offset!");
static_assert(offsetof(AHWGameMode, EndOfDraftTime) == 0x000B34, "Member 'AHWGameMode::EndOfDraftTime' has a wrong offset!");
static_assert(offsetof(AHWGameMode, EndOfDraftTimeRanked) == 0x000B38, "Member 'AHWGameMode::EndOfDraftTimeRanked' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bDoSkinSelect) == 0x000B3C, "Member 'AHWGameMode::bDoSkinSelect' has a wrong offset!");
static_assert(offsetof(AHWGameMode, SkinSelectAuthorities) == 0x000B40, "Member 'AHWGameMode::SkinSelectAuthorities' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bBlockAttemptToEndSkinSelectPhase) == 0x000B90, "Member 'AHWGameMode::bBlockAttemptToEndSkinSelectPhase' has a wrong offset!");
static_assert(offsetof(AHWGameMode, StatsSnapshotFrequencySeconds) == 0x000B94, "Member 'AHWGameMode::StatsSnapshotFrequencySeconds' has a wrong offset!");
static_assert(offsetof(AHWGameMode, StartStatsWithPhase) == 0x000B98, "Member 'AHWGameMode::StartStatsWithPhase' has a wrong offset!");
static_assert(offsetof(AHWGameMode, SubmitMatchDataWithPhase) == 0x000BA0, "Member 'AHWGameMode::SubmitMatchDataWithPhase' has a wrong offset!");
static_assert(offsetof(AHWGameMode, EndGetGudWithPhase) == 0x000BA8, "Member 'AHWGameMode::EndGetGudWithPhase' has a wrong offset!");
static_assert(offsetof(AHWGameMode, SurrenderAllowedGamePhasesInMatchMadeGame) == 0x000BB8, "Member 'AHWGameMode::SurrenderAllowedGamePhasesInMatchMadeGame' has a wrong offset!");
static_assert(offsetof(AHWGameMode, SurrenderAllowedGamePhasesInCustomGame) == 0x000BD8, "Member 'AHWGameMode::SurrenderAllowedGamePhasesInCustomGame' has a wrong offset!");
static_assert(offsetof(AHWGameMode, SurrenderTimeLimit) == 0x000BF8, "Member 'AHWGameMode::SurrenderTimeLimit' has a wrong offset!");
static_assert(offsetof(AHWGameMode, MinGameTimeBeforeSurrender) == 0x000BFC, "Member 'AHWGameMode::MinGameTimeBeforeSurrender' has a wrong offset!");
static_assert(offsetof(AHWGameMode, MinGameTimeForEarlySurrender) == 0x000C00, "Member 'AHWGameMode::MinGameTimeForEarlySurrender' has a wrong offset!");
static_assert(offsetof(AHWGameMode, DisconnectThresholdForEarlySurrender) == 0x000C04, "Member 'AHWGameMode::DisconnectThresholdForEarlySurrender' has a wrong offset!");
static_assert(offsetof(AHWGameMode, EarlySurrenderLossPrevention) == 0x000C08, "Member 'AHWGameMode::EarlySurrenderLossPrevention' has a wrong offset!");
static_assert(offsetof(AHWGameMode, EarlySurrenderDisconnectPenalty) == 0x000C0C, "Member 'AHWGameMode::EarlySurrenderDisconnectPenalty' has a wrong offset!");
static_assert(offsetof(AHWGameMode, EarlySurrenderWinLimit) == 0x000C10, "Member 'AHWGameMode::EarlySurrenderWinLimit' has a wrong offset!");
static_assert(offsetof(AHWGameMode, CooldownTimeBetweenSurrenderAttempts) == 0x000C14, "Member 'AHWGameMode::CooldownTimeBetweenSurrenderAttempts' has a wrong offset!");
static_assert(offsetof(AHWGameMode, EarlySurrenderTeam) == 0x000C18, "Member 'AHWGameMode::EarlySurrenderTeam' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PauseAllowedGamePhasesInMatchMadeGame) == 0x000C20, "Member 'AHWGameMode::PauseAllowedGamePhasesInMatchMadeGame' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PauseAllowedGamePhasesInCustomGame) == 0x000C40, "Member 'AHWGameMode::PauseAllowedGamePhasesInCustomGame' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PauseTimeLimit) == 0x000C60, "Member 'AHWGameMode::PauseTimeLimit' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PauseVoteTimeLimit) == 0x000C64, "Member 'AHWGameMode::PauseVoteTimeLimit' has a wrong offset!");
static_assert(offsetof(AHWGameMode, MinGameTimeBeforePause) == 0x000C68, "Member 'AHWGameMode::MinGameTimeBeforePause' has a wrong offset!");
static_assert(offsetof(AHWGameMode, CooldownTimeBetweenPauseAttempts) == 0x000C6C, "Member 'AHWGameMode::CooldownTimeBetweenPauseAttempts' has a wrong offset!");
static_assert(offsetof(AHWGameMode, UnpauseDelay) == 0x000C70, "Member 'AHWGameMode::UnpauseDelay' has a wrong offset!");
static_assert(offsetof(AHWGameMode, MaxSuccessfulPausesInMatchmadeGame) == 0x000C74, "Member 'AHWGameMode::MaxSuccessfulPausesInMatchmadeGame' has a wrong offset!");
static_assert(offsetof(AHWGameMode, MaxSuccessfulPausesInCustom) == 0x000C78, "Member 'AHWGameMode::MaxSuccessfulPausesInCustom' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PausingTeam) == 0x000C80, "Member 'AHWGameMode::PausingTeam' has a wrong offset!");
static_assert(offsetof(AHWGameMode, SystemMessageDTSoftPtr) == 0x000CC8, "Member 'AHWGameMode::SystemMessageDTSoftPtr' has a wrong offset!");
static_assert(offsetof(AHWGameMode, QuestFlags) == 0x000CF0, "Member 'AHWGameMode::QuestFlags' has a wrong offset!");
static_assert(offsetof(AHWGameMode, StartQuestsWithPhase) == 0x000D10, "Member 'AHWGameMode::StartQuestsWithPhase' has a wrong offset!");
static_assert(offsetof(AHWGameMode, SubmitsQuestsWithPhase) == 0x000D18, "Member 'AHWGameMode::SubmitsQuestsWithPhase' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bEnableQuestsInAllMatches) == 0x000D20, "Member 'AHWGameMode::bEnableQuestsInAllMatches' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bShouldCalculateTrueSkill) == 0x000D21, "Member 'AHWGameMode::bShouldCalculateTrueSkill' has a wrong offset!");
static_assert(offsetof(AHWGameMode, RankedConfig) == 0x000D38, "Member 'AHWGameMode::RankedConfig' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bShouldCalculateSkillRating) == 0x000D60, "Member 'AHWGameMode::bShouldCalculateSkillRating' has a wrong offset!");
static_assert(offsetof(AHWGameMode, RoleConfig) == 0x000D68, "Member 'AHWGameMode::RoleConfig' has a wrong offset!");
static_assert(offsetof(AHWGameMode, MinimapSize) == 0x000D90, "Member 'AHWGameMode::MinimapSize' has a wrong offset!");
static_assert(offsetof(AHWGameMode, LumenLightingSubLevel) == 0x000D98, "Member 'AHWGameMode::LumenLightingSubLevel' has a wrong offset!");
static_assert(offsetof(AHWGameMode, NoLumenLightingSubLevel) == 0x000DC0, "Member 'AHWGameMode::NoLumenLightingSubLevel' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bEnableTextChatFloodProtection) == 0x000DE8, "Member 'AHWGameMode::bEnableTextChatFloodProtection' has a wrong offset!");
static_assert(offsetof(AHWGameMode, TextChatFloodProtectionTimeWindow) == 0x000DEC, "Member 'AHWGameMode::TextChatFloodProtectionTimeWindow' has a wrong offset!");
static_assert(offsetof(AHWGameMode, TextChatFloodProtectionMessageLimit) == 0x000DF0, "Member 'AHWGameMode::TextChatFloodProtectionMessageLimit' has a wrong offset!");
static_assert(offsetof(AHWGameMode, TextChatFloodProtectionCooldownTime) == 0x000DF4, "Member 'AHWGameMode::TextChatFloodProtectionCooldownTime' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bEnableVGSFloodProtection) == 0x000DF8, "Member 'AHWGameMode::bEnableVGSFloodProtection' has a wrong offset!");
static_assert(offsetof(AHWGameMode, FloodProtectionData) == 0x000E00, "Member 'AHWGameMode::FloodProtectionData' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bEnablePingFloodProtection) == 0x000E50, "Member 'AHWGameMode::bEnablePingFloodProtection' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PingFloodProtectionTimeWindow) == 0x000E54, "Member 'AHWGameMode::PingFloodProtectionTimeWindow' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PingFloodProtectionMessageLimit) == 0x000E58, "Member 'AHWGameMode::PingFloodProtectionMessageLimit' has a wrong offset!");
static_assert(offsetof(AHWGameMode, PingFloodProtectionCooldownTime) == 0x000E5C, "Member 'AHWGameMode::PingFloodProtectionCooldownTime' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bCurrentlyTrackingPlayerBehaviors) == 0x000E60, "Member 'AHWGameMode::bCurrentlyTrackingPlayerBehaviors' has a wrong offset!");
static_assert(offsetof(AHWGameMode, AFKDurationThreshold) == 0x000E64, "Member 'AHWGameMode::AFKDurationThreshold' has a wrong offset!");
static_assert(offsetof(AHWGameMode, AFKWarningThreshold) == 0x000E68, "Member 'AHWGameMode::AFKWarningThreshold' has a wrong offset!");
static_assert(offsetof(AHWGameMode, bHasAlreadyLoggedSessionData) == 0x000E6C, "Member 'AHWGameMode::bHasAlreadyLoggedSessionData' has a wrong offset!");
static_assert(offsetof(AHWGameMode, CharacterInGameMaterialCollection) == 0x000E70, "Member 'AHWGameMode::CharacterInGameMaterialCollection' has a wrong offset!");
static_assert(offsetof(AHWGameMode, MaxPlayerXPForNPEBoost) == 0x000E78, "Member 'AHWGameMode::MaxPlayerXPForNPEBoost' has a wrong offset!");
static_assert(offsetof(AHWGameMode, NPEBoostReceiptId) == 0x000E7C, "Member 'AHWGameMode::NPEBoostReceiptId' has a wrong offset!");
static_assert(offsetof(AHWGameMode, NPEBoostReceiptLootId) == 0x000E80, "Member 'AHWGameMode::NPEBoostReceiptLootId' has a wrong offset!");
static_assert(offsetof(AHWGameMode, MaxNPEBoostsPerPlayer) == 0x000E84, "Member 'AHWGameMode::MaxNPEBoostsPerPlayer' has a wrong offset!");
static_assert(offsetof(AHWGameMode, NPEBoostAbilityPath) == 0x000E88, "Member 'AHWGameMode::NPEBoostAbilityPath' has a wrong offset!");
static_assert(offsetof(AHWGameMode, NPEBoostAbilitySet) == 0x000EB8, "Member 'AHWGameMode::NPEBoostAbilitySet' has a wrong offset!");

// Class Hemingway.HWGameMode_DraftLobby
// 0x0000 (0x0EC0 - 0x0EC0)
class AHWGameMode_DraftLobby final : public AHWGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameMode_DraftLobby">();
	}
	static class AHWGameMode_DraftLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameMode_DraftLobby>();
	}
};
static_assert(alignof(AHWGameMode_DraftLobby) == 0x000008, "Wrong alignment on AHWGameMode_DraftLobby");
static_assert(sizeof(AHWGameMode_DraftLobby) == 0x000EC0, "Wrong size on AHWGameMode_DraftLobby");

// Class Hemingway.HWAIPlayLogic_SupportGank
// 0x0018 (0x0080 - 0x0068)
class UHWAIPlayLogic_SupportGank : public UHWAIPlayLogic
{
public:
	struct FDataTableRowHandle                    GankPlayHandle;                                    // 0x0068(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxDistanceFromGankee;                             // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxJunglerDistanceFromGankee;                      // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_SupportGank">();
	}
	static class UHWAIPlayLogic_SupportGank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_SupportGank>();
	}
};
static_assert(alignof(UHWAIPlayLogic_SupportGank) == 0x000008, "Wrong alignment on UHWAIPlayLogic_SupportGank");
static_assert(sizeof(UHWAIPlayLogic_SupportGank) == 0x000080, "Wrong size on UHWAIPlayLogic_SupportGank");
static_assert(offsetof(UHWAIPlayLogic_SupportGank, GankPlayHandle) == 0x000068, "Member 'UHWAIPlayLogic_SupportGank::GankPlayHandle' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SupportGank, MaxDistanceFromGankee) == 0x000078, "Member 'UHWAIPlayLogic_SupportGank::MaxDistanceFromGankee' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SupportGank, MaxJunglerDistanceFromGankee) == 0x00007C, "Member 'UHWAIPlayLogic_SupportGank::MaxJunglerDistanceFromGankee' has a wrong offset!");

// Class Hemingway.HWAIPlayLogic_FarmJungle
// 0x00E8 (0x0150 - 0x0068)
class UHWAIPlayLogic_FarmJungle : public UHWAIPlayLogic
{
public:
	float                                         HealthPercentageThreshold;                         // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinLevelRequirement;                               // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceFromJungleMob;                          // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCharacterDistance;                              // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxMinionDistance;                                 // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxEnemyGodDistance;                               // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxMinionLanePercentage;                           // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AIRolesToInvalidate;                               // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<ECharacterRole>                        PlayerRolesToInvalidate;                           // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ECharacterRole, class FName>             RoleToLaneMap;                                     // 0x00A8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsInvade;                                         // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FGameplayTag>              TeamTagMap;                                        // 0x0100(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_FarmJungle">();
	}
	static class UHWAIPlayLogic_FarmJungle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_FarmJungle>();
	}
};
static_assert(alignof(UHWAIPlayLogic_FarmJungle) == 0x000008, "Wrong alignment on UHWAIPlayLogic_FarmJungle");
static_assert(sizeof(UHWAIPlayLogic_FarmJungle) == 0x000150, "Wrong size on UHWAIPlayLogic_FarmJungle");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, HealthPercentageThreshold) == 0x000068, "Member 'UHWAIPlayLogic_FarmJungle::HealthPercentageThreshold' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, MinLevelRequirement) == 0x00006C, "Member 'UHWAIPlayLogic_FarmJungle::MinLevelRequirement' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, MaxDistanceFromJungleMob) == 0x000070, "Member 'UHWAIPlayLogic_FarmJungle::MaxDistanceFromJungleMob' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, MaxCharacterDistance) == 0x000074, "Member 'UHWAIPlayLogic_FarmJungle::MaxCharacterDistance' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, MaxMinionDistance) == 0x000078, "Member 'UHWAIPlayLogic_FarmJungle::MaxMinionDistance' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, MaxEnemyGodDistance) == 0x00007C, "Member 'UHWAIPlayLogic_FarmJungle::MaxEnemyGodDistance' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, MaxMinionLanePercentage) == 0x000080, "Member 'UHWAIPlayLogic_FarmJungle::MaxMinionLanePercentage' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, AIRolesToInvalidate) == 0x000088, "Member 'UHWAIPlayLogic_FarmJungle::AIRolesToInvalidate' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, PlayerRolesToInvalidate) == 0x000098, "Member 'UHWAIPlayLogic_FarmJungle::PlayerRolesToInvalidate' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, RoleToLaneMap) == 0x0000A8, "Member 'UHWAIPlayLogic_FarmJungle::RoleToLaneMap' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, bIsInvade) == 0x0000F8, "Member 'UHWAIPlayLogic_FarmJungle::bIsInvade' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmJungle, TeamTagMap) == 0x000100, "Member 'UHWAIPlayLogic_FarmJungle::TeamTagMap' has a wrong offset!");

// Class Hemingway.HWEquipmentComponentSettings_Stacks
// 0x0010 (0x0050 - 0x0040)
class UHWEquipmentComponentSettings_Stacks final : public UHWEquipmentComponentSettings
{
public:
	int32                                         MaxStackCount;                                     // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitialStackCount;                                 // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWEquipmentInfo_EffectInfo            EffectToGrantPerStack;                             // 0x0048(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	struct FHWEquipmentInfo_EffectInfo GetEffectToGrantPerStack() const;
	int32 GetInitialStackCount() const;
	int32 GetMaxStackCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponentSettings_Stacks">();
	}
	static class UHWEquipmentComponentSettings_Stacks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponentSettings_Stacks>();
	}
};
static_assert(alignof(UHWEquipmentComponentSettings_Stacks) == 0x000008, "Wrong alignment on UHWEquipmentComponentSettings_Stacks");
static_assert(sizeof(UHWEquipmentComponentSettings_Stacks) == 0x000050, "Wrong size on UHWEquipmentComponentSettings_Stacks");
static_assert(offsetof(UHWEquipmentComponentSettings_Stacks, MaxStackCount) == 0x000040, "Member 'UHWEquipmentComponentSettings_Stacks::MaxStackCount' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Stacks, InitialStackCount) == 0x000044, "Member 'UHWEquipmentComponentSettings_Stacks::InitialStackCount' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Stacks, EffectToGrantPerStack) == 0x000048, "Member 'UHWEquipmentComponentSettings_Stacks::EffectToGrantPerStack' has a wrong offset!");

// Class Hemingway.HWAIPlayLogic_FarmLaneNPE
// 0x0060 (0x00C8 - 0x0068)
class UHWAIPlayLogic_FarmLaneNPE : public UHWAIPlayLogic
{
public:
	int32                                         MinValuableMinionCount;                            // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LaneDistancePercentage;                            // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceFromMinions;                            // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECharacterRole, class FName>             RoleToLaneMap;                                     // 0x0078(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_FarmLaneNPE">();
	}
	static class UHWAIPlayLogic_FarmLaneNPE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_FarmLaneNPE>();
	}
};
static_assert(alignof(UHWAIPlayLogic_FarmLaneNPE) == 0x000008, "Wrong alignment on UHWAIPlayLogic_FarmLaneNPE");
static_assert(sizeof(UHWAIPlayLogic_FarmLaneNPE) == 0x0000C8, "Wrong size on UHWAIPlayLogic_FarmLaneNPE");
static_assert(offsetof(UHWAIPlayLogic_FarmLaneNPE, MinValuableMinionCount) == 0x000068, "Member 'UHWAIPlayLogic_FarmLaneNPE::MinValuableMinionCount' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmLaneNPE, LaneDistancePercentage) == 0x00006C, "Member 'UHWAIPlayLogic_FarmLaneNPE::LaneDistancePercentage' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmLaneNPE, MinDistanceFromMinions) == 0x000070, "Member 'UHWAIPlayLogic_FarmLaneNPE::MinDistanceFromMinions' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_FarmLaneNPE, RoleToLaneMap) == 0x000078, "Member 'UHWAIPlayLogic_FarmLaneNPE::RoleToLaneMap' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Stealth
// 0x0228 (0x0CE0 - 0x0AB8)
class UHWGameplayEffect_Stealth : public UHWGameplayEffect
{
public:
	struct FHWGameplayTargetDataFilter_Stealth    StealthFilterTemplate;                             // 0x0AB8(0x01E8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  RevealRulesTagContainer;                           // 0x0CA0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  EndStealthAbilityTagsIfFired;                      // 0x0CC0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Stealth">();
	}
	static class UHWGameplayEffect_Stealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Stealth>();
	}
};
static_assert(alignof(UHWGameplayEffect_Stealth) == 0x000008, "Wrong alignment on UHWGameplayEffect_Stealth");
static_assert(sizeof(UHWGameplayEffect_Stealth) == 0x000CE0, "Wrong size on UHWGameplayEffect_Stealth");
static_assert(offsetof(UHWGameplayEffect_Stealth, StealthFilterTemplate) == 0x000AB8, "Member 'UHWGameplayEffect_Stealth::StealthFilterTemplate' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Stealth, RevealRulesTagContainer) == 0x000CA0, "Member 'UHWGameplayEffect_Stealth::RevealRulesTagContainer' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Stealth, EndStealthAbilityTagsIfFired) == 0x000CC0, "Member 'UHWGameplayEffect_Stealth::EndStealthAbilityTagsIfFired' has a wrong offset!");

// Class Hemingway.HWAIPlayLogic_AttackDefendNPE
// 0x0018 (0x0080 - 0x0068)
class UHWAIPlayLogic_AttackDefendNPE : public UHWAIPlayLogic
{
public:
	float                                         MaxCharacterDistance;                              // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttack;                                         // 0x006C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalHealthPercentageDiffForAdvantage;             // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowHealthPercentageThreshold;                      // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinMinionCountForAdvantage;                        // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_AttackDefendNPE">();
	}
	static class UHWAIPlayLogic_AttackDefendNPE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_AttackDefendNPE>();
	}
};
static_assert(alignof(UHWAIPlayLogic_AttackDefendNPE) == 0x000008, "Wrong alignment on UHWAIPlayLogic_AttackDefendNPE");
static_assert(sizeof(UHWAIPlayLogic_AttackDefendNPE) == 0x000080, "Wrong size on UHWAIPlayLogic_AttackDefendNPE");
static_assert(offsetof(UHWAIPlayLogic_AttackDefendNPE, MaxCharacterDistance) == 0x000068, "Member 'UHWAIPlayLogic_AttackDefendNPE::MaxCharacterDistance' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_AttackDefendNPE, bIsAttack) == 0x00006C, "Member 'UHWAIPlayLogic_AttackDefendNPE::bIsAttack' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_AttackDefendNPE, TotalHealthPercentageDiffForAdvantage) == 0x000070, "Member 'UHWAIPlayLogic_AttackDefendNPE::TotalHealthPercentageDiffForAdvantage' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_AttackDefendNPE, LowHealthPercentageThreshold) == 0x000074, "Member 'UHWAIPlayLogic_AttackDefendNPE::LowHealthPercentageThreshold' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_AttackDefendNPE, MinMinionCountForAdvantage) == 0x000078, "Member 'UHWAIPlayLogic_AttackDefendNPE::MinMinionCountForAdvantage' has a wrong offset!");

// Class Hemingway.HWGameplayAbility_Teleporter
// 0x01F0 (0x0BB0 - 0x09C0)
class UHWGameplayAbility_Teleporter final : public UHWGameplayAbility
{
public:
	class UVisibilityData*                        VisibilityData;                                    // 0x09C0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWGameplayTargetDataFilter_Stealth    MapTeleportVisibilityFilter;                       // 0x09C8(0x01E8)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayAbility_Teleporter">();
	}
	static class UHWGameplayAbility_Teleporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayAbility_Teleporter>();
	}
};
static_assert(alignof(UHWGameplayAbility_Teleporter) == 0x000008, "Wrong alignment on UHWGameplayAbility_Teleporter");
static_assert(sizeof(UHWGameplayAbility_Teleporter) == 0x000BB0, "Wrong size on UHWGameplayAbility_Teleporter");
static_assert(offsetof(UHWGameplayAbility_Teleporter, VisibilityData) == 0x0009C0, "Member 'UHWGameplayAbility_Teleporter::VisibilityData' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Teleporter, MapTeleportVisibilityFilter) == 0x0009C8, "Member 'UHWGameplayAbility_Teleporter::MapTeleportVisibilityFilter' has a wrong offset!");

// Class Hemingway.HWAIPlayLogic_BackToBaseNPE
// 0x0010 (0x0078 - 0x0068)
class UHWAIPlayLogic_BackToBaseNPE : public UHWAIPlayLogic
{
public:
	float                                         HealthPercentageThreshold;                         // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         manaThreshold;                                     // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GoldThreshold;                                     // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_BackToBaseNPE">();
	}
	static class UHWAIPlayLogic_BackToBaseNPE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_BackToBaseNPE>();
	}
};
static_assert(alignof(UHWAIPlayLogic_BackToBaseNPE) == 0x000008, "Wrong alignment on UHWAIPlayLogic_BackToBaseNPE");
static_assert(sizeof(UHWAIPlayLogic_BackToBaseNPE) == 0x000078, "Wrong size on UHWAIPlayLogic_BackToBaseNPE");
static_assert(offsetof(UHWAIPlayLogic_BackToBaseNPE, HealthPercentageThreshold) == 0x000068, "Member 'UHWAIPlayLogic_BackToBaseNPE::HealthPercentageThreshold' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_BackToBaseNPE, manaThreshold) == 0x00006C, "Member 'UHWAIPlayLogic_BackToBaseNPE::manaThreshold' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_BackToBaseNPE, GoldThreshold) == 0x000070, "Member 'UHWAIPlayLogic_BackToBaseNPE::GoldThreshold' has a wrong offset!");

// Class Hemingway.HWAIPlayLogic_JungleBossObjective
// 0x0038 (0x00A0 - 0x0068)
class UHWAIPlayLogic_JungleBossObjective : public UHWAIPlayLogic
{
public:
	float                                         MinIndividualGodLevel;                             // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthPercentageThresholdToParticipate;            // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthPercentageThresholdToTank;                   // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinNumbersAdvantage;                               // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceFromBossForConsideration;               // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CharacterIgnoreTags;                               // 0x0080(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_JungleBossObjective">();
	}
	static class UHWAIPlayLogic_JungleBossObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_JungleBossObjective>();
	}
};
static_assert(alignof(UHWAIPlayLogic_JungleBossObjective) == 0x000008, "Wrong alignment on UHWAIPlayLogic_JungleBossObjective");
static_assert(sizeof(UHWAIPlayLogic_JungleBossObjective) == 0x0000A0, "Wrong size on UHWAIPlayLogic_JungleBossObjective");
static_assert(offsetof(UHWAIPlayLogic_JungleBossObjective, MinIndividualGodLevel) == 0x000068, "Member 'UHWAIPlayLogic_JungleBossObjective::MinIndividualGodLevel' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_JungleBossObjective, HealthPercentageThresholdToParticipate) == 0x00006C, "Member 'UHWAIPlayLogic_JungleBossObjective::HealthPercentageThresholdToParticipate' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_JungleBossObjective, HealthPercentageThresholdToTank) == 0x000070, "Member 'UHWAIPlayLogic_JungleBossObjective::HealthPercentageThresholdToTank' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_JungleBossObjective, MinNumbersAdvantage) == 0x000074, "Member 'UHWAIPlayLogic_JungleBossObjective::MinNumbersAdvantage' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_JungleBossObjective, MinDistanceFromBossForConsideration) == 0x000078, "Member 'UHWAIPlayLogic_JungleBossObjective::MinDistanceFromBossForConsideration' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_JungleBossObjective, CharacterIgnoreTags) == 0x000080, "Member 'UHWAIPlayLogic_JungleBossObjective::CharacterIgnoreTags' has a wrong offset!");

// Class Hemingway.HWGEModiferMagnitudeCalc_Base
// 0x0000 (0x0040 - 0x0040)
class UHWGEModiferMagnitudeCalc_Base : public UGameplayModMagnitudeCalculation
{
public:
	const class UHWCharacterInfo* GetCharacterInfoFromInstigator(const struct FGameplayEffectContextHandle& EffectContextHandle) const;
	const class UHWCharacterItem* GetCharacterItemFromInstigator(const struct FGameplayEffectContextHandle& EffectContextHandle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEModiferMagnitudeCalc_Base">();
	}
	static class UHWGEModiferMagnitudeCalc_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEModiferMagnitudeCalc_Base>();
	}
};
static_assert(alignof(UHWGEModiferMagnitudeCalc_Base) == 0x000008, "Wrong alignment on UHWGEModiferMagnitudeCalc_Base");
static_assert(sizeof(UHWGEModiferMagnitudeCalc_Base) == 0x000040, "Wrong size on UHWGEModiferMagnitudeCalc_Base");

// Class Hemingway.HWGEMMC_Heal_MissingAmount
// 0x0070 (0x00B0 - 0x0040)
class UHWGEMMC_Heal_MissingAmount final : public UHWGEModiferMagnitudeCalc_Base
{
public:
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEMMC_Heal_MissingAmount">();
	}
	static class UHWGEMMC_Heal_MissingAmount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEMMC_Heal_MissingAmount>();
	}
};
static_assert(alignof(UHWGEMMC_Heal_MissingAmount) == 0x000008, "Wrong alignment on UHWGEMMC_Heal_MissingAmount");
static_assert(sizeof(UHWGEMMC_Heal_MissingAmount) == 0x0000B0, "Wrong size on UHWGEMMC_Heal_MissingAmount");

// Class Hemingway.HWAIPlayLogic_SeigeObjective
// 0x0060 (0x00C8 - 0x0068)
class UHWAIPlayLogic_SeigeObjective : public UHWAIPlayLogic
{
public:
	float                                         MinAverageTeamLevel;                               // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinIndividualGodLevel;                             // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceFromObjective;                          // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StagingDistanceFromObjective;                      // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxGroupedUpDistance;                              // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceWeight;                                 // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NumbersAdvantageWeight;                            // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FireGiantPerTeammateWeight;                        // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FireGiantEffectTag;                                // 0x0088(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           StageStateTag;                                     // 0x0090(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SeigeStateTag;                                     // 0x0098(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TitanMinPhoenixCount;                              // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ImmunityTag;                                       // 0x00A4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StagingLocation;                                   // 0x00B0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_SeigeObjective">();
	}
	static class UHWAIPlayLogic_SeigeObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_SeigeObjective>();
	}
};
static_assert(alignof(UHWAIPlayLogic_SeigeObjective) == 0x000008, "Wrong alignment on UHWAIPlayLogic_SeigeObjective");
static_assert(sizeof(UHWAIPlayLogic_SeigeObjective) == 0x0000C8, "Wrong size on UHWAIPlayLogic_SeigeObjective");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, MinAverageTeamLevel) == 0x000068, "Member 'UHWAIPlayLogic_SeigeObjective::MinAverageTeamLevel' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, MinIndividualGodLevel) == 0x00006C, "Member 'UHWAIPlayLogic_SeigeObjective::MinIndividualGodLevel' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, MaxDistanceFromObjective) == 0x000070, "Member 'UHWAIPlayLogic_SeigeObjective::MaxDistanceFromObjective' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, StagingDistanceFromObjective) == 0x000074, "Member 'UHWAIPlayLogic_SeigeObjective::StagingDistanceFromObjective' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, MaxGroupedUpDistance) == 0x000078, "Member 'UHWAIPlayLogic_SeigeObjective::MaxGroupedUpDistance' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, MaxDistanceWeight) == 0x00007C, "Member 'UHWAIPlayLogic_SeigeObjective::MaxDistanceWeight' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, NumbersAdvantageWeight) == 0x000080, "Member 'UHWAIPlayLogic_SeigeObjective::NumbersAdvantageWeight' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, FireGiantPerTeammateWeight) == 0x000084, "Member 'UHWAIPlayLogic_SeigeObjective::FireGiantPerTeammateWeight' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, FireGiantEffectTag) == 0x000088, "Member 'UHWAIPlayLogic_SeigeObjective::FireGiantEffectTag' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, StageStateTag) == 0x000090, "Member 'UHWAIPlayLogic_SeigeObjective::StageStateTag' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, SeigeStateTag) == 0x000098, "Member 'UHWAIPlayLogic_SeigeObjective::SeigeStateTag' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, TitanMinPhoenixCount) == 0x0000A0, "Member 'UHWAIPlayLogic_SeigeObjective::TitanMinPhoenixCount' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, ImmunityTag) == 0x0000A4, "Member 'UHWAIPlayLogic_SeigeObjective::ImmunityTag' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_SeigeObjective, StagingLocation) == 0x0000B0, "Member 'UHWAIPlayLogic_SeigeObjective::StagingLocation' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_VisionRange
// 0x0000 (0x0AB8 - 0x0AB8)
class UHWGameplayEffect_VisionRange : public UHWGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_VisionRange">();
	}
	static class UHWGameplayEffect_VisionRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_VisionRange>();
	}
};
static_assert(alignof(UHWGameplayEffect_VisionRange) == 0x000008, "Wrong alignment on UHWGameplayEffect_VisionRange");
static_assert(sizeof(UHWGameplayEffect_VisionRange) == 0x000AB8, "Wrong size on UHWGameplayEffect_VisionRange");

// Class Hemingway.HWAIPlayLogic_DefendObjective
// 0x0010 (0x0078 - 0x0068)
class UHWAIPlayLogic_DefendObjective : public UHWAIPlayLogic
{
public:
	struct FGameplayTag                           ImmunityTag;                                       // 0x0068(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHealthWeight;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_DefendObjective">();
	}
	static class UHWAIPlayLogic_DefendObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_DefendObjective>();
	}
};
static_assert(alignof(UHWAIPlayLogic_DefendObjective) == 0x000008, "Wrong alignment on UHWAIPlayLogic_DefendObjective");
static_assert(sizeof(UHWAIPlayLogic_DefendObjective) == 0x000078, "Wrong size on UHWAIPlayLogic_DefendObjective");
static_assert(offsetof(UHWAIPlayLogic_DefendObjective, ImmunityTag) == 0x000068, "Member 'UHWAIPlayLogic_DefendObjective::ImmunityTag' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_DefendObjective, MaxHealthWeight) == 0x000070, "Member 'UHWAIPlayLogic_DefendObjective::MaxHealthWeight' has a wrong offset!");

// Class Hemingway.HWGameplayCueNotify_StackingVFX
// 0x0040 (0x03A8 - 0x0368)
class AHWGameplayCueNotify_StackingVFX final : public AHWGameplayCueNotify_Actor
{
public:
	class USceneComponent*                        Root;                                              // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWNiagaraComponent*                    StackingVFX;                                       // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                OverridenRelativeLocation;                         // 0x0378(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachRootToTargetMesh;                           // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               LocationRule;                                      // 0x0391(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               RotationRule;                                      // 0x0392(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               ScaleRule;                                         // 0x0393(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldWeldSimulatedBodies;                        // 0x0394(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VFXSocket;                                         // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StackPropertyName;                                 // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_StackingVFX">();
	}
	static class AHWGameplayCueNotify_StackingVFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameplayCueNotify_StackingVFX>();
	}
};
static_assert(alignof(AHWGameplayCueNotify_StackingVFX) == 0x000008, "Wrong alignment on AHWGameplayCueNotify_StackingVFX");
static_assert(sizeof(AHWGameplayCueNotify_StackingVFX) == 0x0003A8, "Wrong size on AHWGameplayCueNotify_StackingVFX");
static_assert(offsetof(AHWGameplayCueNotify_StackingVFX, Root) == 0x000368, "Member 'AHWGameplayCueNotify_StackingVFX::Root' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_StackingVFX, StackingVFX) == 0x000370, "Member 'AHWGameplayCueNotify_StackingVFX::StackingVFX' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_StackingVFX, OverridenRelativeLocation) == 0x000378, "Member 'AHWGameplayCueNotify_StackingVFX::OverridenRelativeLocation' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_StackingVFX, bAttachRootToTargetMesh) == 0x000390, "Member 'AHWGameplayCueNotify_StackingVFX::bAttachRootToTargetMesh' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_StackingVFX, LocationRule) == 0x000391, "Member 'AHWGameplayCueNotify_StackingVFX::LocationRule' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_StackingVFX, RotationRule) == 0x000392, "Member 'AHWGameplayCueNotify_StackingVFX::RotationRule' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_StackingVFX, ScaleRule) == 0x000393, "Member 'AHWGameplayCueNotify_StackingVFX::ScaleRule' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_StackingVFX, bShouldWeldSimulatedBodies) == 0x000394, "Member 'AHWGameplayCueNotify_StackingVFX::bShouldWeldSimulatedBodies' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_StackingVFX, VFXSocket) == 0x000398, "Member 'AHWGameplayCueNotify_StackingVFX::VFXSocket' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_StackingVFX, StackPropertyName) == 0x0003A0, "Member 'AHWGameplayCueNotify_StackingVFX::StackPropertyName' has a wrong offset!");

// Class Hemingway.HWAIPlayLogic_HelpMe
// 0x0018 (0x0080 - 0x0068)
class UHWAIPlayLogic_HelpMe : public UHWAIPlayLogic
{
public:
	float                                         MinHealthPercent;                                  // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistance;                                       // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHostileTimeframe;                               // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinWeight;                                         // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWeight;                                         // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_HelpMe">();
	}
	static class UHWAIPlayLogic_HelpMe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_HelpMe>();
	}
};
static_assert(alignof(UHWAIPlayLogic_HelpMe) == 0x000008, "Wrong alignment on UHWAIPlayLogic_HelpMe");
static_assert(sizeof(UHWAIPlayLogic_HelpMe) == 0x000080, "Wrong size on UHWAIPlayLogic_HelpMe");
static_assert(offsetof(UHWAIPlayLogic_HelpMe, MinHealthPercent) == 0x000068, "Member 'UHWAIPlayLogic_HelpMe::MinHealthPercent' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_HelpMe, MaxDistance) == 0x00006C, "Member 'UHWAIPlayLogic_HelpMe::MaxDistance' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_HelpMe, MaxHostileTimeframe) == 0x000070, "Member 'UHWAIPlayLogic_HelpMe::MaxHostileTimeframe' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_HelpMe, MinWeight) == 0x000074, "Member 'UHWAIPlayLogic_HelpMe::MinWeight' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_HelpMe, MaxWeight) == 0x000078, "Member 'UHWAIPlayLogic_HelpMe::MaxWeight' has a wrong offset!");

// Class Hemingway.HWAIPlayLogic_Interact
// 0x0010 (0x0078 - 0x0068)
class UHWAIPlayLogic_Interact : public UHWAIPlayLogic
{
public:
	float                                         MaxDistance;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinWeight;                                         // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWeight;                                         // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_Interact">();
	}
	static class UHWAIPlayLogic_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_Interact>();
	}
};
static_assert(alignof(UHWAIPlayLogic_Interact) == 0x000008, "Wrong alignment on UHWAIPlayLogic_Interact");
static_assert(sizeof(UHWAIPlayLogic_Interact) == 0x000078, "Wrong size on UHWAIPlayLogic_Interact");
static_assert(offsetof(UHWAIPlayLogic_Interact, MaxDistance) == 0x000068, "Member 'UHWAIPlayLogic_Interact::MaxDistance' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_Interact, MinWeight) == 0x00006C, "Member 'UHWAIPlayLogic_Interact::MinWeight' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_Interact, MaxWeight) == 0x000070, "Member 'UHWAIPlayLogic_Interact::MaxWeight' has a wrong offset!");

// Class Hemingway.HWGameplayAbility_Shield
// 0x0000 (0x09C0 - 0x09C0)
class UHWGameplayAbility_Shield : public UHWGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayAbility_Shield">();
	}
	static class UHWGameplayAbility_Shield* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayAbility_Shield>();
	}
};
static_assert(alignof(UHWGameplayAbility_Shield) == 0x000008, "Wrong alignment on UHWGameplayAbility_Shield");
static_assert(sizeof(UHWGameplayAbility_Shield) == 0x0009C0, "Wrong size on UHWGameplayAbility_Shield");

// Class Hemingway.HWGameplayEffect_MovementSpeed
// 0x0050 (0x0B08 - 0x0AB8)
class UHWGameplayEffect_MovementSpeed : public UHWGameplayEffect
{
public:
	TMap<struct FGameplayTag, struct FGameplayEffectModifierMagnitude> MovementSpeedModifiers;       // 0x0AB8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_MovementSpeed">();
	}
	static class UHWGameplayEffect_MovementSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_MovementSpeed>();
	}
};
static_assert(alignof(UHWGameplayEffect_MovementSpeed) == 0x000008, "Wrong alignment on UHWGameplayEffect_MovementSpeed");
static_assert(sizeof(UHWGameplayEffect_MovementSpeed) == 0x000B08, "Wrong size on UHWGameplayEffect_MovementSpeed");
static_assert(offsetof(UHWGameplayEffect_MovementSpeed, MovementSpeedModifiers) == 0x000AB8, "Member 'UHWGameplayEffect_MovementSpeed::MovementSpeedModifiers' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Slow
// 0x0008 (0x0B10 - 0x0B08)
class UHWGameplayEffect_Slow : public UHWGameplayEffect_MovementSpeed
{
public:
	uint8                                         Pad_B08[0x8];                                      // 0x0B08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Slow">();
	}
	static class UHWGameplayEffect_Slow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Slow>();
	}
};
static_assert(alignof(UHWGameplayEffect_Slow) == 0x000008, "Wrong alignment on UHWGameplayEffect_Slow");
static_assert(sizeof(UHWGameplayEffect_Slow) == 0x000B10, "Wrong size on UHWGameplayEffect_Slow");

// Class Hemingway.HWAIPlayLogic_PushTugOfWar
// 0x0018 (0x0080 - 0x0068)
class UHWAIPlayLogic_PushTugOfWar : public UHWAIPlayLogic
{
public:
	float                                         MinHealthPercent;                                  // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowHealthPercent;                                  // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowHealthWeight;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceToFront;                                // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartOfMatchTiming;                                // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxExecutionTime;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_PushTugOfWar">();
	}
	static class UHWAIPlayLogic_PushTugOfWar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_PushTugOfWar>();
	}
};
static_assert(alignof(UHWAIPlayLogic_PushTugOfWar) == 0x000008, "Wrong alignment on UHWAIPlayLogic_PushTugOfWar");
static_assert(sizeof(UHWAIPlayLogic_PushTugOfWar) == 0x000080, "Wrong size on UHWAIPlayLogic_PushTugOfWar");
static_assert(offsetof(UHWAIPlayLogic_PushTugOfWar, MinHealthPercent) == 0x000068, "Member 'UHWAIPlayLogic_PushTugOfWar::MinHealthPercent' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_PushTugOfWar, LowHealthPercent) == 0x00006C, "Member 'UHWAIPlayLogic_PushTugOfWar::LowHealthPercent' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_PushTugOfWar, LowHealthWeight) == 0x000070, "Member 'UHWAIPlayLogic_PushTugOfWar::LowHealthWeight' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_PushTugOfWar, MaxDistanceToFront) == 0x000074, "Member 'UHWAIPlayLogic_PushTugOfWar::MaxDistanceToFront' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_PushTugOfWar, StartOfMatchTiming) == 0x000078, "Member 'UHWAIPlayLogic_PushTugOfWar::StartOfMatchTiming' has a wrong offset!");
static_assert(offsetof(UHWAIPlayLogic_PushTugOfWar, MaxExecutionTime) == 0x00007C, "Member 'UHWAIPlayLogic_PushTugOfWar::MaxExecutionTime' has a wrong offset!");

// Class Hemingway.HWAIPlayLogic_UseBaseTeleporter
// 0x0008 (0x0080 - 0x0078)
class UHWAIPlayLogic_UseBaseTeleporter : public UHWAIPlayLogic_Interact
{
public:
	struct FGameplayTag                           TeleporterCooldownTag;                             // 0x0078(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayLogic_UseBaseTeleporter">();
	}
	static class UHWAIPlayLogic_UseBaseTeleporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayLogic_UseBaseTeleporter>();
	}
};
static_assert(alignof(UHWAIPlayLogic_UseBaseTeleporter) == 0x000008, "Wrong alignment on UHWAIPlayLogic_UseBaseTeleporter");
static_assert(sizeof(UHWAIPlayLogic_UseBaseTeleporter) == 0x000080, "Wrong size on UHWAIPlayLogic_UseBaseTeleporter");
static_assert(offsetof(UHWAIPlayLogic_UseBaseTeleporter, TeleporterCooldownTag) == 0x000078, "Member 'UHWAIPlayLogic_UseBaseTeleporter::TeleporterCooldownTag' has a wrong offset!");

// Class Hemingway.HWAIPlayComponent
// 0x0038 (0x00D8 - 0x00A0)
class UHWAIPlayComponent final : public UActorComponent
{
public:
	bool                                          bDelayRegistration;                                // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceUpdate;                                      // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDataTableRowHandle>            GeneralPlays;                                      // 0x00A8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDataTableRowHandle>            OrderPlays;                                        // 0x00B8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDataTableRowHandle>            ChaosPlays;                                        // 0x00C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void RegisterPlays();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayComponent">();
	}
	static class UHWAIPlayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayComponent>();
	}
};
static_assert(alignof(UHWAIPlayComponent) == 0x000008, "Wrong alignment on UHWAIPlayComponent");
static_assert(sizeof(UHWAIPlayComponent) == 0x0000D8, "Wrong size on UHWAIPlayComponent");
static_assert(offsetof(UHWAIPlayComponent, bDelayRegistration) == 0x0000A0, "Member 'UHWAIPlayComponent::bDelayRegistration' has a wrong offset!");
static_assert(offsetof(UHWAIPlayComponent, bForceUpdate) == 0x0000A1, "Member 'UHWAIPlayComponent::bForceUpdate' has a wrong offset!");
static_assert(offsetof(UHWAIPlayComponent, GeneralPlays) == 0x0000A8, "Member 'UHWAIPlayComponent::GeneralPlays' has a wrong offset!");
static_assert(offsetof(UHWAIPlayComponent, OrderPlays) == 0x0000B8, "Member 'UHWAIPlayComponent::OrderPlays' has a wrong offset!");
static_assert(offsetof(UHWAIPlayComponent, ChaosPlays) == 0x0000C8, "Member 'UHWAIPlayComponent::ChaosPlays' has a wrong offset!");

// Class Hemingway.HWAIPlayCaller
// 0x00E8 (0x0110 - 0x0028)
class UHWAIPlayCaller final : public UObject
{
public:
	float                                         QueryForNewPlayUpdateRate;                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateCurrentPlayUpdateRate;                       // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAverageTeamLevelForLaningStage;                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxStructureCountForEndGameStage;                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EHWAIPlayGameStage, float>               MinWeightToExecuteByGameStage;                     // 0x0038(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWTeamState>            Team;                                              // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHWAIPlayLogic*>                 Playlist;                                          // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      PlayCooldowns;                                     // 0x00A0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class FName                                   ForcedPlayRowName;                                 // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BailOnCurrentPlay(const class AHWCharacter_Base* Character);
	void DebugForcePlay(class FName PlayRowName);
	void ForceQueryForNewPlays();
	void QueryForNewPlays();
	void RegisterPlays(class AActor* AssociatedActor, const TArray<struct FDataTableRowHandle>& plays, const bool bForceUpdate);
	void StartPlayCalling(class AHWTeamState* inTeam);
	void StopPlayCalling();
	void UnregisterPlays(class AActor* AssociatedActor);
	void UpdateCurrentPlays();

	struct FGameplayTag GetActivePlayCurrentStateTag(const class AHWCharacter_Base* Character) const;
	void GetPlayParticipants(const class AHWCharacter_Base* Character, TArray<class AHWCharacter_Base*>* OutParticipants) const;
	float GetTimeInPlay(const class AHWCharacter_Base* Character) const;
	bool IsCharacterInActivePlay(const class AHWCharacter_Base* Character) const;
	bool IsCharacterInActiveSpecificPlay(const class AHWCharacter_Base* Character, const struct FDataTableRowHandle& PlayId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIPlayCaller">();
	}
	static class UHWAIPlayCaller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIPlayCaller>();
	}
};
static_assert(alignof(UHWAIPlayCaller) == 0x000008, "Wrong alignment on UHWAIPlayCaller");
static_assert(sizeof(UHWAIPlayCaller) == 0x000110, "Wrong size on UHWAIPlayCaller");
static_assert(offsetof(UHWAIPlayCaller, QueryForNewPlayUpdateRate) == 0x000028, "Member 'UHWAIPlayCaller::QueryForNewPlayUpdateRate' has a wrong offset!");
static_assert(offsetof(UHWAIPlayCaller, UpdateCurrentPlayUpdateRate) == 0x00002C, "Member 'UHWAIPlayCaller::UpdateCurrentPlayUpdateRate' has a wrong offset!");
static_assert(offsetof(UHWAIPlayCaller, MaxAverageTeamLevelForLaningStage) == 0x000030, "Member 'UHWAIPlayCaller::MaxAverageTeamLevelForLaningStage' has a wrong offset!");
static_assert(offsetof(UHWAIPlayCaller, MaxStructureCountForEndGameStage) == 0x000034, "Member 'UHWAIPlayCaller::MaxStructureCountForEndGameStage' has a wrong offset!");
static_assert(offsetof(UHWAIPlayCaller, MinWeightToExecuteByGameStage) == 0x000038, "Member 'UHWAIPlayCaller::MinWeightToExecuteByGameStage' has a wrong offset!");
static_assert(offsetof(UHWAIPlayCaller, Team) == 0x000088, "Member 'UHWAIPlayCaller::Team' has a wrong offset!");
static_assert(offsetof(UHWAIPlayCaller, Playlist) == 0x000090, "Member 'UHWAIPlayCaller::Playlist' has a wrong offset!");
static_assert(offsetof(UHWAIPlayCaller, PlayCooldowns) == 0x0000A0, "Member 'UHWAIPlayCaller::PlayCooldowns' has a wrong offset!");
static_assert(offsetof(UHWAIPlayCaller, ForcedPlayRowName) == 0x0000F0, "Member 'UHWAIPlayCaller::ForcedPlayRowName' has a wrong offset!");

// Class Hemingway.HWGEMMC_Cooldown
// 0x0070 (0x00B0 - 0x0040)
class UHWGEMMC_Cooldown : public UHWGEModiferMagnitudeCalc_Base
{
public:
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_AdjustCooldown(const struct FGameplayEffectSpec& Spec, const float InCooldownBase, const float InCooldownMultiplier, const float InCooldownFlatDelta, float* OutCooldownMultiplier, float* OutCooldownFlatDelta) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEMMC_Cooldown">();
	}
	static class UHWGEMMC_Cooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEMMC_Cooldown>();
	}
};
static_assert(alignof(UHWGEMMC_Cooldown) == 0x000008, "Wrong alignment on UHWGEMMC_Cooldown");
static_assert(sizeof(UHWGEMMC_Cooldown) == 0x0000B0, "Wrong size on UHWGEMMC_Cooldown");

// Class Hemingway.HWPlayCallSuggestionManager
// 0x0050 (0x02E8 - 0x0298)
class AHWPlayCallSuggestionManager : public AActor
{
public:
	float                                         MinRouteDistanceForVFX;                            // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PathPointArriveDistanceForVFX;                     // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWPlayCallSuggestion                  PlayCallSuggestion;                                // 0x02A0(0x0048)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void ClearPlayCallSuggestionVFX();
	void CreatePlayCallSuggestionVFX(const struct FVector& P0, const struct FVector& P1, const struct FVector& Tangent0, const struct FVector& Tangent1, bool bStartSegment, bool bEndSegment);
	void HandleEndSuggestion();
	void HandleStartSuggestion();
	void OnRep_PlayCallSuggestion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayCallSuggestionManager">();
	}
	static class AHWPlayCallSuggestionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPlayCallSuggestionManager>();
	}
};
static_assert(alignof(AHWPlayCallSuggestionManager) == 0x000008, "Wrong alignment on AHWPlayCallSuggestionManager");
static_assert(sizeof(AHWPlayCallSuggestionManager) == 0x0002E8, "Wrong size on AHWPlayCallSuggestionManager");
static_assert(offsetof(AHWPlayCallSuggestionManager, MinRouteDistanceForVFX) == 0x000298, "Member 'AHWPlayCallSuggestionManager::MinRouteDistanceForVFX' has a wrong offset!");
static_assert(offsetof(AHWPlayCallSuggestionManager, PathPointArriveDistanceForVFX) == 0x00029C, "Member 'AHWPlayCallSuggestionManager::PathPointArriveDistanceForVFX' has a wrong offset!");
static_assert(offsetof(AHWPlayCallSuggestionManager, PlayCallSuggestion) == 0x0002A0, "Member 'AHWPlayCallSuggestionManager::PlayCallSuggestion' has a wrong offset!");

// Class Hemingway.HWAIReasonerComponent
// 0x0048 (0x00E8 - 0x00A0)
class UHWAIReasonerComponent final : public UHWActorComponent
{
public:
	TArray<class FName>                           PriorityLanes;                                     // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         LanesIndex;                                        // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWAIReasonerOption*>            BaseOptions;                                       // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UHWAIReasonerOption*                    CurrentActiveOption;                               // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWWaypoint*                            StartingWaypoint;                                  // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StartWaypointLaneID;                               // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWaypointPathDirectionType                    LaneDirection;                                     // 0x00E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetermineCurrentAction();
	bool GetLandmarkTargets(const struct FGameplayTagContainer& TargetTags, TArray<class AHWCharacter_Base*>* OutResults);
	const class FName GetLaneByIndex(int32 Index_0, bool bSetIndex);
	void InitilizeBotProperties(const class UHWBotPropertiesDefinition* Properties);
	const class FName SelectNextLaneID(ELaneSelectType SelectType);
	void SetBaseActiveActions(const TArray<TSubclassOf<class UHWAIReasonerOption>>& NewOptions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIReasonerComponent">();
	}
	static class UHWAIReasonerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIReasonerComponent>();
	}
};
static_assert(alignof(UHWAIReasonerComponent) == 0x000008, "Wrong alignment on UHWAIReasonerComponent");
static_assert(sizeof(UHWAIReasonerComponent) == 0x0000E8, "Wrong size on UHWAIReasonerComponent");
static_assert(offsetof(UHWAIReasonerComponent, PriorityLanes) == 0x0000A0, "Member 'UHWAIReasonerComponent::PriorityLanes' has a wrong offset!");
static_assert(offsetof(UHWAIReasonerComponent, LanesIndex) == 0x0000B0, "Member 'UHWAIReasonerComponent::LanesIndex' has a wrong offset!");
static_assert(offsetof(UHWAIReasonerComponent, BaseOptions) == 0x0000B8, "Member 'UHWAIReasonerComponent::BaseOptions' has a wrong offset!");
static_assert(offsetof(UHWAIReasonerComponent, CurrentActiveOption) == 0x0000C8, "Member 'UHWAIReasonerComponent::CurrentActiveOption' has a wrong offset!");
static_assert(offsetof(UHWAIReasonerComponent, StartingWaypoint) == 0x0000D0, "Member 'UHWAIReasonerComponent::StartingWaypoint' has a wrong offset!");
static_assert(offsetof(UHWAIReasonerComponent, StartWaypointLaneID) == 0x0000D8, "Member 'UHWAIReasonerComponent::StartWaypointLaneID' has a wrong offset!");
static_assert(offsetof(UHWAIReasonerComponent, LaneDirection) == 0x0000E0, "Member 'UHWAIReasonerComponent::LaneDirection' has a wrong offset!");

// Class Hemingway.HWCharacter_AnimInstStatue
// 0x0030 (0x0600 - 0x05D0)
class UHWCharacter_AnimInstStatue final : public UHWCharacter_AnimInstBase
{
public:
	struct FPoseSnapshot                          DepictedPoseSnapshot;                              // 0x05C8(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_AnimInstStatue">();
	}
	static class UHWCharacter_AnimInstStatue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCharacter_AnimInstStatue>();
	}
};
static_assert(alignof(UHWCharacter_AnimInstStatue) == 0x000010, "Wrong alignment on UHWCharacter_AnimInstStatue");
static_assert(sizeof(UHWCharacter_AnimInstStatue) == 0x000600, "Wrong size on UHWCharacter_AnimInstStatue");
static_assert(offsetof(UHWCharacter_AnimInstStatue, DepictedPoseSnapshot) == 0x0005C8, "Member 'UHWCharacter_AnimInstStatue::DepictedPoseSnapshot' has a wrong offset!");

// Class Hemingway.HWAIReasonerOption
// 0x0018 (0x0040 - 0x0028)
class UHWAIReasonerOption final : public UObject
{
public:
	class FName                                   ActionName;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          ActionBehaviorTree;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Stickiness;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateWeight(class AHWAIController* AIController);
	bool CanActivate(class AHWAIController* AIController);
	class AGameStateBase* GetGameState(class AHWAIController* AIController);
	class UWorld* GetWorldFromController(class AHWAIController* AIController);
	void StartAction(class AHWAIController* AIController);
	void StopAction(class AHWAIController* AIController);
	void TickAction(float DeltaTime, class AHWAIController* AIController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIReasonerOption">();
	}
	static class UHWAIReasonerOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIReasonerOption>();
	}
};
static_assert(alignof(UHWAIReasonerOption) == 0x000008, "Wrong alignment on UHWAIReasonerOption");
static_assert(sizeof(UHWAIReasonerOption) == 0x000040, "Wrong size on UHWAIReasonerOption");
static_assert(offsetof(UHWAIReasonerOption, ActionName) == 0x000028, "Member 'UHWAIReasonerOption::ActionName' has a wrong offset!");
static_assert(offsetof(UHWAIReasonerOption, ActionBehaviorTree) == 0x000030, "Member 'UHWAIReasonerOption::ActionBehaviorTree' has a wrong offset!");
static_assert(offsetof(UHWAIReasonerOption, Stickiness) == 0x000038, "Member 'UHWAIReasonerOption::Stickiness' has a wrong offset!");

// Class Hemingway.HWAISquadManager
// 0x0068 (0x0300 - 0x0298)
class AHWAISquadManager : public AActor
{
public:
	float                                         TimeBetweenMerges;                                 // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x8];                                      // 0x029C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenSpreads;                                // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroupSpreadFactor;                                 // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpreadSideMultiplier;                              // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpreadForwardMultiplier;                           // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AHWCharacter_NPC>> SquadMembers;                                     // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      FormationOffsets;                                  // 0x02C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      CombatFormationOffsets;                            // 0x02D8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         LeaderIndex;                                       // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWBotFactory*                          BotFactory;                                        // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SquadTeamNum;                                      // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSquadMember(class AHWCharacter_NPC* Character);
	struct FVector GetSquadMemberRelativeLocationAlongRoute(int32 Index_0, EWaypointPathDirectionType Direction);
	void OnSquadMemberAdded(class AHWCharacter_NPC* Character);
	void RemoveSquadMember(class AHWCharacter_NPC* Character);
	void SpreadSquad();

	bool AreAllMembersWithinRange(const struct FVector& Center, float Range) const;
	bool CanMemberPerformSquadTactics(const class AHWCharacter_NPC* member) const;
	bool DoesSquadHaveTag(const struct FGameplayTagContainer& TagsToCheck, bool bCheckAll) const;
	bool DoesSquadMemberHaveTag(int32 Index_0, const struct FGameplayTagContainer& TagsToCheck, bool bCheckAll) const;
	class AHWBotFactory* GetBotFactory() const;
	void GetMembers(TArray<class AHWCharacter_NPC*>* outMembers) const;
	void GetMembersAsActors(TArray<class AActor*>* outMembers) const;
	struct FVector GetMembersAvgLocation() const;
	class AHWCharacter_NPC* GetSquadLeader() const;
	class AHWCharacter_NPC* GetSquadMemberByIndex(int32 Index_0) const;
	struct FVector GetSquadMemberCombatFormationRelativeLocation(int32 Index_0) const;
	struct FVector GetSquadMemberRelativeLocation(int32 Index_0) const;
	int32 GetSquadTeamNum() const;
	bool IsMember(const class AHWCharacter_NPC* Character) const;
	bool IsMerged() const;
	bool IsSquadInCombat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAISquadManager">();
	}
	static class AHWAISquadManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWAISquadManager>();
	}
};
static_assert(alignof(AHWAISquadManager) == 0x000008, "Wrong alignment on AHWAISquadManager");
static_assert(sizeof(AHWAISquadManager) == 0x000300, "Wrong size on AHWAISquadManager");
static_assert(offsetof(AHWAISquadManager, TimeBetweenMerges) == 0x000298, "Member 'AHWAISquadManager::TimeBetweenMerges' has a wrong offset!");
static_assert(offsetof(AHWAISquadManager, TimeBetweenSpreads) == 0x0002A4, "Member 'AHWAISquadManager::TimeBetweenSpreads' has a wrong offset!");
static_assert(offsetof(AHWAISquadManager, GroupSpreadFactor) == 0x0002A8, "Member 'AHWAISquadManager::GroupSpreadFactor' has a wrong offset!");
static_assert(offsetof(AHWAISquadManager, SpreadSideMultiplier) == 0x0002AC, "Member 'AHWAISquadManager::SpreadSideMultiplier' has a wrong offset!");
static_assert(offsetof(AHWAISquadManager, SpreadForwardMultiplier) == 0x0002B0, "Member 'AHWAISquadManager::SpreadForwardMultiplier' has a wrong offset!");
static_assert(offsetof(AHWAISquadManager, SquadMembers) == 0x0002B8, "Member 'AHWAISquadManager::SquadMembers' has a wrong offset!");
static_assert(offsetof(AHWAISquadManager, FormationOffsets) == 0x0002C8, "Member 'AHWAISquadManager::FormationOffsets' has a wrong offset!");
static_assert(offsetof(AHWAISquadManager, CombatFormationOffsets) == 0x0002D8, "Member 'AHWAISquadManager::CombatFormationOffsets' has a wrong offset!");
static_assert(offsetof(AHWAISquadManager, LeaderIndex) == 0x0002E8, "Member 'AHWAISquadManager::LeaderIndex' has a wrong offset!");
static_assert(offsetof(AHWAISquadManager, BotFactory) == 0x0002F0, "Member 'AHWAISquadManager::BotFactory' has a wrong offset!");
static_assert(offsetof(AHWAISquadManager, SquadTeamNum) == 0x0002F8, "Member 'AHWAISquadManager::SquadTeamNum' has a wrong offset!");

// Class Hemingway.HWGodBotMapSetupData
// 0x0018 (0x0048 - 0x0030)
class UHWGodBotMapSetupData final : public UDataAsset
{
public:
	class UHWCharacterItem*                       Item;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Role;                                              // 0x0038(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Lane;                                              // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGodBotMapSetupData">();
	}
	static class UHWGodBotMapSetupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGodBotMapSetupData>();
	}
};
static_assert(alignof(UHWGodBotMapSetupData) == 0x000008, "Wrong alignment on UHWGodBotMapSetupData");
static_assert(sizeof(UHWGodBotMapSetupData) == 0x000048, "Wrong size on UHWGodBotMapSetupData");
static_assert(offsetof(UHWGodBotMapSetupData, Item) == 0x000030, "Member 'UHWGodBotMapSetupData::Item' has a wrong offset!");
static_assert(offsetof(UHWGodBotMapSetupData, Role) == 0x000038, "Member 'UHWGodBotMapSetupData::Role' has a wrong offset!");
static_assert(offsetof(UHWGodBotMapSetupData, Lane) == 0x000040, "Member 'UHWGodBotMapSetupData::Lane' has a wrong offset!");

// Class Hemingway.HWAIThreatEvaluator
// 0x00F0 (0x0120 - 0x0030)
class UHWAIThreatEvaluator final : public UDataAsset
{
public:
	float                                         LossOfPerceptionTimeout;                           // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceToPerceiveAsThreat;                     // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProtectedThreatModifier;                           // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxStealthPerceptionTime;                          // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTargetStickyness;                           // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTargetStickyTime;                           // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowThreatStealing;                              // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ThreatStealChanceByDamagePercentageCurve;          // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AllowedThreatStealerTags;                          // 0x0058(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         CarryOverThreatValue;                              // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CarryOverThreatDecaySpeed;                         // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLastHitByThreatTime;                            // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamagedByThreatWeight;                             // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWAIThreatCalculation                 DistanceCalculation;                               // 0x0088(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LowHealthThreshold;                                // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowHealthValue;                                    // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, float>              TargetTypeValues;                                  // 0x00B0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  IgnoreTags;                                        // 0x0100(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAIThreatEvaluator">();
	}
	static class UHWAIThreatEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAIThreatEvaluator>();
	}
};
static_assert(alignof(UHWAIThreatEvaluator) == 0x000008, "Wrong alignment on UHWAIThreatEvaluator");
static_assert(sizeof(UHWAIThreatEvaluator) == 0x000120, "Wrong size on UHWAIThreatEvaluator");
static_assert(offsetof(UHWAIThreatEvaluator, LossOfPerceptionTimeout) == 0x000030, "Member 'UHWAIThreatEvaluator::LossOfPerceptionTimeout' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, MinDistanceToPerceiveAsThreat) == 0x000034, "Member 'UHWAIThreatEvaluator::MinDistanceToPerceiveAsThreat' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, ProtectedThreatModifier) == 0x000038, "Member 'UHWAIThreatEvaluator::ProtectedThreatModifier' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, MaxStealthPerceptionTime) == 0x00003C, "Member 'UHWAIThreatEvaluator::MaxStealthPerceptionTime' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, CurrentTargetStickyness) == 0x000040, "Member 'UHWAIThreatEvaluator::CurrentTargetStickyness' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, CurrentTargetStickyTime) == 0x000044, "Member 'UHWAIThreatEvaluator::CurrentTargetStickyTime' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, bAllowThreatStealing) == 0x000048, "Member 'UHWAIThreatEvaluator::bAllowThreatStealing' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, ThreatStealChanceByDamagePercentageCurve) == 0x000050, "Member 'UHWAIThreatEvaluator::ThreatStealChanceByDamagePercentageCurve' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, AllowedThreatStealerTags) == 0x000058, "Member 'UHWAIThreatEvaluator::AllowedThreatStealerTags' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, CarryOverThreatValue) == 0x000078, "Member 'UHWAIThreatEvaluator::CarryOverThreatValue' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, CarryOverThreatDecaySpeed) == 0x00007C, "Member 'UHWAIThreatEvaluator::CarryOverThreatDecaySpeed' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, MaxLastHitByThreatTime) == 0x000080, "Member 'UHWAIThreatEvaluator::MaxLastHitByThreatTime' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, DamagedByThreatWeight) == 0x000084, "Member 'UHWAIThreatEvaluator::DamagedByThreatWeight' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, DistanceCalculation) == 0x000088, "Member 'UHWAIThreatEvaluator::DistanceCalculation' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, LowHealthThreshold) == 0x0000A8, "Member 'UHWAIThreatEvaluator::LowHealthThreshold' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, LowHealthValue) == 0x0000AC, "Member 'UHWAIThreatEvaluator::LowHealthValue' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, TargetTypeValues) == 0x0000B0, "Member 'UHWAIThreatEvaluator::TargetTypeValues' has a wrong offset!");
static_assert(offsetof(UHWAIThreatEvaluator, IgnoreTags) == 0x000100, "Member 'UHWAIThreatEvaluator::IgnoreTags' has a wrong offset!");

// Class Hemingway.HWGameState
// 0x0568 (0x0878 - 0x0310)
class AHWGameState : public ARHGameState
{
public:
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWDisplayInfoManager*                  DisplayInfoManager;                                // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWMinimapManager*                      MinimapManager;                                    // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWDynamicSubLevelComponent*            DynamicSubLevelComponent;                          // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SessionId;                                         // 0x0340(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGenericTeamId>                 TeamPlacementOrder;                                // 0x0350(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* AddedTeam)> OnTeamAdded;                       // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* RemovedTeam)> OnTeamRemoved;                   // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTeamsUpdated;                                    // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<struct FGenericTeamId>& UpdatedPlacementOrder)> OnTeamPlacementOrderUpdated; // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AHWTeamState*>                   Teams;                                             // 0x03A0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWCharacter_Base*>              LandmarkActors;                                    // 0x03B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FDamageEventData& DamageEventData)> OnPlayerDamaged;  // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const class AActor* EventInstigator, const class AActor* Affected, const TArray<class UObject*>& Info)> OnGameFeedNotification; // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWGameStatsTracker* GameStatsTracker)> OnGameStatsTrackerReplicated; // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AHWGameStatsTracker*                    GameStatsTracker;                                  // 0x03F8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWPingManager* PingManager)> OnPingManagerReplicated;       // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AHWPingManager*                         PingManager;                                       // 0x0410(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWVGSManager* VGSManager)> OnVGSManagerReplicated;          // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AHWVGSManager*                          VGSManager;                                        // 0x0428(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWChatManager* VGSManager)> OnChatManagerReplicated;        // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AHWChatManager*                         ChatManager;                                       // 0x0440(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FGameplayTag& PhaseTag, float PhaseStartTime, float PhaseDuration)> OnPhaseConfigChanged; // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& NewPhase)> OnGamePhaseStarted;          // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& CurrentPhase)> OnGamePhaseEnded;        // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bDidAllPlayersConnect)> OnAllPlayersConnected;                // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& TransitionInfoTag)> OnTransitionInfoTagChanged; // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHWGamePhaseConfig                     CurrentPhaseConfig;                                // 0x0498(0x0058)(Net, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UHWPhaseLogic*                          CurrentPhaseLogic;                                 // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bConfirmedAllPlayersConnected;                     // 0x0500(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_501[0x3];                                      // 0x0501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TransitionInfoTag;                                 // 0x0504(0x0008)(Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchActivePhaseDuration;                          // 0x050C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FReplicatedPreloader                   Preloader;                                         // 0x0510(0x01E0)(Net, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, const class UHWCharacterItem* Choice)> OnPlayerDraftChoiceUpdated; // 0x06F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_700[0x18];                                     // 0x0700(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWProjectile*>                  SimulatedProjectiles;                              // 0x0718(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_728[0x10];                                     // 0x0728(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnReceivedGameModeClass;                           // 0x0738(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AHWBotFactory*>                  BotFactories;                                      // 0x0748(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class AHWWaypointSet*                         WaypointSet;                                       // 0x0758(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LevelLoadActionId;                                 // 0x0760(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_764[0x8];                                      // 0x0764(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWillUploadPEX;                                    // 0x076C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_76D[0x3];                                      // 0x076D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedStartingGold;                                // 0x0770(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasCachedStartingStats;                           // 0x0774(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_775[0x3];                                      // 0x0775(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AHWEventManager>            EventManagerClass;                                 // 0x0778(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWEventManager*                        EventManager;                                      // 0x0780(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSendMinionSpawnAnnouncements;                     // 0x0788(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_789[0x3];                                      // 0x0789(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreMinionSpawnAnnouncementTime;                    // 0x078C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_790[0x8];                                      // 0x0790(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bIsPaused, class AHWTeamState* PausingTeam, const struct FDateTime& PauseStartTime)> OnPauseStateUpdated; // 0x0798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 UnpauseDelayRemaining)> OnUnpauseDelayUpdated;               // 0x07A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsPaused;                                         // 0x07B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B9[0x7];                                      // 0x07B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWTeamState*                           PausingTeam;                                       // 0x07C0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              PauseStartTime;                                    // 0x07C8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbilitiesCanBeCanceledPreFire;                    // 0x07D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D1[0x7];                                      // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWAladdinArenaManager*                 AladdinArenaManager;                               // 0x07D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWDeployable* Deployable)> OnDeployableSpawnedDelegate;     // 0x07E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWDeployable* Deployable)> OnDeployableDestroyedDelegate;   // 0x07F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AHWDeployable*>                  Deployables;                                       // 0x0800(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FHWActiveFamiliarInfo& FamiliarInfo)> OnFamiliarSpawnedDelegate; // 0x0810(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHWActiveFamiliarInfo& FamiliarInfo)> OnFamiliarDestroyedDelegate; // 0x0820(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHWActiveFamiliarInfo>          Familiars;                                         // 0x0830(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UHWGameAudioManagerComponent*           GameAudioManagerComponent;                         // 0x0840(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameAudioManagerComponent> AudioManagerClass;                               // 0x0848(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnMatchDeserted;                                   // 0x0850(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bMatchDeserted;                                    // 0x0860(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_861[0xF];                                      // 0x0861(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTutorialAnnouncementsEnabled;                   // 0x0870(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_871[0x7];                                      // 0x0871(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FHWDynamicSubLevelHandle ApplyDynamicSubLevel(class UWorld* SubLevel);
	struct FHWDynamicSubLevelHandle ApplyDynamicSubLevelBySoftObjectPtr(TSoftObjectPtr<class UWorld> SubLevel);
	void CacheStartingPropertiesForStats();
	void GamePhaseEnding(const struct FGameplayTag& EndingPhase);
	void GamePhaseStarting(const struct FGameplayTag& NewPhase);
	int32 GenerateNextClientOnlyProjectileInstanceId();
	int32 GenerateNextProjectileInstanceId();
	void GetGudSendStartGame();
	int32 GetTeamCount();
	class AHWWaypointSet* GetWaypointSet();
	void HandleTeamKillsUpdated(class AHWTeamState* TeamState, int32 NewTeamKills);
	void HandleTeamStatsTrackerReplicated(class AHWTeamState* TeamState, class AHWTeamStatsTracker* TeamStatsTracker);
	void MarkAllPlayersConnected(bool bAreAllConnected);
	void MulticastNotifyGameFeedEvent(const struct FGameplayTag& EventTag, const class AActor* EventInstigator, const class AActor* Affected, const TArray<class UObject*>& Info);
	void MulticastPlayerDraftChoiceUpdated(class AHWPlayerState* PlayerState, const class UHWCharacterItem* Choice);
	void MulticastSendGameplayEventToActor(class AActor* EventReciever, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	void MulticastUpdatePauseState(bool bInIsPaused, class AHWTeamState* InPausingTeam, const struct FDateTime& InPauseStartTime);
	void MulticastUpdateUnpauseDelay(int32 UnpauseDelayRemaining);
	void OnRep_ChatManager();
	void OnRep_CurrentPhaseConfig();
	void OnRep_GameStatsTracker();
	void OnRep_IsPaused();
	void OnRep_MatchDeserted();
	void OnRep_PauseStartTime();
	void OnRep_PausingTeam();
	void OnRep_PingManager();
	void OnRep_TeamPlacementOrder();
	void OnRep_Teams();
	void OnRep_TransitionInfoTag();
	void OnRep_UploadPex();
	void OnRep_VGSManager();
	void OwningClientSendGameplayEventToActor(class AActor* EventReciever, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	void RemoveDynamicSubLevel(const struct FHWDynamicSubLevelHandle& LevelHandle);
	void ServerSendGameplayEventToActor(class AActor* EventReciever, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	void SetAbilitiesCanBeCanceledPreFire(const bool bOn);
	void SetDynamicSubLevelInvisible(const struct FHWDynamicSubLevelHandle& LevelHandle);
	void SetDynamicSubLevelVisible(const struct FHWDynamicSubLevelHandle& LevelHandle);
	void SetPauseState(bool bInIsPaused, class AHWTeamState* InPausingTeam, const struct FDateTime& InPauseStartTime);
	bool TeamCaresAboutObservingOthersInMinimap(const struct FGenericTeamId& TeamId);

	bool CanAbilitiesBeCanceledPreFire() const;
	bool CanEarlySurrender(int32 TeamId) const;
	class AHWAladdinArenaManager* GetAladdinArenaManager() const;
	void GetAllBotFactories(TArray<class AHWBotFactory*>* outBotFactories) const;
	void GetAllBotFactoriesWithAssetTags(const struct FGameplayTagRequirements& TagRequirements, TArray<class AHWBotFactory*>* outFactories) const;
	class UHWGameAudioManagerComponent* GetAudioManagerComponent() const;
	class AHWChatManager* GetChatManager() const;
	struct FGameplayTag GetCurrentGamePhaseTag() const;
	const struct FHWGamePhaseConfig GetCurrentPhaseConfig() const;
	float GetCurrentPhaseDuration() const;
	float GetCurrentPhaseElapsedTime() const;
	float GetCurrentPhaseRemainingTime() const;
	float GetCurrentPhaseStartTime() const;
	class UHWDisplayInfoManager* GetDisplayInfoManager() const;
	class AHWEventManager* GetEventManager() const;
	class AHWGameStatsTracker* GetGameStatsTracker() const;
	bool GetHaveAllPlayersInitiallyConnected() const;
	int32 GetLocalPlayerTeamPlacementOrder() const;
	float GetMatchActivePhaseTime() const;
	bool GetOpposingTeams(const struct FGenericTeamId& FriendlyTeamId, bool bIncludeNeutralTeam, TArray<class AHWTeamState*>* OutOpposingTeams) const;
	class AHWPingManager* GetPingManager() const;
	class AHWPlayerState* GetPlayer(const struct FHWPersistentPlayerId& PlayerId) const;
	class AHWProjectile* GetSimulatedProjectile(const int32 ProjectileId) const;
	class AHWTeamState* GetTeam(const struct FGenericTeamId& TeamId) const;
	int32 GetTeamPlacementOrder(const class APlayerController* PlayerController) const;
	int32 GetTeamPlacementOrderWithTeamId(const struct FGenericTeamId& TeamId) const;
	TArray<class AHWTeamState*> GetTeams() const;
	struct FGameplayTag GetTransitionInfoTag() const;
	class AHWVGSManager* GetVGSManager() const;
	bool IsDyanmicSubLevelVisible(const struct FHWDynamicSubLevelHandle& LevelHandle) const;
	bool IsDynamicSubLevelLoaded(const struct FHWDynamicSubLevelHandle& LevelHandle) const;
	bool IsMatchDeserted() const;
	bool IsTutorialAnnouncementsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameState">();
	}
	static class AHWGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameState>();
	}
};
static_assert(alignof(AHWGameState) == 0x000008, "Wrong alignment on AHWGameState");
static_assert(sizeof(AHWGameState) == 0x000878, "Wrong size on AHWGameState");
static_assert(offsetof(AHWGameState, DisplayInfoManager) == 0x000328, "Member 'AHWGameState::DisplayInfoManager' has a wrong offset!");
static_assert(offsetof(AHWGameState, MinimapManager) == 0x000330, "Member 'AHWGameState::MinimapManager' has a wrong offset!");
static_assert(offsetof(AHWGameState, DynamicSubLevelComponent) == 0x000338, "Member 'AHWGameState::DynamicSubLevelComponent' has a wrong offset!");
static_assert(offsetof(AHWGameState, SessionId) == 0x000340, "Member 'AHWGameState::SessionId' has a wrong offset!");
static_assert(offsetof(AHWGameState, TeamPlacementOrder) == 0x000350, "Member 'AHWGameState::TeamPlacementOrder' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnTeamAdded) == 0x000360, "Member 'AHWGameState::OnTeamAdded' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnTeamRemoved) == 0x000370, "Member 'AHWGameState::OnTeamRemoved' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnTeamsUpdated) == 0x000380, "Member 'AHWGameState::OnTeamsUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnTeamPlacementOrderUpdated) == 0x000390, "Member 'AHWGameState::OnTeamPlacementOrderUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState, Teams) == 0x0003A0, "Member 'AHWGameState::Teams' has a wrong offset!");
static_assert(offsetof(AHWGameState, LandmarkActors) == 0x0003B8, "Member 'AHWGameState::LandmarkActors' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnPlayerDamaged) == 0x0003C8, "Member 'AHWGameState::OnPlayerDamaged' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnGameFeedNotification) == 0x0003D8, "Member 'AHWGameState::OnGameFeedNotification' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnGameStatsTrackerReplicated) == 0x0003E8, "Member 'AHWGameState::OnGameStatsTrackerReplicated' has a wrong offset!");
static_assert(offsetof(AHWGameState, GameStatsTracker) == 0x0003F8, "Member 'AHWGameState::GameStatsTracker' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnPingManagerReplicated) == 0x000400, "Member 'AHWGameState::OnPingManagerReplicated' has a wrong offset!");
static_assert(offsetof(AHWGameState, PingManager) == 0x000410, "Member 'AHWGameState::PingManager' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnVGSManagerReplicated) == 0x000418, "Member 'AHWGameState::OnVGSManagerReplicated' has a wrong offset!");
static_assert(offsetof(AHWGameState, VGSManager) == 0x000428, "Member 'AHWGameState::VGSManager' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnChatManagerReplicated) == 0x000430, "Member 'AHWGameState::OnChatManagerReplicated' has a wrong offset!");
static_assert(offsetof(AHWGameState, ChatManager) == 0x000440, "Member 'AHWGameState::ChatManager' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnPhaseConfigChanged) == 0x000448, "Member 'AHWGameState::OnPhaseConfigChanged' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnGamePhaseStarted) == 0x000458, "Member 'AHWGameState::OnGamePhaseStarted' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnGamePhaseEnded) == 0x000468, "Member 'AHWGameState::OnGamePhaseEnded' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnAllPlayersConnected) == 0x000478, "Member 'AHWGameState::OnAllPlayersConnected' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnTransitionInfoTagChanged) == 0x000488, "Member 'AHWGameState::OnTransitionInfoTagChanged' has a wrong offset!");
static_assert(offsetof(AHWGameState, CurrentPhaseConfig) == 0x000498, "Member 'AHWGameState::CurrentPhaseConfig' has a wrong offset!");
static_assert(offsetof(AHWGameState, CurrentPhaseLogic) == 0x0004F0, "Member 'AHWGameState::CurrentPhaseLogic' has a wrong offset!");
static_assert(offsetof(AHWGameState, bConfirmedAllPlayersConnected) == 0x000500, "Member 'AHWGameState::bConfirmedAllPlayersConnected' has a wrong offset!");
static_assert(offsetof(AHWGameState, TransitionInfoTag) == 0x000504, "Member 'AHWGameState::TransitionInfoTag' has a wrong offset!");
static_assert(offsetof(AHWGameState, MatchActivePhaseDuration) == 0x00050C, "Member 'AHWGameState::MatchActivePhaseDuration' has a wrong offset!");
static_assert(offsetof(AHWGameState, Preloader) == 0x000510, "Member 'AHWGameState::Preloader' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnPlayerDraftChoiceUpdated) == 0x0006F0, "Member 'AHWGameState::OnPlayerDraftChoiceUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState, SimulatedProjectiles) == 0x000718, "Member 'AHWGameState::SimulatedProjectiles' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnReceivedGameModeClass) == 0x000738, "Member 'AHWGameState::OnReceivedGameModeClass' has a wrong offset!");
static_assert(offsetof(AHWGameState, BotFactories) == 0x000748, "Member 'AHWGameState::BotFactories' has a wrong offset!");
static_assert(offsetof(AHWGameState, WaypointSet) == 0x000758, "Member 'AHWGameState::WaypointSet' has a wrong offset!");
static_assert(offsetof(AHWGameState, LevelLoadActionId) == 0x000760, "Member 'AHWGameState::LevelLoadActionId' has a wrong offset!");
static_assert(offsetof(AHWGameState, bWillUploadPEX) == 0x00076C, "Member 'AHWGameState::bWillUploadPEX' has a wrong offset!");
static_assert(offsetof(AHWGameState, CachedStartingGold) == 0x000770, "Member 'AHWGameState::CachedStartingGold' has a wrong offset!");
static_assert(offsetof(AHWGameState, bHasCachedStartingStats) == 0x000774, "Member 'AHWGameState::bHasCachedStartingStats' has a wrong offset!");
static_assert(offsetof(AHWGameState, EventManagerClass) == 0x000778, "Member 'AHWGameState::EventManagerClass' has a wrong offset!");
static_assert(offsetof(AHWGameState, EventManager) == 0x000780, "Member 'AHWGameState::EventManager' has a wrong offset!");
static_assert(offsetof(AHWGameState, bSendMinionSpawnAnnouncements) == 0x000788, "Member 'AHWGameState::bSendMinionSpawnAnnouncements' has a wrong offset!");
static_assert(offsetof(AHWGameState, PreMinionSpawnAnnouncementTime) == 0x00078C, "Member 'AHWGameState::PreMinionSpawnAnnouncementTime' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnPauseStateUpdated) == 0x000798, "Member 'AHWGameState::OnPauseStateUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnUnpauseDelayUpdated) == 0x0007A8, "Member 'AHWGameState::OnUnpauseDelayUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState, bIsPaused) == 0x0007B8, "Member 'AHWGameState::bIsPaused' has a wrong offset!");
static_assert(offsetof(AHWGameState, PausingTeam) == 0x0007C0, "Member 'AHWGameState::PausingTeam' has a wrong offset!");
static_assert(offsetof(AHWGameState, PauseStartTime) == 0x0007C8, "Member 'AHWGameState::PauseStartTime' has a wrong offset!");
static_assert(offsetof(AHWGameState, bAbilitiesCanBeCanceledPreFire) == 0x0007D0, "Member 'AHWGameState::bAbilitiesCanBeCanceledPreFire' has a wrong offset!");
static_assert(offsetof(AHWGameState, AladdinArenaManager) == 0x0007D8, "Member 'AHWGameState::AladdinArenaManager' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnDeployableSpawnedDelegate) == 0x0007E0, "Member 'AHWGameState::OnDeployableSpawnedDelegate' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnDeployableDestroyedDelegate) == 0x0007F0, "Member 'AHWGameState::OnDeployableDestroyedDelegate' has a wrong offset!");
static_assert(offsetof(AHWGameState, Deployables) == 0x000800, "Member 'AHWGameState::Deployables' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnFamiliarSpawnedDelegate) == 0x000810, "Member 'AHWGameState::OnFamiliarSpawnedDelegate' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnFamiliarDestroyedDelegate) == 0x000820, "Member 'AHWGameState::OnFamiliarDestroyedDelegate' has a wrong offset!");
static_assert(offsetof(AHWGameState, Familiars) == 0x000830, "Member 'AHWGameState::Familiars' has a wrong offset!");
static_assert(offsetof(AHWGameState, GameAudioManagerComponent) == 0x000840, "Member 'AHWGameState::GameAudioManagerComponent' has a wrong offset!");
static_assert(offsetof(AHWGameState, AudioManagerClass) == 0x000848, "Member 'AHWGameState::AudioManagerClass' has a wrong offset!");
static_assert(offsetof(AHWGameState, OnMatchDeserted) == 0x000850, "Member 'AHWGameState::OnMatchDeserted' has a wrong offset!");
static_assert(offsetof(AHWGameState, bMatchDeserted) == 0x000860, "Member 'AHWGameState::bMatchDeserted' has a wrong offset!");
static_assert(offsetof(AHWGameState, bIsTutorialAnnouncementsEnabled) == 0x000870, "Member 'AHWGameState::bIsTutorialAnnouncementsEnabled' has a wrong offset!");

// Class Hemingway.HWGameState_DraftLobby
// 0x0168 (0x09E0 - 0x0878)
class AHWGameState_DraftLobby final : public AHWGameState
{
public:
	float                                         TradeTimeOutSeconds;                               // 0x0878(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_87C[0x44];                                     // 0x087C(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FPendingTradeRequest>     PendingRoleSwapRequests;                           // 0x08C0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_910[0x40];                                     // 0x0910(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FPendingTradeRequest>     PendingCharacterSwapRequests;                      // 0x0950(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FHWReplicatedAppliedTeamBoosters       AppliedTeamBoosters;                               // 0x09A0(0x0020)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FHWReplicatedGrantedSkins              GrantedSkins;                                      // 0x09C0(0x0020)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void CharacterSwapRequestTimedOut(const struct FPGame_ReplicatedTimerId& InTimerId, int32 TradeId);
	void OnRep_AppliedTeamBoosters();
	void OnRep_GrantedSkins();
	void RoleSwapRequestTimedOut(const struct FPGame_ReplicatedTimerId& InTimerId, int32 TradeId);
	void ServerRequestRole(class AHWPlayerState* RequestingPlayerState, ECharacterRole CharacterRole);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameState_DraftLobby">();
	}
	static class AHWGameState_DraftLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameState_DraftLobby>();
	}
};
static_assert(alignof(AHWGameState_DraftLobby) == 0x000008, "Wrong alignment on AHWGameState_DraftLobby");
static_assert(sizeof(AHWGameState_DraftLobby) == 0x0009E0, "Wrong size on AHWGameState_DraftLobby");
static_assert(offsetof(AHWGameState_DraftLobby, TradeTimeOutSeconds) == 0x000878, "Member 'AHWGameState_DraftLobby::TradeTimeOutSeconds' has a wrong offset!");
static_assert(offsetof(AHWGameState_DraftLobby, PendingRoleSwapRequests) == 0x0008C0, "Member 'AHWGameState_DraftLobby::PendingRoleSwapRequests' has a wrong offset!");
static_assert(offsetof(AHWGameState_DraftLobby, PendingCharacterSwapRequests) == 0x000950, "Member 'AHWGameState_DraftLobby::PendingCharacterSwapRequests' has a wrong offset!");
static_assert(offsetof(AHWGameState_DraftLobby, AppliedTeamBoosters) == 0x0009A0, "Member 'AHWGameState_DraftLobby::AppliedTeamBoosters' has a wrong offset!");
static_assert(offsetof(AHWGameState_DraftLobby, GrantedSkins) == 0x0009C0, "Member 'AHWGameState_DraftLobby::GrantedSkins' has a wrong offset!");

// Class Hemingway.HWAITugOfWarManager
// 0x0128 (0x03C0 - 0x0298)
class AHWAITugOfWarManager : public AActor
{
public:
	float                                         UpdateTime;                                        // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OrderMapDirection;                                 // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BoundsOffset;                                      // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCountStructures;                                  // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TugOfWarAxis;                                      // 0x02B8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TeamGroupUpDistance;                               // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceFromFront;                              // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPCScale;                                          // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSafeZoneSize;                                   // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TugOfWarRateOfChangeMax;                           // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawDebug;                                        // 0x02E4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FVector2D>   FormationOffsets;                                  // 0x02E8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TugOfWarChangeRate;                                // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TugOfWarValueSafetyLimit;                          // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TugOfWarValue;                                     // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayedTugOfWarValue;                              // 0x0344(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LevelMin;                                          // 0x0348(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LevelMax;                                          // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGenericTeamId, struct FBox2D>    SafeZones;                                         // 0x0368(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateTugOfWarValue();

	bool CalculateFormationLocation(const struct FGenericTeamId& Team, const struct FGameplayTag& RoleTag, struct FVector2D* OutFormationOffset) const;
	bool CalculateFormationLocationWithForwardOffset(const struct FGenericTeamId& Team, const struct FGameplayTag& RoleTag, const float ForwardOffset, struct FVector2D* OutFormationOffset) const;
	float GetCharacterDistanceFromFront(const class AHWCharacter_Base* Character) const;
	bool GetSafeZoneForTeam(const struct FGenericTeamId& Team, struct FVector2D* OutMinBounds, struct FVector2D* OutMaxBounds) const;
	bool GetSafeZoneFrontForTeam(const struct FGenericTeamId& Team, struct FVector2D* OutFrontLocation) const;
	float GetTugOfWarValue(const struct FGenericTeamId& Team) const;
	bool IsCharacterSafe(const class AHWCharacter_Base* Character) const;
	bool IsLocationInSafeZoneForTeam(const struct FVector& Location, const struct FGenericTeamId& Team) const;
	struct FVector ProjectCharacterLocationToSafeDistance(const class AHWCharacter_Base* Character, float DistanceBuffer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAITugOfWarManager">();
	}
	static class AHWAITugOfWarManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWAITugOfWarManager>();
	}
};
static_assert(alignof(AHWAITugOfWarManager) == 0x000008, "Wrong alignment on AHWAITugOfWarManager");
static_assert(sizeof(AHWAITugOfWarManager) == 0x0003C0, "Wrong size on AHWAITugOfWarManager");
static_assert(offsetof(AHWAITugOfWarManager, UpdateTime) == 0x000298, "Member 'AHWAITugOfWarManager::UpdateTime' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, OrderMapDirection) == 0x00029C, "Member 'AHWAITugOfWarManager::OrderMapDirection' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, BoundsOffset) == 0x0002A0, "Member 'AHWAITugOfWarManager::BoundsOffset' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, bCountStructures) == 0x0002B0, "Member 'AHWAITugOfWarManager::bCountStructures' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, TugOfWarAxis) == 0x0002B8, "Member 'AHWAITugOfWarManager::TugOfWarAxis' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, TeamGroupUpDistance) == 0x0002D0, "Member 'AHWAITugOfWarManager::TeamGroupUpDistance' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, MaxDistanceFromFront) == 0x0002D4, "Member 'AHWAITugOfWarManager::MaxDistanceFromFront' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, NPCScale) == 0x0002D8, "Member 'AHWAITugOfWarManager::NPCScale' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, MinSafeZoneSize) == 0x0002DC, "Member 'AHWAITugOfWarManager::MinSafeZoneSize' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, TugOfWarRateOfChangeMax) == 0x0002E0, "Member 'AHWAITugOfWarManager::TugOfWarRateOfChangeMax' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, bDrawDebug) == 0x0002E4, "Member 'AHWAITugOfWarManager::bDrawDebug' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, FormationOffsets) == 0x0002E8, "Member 'AHWAITugOfWarManager::FormationOffsets' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, TugOfWarChangeRate) == 0x000338, "Member 'AHWAITugOfWarManager::TugOfWarChangeRate' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, TugOfWarValueSafetyLimit) == 0x00033C, "Member 'AHWAITugOfWarManager::TugOfWarValueSafetyLimit' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, TugOfWarValue) == 0x000340, "Member 'AHWAITugOfWarManager::TugOfWarValue' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, DelayedTugOfWarValue) == 0x000344, "Member 'AHWAITugOfWarManager::DelayedTugOfWarValue' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, LevelMin) == 0x000348, "Member 'AHWAITugOfWarManager::LevelMin' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, LevelMax) == 0x000358, "Member 'AHWAITugOfWarManager::LevelMax' has a wrong offset!");
static_assert(offsetof(AHWAITugOfWarManager, SafeZones) == 0x000368, "Member 'AHWAITugOfWarManager::SafeZones' has a wrong offset!");

// Class Hemingway.HWAnimInst_Danzaburou_A01_Deployable
// 0x0020 (0x03D0 - 0x03B0)
class UHWAnimInst_Danzaburou_A01_Deployable final : public USkinnedAnimInstance
{
public:
	float                                         MaxPlayRate;                                       // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinPlayRate;                                       // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BounceFlipAngle;                                   // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimPlayrateBySpeed;                               // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RollDirection;                                     // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWDeployableMovementComponent*         DeployableMovement;                                // 0x03C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlipPlayrate(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimInst_Danzaburou_A01_Deployable">();
	}
	static class UHWAnimInst_Danzaburou_A01_Deployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimInst_Danzaburou_A01_Deployable>();
	}
};
static_assert(alignof(UHWAnimInst_Danzaburou_A01_Deployable) == 0x000010, "Wrong alignment on UHWAnimInst_Danzaburou_A01_Deployable");
static_assert(sizeof(UHWAnimInst_Danzaburou_A01_Deployable) == 0x0003D0, "Wrong size on UHWAnimInst_Danzaburou_A01_Deployable");
static_assert(offsetof(UHWAnimInst_Danzaburou_A01_Deployable, MaxPlayRate) == 0x0003A8, "Member 'UHWAnimInst_Danzaburou_A01_Deployable::MaxPlayRate' has a wrong offset!");
static_assert(offsetof(UHWAnimInst_Danzaburou_A01_Deployable, MinPlayRate) == 0x0003AC, "Member 'UHWAnimInst_Danzaburou_A01_Deployable::MinPlayRate' has a wrong offset!");
static_assert(offsetof(UHWAnimInst_Danzaburou_A01_Deployable, BounceFlipAngle) == 0x0003B0, "Member 'UHWAnimInst_Danzaburou_A01_Deployable::BounceFlipAngle' has a wrong offset!");
static_assert(offsetof(UHWAnimInst_Danzaburou_A01_Deployable, AnimPlayrateBySpeed) == 0x0003B4, "Member 'UHWAnimInst_Danzaburou_A01_Deployable::AnimPlayrateBySpeed' has a wrong offset!");
static_assert(offsetof(UHWAnimInst_Danzaburou_A01_Deployable, RollDirection) == 0x0003B8, "Member 'UHWAnimInst_Danzaburou_A01_Deployable::RollDirection' has a wrong offset!");
static_assert(offsetof(UHWAnimInst_Danzaburou_A01_Deployable, DeployableMovement) == 0x0003C0, "Member 'UHWAnimInst_Danzaburou_A01_Deployable::DeployableMovement' has a wrong offset!");

// Class Hemingway.HWInterface_CurveLookup_BaseCooldown
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_CurveLookup_BaseCooldown final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_CurveLookup_BaseCooldown">();
	}
	static class IHWInterface_CurveLookup_BaseCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_CurveLookup_BaseCooldown>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_CurveLookup_BaseCooldown) == 0x000001, "Wrong alignment on IHWInterface_CurveLookup_BaseCooldown");
static_assert(sizeof(IHWInterface_CurveLookup_BaseCooldown) == 0x000001, "Wrong size on IHWInterface_CurveLookup_BaseCooldown");

// Class Hemingway.HWAnimNotifyState_SkinnedTimedNiagaraOverride
// 0x00D8 (0x0158 - 0x0080)
class UHWAnimNotifyState_SkinnedTimedNiagaraOverride final : public UAnimNotifyState_SkinnedTimedNiagaraEffect
{
public:
	struct FGameplayTagRequirements               NotifyTagRequirements;                             // 0x0080(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FHWNotifyNiagaraUserParameters> ParamMap;                               // 0x0108(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimNotifyState_SkinnedTimedNiagaraOverride">();
	}
	static class UHWAnimNotifyState_SkinnedTimedNiagaraOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimNotifyState_SkinnedTimedNiagaraOverride>();
	}
};
static_assert(alignof(UHWAnimNotifyState_SkinnedTimedNiagaraOverride) == 0x000008, "Wrong alignment on UHWAnimNotifyState_SkinnedTimedNiagaraOverride");
static_assert(sizeof(UHWAnimNotifyState_SkinnedTimedNiagaraOverride) == 0x000158, "Wrong size on UHWAnimNotifyState_SkinnedTimedNiagaraOverride");
static_assert(offsetof(UHWAnimNotifyState_SkinnedTimedNiagaraOverride, NotifyTagRequirements) == 0x000080, "Member 'UHWAnimNotifyState_SkinnedTimedNiagaraOverride::NotifyTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWAnimNotifyState_SkinnedTimedNiagaraOverride, ParamMap) == 0x000108, "Member 'UHWAnimNotifyState_SkinnedTimedNiagaraOverride::ParamMap' has a wrong offset!");

// Class Hemingway.HWAnimNotifySubsystem
// 0x0050 (0x0090 - 0x0040)
class UHWAnimNotifySubsystem final : public UTickableWorldSubsystem
{
public:
	TMap<class UAnimNotify*, float>               LastNotifyActivationTimes;                         // 0x0040(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimNotifySubsystem">();
	}
	static class UHWAnimNotifySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimNotifySubsystem>();
	}
};
static_assert(alignof(UHWAnimNotifySubsystem) == 0x000008, "Wrong alignment on UHWAnimNotifySubsystem");
static_assert(sizeof(UHWAnimNotifySubsystem) == 0x000090, "Wrong size on UHWAnimNotifySubsystem");
static_assert(offsetof(UHWAnimNotifySubsystem, LastNotifyActivationTimes) == 0x000040, "Member 'UHWAnimNotifySubsystem::LastNotifyActivationTimes' has a wrong offset!");

// Class Hemingway.HWGEModifier_CustomCalc_NuWa_ClaySoldierHealth
// 0x0008 (0x0048 - 0x0040)
class UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth final : public UHWGEModiferMagnitudeCalc_Base
{
public:
	float                                         BaseHealth;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentOwnerHealth;                                // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEModifier_CustomCalc_NuWa_ClaySoldierHealth">();
	}
	static class UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth>();
	}
};
static_assert(alignof(UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth) == 0x000008, "Wrong alignment on UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth");
static_assert(sizeof(UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth) == 0x000048, "Wrong size on UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth");
static_assert(offsetof(UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth, BaseHealth) == 0x000040, "Member 'UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth::BaseHealth' has a wrong offset!");
static_assert(offsetof(UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth, PercentOwnerHealth) == 0x000044, "Member 'UHWGEModifier_CustomCalc_NuWa_ClaySoldierHealth::PercentOwnerHealth' has a wrong offset!");

// Class Hemingway.HWAnimNotify_HideForDeath
// 0x0000 (0x0038 - 0x0038)
class UHWAnimNotify_HideForDeath final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimNotify_HideForDeath">();
	}
	static class UHWAnimNotify_HideForDeath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimNotify_HideForDeath>();
	}
};
static_assert(alignof(UHWAnimNotify_HideForDeath) == 0x000008, "Wrong alignment on UHWAnimNotify_HideForDeath");
static_assert(sizeof(UHWAnimNotify_HideForDeath) == 0x000038, "Wrong size on UHWAnimNotify_HideForDeath");

// Class Hemingway.HWAnimNotify_PlaySkinnedNiagaraEffect
// 0x0090 (0x0170 - 0x00E0)
class UHWAnimNotify_PlaySkinnedNiagaraEffect final : public UAnimNotify_PlaySkinnedNiagaraEffect
{
public:
	struct FGameplayTagRequirements               NotifyTagRequirements;                             // 0x00D8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bRequireMeshVisible;                               // 0x0160(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0xF];                                      // 0x0161(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimNotify_PlaySkinnedNiagaraEffect">();
	}
	static class UHWAnimNotify_PlaySkinnedNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimNotify_PlaySkinnedNiagaraEffect>();
	}
};
static_assert(alignof(UHWAnimNotify_PlaySkinnedNiagaraEffect) == 0x000010, "Wrong alignment on UHWAnimNotify_PlaySkinnedNiagaraEffect");
static_assert(sizeof(UHWAnimNotify_PlaySkinnedNiagaraEffect) == 0x000170, "Wrong size on UHWAnimNotify_PlaySkinnedNiagaraEffect");
static_assert(offsetof(UHWAnimNotify_PlaySkinnedNiagaraEffect, NotifyTagRequirements) == 0x0000D8, "Member 'UHWAnimNotify_PlaySkinnedNiagaraEffect::NotifyTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWAnimNotify_PlaySkinnedNiagaraEffect, bRequireMeshVisible) == 0x000160, "Member 'UHWAnimNotify_PlaySkinnedNiagaraEffect::bRequireMeshVisible' has a wrong offset!");

// Class Hemingway.HWGameplayLevitate
// 0x0480 (0x04A8 - 0x0028)
class UHWGameplayLevitate final : public UObject
{
public:
	EHWLevitationState                            LevitationState;                                   // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWCharacter_Base*                      LevitatingCharacter;                               // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWCharacterMovementComponent*          LevitatingCharacterMovementComponent;              // 0x0038(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LevitationOriginLocation;                          // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LevitationEndLocation;                             // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayLevitate* LevitationInstance)> OnLevitationStartedDel; // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayLevitate* Levitation, const EHWEndLevitationReason EndLevitationReason)> OnLevitationEndedDel; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LevitationIdTag;                                   // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         AbilityPredictionKey;                              // 0x0098(0x0018)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLevitationActive;                               // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayAbility*                       OwningGameplayAbility;                             // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeCleansed;                                    // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenCleansed;                                  // 0x00C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0xE];                                       // 0x00C2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLockPawnRotation;                                 // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldIgnoreClientCorrectionsDuringLevitate;      // 0x00D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWGameplayLevitate* LevitationInstance)> OnAscentStarted;   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayLevitate* LevitationInstance)> OnAscentEnded;     // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayLevitate* LevitationInstance)> OnDescentStarted;  // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayLevitate* LevitationInstance)> OnDescentEnded;    // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         LevitationHeight;                                  // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWGameplayTween>           LevitationAscentTweenClass;                        // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityTask_GameplayTween*           AscentTweenTask;                                   // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayTween>           LevitationDescentTweenClass;                       // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWGameplayLevitate* LevitationInstance)> OnHoverStarted;    // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayLevitate* LevitationInstance)> OnHoverEnded;      // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         LevitationDuration;                                // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LevitationTimerHandle;                             // 0x0160(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWAbilityCancelTagRequirement         CancelTags;                                        // 0x0168(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 BlockTags;                                         // 0x01A8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 TagsToApplyWhileLevitating;                        // 0x0208(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyWhileLevitating;                     // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    EffectsAppliedWhileLevitating;                     // 0x0278(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGameplayTagContainer> LevitateTweenCues;                       // 0x0288(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FBodyInstance                          LevitateCollision;                                 // 0x02D8(0x0190)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ELevitateCollisionProfileChoice               LevitateProfileChoice;                             // 0x0468(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWCollisionState                      PushedCollisionState;                              // 0x046C(0x003C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	bool bIsUsingCustomProfile();
	void CleanseLevitation();
	void OnAscentTweenEnded(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget, const EHWEndTweenReason EndTweenReason);
	void OnAscentTweenStarted(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget);
	void OnDescentTweenEnded(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget, const EHWEndTweenReason EndTweenReason);
	void OnDescentTweenStarted(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget);
	void OnLevitationHoverEnded();
	void StartAscentTween();
	void StartDescentTween();
	void TriggerEarlyLevitationEnd();

	bool DoesAllowCleansingLevitate() const;
	struct FGameplayTag GetLevitationIdTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayLevitate">();
	}
	static class UHWGameplayLevitate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayLevitate>();
	}
};
static_assert(alignof(UHWGameplayLevitate) == 0x000008, "Wrong alignment on UHWGameplayLevitate");
static_assert(sizeof(UHWGameplayLevitate) == 0x0004A8, "Wrong size on UHWGameplayLevitate");
static_assert(offsetof(UHWGameplayLevitate, LevitationState) == 0x000028, "Member 'UHWGameplayLevitate::LevitationState' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitatingCharacter) == 0x000030, "Member 'UHWGameplayLevitate::LevitatingCharacter' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitatingCharacterMovementComponent) == 0x000038, "Member 'UHWGameplayLevitate::LevitatingCharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitationOriginLocation) == 0x000040, "Member 'UHWGameplayLevitate::LevitationOriginLocation' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitationEndLocation) == 0x000058, "Member 'UHWGameplayLevitate::LevitationEndLocation' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, OnLevitationStartedDel) == 0x000070, "Member 'UHWGameplayLevitate::OnLevitationStartedDel' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, OnLevitationEndedDel) == 0x000080, "Member 'UHWGameplayLevitate::OnLevitationEndedDel' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitationIdTag) == 0x000090, "Member 'UHWGameplayLevitate::LevitationIdTag' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, AbilityPredictionKey) == 0x000098, "Member 'UHWGameplayLevitate::AbilityPredictionKey' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, bIsLevitationActive) == 0x0000B0, "Member 'UHWGameplayLevitate::bIsLevitationActive' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, OwningGameplayAbility) == 0x0000B8, "Member 'UHWGameplayLevitate::OwningGameplayAbility' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, bCanBeCleansed) == 0x0000C0, "Member 'UHWGameplayLevitate::bCanBeCleansed' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, bHasBeenCleansed) == 0x0000C1, "Member 'UHWGameplayLevitate::bHasBeenCleansed' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, bLockPawnRotation) == 0x0000D0, "Member 'UHWGameplayLevitate::bLockPawnRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, bShouldIgnoreClientCorrectionsDuringLevitate) == 0x0000D1, "Member 'UHWGameplayLevitate::bShouldIgnoreClientCorrectionsDuringLevitate' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, OnAscentStarted) == 0x0000D8, "Member 'UHWGameplayLevitate::OnAscentStarted' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, OnAscentEnded) == 0x0000E8, "Member 'UHWGameplayLevitate::OnAscentEnded' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, OnDescentStarted) == 0x0000F8, "Member 'UHWGameplayLevitate::OnDescentStarted' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, OnDescentEnded) == 0x000108, "Member 'UHWGameplayLevitate::OnDescentEnded' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitationHeight) == 0x000118, "Member 'UHWGameplayLevitate::LevitationHeight' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitationAscentTweenClass) == 0x000120, "Member 'UHWGameplayLevitate::LevitationAscentTweenClass' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, AscentTweenTask) == 0x000128, "Member 'UHWGameplayLevitate::AscentTweenTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitationDescentTweenClass) == 0x000130, "Member 'UHWGameplayLevitate::LevitationDescentTweenClass' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, OnHoverStarted) == 0x000138, "Member 'UHWGameplayLevitate::OnHoverStarted' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, OnHoverEnded) == 0x000148, "Member 'UHWGameplayLevitate::OnHoverEnded' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitationDuration) == 0x000158, "Member 'UHWGameplayLevitate::LevitationDuration' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitationTimerHandle) == 0x000160, "Member 'UHWGameplayLevitate::LevitationTimerHandle' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, CancelTags) == 0x000168, "Member 'UHWGameplayLevitate::CancelTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, BlockTags) == 0x0001A8, "Member 'UHWGameplayLevitate::BlockTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, TagsToApplyWhileLevitating) == 0x000208, "Member 'UHWGameplayLevitate::TagsToApplyWhileLevitating' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, EffectsToApplyWhileLevitating) == 0x000268, "Member 'UHWGameplayLevitate::EffectsToApplyWhileLevitating' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, EffectsAppliedWhileLevitating) == 0x000278, "Member 'UHWGameplayLevitate::EffectsAppliedWhileLevitating' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitateTweenCues) == 0x000288, "Member 'UHWGameplayLevitate::LevitateTweenCues' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitateCollision) == 0x0002D8, "Member 'UHWGameplayLevitate::LevitateCollision' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, LevitateProfileChoice) == 0x000468, "Member 'UHWGameplayLevitate::LevitateProfileChoice' has a wrong offset!");
static_assert(offsetof(UHWGameplayLevitate, PushedCollisionState) == 0x00046C, "Member 'UHWGameplayLevitate::PushedCollisionState' has a wrong offset!");

// Class Hemingway.HWAnimNotify_PlaySound
// 0x0090 (0x00E8 - 0x0058)
class UHWAnimNotify_PlaySound final : public UAnimNotify_PlaySound
{
public:
	struct FGameplayTagRequirements               NotifyTagRequirements;                             // 0x0058(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         CooldownTime;                                      // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimNotify_PlaySound">();
	}
	static class UHWAnimNotify_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimNotify_PlaySound>();
	}
};
static_assert(alignof(UHWAnimNotify_PlaySound) == 0x000008, "Wrong alignment on UHWAnimNotify_PlaySound");
static_assert(sizeof(UHWAnimNotify_PlaySound) == 0x0000E8, "Wrong size on UHWAnimNotify_PlaySound");
static_assert(offsetof(UHWAnimNotify_PlaySound, NotifyTagRequirements) == 0x000058, "Member 'UHWAnimNotify_PlaySound::NotifyTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWAnimNotify_PlaySound, CooldownTime) == 0x0000E0, "Member 'UHWAnimNotify_PlaySound::CooldownTime' has a wrong offset!");

// Class Hemingway.HWAudioSubsystem
// 0x00F8 (0x0128 - 0x0030)
class UHWAudioSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayTag& ComponentTag, class UAudioComponent* InAudioComponent)> OnAudioComponentAdded; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FGameplayTag& ComponentTag)> OnAudioComponentRemoved; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAudioComponent*> AudioComponents;                               // 0x0050(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             AudioTypeTable;                                    // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             VolumeLoweringTable;                               // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SoundCount;                                        // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundClass*                            PCSoundClass;                                      // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              GlobalDefaultMusicSoftPtr;                         // 0x00E0(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAnnouncerPackItem*                   DefaultAnnouncerPack;                              // 0x0108(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x18];                                     // 0x0110(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddAudioComponent(const struct FGameplayTag& ComponentTag, class UAudioComponent* AudioComponent);
	void AudioSettingsUpdated();
	void AudioTypeTableLoaded();
	void FadeOutCurrentStinger();
	void OnDefaultAnnouncerPackLoaded();
	void OnGlobalDefaultMusicLoaded();
	void PauseCurrentMusicTrack();
	class UAudioComponent* PlayMusicTrack(const struct FHWAudioTrackPlayInfo& TrackPlayInfo, const class UHWMusicPackItem* MusicPack);
	class UAudioComponent* PlayStinger(const struct FHWAudioStingerPlayInfo& StingerPlayInfo);
	class UAudioComponent* PlayVOAnnouncement(const struct FAssetRequestKey& AnnouncementAssetKey);
	bool RemoveAudioComponent(const struct FGameplayTag& ComponentTag);
	void ResumeCurrentMusicTrack();
	void VolumeLoweringTableLoaded();

	bool DoesAudioComponentExist(const struct FGameplayTag& ComponentTag) const;
	class UAudioComponent* GetAudioComponent(const struct FGameplayTag& ComponentTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAudioSubsystem">();
	}
	static class UHWAudioSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAudioSubsystem>();
	}
};
static_assert(alignof(UHWAudioSubsystem) == 0x000008, "Wrong alignment on UHWAudioSubsystem");
static_assert(sizeof(UHWAudioSubsystem) == 0x000128, "Wrong size on UHWAudioSubsystem");
static_assert(offsetof(UHWAudioSubsystem, OnAudioComponentAdded) == 0x000030, "Member 'UHWAudioSubsystem::OnAudioComponentAdded' has a wrong offset!");
static_assert(offsetof(UHWAudioSubsystem, OnAudioComponentRemoved) == 0x000040, "Member 'UHWAudioSubsystem::OnAudioComponentRemoved' has a wrong offset!");
static_assert(offsetof(UHWAudioSubsystem, AudioComponents) == 0x000050, "Member 'UHWAudioSubsystem::AudioComponents' has a wrong offset!");
static_assert(offsetof(UHWAudioSubsystem, AudioTypeTable) == 0x0000A0, "Member 'UHWAudioSubsystem::AudioTypeTable' has a wrong offset!");
static_assert(offsetof(UHWAudioSubsystem, VolumeLoweringTable) == 0x0000B8, "Member 'UHWAudioSubsystem::VolumeLoweringTable' has a wrong offset!");
static_assert(offsetof(UHWAudioSubsystem, SoundCount) == 0x0000D0, "Member 'UHWAudioSubsystem::SoundCount' has a wrong offset!");
static_assert(offsetof(UHWAudioSubsystem, PCSoundClass) == 0x0000D8, "Member 'UHWAudioSubsystem::PCSoundClass' has a wrong offset!");
static_assert(offsetof(UHWAudioSubsystem, GlobalDefaultMusicSoftPtr) == 0x0000E0, "Member 'UHWAudioSubsystem::GlobalDefaultMusicSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWAudioSubsystem, DefaultAnnouncerPack) == 0x000108, "Member 'UHWAudioSubsystem::DefaultAnnouncerPack' has a wrong offset!");

// Class Hemingway.HWAnimNotify_SpawnSpecialFXActor
// 0x0048 (0x0080 - 0x0038)
class UHWAnimNotify_SpawnSpecialFXActor final : public UAnimNotify
{
public:
	TSubclassOf<class AHWActor_SpecialFX>         SpecialFXActorClass;                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocationOffset;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         AttachToOwner : 1;                                 // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnedActorLifetime;                              // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimNotify_SpawnSpecialFXActor">();
	}
	static class UHWAnimNotify_SpawnSpecialFXActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimNotify_SpawnSpecialFXActor>();
	}
};
static_assert(alignof(UHWAnimNotify_SpawnSpecialFXActor) == 0x000008, "Wrong alignment on UHWAnimNotify_SpawnSpecialFXActor");
static_assert(sizeof(UHWAnimNotify_SpawnSpecialFXActor) == 0x000080, "Wrong size on UHWAnimNotify_SpawnSpecialFXActor");
static_assert(offsetof(UHWAnimNotify_SpawnSpecialFXActor, SpecialFXActorClass) == 0x000038, "Member 'UHWAnimNotify_SpawnSpecialFXActor::SpecialFXActorClass' has a wrong offset!");
static_assert(offsetof(UHWAnimNotify_SpawnSpecialFXActor, LocationOffset) == 0x000040, "Member 'UHWAnimNotify_SpawnSpecialFXActor::LocationOffset' has a wrong offset!");
static_assert(offsetof(UHWAnimNotify_SpawnSpecialFXActor, RotationOffset) == 0x000058, "Member 'UHWAnimNotify_SpawnSpecialFXActor::RotationOffset' has a wrong offset!");
static_assert(offsetof(UHWAnimNotify_SpawnSpecialFXActor, SocketName) == 0x000074, "Member 'UHWAnimNotify_SpawnSpecialFXActor::SocketName' has a wrong offset!");
static_assert(offsetof(UHWAnimNotify_SpawnSpecialFXActor, SpawnedActorLifetime) == 0x00007C, "Member 'UHWAnimNotify_SpawnSpecialFXActor::SpawnedActorLifetime' has a wrong offset!");

// Class Hemingway.HWInterface_Bari_BellRicochetAiming
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_Bari_BellRicochetAiming final
{
public:
	class AHWDeployable_Bari_A01* GetBariBellToShoot(const int32 Index_0) const;
	const struct FHWTargetData_LocationInfo GetBariBellToShootAimTargetingInfo(const int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_Bari_BellRicochetAiming">();
	}
	static class IHWInterface_Bari_BellRicochetAiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_Bari_BellRicochetAiming>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_Bari_BellRicochetAiming) == 0x000001, "Wrong alignment on IHWInterface_Bari_BellRicochetAiming");
static_assert(sizeof(IHWInterface_Bari_BellRicochetAiming) == 0x000001, "Wrong size on IHWInterface_Bari_BellRicochetAiming");

// Class Hemingway.HWAnimState_PP_ScreenFX
// 0x0078 (0x00A8 - 0x0030)
class UHWAnimState_PP_ScreenFX final : public UAnimNotifyState
{
public:
	struct FHWSpecialEffect                       SpecialEffect;                                     // 0x0030(0x0070)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   SkinKeyword;                                       // 0x00A0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimState_PP_ScreenFX">();
	}
	static class UHWAnimState_PP_ScreenFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimState_PP_ScreenFX>();
	}
};
static_assert(alignof(UHWAnimState_PP_ScreenFX) == 0x000008, "Wrong alignment on UHWAnimState_PP_ScreenFX");
static_assert(sizeof(UHWAnimState_PP_ScreenFX) == 0x0000A8, "Wrong size on UHWAnimState_PP_ScreenFX");
static_assert(offsetof(UHWAnimState_PP_ScreenFX, SpecialEffect) == 0x000030, "Member 'UHWAnimState_PP_ScreenFX::SpecialEffect' has a wrong offset!");
static_assert(offsetof(UHWAnimState_PP_ScreenFX, SkinKeyword) == 0x0000A0, "Member 'UHWAnimState_PP_ScreenFX::SkinKeyword' has a wrong offset!");

// Class Hemingway.HWArtemisRevealIndicator
// 0x0008 (0x02A0 - 0x0298)
class AHWArtemisRevealIndicator final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWArtemisRevealIndicator">();
	}
	static class AHWArtemisRevealIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWArtemisRevealIndicator>();
	}
};
static_assert(alignof(AHWArtemisRevealIndicator) == 0x000008, "Wrong alignment on AHWArtemisRevealIndicator");
static_assert(sizeof(AHWArtemisRevealIndicator) == 0x0002A0, "Wrong size on AHWArtemisRevealIndicator");

// Class Hemingway.HWInterface_RefireAbility
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_RefireAbility final
{
public:
	void Refire(class UHWEquipmentComponent_Refireable* RefireComponent, const struct FHWAbilityRefireInfo& RefireInfo, const float ElapsedRefireTime);

	bool CanRefire(const class UHWEquipmentComponent_Refireable* RefireComponent, const struct FHWAbilityRefireInfo& RefireInfo, const class UHWAbilitySystemComponent* AbilitySystem, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_RefireAbility">();
	}
	static class IHWInterface_RefireAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_RefireAbility>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_RefireAbility) == 0x000001, "Wrong alignment on IHWInterface_RefireAbility");
static_assert(sizeof(IHWInterface_RefireAbility) == 0x000001, "Wrong size on IHWInterface_RefireAbility");

// Class Hemingway.HWLibrary_CallToAction
// 0x0000 (0x0028 - 0x0028)
class UHWLibrary_CallToAction final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> GetCTAAffixPath(EHWCallToActionAffixPath AffixPath);
	static TArray<class FName> GetCTAAffixPaths(const TArray<EHWCallToActionAffixPath>& AffixPaths);
	static TArray<class FName> GetCTACollectionAffixPath(EHWCollectionItemType CollectionType);
	static void SetCTASeenByItem(const class UObject* WorldContext, const class UHWInventoryItem* InventoryItem, EHWCallToActionAffixPath Preffix, EHWCallToActionAffixPath Suffix, int32 SeenAmount);
	static void SetCTASeenByItemPtr(const class UObject* WorldContext, TSoftObjectPtr<class UHWInventoryItem> InventoryItemPtr, EHWCallToActionAffixPath Preffix, EHWCallToActionAffixPath Suffix, int32 SeenAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLibrary_CallToAction">();
	}
	static class UHWLibrary_CallToAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLibrary_CallToAction>();
	}
};
static_assert(alignof(UHWLibrary_CallToAction) == 0x000008, "Wrong alignment on UHWLibrary_CallToAction");
static_assert(sizeof(UHWLibrary_CallToAction) == 0x000028, "Wrong size on UHWLibrary_CallToAction");

// Class Hemingway.HWInterface_GameplayMovementActor
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_GameplayMovementActor final
{
public:
	void SetLobGroundTargetLocation(const struct FVector& InGroundTargetLocation);
	void SetMovementRange(const float Range);

	struct FVector GetLobGroundTargetLocation() const;
	float GetMovementRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_GameplayMovementActor">();
	}
	static class IHWInterface_GameplayMovementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_GameplayMovementActor>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_GameplayMovementActor) == 0x000001, "Wrong alignment on IHWInterface_GameplayMovementActor");
static_assert(sizeof(IHWInterface_GameplayMovementActor) == 0x000001, "Wrong size on IHWInterface_GameplayMovementActor");

// Class Hemingway.HWAttributeSet_KingArthur
// 0x0028 (0x07D0 - 0x07A8)
class UHWAttributeSet_KingArthur final : public UHWAttributeSet_God
{
public:
	struct FGameplayAttributeData                 Energy;                                            // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EnergyPerTime;                                     // 0x07B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         MaxEnergy;                                         // 0x07C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7CC[0x4];                                      // 0x07CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Energy(const struct FGameplayAttributeData& OldValue);
	void OnRep_EnergyPerTime(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_KingArthur">();
	}
	static class UHWAttributeSet_KingArthur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_KingArthur>();
	}
};
static_assert(alignof(UHWAttributeSet_KingArthur) == 0x000008, "Wrong alignment on UHWAttributeSet_KingArthur");
static_assert(sizeof(UHWAttributeSet_KingArthur) == 0x0007D0, "Wrong size on UHWAttributeSet_KingArthur");
static_assert(offsetof(UHWAttributeSet_KingArthur, Energy) == 0x0007A8, "Member 'UHWAttributeSet_KingArthur::Energy' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_KingArthur, EnergyPerTime) == 0x0007B8, "Member 'UHWAttributeSet_KingArthur::EnergyPerTime' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_KingArthur, MaxEnergy) == 0x0007C8, "Member 'UHWAttributeSet_KingArthur::MaxEnergy' has a wrong offset!");

// Class Hemingway.HWGodSettingsSubsystem
// 0x0270 (0x02A0 - 0x0030)
class UHWGodSettingsSubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_30[0xA8];                                      // 0x0030(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URHSettingsInfoBase*>            CachedSettingsInfos;                               // 0x00D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x140];                                     // 0x00E8(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FRHAPI_SettingData> CachedPlayerData;                                 // 0x0228(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x4];                                      // 0x0278(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AHWPlayerController>     CachedPlayerController;                            // 0x027C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWPlayerState>          CachedPlayerState;                                 // 0x0284(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWCharacterAbilitySystemActor> CachedCharASA;                              // 0x028C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHWCharacterItem>        CachedCharacterItem;                               // 0x0294(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAbilitySystemActorReplicated(class AHWPlayerState* PlayerState, class AHWCharacterAbilitySystemActor* CharASA);
	void HandleCharacterItemUpdated(TScriptInterface<class IHWInterface_LoadoutManagement> LoadoutOwner, const class UHWCharacterItem* CharacterItem);
	void HandleGodLoadoutReceived(const class UHWCharacterItem* CharacterItem, const struct FHWGodLoadout& GodLoadout);
	void HandlePlayerControllerChanged(class APlayerController* PlayerController);
	void HandlePlayerStateReplicated(class AHWPlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGodSettingsSubsystem">();
	}
	static class UHWGodSettingsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGodSettingsSubsystem>();
	}
};
static_assert(alignof(UHWGodSettingsSubsystem) == 0x000008, "Wrong alignment on UHWGodSettingsSubsystem");
static_assert(sizeof(UHWGodSettingsSubsystem) == 0x0002A0, "Wrong size on UHWGodSettingsSubsystem");
static_assert(offsetof(UHWGodSettingsSubsystem, CachedSettingsInfos) == 0x0000D8, "Member 'UHWGodSettingsSubsystem::CachedSettingsInfos' has a wrong offset!");
static_assert(offsetof(UHWGodSettingsSubsystem, CachedPlayerData) == 0x000228, "Member 'UHWGodSettingsSubsystem::CachedPlayerData' has a wrong offset!");
static_assert(offsetof(UHWGodSettingsSubsystem, CachedPlayerController) == 0x00027C, "Member 'UHWGodSettingsSubsystem::CachedPlayerController' has a wrong offset!");
static_assert(offsetof(UHWGodSettingsSubsystem, CachedPlayerState) == 0x000284, "Member 'UHWGodSettingsSubsystem::CachedPlayerState' has a wrong offset!");
static_assert(offsetof(UHWGodSettingsSubsystem, CachedCharASA) == 0x00028C, "Member 'UHWGodSettingsSubsystem::CachedCharASA' has a wrong offset!");
static_assert(offsetof(UHWGodSettingsSubsystem, CachedCharacterItem) == 0x000294, "Member 'UHWGodSettingsSubsystem::CachedCharacterItem' has a wrong offset!");

// Class Hemingway.HWAttributeSet_Pele
// 0x0018 (0x07C0 - 0x07A8)
class UHWAttributeSet_Pele final : public UHWAttributeSet_God
{
public:
	struct FGameplayAttributeData                 Fuel;                                              // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         MaxFuel;                                           // 0x07B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Fuel(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Pele">();
	}
	static class UHWAttributeSet_Pele* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Pele>();
	}
};
static_assert(alignof(UHWAttributeSet_Pele) == 0x000008, "Wrong alignment on UHWAttributeSet_Pele");
static_assert(sizeof(UHWAttributeSet_Pele) == 0x0007C0, "Wrong size on UHWAttributeSet_Pele");
static_assert(offsetof(UHWAttributeSet_Pele, Fuel) == 0x0007A8, "Member 'UHWAttributeSet_Pele::Fuel' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Pele, MaxFuel) == 0x0007B8, "Member 'UHWAttributeSet_Pele::MaxFuel' has a wrong offset!");

// Class Hemingway.HWEquipmentItemSortingConfig
// 0x0090 (0x00C0 - 0x0030)
class UHWEquipmentItemSortingConfig final : public UDataAsset
{
public:
	TArray<struct FHWAllItemListGroup>            AllItemListGroups;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWAllItemListFilter>           AllItemListFilters;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWAllItemListRoleFilters>      AllItemListRoleFilters;                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWAllItemListRoleFilters>      AllItemListRoleFiltersLegacy;                      // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EHWItemStoreMajorCategory, struct FHWMajorCategoryFilters> SplitStoreFilters;               // 0x0070(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentItemSortingConfig">();
	}
	static class UHWEquipmentItemSortingConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentItemSortingConfig>();
	}
};
static_assert(alignof(UHWEquipmentItemSortingConfig) == 0x000008, "Wrong alignment on UHWEquipmentItemSortingConfig");
static_assert(sizeof(UHWEquipmentItemSortingConfig) == 0x0000C0, "Wrong size on UHWEquipmentItemSortingConfig");
static_assert(offsetof(UHWEquipmentItemSortingConfig, AllItemListGroups) == 0x000030, "Member 'UHWEquipmentItemSortingConfig::AllItemListGroups' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSortingConfig, AllItemListFilters) == 0x000040, "Member 'UHWEquipmentItemSortingConfig::AllItemListFilters' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSortingConfig, AllItemListRoleFilters) == 0x000050, "Member 'UHWEquipmentItemSortingConfig::AllItemListRoleFilters' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSortingConfig, AllItemListRoleFiltersLegacy) == 0x000060, "Member 'UHWEquipmentItemSortingConfig::AllItemListRoleFiltersLegacy' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSortingConfig, SplitStoreFilters) == 0x000070, "Member 'UHWEquipmentItemSortingConfig::SplitStoreFilters' has a wrong offset!");

// Class Hemingway.HWAttributeSet_Scylla
// 0x0020 (0x07C8 - 0x07A8)
class UHWAttributeSet_Scylla final : public UHWAttributeSet_God
{
public:
	struct FGameplayTagContainer                  EffectTagsAllowedToModifyMana;                     // 0x07A8(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Scylla">();
	}
	static class UHWAttributeSet_Scylla* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Scylla>();
	}
};
static_assert(alignof(UHWAttributeSet_Scylla) == 0x000008, "Wrong alignment on UHWAttributeSet_Scylla");
static_assert(sizeof(UHWAttributeSet_Scylla) == 0x0007C8, "Wrong size on UHWAttributeSet_Scylla");
static_assert(offsetof(UHWAttributeSet_Scylla, EffectTagsAllowedToModifyMana) == 0x0007A8, "Member 'UHWAttributeSet_Scylla::EffectTagsAllowedToModifyMana' has a wrong offset!");

// Class Hemingway.HWInterface_Passthrough
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_Passthrough final
{
public:
	const struct FGameplayTagContainer GetPassthroughTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_Passthrough">();
	}
	static class IHWInterface_Passthrough* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_Passthrough>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_Passthrough) == 0x000001, "Wrong alignment on IHWInterface_Passthrough");
static_assert(sizeof(IHWInterface_Passthrough) == 0x000001, "Wrong size on IHWInterface_Passthrough");

// Class Hemingway.HWAttributeSet_Yemoja
// 0x0030 (0x07D8 - 0x07A8)
class UHWAttributeSet_Yemoja final : public UHWAttributeSet_God
{
public:
	struct FGameplayAttributeData                 Omi;                                               // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OmiPerTime;                                        // 0x07B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxOmi;                                            // 0x07C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_MaxOmi(const struct FGameplayAttributeData& OldValue);
	void OnRep_Omi(const struct FGameplayAttributeData& OldValue);
	void OnRep_OmiPerTime(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Yemoja">();
	}
	static class UHWAttributeSet_Yemoja* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Yemoja>();
	}
};
static_assert(alignof(UHWAttributeSet_Yemoja) == 0x000008, "Wrong alignment on UHWAttributeSet_Yemoja");
static_assert(sizeof(UHWAttributeSet_Yemoja) == 0x0007D8, "Wrong size on UHWAttributeSet_Yemoja");
static_assert(offsetof(UHWAttributeSet_Yemoja, Omi) == 0x0007A8, "Member 'UHWAttributeSet_Yemoja::Omi' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Yemoja, OmiPerTime) == 0x0007B8, "Member 'UHWAttributeSet_Yemoja::OmiPerTime' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Yemoja, MaxOmi) == 0x0007C8, "Member 'UHWAttributeSet_Yemoja::MaxOmi' has a wrong offset!");

// Class Hemingway.HWAudioComponent
// 0x0010 (0x0C90 - 0x0C80)
class UHWAudioComponent : public UAudioComponent
{
public:
	class FName                                   SkinningKeyword;                                   // 0x0C78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class IHWInterface_Skinnable> OwnerInterfaceSkinnable;                          // 0x0C80(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PerformSkinUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAudioComponent">();
	}
	static class UHWAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAudioComponent>();
	}
};
static_assert(alignof(UHWAudioComponent) == 0x000010, "Wrong alignment on UHWAudioComponent");
static_assert(sizeof(UHWAudioComponent) == 0x000C90, "Wrong size on UHWAudioComponent");
static_assert(offsetof(UHWAudioComponent, SkinningKeyword) == 0x000C78, "Member 'UHWAudioComponent::SkinningKeyword' has a wrong offset!");
static_assert(offsetof(UHWAudioComponent, OwnerInterfaceSkinnable) == 0x000C80, "Member 'UHWAudioComponent::OwnerInterfaceSkinnable' has a wrong offset!");

// Class Hemingway.HWLibrary_StatsParsing
// 0x0000 (0x0028 - 0x0028)
class UHWLibrary_StatsParsing final : public UBlueprintFunctionLibrary
{
public:
	static void AggregateTimeSeries(const TArray<struct FHWCombatLogEvent>& FilteredEvents, bool bCumulative, EHWGroupingField GroupingField, TMap<class FString, struct FHWTimeValueArray>* OutGroupedTimeSeries);
	static void CreateFilterFor(const class FString& RowType, const TArray<class FString>& RelevantNames, struct FHWCombatLogEventFilter* OutRowFilter);
	static struct FHWCombatLogTeamData ExtractTeams(const TArray<struct FHWCombatLogEvent>& MatchEvents);
	static void FetchAndParseCombatLog(class UObject* WorldContextObject, const struct FGuid& MatchID, TDelegate<void(const class FString& LoadedCombatLog)> CombatLogLoadedDelegate);
	static void FilterMatchEvents(const TArray<struct FHWCombatLogEvent>& AllEvents, const struct FHWCombatLogEventFilter& Filter, TArray<struct FHWCombatLogEvent>* OutFilteredEvents);
	static void GenerateTimeSeriesData(const TArray<struct FHWCombatLogEvent>& MatchEvents, const class FString& EventTypeFilter, const TArray<class FString>& SourceActors, const TArray<class FString>& TargetActors, bool bCumulative, TArray<struct FVector2D>* OutData);
	static void GetNamesForRoles(const TArray<struct FHWCombatLogEvent>& MatchEvents, const class FString& RoleName, const int32 TeamId, TArray<class FString>* OutNames, int32 OutTeamSplitIndex);
	static void LoadCombatLog(const class FString& FilePath, TArray<struct FHWCombatLogEvent>* MatchEvents);
	static void ProcessCombatLogString(const class FString& CombatLogString, TArray<struct FHWCombatLogEvent>* OutMatchEvents);
	static void UpdateTimeSeriesPlot(class UHWTimeSeriesDataSource* DataSource, class UTimeSeriesPlot* TimeSeriesPlot, const TArray<struct FVector2D>& DataSeries, const class FString& SeriesName, const struct FLinearColor& LineColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLibrary_StatsParsing">();
	}
	static class UHWLibrary_StatsParsing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLibrary_StatsParsing>();
	}
};
static_assert(alignof(UHWLibrary_StatsParsing) == 0x000008, "Wrong alignment on UHWLibrary_StatsParsing");
static_assert(sizeof(UHWLibrary_StatsParsing) == 0x000028, "Wrong size on UHWLibrary_StatsParsing");

// Class Hemingway.HWAudioComponent_Deployable
// 0x0000 (0x0C90 - 0x0C90)
class UHWAudioComponent_Deployable final : public UHWAudioComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAudioComponent_Deployable">();
	}
	static class UHWAudioComponent_Deployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAudioComponent_Deployable>();
	}
};
static_assert(alignof(UHWAudioComponent_Deployable) == 0x000010, "Wrong alignment on UHWAudioComponent_Deployable");
static_assert(sizeof(UHWAudioComponent_Deployable) == 0x000C90, "Wrong size on UHWAudioComponent_Deployable");

// Class Hemingway.HWGodSubsystem
// 0x0160 (0x0190 - 0x0030)
class UHWGodSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnGodSubsystemReady;                               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FRH_ItemId>                     CachedGodsOnRotation;                              // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWCharacterItem*>               FullListOfGods;                                    // 0x0070(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UHWCharacterItem*>               CachedPlayableGods;                                // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UHWCharacterItem*>               CachedActiveGods;                                  // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UHWSkinItem*>                    CachedPlayableSkins;                               // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UHWSkinItem*>                    CachedActiveSkins;                                 // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UHWCharacterItem*>               CachedPreviewGods;                                 // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UHWCharacterItem*>               ComingSoonGods;                                    // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x20];                                      // 0x00E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 FallbackGodIds;                                    // 0x0100(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          PreviewGodIds;                                     // 0x0110(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bSkipRotationVendor;                               // 0x0120(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UHWCharacterItem>> GodItemsToLoad;                                   // 0x0128(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class FString>                         GodBotRestrictedList;                              // 0x0138(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<class UHWCharacterItem*>               CachedGodsWithConfiguredAI;                        // 0x0148(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x38];                                     // 0x0158(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGodsRotationVendorReceived(bool bSuccessfullyLoaded);
	void OnGodsVendorReceived(bool bSuccessfullyLoaded);
	void OnRHSessionChanged(class URH_JoinedSession* OldSession, class URH_JoinedSession* ActiveSession);
	void OnSkinsLoaded();
	void OnSkinsVendorReceived(bool bSuccessfullyLoaded);

	const class UHWCharacterItem* GetGodByItemId(const struct FRH_ItemId& ItemId, bool bPlayableOnly) const;
	const class UHWCharacterItem* GetGodByName(const class FString& Name_0, bool bPlayableOnly) const;
	const class UHWCharacterItem* GetGodByPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId, bool bPlayableOnly) const;
	const class UHWCharacterItem* GetGodByTag(const struct FGameplayTag& GameplayTag, bool bPlayableOnly) const;
	const class UHWSkinItem* GetSkinByItemId(const struct FRH_ItemId& ItemId, bool bPlayableOnly) const;
	bool HasLoadedGodsAndSkins() const;
	bool IsGodInComingSoon(const struct FGameplayTag& GodTag) const;
	bool IsReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGodSubsystem">();
	}
	static class UHWGodSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGodSubsystem>();
	}
};
static_assert(alignof(UHWGodSubsystem) == 0x000008, "Wrong alignment on UHWGodSubsystem");
static_assert(sizeof(UHWGodSubsystem) == 0x000190, "Wrong size on UHWGodSubsystem");
static_assert(offsetof(UHWGodSubsystem, OnGodSubsystemReady) == 0x000030, "Member 'UHWGodSubsystem::OnGodSubsystemReady' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, CachedGodsOnRotation) == 0x000040, "Member 'UHWGodSubsystem::CachedGodsOnRotation' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, FullListOfGods) == 0x000070, "Member 'UHWGodSubsystem::FullListOfGods' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, CachedPlayableGods) == 0x000080, "Member 'UHWGodSubsystem::CachedPlayableGods' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, CachedActiveGods) == 0x000090, "Member 'UHWGodSubsystem::CachedActiveGods' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, CachedPlayableSkins) == 0x0000A0, "Member 'UHWGodSubsystem::CachedPlayableSkins' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, CachedActiveSkins) == 0x0000B0, "Member 'UHWGodSubsystem::CachedActiveSkins' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, CachedPreviewGods) == 0x0000C0, "Member 'UHWGodSubsystem::CachedPreviewGods' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, ComingSoonGods) == 0x0000D0, "Member 'UHWGodSubsystem::ComingSoonGods' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, FallbackGodIds) == 0x000100, "Member 'UHWGodSubsystem::FallbackGodIds' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, PreviewGodIds) == 0x000110, "Member 'UHWGodSubsystem::PreviewGodIds' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, bSkipRotationVendor) == 0x000120, "Member 'UHWGodSubsystem::bSkipRotationVendor' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, GodItemsToLoad) == 0x000128, "Member 'UHWGodSubsystem::GodItemsToLoad' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, GodBotRestrictedList) == 0x000138, "Member 'UHWGodSubsystem::GodBotRestrictedList' has a wrong offset!");
static_assert(offsetof(UHWGodSubsystem, CachedGodsWithConfiguredAI) == 0x000148, "Member 'UHWGodSubsystem::CachedGodsWithConfiguredAI' has a wrong offset!");

// Class Hemingway.HWAudioManager
// 0x0000 (0x0028 - 0x0028)
class UHWAudioManager final : public UAudioFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAudioManager">();
	}
	static class UHWAudioManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAudioManager>();
	}
};
static_assert(alignof(UHWAudioManager) == 0x000008, "Wrong alignment on UHWAudioManager");
static_assert(sizeof(UHWAudioManager) == 0x000028, "Wrong size on UHWAudioManager");

// Class Hemingway.HWInterface_SwapAbility
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_SwapAbility final
{
public:
	void SwapAbility(class UHWEquipmentComponent_AbilitySwap* AbilitySwapComponent, const struct FHWAbilitySwapInfo& SwapInfo);

	bool CanSwapAbility(const class UHWEquipmentComponent_AbilitySwap* AbilitySwapComponent, const struct FHWAbilitySwapInfo& SwapInfo, const class UHWAbilitySystemComponent* AbilitySystem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_SwapAbility">();
	}
	static class IHWInterface_SwapAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_SwapAbility>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_SwapAbility) == 0x000001, "Wrong alignment on IHWInterface_SwapAbility");
static_assert(sizeof(IHWInterface_SwapAbility) == 0x000001, "Wrong size on IHWInterface_SwapAbility");

// Class Hemingway.HWAutoBuyBuildProfile
// 0x0050 (0x0078 - 0x0028)
class UHWAutoBuyBuildProfile : public UObject
{
public:
	class FName                                   ProfileName;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ProfileDisplayName;                                // 0x0030(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ProfileDesc;                                       // 0x0048(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             ProfileIcon;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHWEquipmentRecipe*>             RecipesToBuild;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class FText GetProfileDesc() const;
	class FText GetProfileDisplayName() const;
	class UTexture2D* GetProfileIcon() const;
	class FName GetProfileName() const;
	const TArray<class UHWEquipmentRecipe*> GetRecipesToBuild() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAutoBuyBuildProfile">();
	}
	static class UHWAutoBuyBuildProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAutoBuyBuildProfile>();
	}
};
static_assert(alignof(UHWAutoBuyBuildProfile) == 0x000008, "Wrong alignment on UHWAutoBuyBuildProfile");
static_assert(sizeof(UHWAutoBuyBuildProfile) == 0x000078, "Wrong size on UHWAutoBuyBuildProfile");
static_assert(offsetof(UHWAutoBuyBuildProfile, ProfileName) == 0x000028, "Member 'UHWAutoBuyBuildProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(UHWAutoBuyBuildProfile, ProfileDisplayName) == 0x000030, "Member 'UHWAutoBuyBuildProfile::ProfileDisplayName' has a wrong offset!");
static_assert(offsetof(UHWAutoBuyBuildProfile, ProfileDesc) == 0x000048, "Member 'UHWAutoBuyBuildProfile::ProfileDesc' has a wrong offset!");
static_assert(offsetof(UHWAutoBuyBuildProfile, ProfileIcon) == 0x000060, "Member 'UHWAutoBuyBuildProfile::ProfileIcon' has a wrong offset!");
static_assert(offsetof(UHWAutoBuyBuildProfile, RecipesToBuild) == 0x000068, "Member 'UHWAutoBuyBuildProfile::RecipesToBuild' has a wrong offset!");

// Class Hemingway.HWAutoPingWorldActor
// 0x0030 (0x02C8 - 0x0298)
class AHWAutoPingWorldActor final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AutoPingTags;                                      // 0x02A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	int32                                         TeamAssignment;                                    // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool MatchesRequiredTags(const struct FGameplayTagContainer& PingTags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAutoPingWorldActor">();
	}
	static class AHWAutoPingWorldActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWAutoPingWorldActor>();
	}
};
static_assert(alignof(AHWAutoPingWorldActor) == 0x000008, "Wrong alignment on AHWAutoPingWorldActor");
static_assert(sizeof(AHWAutoPingWorldActor) == 0x0002C8, "Wrong size on AHWAutoPingWorldActor");
static_assert(offsetof(AHWAutoPingWorldActor, AutoPingTags) == 0x0002A0, "Member 'AHWAutoPingWorldActor::AutoPingTags' has a wrong offset!");
static_assert(offsetof(AHWAutoPingWorldActor, TeamAssignment) == 0x0002C0, "Member 'AHWAutoPingWorldActor::TeamAssignment' has a wrong offset!");

// Class Hemingway.HWInterface_HUD
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_HUD final
{
public:
	void GetSeamlessTravelActorList(bool bToEntry, TArray<class AActor*>* ActorList);
	TMap<struct FGameplayTag, struct FLinearColor> GetWorldColorForTags(const struct FGameplayTagContainer& ColorTags);
	void ProcessInput(const struct FGameplayTag& InputTag, ETriggerEvent TriggerEvent);
	void ReceivedGameModeClass(TSubclassOf<class AGameModeBase> GameModeClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_HUD">();
	}
	static class IHWInterface_HUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_HUD>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_HUD) == 0x000001, "Wrong alignment on IHWInterface_HUD");
static_assert(sizeof(IHWInterface_HUD) == 0x000001, "Wrong size on IHWInterface_HUD");

// Class Hemingway.HWBackfillSubsystem
// 0x0028 (0x0058 - 0x0030)
class UHWBackfillSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(const struct FHWBackfillQueueInfo& BackfillQueueInfo)> OnBackfillInfoUpdated; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHWBackfillQueueInfo                   QueueInfo;                                         // 0x0040(0x0014)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleActiveSessionChanged(class URH_JoinedSession* OldSession, class URH_JoinedSession* NewSession);

	struct FHWBackfillQueueInfo GetBackfillQueueInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBackfillSubsystem">();
	}
	static class UHWBackfillSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBackfillSubsystem>();
	}
};
static_assert(alignof(UHWBackfillSubsystem) == 0x000008, "Wrong alignment on UHWBackfillSubsystem");
static_assert(sizeof(UHWBackfillSubsystem) == 0x000058, "Wrong size on UHWBackfillSubsystem");
static_assert(offsetof(UHWBackfillSubsystem, OnBackfillInfoUpdated) == 0x000030, "Member 'UHWBackfillSubsystem::OnBackfillInfoUpdated' has a wrong offset!");
static_assert(offsetof(UHWBackfillSubsystem, QueueInfo) == 0x000040, "Member 'UHWBackfillSubsystem::QueueInfo' has a wrong offset!");

// Class Hemingway.HWBotFactory_VisibilityComponent
// 0x0168 (0x0208 - 0x00A0)
class UHWBotFactory_VisibilityComponent final : public UHWActorComponent
{
public:
	TMulticastInlineDelegate<void(class UHWBotFactory_VisibilityComponent* Comp)> OnMinimapStateChanged; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bGlobalMinimapVision;                              // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x17];                                      // 0x00B1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	EFactoryMinimapState                          ServerMapState;                                    // 0x00C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTeamFactoryMapStateList               TeamMapStates;                                     // 0x00D0(0x0120)(Net, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 TeamsThatOnlySeeTimerOnEmpty;                      // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDidJustEmpty;                                     // 0x0200(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckAndUpdateMapVisionFor(int32 TeamId);
	bool DoesTeamNeedUpdatedMapState(int32 TeamId);
	EFactoryMinimapState GetLocalTeamMinimapState();
	bool IsLocalTeamMinimapStateOutOfSync();
	void OnRep_TeamMinimapStates();
	void RepeatingMapVisionUpdate();
	void SetAllTeamMinimapsTo(EFactoryMinimapState CurrentFactoryState);
	void SetAllTeamsRequireVisibilityUpdate();
	void SetSyncedTeamMinimapsTo(EFactoryMinimapState CurrentFactoryState);
	void SetSyncedTeamStatesToActive();
	void SetToActive();
	void SetToEmpty(class AActor* Causer, bool bIsRespawning);
	void SetToRespawning();

	bool CanLocalTeamSeeCampRespawn() const;
	EFactoryMinimapState GetServerMapState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBotFactory_VisibilityComponent">();
	}
	static class UHWBotFactory_VisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBotFactory_VisibilityComponent>();
	}
};
static_assert(alignof(UHWBotFactory_VisibilityComponent) == 0x000008, "Wrong alignment on UHWBotFactory_VisibilityComponent");
static_assert(sizeof(UHWBotFactory_VisibilityComponent) == 0x000208, "Wrong size on UHWBotFactory_VisibilityComponent");
static_assert(offsetof(UHWBotFactory_VisibilityComponent, OnMinimapStateChanged) == 0x0000A0, "Member 'UHWBotFactory_VisibilityComponent::OnMinimapStateChanged' has a wrong offset!");
static_assert(offsetof(UHWBotFactory_VisibilityComponent, bGlobalMinimapVision) == 0x0000B0, "Member 'UHWBotFactory_VisibilityComponent::bGlobalMinimapVision' has a wrong offset!");
static_assert(offsetof(UHWBotFactory_VisibilityComponent, ServerMapState) == 0x0000C8, "Member 'UHWBotFactory_VisibilityComponent::ServerMapState' has a wrong offset!");
static_assert(offsetof(UHWBotFactory_VisibilityComponent, TeamMapStates) == 0x0000D0, "Member 'UHWBotFactory_VisibilityComponent::TeamMapStates' has a wrong offset!");
static_assert(offsetof(UHWBotFactory_VisibilityComponent, TeamsThatOnlySeeTimerOnEmpty) == 0x0001F0, "Member 'UHWBotFactory_VisibilityComponent::TeamsThatOnlySeeTimerOnEmpty' has a wrong offset!");
static_assert(offsetof(UHWBotFactory_VisibilityComponent, bDidJustEmpty) == 0x000200, "Member 'UHWBotFactory_VisibilityComponent::bDidJustEmpty' has a wrong offset!");

// Class Hemingway.HWDestructible
// 0x0000 (0x04C8 - 0x04C8)
class AHWDestructible final : public AHWDeployable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDestructible">();
	}
	static class AHWDestructible* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDestructible>();
	}
};
static_assert(alignof(AHWDestructible) == 0x000008, "Wrong alignment on AHWDestructible");
static_assert(sizeof(AHWDestructible) == 0x0004C8, "Wrong size on AHWDestructible");

// Class Hemingway.HWBotPropertiesDefinition
// 0x0020 (0x0050 - 0x0030)
class UHWBotPropertiesDefinition final : public UPrimaryDataAsset
{
public:
	TArray<class FName>                           LanePriorities;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UHWAIReasonerOption>> Options;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBotPropertiesDefinition">();
	}
	static class UHWBotPropertiesDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBotPropertiesDefinition>();
	}
};
static_assert(alignof(UHWBotPropertiesDefinition) == 0x000008, "Wrong alignment on UHWBotPropertiesDefinition");
static_assert(sizeof(UHWBotPropertiesDefinition) == 0x000050, "Wrong size on UHWBotPropertiesDefinition");
static_assert(offsetof(UHWBotPropertiesDefinition, LanePriorities) == 0x000030, "Member 'UHWBotPropertiesDefinition::LanePriorities' has a wrong offset!");
static_assert(offsetof(UHWBotPropertiesDefinition, Options) == 0x000040, "Member 'UHWBotPropertiesDefinition::Options' has a wrong offset!");

// Class Hemingway.HWBTDecorator_CanUseAbility
// 0x0010 (0x0078 - 0x0068)
class UHWBTDecorator_CanUseAbility final : public UBTDecorator
{
public:
	struct FGameplayTag                           EquipmentSlotTag;                                  // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotId;                                            // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckRangeAgainstTarget;                          // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTDecorator_CanUseAbility">();
	}
	static class UHWBTDecorator_CanUseAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTDecorator_CanUseAbility>();
	}
};
static_assert(alignof(UHWBTDecorator_CanUseAbility) == 0x000008, "Wrong alignment on UHWBTDecorator_CanUseAbility");
static_assert(sizeof(UHWBTDecorator_CanUseAbility) == 0x000078, "Wrong size on UHWBTDecorator_CanUseAbility");
static_assert(offsetof(UHWBTDecorator_CanUseAbility, EquipmentSlotTag) == 0x000068, "Member 'UHWBTDecorator_CanUseAbility::EquipmentSlotTag' has a wrong offset!");
static_assert(offsetof(UHWBTDecorator_CanUseAbility, SlotId) == 0x000070, "Member 'UHWBTDecorator_CanUseAbility::SlotId' has a wrong offset!");
static_assert(offsetof(UHWBTDecorator_CanUseAbility, bCheckRangeAgainstTarget) == 0x000074, "Member 'UHWBTDecorator_CanUseAbility::bCheckRangeAgainstTarget' has a wrong offset!");

// Class Hemingway.HWShieldManagerComponent
// 0x0138 (0x01D8 - 0x00A0)
class UHWShieldManagerComponent final : public UHWActorComponent
{
public:
	TMulticastInlineDelegate<void(class UHWShieldInstance* ShieldInstance, float NewHealth)> OnShieldInstanceHealthChangeDel; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWShieldManagerComponent* ShieldManagerComponent)> OnActiveShieldsListUpdatedDel; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHWActiveShieldList                    ActiveShields;                                     // 0x00C0(0x0118)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void AddShieldEntry(struct FActiveShieldEntry* NewShield);
	void GetAllShieldInstances(TArray<class UHWShieldInstance*>* OutShieldInstances);
	void GetAllShieldInstancesByGrantingASC(TArray<class UHWShieldInstance*>* OutShieldInstances, class UHWAbilitySystemComponent* GranterASC);
	void GetAllShieldInstancesByTag(TArray<class UHWShieldInstance*>* OutShieldInstances, const struct FGameplayTag& ShieldEffectTag);
	void GetAllShieldInstancesByType(TArray<class UHWShieldInstance*>* OutShieldInstances, EShieldType ShieldType);
	void GetAllShieldInstancesWithLifetimes(TArray<class UHWShieldInstance*>* OutShieldInstances);
	class UHWShieldInstance* GetHighestPriorityShieldInstance(EShieldType TargetShieldType);
	class UHWShieldInstance* GetShieldInstanceByTagAndASC(const struct FGameplayTag& ShieldEffectTag, class UHWAbilitySystemComponent* GranterASC);
	float GetTotalMagicalShieldHealth();
	float GetTotalOmniShieldHealth();
	float GetTotalPhysicalShieldHealth();
	float GetTotalShieldHealth();
	void HandleIncomingShieldModifierEffect(const class UHWGameplayEffect_ShieldModifier* ShieldModifierEffectCDO, const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FGameplayEffectSpec& EffectSpec);
	class UHWShieldInstance* HandleIncomingShieldOwnerEffect(const class UHWGameplayEffect_ShieldOwner* ShieldOwnerEffectCDO, const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FGameplayEffectSpec& EffectSpec, const struct FActiveGameplayEffectHandle& ShieldOwnerActiveEffectHandle);
	void OnRep_ActiveShields();
	void RemoveShieldEntry(const struct FActiveShieldEntry& ShieldToRemove);
	bool RemoveShieldInstance(class UHWShieldInstance* ShieldInstanceToRemove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWShieldManagerComponent">();
	}
	static class UHWShieldManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWShieldManagerComponent>();
	}
};
static_assert(alignof(UHWShieldManagerComponent) == 0x000008, "Wrong alignment on UHWShieldManagerComponent");
static_assert(sizeof(UHWShieldManagerComponent) == 0x0001D8, "Wrong size on UHWShieldManagerComponent");
static_assert(offsetof(UHWShieldManagerComponent, OnShieldInstanceHealthChangeDel) == 0x0000A0, "Member 'UHWShieldManagerComponent::OnShieldInstanceHealthChangeDel' has a wrong offset!");
static_assert(offsetof(UHWShieldManagerComponent, OnActiveShieldsListUpdatedDel) == 0x0000B0, "Member 'UHWShieldManagerComponent::OnActiveShieldsListUpdatedDel' has a wrong offset!");
static_assert(offsetof(UHWShieldManagerComponent, ActiveShields) == 0x0000C0, "Member 'UHWShieldManagerComponent::ActiveShields' has a wrong offset!");

// Class Hemingway.HWBTDecorator_IsCharacterValid
// 0x0000 (0x0090 - 0x0090)
class UHWBTDecorator_IsCharacterValid final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTDecorator_IsCharacterValid">();
	}
	static class UHWBTDecorator_IsCharacterValid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTDecorator_IsCharacterValid>();
	}
};
static_assert(alignof(UHWBTDecorator_IsCharacterValid) == 0x000008, "Wrong alignment on UHWBTDecorator_IsCharacterValid");
static_assert(sizeof(UHWBTDecorator_IsCharacterValid) == 0x000090, "Wrong size on UHWBTDecorator_IsCharacterValid");

// Class Hemingway.HWBTService_AquireTarget
// 0x00A8 (0x0118 - 0x0070)
class UHWBTService_AquireTarget final : public UBTService
{
public:
	struct FBlackboardKeySelector                 TargetContainerKey;                                // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAITargetPriorityInfo>          TargetPriorities;                                  // 0x0098(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x00A8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  InitialTagsToIgnore;                               // 0x00C8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGenericTeamId>                 IgnoreTeamsList;                                   // 0x00E8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         HostileTargetDecayTime;                            // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPointZOffset;                                  // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PerceptionConeAngleInDegrees;                      // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyTargetListPostProcessing;                    // 0x0104(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          CollectedActorsList;                               // 0x0108(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTService_AquireTarget">();
	}
	static class UHWBTService_AquireTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTService_AquireTarget>();
	}
};
static_assert(alignof(UHWBTService_AquireTarget) == 0x000008, "Wrong alignment on UHWBTService_AquireTarget");
static_assert(sizeof(UHWBTService_AquireTarget) == 0x000118, "Wrong size on UHWBTService_AquireTarget");
static_assert(offsetof(UHWBTService_AquireTarget, TargetContainerKey) == 0x000070, "Member 'UHWBTService_AquireTarget::TargetContainerKey' has a wrong offset!");
static_assert(offsetof(UHWBTService_AquireTarget, TargetPriorities) == 0x000098, "Member 'UHWBTService_AquireTarget::TargetPriorities' has a wrong offset!");
static_assert(offsetof(UHWBTService_AquireTarget, tagsToIgnore) == 0x0000A8, "Member 'UHWBTService_AquireTarget::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(UHWBTService_AquireTarget, InitialTagsToIgnore) == 0x0000C8, "Member 'UHWBTService_AquireTarget::InitialTagsToIgnore' has a wrong offset!");
static_assert(offsetof(UHWBTService_AquireTarget, IgnoreTeamsList) == 0x0000E8, "Member 'UHWBTService_AquireTarget::IgnoreTeamsList' has a wrong offset!");
static_assert(offsetof(UHWBTService_AquireTarget, HostileTargetDecayTime) == 0x0000F8, "Member 'UHWBTService_AquireTarget::HostileTargetDecayTime' has a wrong offset!");
static_assert(offsetof(UHWBTService_AquireTarget, ViewPointZOffset) == 0x0000FC, "Member 'UHWBTService_AquireTarget::ViewPointZOffset' has a wrong offset!");
static_assert(offsetof(UHWBTService_AquireTarget, PerceptionConeAngleInDegrees) == 0x000100, "Member 'UHWBTService_AquireTarget::PerceptionConeAngleInDegrees' has a wrong offset!");
static_assert(offsetof(UHWBTService_AquireTarget, bApplyTargetListPostProcessing) == 0x000104, "Member 'UHWBTService_AquireTarget::bApplyTargetListPostProcessing' has a wrong offset!");
static_assert(offsetof(UHWBTService_AquireTarget, CollectedActorsList) == 0x000108, "Member 'UHWBTService_AquireTarget::CollectedActorsList' has a wrong offset!");

// Class Hemingway.HWDeployable_Trail
// 0x00D8 (0x05A0 - 0x04C8)
class AHWDeployable_Trail final : public AHWDeployable
{
public:
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWDeployable_Trail* Trail, const bool bIsActive)> OnTrailStateChangedDelegate; // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHWSplineActiveState                   TrailActiveState;                                  // 0x04E0(0x0038)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHideTrailOnDeactivate;                            // 0x0518(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_519[0x7];                                      // 0x0519(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CharacterRequireTags;                              // 0x0520(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UHWSplinePathMeshManagerComponent*      TrailSplineManager;                                // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSegmentDistance;                                // 0x0548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialSpawnLocationOffset;                        // 0x0550(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysSpawnTrailOnGround;                         // 0x0568(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x7];                                      // 0x0569(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bKeepEndCapStraight;                               // 0x0570(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowNewTrailSegments;                            // 0x0571(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_572[0x6];                                      // 0x0572(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWDeployable_Trail* Trail, const struct FGameplayAbilityTargetDataHandle& OverlappedTarget, const struct FHWSplineOverlapInfo& TrailOverlapInfo)> OnTrailBeginOverlapDelegate; // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWDeployable_Trail* Trail, const struct FGameplayAbilityTargetDataHandle& OverlappedTarget)> OnTrailEndOverlapDelegate; // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWNiagaraComponent*                    TrailFx;                                           // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActivateTrail();
	void BP_OnTrailActivated();
	void BP_OnTrailDeactivated();
	void DeactivateTrail(const bool bDestroyTrail);
	void DefaultOnTrailActivated();
	void OnRep_IsTrailActive();
	void OnTrailBeginOverlap(class UHWSplinePathMeshManagerComponent* TrailSpline, const struct FGameplayAbilityTargetDataHandle& OverlappedTarget, const struct FHWSplineOverlapInfo& TrailOverlapInfo);
	void OnTrailEndOverlap(class UHWSplinePathMeshManagerComponent* TrailSpline, const struct FGameplayAbilityTargetDataHandle& OverlappedTarget);
	void OwningProxyOnTrailActivated();
	void SetAllowNewTrailSegments(bool bAllowNewSegments);

	float GetCurrentSegmentDistance() const;
	float GetMaxSegmentDistance() const;
	struct FVector GetOwnerVelocity() const;
	const TMap<class AActor*, struct FHWSplineOverlapInfo> GetTrailOverlaps() const;
	struct FVector GetTrailStartLocation() const;
	bool IsTrailActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Trail">();
	}
	static class AHWDeployable_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Trail>();
	}
};
static_assert(alignof(AHWDeployable_Trail) == 0x000008, "Wrong alignment on AHWDeployable_Trail");
static_assert(sizeof(AHWDeployable_Trail) == 0x0005A0, "Wrong size on AHWDeployable_Trail");
static_assert(offsetof(AHWDeployable_Trail, OnTrailStateChangedDelegate) == 0x0004D0, "Member 'AHWDeployable_Trail::OnTrailStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, TrailActiveState) == 0x0004E0, "Member 'AHWDeployable_Trail::TrailActiveState' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, bHideTrailOnDeactivate) == 0x000518, "Member 'AHWDeployable_Trail::bHideTrailOnDeactivate' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, CharacterRequireTags) == 0x000520, "Member 'AHWDeployable_Trail::CharacterRequireTags' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, TrailSplineManager) == 0x000540, "Member 'AHWDeployable_Trail::TrailSplineManager' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, MaxSegmentDistance) == 0x000548, "Member 'AHWDeployable_Trail::MaxSegmentDistance' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, InitialSpawnLocationOffset) == 0x000550, "Member 'AHWDeployable_Trail::InitialSpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, bAlwaysSpawnTrailOnGround) == 0x000568, "Member 'AHWDeployable_Trail::bAlwaysSpawnTrailOnGround' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, bKeepEndCapStraight) == 0x000570, "Member 'AHWDeployable_Trail::bKeepEndCapStraight' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, bAllowNewTrailSegments) == 0x000571, "Member 'AHWDeployable_Trail::bAllowNewTrailSegments' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, OnTrailBeginOverlapDelegate) == 0x000578, "Member 'AHWDeployable_Trail::OnTrailBeginOverlapDelegate' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, OnTrailEndOverlapDelegate) == 0x000588, "Member 'AHWDeployable_Trail::OnTrailEndOverlapDelegate' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Trail, TrailFx) == 0x000598, "Member 'AHWDeployable_Trail::TrailFx' has a wrong offset!");

// Class Hemingway.HWBTService_FleeTarget
// 0x0070 (0x00E0 - 0x0070)
class UHWBTService_FleeTarget final : public UBTService
{
public:
	struct FBlackboardKeySelector                 FleeTargetKey;                                     // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class UHWVectorFieldFollowCalc*               FleeVectorFieldCalculation;                        // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FleeWeight;                                        // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 CurrentTargetKey;                                  // 0x00A8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class UHWVectorFieldFollowCalc*               ObstacleAvoidanceVectorFieldCalculation;           // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleLookAheadDistance;                         // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleAvoidanceWeight;                           // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTService_FleeTarget">();
	}
	static class UHWBTService_FleeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTService_FleeTarget>();
	}
};
static_assert(alignof(UHWBTService_FleeTarget) == 0x000008, "Wrong alignment on UHWBTService_FleeTarget");
static_assert(sizeof(UHWBTService_FleeTarget) == 0x0000E0, "Wrong size on UHWBTService_FleeTarget");
static_assert(offsetof(UHWBTService_FleeTarget, FleeTargetKey) == 0x000070, "Member 'UHWBTService_FleeTarget::FleeTargetKey' has a wrong offset!");
static_assert(offsetof(UHWBTService_FleeTarget, FleeVectorFieldCalculation) == 0x000098, "Member 'UHWBTService_FleeTarget::FleeVectorFieldCalculation' has a wrong offset!");
static_assert(offsetof(UHWBTService_FleeTarget, FleeWeight) == 0x0000A0, "Member 'UHWBTService_FleeTarget::FleeWeight' has a wrong offset!");
static_assert(offsetof(UHWBTService_FleeTarget, CurrentTargetKey) == 0x0000A8, "Member 'UHWBTService_FleeTarget::CurrentTargetKey' has a wrong offset!");
static_assert(offsetof(UHWBTService_FleeTarget, ObstacleAvoidanceVectorFieldCalculation) == 0x0000D0, "Member 'UHWBTService_FleeTarget::ObstacleAvoidanceVectorFieldCalculation' has a wrong offset!");
static_assert(offsetof(UHWBTService_FleeTarget, ObstacleLookAheadDistance) == 0x0000D8, "Member 'UHWBTService_FleeTarget::ObstacleLookAheadDistance' has a wrong offset!");
static_assert(offsetof(UHWBTService_FleeTarget, ObstacleAvoidanceWeight) == 0x0000DC, "Member 'UHWBTService_FleeTarget::ObstacleAvoidanceWeight' has a wrong offset!");

// Class Hemingway.HWBTService_UpdateCombatRules
// 0x0028 (0x0098 - 0x0070)
class UHWBTService_UpdateCombatRules final : public UBTService
{
public:
	float                                         LowHealthThreshold;                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowHealthWeight;                                   // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinThreatHealthDiff;                               // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthAdvantageWeight;                             // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDamagedByTime;                                  // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HostilityWeight;                                   // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DangerZoneWeight;                                  // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NeutralMaxAdvantage;                               // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighMaxAdvantage;                                  // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTService_UpdateCombatRules">();
	}
	static class UHWBTService_UpdateCombatRules* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTService_UpdateCombatRules>();
	}
};
static_assert(alignof(UHWBTService_UpdateCombatRules) == 0x000008, "Wrong alignment on UHWBTService_UpdateCombatRules");
static_assert(sizeof(UHWBTService_UpdateCombatRules) == 0x000098, "Wrong size on UHWBTService_UpdateCombatRules");
static_assert(offsetof(UHWBTService_UpdateCombatRules, LowHealthThreshold) == 0x000070, "Member 'UHWBTService_UpdateCombatRules::LowHealthThreshold' has a wrong offset!");
static_assert(offsetof(UHWBTService_UpdateCombatRules, LowHealthWeight) == 0x000074, "Member 'UHWBTService_UpdateCombatRules::LowHealthWeight' has a wrong offset!");
static_assert(offsetof(UHWBTService_UpdateCombatRules, MinThreatHealthDiff) == 0x000078, "Member 'UHWBTService_UpdateCombatRules::MinThreatHealthDiff' has a wrong offset!");
static_assert(offsetof(UHWBTService_UpdateCombatRules, HealthAdvantageWeight) == 0x00007C, "Member 'UHWBTService_UpdateCombatRules::HealthAdvantageWeight' has a wrong offset!");
static_assert(offsetof(UHWBTService_UpdateCombatRules, MaxDamagedByTime) == 0x000080, "Member 'UHWBTService_UpdateCombatRules::MaxDamagedByTime' has a wrong offset!");
static_assert(offsetof(UHWBTService_UpdateCombatRules, HostilityWeight) == 0x000084, "Member 'UHWBTService_UpdateCombatRules::HostilityWeight' has a wrong offset!");
static_assert(offsetof(UHWBTService_UpdateCombatRules, DangerZoneWeight) == 0x000088, "Member 'UHWBTService_UpdateCombatRules::DangerZoneWeight' has a wrong offset!");
static_assert(offsetof(UHWBTService_UpdateCombatRules, NeutralMaxAdvantage) == 0x00008C, "Member 'UHWBTService_UpdateCombatRules::NeutralMaxAdvantage' has a wrong offset!");
static_assert(offsetof(UHWBTService_UpdateCombatRules, HighMaxAdvantage) == 0x000090, "Member 'UHWBTService_UpdateCombatRules::HighMaxAdvantage' has a wrong offset!");

// Class Hemingway.HWCheatComponent
// 0x0090 (0x0130 - 0x00A0)
class UHWCheatComponent : public UHWActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              TestEffectTable;                                   // 0x00B0(0x0028)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAILearningRecorder*                  AILearningRecorder;                                // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWAIPerceptionComponent>   BotPerceptionComponentClass;                       // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BotsShootTree;                                     // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BotsOrbitTree;                                     // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BotsPatrolTree;                                    // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWAIGoal>                  BotsFightGoalClass;                                // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHWActiveQuest*>                 ActiveTestQuests;                                  // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddGold(const int32 GoldToAdd);
	void ApplyBooster(const struct FGameplayTag& BoosterTag);
	void BotsAddGold(int32 Amount);
	void BotsCooldowns(bool bIgnoreCooldowns);
	void BotsFight();
	void BotShootHUD(const int32 AbilityNumber, const class FString& BotName, const float WaitTime, const int32 Count);
	void BotsImmune(bool bImmunity);
	void BotsLevel(int32 Level);
	void BotsOrbit(float Radius, bool bGlobal);
	void BotsPatrol(float Distance, bool bGlobal);
	void BotsShoot(const int32 AbilityNumber, float WaitTime, int32 Count);
	void BotsShootOnce(const int32 AbilityNumber, float WaitTime);
	void BotsShootOnceSpecific(const class FString& BotName, const int32 AbilityNumber, float WaitTime);
	void BotsShootSpecific(const class FString& BotName, const int32 AbilityNumber, float WaitTime, int32 Count);
	void BotsShootWithRefire(const int32 AbilityNumber, float RefireTime, class FName RefireInput, float WaitTime, int32 Count);
	void BotsShootWithRefireSpecific(const class FString& BotName, const int32 AbilityNumber, float RefireTime, class FName RefireInput, float WaitTime, int32 Count);
	void BotsSkillsToLevel(int32 Level);
	void BotsStopShooting();
	void BotsUp(bool bToggle);
	void CallVGS(const class FString& ActionTag);
	void CharacterTestCheat(bool bSetActive, int32 testInt);
	void CheevesMeJeeves();
	void ClientTriggerTestAssert();
	void ClientTriggerTestEnsure();
	void Cooldowns();
	void Costs();
	void DebugMinimap(const class FName& UniqueNameTag);
	void DebugSocket(const class FString& SocketName);
	void DebugStat(const class FName& StatName);
	void DestroyNextAlliedTowerInLane(class FName Lane);
	void DestroyNextEnemyTowerInLane(class FName Lane);
	void DumpGodVisibilityData();
	void ForceDraftToComplete();
	void ForceSetFadeParameter(float FadeParameter);
	void ForceUpdateVisibility();
	void God();
	void hmu(const class FName& Name_0);
	void HookMeUp();
	void InternalServerQuickTrace();
	void KillAllMinions();
	void LogCosmeticInventory();
	void MorriganTest(bool bEnable);
	void NoMoreMinions();
	void PopSoundMixModifier(const class FString& Name_0);
	void PrintGameplayTagNetIndices();
	void PushSoundMixModifier(const class FString& Name_0);
	void QEG(bool bWin);
	void QuickEndGame(bool bWin);
	void QuickTrace();
	void RequestPlayerRolePreferences();
	void RequestRelease();
	void RerollCharacter(EHWDraftHealerRequirement HealerRequirement);
	void ResetCooldowns();
	void sc(const class FName& Name_0);
	void ServerAddGold(const int32 GoldToAdd);
	void ServerApplyBooster(const struct FGameplayTag& BoosterTag);
	void ServerBotsAddGold(int32 Amount);
	void ServerBotsCooldowns(bool bIgnoreCooldowns);
	void ServerBotsFight();
	void ServerBotShootHUD(const int32 AbilityNumber, const class FString& BotName, const float WaitTime, const int32 Count);
	void ServerBotsImmune(bool bImmunity);
	void ServerBotsLevel(int32 Level);
	void ServerBotsOrbit(float Radius, bool bGlobal);
	void ServerBotsPatrol(float Distance, bool bGlobal);
	void ServerBotsShoot(const class FString& BotName, const int32 AbilityNumber, float WaitTime, int32 Count, float RefireTime, class FName RefireInput);
	void ServerBotsSkillsToLevel(int32 Level);
	void ServerBotsStopShooting();
	void ServerBotsUp(bool bToggle);
	void ServerCharacterTestCheat(bool bSetActive, int32 testInt);
	void ServerCooldowns();
	void ServerCosts();
	void ServerDebugMinimap(const class FName& UniqueNameTag);
	void ServerDestroyNextTowerInLane(class FName Lane, bool bEnemy);
	void ServerExec(const class FString& Request);
	void ServerExecCall(const class FString& Request);
	void ServerForceDraftToComplete();
	void ServerGod();
	void ServerHookMeUp();
	void ServerKillAllMinions(bool bPreventNewMinions);
	void ServerLogCosmeticInventory();
	void ServerQuickEndGame(bool bWin);
	void ServerQuickTrace();
	void ServerRequestRelease();
	void ServerResetCooldowns();
	void ServerSetAnnouncerPack(const class FName& AnnouncerPackName);
	void ServerSetAutoBuy(const bool bEnable);
	void ServerSetAutoSkill(const bool bEnable);
	void ServerSetCharacter(const class FName& Name_0);
	void ServerSetCharacterRole(ECharacterRole NewRole);
	void ServerSetGlobalEmote(const class FName& GlobalEmoteName, int32 SlotIndex);
	void ServerSetInventoryAutoSortEnabled(bool bAutoSortEnabled);
	void ServerSetJumpStamp(const class FName& JumpStampName);
	void ServerSetLevel(const int32 Level);
	void ServerSetScore(int32 TeamId, int32 Score);
	void ServerSetSkin(const class FName& Name_0);
	void ServerSetSoundEmote(const class FName& SoundEmoteName);
	void ServerSetTeam(const int32 TeamId);
	void ServerSetTeleporterSkin(const class FName& TeleporterSkinName);
	void ServerSetVoicePackType(const int32 VoicePackType);
	void ServerSetWardSkin(const class FName& WardSkinName);
	void ServerSlomo(const float NewTimeDilation);
	void ServerSpawnBot(const class FName& BotRowName, const class FString& BotSkinName, const class FString& ActorName, const uint8 TeamId, const uint8 Level, const uint8 Count);
	void ServerSpawnBotHUD(const class FName& BotRowName, const class FString& BotSkinName, const class FString& ActorName, const uint8 TeamId, const uint8 Level);
	void ServerSpectate();
	void ServerStartAILearningRecording();
	void ServerStopAILearningRecording();
	void ServerSuicide();
	void ServerSuicideBots(bool bGodsOnly);
	void ServerSuperSonic(const bool bEnable);
	void ServerTestEffect(const class FName& EffectName, const float Duration, const float Magnitude);
	void ServerTestEffectOnTarget(const class FName& EffectName, const float Duration, const float Magnitude);
	void ServerTestQuest(int32 ItemId);
	void ServerTestTalent(const class FName& TalentName);
	void ServerToggleGodBotDebugDisplay(bool bOn);
	void ServerToggleItemEquip(const class UHWEquipmentItem* Equipment, const struct FHWInventorySlot& InventorySlot);
	void ServerTogglePrefireTest(const bool bOn);
	void ServerTowerKiller(const bool bEnable);
	void ServerUndoAllInvTransactions();
	void ServerUndoLastInvTransaction();
	void SetAbilityTargetingDebug(const bool bEnable);
	void SetAnnouncerPack(const class FName& AnnouncerPackName);
	void SetAutoBuy(const bool bEnable);
	void SetAutoSkill(const bool bEnable);
	void SetCharacter(const class FName& Name_0);
	void SetCharacterRole(ECharacterRole NewRole);
	void SetGlobalEmote(const class FName& GlobalEmoteName, int32 SlotIndex);
	void SetInventoryAutoSortEnabled(bool bAutoSortEnabled);
	void SetJumpStamp(const class FName& JumpStampName);
	void SetLevel(const int32 Level);
	void SetMusicPack(const class FName& MusicPackName);
	void SetScore(int32 TeamId, int32 Score);
	void SetSkin(const class FName& Name_0);
	void SetSoundEmote(const class FName& SoundEmoteName);
	void SetTeam(const int32 TeamId);
	void SetTeleporterSkin(const class FName& TeleporterSkinName);
	void SetVoicePackType(const int32 VoicePackType);
	void SetWardSkin(const class FName& WardSkinName);
	void Slomo(const float NewTimeDilation);
	void SpawnBot(const class FName& BotRowName, const uint8 TeamId, const uint8 Level);
	void SpawnBotHUD(const class FName& BotRowName, const class FString& BotSkinName, const class FString& ActorName, const uint8 TeamId, const uint8 Level);
	void SpawnBots(const class FName& BotRowName, const uint8 TeamId, const uint8 Level, const uint8 Count);
	void SpawnBotWithSkin(const class FName& BotRowName, const class FString& BotSkinName, const uint8 TeamId, const uint8 Level);
	void SpawnNamedBot(const class FName& BotRowName, const class FString& ActorName, const uint8 TeamId, const uint8 Level);
	void Spectate();
	void StartAILearningRecording();
	void StopAILearningRecording();
	void Suicide();
	void SuicideBots(bool bGodsOnly);
	void SuperSonic(const bool bEnable);
	void TestEffect(const class FName& EffectName, const float Duration, const float Magnitude);
	void TestEffectOnTarget(const class FName& EffectName, const float Duration, const float Magnitude);
	void TestQuest(int32 ItemId);
	void TestTalent(const class FName& TalentName);
	void ToggleGodBotDebugDisplay(bool bOn);
	void TogglePrefireTest(const bool bOn);
	void TowerKiller(const bool bEnable);
	void UndoAllInvTransactions();
	void UndoLastInvTransaction();
	void UpdatePlayerRolePreferences(int32 AssassinPreference, int32 SupportPreference, int32 ADCPreference, int32 SoloPreference, int32 MidPreference, bool bRoleFill);

	class AController* GetOuterController() const;
	class UHWAbilitySystemComponent* GetOwningAbilitySystem() const;
	class AHWCharacter_Base* GetOwningCharacter() const;
	class AHWCharacterAbilitySystemActor* GetOwningCharacterAbilitySystemActor() const;
	class UHWLoadoutComponent* GetOwningLoadoutComponent() const;
	class AHWPlayerState* GetOwningPlayerState() const;
	bool ValidateCheatPermission() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCheatComponent">();
	}
	static class UHWCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCheatComponent>();
	}
};
static_assert(alignof(UHWCheatComponent) == 0x000008, "Wrong alignment on UHWCheatComponent");
static_assert(sizeof(UHWCheatComponent) == 0x000130, "Wrong size on UHWCheatComponent");
static_assert(offsetof(UHWCheatComponent, TestEffectTable) == 0x0000B0, "Member 'UHWCheatComponent::TestEffectTable' has a wrong offset!");
static_assert(offsetof(UHWCheatComponent, AILearningRecorder) == 0x0000E8, "Member 'UHWCheatComponent::AILearningRecorder' has a wrong offset!");
static_assert(offsetof(UHWCheatComponent, BotPerceptionComponentClass) == 0x0000F8, "Member 'UHWCheatComponent::BotPerceptionComponentClass' has a wrong offset!");
static_assert(offsetof(UHWCheatComponent, BotsShootTree) == 0x000100, "Member 'UHWCheatComponent::BotsShootTree' has a wrong offset!");
static_assert(offsetof(UHWCheatComponent, BotsOrbitTree) == 0x000108, "Member 'UHWCheatComponent::BotsOrbitTree' has a wrong offset!");
static_assert(offsetof(UHWCheatComponent, BotsPatrolTree) == 0x000110, "Member 'UHWCheatComponent::BotsPatrolTree' has a wrong offset!");
static_assert(offsetof(UHWCheatComponent, BotsFightGoalClass) == 0x000118, "Member 'UHWCheatComponent::BotsFightGoalClass' has a wrong offset!");
static_assert(offsetof(UHWCheatComponent, ActiveTestQuests) == 0x000120, "Member 'UHWCheatComponent::ActiveTestQuests' has a wrong offset!");

// Class Hemingway.HWBTS_CombatPositioning
// 0x0088 (0x00F8 - 0x0070)
class UHWBTS_CombatPositioning final : public UBTService
{
public:
	bool                                          bUseLaneLogic;                                     // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWLaneAggressionParams                LanePositionParams;                                // 0x0078(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxTeammateRange;                                  // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TeammatesToIgnoreTags;                             // 0x00B8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	class UHWVectorFieldFollowCalc*               LaneFollowVectorFieldCalculation;                  // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWVectorFieldFollowCalc*               MeleeAttackVectorFieldCalculation;                 // 0x00E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWVectorFieldFollowCalc*               RangedAttackVectorFieldCalculation;                // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LaneFollowWeight;                                  // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTargetWeight;                               // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTS_CombatPositioning">();
	}
	static class UHWBTS_CombatPositioning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTS_CombatPositioning>();
	}
};
static_assert(alignof(UHWBTS_CombatPositioning) == 0x000008, "Wrong alignment on UHWBTS_CombatPositioning");
static_assert(sizeof(UHWBTS_CombatPositioning) == 0x0000F8, "Wrong size on UHWBTS_CombatPositioning");
static_assert(offsetof(UHWBTS_CombatPositioning, bUseLaneLogic) == 0x000070, "Member 'UHWBTS_CombatPositioning::bUseLaneLogic' has a wrong offset!");
static_assert(offsetof(UHWBTS_CombatPositioning, LanePositionParams) == 0x000078, "Member 'UHWBTS_CombatPositioning::LanePositionParams' has a wrong offset!");
static_assert(offsetof(UHWBTS_CombatPositioning, MaxTeammateRange) == 0x0000B0, "Member 'UHWBTS_CombatPositioning::MaxTeammateRange' has a wrong offset!");
static_assert(offsetof(UHWBTS_CombatPositioning, TeammatesToIgnoreTags) == 0x0000B8, "Member 'UHWBTS_CombatPositioning::TeammatesToIgnoreTags' has a wrong offset!");
static_assert(offsetof(UHWBTS_CombatPositioning, LaneFollowVectorFieldCalculation) == 0x0000D8, "Member 'UHWBTS_CombatPositioning::LaneFollowVectorFieldCalculation' has a wrong offset!");
static_assert(offsetof(UHWBTS_CombatPositioning, MeleeAttackVectorFieldCalculation) == 0x0000E0, "Member 'UHWBTS_CombatPositioning::MeleeAttackVectorFieldCalculation' has a wrong offset!");
static_assert(offsetof(UHWBTS_CombatPositioning, RangedAttackVectorFieldCalculation) == 0x0000E8, "Member 'UHWBTS_CombatPositioning::RangedAttackVectorFieldCalculation' has a wrong offset!");
static_assert(offsetof(UHWBTS_CombatPositioning, LaneFollowWeight) == 0x0000F0, "Member 'UHWBTS_CombatPositioning::LaneFollowWeight' has a wrong offset!");
static_assert(offsetof(UHWBTS_CombatPositioning, CurrentTargetWeight) == 0x0000F4, "Member 'UHWBTS_CombatPositioning::CurrentTargetWeight' has a wrong offset!");

// Class Hemingway.HWBTTask_ChooseAndFireAbility
// 0x0028 (0x0098 - 0x0070)
class UHWBTTask_ChooseAndFireAbility final : public UBTTaskNode
{
public:
	TArray<struct FHWBotAbilityData>              AbilityData;                                       // 0x0070(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         DoNothingWeight;                                   // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxReturnFireTime;                                 // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinCCDurationToTriggerAbilities;                   // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TraceChannel;                                      // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EscapeDot;                                         // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_ChooseAndFireAbility">();
	}
	static class UHWBTTask_ChooseAndFireAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_ChooseAndFireAbility>();
	}
};
static_assert(alignof(UHWBTTask_ChooseAndFireAbility) == 0x000008, "Wrong alignment on UHWBTTask_ChooseAndFireAbility");
static_assert(sizeof(UHWBTTask_ChooseAndFireAbility) == 0x000098, "Wrong size on UHWBTTask_ChooseAndFireAbility");
static_assert(offsetof(UHWBTTask_ChooseAndFireAbility, AbilityData) == 0x000070, "Member 'UHWBTTask_ChooseAndFireAbility::AbilityData' has a wrong offset!");
static_assert(offsetof(UHWBTTask_ChooseAndFireAbility, DoNothingWeight) == 0x000080, "Member 'UHWBTTask_ChooseAndFireAbility::DoNothingWeight' has a wrong offset!");
static_assert(offsetof(UHWBTTask_ChooseAndFireAbility, MaxReturnFireTime) == 0x000084, "Member 'UHWBTTask_ChooseAndFireAbility::MaxReturnFireTime' has a wrong offset!");
static_assert(offsetof(UHWBTTask_ChooseAndFireAbility, MinCCDurationToTriggerAbilities) == 0x000088, "Member 'UHWBTTask_ChooseAndFireAbility::MinCCDurationToTriggerAbilities' has a wrong offset!");
static_assert(offsetof(UHWBTTask_ChooseAndFireAbility, TraceChannel) == 0x00008C, "Member 'UHWBTTask_ChooseAndFireAbility::TraceChannel' has a wrong offset!");
static_assert(offsetof(UHWBTTask_ChooseAndFireAbility, EscapeDot) == 0x000090, "Member 'UHWBTTask_ChooseAndFireAbility::EscapeDot' has a wrong offset!");

// Class Hemingway.HWFamiliarConfigSettings
// 0x00D8 (0x0100 - 0x0028)
class UHWFamiliarConfigSettings final : public UObject
{
public:
	class UHWCharacterItem*                       CharacterItem;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFamiliarLevelType                            LevelType;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritOffhandLevels;                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritOwnerVelocity;                             // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOwnerCollisions;                            // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyFamiliarOnOwnerDeath;                      // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistFamiliarTillNextCast;                      // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxActiveFamiliars;                                // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lifetime;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Lives;                                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWFamiliarAttribute>           AttributesToInherit;                               // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EquipmentSlotTypesToInherit;                       // 0x0060(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FHWInventorySlot>               EquipmentSlotsToInherit;                           // 0x0080(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UHWEquipmentItem*, struct FScalableFloat> DesiredEquipmentLevels;                     // 0x0090(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FHWAbilitySet_GameplayEffect>   EffectsToApplyPreFamiliarInitialize;               // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWAbilitySet_GameplayEffect>   EffectsToApplyPostFamiliarInitialize;              // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWFamiliarConfigSettings">();
	}
	static class UHWFamiliarConfigSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWFamiliarConfigSettings>();
	}
};
static_assert(alignof(UHWFamiliarConfigSettings) == 0x000008, "Wrong alignment on UHWFamiliarConfigSettings");
static_assert(sizeof(UHWFamiliarConfigSettings) == 0x000100, "Wrong size on UHWFamiliarConfigSettings");
static_assert(offsetof(UHWFamiliarConfigSettings, CharacterItem) == 0x000028, "Member 'UHWFamiliarConfigSettings::CharacterItem' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, LevelType) == 0x000030, "Member 'UHWFamiliarConfigSettings::LevelType' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, Level) == 0x000034, "Member 'UHWFamiliarConfigSettings::Level' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, bInheritOffhandLevels) == 0x000038, "Member 'UHWFamiliarConfigSettings::bInheritOffhandLevels' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, bInheritOwnerVelocity) == 0x000039, "Member 'UHWFamiliarConfigSettings::bInheritOwnerVelocity' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, bIgnoreOwnerCollisions) == 0x00003A, "Member 'UHWFamiliarConfigSettings::bIgnoreOwnerCollisions' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, bDestroyFamiliarOnOwnerDeath) == 0x00003B, "Member 'UHWFamiliarConfigSettings::bDestroyFamiliarOnOwnerDeath' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, bPersistFamiliarTillNextCast) == 0x00003C, "Member 'UHWFamiliarConfigSettings::bPersistFamiliarTillNextCast' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, MaxActiveFamiliars) == 0x000040, "Member 'UHWFamiliarConfigSettings::MaxActiveFamiliars' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, Lifetime) == 0x000044, "Member 'UHWFamiliarConfigSettings::Lifetime' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, Lives) == 0x000048, "Member 'UHWFamiliarConfigSettings::Lives' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, AttributesToInherit) == 0x000050, "Member 'UHWFamiliarConfigSettings::AttributesToInherit' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, EquipmentSlotTypesToInherit) == 0x000060, "Member 'UHWFamiliarConfigSettings::EquipmentSlotTypesToInherit' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, EquipmentSlotsToInherit) == 0x000080, "Member 'UHWFamiliarConfigSettings::EquipmentSlotsToInherit' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, DesiredEquipmentLevels) == 0x000090, "Member 'UHWFamiliarConfigSettings::DesiredEquipmentLevels' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, EffectsToApplyPreFamiliarInitialize) == 0x0000E0, "Member 'UHWFamiliarConfigSettings::EffectsToApplyPreFamiliarInitialize' has a wrong offset!");
static_assert(offsetof(UHWFamiliarConfigSettings, EffectsToApplyPostFamiliarInitialize) == 0x0000F0, "Member 'UHWFamiliarConfigSettings::EffectsToApplyPostFamiliarInitialize' has a wrong offset!");

// Class Hemingway.HWBTTask_FindBestCombatPosition
// 0x00E8 (0x0198 - 0x00B0)
class UHWBTTask_FindBestCombatPosition final : public UBTTask_MoveTo
{
public:
	class UHWVectorFieldFollowCalc*               MeleeIdealAttackHeuristic;                         // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWVectorFieldFollowCalc*               RangedIdealAttackHeuristic;                        // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWVectorFieldFollowCalc*               RangedIdealAttackHeuristicVsJungle;                // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWFindCombatPositionEffector          EnemyMeleeAttackHeuristic;                         // 0x00C8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHWFindCombatPositionEffector          EnemyRangedAttackHeuristic;                        // 0x00D8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHWFindCombatPositionEffector          EnemyMinionAvoidanceHeuristic;                     // 0x00E8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHWFindCombatPositionEffector          AllySquadAvoidanceHeuristic;                       // 0x00F8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxThreatHostileTime;                              // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyMinionAvoidanceMinDot;                        // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTargetDistanceForCombatPositioning;             // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NavigationAimPointDistance;                        // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinInputSize;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinNewAimLocationDistance;                         // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSquadDistance;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AllySquadMaxFormationDistance;                     // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AllySquadSideDistance;                             // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AllySquadFwdDistance;                              // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinSquadAvoidCount;                                // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableRandomStrafing;                             // 0x0134(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomStrafingGodThreatDistance;                   // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomStrafeFrequencyMin;                          // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomStrafeFrequencyMax;                          // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomStrafeMinFacingDot;                          // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomStrafeMeleePercentage;                       // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinStrafeInterval;                                 // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxStrafeInterval;                                 // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToggleStrafeDirectionEveryInterval;               // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinStrafeStrength;                                 // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxStrafeStrength;                                 // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0xC];                                      // 0x0160(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDrawNavigationAimPoints;                     // 0x016C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16D[0x2B];                                     // 0x016D(0x002B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_FindBestCombatPosition">();
	}
	static class UHWBTTask_FindBestCombatPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_FindBestCombatPosition>();
	}
};
static_assert(alignof(UHWBTTask_FindBestCombatPosition) == 0x000008, "Wrong alignment on UHWBTTask_FindBestCombatPosition");
static_assert(sizeof(UHWBTTask_FindBestCombatPosition) == 0x000198, "Wrong size on UHWBTTask_FindBestCombatPosition");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MeleeIdealAttackHeuristic) == 0x0000B0, "Member 'UHWBTTask_FindBestCombatPosition::MeleeIdealAttackHeuristic' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, RangedIdealAttackHeuristic) == 0x0000B8, "Member 'UHWBTTask_FindBestCombatPosition::RangedIdealAttackHeuristic' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, RangedIdealAttackHeuristicVsJungle) == 0x0000C0, "Member 'UHWBTTask_FindBestCombatPosition::RangedIdealAttackHeuristicVsJungle' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, EnemyMeleeAttackHeuristic) == 0x0000C8, "Member 'UHWBTTask_FindBestCombatPosition::EnemyMeleeAttackHeuristic' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, EnemyRangedAttackHeuristic) == 0x0000D8, "Member 'UHWBTTask_FindBestCombatPosition::EnemyRangedAttackHeuristic' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, EnemyMinionAvoidanceHeuristic) == 0x0000E8, "Member 'UHWBTTask_FindBestCombatPosition::EnemyMinionAvoidanceHeuristic' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, AllySquadAvoidanceHeuristic) == 0x0000F8, "Member 'UHWBTTask_FindBestCombatPosition::AllySquadAvoidanceHeuristic' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MaxThreatHostileTime) == 0x000108, "Member 'UHWBTTask_FindBestCombatPosition::MaxThreatHostileTime' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, EnemyMinionAvoidanceMinDot) == 0x00010C, "Member 'UHWBTTask_FindBestCombatPosition::EnemyMinionAvoidanceMinDot' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MaxTargetDistanceForCombatPositioning) == 0x000110, "Member 'UHWBTTask_FindBestCombatPosition::MaxTargetDistanceForCombatPositioning' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, NavigationAimPointDistance) == 0x000114, "Member 'UHWBTTask_FindBestCombatPosition::NavigationAimPointDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MinInputSize) == 0x000118, "Member 'UHWBTTask_FindBestCombatPosition::MinInputSize' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MinNewAimLocationDistance) == 0x00011C, "Member 'UHWBTTask_FindBestCombatPosition::MinNewAimLocationDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MaxSquadDistance) == 0x000120, "Member 'UHWBTTask_FindBestCombatPosition::MaxSquadDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, AllySquadMaxFormationDistance) == 0x000124, "Member 'UHWBTTask_FindBestCombatPosition::AllySquadMaxFormationDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, AllySquadSideDistance) == 0x000128, "Member 'UHWBTTask_FindBestCombatPosition::AllySquadSideDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, AllySquadFwdDistance) == 0x00012C, "Member 'UHWBTTask_FindBestCombatPosition::AllySquadFwdDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MinSquadAvoidCount) == 0x000130, "Member 'UHWBTTask_FindBestCombatPosition::MinSquadAvoidCount' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, bEnableRandomStrafing) == 0x000134, "Member 'UHWBTTask_FindBestCombatPosition::bEnableRandomStrafing' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, RandomStrafingGodThreatDistance) == 0x000138, "Member 'UHWBTTask_FindBestCombatPosition::RandomStrafingGodThreatDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, RandomStrafeFrequencyMin) == 0x00013C, "Member 'UHWBTTask_FindBestCombatPosition::RandomStrafeFrequencyMin' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, RandomStrafeFrequencyMax) == 0x000140, "Member 'UHWBTTask_FindBestCombatPosition::RandomStrafeFrequencyMax' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, RandomStrafeMinFacingDot) == 0x000144, "Member 'UHWBTTask_FindBestCombatPosition::RandomStrafeMinFacingDot' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, RandomStrafeMeleePercentage) == 0x000148, "Member 'UHWBTTask_FindBestCombatPosition::RandomStrafeMeleePercentage' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MinStrafeInterval) == 0x00014C, "Member 'UHWBTTask_FindBestCombatPosition::MinStrafeInterval' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MaxStrafeInterval) == 0x000150, "Member 'UHWBTTask_FindBestCombatPosition::MaxStrafeInterval' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, bToggleStrafeDirectionEveryInterval) == 0x000154, "Member 'UHWBTTask_FindBestCombatPosition::bToggleStrafeDirectionEveryInterval' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MinStrafeStrength) == 0x000158, "Member 'UHWBTTask_FindBestCombatPosition::MinStrafeStrength' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, MaxStrafeStrength) == 0x00015C, "Member 'UHWBTTask_FindBestCombatPosition::MaxStrafeStrength' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FindBestCombatPosition, bDebugDrawNavigationAimPoints) == 0x00016C, "Member 'UHWBTTask_FindBestCombatPosition::bDebugDrawNavigationAimPoints' has a wrong offset!");

// Class Hemingway.HWBTTask_FireAbility
// 0x0018 (0x0088 - 0x0070)
class UHWBTTask_FireAbility final : public UBTTaskNode
{
public:
	struct FGameplayTag                           EquipmentSlotTag;                                  // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotId;                                            // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Input;                                             // 0x007C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_FireAbility">();
	}
	static class UHWBTTask_FireAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_FireAbility>();
	}
};
static_assert(alignof(UHWBTTask_FireAbility) == 0x000008, "Wrong alignment on UHWBTTask_FireAbility");
static_assert(sizeof(UHWBTTask_FireAbility) == 0x000088, "Wrong size on UHWBTTask_FireAbility");
static_assert(offsetof(UHWBTTask_FireAbility, EquipmentSlotTag) == 0x000070, "Member 'UHWBTTask_FireAbility::EquipmentSlotTag' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FireAbility, SlotId) == 0x000078, "Member 'UHWBTTask_FireAbility::SlotId' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FireAbility, Input) == 0x00007C, "Member 'UHWBTTask_FireAbility::Input' has a wrong offset!");

// Class Hemingway.HWWidgetComponent
// 0x0020 (0x0710 - 0x06F0)
class UHWWidgetComponent final : public UWidgetComponent
{
public:
	uint8                                         AxisToClamp;                                       // 0x06E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E9[0x7];                                      // 0x06E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               ClampMargin;                                       // 0x06F0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetClampAxes(uint8 InAxisToClamp);

	bool ShouldClampAxes(EHWClampAxis Axis) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWWidgetComponent">();
	}
	static class UHWWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWWidgetComponent>();
	}
};
static_assert(alignof(UHWWidgetComponent) == 0x000010, "Wrong alignment on UHWWidgetComponent");
static_assert(sizeof(UHWWidgetComponent) == 0x000710, "Wrong size on UHWWidgetComponent");
static_assert(offsetof(UHWWidgetComponent, AxisToClamp) == 0x0006E8, "Member 'UHWWidgetComponent::AxisToClamp' has a wrong offset!");
static_assert(offsetof(UHWWidgetComponent, ClampMargin) == 0x0006F0, "Member 'UHWWidgetComponent::ClampMargin' has a wrong offset!");

// Class Hemingway.HWBTTask_FireAbilityBlackboard
// 0x0000 (0x0070 - 0x0070)
class UHWBTTask_FireAbilityBlackboard final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_FireAbilityBlackboard">();
	}
	static class UHWBTTask_FireAbilityBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_FireAbilityBlackboard>();
	}
};
static_assert(alignof(UHWBTTask_FireAbilityBlackboard) == 0x000008, "Wrong alignment on UHWBTTask_FireAbilityBlackboard");
static_assert(sizeof(UHWBTTask_FireAbilityBlackboard) == 0x000070, "Wrong size on UHWBTTask_FireAbilityBlackboard");

// Class Hemingway.HWBTTask_FollowVectorField
// 0x0090 (0x0100 - 0x0070)
class UHWBTTask_FollowVectorField final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 WaypointKey;                                       // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         WaypointWeight;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 CloseEnoughDistanceKey;                            // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 CurrentTargetKey;                                  // 0x00C8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class UHWVectorFieldFollowCalc*               ObstacleAvoidanceVectorFieldCalculation;           // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleLookAheadDistance;                         // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleAvoidanceWeight;                           // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_FollowVectorField">();
	}
	static class UHWBTTask_FollowVectorField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_FollowVectorField>();
	}
};
static_assert(alignof(UHWBTTask_FollowVectorField) == 0x000008, "Wrong alignment on UHWBTTask_FollowVectorField");
static_assert(sizeof(UHWBTTask_FollowVectorField) == 0x000100, "Wrong size on UHWBTTask_FollowVectorField");
static_assert(offsetof(UHWBTTask_FollowVectorField, WaypointKey) == 0x000070, "Member 'UHWBTTask_FollowVectorField::WaypointKey' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FollowVectorField, WaypointWeight) == 0x000098, "Member 'UHWBTTask_FollowVectorField::WaypointWeight' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FollowVectorField, CloseEnoughDistanceKey) == 0x0000A0, "Member 'UHWBTTask_FollowVectorField::CloseEnoughDistanceKey' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FollowVectorField, CurrentTargetKey) == 0x0000C8, "Member 'UHWBTTask_FollowVectorField::CurrentTargetKey' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FollowVectorField, ObstacleAvoidanceVectorFieldCalculation) == 0x0000F0, "Member 'UHWBTTask_FollowVectorField::ObstacleAvoidanceVectorFieldCalculation' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FollowVectorField, ObstacleLookAheadDistance) == 0x0000F8, "Member 'UHWBTTask_FollowVectorField::ObstacleLookAheadDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_FollowVectorField, ObstacleAvoidanceWeight) == 0x0000FC, "Member 'UHWBTTask_FollowVectorField::ObstacleAvoidanceWeight' has a wrong offset!");

// Class Hemingway.HWGameplayCueNotify_BurstLatent
// 0x0008 (0x06E0 - 0x06D8)
class AHWGameplayCueNotify_BurstLatent : public AGameplayCueNotify_BurstLatent
{
public:
	EHWFriendlyEnemyReferenceActorChoice          FriendlyEnemyReferenceActorChoice;                 // 0x06D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldVisibilityComponentControlCue;              // 0x06D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6DA[0x6];                                      // 0x06DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_BurstLatent">();
	}
	static class AHWGameplayCueNotify_BurstLatent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameplayCueNotify_BurstLatent>();
	}
};
static_assert(alignof(AHWGameplayCueNotify_BurstLatent) == 0x000008, "Wrong alignment on AHWGameplayCueNotify_BurstLatent");
static_assert(sizeof(AHWGameplayCueNotify_BurstLatent) == 0x0006E0, "Wrong size on AHWGameplayCueNotify_BurstLatent");
static_assert(offsetof(AHWGameplayCueNotify_BurstLatent, FriendlyEnemyReferenceActorChoice) == 0x0006D8, "Member 'AHWGameplayCueNotify_BurstLatent::FriendlyEnemyReferenceActorChoice' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_BurstLatent, bShouldVisibilityComponentControlCue) == 0x0006D9, "Member 'AHWGameplayCueNotify_BurstLatent::bShouldVisibilityComponentControlCue' has a wrong offset!");

// Class Hemingway.HWBTTask_MoveToMinionCombatFormationLocation
// 0x00B0 (0x0160 - 0x00B0)
class UHWBTTask_MoveToMinionCombatFormationLocation final : public UBTTask_MoveTo
{
public:
	struct FBlackboardKeySelector                 RangeKey;                                          // 0x00B0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	int32                                         ExpectedFormationSize;                             // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFormationPointDistance;                         // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplySquadAvoidance;                              // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAvoidanceDistance;                              // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinAvoidanceAngleInDeg;                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDrawFormationLocations;                      // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED[0x73];                                      // 0x00ED(0x0073)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_MoveToMinionCombatFormationLocation">();
	}
	static class UHWBTTask_MoveToMinionCombatFormationLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_MoveToMinionCombatFormationLocation>();
	}
};
static_assert(alignof(UHWBTTask_MoveToMinionCombatFormationLocation) == 0x000008, "Wrong alignment on UHWBTTask_MoveToMinionCombatFormationLocation");
static_assert(sizeof(UHWBTTask_MoveToMinionCombatFormationLocation) == 0x000160, "Wrong size on UHWBTTask_MoveToMinionCombatFormationLocation");
static_assert(offsetof(UHWBTTask_MoveToMinionCombatFormationLocation, RangeKey) == 0x0000B0, "Member 'UHWBTTask_MoveToMinionCombatFormationLocation::RangeKey' has a wrong offset!");
static_assert(offsetof(UHWBTTask_MoveToMinionCombatFormationLocation, ExpectedFormationSize) == 0x0000D8, "Member 'UHWBTTask_MoveToMinionCombatFormationLocation::ExpectedFormationSize' has a wrong offset!");
static_assert(offsetof(UHWBTTask_MoveToMinionCombatFormationLocation, MaxFormationPointDistance) == 0x0000DC, "Member 'UHWBTTask_MoveToMinionCombatFormationLocation::MaxFormationPointDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_MoveToMinionCombatFormationLocation, bApplySquadAvoidance) == 0x0000E0, "Member 'UHWBTTask_MoveToMinionCombatFormationLocation::bApplySquadAvoidance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_MoveToMinionCombatFormationLocation, MaxAvoidanceDistance) == 0x0000E4, "Member 'UHWBTTask_MoveToMinionCombatFormationLocation::MaxAvoidanceDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_MoveToMinionCombatFormationLocation, MinAvoidanceAngleInDeg) == 0x0000E8, "Member 'UHWBTTask_MoveToMinionCombatFormationLocation::MinAvoidanceAngleInDeg' has a wrong offset!");
static_assert(offsetof(UHWBTTask_MoveToMinionCombatFormationLocation, bDebugDrawFormationLocations) == 0x0000EC, "Member 'UHWBTTask_MoveToMinionCombatFormationLocation::bDebugDrawFormationLocations' has a wrong offset!");

// Class Hemingway.HWBTTask_MoveToSpreadLocation
// 0x0000 (0x00B0 - 0x00B0)
class UHWBTTask_MoveToSpreadLocation final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_MoveToSpreadLocation">();
	}
	static class UHWBTTask_MoveToSpreadLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_MoveToSpreadLocation>();
	}
};
static_assert(alignof(UHWBTTask_MoveToSpreadLocation) == 0x000008, "Wrong alignment on UHWBTTask_MoveToSpreadLocation");
static_assert(sizeof(UHWBTTask_MoveToSpreadLocation) == 0x0000B0, "Wrong size on UHWBTTask_MoveToSpreadLocation");

// Class Hemingway.HWItemStoreManagerComponent
// 0x0078 (0x0118 - 0x00A0)
class UHWItemStoreManagerComponent final : public UHWActorComponent
{
public:
	TMulticastInlineDelegate<void(const class UHWEquipmentItem* SelectedEquipmentItem, const struct FGameplayTag& EquipmentSlot, const class UHWEquipmentItem* DefaultSelectedItem)> OnEquipmentItemSelected; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UHWEquipmentItem* TrackedEquipmentItem, const struct FGameplayTag& EquipmentSlot)> OnEquipmentItemTracked; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UHWEquipmentItem* SelectedComponentItem)> OnItemComponentSelected; // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UHWEquipmentItem* HoveredEquipmentItem, const struct FGameplayTag& EquipmentSlot)> OnGamepadHoverEquipmentItem; // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UHWEquipmentItem* HoveredEquipmentItem)> OnGamepadHoverBuildsIntoEquipmentItem; // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UHWEquipmentItem* ClickedEquipmentItem, const struct FGameplayTag& EquipmentSlot)> OnGamepadClickEquipmentItem; // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnGamepadSimulateBack;                             // 0x0100(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UHWEquipmentItem>        SelectedEquipmentItem;                             // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GamepadClickEquipmentItem(const class UHWEquipmentItem* EquipmentItem, const struct FGameplayTag& SlotTag);
	void GamepadHoverBuildsIntoEquipmentItem(const class UHWEquipmentItem* EquipmentItem);
	void GamepadHoverEquipmentItem(const class UHWEquipmentItem* EquipmentItem, const struct FGameplayTag& SlotTag);
	void SelectComponentItem(const class UHWEquipmentItem* EquipmentItem);
	void SelectEquipmentItem(const class UHWEquipmentItem* EquipmentItem, const struct FGameplayTag& SlotTag, const class UHWEquipmentItem* DefaultSelectedItem);
	void SellEquipmentInstance(class UHWEquipmentInstance* EquipmentInstance);
	void TrackEquipmentItem(const class UHWEquipmentItem* EquipmentItem, const struct FGameplayTag& SlotTag);

	struct FHWCanCraftInfo GetCanCraftInfoFromEquipmentItem(const class UHWEquipmentItem* EquipmentItem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWItemStoreManagerComponent">();
	}
	static class UHWItemStoreManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWItemStoreManagerComponent>();
	}
};
static_assert(alignof(UHWItemStoreManagerComponent) == 0x000008, "Wrong alignment on UHWItemStoreManagerComponent");
static_assert(sizeof(UHWItemStoreManagerComponent) == 0x000118, "Wrong size on UHWItemStoreManagerComponent");
static_assert(offsetof(UHWItemStoreManagerComponent, OnEquipmentItemSelected) == 0x0000A0, "Member 'UHWItemStoreManagerComponent::OnEquipmentItemSelected' has a wrong offset!");
static_assert(offsetof(UHWItemStoreManagerComponent, OnEquipmentItemTracked) == 0x0000B0, "Member 'UHWItemStoreManagerComponent::OnEquipmentItemTracked' has a wrong offset!");
static_assert(offsetof(UHWItemStoreManagerComponent, OnItemComponentSelected) == 0x0000C0, "Member 'UHWItemStoreManagerComponent::OnItemComponentSelected' has a wrong offset!");
static_assert(offsetof(UHWItemStoreManagerComponent, OnGamepadHoverEquipmentItem) == 0x0000D0, "Member 'UHWItemStoreManagerComponent::OnGamepadHoverEquipmentItem' has a wrong offset!");
static_assert(offsetof(UHWItemStoreManagerComponent, OnGamepadHoverBuildsIntoEquipmentItem) == 0x0000E0, "Member 'UHWItemStoreManagerComponent::OnGamepadHoverBuildsIntoEquipmentItem' has a wrong offset!");
static_assert(offsetof(UHWItemStoreManagerComponent, OnGamepadClickEquipmentItem) == 0x0000F0, "Member 'UHWItemStoreManagerComponent::OnGamepadClickEquipmentItem' has a wrong offset!");
static_assert(offsetof(UHWItemStoreManagerComponent, OnGamepadSimulateBack) == 0x000100, "Member 'UHWItemStoreManagerComponent::OnGamepadSimulateBack' has a wrong offset!");
static_assert(offsetof(UHWItemStoreManagerComponent, SelectedEquipmentItem) == 0x000110, "Member 'UHWItemStoreManagerComponent::SelectedEquipmentItem' has a wrong offset!");

// Class Hemingway.HWBTTask_Move_TargetLane
// 0x0008 (0x00B8 - 0x00B0)
class UHWBTTask_Move_TargetLane : public UBTTask_MoveTo
{
public:
	bool                                          bShowDebug;                                        // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_Move_TargetLane">();
	}
	static class UHWBTTask_Move_TargetLane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_Move_TargetLane>();
	}
};
static_assert(alignof(UHWBTTask_Move_TargetLane) == 0x000008, "Wrong alignment on UHWBTTask_Move_TargetLane");
static_assert(sizeof(UHWBTTask_Move_TargetLane) == 0x0000B8, "Wrong size on UHWBTTask_Move_TargetLane");
static_assert(offsetof(UHWBTTask_Move_TargetLane, bShowDebug) == 0x0000B0, "Member 'UHWBTTask_Move_TargetLane::bShowDebug' has a wrong offset!");

// Class Hemingway.HWBTTask_PushLane
// 0x0040 (0x00F0 - 0x00B0)
class UHWBTTask_PushLane final : public UBTTask_MoveTo
{
public:
	struct FBlackboardKeySelector                 MoveLocationKey;                                   // 0x00B0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           StructureImmunityTag;                              // 0x00D8(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeWaitBehindDistance;                           // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RangedWaitBehindDistance;                          // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTargetChangeDistance;                           // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_PushLane">();
	}
	static class UHWBTTask_PushLane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_PushLane>();
	}
};
static_assert(alignof(UHWBTTask_PushLane) == 0x000008, "Wrong alignment on UHWBTTask_PushLane");
static_assert(sizeof(UHWBTTask_PushLane) == 0x0000F0, "Wrong size on UHWBTTask_PushLane");
static_assert(offsetof(UHWBTTask_PushLane, MoveLocationKey) == 0x0000B0, "Member 'UHWBTTask_PushLane::MoveLocationKey' has a wrong offset!");
static_assert(offsetof(UHWBTTask_PushLane, StructureImmunityTag) == 0x0000D8, "Member 'UHWBTTask_PushLane::StructureImmunityTag' has a wrong offset!");
static_assert(offsetof(UHWBTTask_PushLane, MeleeWaitBehindDistance) == 0x0000E0, "Member 'UHWBTTask_PushLane::MeleeWaitBehindDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_PushLane, RangedWaitBehindDistance) == 0x0000E4, "Member 'UHWBTTask_PushLane::RangedWaitBehindDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_PushLane, MaxTargetChangeDistance) == 0x0000E8, "Member 'UHWBTTask_PushLane::MaxTargetChangeDistance' has a wrong offset!");

// Class Hemingway.HWAnnouncementComponent
// 0x0020 (0x00C0 - 0x00A0)
class UHWAnnouncementComponent final : public UHWActorComponent
{
public:
	TMulticastInlineDelegate<void(class AHWGameStatsTracker* GameStatsTracker, const struct FGameplayTag& AnnouncementTag)> OnNewAnnouncementAdded; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHWAnnouncementRecord>          AnnouncementRecords;                               // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddNewAnnouncement(const struct FGameplayTag& AnnouncementTag);
	void MulticastSendAnnouncementToClient(const struct FGameplayTag& AnnouncementTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnnouncementComponent">();
	}
	static class UHWAnnouncementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnnouncementComponent>();
	}
};
static_assert(alignof(UHWAnnouncementComponent) == 0x000008, "Wrong alignment on UHWAnnouncementComponent");
static_assert(sizeof(UHWAnnouncementComponent) == 0x0000C0, "Wrong size on UHWAnnouncementComponent");
static_assert(offsetof(UHWAnnouncementComponent, OnNewAnnouncementAdded) == 0x0000A0, "Member 'UHWAnnouncementComponent::OnNewAnnouncementAdded' has a wrong offset!");
static_assert(offsetof(UHWAnnouncementComponent, AnnouncementRecords) == 0x0000B0, "Member 'UHWAnnouncementComponent::AnnouncementRecords' has a wrong offset!");

// Class Hemingway.HWBTTask_SelectAttackTarget
// 0x00D0 (0x0140 - 0x0070)
class UHWBTTask_SelectAttackTarget final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 TargetContainerKey;                                // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 HostileTargetKey;                                  // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 HostileDecayTimerKey;                              // 0x00C0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAITargetPriorityInfo>          TargetPriorities;                                  // 0x00E8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x00F8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGenericTeamId>                 IgnoreTeamsList;                                   // 0x0118(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         HostileTargetDecayTime;                            // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PerceptionConeAngleInDegrees;                      // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          CollectedActorsList;                               // 0x0130(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_SelectAttackTarget">();
	}
	static class UHWBTTask_SelectAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_SelectAttackTarget>();
	}
};
static_assert(alignof(UHWBTTask_SelectAttackTarget) == 0x000008, "Wrong alignment on UHWBTTask_SelectAttackTarget");
static_assert(sizeof(UHWBTTask_SelectAttackTarget) == 0x000140, "Wrong size on UHWBTTask_SelectAttackTarget");
static_assert(offsetof(UHWBTTask_SelectAttackTarget, TargetContainerKey) == 0x000070, "Member 'UHWBTTask_SelectAttackTarget::TargetContainerKey' has a wrong offset!");
static_assert(offsetof(UHWBTTask_SelectAttackTarget, HostileTargetKey) == 0x000098, "Member 'UHWBTTask_SelectAttackTarget::HostileTargetKey' has a wrong offset!");
static_assert(offsetof(UHWBTTask_SelectAttackTarget, HostileDecayTimerKey) == 0x0000C0, "Member 'UHWBTTask_SelectAttackTarget::HostileDecayTimerKey' has a wrong offset!");
static_assert(offsetof(UHWBTTask_SelectAttackTarget, TargetPriorities) == 0x0000E8, "Member 'UHWBTTask_SelectAttackTarget::TargetPriorities' has a wrong offset!");
static_assert(offsetof(UHWBTTask_SelectAttackTarget, tagsToIgnore) == 0x0000F8, "Member 'UHWBTTask_SelectAttackTarget::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(UHWBTTask_SelectAttackTarget, IgnoreTeamsList) == 0x000118, "Member 'UHWBTTask_SelectAttackTarget::IgnoreTeamsList' has a wrong offset!");
static_assert(offsetof(UHWBTTask_SelectAttackTarget, HostileTargetDecayTime) == 0x000128, "Member 'UHWBTTask_SelectAttackTarget::HostileTargetDecayTime' has a wrong offset!");
static_assert(offsetof(UHWBTTask_SelectAttackTarget, PerceptionConeAngleInDegrees) == 0x00012C, "Member 'UHWBTTask_SelectAttackTarget::PerceptionConeAngleInDegrees' has a wrong offset!");
static_assert(offsetof(UHWBTTask_SelectAttackTarget, CollectedActorsList) == 0x000130, "Member 'UHWBTTask_SelectAttackTarget::CollectedActorsList' has a wrong offset!");

// Class Hemingway.HWBTTask_Squad_LaneMovement
// 0x0018 (0x00D0 - 0x00B8)
class UHWBTTask_Squad_LaneMovement final : public UHWBTTask_Move_TargetLane
{
public:
	float                                         FormationThreshold;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SquadCatchupDistance;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CatchupSpeedRatio;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FormationUpdateTime;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationRate;                                      // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrailDistance;                                     // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_Squad_LaneMovement">();
	}
	static class UHWBTTask_Squad_LaneMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_Squad_LaneMovement>();
	}
};
static_assert(alignof(UHWBTTask_Squad_LaneMovement) == 0x000008, "Wrong alignment on UHWBTTask_Squad_LaneMovement");
static_assert(sizeof(UHWBTTask_Squad_LaneMovement) == 0x0000D0, "Wrong size on UHWBTTask_Squad_LaneMovement");
static_assert(offsetof(UHWBTTask_Squad_LaneMovement, FormationThreshold) == 0x0000B8, "Member 'UHWBTTask_Squad_LaneMovement::FormationThreshold' has a wrong offset!");
static_assert(offsetof(UHWBTTask_Squad_LaneMovement, SquadCatchupDistance) == 0x0000BC, "Member 'UHWBTTask_Squad_LaneMovement::SquadCatchupDistance' has a wrong offset!");
static_assert(offsetof(UHWBTTask_Squad_LaneMovement, CatchupSpeedRatio) == 0x0000C0, "Member 'UHWBTTask_Squad_LaneMovement::CatchupSpeedRatio' has a wrong offset!");
static_assert(offsetof(UHWBTTask_Squad_LaneMovement, FormationUpdateTime) == 0x0000C4, "Member 'UHWBTTask_Squad_LaneMovement::FormationUpdateTime' has a wrong offset!");
static_assert(offsetof(UHWBTTask_Squad_LaneMovement, RotationRate) == 0x0000C8, "Member 'UHWBTTask_Squad_LaneMovement::RotationRate' has a wrong offset!");
static_assert(offsetof(UHWBTTask_Squad_LaneMovement, TrailDistance) == 0x0000CC, "Member 'UHWBTTask_Squad_LaneMovement::TrailDistance' has a wrong offset!");

// Class Hemingway.HWBTTask_WaitForAbilityEnd
// 0x0028 (0x0098 - 0x0070)
class UHWBTTask_WaitForAbilityEnd final : public UBTTaskNode
{
public:
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bExactMatch;                                       // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBTTask_WaitForAbilityEnd">();
	}
	static class UHWBTTask_WaitForAbilityEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBTTask_WaitForAbilityEnd>();
	}
};
static_assert(alignof(UHWBTTask_WaitForAbilityEnd) == 0x000008, "Wrong alignment on UHWBTTask_WaitForAbilityEnd");
static_assert(sizeof(UHWBTTask_WaitForAbilityEnd) == 0x000098, "Wrong size on UHWBTTask_WaitForAbilityEnd");
static_assert(offsetof(UHWBTTask_WaitForAbilityEnd, AbilityTags) == 0x000070, "Member 'UHWBTTask_WaitForAbilityEnd::AbilityTags' has a wrong offset!");
static_assert(offsetof(UHWBTTask_WaitForAbilityEnd, bExactMatch) == 0x000090, "Member 'UHWBTTask_WaitForAbilityEnd::bExactMatch' has a wrong offset!");

// Class Hemingway.HWFXCurveComponent
// 0x00A8 (0x0148 - 0x00A0)
class UHWFXCurveComponent final : public UHWActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlaying;                                          // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReversing;                                        // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLooping;                                          // 0x00AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB[0x1];                                       // 0x00AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentTime;                                       // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNormalisedCurves;                                 // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x70];                                      // 0x00B8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               PostProcessMID;                                    // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PostProcessMIDParent;                              // 0x0130(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ParticleSystem;                                    // 0x0138(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleSystemParent;                              // 0x0140(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Play();
	void ResetTime();
	void Reverse();
	void Stop();
	void UpdateColorTrack(class FName TrackName, const struct FLinearColor& TrackValue);
	void UpdateScalarTrack(class FName TrackName, float TrackValue);

	class AHWCharacter_Base* GetCharacterOwner() const;
	class FName GetFxID() const;
	class UMaterialInstanceDynamic* GetPostProcessMID() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWFXCurveComponent">();
	}
	static class UHWFXCurveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWFXCurveComponent>();
	}
};
static_assert(alignof(UHWFXCurveComponent) == 0x000008, "Wrong alignment on UHWFXCurveComponent");
static_assert(sizeof(UHWFXCurveComponent) == 0x000148, "Wrong size on UHWFXCurveComponent");
static_assert(offsetof(UHWFXCurveComponent, bPlaying) == 0x0000A8, "Member 'UHWFXCurveComponent::bPlaying' has a wrong offset!");
static_assert(offsetof(UHWFXCurveComponent, bReversing) == 0x0000A9, "Member 'UHWFXCurveComponent::bReversing' has a wrong offset!");
static_assert(offsetof(UHWFXCurveComponent, bLooping) == 0x0000AA, "Member 'UHWFXCurveComponent::bLooping' has a wrong offset!");
static_assert(offsetof(UHWFXCurveComponent, CurrentTime) == 0x0000AC, "Member 'UHWFXCurveComponent::CurrentTime' has a wrong offset!");
static_assert(offsetof(UHWFXCurveComponent, bNormalisedCurves) == 0x0000B0, "Member 'UHWFXCurveComponent::bNormalisedCurves' has a wrong offset!");
static_assert(offsetof(UHWFXCurveComponent, PlayRate) == 0x0000B4, "Member 'UHWFXCurveComponent::PlayRate' has a wrong offset!");
static_assert(offsetof(UHWFXCurveComponent, PostProcessMID) == 0x000128, "Member 'UHWFXCurveComponent::PostProcessMID' has a wrong offset!");
static_assert(offsetof(UHWFXCurveComponent, PostProcessMIDParent) == 0x000130, "Member 'UHWFXCurveComponent::PostProcessMIDParent' has a wrong offset!");
static_assert(offsetof(UHWFXCurveComponent, ParticleSystem) == 0x000138, "Member 'UHWFXCurveComponent::ParticleSystem' has a wrong offset!");
static_assert(offsetof(UHWFXCurveComponent, ParticleSystemParent) == 0x000140, "Member 'UHWFXCurveComponent::ParticleSystemParent' has a wrong offset!");

// Class Hemingway.HWSplineComponent
// 0x0020 (0x0690 - 0x0670)
class UHWSplineComponent : public USplineComponent
{
public:
	bool                                          bShouldReplicateSplinePoints;                      // 0x0670(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_671[0x7];                                      // 0x0671(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSplinePoint>                   ReplicatedSplinePoints;                            // 0x0678(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawDebugSpline(const float splineDistanceSteps, const struct FLinearColor& Color, bool bPersistentLines, float Lifetime, uint8 DepthPriority, float Thickness);
	void OnRep_ReplicatedSplinePoints();
	void SetShouldReplicateSplinePoints(const bool bShouldReplicate);

	bool HasAuthority() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSplineComponent">();
	}
	static class UHWSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSplineComponent>();
	}
};
static_assert(alignof(UHWSplineComponent) == 0x000010, "Wrong alignment on UHWSplineComponent");
static_assert(sizeof(UHWSplineComponent) == 0x000690, "Wrong size on UHWSplineComponent");
static_assert(offsetof(UHWSplineComponent, bShouldReplicateSplinePoints) == 0x000670, "Member 'UHWSplineComponent::bShouldReplicateSplinePoints' has a wrong offset!");
static_assert(offsetof(UHWSplineComponent, ReplicatedSplinePoints) == 0x000678, "Member 'UHWSplineComponent::ReplicatedSplinePoints' has a wrong offset!");

// Class Hemingway.HWSplinePathMeshManagerComponent
// 0x02A0 (0x0930 - 0x0690)
class UHWSplinePathMeshManagerComponent final : public UHWSplineComponent
{
public:
	TMulticastInlineDelegate<void(class UHWSplinePathMeshManagerComponent* SplineManager, const struct FGameplayAbilityTargetDataHandle& OverlappedTarget, const struct FHWSplineOverlapInfo& TrailOverlapInfo)> OnSplineBeginOverlapDelegate; // 0x0690(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWSplinePathMeshManagerComponent* SplineManager, const struct FGameplayAbilityTargetDataHandle& OverlappedTarget)> OnSplineEndOverlapDelegate; // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FHWSplineOverlapInfo> SplineOverlaps;                                 // 0x06B0(0x0050)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FBodyInstance                          SplineCollision;                                   // 0x0700(0x0190)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTargetDataFilterHandle        AcceptableCollisionFilterHandle;                   // 0x0890(0x0010)(Net, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const int32 SegmentNum, const struct FVector& StartLocation, const struct FVector& EndLocation)> OnCreateSplineMeshSegment; // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           SplineSegments;                                    // 0x08B0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<EHWSplineSegmentMeshType, struct FAssetRequestKey> SplineSegmentMeshAssets;                 // 0x08C0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EHWSplineMeshPlacementBehavior                MeshPlacementBehavior;                             // 0x0910(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_911[0x3];                                      // 0x0911(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlacementDistanceInterval;                         // 0x0914(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapThreshold;                                  // 0x0918(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESplineMeshAxis                               SplineMeshForwardAxis;                             // 0x091C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAdjustMeshesToBottomOfActor;                      // 0x091D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateMeshPlacementsOnBeginPlay;                  // 0x091E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91F[0x1];                                      // 0x091F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EnemyMaterialParamName;                            // 0x0920(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_928[0x8];                                      // 0x0928(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplySplineEndCap();
	void DestroyAllSplineMeshSegments();
	void HandleOnSplineSegmentBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleOnSplineSegmentEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetAcceptableCollisionFilter(const struct FGameplayTargetDataFilterHandle& collisionFilter);
	void SetCollisionProfile(const class FName& ProfileName);

	float GetOverlapDistance() const;
	float GetPlacementDistanceInterval() const;
	class UStaticMesh* GetSkinnedSplineMesh(EHWSplineSegmentMeshType MeshType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSplinePathMeshManagerComponent">();
	}
	static class UHWSplinePathMeshManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSplinePathMeshManagerComponent>();
	}
};
static_assert(alignof(UHWSplinePathMeshManagerComponent) == 0x000010, "Wrong alignment on UHWSplinePathMeshManagerComponent");
static_assert(sizeof(UHWSplinePathMeshManagerComponent) == 0x000930, "Wrong size on UHWSplinePathMeshManagerComponent");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, OnSplineBeginOverlapDelegate) == 0x000690, "Member 'UHWSplinePathMeshManagerComponent::OnSplineBeginOverlapDelegate' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, OnSplineEndOverlapDelegate) == 0x0006A0, "Member 'UHWSplinePathMeshManagerComponent::OnSplineEndOverlapDelegate' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, SplineOverlaps) == 0x0006B0, "Member 'UHWSplinePathMeshManagerComponent::SplineOverlaps' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, SplineCollision) == 0x000700, "Member 'UHWSplinePathMeshManagerComponent::SplineCollision' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, AcceptableCollisionFilterHandle) == 0x000890, "Member 'UHWSplinePathMeshManagerComponent::AcceptableCollisionFilterHandle' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, OnCreateSplineMeshSegment) == 0x0008A0, "Member 'UHWSplinePathMeshManagerComponent::OnCreateSplineMeshSegment' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, SplineSegments) == 0x0008B0, "Member 'UHWSplinePathMeshManagerComponent::SplineSegments' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, SplineSegmentMeshAssets) == 0x0008C0, "Member 'UHWSplinePathMeshManagerComponent::SplineSegmentMeshAssets' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, MeshPlacementBehavior) == 0x000910, "Member 'UHWSplinePathMeshManagerComponent::MeshPlacementBehavior' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, PlacementDistanceInterval) == 0x000914, "Member 'UHWSplinePathMeshManagerComponent::PlacementDistanceInterval' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, OverlapThreshold) == 0x000918, "Member 'UHWSplinePathMeshManagerComponent::OverlapThreshold' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, SplineMeshForwardAxis) == 0x00091C, "Member 'UHWSplinePathMeshManagerComponent::SplineMeshForwardAxis' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, bAdjustMeshesToBottomOfActor) == 0x00091D, "Member 'UHWSplinePathMeshManagerComponent::bAdjustMeshesToBottomOfActor' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, bUpdateMeshPlacementsOnBeginPlay) == 0x00091E, "Member 'UHWSplinePathMeshManagerComponent::bUpdateMeshPlacementsOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UHWSplinePathMeshManagerComponent, EnemyMaterialParamName) == 0x000920, "Member 'UHWSplinePathMeshManagerComponent::EnemyMaterialParamName' has a wrong offset!");

// Class Hemingway.HWCharacterCapsuleComponent
// 0x0000 (0x05A0 - 0x05A0)
class UHWCharacterCapsuleComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacterCapsuleComponent">();
	}
	static class UHWCharacterCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCharacterCapsuleComponent>();
	}
};
static_assert(alignof(UHWCharacterCapsuleComponent) == 0x000010, "Wrong alignment on UHWCharacterCapsuleComponent");
static_assert(sizeof(UHWCharacterCapsuleComponent) == 0x0005A0, "Wrong size on UHWCharacterCapsuleComponent");

// Class Hemingway.HWInteractableComponent
// 0x0180 (0x0220 - 0x00A0)
class UHWInteractableComponent : public UHWActorComponent
{
public:
	bool                                          bEnabled;                                          // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    InteractFieldCollisionComponent;                   // 0x00A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* OverlappedActor)> OnInteractFieldBeginOverlapDelegate; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* OverlappedActor)> OnInteractFieldEndOverlapDelegate; // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsAllowedToInteract;                           // 0x00D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWInteractableComponent* Interactable, class AActor* InteractInstigator)> OnInteractionStartedDelegate; // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWInteractableComponent* Interactable, class AActor* InteractInstigator)> OnInteractionCompletedDelegate; // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWInteractableComponent* Interactable, class AActor* InteractInstigator)> OnInteractionCancelledDelegate; // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInteractabilityMemberReplicated;                 // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         LOSAngleReguiredToInteract;                        // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumTimesAllowedToInteract;                         // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumTimesAllowedToInteractPerInstigator;            // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AActor>, int32>     InstigatorInteractCounterMap;                      // 0x0130(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         InteractionTime;                                   // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxOngoingInteractionsAllowed;                     // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelOngoingInteractionsOnInteractionComplete;   // 0x0188(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentInteractionCount;                           // 0x018C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         OngoingInteractors;                                // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowMovementDuringInteract;                      // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bShow)>    OnUpdateInteractionPromptVisuals;                  // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsCurrentlyTargeted)> OnUpdateIsCurrentlyTargeted;           // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidgetComponent*                       InteractionPromptWidget;                           // 0x01C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowPromptWhileInteractionOngoing;                // 0x01D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanUseTargetingBasedDisplay;                      // 0x01D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCurrentlyTargeted;                              // 0x01D2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D3[0x1];                                      // 0x01D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowDebugDrawing;                                 // 0x01D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FText& NewInteractPromptText)> OnInteractPromptTextUpdated; // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InteractPromptDisplayInfoTag;                      // 0x01E8(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InteractPromptOffset;                              // 0x01F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   InteractPromptText;                                // 0x0208(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void EndInteraction(class AActor* InteractInstigator, const bool bWasCancelled);
	void OnInteractFieldBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnInteractFieldEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_bEnabled();
	void OnRep_OngoingInteractors();
	void SetEnabled(const bool bShouldEnable);
	void SetInteractPromptText(const class FText& NewPromptText);
	void StartInteraction(class AActor* InteractInstigator);
	void UpdatePromptVisuals(const bool bShowPrompt);

	bool CanEverInteractWith(const class AActor* InteractInstigator) const;
	bool CanInteractWith(const class AActor* InteractInstigator) const;
	bool CanMoveDuringInteraction() const;
	float GetInteractionTime() const;
	struct FGameplayTag GetInteractMontageTag() const;
	const class FText GetInteractPromptText() const;
	bool IsActorInteractionInProgress(const class AActor* ActorToCheck) const;
	bool IsEnabled() const;
	bool IsInInteractionField(const class AActor* ActorToCheck) const;
	bool IsInteractionAllowed() const;
	bool IsInteractionInProgress() const;
	bool ShouldShowPromptVisualsOnClient() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInteractableComponent">();
	}
	static class UHWInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInteractableComponent>();
	}
};
static_assert(alignof(UHWInteractableComponent) == 0x000008, "Wrong alignment on UHWInteractableComponent");
static_assert(sizeof(UHWInteractableComponent) == 0x000220, "Wrong size on UHWInteractableComponent");
static_assert(offsetof(UHWInteractableComponent, bEnabled) == 0x0000A0, "Member 'UHWInteractableComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, InteractFieldCollisionComponent) == 0x0000A8, "Member 'UHWInteractableComponent::InteractFieldCollisionComponent' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, OnInteractFieldBeginOverlapDelegate) == 0x0000B0, "Member 'UHWInteractableComponent::OnInteractFieldBeginOverlapDelegate' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, OnInteractFieldEndOverlapDelegate) == 0x0000C0, "Member 'UHWInteractableComponent::OnInteractFieldEndOverlapDelegate' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, ActorsAllowedToInteract) == 0x0000D0, "Member 'UHWInteractableComponent::ActorsAllowedToInteract' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, OnInteractionStartedDelegate) == 0x0000E0, "Member 'UHWInteractableComponent::OnInteractionStartedDelegate' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, OnInteractionCompletedDelegate) == 0x0000F0, "Member 'UHWInteractableComponent::OnInteractionCompletedDelegate' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, OnInteractionCancelledDelegate) == 0x000100, "Member 'UHWInteractableComponent::OnInteractionCancelledDelegate' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, OnInteractabilityMemberReplicated) == 0x000110, "Member 'UHWInteractableComponent::OnInteractabilityMemberReplicated' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, LOSAngleReguiredToInteract) == 0x000120, "Member 'UHWInteractableComponent::LOSAngleReguiredToInteract' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, NumTimesAllowedToInteract) == 0x000124, "Member 'UHWInteractableComponent::NumTimesAllowedToInteract' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, NumTimesAllowedToInteractPerInstigator) == 0x000128, "Member 'UHWInteractableComponent::NumTimesAllowedToInteractPerInstigator' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, InstigatorInteractCounterMap) == 0x000130, "Member 'UHWInteractableComponent::InstigatorInteractCounterMap' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, InteractionTime) == 0x000180, "Member 'UHWInteractableComponent::InteractionTime' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, MaxOngoingInteractionsAllowed) == 0x000184, "Member 'UHWInteractableComponent::MaxOngoingInteractionsAllowed' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, bCancelOngoingInteractionsOnInteractionComplete) == 0x000188, "Member 'UHWInteractableComponent::bCancelOngoingInteractionsOnInteractionComplete' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, CurrentInteractionCount) == 0x00018C, "Member 'UHWInteractableComponent::CurrentInteractionCount' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, OngoingInteractors) == 0x000190, "Member 'UHWInteractableComponent::OngoingInteractors' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, bAllowMovementDuringInteract) == 0x0001A0, "Member 'UHWInteractableComponent::bAllowMovementDuringInteract' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, OnUpdateInteractionPromptVisuals) == 0x0001A8, "Member 'UHWInteractableComponent::OnUpdateInteractionPromptVisuals' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, OnUpdateIsCurrentlyTargeted) == 0x0001B8, "Member 'UHWInteractableComponent::OnUpdateIsCurrentlyTargeted' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, InteractionPromptWidget) == 0x0001C8, "Member 'UHWInteractableComponent::InteractionPromptWidget' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, bShowPromptWhileInteractionOngoing) == 0x0001D0, "Member 'UHWInteractableComponent::bShowPromptWhileInteractionOngoing' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, bCanUseTargetingBasedDisplay) == 0x0001D1, "Member 'UHWInteractableComponent::bCanUseTargetingBasedDisplay' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, bIsCurrentlyTargeted) == 0x0001D2, "Member 'UHWInteractableComponent::bIsCurrentlyTargeted' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, bShowDebugDrawing) == 0x0001D4, "Member 'UHWInteractableComponent::bShowDebugDrawing' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, OnInteractPromptTextUpdated) == 0x0001D8, "Member 'UHWInteractableComponent::OnInteractPromptTextUpdated' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, InteractPromptDisplayInfoTag) == 0x0001E8, "Member 'UHWInteractableComponent::InteractPromptDisplayInfoTag' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, InteractPromptOffset) == 0x0001F0, "Member 'UHWInteractableComponent::InteractPromptOffset' has a wrong offset!");
static_assert(offsetof(UHWInteractableComponent, InteractPromptText) == 0x000208, "Member 'UHWInteractableComponent::InteractPromptText' has a wrong offset!");

// Class Hemingway.HWCharacter_Amaterasu
// 0x0010 (0x1450 - 0x1440)
class AHWCharacter_Amaterasu final : public AHWCharacter_Smite_God
{
public:
	bool                                          bMirrorGlowEnabled;                                // 0x1440(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1441[0xF];                                     // 0x1441(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_MirrorGlow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Amaterasu">();
	}
	static class AHWCharacter_Amaterasu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Amaterasu>();
	}
};
static_assert(alignof(AHWCharacter_Amaterasu) == 0x000010, "Wrong alignment on AHWCharacter_Amaterasu");
static_assert(sizeof(AHWCharacter_Amaterasu) == 0x001450, "Wrong size on AHWCharacter_Amaterasu");
static_assert(offsetof(AHWCharacter_Amaterasu, bMirrorGlowEnabled) == 0x001440, "Member 'AHWCharacter_Amaterasu::bMirrorGlowEnabled' has a wrong offset!");

// Class Hemingway.HWCharacter_AnimInstNPC
// 0x0010 (0x05E0 - 0x05D0)
class UHWCharacter_AnimInstNPC : public UHWCharacter_AnimInstBase
{
public:
	int32                                         PostureRND;                                        // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWNpcPostureState                            NpcPostureState;                                   // 0x05CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPostureDefault;                                   // 0x05CD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPostureAware;                                     // 0x05CE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPostureResting;                                   // 0x05CF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseBlendSpaceHit;                                 // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0xF];                                      // 0x05D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNpcASCUpdated(class UHWAbilitySystemComponent* UpdatedASC, class UHWAbilitySystemComponent* OldAbilitySystem);
	void OnStatusNpcTagsUpdated(const struct FGameplayTag& UpdatedStatusTag, int32 NewStackCount);
	void PlayHitReaction(const struct FVector& RelativeDirection, float HealthPercent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_AnimInstNPC">();
	}
	static class UHWCharacter_AnimInstNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCharacter_AnimInstNPC>();
	}
};
static_assert(alignof(UHWCharacter_AnimInstNPC) == 0x000010, "Wrong alignment on UHWCharacter_AnimInstNPC");
static_assert(sizeof(UHWCharacter_AnimInstNPC) == 0x0005E0, "Wrong size on UHWCharacter_AnimInstNPC");
static_assert(offsetof(UHWCharacter_AnimInstNPC, PostureRND) == 0x0005C8, "Member 'UHWCharacter_AnimInstNPC::PostureRND' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstNPC, NpcPostureState) == 0x0005CC, "Member 'UHWCharacter_AnimInstNPC::NpcPostureState' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstNPC, bPostureDefault) == 0x0005CD, "Member 'UHWCharacter_AnimInstNPC::bPostureDefault' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstNPC, bPostureAware) == 0x0005CE, "Member 'UHWCharacter_AnimInstNPC::bPostureAware' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstNPC, bPostureResting) == 0x0005CF, "Member 'UHWCharacter_AnimInstNPC::bPostureResting' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstNPC, bUseBlendSpaceHit) == 0x0005D0, "Member 'UHWCharacter_AnimInstNPC::bUseBlendSpaceHit' has a wrong offset!");

// Class Hemingway.HWGameplayMovementComponent
// 0x00A0 (0x0300 - 0x0260)
class UHWGameplayMovementComponent : public UProjectileMovementComponent
{
public:
	float                                         DistanceTraveled;                                  // 0x0258(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUse2DForDistanceTravelled;                        // 0x025C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTrackGroundDistanceSeparately;                    // 0x025D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E[0x2];                                      // 0x025E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundDistanceTraveled;                            // 0x0260(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMovingOnGround;                                   // 0x0264(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConstrainPitch;                                   // 0x0265(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConstrainYaw;                                     // 0x0266(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConstrainRoll;                                    // 0x0267(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSpeed;                                          // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceCurrentSpeedToMatchMaxSpeed;                 // 0x026C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitSpeedBasedOnDistanceTraveled;                // 0x026D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26E[0x2];                                      // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceSpeedLossTrigger;                          // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedLossPerMeter;                                 // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitSpeedBasedOnNumberOfBounces;                 // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedLossPerBounceMult;                            // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyBounceSpeedLoss;                             // 0x0280(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedDampening;                                    // 0x0284(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumVerticalBounces;                             // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MinVelocityZToContinueVerticallyBouncing;          // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumBounces;                                        // 0x0298(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumVerticalBounces;                                // 0x0299(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A[0x6];                                      // 0x029A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BouncinessCoefficients;                            // 0x02A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BouncinessUpwardVelocityMax;                       // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTrackFloorHitsAsBounces;                          // 0x02BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BD[0x3];                                      // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWGameplayMovementComponent* MovementComponent)> OnMaxRangeReachedDelegate; // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bStopMovementAtMaxRange;                           // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWGameplayMovementComponent* MovementComponent)> OnLobTravelTimeCompleteDel; // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EHWProjectileLobType                          LobType;                                           // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetermineLobAirTimeBasedOnSpeedAndDistance;       // 0x02EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LobFixedTravelTime;                                // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LobAngle;                                          // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinAirTime;                                        // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConstrainRotation(struct FRotator* RotationToConstrain);
	void OnLobTravelTimeComplete();
	void ResetDistanceTraveled();

	float GetDistanceTraveled() const;
	EHWProjectileLobType GetLobType() const;
	float GetRange() const;
	bool HasReachedMaxRange(const float Distance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayMovementComponent">();
	}
	static class UHWGameplayMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayMovementComponent>();
	}
};
static_assert(alignof(UHWGameplayMovementComponent) == 0x000010, "Wrong alignment on UHWGameplayMovementComponent");
static_assert(sizeof(UHWGameplayMovementComponent) == 0x000300, "Wrong size on UHWGameplayMovementComponent");
static_assert(offsetof(UHWGameplayMovementComponent, DistanceTraveled) == 0x000258, "Member 'UHWGameplayMovementComponent::DistanceTraveled' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bUse2DForDistanceTravelled) == 0x00025C, "Member 'UHWGameplayMovementComponent::bUse2DForDistanceTravelled' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bTrackGroundDistanceSeparately) == 0x00025D, "Member 'UHWGameplayMovementComponent::bTrackGroundDistanceSeparately' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, GroundDistanceTraveled) == 0x000260, "Member 'UHWGameplayMovementComponent::GroundDistanceTraveled' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bMovingOnGround) == 0x000264, "Member 'UHWGameplayMovementComponent::bMovingOnGround' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bConstrainPitch) == 0x000265, "Member 'UHWGameplayMovementComponent::bConstrainPitch' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bConstrainYaw) == 0x000266, "Member 'UHWGameplayMovementComponent::bConstrainYaw' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bConstrainRoll) == 0x000267, "Member 'UHWGameplayMovementComponent::bConstrainRoll' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, MinSpeed) == 0x000268, "Member 'UHWGameplayMovementComponent::MinSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bForceCurrentSpeedToMatchMaxSpeed) == 0x00026C, "Member 'UHWGameplayMovementComponent::bForceCurrentSpeedToMatchMaxSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bLimitSpeedBasedOnDistanceTraveled) == 0x00026D, "Member 'UHWGameplayMovementComponent::bLimitSpeedBasedOnDistanceTraveled' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, DistanceSpeedLossTrigger) == 0x000270, "Member 'UHWGameplayMovementComponent::DistanceSpeedLossTrigger' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, SpeedLossPerMeter) == 0x000274, "Member 'UHWGameplayMovementComponent::SpeedLossPerMeter' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bLimitSpeedBasedOnNumberOfBounces) == 0x000278, "Member 'UHWGameplayMovementComponent::bLimitSpeedBasedOnNumberOfBounces' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, SpeedLossPerBounceMult) == 0x00027C, "Member 'UHWGameplayMovementComponent::SpeedLossPerBounceMult' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bApplyBounceSpeedLoss) == 0x000280, "Member 'UHWGameplayMovementComponent::bApplyBounceSpeedLoss' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, SpeedDampening) == 0x000284, "Member 'UHWGameplayMovementComponent::SpeedDampening' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, MaxNumVerticalBounces) == 0x000288, "Member 'UHWGameplayMovementComponent::MaxNumVerticalBounces' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, MinVelocityZToContinueVerticallyBouncing) == 0x000290, "Member 'UHWGameplayMovementComponent::MinVelocityZToContinueVerticallyBouncing' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, NumBounces) == 0x000298, "Member 'UHWGameplayMovementComponent::NumBounces' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, NumVerticalBounces) == 0x000299, "Member 'UHWGameplayMovementComponent::NumVerticalBounces' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, BouncinessCoefficients) == 0x0002A0, "Member 'UHWGameplayMovementComponent::BouncinessCoefficients' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, BouncinessUpwardVelocityMax) == 0x0002B8, "Member 'UHWGameplayMovementComponent::BouncinessUpwardVelocityMax' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bTrackFloorHitsAsBounces) == 0x0002BC, "Member 'UHWGameplayMovementComponent::bTrackFloorHitsAsBounces' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, OnMaxRangeReachedDelegate) == 0x0002C0, "Member 'UHWGameplayMovementComponent::OnMaxRangeReachedDelegate' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bStopMovementAtMaxRange) == 0x0002D0, "Member 'UHWGameplayMovementComponent::bStopMovementAtMaxRange' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, OnLobTravelTimeCompleteDel) == 0x0002D8, "Member 'UHWGameplayMovementComponent::OnLobTravelTimeCompleteDel' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, LobType) == 0x0002E8, "Member 'UHWGameplayMovementComponent::LobType' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, bDetermineLobAirTimeBasedOnSpeedAndDistance) == 0x0002EC, "Member 'UHWGameplayMovementComponent::bDetermineLobAirTimeBasedOnSpeedAndDistance' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, LobFixedTravelTime) == 0x0002F0, "Member 'UHWGameplayMovementComponent::LobFixedTravelTime' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, LobAngle) == 0x0002F4, "Member 'UHWGameplayMovementComponent::LobAngle' has a wrong offset!");
static_assert(offsetof(UHWGameplayMovementComponent, MinAirTime) == 0x0002F8, "Member 'UHWGameplayMovementComponent::MinAirTime' has a wrong offset!");

// Class Hemingway.HWDisplayInfoComponent
// 0x0198 (0x0238 - 0x00A0)
class UHWDisplayInfoComponent : public UHWActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DisplayOnSpawnTags;                                // 0x00B8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ExcludedTags;                                      // 0x00D8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWPendingDisplayInfoRequest>   PendingDisplayInfoRequests;                        // 0x00F8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FHWDisplayInfoConfig> DefaultDisplayConfigs;                    // 0x0108(0x0050)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x50];                                     // 0x0158(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWDisplayInfoComponent* DisplayInfoComponent)> OnDisplayInfoComponentFlagsUpdated; // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x2];                                      // 0x01B8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideWorldOverlayAnchor;                       // 0x01BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BB[0x5];                                      // 0x01BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldOverlayAnchor;                                // 0x01C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideFloatingTextAnchor;                       // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FloatingTextAnchor;                                // 0x01E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FloatingTextAlignment;                             // 0x01F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FloatingTextOffset;                                // 0x0210(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHWWidgetComponent*>             WidgetComponents;                                  // 0x0228(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddDisplayInfo(const struct FGameplayTag& DisplayInfoTag, bool bApplyNextTick);
	void AddDisplayInfoFromConfig(const struct FGameplayTag& DisplayInfoTag, const struct FHWDisplayInfoConfig& Config, bool bApplyNextTick);
	void DisplayInfoResetRequested();
	class UHWWidgetComponent* GetInactiveWidgetComponent();
	void HandleCharacterAbilitySystemUpdated(class UHWAbilitySystemComponent* AbilitySystem, class UHWAbilitySystemComponent* OldAbilitySystem);
	void HandleCharacterTeamChanged(class AHWCharacterAbilitySystemActor* OwningAbilitySystemActor, class AHWTeamState* InTeamState);
	void HandleLocalFoWVisibilityUpdated(class UHWVisibilityComponent* VisibilityComponent);
	void HandleLocalMinimapVisibilityUpdated(class UHWVisibilityComponent* VisibilityComponent);
	void HandleLocalOwnerVisibilityUpdated(class UHWVisibilityComponent* VisibilityComponent);
	void HandleOnPawnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void HandleUIRelevanceChange();
	void HandleVisibilityComponentUpdated(class UHWVisibilityComponent* VisibilityComponent);
	void HideActiveDisplayInfo(const struct FGameplayTag& DisplayInfoTag);
	void HideActiveDisplayInfos();
	void RegisterDisplayInfoConfig(const struct FGameplayTag& DisplayInfoTag, const struct FHWDisplayInfoConfig& NewConfig);
	void RemoveDisplayInfo(const struct FGameplayTag& DisplayInfoTag, bool bApplyNextTick);
	void RemoveDisplayInfoConfig(const struct FGameplayTag& DisplayInfoTag);
	void RemoveDisplayInfos();
	void SetFlag(EHWDisplayInfoComponentFlag flag, bool bActivate);
	void ShowActiveDisplayInfo(const struct FGameplayTag& DisplayInfoTag);
	void ShowActiveDisplayInfos();
	void ToggleFlag(EHWDisplayInfoComponentFlag flag);
	void UpdateDisplayInfoLifespan(const struct FGameplayTag& DisplayInfoTag, float LifeSpan);

	struct FHWDisplayInfoConfig GetDisplayInfoConfig(const struct FGameplayTag& DisplayInfoTag) const;
	const struct FVector GetFloatingTextAlignment() const;
	const struct FVector GetFloatingTextAnchor() const;
	const struct FVector GetFloatingTextOffset() const;
	const struct FVector GetWorldOverlayAnchor() const;
	bool HasFloatingTextAnchorOverride() const;
	bool HasWorldOverlayAnchorOverride() const;
	bool IsDisplayInfoActive(const struct FGameplayTag& DisplayInfoTag) const;
	bool IsFlagActive(EHWDisplayInfoComponentFlag flag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDisplayInfoComponent">();
	}
	static class UHWDisplayInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDisplayInfoComponent>();
	}
};
static_assert(alignof(UHWDisplayInfoComponent) == 0x000008, "Wrong alignment on UHWDisplayInfoComponent");
static_assert(sizeof(UHWDisplayInfoComponent) == 0x000238, "Wrong size on UHWDisplayInfoComponent");
static_assert(offsetof(UHWDisplayInfoComponent, DisplayOnSpawnTags) == 0x0000B8, "Member 'UHWDisplayInfoComponent::DisplayOnSpawnTags' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, ExcludedTags) == 0x0000D8, "Member 'UHWDisplayInfoComponent::ExcludedTags' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, PendingDisplayInfoRequests) == 0x0000F8, "Member 'UHWDisplayInfoComponent::PendingDisplayInfoRequests' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, DefaultDisplayConfigs) == 0x000108, "Member 'UHWDisplayInfoComponent::DefaultDisplayConfigs' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, OnDisplayInfoComponentFlagsUpdated) == 0x0001A8, "Member 'UHWDisplayInfoComponent::OnDisplayInfoComponentFlagsUpdated' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, bOverrideWorldOverlayAnchor) == 0x0001BA, "Member 'UHWDisplayInfoComponent::bOverrideWorldOverlayAnchor' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, WorldOverlayAnchor) == 0x0001C0, "Member 'UHWDisplayInfoComponent::WorldOverlayAnchor' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, bOverrideFloatingTextAnchor) == 0x0001D8, "Member 'UHWDisplayInfoComponent::bOverrideFloatingTextAnchor' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, FloatingTextAnchor) == 0x0001E0, "Member 'UHWDisplayInfoComponent::FloatingTextAnchor' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, FloatingTextAlignment) == 0x0001F8, "Member 'UHWDisplayInfoComponent::FloatingTextAlignment' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, FloatingTextOffset) == 0x000210, "Member 'UHWDisplayInfoComponent::FloatingTextOffset' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoComponent, WidgetComponents) == 0x000228, "Member 'UHWDisplayInfoComponent::WidgetComponents' has a wrong offset!");

// Class Hemingway.HWDisplayInfoJungleComponent
// 0x0020 (0x0258 - 0x0238)
class UHWDisplayInfoJungleComponent : public UHWDisplayInfoComponent
{
public:
	TMulticastInlineDelegate<void()>              OnCampDisplayInfoUpdated;                          // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CampTypeTag;                                       // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAwaitingRespawn;                                // 0x0250(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCampIsEmpty;                                      // 0x0251(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_252[0x6];                                      // 0x0252(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleFactoryMinimapStateUpdated(class AHWBotFactory* BotFactory);

	bool CanLocalTeamSeeRespawns() const;
	struct FGameplayTag GetCampTypeTag() const;
	bool GetRespawnTimeInfo(float* OutTotalRespawnTime, float* OutRemainingRespawnTime) const;
	bool IsCampActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDisplayInfoJungleComponent">();
	}
	static class UHWDisplayInfoJungleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDisplayInfoJungleComponent>();
	}
};
static_assert(alignof(UHWDisplayInfoJungleComponent) == 0x000008, "Wrong alignment on UHWDisplayInfoJungleComponent");
static_assert(sizeof(UHWDisplayInfoJungleComponent) == 0x000258, "Wrong size on UHWDisplayInfoJungleComponent");
static_assert(offsetof(UHWDisplayInfoJungleComponent, OnCampDisplayInfoUpdated) == 0x000238, "Member 'UHWDisplayInfoJungleComponent::OnCampDisplayInfoUpdated' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoJungleComponent, CampTypeTag) == 0x000248, "Member 'UHWDisplayInfoJungleComponent::CampTypeTag' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoJungleComponent, bIsAwaitingRespawn) == 0x000250, "Member 'UHWDisplayInfoJungleComponent::bIsAwaitingRespawn' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoJungleComponent, bCampIsEmpty) == 0x000251, "Member 'UHWDisplayInfoJungleComponent::bCampIsEmpty' has a wrong offset!");

// Class Hemingway.HWCharacter_Geb
// 0x0080 (0x14C0 - 0x1440)
class AHWCharacter_Geb final : public AHWCharacter_Smite_God
{
public:
	struct FVector                                BoulderMeshTranslationOffset;                      // 0x1440(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWBoulderState                               BoulderState;                                      // 0x1458(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1459[0x7];                                     // 0x1459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          BoulderMesh;                                       // 0x1460(0x0008)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 BoulderAnimInstanceClass;                          // 0x1468(0x0008)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BoulderMaterial;                                   // 0x1470(0x0008)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BoulderAssetKey;                                   // 0x1478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BoulderMaterialSkinningPrefix;                     // 0x1480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1488[0x8];                                     // 0x1488(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           BoulderMontage;                                    // 0x1490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EHWBoulderState BoulderEndReason)> OnBoulderVisualEnd;             // 0x1498(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A8[0x18];                                    // 0x14A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateBoulderFormVisuals();
	void AnimateBoulderOutro(bool isLeap);
	void DeactivateBoulderFormVisuals();
	void InitializeBoulderMesh();
	void OnRep_BoulderState();
	void SetBoulderState(const EHWBoulderState NewBoulderState);

	EHWBoulderState GetBoulderState() const;
	bool IsBoulderStateActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Geb">();
	}
	static class AHWCharacter_Geb* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Geb>();
	}
};
static_assert(alignof(AHWCharacter_Geb) == 0x000010, "Wrong alignment on AHWCharacter_Geb");
static_assert(sizeof(AHWCharacter_Geb) == 0x0014C0, "Wrong size on AHWCharacter_Geb");
static_assert(offsetof(AHWCharacter_Geb, BoulderMeshTranslationOffset) == 0x001440, "Member 'AHWCharacter_Geb::BoulderMeshTranslationOffset' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Geb, BoulderState) == 0x001458, "Member 'AHWCharacter_Geb::BoulderState' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Geb, BoulderMesh) == 0x001460, "Member 'AHWCharacter_Geb::BoulderMesh' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Geb, BoulderAnimInstanceClass) == 0x001468, "Member 'AHWCharacter_Geb::BoulderAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Geb, BoulderMaterial) == 0x001470, "Member 'AHWCharacter_Geb::BoulderMaterial' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Geb, BoulderAssetKey) == 0x001478, "Member 'AHWCharacter_Geb::BoulderAssetKey' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Geb, BoulderMaterialSkinningPrefix) == 0x001480, "Member 'AHWCharacter_Geb::BoulderMaterialSkinningPrefix' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Geb, BoulderMontage) == 0x001490, "Member 'AHWCharacter_Geb::BoulderMontage' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Geb, OnBoulderVisualEnd) == 0x001498, "Member 'AHWCharacter_Geb::OnBoulderVisualEnd' has a wrong offset!");

// Class Hemingway.HWAbilityTask_WaitAITargetChange
// 0x0018 (0x0098 - 0x0080)
class UHWAbilityTask_WaitAITargetChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const class AActor* NewTarget)> OnTargetChanged;                   // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_WaitAITargetChange* WaitForAITargetChange(class UGameplayAbility* OwningAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_WaitAITargetChange">();
	}
	static class UHWAbilityTask_WaitAITargetChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_WaitAITargetChange>();
	}
};
static_assert(alignof(UHWAbilityTask_WaitAITargetChange) == 0x000008, "Wrong alignment on UHWAbilityTask_WaitAITargetChange");
static_assert(sizeof(UHWAbilityTask_WaitAITargetChange) == 0x000098, "Wrong size on UHWAbilityTask_WaitAITargetChange");
static_assert(offsetof(UHWAbilityTask_WaitAITargetChange, OnTargetChanged) == 0x000080, "Member 'UHWAbilityTask_WaitAITargetChange::OnTargetChanged' has a wrong offset!");

// Class Hemingway.HWCharacter_Kali
// 0x0000 (0x1440 - 0x1440)
class AHWCharacter_Kali final : public AHWCharacter_Smite_God
{
public:
	class USplineComponent* GetBaseA02ProjectileSpline(int32 SplineIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Kali">();
	}
	static class AHWCharacter_Kali* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Kali>();
	}
};
static_assert(alignof(AHWCharacter_Kali) == 0x000010, "Wrong alignment on AHWCharacter_Kali");
static_assert(sizeof(AHWCharacter_Kali) == 0x001440, "Wrong size on AHWCharacter_Kali");

// Class Hemingway.HWCharacter_Mulan
// 0x0030 (0x1470 - 0x1440)
class AHWCharacter_Mulan final : public AHWCharacter_Smite_God
{
public:
	struct FHWMulanRopeTetherInfo                 RopeTetherInfo;                                    // 0x1440(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void AssignRopeTarget(bool bEnableTether, const class AActor* TetherTarget, const struct FVector& WallTetherLocation);
	void OnRep_RopeTetherInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Mulan">();
	}
	static class AHWCharacter_Mulan* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Mulan>();
	}
};
static_assert(alignof(AHWCharacter_Mulan) == 0x000010, "Wrong alignment on AHWCharacter_Mulan");
static_assert(sizeof(AHWCharacter_Mulan) == 0x001470, "Wrong size on AHWCharacter_Mulan");
static_assert(offsetof(AHWCharacter_Mulan, RopeTetherInfo) == 0x001440, "Member 'AHWCharacter_Mulan::RopeTetherInfo' has a wrong offset!");

// Class Hemingway.HWAbilityTask_WaitGameplayEffectApplied_Self
// 0x0418 (0x0498 - 0x0080)
class UHWAbilityTask_WaitGameplayEffectApplied_Self final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class UHWAbilityTask_WaitGameplayEffectApplied_Self* Task, class AActor* EffectSource, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle)> OnApplied; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ExternalOwnerASC;                                  // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x400];                                     // 0x0098(0x0400)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_WaitGameplayEffectApplied_Self* WaitForGameplayEffectAppliedToSelf(class UGameplayAbility* OwningAbility, const struct FGameplayTargetDataFilterHandle& EffectSourceFilter, const struct FGameplayTagRequirements& EffectSourceTagRequirements, const struct FGameplayTagRequirements& EffectTargetTagRequirements, const struct FGameplayTagRequirements& EffectRequirements, bool TriggerOnce, class AActor* OptionalExternalOwner, bool ListenForPeriodicEffect);
	static class UHWAbilityTask_WaitGameplayEffectApplied_Self* WaitGameplayEffectAppliedToSelf_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTargetDataFilterHandle& EffectSourceFilter, const struct FGameplayTagQuery& EffectSourceTagQuery, const struct FGameplayTagQuery& EffectTargetTagQuery, const struct FGameplayEffectQuery& EffectQuery, bool TriggerOnce, class AActor* OptionalExternalOwner, bool ListenForPeriodicEffect);

	void OnGameplayEffectApplied(class UAbilitySystemComponent* EffectSourceASC, const struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle);

	class AActor* GetTrackedActor() const;
	class UAbilitySystemComponent* GetTrackedASC() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_WaitGameplayEffectApplied_Self">();
	}
	static class UHWAbilityTask_WaitGameplayEffectApplied_Self* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_WaitGameplayEffectApplied_Self>();
	}
};
static_assert(alignof(UHWAbilityTask_WaitGameplayEffectApplied_Self) == 0x000008, "Wrong alignment on UHWAbilityTask_WaitGameplayEffectApplied_Self");
static_assert(sizeof(UHWAbilityTask_WaitGameplayEffectApplied_Self) == 0x000498, "Wrong size on UHWAbilityTask_WaitGameplayEffectApplied_Self");
static_assert(offsetof(UHWAbilityTask_WaitGameplayEffectApplied_Self, OnApplied) == 0x000080, "Member 'UHWAbilityTask_WaitGameplayEffectApplied_Self::OnApplied' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitGameplayEffectApplied_Self, ExternalOwnerASC) == 0x000090, "Member 'UHWAbilityTask_WaitGameplayEffectApplied_Self::ExternalOwnerASC' has a wrong offset!");

// Class Hemingway.HWCharacter_Thanatos
// 0x0010 (0x1450 - 0x1440)
class AHWCharacter_Thanatos final : public AHWCharacter_Smite_God
{
public:
	TWeakObjectPtr<class UHWAbility_Thanatos_A02_MarkedMovementSpeed> CachedActiveA02AbilityInstance; // 0x1440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1448[0x8];                                     // 0x1448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Thanatos">();
	}
	static class AHWCharacter_Thanatos* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Thanatos>();
	}
};
static_assert(alignof(AHWCharacter_Thanatos) == 0x000010, "Wrong alignment on AHWCharacter_Thanatos");
static_assert(sizeof(AHWCharacter_Thanatos) == 0x001450, "Wrong size on AHWCharacter_Thanatos");
static_assert(offsetof(AHWCharacter_Thanatos, CachedActiveA02AbilityInstance) == 0x001440, "Member 'AHWCharacter_Thanatos::CachedActiveA02AbilityInstance' has a wrong offset!");

// Class Hemingway.HWLobbyGodAnimationInfo
// 0x0198 (0x01C8 - 0x0030)
class UHWLobbyGodAnimationInfo final : public UDataAsset
{
public:
	class UCurveFloat*                            CurveBreath;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Breath_Rotation_Spine1;                            // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Breath_Rotation_Spine2;                            // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Breath_Rotation_Neck;                              // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Breath_Rotation_ClavicleL;                         // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Breath_Rotation_ClavicleR;                         // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Breath_Rotation_Head;                              // 0x00B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Breath_Scale_Spine1;                               // 0x00C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Breath_Scale_Spine2;                               // 0x00E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Breath_Scale_Neck;                                 // 0x00F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CurveBlink;                                        // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blink_MaxRot;                                      // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blink_Time_Min;                                    // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blink_Time_Max;                                    // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EyeDartEnabled;                                    // 0x0124(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        EyeDart_Targets_L;                                 // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        EyeDart_Targets_C;                                 // 0x0138(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        EyeDart_Targets_R;                                 // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         EyeDart_ClampEyeRotation;                          // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeDart_InterpTime;                                // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeDart_Aim_Left;                                  // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeDart_Aim_Right;                                 // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeDart_Time_Min;                                  // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeDart_Time_Max;                                  // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AimEnabled;                                        // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Aim_Time_Min;                                      // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_Time_Max;                                      // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_Yaw_Range_Min;                                 // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_Yaw_Range_Max;                                 // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_Pitch_Range_Min;                               // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_Pitch_Range_Max;                               // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_Yaw_Next_Min;                                  // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_Yaw_Next_Max;                                  // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_Pitch_Next_Min;                                // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_Pitch_Next_Max;                                // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Fidget_Enabled;                                    // 0x019C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Fidget_Count;                                      // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fidget_Time_Min;                                   // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fidget_Time_Max;                                   // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Variant_Enabled;                                   // 0x01AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Variant_TriggerTime_Min;                           // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Variant_TriggerTime_Max;                           // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Variant_Duration_Min;                              // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Variant_Duration_Max;                              // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootMotion_Alpha;                                  // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootMotion_PlayRate;                               // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLobbyGodAnimationInfo">();
	}
	static class UHWLobbyGodAnimationInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLobbyGodAnimationInfo>();
	}
};
static_assert(alignof(UHWLobbyGodAnimationInfo) == 0x000008, "Wrong alignment on UHWLobbyGodAnimationInfo");
static_assert(sizeof(UHWLobbyGodAnimationInfo) == 0x0001C8, "Wrong size on UHWLobbyGodAnimationInfo");
static_assert(offsetof(UHWLobbyGodAnimationInfo, CurveBreath) == 0x000030, "Member 'UHWLobbyGodAnimationInfo::CurveBreath' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Breath_Rotation_Spine1) == 0x000038, "Member 'UHWLobbyGodAnimationInfo::Breath_Rotation_Spine1' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Breath_Rotation_Spine2) == 0x000050, "Member 'UHWLobbyGodAnimationInfo::Breath_Rotation_Spine2' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Breath_Rotation_Neck) == 0x000068, "Member 'UHWLobbyGodAnimationInfo::Breath_Rotation_Neck' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Breath_Rotation_ClavicleL) == 0x000080, "Member 'UHWLobbyGodAnimationInfo::Breath_Rotation_ClavicleL' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Breath_Rotation_ClavicleR) == 0x000098, "Member 'UHWLobbyGodAnimationInfo::Breath_Rotation_ClavicleR' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Breath_Rotation_Head) == 0x0000B0, "Member 'UHWLobbyGodAnimationInfo::Breath_Rotation_Head' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Breath_Scale_Spine1) == 0x0000C8, "Member 'UHWLobbyGodAnimationInfo::Breath_Scale_Spine1' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Breath_Scale_Spine2) == 0x0000E0, "Member 'UHWLobbyGodAnimationInfo::Breath_Scale_Spine2' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Breath_Scale_Neck) == 0x0000F8, "Member 'UHWLobbyGodAnimationInfo::Breath_Scale_Neck' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, CurveBlink) == 0x000110, "Member 'UHWLobbyGodAnimationInfo::CurveBlink' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Blink_MaxRot) == 0x000118, "Member 'UHWLobbyGodAnimationInfo::Blink_MaxRot' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Blink_Time_Min) == 0x00011C, "Member 'UHWLobbyGodAnimationInfo::Blink_Time_Min' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Blink_Time_Max) == 0x000120, "Member 'UHWLobbyGodAnimationInfo::Blink_Time_Max' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, EyeDartEnabled) == 0x000124, "Member 'UHWLobbyGodAnimationInfo::EyeDartEnabled' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, EyeDart_Targets_L) == 0x000128, "Member 'UHWLobbyGodAnimationInfo::EyeDart_Targets_L' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, EyeDart_Targets_C) == 0x000138, "Member 'UHWLobbyGodAnimationInfo::EyeDart_Targets_C' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, EyeDart_Targets_R) == 0x000148, "Member 'UHWLobbyGodAnimationInfo::EyeDart_Targets_R' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, EyeDart_ClampEyeRotation) == 0x000158, "Member 'UHWLobbyGodAnimationInfo::EyeDart_ClampEyeRotation' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, EyeDart_InterpTime) == 0x00015C, "Member 'UHWLobbyGodAnimationInfo::EyeDart_InterpTime' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, EyeDart_Aim_Left) == 0x000160, "Member 'UHWLobbyGodAnimationInfo::EyeDart_Aim_Left' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, EyeDart_Aim_Right) == 0x000164, "Member 'UHWLobbyGodAnimationInfo::EyeDart_Aim_Right' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, EyeDart_Time_Min) == 0x000168, "Member 'UHWLobbyGodAnimationInfo::EyeDart_Time_Min' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, EyeDart_Time_Max) == 0x00016C, "Member 'UHWLobbyGodAnimationInfo::EyeDart_Time_Max' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, AimEnabled) == 0x000170, "Member 'UHWLobbyGodAnimationInfo::AimEnabled' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Aim_Time_Min) == 0x000174, "Member 'UHWLobbyGodAnimationInfo::Aim_Time_Min' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Aim_Time_Max) == 0x000178, "Member 'UHWLobbyGodAnimationInfo::Aim_Time_Max' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Aim_Yaw_Range_Min) == 0x00017C, "Member 'UHWLobbyGodAnimationInfo::Aim_Yaw_Range_Min' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Aim_Yaw_Range_Max) == 0x000180, "Member 'UHWLobbyGodAnimationInfo::Aim_Yaw_Range_Max' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Aim_Pitch_Range_Min) == 0x000184, "Member 'UHWLobbyGodAnimationInfo::Aim_Pitch_Range_Min' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Aim_Pitch_Range_Max) == 0x000188, "Member 'UHWLobbyGodAnimationInfo::Aim_Pitch_Range_Max' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Aim_Yaw_Next_Min) == 0x00018C, "Member 'UHWLobbyGodAnimationInfo::Aim_Yaw_Next_Min' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Aim_Yaw_Next_Max) == 0x000190, "Member 'UHWLobbyGodAnimationInfo::Aim_Yaw_Next_Max' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Aim_Pitch_Next_Min) == 0x000194, "Member 'UHWLobbyGodAnimationInfo::Aim_Pitch_Next_Min' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Aim_Pitch_Next_Max) == 0x000198, "Member 'UHWLobbyGodAnimationInfo::Aim_Pitch_Next_Max' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Fidget_Enabled) == 0x00019C, "Member 'UHWLobbyGodAnimationInfo::Fidget_Enabled' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Fidget_Count) == 0x0001A0, "Member 'UHWLobbyGodAnimationInfo::Fidget_Count' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Fidget_Time_Min) == 0x0001A4, "Member 'UHWLobbyGodAnimationInfo::Fidget_Time_Min' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Fidget_Time_Max) == 0x0001A8, "Member 'UHWLobbyGodAnimationInfo::Fidget_Time_Max' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Variant_Enabled) == 0x0001AC, "Member 'UHWLobbyGodAnimationInfo::Variant_Enabled' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Variant_TriggerTime_Min) == 0x0001B0, "Member 'UHWLobbyGodAnimationInfo::Variant_TriggerTime_Min' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Variant_TriggerTime_Max) == 0x0001B4, "Member 'UHWLobbyGodAnimationInfo::Variant_TriggerTime_Max' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Variant_Duration_Min) == 0x0001B8, "Member 'UHWLobbyGodAnimationInfo::Variant_Duration_Min' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, Variant_Duration_Max) == 0x0001BC, "Member 'UHWLobbyGodAnimationInfo::Variant_Duration_Max' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, RootMotion_Alpha) == 0x0001C0, "Member 'UHWLobbyGodAnimationInfo::RootMotion_Alpha' has a wrong offset!");
static_assert(offsetof(UHWLobbyGodAnimationInfo, RootMotion_PlayRate) == 0x0001C4, "Member 'UHWLobbyGodAnimationInfo::RootMotion_PlayRate' has a wrong offset!");

// Class Hemingway.HWCritProbability
// 0x0018 (0x0040 - 0x0028)
class UHWCritProbability final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCritProbability">();
	}
	static class UHWCritProbability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCritProbability>();
	}
};
static_assert(alignof(UHWCritProbability) == 0x000008, "Wrong alignment on UHWCritProbability");
static_assert(sizeof(UHWCritProbability) == 0x000040, "Wrong size on UHWCritProbability");

// Class Hemingway.HWAnimNotify_SkinnedMetaSound
// 0x0090 (0x00F0 - 0x0060)
class UHWAnimNotify_SkinnedMetaSound final : public UAnimNotify_SkinnedMetaSound
{
public:
	struct FGameplayTagRequirements               NotifyTagRequirements;                             // 0x0060(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         CooldownTime;                                      // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimNotify_SkinnedMetaSound">();
	}
	static class UHWAnimNotify_SkinnedMetaSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimNotify_SkinnedMetaSound>();
	}
};
static_assert(alignof(UHWAnimNotify_SkinnedMetaSound) == 0x000008, "Wrong alignment on UHWAnimNotify_SkinnedMetaSound");
static_assert(sizeof(UHWAnimNotify_SkinnedMetaSound) == 0x0000F0, "Wrong size on UHWAnimNotify_SkinnedMetaSound");
static_assert(offsetof(UHWAnimNotify_SkinnedMetaSound, NotifyTagRequirements) == 0x000060, "Member 'UHWAnimNotify_SkinnedMetaSound::NotifyTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWAnimNotify_SkinnedMetaSound, CooldownTime) == 0x0000E8, "Member 'UHWAnimNotify_SkinnedMetaSound::CooldownTime' has a wrong offset!");

// Class Hemingway.HWDeployable_Danzaburou_A01
// 0x0018 (0x04E0 - 0x04C8)
class AHWDeployable_Danzaburou_A01 final : public AHWDeployable
{
public:
	class UHWDeployableMovementComponent*         MovementComponent;                                 // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMarkedForExplosion;                             // 0x04D0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExploded;                                       // 0x04D1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D2[0x2];                                      // 0x04D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionTime;                                     // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ExplosionTimerHandler;                             // 0x04D8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActivateExplosionVisuals();
	void ActivateExplosionWarningVisuals();
	void OnMaxRangedReached(class UHWGameplayMovementComponent* GameplayMovementComponent);
	void OnRep_IsExploded();
	void OnRep_IsMarkedForExplosion();
	void StartExplosionTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Danzaburou_A01">();
	}
	static class AHWDeployable_Danzaburou_A01* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Danzaburou_A01>();
	}
};
static_assert(alignof(AHWDeployable_Danzaburou_A01) == 0x000008, "Wrong alignment on AHWDeployable_Danzaburou_A01");
static_assert(sizeof(AHWDeployable_Danzaburou_A01) == 0x0004E0, "Wrong size on AHWDeployable_Danzaburou_A01");
static_assert(offsetof(AHWDeployable_Danzaburou_A01, MovementComponent) == 0x0004C8, "Member 'AHWDeployable_Danzaburou_A01::MovementComponent' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A01, bIsMarkedForExplosion) == 0x0004D0, "Member 'AHWDeployable_Danzaburou_A01::bIsMarkedForExplosion' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A01, bIsExploded) == 0x0004D1, "Member 'AHWDeployable_Danzaburou_A01::bIsExploded' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A01, ExplosionTime) == 0x0004D4, "Member 'AHWDeployable_Danzaburou_A01::ExplosionTime' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A01, ExplosionTimerHandler) == 0x0004D8, "Member 'AHWDeployable_Danzaburou_A01::ExplosionTimerHandler' has a wrong offset!");

// Class Hemingway.HWEquipmentComponent
// 0x0010 (0x0038 - 0x0028)
class UHWEquipmentComponent : public UObject
{
public:
	class UHWEquipmentInstance*                   OwningEquipment;                                   // 0x0028(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SettingsIndex;                                     // 0x0030(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class UHWEquipmentComponentSettings* GetComponentSettings() const;
	struct FGameplayTag GetIdTag() const;
	class UHWAbilitySystemComponent* GetOwningAbilitySystem() const;
	class UHWEquipmentInstance* GetOwningEquipment() const;
	class UHWInventoryManagerComponent* GetOwningInventoryManagerComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponent">();
	}
	static class UHWEquipmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponent>();
	}
};
static_assert(alignof(UHWEquipmentComponent) == 0x000008, "Wrong alignment on UHWEquipmentComponent");
static_assert(sizeof(UHWEquipmentComponent) == 0x000038, "Wrong size on UHWEquipmentComponent");
static_assert(offsetof(UHWEquipmentComponent, OwningEquipment) == 0x000028, "Member 'UHWEquipmentComponent::OwningEquipment' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent, SettingsIndex) == 0x000030, "Member 'UHWEquipmentComponent::SettingsIndex' has a wrong offset!");

// Class Hemingway.HWEquipmentComponent_ChildEquipment
// 0x0020 (0x0058 - 0x0038)
class UHWEquipmentComponent_ChildEquipment final : public UHWEquipmentComponent
{
public:
	TMulticastInlineDelegate<void(class UHWEquipmentComponent_ChildEquipment* ChildEquipmentComponent)> OnParentEquipmentInstanceChangedDelegate; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UHWEquipmentInstance>    ParentEquipment;                                   // 0x0048(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseParentEquipmentFiringInstanceId;               // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEquipmentSlotChanged(class UHWInventoryManagerComponent* InventoryManager, class UHWEquipmentInstance* EquipmentInstance, const struct FHWInventorySlot& Slot, const EHWInventoryChangeReason InventoryChangeReason);
	void OnParentLevelChanged(class UHWEquipmentInstance* Equipment, const int32 PreviousLevel);
	void OnRep_ParentEquipment();

	class UHWEquipmentInstance* GetParentEquipment() const;
	class UHWEquipmentComponent* GetParentEquipmentComponentByClass(TSubclassOf<class UHWEquipmentComponent> ComponentClass) const;
	bool ShouldUseParentEquipmentFiringInstanceId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponent_ChildEquipment">();
	}
	static class UHWEquipmentComponent_ChildEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponent_ChildEquipment>();
	}
};
static_assert(alignof(UHWEquipmentComponent_ChildEquipment) == 0x000008, "Wrong alignment on UHWEquipmentComponent_ChildEquipment");
static_assert(sizeof(UHWEquipmentComponent_ChildEquipment) == 0x000058, "Wrong size on UHWEquipmentComponent_ChildEquipment");
static_assert(offsetof(UHWEquipmentComponent_ChildEquipment, OnParentEquipmentInstanceChangedDelegate) == 0x000038, "Member 'UHWEquipmentComponent_ChildEquipment::OnParentEquipmentInstanceChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_ChildEquipment, ParentEquipment) == 0x000048, "Member 'UHWEquipmentComponent_ChildEquipment::ParentEquipment' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_ChildEquipment, bUseParentEquipmentFiringInstanceId) == 0x000050, "Member 'UHWEquipmentComponent_ChildEquipment::bUseParentEquipmentFiringInstanceId' has a wrong offset!");

// Class Hemingway.HWDeployable_Statue
// 0x0028 (0x0570 - 0x0548)
class AHWDeployable_Statue final : public AHWDeployable_Wall
{
public:
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWSkeletalMeshComponent*               StatueMesh;                                        // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacter_Base*                      DepictedCharacter;                                 // 0x0558(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 AnimInstanceClassRef;                              // 0x0560(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHighlightStatue;                                  // 0x0568(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x7];                                      // 0x0569(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FreezeSkeleton();
	class AHWCharacter_Base* GetTargetCharacterToDepict();
	void HandleTagUpdated_TargetLock(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void InitializeStatue(class AHWCharacter_Base* InTargetCharacter);
	void OnDepictedCharacterCopied();
	void OnRep_DepictedCharacter();
	void SetUpCollision();
	void SetUpMeshDepiction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Statue">();
	}
	static class AHWDeployable_Statue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Statue>();
	}
};
static_assert(alignof(AHWDeployable_Statue) == 0x000008, "Wrong alignment on AHWDeployable_Statue");
static_assert(sizeof(AHWDeployable_Statue) == 0x000570, "Wrong size on AHWDeployable_Statue");
static_assert(offsetof(AHWDeployable_Statue, StatueMesh) == 0x000550, "Member 'AHWDeployable_Statue::StatueMesh' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Statue, DepictedCharacter) == 0x000558, "Member 'AHWDeployable_Statue::DepictedCharacter' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Statue, AnimInstanceClassRef) == 0x000560, "Member 'AHWDeployable_Statue::AnimInstanceClassRef' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Statue, bHighlightStatue) == 0x000568, "Member 'AHWDeployable_Statue::bHighlightStatue' has a wrong offset!");

// Class Hemingway.HWEquipmentInstance
// 0x0180 (0x01A8 - 0x0028)
class UHWEquipmentInstance final : public UObject
{
public:
	struct FHWInventorySlot                       InventorySlot;                                     // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWEquipmentItem*                       EquipmentItem;                                     // 0x0038(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWEquipmentInfo*                       EquipmentInfo;                                     // 0x0040(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWInventoryManagerComponent*           OwningInventoryManager;                            // 0x0048(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInitialized;                                    // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEquipped;                                       // 0x0051(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilitySpecHandle             GrantedAbilityHandle;                              // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    GrantedEffectHandles;                              // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWEquipmentInstance* EquipmentChanged, const int32 PreviousLevel)> OnEquipmentLevelChangedDelegate; // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWEquipmentInstance* EquipmentInstance)> OnEquipmentComponentsInitializedDelegate; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UHWEquipmentComponent*>          Components;                                        // 0x0090(0x0010)(Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWEquipmentInstance* EquipmentChanged)> OnEquipmentStatusTagsChangedDel; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  StatusTags;                                        // 0x00B0(0x0020)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EAbilityFlowPhase                             CurrentAbilityPhase;                               // 0x0100(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101[0x58];                                     // 0x0101(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	EAbilityCastStyle                             CastStyle;                                         // 0x0159(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15A[0xE];                                      // 0x015A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGameplayTag& IconOverrideTag)> IconOverrideSetDel;   // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           IconOverrideTag;                                   // 0x0178(0x0008)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWTargeter*                            AbilityTargeter;                                   // 0x0180(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWEquipmentInstance* EquipmentInstance, const struct FGameplayTag& InputTag, const struct FGameplayTag& DisplayInputTag)> OnInputChangedDelegate; // 0x0188(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AssignedInputTag;                                  // 0x0198(0x0008)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWEquipmentInstance*                   ListenerEquipmentInstance;                         // 0x01A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddStatusTag(const struct FGameplayTag& Tag);
	void AssignInputTag(const struct FGameplayTag& InputTag);
	void ClearInventorySlot();
	EAbilityCastStyle GetCastStyle();
	void HandleAbilityActivationBlockedTagUpdated(const struct FGameplayTag& ActivationBlockTag, int32 Count);
	void OnEquipmentLevelChanged(int32 PreviousLevel);
	void OnRep_AssignedInputTag(const struct FGameplayTag& OldInputTag);
	void OnRep_CastStyle();
	void OnRep_EquipmentComponents();
	void OnRep_IconOverrideTag();
	void OnRep_OwningInventoryManager();
	void OnRep_StatusTags();
	float RefundSkillPoints();
	void RemoveGrantedByEffect();
	void RemoveStatusTag(const struct FGameplayTag& Tag);
	void ServerSetLevel(const int32 NewLevel);
	void SetAbilityCastStyle(EAbilityCastStyle InCastStyle);
	void SetAbilityPersistentState(const class FString& PersistentState);
	void SetIconOverrideTag(const struct FGameplayTag& NewIconOverrideTag);
	void SetInventorySlot(const struct FHWInventorySlot& Slot);
	void SetLevel(const int32 NewLevel);
	void UpdateCastStyle();

	bool CanEquipmentLevelUp() const;
	bool CanSetEquipmentLevelTo(const int32 DesiredLevel) const;
	struct FGameplayTagContainer GetAbilityAdditionalActivationBlockTags() const;
	struct FGameplayAbilitySpecHandle GetAbilityHandle() const;
	class FString GetAbilityPersistentState() const;
	EAbilityFlowPhase GetCurrentAbilityPhase() const;
	class UHWEquipmentComponent* GetEquipmentComponentByClass(TSubclassOf<class UHWEquipmentComponent> ComponentClass, const struct FGameplayTag& ID) const;
	const class UHWEquipmentInfo* GetEquipmentInfo() const;
	struct FGameplayTag GetEquipmentInputTag(const bool bIsForDisplay) const;
	const class UHWEquipmentItem* GetEquipmentItem() const;
	struct FGameplayTag GetEquipmentType() const;
	struct FActiveGameplayEffectHandle GetGrantedByEffect() const;
	struct FGameplayTag GetIconOverridesTag() const;
	struct FHWInventorySlot GetInventorySlot() const;
	int32 GetLevel() const;
	int32 GetMaxLevel() const;
	class UHWAbilitySystemComponent* GetOwningAbilitySystem() const;
	class UHWInventoryManagerComponent* GetOwningInventory() const;
	float GetSkillPointsNeededForLvl(const int32 CurrentLvl, const int32 NewLvl) const;
	void GetStatusTags(struct FGameplayTagContainer* OutStatusTags) const;
	bool HasStatusTag(const struct FGameplayTag& Tag, bool bExactMatch) const;
	bool IsActivatableItem() const;
	bool IsEquipped() const;
	bool IsInInventory() const;
	struct FGameplayEffectContextHandle MakeEffectContext() const;
	bool ShouldUseSkillPointToLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentInstance">();
	}
	static class UHWEquipmentInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentInstance>();
	}
};
static_assert(alignof(UHWEquipmentInstance) == 0x000008, "Wrong alignment on UHWEquipmentInstance");
static_assert(sizeof(UHWEquipmentInstance) == 0x0001A8, "Wrong size on UHWEquipmentInstance");
static_assert(offsetof(UHWEquipmentInstance, InventorySlot) == 0x000028, "Member 'UHWEquipmentInstance::InventorySlot' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, EquipmentItem) == 0x000038, "Member 'UHWEquipmentInstance::EquipmentItem' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, EquipmentInfo) == 0x000040, "Member 'UHWEquipmentInstance::EquipmentInfo' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, OwningInventoryManager) == 0x000048, "Member 'UHWEquipmentInstance::OwningInventoryManager' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, bIsInitialized) == 0x000050, "Member 'UHWEquipmentInstance::bIsInitialized' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, bIsEquipped) == 0x000051, "Member 'UHWEquipmentInstance::bIsEquipped' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, GrantedAbilityHandle) == 0x000054, "Member 'UHWEquipmentInstance::GrantedAbilityHandle' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, GrantedEffectHandles) == 0x000058, "Member 'UHWEquipmentInstance::GrantedEffectHandles' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, OnEquipmentLevelChangedDelegate) == 0x000068, "Member 'UHWEquipmentInstance::OnEquipmentLevelChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, Level) == 0x000078, "Member 'UHWEquipmentInstance::Level' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, OnEquipmentComponentsInitializedDelegate) == 0x000080, "Member 'UHWEquipmentInstance::OnEquipmentComponentsInitializedDelegate' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, Components) == 0x000090, "Member 'UHWEquipmentInstance::Components' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, OnEquipmentStatusTagsChangedDel) == 0x0000A0, "Member 'UHWEquipmentInstance::OnEquipmentStatusTagsChangedDel' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, StatusTags) == 0x0000B0, "Member 'UHWEquipmentInstance::StatusTags' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, CurrentAbilityPhase) == 0x000100, "Member 'UHWEquipmentInstance::CurrentAbilityPhase' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, CastStyle) == 0x000159, "Member 'UHWEquipmentInstance::CastStyle' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, IconOverrideSetDel) == 0x000168, "Member 'UHWEquipmentInstance::IconOverrideSetDel' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, IconOverrideTag) == 0x000178, "Member 'UHWEquipmentInstance::IconOverrideTag' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, AbilityTargeter) == 0x000180, "Member 'UHWEquipmentInstance::AbilityTargeter' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, OnInputChangedDelegate) == 0x000188, "Member 'UHWEquipmentInstance::OnInputChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, AssignedInputTag) == 0x000198, "Member 'UHWEquipmentInstance::AssignedInputTag' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInstance, ListenerEquipmentInstance) == 0x0001A0, "Member 'UHWEquipmentInstance::ListenerEquipmentInstance' has a wrong offset!");

// Class Hemingway.HWDraftAuthority
// 0x0110 (0x0CB0 - 0x0BA0)
class AHWDraftAuthority final : public ADraftAuthority
{
public:
	TMap<struct FDraftPlayerIdHandle, struct FDraftPlayerIdHandle> BackfillBotMapping;               // 0x0BA0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	bool                                          bHasReceivedGodChoices;                            // 0x0BF0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAreAllPlayersConnected;                           // 0x0BF1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasStartedDraft;                                  // 0x0BF2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceDraftToStart;                                // 0x0BF3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BF4[0x4];                                      // 0x0BF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDraftRules>                PendingDraftRules;                                 // 0x0BF8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PendingDraftName;                                  // 0x0C00(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C08[0x8];                                      // 0x0C08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FHWPersistentPlayerId, class UObject*> InitialRandomChoices;                         // 0x0C10(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C60[0x50];                                     // 0x0C60(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KeepAllDraftTimersInSync();
	void OnAllPlayersConnectedToMatch(bool bDidAllPlayersConnect);
	void OnGamePhaseStarted(const struct FGameplayTag& NewPhase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDraftAuthority">();
	}
	static class AHWDraftAuthority* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDraftAuthority>();
	}
};
static_assert(alignof(AHWDraftAuthority) == 0x000008, "Wrong alignment on AHWDraftAuthority");
static_assert(sizeof(AHWDraftAuthority) == 0x000CB0, "Wrong size on AHWDraftAuthority");
static_assert(offsetof(AHWDraftAuthority, BackfillBotMapping) == 0x000BA0, "Member 'AHWDraftAuthority::BackfillBotMapping' has a wrong offset!");
static_assert(offsetof(AHWDraftAuthority, bHasReceivedGodChoices) == 0x000BF0, "Member 'AHWDraftAuthority::bHasReceivedGodChoices' has a wrong offset!");
static_assert(offsetof(AHWDraftAuthority, bAreAllPlayersConnected) == 0x000BF1, "Member 'AHWDraftAuthority::bAreAllPlayersConnected' has a wrong offset!");
static_assert(offsetof(AHWDraftAuthority, bHasStartedDraft) == 0x000BF2, "Member 'AHWDraftAuthority::bHasStartedDraft' has a wrong offset!");
static_assert(offsetof(AHWDraftAuthority, bForceDraftToStart) == 0x000BF3, "Member 'AHWDraftAuthority::bForceDraftToStart' has a wrong offset!");
static_assert(offsetof(AHWDraftAuthority, PendingDraftRules) == 0x000BF8, "Member 'AHWDraftAuthority::PendingDraftRules' has a wrong offset!");
static_assert(offsetof(AHWDraftAuthority, PendingDraftName) == 0x000C00, "Member 'AHWDraftAuthority::PendingDraftName' has a wrong offset!");
static_assert(offsetof(AHWDraftAuthority, InitialRandomChoices) == 0x000C10, "Member 'AHWDraftAuthority::InitialRandomChoices' has a wrong offset!");

// Class Hemingway.HWEquipmentItem_TooltipDataBase
// 0x0000 (0x0028 - 0x0028)
class UHWEquipmentItem_TooltipDataBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentItem_TooltipDataBase">();
	}
	static class UHWEquipmentItem_TooltipDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentItem_TooltipDataBase>();
	}
};
static_assert(alignof(UHWEquipmentItem_TooltipDataBase) == 0x000008, "Wrong alignment on UHWEquipmentItem_TooltipDataBase");
static_assert(sizeof(UHWEquipmentItem_TooltipDataBase) == 0x000028, "Wrong size on UHWEquipmentItem_TooltipDataBase");

// Class Hemingway.HWEquipmentItem_ItemTooltipData
// 0x0020 (0x0048 - 0x0028)
class UHWEquipmentItem_ItemTooltipData final : public UHWEquipmentItem_TooltipDataBase
{
public:
	TArray<struct FHWEquipmentItem_ItemTooltip_Stat> ItemStats;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHWEquipmentItem_ItemTooltip_Ability> ItemAbilities;                               // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentItem_ItemTooltipData">();
	}
	static class UHWEquipmentItem_ItemTooltipData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentItem_ItemTooltipData>();
	}
};
static_assert(alignof(UHWEquipmentItem_ItemTooltipData) == 0x000008, "Wrong alignment on UHWEquipmentItem_ItemTooltipData");
static_assert(sizeof(UHWEquipmentItem_ItemTooltipData) == 0x000048, "Wrong size on UHWEquipmentItem_ItemTooltipData");
static_assert(offsetof(UHWEquipmentItem_ItemTooltipData, ItemStats) == 0x000028, "Member 'UHWEquipmentItem_ItemTooltipData::ItemStats' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem_ItemTooltipData, ItemAbilities) == 0x000038, "Member 'UHWEquipmentItem_ItemTooltipData::ItemAbilities' has a wrong offset!");

// Class Hemingway.HWDraftRules_Casual
// 0x0010 (0x0118 - 0x0108)
class UHWDraftRules_Casual : public UHWDraftRules
{
public:
	float                                         HumanTimeToPick;                                   // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RegularAITimeToPick;                               // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FakeHumanAIMinTimeToPick;                          // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FakeHumanAIMaxTimeToPick;                          // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDraftRules_Casual">();
	}
	static class UHWDraftRules_Casual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDraftRules_Casual>();
	}
};
static_assert(alignof(UHWDraftRules_Casual) == 0x000008, "Wrong alignment on UHWDraftRules_Casual");
static_assert(sizeof(UHWDraftRules_Casual) == 0x000118, "Wrong size on UHWDraftRules_Casual");
static_assert(offsetof(UHWDraftRules_Casual, HumanTimeToPick) == 0x000108, "Member 'UHWDraftRules_Casual::HumanTimeToPick' has a wrong offset!");
static_assert(offsetof(UHWDraftRules_Casual, RegularAITimeToPick) == 0x00010C, "Member 'UHWDraftRules_Casual::RegularAITimeToPick' has a wrong offset!");
static_assert(offsetof(UHWDraftRules_Casual, FakeHumanAIMinTimeToPick) == 0x000110, "Member 'UHWDraftRules_Casual::FakeHumanAIMinTimeToPick' has a wrong offset!");
static_assert(offsetof(UHWDraftRules_Casual, FakeHumanAIMaxTimeToPick) == 0x000114, "Member 'UHWDraftRules_Casual::FakeHumanAIMaxTimeToPick' has a wrong offset!");

// Class Hemingway.HWDraftRules_Assault
// 0x0000 (0x0118 - 0x0118)
class UHWDraftRules_Assault : public UHWDraftRules_Casual
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDraftRules_Assault">();
	}
	static class UHWDraftRules_Assault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDraftRules_Assault>();
	}
};
static_assert(alignof(UHWDraftRules_Assault) == 0x000008, "Wrong alignment on UHWDraftRules_Assault");
static_assert(sizeof(UHWDraftRules_Assault) == 0x000118, "Wrong size on UHWDraftRules_Assault");

// Class Hemingway.HWStaticMeshComponent
// 0x0000 (0x06F0 - 0x06F0)
class UHWStaticMeshComponent : public USkinnableStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWStaticMeshComponent">();
	}
	static class UHWStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWStaticMeshComponent>();
	}
};
static_assert(alignof(UHWStaticMeshComponent) == 0x000010, "Wrong alignment on UHWStaticMeshComponent");
static_assert(sizeof(UHWStaticMeshComponent) == 0x0006F0, "Wrong size on UHWStaticMeshComponent");

// Class Hemingway.HWEventManager
// 0x01F0 (0x0488 - 0x0298)
class AHWEventManager : public AInfo
{
public:
	TSoftObjectPtr<class UDataTable>              EventBucketConfigDTSoftPtr;                        // 0x0298(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FHWEventConfig> EventTagToEventConfig;                          // 0x02C0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FHWEventBucketConfig> BucketTagToBucketConfig;                  // 0x0310(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x50];                                     // 0x0360(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FHWEventContext& EventContext, const bool bStomped)> OnEventAdded; // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x18];                                     // 0x03C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWEventInstanceData                   OngoingEventInstanceData;                          // 0x03D8(0x0098)(Transient, Protected, NativeAccessSpecifierProtected)
	class UHWEventHandlerBase*                    OngoingEventHandler;                               // 0x0470(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x10];                                     // 0x0478(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddEvent(const struct FGameplayTag& EventTag, struct FHWEventContext* EventContext);

	bool IsQueueEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEventManager">();
	}
	static class AHWEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWEventManager>();
	}
};
static_assert(alignof(AHWEventManager) == 0x000008, "Wrong alignment on AHWEventManager");
static_assert(sizeof(AHWEventManager) == 0x000488, "Wrong size on AHWEventManager");
static_assert(offsetof(AHWEventManager, EventBucketConfigDTSoftPtr) == 0x000298, "Member 'AHWEventManager::EventBucketConfigDTSoftPtr' has a wrong offset!");
static_assert(offsetof(AHWEventManager, EventTagToEventConfig) == 0x0002C0, "Member 'AHWEventManager::EventTagToEventConfig' has a wrong offset!");
static_assert(offsetof(AHWEventManager, BucketTagToBucketConfig) == 0x000310, "Member 'AHWEventManager::BucketTagToBucketConfig' has a wrong offset!");
static_assert(offsetof(AHWEventManager, OnEventAdded) == 0x0003B0, "Member 'AHWEventManager::OnEventAdded' has a wrong offset!");
static_assert(offsetof(AHWEventManager, OngoingEventInstanceData) == 0x0003D8, "Member 'AHWEventManager::OngoingEventInstanceData' has a wrong offset!");
static_assert(offsetof(AHWEventManager, OngoingEventHandler) == 0x000470, "Member 'AHWEventManager::OngoingEventHandler' has a wrong offset!");

// Class Hemingway.HWEditorSettings
// 0x0038 (0x0060 - 0x0028)
class UHWEditorSettings final : public UObject
{
public:
	struct FSoftObjectPath                        DefaultCharacter;                                  // 0x0028(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                TestQuests;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultCastStyle;                              // 0x0058(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityCastStyle                             DefaultCastStyle;                                  // 0x0059(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEditorSettings">();
	}
	static class UHWEditorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEditorSettings>();
	}
};
static_assert(alignof(UHWEditorSettings) == 0x000008, "Wrong alignment on UHWEditorSettings");
static_assert(sizeof(UHWEditorSettings) == 0x000060, "Wrong size on UHWEditorSettings");
static_assert(offsetof(UHWEditorSettings, DefaultCharacter) == 0x000028, "Member 'UHWEditorSettings::DefaultCharacter' has a wrong offset!");
static_assert(offsetof(UHWEditorSettings, TestQuests) == 0x000048, "Member 'UHWEditorSettings::TestQuests' has a wrong offset!");
static_assert(offsetof(UHWEditorSettings, bUseDefaultCastStyle) == 0x000058, "Member 'UHWEditorSettings::bUseDefaultCastStyle' has a wrong offset!");
static_assert(offsetof(UHWEditorSettings, DefaultCastStyle) == 0x000059, "Member 'UHWEditorSettings::DefaultCastStyle' has a wrong offset!");

// Class Hemingway.HWEnvQueryGenerator_GridToTarget
// 0x0080 (0x0110 - 0x0090)
class UHWEnvQueryGenerator_GridToTarget final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              GridWidth;                                         // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              GridSpacing;                                       // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Source;                                            // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Target;                                            // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEnvQueryGenerator_GridToTarget">();
	}
	static class UHWEnvQueryGenerator_GridToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEnvQueryGenerator_GridToTarget>();
	}
};
static_assert(alignof(UHWEnvQueryGenerator_GridToTarget) == 0x000008, "Wrong alignment on UHWEnvQueryGenerator_GridToTarget");
static_assert(sizeof(UHWEnvQueryGenerator_GridToTarget) == 0x000110, "Wrong size on UHWEnvQueryGenerator_GridToTarget");
static_assert(offsetof(UHWEnvQueryGenerator_GridToTarget, GridWidth) == 0x000090, "Member 'UHWEnvQueryGenerator_GridToTarget::GridWidth' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryGenerator_GridToTarget, GridSpacing) == 0x0000C8, "Member 'UHWEnvQueryGenerator_GridToTarget::GridSpacing' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryGenerator_GridToTarget, Source) == 0x000100, "Member 'UHWEnvQueryGenerator_GridToTarget::Source' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryGenerator_GridToTarget, Target) == 0x000108, "Member 'UHWEnvQueryGenerator_GridToTarget::Target' has a wrong offset!");

// Class Hemingway.HWEnvQueryTest_AbilityTargeting
// 0x0048 (0x0240 - 0x01F8)
class UHWEnvQueryTest_AbilityTargeting final : public UEnvQueryTest
{
public:
	class UHWEquipmentItem*                       EquipmentToTest;                                   // 0x01F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DesiredAttack;                                     // 0x0200(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDataProviderBoolValue               bIsCircleAOE;                                      // 0x0208(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEnvQueryTest_AbilityTargeting">();
	}
	static class UHWEnvQueryTest_AbilityTargeting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEnvQueryTest_AbilityTargeting>();
	}
};
static_assert(alignof(UHWEnvQueryTest_AbilityTargeting) == 0x000008, "Wrong alignment on UHWEnvQueryTest_AbilityTargeting");
static_assert(sizeof(UHWEnvQueryTest_AbilityTargeting) == 0x000240, "Wrong size on UHWEnvQueryTest_AbilityTargeting");
static_assert(offsetof(UHWEnvQueryTest_AbilityTargeting, EquipmentToTest) == 0x0001F8, "Member 'UHWEnvQueryTest_AbilityTargeting::EquipmentToTest' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryTest_AbilityTargeting, DesiredAttack) == 0x000200, "Member 'UHWEnvQueryTest_AbilityTargeting::DesiredAttack' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryTest_AbilityTargeting, bIsCircleAOE) == 0x000208, "Member 'UHWEnvQueryTest_AbilityTargeting::bIsCircleAOE' has a wrong offset!");

// Class Hemingway.HWAbilityAimSettings_Linear
// 0x0020 (0x0088 - 0x0068)
class UHWAbilityAimSettings_Linear : public UHWAbilityAimSettings
{
public:
	bool                                          bValidateEndAimAtGround;                           // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWGroundTargetValidationType                 GroundPlacementValidationType;                     // 0x0069(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRange;                                          // 0x006C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ManualCollisionRadius;                             // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldStopOnWorld;                                // 0x0074(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionProfileName;                              // 0x0078(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldCollisionRadius;                              // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetManualCollisionRadius() const;
	float GetMaxRange(const struct FHWAimTargetingInfo& AimTargetingInfo) const;
	float GetWorldCollisionRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSettings_Linear">();
	}
	static class UHWAbilityAimSettings_Linear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSettings_Linear>();
	}
};
static_assert(alignof(UHWAbilityAimSettings_Linear) == 0x000008, "Wrong alignment on UHWAbilityAimSettings_Linear");
static_assert(sizeof(UHWAbilityAimSettings_Linear) == 0x000088, "Wrong size on UHWAbilityAimSettings_Linear");
static_assert(offsetof(UHWAbilityAimSettings_Linear, bValidateEndAimAtGround) == 0x000068, "Member 'UHWAbilityAimSettings_Linear::bValidateEndAimAtGround' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_Linear, GroundPlacementValidationType) == 0x000069, "Member 'UHWAbilityAimSettings_Linear::GroundPlacementValidationType' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_Linear, MaxRange) == 0x00006C, "Member 'UHWAbilityAimSettings_Linear::MaxRange' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_Linear, ManualCollisionRadius) == 0x000070, "Member 'UHWAbilityAimSettings_Linear::ManualCollisionRadius' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_Linear, bShouldStopOnWorld) == 0x000074, "Member 'UHWAbilityAimSettings_Linear::bShouldStopOnWorld' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_Linear, CollisionProfileName) == 0x000078, "Member 'UHWAbilityAimSettings_Linear::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_Linear, WorldCollisionRadius) == 0x000080, "Member 'UHWAbilityAimSettings_Linear::WorldCollisionRadius' has a wrong offset!");

// Class Hemingway.HWAimSetting_Mercury_A04
// 0x0008 (0x0090 - 0x0088)
class UHWAimSetting_Mercury_A04 final : public UHWAbilityAimSettings_Linear
{
public:
	float                                         MaxChargeUpTime;                                   // 0x0088(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAimSetting_Mercury_A04">();
	}
	static class UHWAimSetting_Mercury_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAimSetting_Mercury_A04>();
	}
};
static_assert(alignof(UHWAimSetting_Mercury_A04) == 0x000008, "Wrong alignment on UHWAimSetting_Mercury_A04");
static_assert(sizeof(UHWAimSetting_Mercury_A04) == 0x000090, "Wrong size on UHWAimSetting_Mercury_A04");
static_assert(offsetof(UHWAimSetting_Mercury_A04, MaxChargeUpTime) == 0x000088, "Member 'UHWAimSetting_Mercury_A04::MaxChargeUpTime' has a wrong offset!");

// Class Hemingway.HWEquipmentComponentSettings_Ammo
// 0x00C8 (0x0108 - 0x0040)
class UHWEquipmentComponentSettings_Ammo final : public UHWEquipmentComponentSettings
{
public:
	int32                                         StartingAmmoCount;                                 // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         MaxAmmoCount;                                      // 0x0048(0x0028)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         AmmoToConsumePerFire;                              // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManuallyConsumeAmmo;                              // 0x0074(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysHasEnoughAmmo;                              // 0x0075(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyEquipmentWhenOutOfAmmo;                    // 0x0076(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegenerateAmmoOverTime;                           // 0x0077(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWGameplayEffect>          RegenerateAmmoCooldownEffectClass;                 // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoToRegeneratePerCooldown;                       // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RefillAmmoWhenTagAdded;                            // 0x0088(0x0020)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bSellWholeStack;                                   // 0x00A8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, TSoftObjectPtr<class UTexture2D>> AmmoIconThresholds;                                // 0x00B0(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bShouldAmmoAffectUICooldown;                       // 0x0100(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponentSettings_Ammo">();
	}
	static class UHWEquipmentComponentSettings_Ammo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponentSettings_Ammo>();
	}
};
static_assert(alignof(UHWEquipmentComponentSettings_Ammo) == 0x000008, "Wrong alignment on UHWEquipmentComponentSettings_Ammo");
static_assert(sizeof(UHWEquipmentComponentSettings_Ammo) == 0x000108, "Wrong size on UHWEquipmentComponentSettings_Ammo");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, StartingAmmoCount) == 0x000040, "Member 'UHWEquipmentComponentSettings_Ammo::StartingAmmoCount' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, MaxAmmoCount) == 0x000048, "Member 'UHWEquipmentComponentSettings_Ammo::MaxAmmoCount' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, AmmoToConsumePerFire) == 0x000070, "Member 'UHWEquipmentComponentSettings_Ammo::AmmoToConsumePerFire' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, bManuallyConsumeAmmo) == 0x000074, "Member 'UHWEquipmentComponentSettings_Ammo::bManuallyConsumeAmmo' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, bAlwaysHasEnoughAmmo) == 0x000075, "Member 'UHWEquipmentComponentSettings_Ammo::bAlwaysHasEnoughAmmo' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, bDestroyEquipmentWhenOutOfAmmo) == 0x000076, "Member 'UHWEquipmentComponentSettings_Ammo::bDestroyEquipmentWhenOutOfAmmo' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, bRegenerateAmmoOverTime) == 0x000077, "Member 'UHWEquipmentComponentSettings_Ammo::bRegenerateAmmoOverTime' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, RegenerateAmmoCooldownEffectClass) == 0x000078, "Member 'UHWEquipmentComponentSettings_Ammo::RegenerateAmmoCooldownEffectClass' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, AmmoToRegeneratePerCooldown) == 0x000080, "Member 'UHWEquipmentComponentSettings_Ammo::AmmoToRegeneratePerCooldown' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, RefillAmmoWhenTagAdded) == 0x000088, "Member 'UHWEquipmentComponentSettings_Ammo::RefillAmmoWhenTagAdded' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, bSellWholeStack) == 0x0000A8, "Member 'UHWEquipmentComponentSettings_Ammo::bSellWholeStack' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, AmmoIconThresholds) == 0x0000B0, "Member 'UHWEquipmentComponentSettings_Ammo::AmmoIconThresholds' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Ammo, bShouldAmmoAffectUICooldown) == 0x000100, "Member 'UHWEquipmentComponentSettings_Ammo::bShouldAmmoAffectUICooldown' has a wrong offset!");

// Class Hemingway.HWAbility_Morrigan_A04
// 0x0008 (0x0D68 - 0x0D60)
class UHWAbility_Morrigan_A04 final : public UHWGameplayAbility_Enhanced
{
public:
	class UHWEquipmentItem*                       ChangelingEquipmentItem;                           // 0x0D60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Morrigan_A04">();
	}
	static class UHWAbility_Morrigan_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Morrigan_A04>();
	}
};
static_assert(alignof(UHWAbility_Morrigan_A04) == 0x000008, "Wrong alignment on UHWAbility_Morrigan_A04");
static_assert(sizeof(UHWAbility_Morrigan_A04) == 0x000D68, "Wrong size on UHWAbility_Morrigan_A04");
static_assert(offsetof(UHWAbility_Morrigan_A04, ChangelingEquipmentItem) == 0x000D60, "Member 'UHWAbility_Morrigan_A04::ChangelingEquipmentItem' has a wrong offset!");

// Class Hemingway.HWEquipmentComponentSettings_FiringInstanceTracker
// 0x0008 (0x0048 - 0x0040)
class UHWEquipmentComponentSettings_FiringInstanceTracker final : public UHWEquipmentComponentSettings
{
public:
	EHWFiringInstanceTrackingBehavior             TrackingBehavior;                                  // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TrackerTimeTillPurge;                              // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponentSettings_FiringInstanceTracker">();
	}
	static class UHWEquipmentComponentSettings_FiringInstanceTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponentSettings_FiringInstanceTracker>();
	}
};
static_assert(alignof(UHWEquipmentComponentSettings_FiringInstanceTracker) == 0x000008, "Wrong alignment on UHWEquipmentComponentSettings_FiringInstanceTracker");
static_assert(sizeof(UHWEquipmentComponentSettings_FiringInstanceTracker) == 0x000048, "Wrong size on UHWEquipmentComponentSettings_FiringInstanceTracker");
static_assert(offsetof(UHWEquipmentComponentSettings_FiringInstanceTracker, TrackingBehavior) == 0x000040, "Member 'UHWEquipmentComponentSettings_FiringInstanceTracker::TrackingBehavior' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_FiringInstanceTracker, TrackerTimeTillPurge) == 0x000044, "Member 'UHWEquipmentComponentSettings_FiringInstanceTracker::TrackerTimeTillPurge' has a wrong offset!");

// Class Hemingway.HWEquipmentComponentSettings_Refireable
// 0x0038 (0x0078 - 0x0040)
class UHWEquipmentComponentSettings_Refireable final : public UHWEquipmentComponentSettings
{
public:
	ERefireAbilityBehavior                        RefireBehavior;                                    // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RefireTriggerFlags;                                // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayAbility>           RefireAbility;                                     // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelRefireAbilityImmeditatelyOnRefireWindowEnd; // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           InputTagOverride;                                  // 0x0054(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldAllowMultipleRefires;                       // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RefireIconTag;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RefireBorderTint;                                  // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FGameplayTag GetInputTagOverride() const;
	TSubclassOf<class UGameplayAbility> GetRefireAbility() const;
	ERefireAbilityBehavior GetRefireBehavior() const;
	bool ShouldAllowMultipleRefires() const;
	bool ShouldCancelRefireAbilityImmeditatelyOnRefireWindowEnd() const;
	bool ShouldRefireOnTrigger(EHWRefireTrigger RefireTrigger) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponentSettings_Refireable">();
	}
	static class UHWEquipmentComponentSettings_Refireable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponentSettings_Refireable>();
	}
};
static_assert(alignof(UHWEquipmentComponentSettings_Refireable) == 0x000008, "Wrong alignment on UHWEquipmentComponentSettings_Refireable");
static_assert(sizeof(UHWEquipmentComponentSettings_Refireable) == 0x000078, "Wrong size on UHWEquipmentComponentSettings_Refireable");
static_assert(offsetof(UHWEquipmentComponentSettings_Refireable, RefireBehavior) == 0x000040, "Member 'UHWEquipmentComponentSettings_Refireable::RefireBehavior' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Refireable, RefireTriggerFlags) == 0x000044, "Member 'UHWEquipmentComponentSettings_Refireable::RefireTriggerFlags' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Refireable, RefireAbility) == 0x000048, "Member 'UHWEquipmentComponentSettings_Refireable::RefireAbility' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Refireable, bCancelRefireAbilityImmeditatelyOnRefireWindowEnd) == 0x000050, "Member 'UHWEquipmentComponentSettings_Refireable::bCancelRefireAbilityImmeditatelyOnRefireWindowEnd' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Refireable, InputTagOverride) == 0x000054, "Member 'UHWEquipmentComponentSettings_Refireable::InputTagOverride' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Refireable, bShouldAllowMultipleRefires) == 0x00005C, "Member 'UHWEquipmentComponentSettings_Refireable::bShouldAllowMultipleRefires' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Refireable, RefireIconTag) == 0x000060, "Member 'UHWEquipmentComponentSettings_Refireable::RefireIconTag' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponentSettings_Refireable, RefireBorderTint) == 0x000068, "Member 'UHWEquipmentComponentSettings_Refireable::RefireBorderTint' has a wrong offset!");

// Class Hemingway.HWDeployable_Neith_Weave
// 0x0000 (0x04C8 - 0x04C8)
class AHWDeployable_Neith_Weave final : public AHWDeployable
{
public:
	void ActivateLocalTargetingVFX(const bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Neith_Weave">();
	}
	static class AHWDeployable_Neith_Weave* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Neith_Weave>();
	}
};
static_assert(alignof(AHWDeployable_Neith_Weave) == 0x000008, "Wrong alignment on AHWDeployable_Neith_Weave");
static_assert(sizeof(AHWDeployable_Neith_Weave) == 0x0004C8, "Wrong size on AHWDeployable_Neith_Weave");

// Class Hemingway.HWEventStompAssessorBase
// 0x0000 (0x0028 - 0x0028)
class UHWEventStompAssessorBase : public UObject
{
public:
	bool ShouldStomp(const struct FHWEventConfig& Event1Config, const struct FHWEventContext& Event1Context, const struct FHWEventConfig& Event2Config, const struct FHWEventContext& Event2Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEventStompAssessorBase">();
	}
	static class UHWEventStompAssessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEventStompAssessorBase>();
	}
};
static_assert(alignof(UHWEventStompAssessorBase) == 0x000008, "Wrong alignment on UHWEventStompAssessorBase");
static_assert(sizeof(UHWEventStompAssessorBase) == 0x000028, "Wrong size on UHWEventStompAssessorBase");

// Class Hemingway.HWAbility_NuWa_A02
// 0x0018 (0x0D78 - 0x0D60)
class UHWAbility_NuWa_A02 final : public UHWGameplayAbility_Enhanced
{
public:
	TWeakObjectPtr<class AActor>                  CurrentSelectedTarget;                             // 0x0D60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SelectTargetAttackTag;                             // 0x0D68(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SelectTargetGameplayCueTag;                        // 0x0D70(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_NuWa_A02">();
	}
	static class UHWAbility_NuWa_A02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_NuWa_A02>();
	}
};
static_assert(alignof(UHWAbility_NuWa_A02) == 0x000008, "Wrong alignment on UHWAbility_NuWa_A02");
static_assert(sizeof(UHWAbility_NuWa_A02) == 0x000D78, "Wrong size on UHWAbility_NuWa_A02");
static_assert(offsetof(UHWAbility_NuWa_A02, CurrentSelectedTarget) == 0x000D60, "Member 'UHWAbility_NuWa_A02::CurrentSelectedTarget' has a wrong offset!");
static_assert(offsetof(UHWAbility_NuWa_A02, SelectTargetAttackTag) == 0x000D68, "Member 'UHWAbility_NuWa_A02::SelectTargetAttackTag' has a wrong offset!");
static_assert(offsetof(UHWAbility_NuWa_A02, SelectTargetGameplayCueTag) == 0x000D70, "Member 'UHWAbility_NuWa_A02::SelectTargetGameplayCueTag' has a wrong offset!");

// Class Hemingway.HWGameplayAbility_Mordred_B04
// 0x0008 (0x0D68 - 0x0D60)
class UHWGameplayAbility_Mordred_B04 final : public UHWGameplayAbility_Enhanced
{
public:
	bool                                          bDashHitGod;                                       // 0x0D60(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D61[0x7];                                      // 0x0D61(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDashHitGod();
	void OnRep_DashHitGod();
	void SetDashHitGod(bool bValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayAbility_Mordred_B04">();
	}
	static class UHWGameplayAbility_Mordred_B04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayAbility_Mordred_B04>();
	}
};
static_assert(alignof(UHWGameplayAbility_Mordred_B04) == 0x000008, "Wrong alignment on UHWGameplayAbility_Mordred_B04");
static_assert(sizeof(UHWGameplayAbility_Mordred_B04) == 0x000D68, "Wrong size on UHWGameplayAbility_Mordred_B04");
static_assert(offsetof(UHWGameplayAbility_Mordred_B04, bDashHitGod) == 0x000D60, "Member 'UHWGameplayAbility_Mordred_B04::bDashHitGod' has a wrong offset!");

// Class Hemingway.HWCheatManager
// 0x0000 (0x0088 - 0x0088)
class UHWCheatManager final : public UCheatManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCheatManager">();
	}
	static class UHWCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCheatManager>();
	}
};
static_assert(alignof(UHWCheatManager) == 0x000008, "Wrong alignment on UHWCheatManager");
static_assert(sizeof(UHWCheatManager) == 0x000088, "Wrong size on UHWCheatManager");

// Class Hemingway.HWGameplayAbility_Stealth
// 0x0028 (0x09E8 - 0x09C0)
class UHWGameplayAbility_Stealth : public UHWGameplayAbility
{
public:
	class UVisibilityData*                        VisibilityData;                                    // 0x09C0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  InheritedEndStealthAbilityTagsIfFired;             // 0x09C8(0x0020)(Protected, NativeAccessSpecifierProtected)

public:
	void EndStealthOnAbilityStartFire(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& InAbilityTags, const struct FHWAbilityFiringInstanceId& FiringInstanceId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayAbility_Stealth">();
	}
	static class UHWGameplayAbility_Stealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayAbility_Stealth>();
	}
};
static_assert(alignof(UHWGameplayAbility_Stealth) == 0x000008, "Wrong alignment on UHWGameplayAbility_Stealth");
static_assert(sizeof(UHWGameplayAbility_Stealth) == 0x0009E8, "Wrong size on UHWGameplayAbility_Stealth");
static_assert(offsetof(UHWGameplayAbility_Stealth, VisibilityData) == 0x0009C0, "Member 'UHWGameplayAbility_Stealth::VisibilityData' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_Stealth, InheritedEndStealthAbilityTagsIfFired) == 0x0009C8, "Member 'UHWGameplayAbility_Stealth::InheritedEndStealthAbilityTagsIfFired' has a wrong offset!");

// Class Hemingway.HWGameplayDash
// 0x07C8 (0x07F0 - 0x0028)
class UHWGameplayDash : public UObject
{
public:
	uint8                                         Pad_28[0x4];                                       // 0x0028(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHWAbilityTask_Attack_Dash> ActiveAttackTask;                               // 0x002C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWCharacterMovementComponent*          CharacterMovementComponent;                        // 0x0038(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             DashingCharacter;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Instigator;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWGameplayAbility_Enhanced*            InstigatingAbility;                                // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDashType                                     DashType;                                          // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DashIdTag;                                         // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         AbilityPredictionKey;                              // 0x0068(0x0018)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PriorityValue;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWDashSpeedCalculationBehavior               SpeedCalculationBehavior;                          // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashSpeed;                                         // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashMaxSpeed;                                      // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAffectedByDiminishingSpeed;                       // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashMinimumSpeed;                                  // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWDashAccelerationBehavior                   AccelerationBehavior;                              // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashAcceleration;                                  // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationTime;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CalculatedAcceleration;                            // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilityTargetDataHandle       AttackAimDataHandle;                               // 0x00A8(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, Transient, Protected, NativeAccessSpecifierProtected)
	EHWDashAccelerationStartingSpeedBehavior      AccelerationStartingSpeedBehavior;                 // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartingDashSpeed;                                 // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CalculatedStartingSpeed;                           // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastCalculatedDashSpeed;                           // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashDistance;                                      // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashDuration;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClampSpeedOnDashEnd;                              // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClampToMaxWalkSpeedOnDashEnd;                     // 0x00E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA[0x2];                                       // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampSpeedDashEndOverride;                         // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowEndingAtInvalidGroundLocation;               // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAffectedByGravity;                                // 0x00F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowVerticalDashMovement;                        // 0x00F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRotationMatchesVelocity;                          // 0x00F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeInterruptedByKnockback;                      // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWEndDashBehavior                            DashBehaviorOnInterrupted;                         // 0x00F5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldMatchDashDirectionOnDashStart;              // 0x00F6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F7[0x1];                                       // 0x00F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndTime;                                           // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CharacterStartingRotation;                         // 0x0100(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               CharacterRotationOffset;                           // 0x0118(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                CharacterStartingLocation;                         // 0x0130(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreClientCorrections;                          // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsesClientAuthoritativeMovement;                  // 0x0149(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A[0x2];                                      // 0x014A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurningDegreesPerSecond;                           // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHWAbilityCollisionProxy> DashCollisionProxy;                               // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCollisionEndingDash;                            // 0x0158(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWDashEndInfo                         DashEndInfo;                                       // 0x0160(0x0130)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EDashCollisionType                            DashCollisionType;                                 // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBodyInstance                          DashingCollision;                                  // 0x0298(0x0190)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	bool                                          bServerDrivesCollisionDashEnding;                  // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldStopOnWorld;                                // 0x0429(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldStopOnCharacter;                            // 0x042A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyStopOnAITarget;                               // 0x042B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPredictsCollisions;                               // 0x042C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42D[0x3];                                      // 0x042D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoxSphereBounds                       MeshCollisionBounds;                               // 0x0430(0x0038)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCollectDashHits;                                  // 0x0468(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWGameplayTargetDataFilter            CharacterStopTargetFilter;                         // 0x0470(0x01D0)(Edit, Net, Protected, NativeAccessSpecifierProtected)
	struct FHWCollisionState                      PushedCollisionState;                              // 0x0640(0x003C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bClientCalledServerEndDashCollided;                // 0x067C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67D[0x3];                                      // 0x067D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWGameplayDash* Dash)> OnDashStartedDelegate;               // 0x0680(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayDash* Dash, const bool bWasInterrupted)> OnDashEndedDelegate; // 0x0690(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsDashActive;                                     // 0x06A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDashTimerStarted;                                 // 0x06A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLocationIsInvalid;                                // 0x06A2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A3[0x1];                                      // 0x06A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtendedDashDistance;                              // 0x06A4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A8[0x8];                                      // 0x06A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInheritedTagContainer                 CancelTags;                                        // 0x06B0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 BlockTags;                                         // 0x0710(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 TagsToApplyWhileDashing;                           // 0x0770(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyWhileDashing;                        // 0x07D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    EffectsAppliedWhileDashing;                        // 0x07E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	struct FRotator CalcDashRotation(const float DeltaTime, const struct FVector& Velocity);
	struct FVector CalcDashVelocity(const float DeltaTime);
	bool CanBeInterruptedByKnockback();
	void CollectDashHits(const struct FVector& Start, const struct FVector& End);
	void EndDash(const bool bIsInterrupting, const bool bShouldStartNextQueuedDash);
	void ExtendDash(const float Distance);
	float GetDashEndClampedSpeed();
	void OnCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void OnDashBeginOverlap(class UHWAbilityTask_FireAttack* AttackTask, const struct FHWAbilityAttackInstance& AttackInstance, const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTagContainer& HitTags);
	void OnDashCharacterHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnDashEnded(const bool bWasInterrupted);
	void OnDashEndOverlap(class UHWAbilityTask_FireAttack* AttackTask, const struct FGameplayTagContainer& HitTags, const struct FGameplayAbilityTargetDataHandle& TargetData);
	void OnDashStarted();
	void OnDashTimerEnded();
	void OnRep_ExtendedDashDistance();
	bool ShouldClampSpeedOnDashEnd();
	void StartDash(const struct FRotator& DashRotation);
	void UpdateMeshCollisionBounds(const class UHWAbilityAttackSettings_Dash* DashAttackSettings);

	struct FVector CalcDashEndLocation() const;
	float CalcDashSpeed(const float DeltaTime) const;
	void CalcHighlightingTargetList(const struct FHWAttackTargetingInfo& TargetingInfo, struct FGameplayAbilityTargetDataHandle& TargetListDataHandle, const class UHWAbilityAttackSettings_Dash* DashAttackSettings, const class UHWAbilityAttackSettings* EndOfDashAttackSetting) const;
	struct FVector CalcInitialDashVelocity() const;
	struct FRotator GetCharacterStartingRotation() const;
	EHWEndDashBehavior GetDashBehaviorOnInterrupted() const;
	float GetDashDistance() const;
	float GetDashDuration() const;
	struct FGameplayTag GetDashId() const;
	class ACharacter* GetDashingCharacter() const;
	float GetDashTurnSpeed() const;
	bool IsActive() const;
	bool IsAffectedByGravity() const;
	bool IsSameDash(class UHWGameplayDash* ComparisonDash) const;
	bool IsSteerable() const;
	bool IsValidDashHit(const class AActor* HitActor, const struct FHitResult& Hit, const class AActor* DashingActor) const;
	bool IsVerticalMovementAllowed() const;
	bool PredictsCollisions() const;
	bool ShouldCollectDashHits() const;
	bool ShouldCollisionEndDash(const class AActor* Target, const struct FHitResult& DashHit, class AActor* SourceActorOverride) const;
	bool ShouldEndDash() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayDash">();
	}
	static class UHWGameplayDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayDash>();
	}
};
static_assert(alignof(UHWGameplayDash) == 0x000008, "Wrong alignment on UHWGameplayDash");
static_assert(sizeof(UHWGameplayDash) == 0x0007F0, "Wrong size on UHWGameplayDash");
static_assert(offsetof(UHWGameplayDash, ActiveAttackTask) == 0x00002C, "Member 'UHWGameplayDash::ActiveAttackTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, CharacterMovementComponent) == 0x000038, "Member 'UHWGameplayDash::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashingCharacter) == 0x000040, "Member 'UHWGameplayDash::DashingCharacter' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, Instigator) == 0x000048, "Member 'UHWGameplayDash::Instigator' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, InstigatingAbility) == 0x000050, "Member 'UHWGameplayDash::InstigatingAbility' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashType) == 0x000058, "Member 'UHWGameplayDash::DashType' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashIdTag) == 0x00005C, "Member 'UHWGameplayDash::DashIdTag' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, AbilityPredictionKey) == 0x000068, "Member 'UHWGameplayDash::AbilityPredictionKey' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, PriorityValue) == 0x000080, "Member 'UHWGameplayDash::PriorityValue' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, SpeedCalculationBehavior) == 0x000084, "Member 'UHWGameplayDash::SpeedCalculationBehavior' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashSpeed) == 0x000088, "Member 'UHWGameplayDash::DashSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashMaxSpeed) == 0x00008C, "Member 'UHWGameplayDash::DashMaxSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bAffectedByDiminishingSpeed) == 0x000090, "Member 'UHWGameplayDash::bAffectedByDiminishingSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashMinimumSpeed) == 0x000094, "Member 'UHWGameplayDash::DashMinimumSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, AccelerationBehavior) == 0x000098, "Member 'UHWGameplayDash::AccelerationBehavior' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashAcceleration) == 0x00009C, "Member 'UHWGameplayDash::DashAcceleration' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, AccelerationTime) == 0x0000A0, "Member 'UHWGameplayDash::AccelerationTime' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, CalculatedAcceleration) == 0x0000A4, "Member 'UHWGameplayDash::CalculatedAcceleration' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, AttackAimDataHandle) == 0x0000A8, "Member 'UHWGameplayDash::AttackAimDataHandle' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, AccelerationStartingSpeedBehavior) == 0x0000D0, "Member 'UHWGameplayDash::AccelerationStartingSpeedBehavior' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, StartingDashSpeed) == 0x0000D4, "Member 'UHWGameplayDash::StartingDashSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, CalculatedStartingSpeed) == 0x0000D8, "Member 'UHWGameplayDash::CalculatedStartingSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, LastCalculatedDashSpeed) == 0x0000DC, "Member 'UHWGameplayDash::LastCalculatedDashSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashDistance) == 0x0000E0, "Member 'UHWGameplayDash::DashDistance' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashDuration) == 0x0000E4, "Member 'UHWGameplayDash::DashDuration' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bClampSpeedOnDashEnd) == 0x0000E8, "Member 'UHWGameplayDash::bClampSpeedOnDashEnd' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bClampToMaxWalkSpeedOnDashEnd) == 0x0000E9, "Member 'UHWGameplayDash::bClampToMaxWalkSpeedOnDashEnd' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, ClampSpeedDashEndOverride) == 0x0000EC, "Member 'UHWGameplayDash::ClampSpeedDashEndOverride' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bAllowEndingAtInvalidGroundLocation) == 0x0000F0, "Member 'UHWGameplayDash::bAllowEndingAtInvalidGroundLocation' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bAffectedByGravity) == 0x0000F1, "Member 'UHWGameplayDash::bAffectedByGravity' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bAllowVerticalDashMovement) == 0x0000F2, "Member 'UHWGameplayDash::bAllowVerticalDashMovement' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bRotationMatchesVelocity) == 0x0000F3, "Member 'UHWGameplayDash::bRotationMatchesVelocity' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bCanBeInterruptedByKnockback) == 0x0000F4, "Member 'UHWGameplayDash::bCanBeInterruptedByKnockback' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashBehaviorOnInterrupted) == 0x0000F5, "Member 'UHWGameplayDash::DashBehaviorOnInterrupted' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bShouldMatchDashDirectionOnDashStart) == 0x0000F6, "Member 'UHWGameplayDash::bShouldMatchDashDirectionOnDashStart' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, EndTime) == 0x0000F8, "Member 'UHWGameplayDash::EndTime' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, CharacterStartingRotation) == 0x000100, "Member 'UHWGameplayDash::CharacterStartingRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, CharacterRotationOffset) == 0x000118, "Member 'UHWGameplayDash::CharacterRotationOffset' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, CharacterStartingLocation) == 0x000130, "Member 'UHWGameplayDash::CharacterStartingLocation' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bIgnoreClientCorrections) == 0x000148, "Member 'UHWGameplayDash::bIgnoreClientCorrections' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bUsesClientAuthoritativeMovement) == 0x000149, "Member 'UHWGameplayDash::bUsesClientAuthoritativeMovement' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, TurningDegreesPerSecond) == 0x00014C, "Member 'UHWGameplayDash::TurningDegreesPerSecond' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashCollisionProxy) == 0x000150, "Member 'UHWGameplayDash::DashCollisionProxy' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bIsCollisionEndingDash) == 0x000158, "Member 'UHWGameplayDash::bIsCollisionEndingDash' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashEndInfo) == 0x000160, "Member 'UHWGameplayDash::DashEndInfo' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashCollisionType) == 0x000290, "Member 'UHWGameplayDash::DashCollisionType' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, DashingCollision) == 0x000298, "Member 'UHWGameplayDash::DashingCollision' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bServerDrivesCollisionDashEnding) == 0x000428, "Member 'UHWGameplayDash::bServerDrivesCollisionDashEnding' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bShouldStopOnWorld) == 0x000429, "Member 'UHWGameplayDash::bShouldStopOnWorld' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bShouldStopOnCharacter) == 0x00042A, "Member 'UHWGameplayDash::bShouldStopOnCharacter' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bOnlyStopOnAITarget) == 0x00042B, "Member 'UHWGameplayDash::bOnlyStopOnAITarget' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bPredictsCollisions) == 0x00042C, "Member 'UHWGameplayDash::bPredictsCollisions' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, MeshCollisionBounds) == 0x000430, "Member 'UHWGameplayDash::MeshCollisionBounds' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bCollectDashHits) == 0x000468, "Member 'UHWGameplayDash::bCollectDashHits' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, CharacterStopTargetFilter) == 0x000470, "Member 'UHWGameplayDash::CharacterStopTargetFilter' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, PushedCollisionState) == 0x000640, "Member 'UHWGameplayDash::PushedCollisionState' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bClientCalledServerEndDashCollided) == 0x00067C, "Member 'UHWGameplayDash::bClientCalledServerEndDashCollided' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, OnDashStartedDelegate) == 0x000680, "Member 'UHWGameplayDash::OnDashStartedDelegate' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, OnDashEndedDelegate) == 0x000690, "Member 'UHWGameplayDash::OnDashEndedDelegate' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bIsDashActive) == 0x0006A0, "Member 'UHWGameplayDash::bIsDashActive' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bDashTimerStarted) == 0x0006A1, "Member 'UHWGameplayDash::bDashTimerStarted' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, bLocationIsInvalid) == 0x0006A2, "Member 'UHWGameplayDash::bLocationIsInvalid' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, ExtendedDashDistance) == 0x0006A4, "Member 'UHWGameplayDash::ExtendedDashDistance' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, CancelTags) == 0x0006B0, "Member 'UHWGameplayDash::CancelTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, BlockTags) == 0x000710, "Member 'UHWGameplayDash::BlockTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, TagsToApplyWhileDashing) == 0x000770, "Member 'UHWGameplayDash::TagsToApplyWhileDashing' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, EffectsToApplyWhileDashing) == 0x0007D0, "Member 'UHWGameplayDash::EffectsToApplyWhileDashing' has a wrong offset!");
static_assert(offsetof(UHWGameplayDash, EffectsAppliedWhileDashing) == 0x0007E0, "Member 'UHWGameplayDash::EffectsAppliedWhileDashing' has a wrong offset!");

// Class Hemingway.HWGameplayMountedDash
// 0x0010 (0x0800 - 0x07F0)
class UHWGameplayMountedDash final : public UHWGameplayDash
{
public:
	float                                         BaseSpeedModifierPercent;                          // 0x07F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackpedalSpeedModifierPercent;                     // 0x07F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurningSpeedModifierPercent;                       // 0x07F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7FC[0x4];                                      // 0x07FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayMountedDash">();
	}
	static class UHWGameplayMountedDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayMountedDash>();
	}
};
static_assert(alignof(UHWGameplayMountedDash) == 0x000008, "Wrong alignment on UHWGameplayMountedDash");
static_assert(sizeof(UHWGameplayMountedDash) == 0x000800, "Wrong size on UHWGameplayMountedDash");
static_assert(offsetof(UHWGameplayMountedDash, BaseSpeedModifierPercent) == 0x0007F0, "Member 'UHWGameplayMountedDash::BaseSpeedModifierPercent' has a wrong offset!");
static_assert(offsetof(UHWGameplayMountedDash, BackpedalSpeedModifierPercent) == 0x0007F4, "Member 'UHWGameplayMountedDash::BackpedalSpeedModifierPercent' has a wrong offset!");
static_assert(offsetof(UHWGameplayMountedDash, TurningSpeedModifierPercent) == 0x0007F8, "Member 'UHWGameplayMountedDash::TurningSpeedModifierPercent' has a wrong offset!");

// Class Hemingway.HWGameplayCueNotify_Polymorph
// 0x0020 (0x0388 - 0x0368)
class AHWGameplayCueNotify_Polymorph : public AHWGameplayCueNotify_Actor
{
public:
	class USkeletalMesh*                          DefaultMeshToApply;                                // 0x0368(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 AnimInstanceClassRef;                              // 0x0370(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkinAnimInstance;                                 // 0x0378(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MeshAssetLookupName;                               // 0x037C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_Polymorph">();
	}
	static class AHWGameplayCueNotify_Polymorph* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameplayCueNotify_Polymorph>();
	}
};
static_assert(alignof(AHWGameplayCueNotify_Polymorph) == 0x000008, "Wrong alignment on AHWGameplayCueNotify_Polymorph");
static_assert(sizeof(AHWGameplayCueNotify_Polymorph) == 0x000388, "Wrong size on AHWGameplayCueNotify_Polymorph");
static_assert(offsetof(AHWGameplayCueNotify_Polymorph, DefaultMeshToApply) == 0x000368, "Member 'AHWGameplayCueNotify_Polymorph::DefaultMeshToApply' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Polymorph, AnimInstanceClassRef) == 0x000370, "Member 'AHWGameplayCueNotify_Polymorph::AnimInstanceClassRef' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Polymorph, bSkinAnimInstance) == 0x000378, "Member 'AHWGameplayCueNotify_Polymorph::bSkinAnimInstance' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Polymorph, MeshAssetLookupName) == 0x00037C, "Member 'AHWGameplayCueNotify_Polymorph::MeshAssetLookupName' has a wrong offset!");

// Class Hemingway.HWGameplayCueNotify_WithMesh
// 0x00D8 (0x0440 - 0x0368)
class AHWGameplayCueNotify_WithMesh final : public AHWGameplayCueNotify_Actor
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             MyTransform;                                       // 0x0370(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 AnimBlueprintClass;                                // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWSkeletalMeshComponent*               SkeletalMeshComponent;                             // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MeshSkinKeyword;                                   // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             MaterialSkinningPrefixes;                          // 0x03E8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_LoadComplete();
	void EndWithMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_WithMesh">();
	}
	static class AHWGameplayCueNotify_WithMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameplayCueNotify_WithMesh>();
	}
};
static_assert(alignof(AHWGameplayCueNotify_WithMesh) == 0x000010, "Wrong alignment on AHWGameplayCueNotify_WithMesh");
static_assert(sizeof(AHWGameplayCueNotify_WithMesh) == 0x000440, "Wrong size on AHWGameplayCueNotify_WithMesh");
static_assert(offsetof(AHWGameplayCueNotify_WithMesh, SkeletalMesh) == 0x000368, "Member 'AHWGameplayCueNotify_WithMesh::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_WithMesh, MyTransform) == 0x000370, "Member 'AHWGameplayCueNotify_WithMesh::MyTransform' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_WithMesh, AnimBlueprintClass) == 0x0003D0, "Member 'AHWGameplayCueNotify_WithMesh::AnimBlueprintClass' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_WithMesh, SkeletalMeshComponent) == 0x0003D8, "Member 'AHWGameplayCueNotify_WithMesh::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_WithMesh, MeshSkinKeyword) == 0x0003E0, "Member 'AHWGameplayCueNotify_WithMesh::MeshSkinKeyword' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_WithMesh, MaterialSkinningPrefixes) == 0x0003E8, "Member 'AHWGameplayCueNotify_WithMesh::MaterialSkinningPrefixes' has a wrong offset!");

// Class Hemingway.HWGameplayEffectComponent
// 0x0000 (0x0028 - 0x0028)
class UHWGameplayEffectComponent : public UGameplayEffectComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffectComponent">();
	}
	static class UHWGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffectComponent>();
	}
};
static_assert(alignof(UHWGameplayEffectComponent) == 0x000008, "Wrong alignment on UHWGameplayEffectComponent");
static_assert(sizeof(UHWGameplayEffectComponent) == 0x000028, "Wrong size on UHWGameplayEffectComponent");

// Class Hemingway.HWGEMMC_CharacterBaseStat
// 0x0008 (0x0048 - 0x0040)
class UHWGEMMC_CharacterBaseStat final : public UHWGEModiferMagnitudeCalc_Base
{
public:
	struct FGameplayTag                           StatTag;                                           // 0x0040(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEMMC_CharacterBaseStat">();
	}
	static class UHWGEMMC_CharacterBaseStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEMMC_CharacterBaseStat>();
	}
};
static_assert(alignof(UHWGEMMC_CharacterBaseStat) == 0x000008, "Wrong alignment on UHWGEMMC_CharacterBaseStat");
static_assert(sizeof(UHWGEMMC_CharacterBaseStat) == 0x000048, "Wrong size on UHWGEMMC_CharacterBaseStat");
static_assert(offsetof(UHWGEMMC_CharacterBaseStat, StatTag) == 0x000040, "Member 'UHWGEMMC_CharacterBaseStat::StatTag' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_ShieldModifier
// 0x0028 (0x0AE0 - 0x0AB8)
class UHWGameplayEffect_ShieldModifier : public UHWGameplayEffect
{
public:
	TArray<struct FGameplayEffectModifierMagnitude> ShieldHealthDeltaFactors;                        // 0x0AB8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectModifierMagnitude> ShieldLifetimeDeltaFactors;                      // 0x0AC8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ShieldEffectTag;                                   // 0x0AD8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FGameplayTag GetShieldEffectTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_ShieldModifier">();
	}
	static class UHWGameplayEffect_ShieldModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_ShieldModifier>();
	}
};
static_assert(alignof(UHWGameplayEffect_ShieldModifier) == 0x000008, "Wrong alignment on UHWGameplayEffect_ShieldModifier");
static_assert(sizeof(UHWGameplayEffect_ShieldModifier) == 0x000AE0, "Wrong size on UHWGameplayEffect_ShieldModifier");
static_assert(offsetof(UHWGameplayEffect_ShieldModifier, ShieldHealthDeltaFactors) == 0x000AB8, "Member 'UHWGameplayEffect_ShieldModifier::ShieldHealthDeltaFactors' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_ShieldModifier, ShieldLifetimeDeltaFactors) == 0x000AC8, "Member 'UHWGameplayEffect_ShieldModifier::ShieldLifetimeDeltaFactors' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_ShieldModifier, ShieldEffectTag) == 0x000AD8, "Member 'UHWGameplayEffect_ShieldModifier::ShieldEffectTag' has a wrong offset!");

// Class Hemingway.HWGameplayEffectComponent_Quest
// 0x0008 (0x0030 - 0x0028)
class UHWGameplayEffectComponent_Quest final : public UHWGameplayEffectComponent
{
public:
	struct FGameplayTag                           QuestTag;                                          // 0x0028(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffectComponent_Quest">();
	}
	static class UHWGameplayEffectComponent_Quest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffectComponent_Quest>();
	}
};
static_assert(alignof(UHWGameplayEffectComponent_Quest) == 0x000008, "Wrong alignment on UHWGameplayEffectComponent_Quest");
static_assert(sizeof(UHWGameplayEffectComponent_Quest) == 0x000030, "Wrong size on UHWGameplayEffectComponent_Quest");
static_assert(offsetof(UHWGameplayEffectComponent_Quest, QuestTag) == 0x000028, "Member 'UHWGameplayEffectComponent_Quest::QuestTag' has a wrong offset!");

// Class Hemingway.HWGameplayEffectComponent_RemoveOnDamaged
// 0x0118 (0x0140 - 0x0028)
class UHWGameplayEffectComponent_RemoveOnDamaged final : public UHWGameplayEffectComponent
{
public:
	struct FGameplayTagRequirements               DamageAttackTagRequirements;                       // 0x0028(0x0088)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               DamageInstigatorTagRequirements;                   // 0x00B0(0x0088)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         RemovalGracePeriod;                                // 0x0138(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTargetDamaged(const struct FDamageEventData& DamageEventData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffectComponent_RemoveOnDamaged">();
	}
	static class UHWGameplayEffectComponent_RemoveOnDamaged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffectComponent_RemoveOnDamaged>();
	}
};
static_assert(alignof(UHWGameplayEffectComponent_RemoveOnDamaged) == 0x000008, "Wrong alignment on UHWGameplayEffectComponent_RemoveOnDamaged");
static_assert(sizeof(UHWGameplayEffectComponent_RemoveOnDamaged) == 0x000140, "Wrong size on UHWGameplayEffectComponent_RemoveOnDamaged");
static_assert(offsetof(UHWGameplayEffectComponent_RemoveOnDamaged, DamageAttackTagRequirements) == 0x000028, "Member 'UHWGameplayEffectComponent_RemoveOnDamaged::DamageAttackTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_RemoveOnDamaged, DamageInstigatorTagRequirements) == 0x0000B0, "Member 'UHWGameplayEffectComponent_RemoveOnDamaged::DamageInstigatorTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_RemoveOnDamaged, RemovalGracePeriod) == 0x000138, "Member 'UHWGameplayEffectComponent_RemoveOnDamaged::RemovalGracePeriod' has a wrong offset!");

// Class Hemingway.HWGameplayEffectComponent_SourceTagRequirements
// 0x0198 (0x01C0 - 0x0028)
class UHWGameplayEffectComponent_SourceTagRequirements final : public UHWGameplayEffectComponent
{
public:
	struct FGameplayTagRequirements               ApplicationTagRequirements;                        // 0x0028(0x0088)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               OngoingTagRequirements;                            // 0x00B0(0x0088)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               RemovalTagRequirements;                            // 0x0138(0x0088)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffectComponent_SourceTagRequirements">();
	}
	static class UHWGameplayEffectComponent_SourceTagRequirements* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffectComponent_SourceTagRequirements>();
	}
};
static_assert(alignof(UHWGameplayEffectComponent_SourceTagRequirements) == 0x000008, "Wrong alignment on UHWGameplayEffectComponent_SourceTagRequirements");
static_assert(sizeof(UHWGameplayEffectComponent_SourceTagRequirements) == 0x0001C0, "Wrong size on UHWGameplayEffectComponent_SourceTagRequirements");
static_assert(offsetof(UHWGameplayEffectComponent_SourceTagRequirements, ApplicationTagRequirements) == 0x000028, "Member 'UHWGameplayEffectComponent_SourceTagRequirements::ApplicationTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_SourceTagRequirements, OngoingTagRequirements) == 0x0000B0, "Member 'UHWGameplayEffectComponent_SourceTagRequirements::OngoingTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_SourceTagRequirements, RemovalTagRequirements) == 0x000138, "Member 'UHWGameplayEffectComponent_SourceTagRequirements::RemovalTagRequirements' has a wrong offset!");

// Class Hemingway.HWGameState_Arena
// 0x0160 (0x09D8 - 0x0878)
class AHWGameState_Arena : public AHWGameState
{
public:
	TMulticastInlineDelegate<void(const struct FGenericTeamId& Team)> TeamDefeated;                  // 0x0878(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            EndPhaseEffect;                                    // 0x0888(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGenericTeamId>                 TeamsInEndPhase;                                   // 0x0890(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(int32 Count)>   OnOrderTicketCountUpdated;                         // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Count)>   OnChaosTicketCountUpdated;                         // 0x08B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Count)>   OnMaxTicketCountUpdated;                           // 0x08C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Count)>   OnOrderGodKillsUpdated;                            // 0x08D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Count)>   OnChaosGodKillsUpdated;                            // 0x08E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Count)>   OnKillsToSpawnSiegeMinionUpdated;                  // 0x08F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         CatchupXPSetupTime;                                // 0x0900(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CatchupXPCheckInterval;                            // 0x0904(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CatchupXPMaxMemberCount;                           // 0x0908(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseBonusKillstreakReward;                         // 0x090C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusXPSpoolingEffect;                             // 0x0910(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OrderTickets;                                      // 0x0918(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChaosTickets;                                      // 0x091C(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxTickets;                                        // 0x0920(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OrderGodKills;                                     // 0x0924(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChaosGodKills;                                     // 0x0928(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KillsToSpawnSiegeMinion;                           // 0x092C(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_930[0x10];                                     // 0x0930(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 Team)>    OnSiegeMinionSpawned;                              // 0x0940(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USoundBase*                             OrderMinotaurSpawnedSfx;                           // 0x0950(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ChaosMinotaurSpawnedSfx;                           // 0x0958(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHWBotFactory*>                  MinotaurFactories;                                 // 0x0960(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	float                                         FireworksDelayTime;                                // 0x0970(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_974[0x4];                                      // 0x0974(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     FireworksClass;                                    // 0x0978(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         Fireworks;                                         // 0x0980(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_990[0x8];                                      // 0x0990(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class AHWPlayerState* Player)> OnKillstreakBonusAwardedDel;  // 0x0998(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AHWPlayerState* Killer, const class AHWPlayerState* Killed)> OnKillstreakBountyAwardedDel; // 0x09A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AHWPlayerState>>  GrantedKillstreakBonuses;                          // 0x09B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            KillstreakActiveEffect;                            // 0x09C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            KillstreakBountyEffect;                            // 0x09D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DeathstreakUpdated(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat);
	void HandlePhaseChanged(const struct FGameplayTag& NewPhase);
	void KillstreakUpdated(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat);
	void MulticastKillstreakBonusAwarded(const class AHWPlayerState* PlayerState);
	void MulticastKillstreakBountyAwarded(const class AHWPlayerState* KillerPlayer, const class AHWPlayerState* KilledPlayer);
	void MulticastPlayEndSequence(const struct FGenericTeamId& Team);
	void MulticastPlayFireworksSequence();
	void MulticastPlaySeigeMinionSpawnedSequence(const struct FGenericTeamId& Team, bool Border);
	void OnRep_ChaosGodKills();
	void OnRep_ChaosTickets();
	void OnRep_KillsToSpawnSiegeMinion();
	void OnRep_MaxTickets();
	void OnRep_OrderGodKills();
	void OnRep_OrderTickets();
	void PlayEndSequence(const struct FGenericTeamId& Team);
	void PlayerDied(class AHWTeamState* Team, class AHWPlayerState* TeamMember, const struct FDamageEventData& DeathEventData);
	void PlayFireworkVFX(class AActor* fireworkActor);
	void StartCatchupXPSpoolTimer();
	void UpdateCatchupXPSpooling();
	void UpdateTeamTickets(const struct FGenericTeamId& Team, int32 TicketsToDeduct);

	int32 GetChaosGodKills() const;
	int32 GetChaosTickets() const;
	int32 GetKillsToSpawnSiegeMinion() const;
	int32 GetMaxTickets() const;
	int32 GetOrderGodKills() const;
	int32 GetOrderTickets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameState_Arena">();
	}
	static class AHWGameState_Arena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameState_Arena>();
	}
};
static_assert(alignof(AHWGameState_Arena) == 0x000008, "Wrong alignment on AHWGameState_Arena");
static_assert(sizeof(AHWGameState_Arena) == 0x0009D8, "Wrong size on AHWGameState_Arena");
static_assert(offsetof(AHWGameState_Arena, TeamDefeated) == 0x000878, "Member 'AHWGameState_Arena::TeamDefeated' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, EndPhaseEffect) == 0x000888, "Member 'AHWGameState_Arena::EndPhaseEffect' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, TeamsInEndPhase) == 0x000890, "Member 'AHWGameState_Arena::TeamsInEndPhase' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OnOrderTicketCountUpdated) == 0x0008A0, "Member 'AHWGameState_Arena::OnOrderTicketCountUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OnChaosTicketCountUpdated) == 0x0008B0, "Member 'AHWGameState_Arena::OnChaosTicketCountUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OnMaxTicketCountUpdated) == 0x0008C0, "Member 'AHWGameState_Arena::OnMaxTicketCountUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OnOrderGodKillsUpdated) == 0x0008D0, "Member 'AHWGameState_Arena::OnOrderGodKillsUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OnChaosGodKillsUpdated) == 0x0008E0, "Member 'AHWGameState_Arena::OnChaosGodKillsUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OnKillsToSpawnSiegeMinionUpdated) == 0x0008F0, "Member 'AHWGameState_Arena::OnKillsToSpawnSiegeMinionUpdated' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, CatchupXPSetupTime) == 0x000900, "Member 'AHWGameState_Arena::CatchupXPSetupTime' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, CatchupXPCheckInterval) == 0x000904, "Member 'AHWGameState_Arena::CatchupXPCheckInterval' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, CatchupXPMaxMemberCount) == 0x000908, "Member 'AHWGameState_Arena::CatchupXPMaxMemberCount' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, BaseBonusKillstreakReward) == 0x00090C, "Member 'AHWGameState_Arena::BaseBonusKillstreakReward' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, BonusXPSpoolingEffect) == 0x000910, "Member 'AHWGameState_Arena::BonusXPSpoolingEffect' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OrderTickets) == 0x000918, "Member 'AHWGameState_Arena::OrderTickets' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, ChaosTickets) == 0x00091C, "Member 'AHWGameState_Arena::ChaosTickets' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, MaxTickets) == 0x000920, "Member 'AHWGameState_Arena::MaxTickets' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OrderGodKills) == 0x000924, "Member 'AHWGameState_Arena::OrderGodKills' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, ChaosGodKills) == 0x000928, "Member 'AHWGameState_Arena::ChaosGodKills' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, KillsToSpawnSiegeMinion) == 0x00092C, "Member 'AHWGameState_Arena::KillsToSpawnSiegeMinion' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OnSiegeMinionSpawned) == 0x000940, "Member 'AHWGameState_Arena::OnSiegeMinionSpawned' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OrderMinotaurSpawnedSfx) == 0x000950, "Member 'AHWGameState_Arena::OrderMinotaurSpawnedSfx' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, ChaosMinotaurSpawnedSfx) == 0x000958, "Member 'AHWGameState_Arena::ChaosMinotaurSpawnedSfx' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, MinotaurFactories) == 0x000960, "Member 'AHWGameState_Arena::MinotaurFactories' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, FireworksDelayTime) == 0x000970, "Member 'AHWGameState_Arena::FireworksDelayTime' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, FireworksClass) == 0x000978, "Member 'AHWGameState_Arena::FireworksClass' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, Fireworks) == 0x000980, "Member 'AHWGameState_Arena::Fireworks' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OnKillstreakBonusAwardedDel) == 0x000998, "Member 'AHWGameState_Arena::OnKillstreakBonusAwardedDel' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, OnKillstreakBountyAwardedDel) == 0x0009A8, "Member 'AHWGameState_Arena::OnKillstreakBountyAwardedDel' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, GrantedKillstreakBonuses) == 0x0009B8, "Member 'AHWGameState_Arena::GrantedKillstreakBonuses' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, KillstreakActiveEffect) == 0x0009C8, "Member 'AHWGameState_Arena::KillstreakActiveEffect' has a wrong offset!");
static_assert(offsetof(AHWGameState_Arena, KillstreakBountyEffect) == 0x0009D0, "Member 'AHWGameState_Arena::KillstreakBountyEffect' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Cooldown
// 0x0000 (0x0AB8 - 0x0AB8)
class UHWGameplayEffect_Cooldown : public UHWGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Cooldown">();
	}
	static class UHWGameplayEffect_Cooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Cooldown>();
	}
};
static_assert(alignof(UHWGameplayEffect_Cooldown) == 0x000008, "Wrong alignment on UHWGameplayEffect_Cooldown");
static_assert(sizeof(UHWGameplayEffect_Cooldown) == 0x000AB8, "Wrong size on UHWGameplayEffect_Cooldown");

// Class Hemingway.HWGameplayEffect_CC
// 0x0010 (0x0AC8 - 0x0AB8)
class UHWGameplayEffect_CC : public UHWGameplayEffect
{
public:
	uint8                                         Pad_AB8[0x8];                                      // 0x0AB8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DiminishingReturnStacks;                           // 0x0AC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC4[0x4];                                      // 0x0AC4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_CC">();
	}
	static class UHWGameplayEffect_CC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_CC>();
	}
};
static_assert(alignof(UHWGameplayEffect_CC) == 0x000008, "Wrong alignment on UHWGameplayEffect_CC");
static_assert(sizeof(UHWGameplayEffect_CC) == 0x000AC8, "Wrong size on UHWGameplayEffect_CC");
static_assert(offsetof(UHWGameplayEffect_CC, DiminishingReturnStacks) == 0x000AC0, "Member 'UHWGameplayEffect_CC::DiminishingReturnStacks' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Levitate
// 0x0008 (0x0AD0 - 0x0AC8)
class UHWGameplayEffect_Levitate final : public UHWGameplayEffect_CC
{
public:
	TSubclassOf<class UHWGameplayLevitate>        LevitationClass;                                   // 0x0AC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Levitate">();
	}
	static class UHWGameplayEffect_Levitate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Levitate>();
	}
};
static_assert(alignof(UHWGameplayEffect_Levitate) == 0x000008, "Wrong alignment on UHWGameplayEffect_Levitate");
static_assert(sizeof(UHWGameplayEffect_Levitate) == 0x000AD0, "Wrong size on UHWGameplayEffect_Levitate");
static_assert(offsetof(UHWGameplayEffect_Levitate, LevitationClass) == 0x000AC8, "Member 'UHWGameplayEffect_Levitate::LevitationClass' has a wrong offset!");

// Class Hemingway.HWSkinEvoEvalComponent
// 0x00A0 (0x0140 - 0x00A0)
class UHWSkinEvoEvalComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  StartingSkinTags;                                  // 0x00A8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SkinTagContainer;                                  // 0x00C8(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWSkinTagTypeEntry>            CurrentSkinTags;                                   // 0x00E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x48];                                      // 0x00F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnNewSkinTagAsset(TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset);
	void HandleOnSkinTagAssetRemoved(TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove);
	void HandleSkinItemUpdated(TScriptInterface<class IHWInterface_LoadoutManagement> LoadoutOwner, const class UHWSkinItem* NewSkinItem);
	bool SetSkinTag(const struct FGameplayTag& NewSkinTagValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinEvoEvalComponent">();
	}
	static class UHWSkinEvoEvalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSkinEvoEvalComponent>();
	}
};
static_assert(alignof(UHWSkinEvoEvalComponent) == 0x000008, "Wrong alignment on UHWSkinEvoEvalComponent");
static_assert(sizeof(UHWSkinEvoEvalComponent) == 0x000140, "Wrong size on UHWSkinEvoEvalComponent");
static_assert(offsetof(UHWSkinEvoEvalComponent, StartingSkinTags) == 0x0000A8, "Member 'UHWSkinEvoEvalComponent::StartingSkinTags' has a wrong offset!");
static_assert(offsetof(UHWSkinEvoEvalComponent, SkinTagContainer) == 0x0000C8, "Member 'UHWSkinEvoEvalComponent::SkinTagContainer' has a wrong offset!");
static_assert(offsetof(UHWSkinEvoEvalComponent, CurrentSkinTags) == 0x0000E8, "Member 'UHWSkinEvoEvalComponent::CurrentSkinTags' has a wrong offset!");

// Class Hemingway.HWGEMMC_Morrigan_A04_Cooldown
// 0x0000 (0x00B0 - 0x00B0)
class UHWGEMMC_Morrigan_A04_Cooldown final : public UHWGEMMC_Cooldown
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEMMC_Morrigan_A04_Cooldown">();
	}
	static class UHWGEMMC_Morrigan_A04_Cooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEMMC_Morrigan_A04_Cooldown>();
	}
};
static_assert(alignof(UHWGEMMC_Morrigan_A04_Cooldown) == 0x000008, "Wrong alignment on UHWGEMMC_Morrigan_A04_Cooldown");
static_assert(sizeof(UHWGEMMC_Morrigan_A04_Cooldown) == 0x0000B0, "Wrong size on UHWGEMMC_Morrigan_A04_Cooldown");

// Class Hemingway.HWVisibilityComponent
// 0x0200 (0x02A0 - 0x00A0)
class UHWVisibilityComponent : public UHWActorComponent
{
public:
	TMulticastInlineDelegate<void(class UHWVisibilityComponent* VisibilityComponent)> OnLocalOwnerVisibilityUpdate; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWVisibilityComponent* NewlyVisibleEnemyVisComp)> OnIntroducedTeamVisionOnNewTarget; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UVisibilityData*>                VisibilityDataList;                                // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWEffectsGrantingVisionForIndividualList EffectsGrantingVisionToIndividualsList;         // 0x00E8(0x0118)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bAlwaysVisible;                                    // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMeshVisible;                                      // 0x0201(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNameplateOverlayVisible;                          // 0x0202(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBecameRelevantWhileDead;                          // 0x0203(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204[0x2C];                                     // 0x0204(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericTeamId                         CachedGenericTeamId;                               // 0x0230(0x0001)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWVisibilityComponent* VisibilityComponent)> OnLocalOwnerMinimapUpdate; // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldMinimapLogicObserve;                        // 0x0258(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimapVisibilityMask;                             // 0x025C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapViewRange;                                  // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldViewRangeOverrideTargetRevealRange;         // 0x0264(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimapRevealRange;                                // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMinimapVisibleToLocalOwner;                       // 0x026C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumSkippedEvaluations;                             // 0x026D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26E[0x2];                                      // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UHWVisibilityComponent>> LastVisionSources;                          // 0x0270(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWVisibilityComponent* VisibilityComponent)> OnLocalOwnerFieldOfViewUpdate; // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ViewConeBackwardsOffset;                           // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewConeMinDotProduct;                             // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInLocalPlayerFieldOfView;                         // 0x0298(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bProximityVisible;                                 // 0x0299(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowDebugDrawing;                                 // 0x029A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B[0x5];                                      // 0x029B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocalPlayerStateChanged(class AHWPlayerState* HWPlayerState);
	void OnLocalTeamChanged(class AController* Controller, const struct FGenericTeamId& TeamId);
	void OnRep_EffectsGrantingVisionToIndividualsList();
	void OnUpdateMinimapVisibilityMask();
	void UpdateVisibility();

	bool IsMeshStealthedForTarget(const class AActor* TargetActor) const;
	bool IsMinimapVisibleToTeam(const struct FGenericTeamId& TeamId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVisibilityComponent">();
	}
	static class UHWVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVisibilityComponent>();
	}
};
static_assert(alignof(UHWVisibilityComponent) == 0x000008, "Wrong alignment on UHWVisibilityComponent");
static_assert(sizeof(UHWVisibilityComponent) == 0x0002A0, "Wrong size on UHWVisibilityComponent");
static_assert(offsetof(UHWVisibilityComponent, OnLocalOwnerVisibilityUpdate) == 0x0000A0, "Member 'UHWVisibilityComponent::OnLocalOwnerVisibilityUpdate' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, OnIntroducedTeamVisionOnNewTarget) == 0x0000B0, "Member 'UHWVisibilityComponent::OnIntroducedTeamVisionOnNewTarget' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, VisibilityDataList) == 0x0000C0, "Member 'UHWVisibilityComponent::VisibilityDataList' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, EffectsGrantingVisionToIndividualsList) == 0x0000E8, "Member 'UHWVisibilityComponent::EffectsGrantingVisionToIndividualsList' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, bAlwaysVisible) == 0x000200, "Member 'UHWVisibilityComponent::bAlwaysVisible' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, bMeshVisible) == 0x000201, "Member 'UHWVisibilityComponent::bMeshVisible' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, bNameplateOverlayVisible) == 0x000202, "Member 'UHWVisibilityComponent::bNameplateOverlayVisible' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, bBecameRelevantWhileDead) == 0x000203, "Member 'UHWVisibilityComponent::bBecameRelevantWhileDead' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, CachedGenericTeamId) == 0x000230, "Member 'UHWVisibilityComponent::CachedGenericTeamId' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, OnLocalOwnerMinimapUpdate) == 0x000238, "Member 'UHWVisibilityComponent::OnLocalOwnerMinimapUpdate' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, bShouldMinimapLogicObserve) == 0x000258, "Member 'UHWVisibilityComponent::bShouldMinimapLogicObserve' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, MinimapVisibilityMask) == 0x00025C, "Member 'UHWVisibilityComponent::MinimapVisibilityMask' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, MinimapViewRange) == 0x000260, "Member 'UHWVisibilityComponent::MinimapViewRange' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, bShouldViewRangeOverrideTargetRevealRange) == 0x000264, "Member 'UHWVisibilityComponent::bShouldViewRangeOverrideTargetRevealRange' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, MinimapRevealRange) == 0x000268, "Member 'UHWVisibilityComponent::MinimapRevealRange' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, bMinimapVisibleToLocalOwner) == 0x00026C, "Member 'UHWVisibilityComponent::bMinimapVisibleToLocalOwner' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, NumSkippedEvaluations) == 0x00026D, "Member 'UHWVisibilityComponent::NumSkippedEvaluations' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, LastVisionSources) == 0x000270, "Member 'UHWVisibilityComponent::LastVisionSources' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, OnLocalOwnerFieldOfViewUpdate) == 0x000280, "Member 'UHWVisibilityComponent::OnLocalOwnerFieldOfViewUpdate' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, ViewConeBackwardsOffset) == 0x000290, "Member 'UHWVisibilityComponent::ViewConeBackwardsOffset' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, ViewConeMinDotProduct) == 0x000294, "Member 'UHWVisibilityComponent::ViewConeMinDotProduct' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, bInLocalPlayerFieldOfView) == 0x000298, "Member 'UHWVisibilityComponent::bInLocalPlayerFieldOfView' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, bProximityVisible) == 0x000299, "Member 'UHWVisibilityComponent::bProximityVisible' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent, bShowDebugDrawing) == 0x00029A, "Member 'UHWVisibilityComponent::bShowDebugDrawing' has a wrong offset!");

// Class Hemingway.HWGetGud
// 0x00F8 (0x0120 - 0x0028)
class UHWGetGud final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PrivateKey;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TitleId;                                           // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GGameGuid;                                         // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GMatchGuid;                                        // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0xB8];                                      // 0x0068(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGetGud">();
	}
	static class UHWGetGud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGetGud>();
	}
};
static_assert(alignof(UHWGetGud) == 0x000008, "Wrong alignment on UHWGetGud");
static_assert(sizeof(UHWGetGud) == 0x000120, "Wrong size on UHWGetGud");
static_assert(offsetof(UHWGetGud, PrivateKey) == 0x000030, "Member 'UHWGetGud::PrivateKey' has a wrong offset!");
static_assert(offsetof(UHWGetGud, TitleId) == 0x000040, "Member 'UHWGetGud::TitleId' has a wrong offset!");
static_assert(offsetof(UHWGetGud, GGameGuid) == 0x000048, "Member 'UHWGetGud::GGameGuid' has a wrong offset!");
static_assert(offsetof(UHWGetGud, GMatchGuid) == 0x000058, "Member 'UHWGetGud::GMatchGuid' has a wrong offset!");

// Class Hemingway.HWInputModifierLookEnabledIgnore
// 0x0020 (0x0048 - 0x0028)
class UHWInputModifierLookEnabledIgnore final : public UInputModifier
{
public:
	float                                         AngleToUnlock;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagnitudeToUnlock;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToUnlock;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedStartingAngle;                               // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CachedStartingMagnitude;                           // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisablingInput;                                   // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimerHandle;                                       // 0x0040(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInputModifierLookEnabledIgnore">();
	}
	static class UHWInputModifierLookEnabledIgnore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInputModifierLookEnabledIgnore>();
	}
};
static_assert(alignof(UHWInputModifierLookEnabledIgnore) == 0x000008, "Wrong alignment on UHWInputModifierLookEnabledIgnore");
static_assert(sizeof(UHWInputModifierLookEnabledIgnore) == 0x000048, "Wrong size on UHWInputModifierLookEnabledIgnore");
static_assert(offsetof(UHWInputModifierLookEnabledIgnore, AngleToUnlock) == 0x000028, "Member 'UHWInputModifierLookEnabledIgnore::AngleToUnlock' has a wrong offset!");
static_assert(offsetof(UHWInputModifierLookEnabledIgnore, MagnitudeToUnlock) == 0x00002C, "Member 'UHWInputModifierLookEnabledIgnore::MagnitudeToUnlock' has a wrong offset!");
static_assert(offsetof(UHWInputModifierLookEnabledIgnore, TimeToUnlock) == 0x000030, "Member 'UHWInputModifierLookEnabledIgnore::TimeToUnlock' has a wrong offset!");
static_assert(offsetof(UHWInputModifierLookEnabledIgnore, CachedStartingAngle) == 0x000034, "Member 'UHWInputModifierLookEnabledIgnore::CachedStartingAngle' has a wrong offset!");
static_assert(offsetof(UHWInputModifierLookEnabledIgnore, CachedStartingMagnitude) == 0x000038, "Member 'UHWInputModifierLookEnabledIgnore::CachedStartingMagnitude' has a wrong offset!");
static_assert(offsetof(UHWInputModifierLookEnabledIgnore, bDisablingInput) == 0x00003C, "Member 'UHWInputModifierLookEnabledIgnore::bDisablingInput' has a wrong offset!");
static_assert(offsetof(UHWInputModifierLookEnabledIgnore, TimerHandle) == 0x000040, "Member 'UHWInputModifierLookEnabledIgnore::TimerHandle' has a wrong offset!");

// Class Hemingway.HWControlModule
// 0x0010 (0x00B0 - 0x00A0)
class UHWControlModule : public UHWActorComponent
{
public:
	TArray<uint32>                                BoundInputHandles;                                 // 0x00A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWControlModule">();
	}
	static class UHWControlModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWControlModule>();
	}
};
static_assert(alignof(UHWControlModule) == 0x000008, "Wrong alignment on UHWControlModule");
static_assert(sizeof(UHWControlModule) == 0x0000B0, "Wrong size on UHWControlModule");
static_assert(offsetof(UHWControlModule, BoundInputHandles) == 0x0000A0, "Member 'UHWControlModule::BoundInputHandles' has a wrong offset!");

// Class Hemingway.HWControlModule_DeathSpectator
// 0x0038 (0x00E8 - 0x00B0)
class UHWControlModule_DeathSpectator final : public UHWControlModule
{
public:
	TArray<TWeakObjectPtr<class AHWPlayerState>>  SpectatePlayerViewTargetList;                      // 0x00B0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AHWBotFactory>>   SpectateStructureViewTargetList;                   // 0x00C0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FHWSpectateTargetIndexInfo             CurrentSpectateTargetInfo;                         // 0x00D0(0x0008)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWBotFactory>           SpectatedStructureFactory;                         // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWPlayerState>          SpectatedPlayerState;                              // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GenerateSpectateViewTargetList();
	void GoToNextSpectateTarget(bool bWasDeath);
	void GoToPrevSpectateTarget();
	void OnRep_CurrentSpectateTargetInfo(const struct FHWSpectateTargetIndexInfo& PreviousSpectateTargetInfo);
	void OnSpectateTargetBotsSet(class AHWBotFactory* BotFactory);
	void OnSpectateTargetCanSpectateStatusChanged(class AHWCharacter_Base* Character, const bool bCanSpectate);
	void OnSpectatingTargetPawnSet(class APlayerState* SetPlayerState, class APawn* NewlySetPawn, class APawn* PreviousPawn);
	void OnTeamChanged(class AController* Controller, const struct FGenericTeamId& TeamId);
	void RecalcSpectateViewTarget();
	void ServerSetSpectatorTarget(int32 DesiredSpectateIndex, bool bWasDeath);

	class AHWCharacter_Base* GetSpectatorViewTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWControlModule_DeathSpectator">();
	}
	static class UHWControlModule_DeathSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWControlModule_DeathSpectator>();
	}
};
static_assert(alignof(UHWControlModule_DeathSpectator) == 0x000008, "Wrong alignment on UHWControlModule_DeathSpectator");
static_assert(sizeof(UHWControlModule_DeathSpectator) == 0x0000E8, "Wrong size on UHWControlModule_DeathSpectator");
static_assert(offsetof(UHWControlModule_DeathSpectator, SpectatePlayerViewTargetList) == 0x0000B0, "Member 'UHWControlModule_DeathSpectator::SpectatePlayerViewTargetList' has a wrong offset!");
static_assert(offsetof(UHWControlModule_DeathSpectator, SpectateStructureViewTargetList) == 0x0000C0, "Member 'UHWControlModule_DeathSpectator::SpectateStructureViewTargetList' has a wrong offset!");
static_assert(offsetof(UHWControlModule_DeathSpectator, CurrentSpectateTargetInfo) == 0x0000D0, "Member 'UHWControlModule_DeathSpectator::CurrentSpectateTargetInfo' has a wrong offset!");
static_assert(offsetof(UHWControlModule_DeathSpectator, SpectatedStructureFactory) == 0x0000D8, "Member 'UHWControlModule_DeathSpectator::SpectatedStructureFactory' has a wrong offset!");
static_assert(offsetof(UHWControlModule_DeathSpectator, SpectatedPlayerState) == 0x0000E0, "Member 'UHWControlModule_DeathSpectator::SpectatedPlayerState' has a wrong offset!");

// Class Hemingway.HWInterface_CC_Effect
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_CC_Effect final
{
public:
	bool CanApplyDiminishingReturns() const;
	bool CanBeAffectedByCrowdControlReduction() const;
	int32 GetDiminishingReturnStacks() const;
	bool IsHardCC() const;
	bool IsSoftCC() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_CC_Effect">();
	}
	static class IHWInterface_CC_Effect* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_CC_Effect>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_CC_Effect) == 0x000001, "Wrong alignment on IHWInterface_CC_Effect");
static_assert(sizeof(IHWInterface_CC_Effect) == 0x000001, "Wrong size on IHWInterface_CC_Effect");

// Class Hemingway.HWInterface_Damagable
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_Damagable final
{
public:
	void CustomDamageEventDataOverride(struct FDamageEventData& OutDamageEvent);
	void Die(const struct FDamageEventData& DeathDamageReceivedEvent);
	void OnDamageTaken(const struct FDamageEventData& DamageEvent);
	void OnHealed(const struct FHealEventData& HealEvent);

	bool CanBeAffectedByCrit() const;
	bool CanBeAffectedByLifeSteal() const;
	bool CanBeDamagedBy(const class AActor* SourceActor, const class UHWAbilitySystemComponent* SourceASC) const;
	float GetCritEffectiveness() const;
	float GetLifeStealEffectiveness() const;
	bool Interface_IsDead() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_Damagable">();
	}
	static class IHWInterface_Damagable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_Damagable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_Damagable) == 0x000001, "Wrong alignment on IHWInterface_Damagable");
static_assert(sizeof(IHWInterface_Damagable) == 0x000001, "Wrong size on IHWInterface_Damagable");

// Class Hemingway.HWInterface_Highlightable
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_Highlightable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_Highlightable">();
	}
	static class IHWInterface_Highlightable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_Highlightable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_Highlightable) == 0x000001, "Wrong alignment on IHWInterface_Highlightable");
static_assert(sizeof(IHWInterface_Highlightable) == 0x000001, "Wrong size on IHWInterface_Highlightable");

// Class Hemingway.HWAbility_Bellona_Passive
// 0x00A8 (0x0E18 - 0x0D70)
class UHWAbility_Bellona_Passive final : public UHWAbility_Passive
{
public:
	TWeakObjectPtr<class UHWInventoryManagerComponent> InventoryManagerComponent;                    // 0x0D70(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EHWBellonaInhandWeaponType, struct FHWInventorySlot> BellonaInhandWeaponTypeAndSlot;        // 0x0D78(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EHWBellonaInhandWeaponType                    CurrentEquippedWeaponType;                         // 0x0DC8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC9[0x3];                                      // 0x0DC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           BellonaA01AbilityTag;                              // 0x0DCC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           BellonaA02AbilityTag;                              // 0x0DD4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           BellonaA03AbilityTag;                              // 0x0DDC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE4[0x4];                                      // 0x0DE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BellonaInhandsTags;                                // 0x0DE8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ResetEquippedInhandTimerHandle;                    // 0x0E08(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResetEquippedInhandTime;                           // 0x0E10(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E14[0x4];                                      // 0x0E14(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateResetEquippedInhandTimer();
	void CheckAndResetEquippedInhand();
	void InitializeInhandWeaponSlotMap();
	void OnBellonaAbilityFire(const struct FGameplayAbilitySpecHandle& FiredAbilityHandle, const struct FGameplayTagContainer& FiredAbilityTags, const struct FHWAbilityFiringInstanceId& FiringInstanceId);
	void OnBellonaApplyDamageHit(const struct FHitResult& HitResult, const struct FDamageEventData& DamageEventData);
	void OnBellonaDamageTaken(const struct FDamageEventData& DamageEventData);
	void OnBellonaDied(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, float RespawnTimeDuration);
	void OnBellonaInhandActivate(class UGameplayAbility* ActivatedAbility);
	void OnBellonaInhandEndFire(const class UGameplayAbility* EndingAbility);
	void OnBellonaInhandRefire(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& BellonaAbilityTags);
	void SwapEquippedInhandWeapon(const EHWBellonaInhandWeaponType WeaponTypeToEquip);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Bellona_Passive">();
	}
	static class UHWAbility_Bellona_Passive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Bellona_Passive>();
	}
};
static_assert(alignof(UHWAbility_Bellona_Passive) == 0x000008, "Wrong alignment on UHWAbility_Bellona_Passive");
static_assert(sizeof(UHWAbility_Bellona_Passive) == 0x000E18, "Wrong size on UHWAbility_Bellona_Passive");
static_assert(offsetof(UHWAbility_Bellona_Passive, InventoryManagerComponent) == 0x000D70, "Member 'UHWAbility_Bellona_Passive::InventoryManagerComponent' has a wrong offset!");
static_assert(offsetof(UHWAbility_Bellona_Passive, BellonaInhandWeaponTypeAndSlot) == 0x000D78, "Member 'UHWAbility_Bellona_Passive::BellonaInhandWeaponTypeAndSlot' has a wrong offset!");
static_assert(offsetof(UHWAbility_Bellona_Passive, CurrentEquippedWeaponType) == 0x000DC8, "Member 'UHWAbility_Bellona_Passive::CurrentEquippedWeaponType' has a wrong offset!");
static_assert(offsetof(UHWAbility_Bellona_Passive, BellonaA01AbilityTag) == 0x000DCC, "Member 'UHWAbility_Bellona_Passive::BellonaA01AbilityTag' has a wrong offset!");
static_assert(offsetof(UHWAbility_Bellona_Passive, BellonaA02AbilityTag) == 0x000DD4, "Member 'UHWAbility_Bellona_Passive::BellonaA02AbilityTag' has a wrong offset!");
static_assert(offsetof(UHWAbility_Bellona_Passive, BellonaA03AbilityTag) == 0x000DDC, "Member 'UHWAbility_Bellona_Passive::BellonaA03AbilityTag' has a wrong offset!");
static_assert(offsetof(UHWAbility_Bellona_Passive, BellonaInhandsTags) == 0x000DE8, "Member 'UHWAbility_Bellona_Passive::BellonaInhandsTags' has a wrong offset!");
static_assert(offsetof(UHWAbility_Bellona_Passive, ResetEquippedInhandTimerHandle) == 0x000E08, "Member 'UHWAbility_Bellona_Passive::ResetEquippedInhandTimerHandle' has a wrong offset!");
static_assert(offsetof(UHWAbility_Bellona_Passive, ResetEquippedInhandTime) == 0x000E10, "Member 'UHWAbility_Bellona_Passive::ResetEquippedInhandTime' has a wrong offset!");

// Class Hemingway.HWInterface_Interactable
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_Interactable final
{
public:
	bool ShouldApplyInteractBlocker(const class AActor* OverlappedActor, const class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_Interactable">();
	}
	static class IHWInterface_Interactable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_Interactable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_Interactable) == 0x000001, "Wrong alignment on IHWInterface_Interactable");
static_assert(sizeof(IHWInterface_Interactable) == 0x000001, "Wrong size on IHWInterface_Interactable");

// Class Hemingway.HWInterface_Recycler
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_Recycler final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_Recycler">();
	}
	static class IHWInterface_Recycler* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_Recycler>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_Recycler) == 0x000001, "Wrong alignment on IHWInterface_Recycler");
static_assert(sizeof(IHWInterface_Recycler) == 0x000001, "Wrong size on IHWInterface_Recycler");

// Class Hemingway.HWDeployable_Danzaburou_A03
// 0x0080 (0x0548 - 0x04C8)
class AHWDeployable_Danzaburou_A03 final : public AHWDeployable
{
public:
	int32                                         DecoysSpawnCount;                                  // 0x04C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecoySpawnAngleOffset;                             // 0x04CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeUntilIllusionCanBreak;                         // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecoyLifetime;                                     // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AbilityTypesThatBreakIllusion;                     // 0x04D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           AllowBreakIllusionTimerHandle;                     // 0x04F8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHWSkeletalMeshActor>       LeafDecoyClass;                                    // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHWSkeletalMeshActor*>           SpawnedDecoys;                                     // 0x0508(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanBreakIllusion;                                 // 0x0518(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_519[0x7];                                      // 0x0519(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyInLeafState;                         // 0x0520(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    LeafStateEffectHandles;                            // 0x0530(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasExploded;                                      // 0x0540(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPreventExplosion;                                 // 0x0541(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_542[0x6];                                      // 0x0542(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateExplosionVisuals();
	void AllowBreakIllusion();
	void AttemptBreakIllusion();
	void BreakIllusion(const bool bInShouldDestroy);
	void DestroyLeafDecoys();
	void OnDanzaburouDamaged(const struct FDamageEventData& DamageEventData);
	void OnDanzaburouFired(const struct FGameplayAbilitySpecHandle& InSpecHandle, const struct FGameplayTagContainer& InTags, const struct FHWAbilityFiringInstanceId& InFiringInstanceId);
	void OnRep_HasExploded();
	void SpawnLeafDecoys();
	void TriggerExplosion();

	bool CanBreakIllusion() const;
	bool CanTriggerExplosion() const;
	bool IsDanzaburouFiringAttacks() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Danzaburou_A03">();
	}
	static class AHWDeployable_Danzaburou_A03* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Danzaburou_A03>();
	}
};
static_assert(alignof(AHWDeployable_Danzaburou_A03) == 0x000008, "Wrong alignment on AHWDeployable_Danzaburou_A03");
static_assert(sizeof(AHWDeployable_Danzaburou_A03) == 0x000548, "Wrong size on AHWDeployable_Danzaburou_A03");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, DecoysSpawnCount) == 0x0004C8, "Member 'AHWDeployable_Danzaburou_A03::DecoysSpawnCount' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, DecoySpawnAngleOffset) == 0x0004CC, "Member 'AHWDeployable_Danzaburou_A03::DecoySpawnAngleOffset' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, TimeUntilIllusionCanBreak) == 0x0004D0, "Member 'AHWDeployable_Danzaburou_A03::TimeUntilIllusionCanBreak' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, DecoyLifetime) == 0x0004D4, "Member 'AHWDeployable_Danzaburou_A03::DecoyLifetime' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, AbilityTypesThatBreakIllusion) == 0x0004D8, "Member 'AHWDeployable_Danzaburou_A03::AbilityTypesThatBreakIllusion' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, AllowBreakIllusionTimerHandle) == 0x0004F8, "Member 'AHWDeployable_Danzaburou_A03::AllowBreakIllusionTimerHandle' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, LeafDecoyClass) == 0x000500, "Member 'AHWDeployable_Danzaburou_A03::LeafDecoyClass' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, SpawnedDecoys) == 0x000508, "Member 'AHWDeployable_Danzaburou_A03::SpawnedDecoys' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, bCanBreakIllusion) == 0x000518, "Member 'AHWDeployable_Danzaburou_A03::bCanBreakIllusion' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, EffectsToApplyInLeafState) == 0x000520, "Member 'AHWDeployable_Danzaburou_A03::EffectsToApplyInLeafState' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, LeafStateEffectHandles) == 0x000530, "Member 'AHWDeployable_Danzaburou_A03::LeafStateEffectHandles' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, bHasExploded) == 0x000540, "Member 'AHWDeployable_Danzaburou_A03::bHasExploded' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Danzaburou_A03, bPreventExplosion) == 0x000541, "Member 'AHWDeployable_Danzaburou_A03::bPreventExplosion' has a wrong offset!");

// Class Hemingway.HWInterface_RefireableActor
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_RefireableActor final
{
public:
	void Refire();

	bool CanRefire() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_RefireableActor">();
	}
	static class IHWInterface_RefireableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_RefireableActor>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_RefireableActor) == 0x000001, "Wrong alignment on IHWInterface_RefireableActor");
static_assert(sizeof(IHWInterface_RefireableActor) == 0x000001, "Wrong size on IHWInterface_RefireableActor");

// Class Hemingway.HWInterface_TransformOverrideActor
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_TransformOverrideActor final
{
public:
	const struct FTransform GetCustomTransformOverride() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_TransformOverrideActor">();
	}
	static class IHWInterface_TransformOverrideActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_TransformOverrideActor>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_TransformOverrideActor) == 0x000001, "Wrong alignment on IHWInterface_TransformOverrideActor");
static_assert(sizeof(IHWInterface_TransformOverrideActor) == 0x000001, "Wrong size on IHWInterface_TransformOverrideActor");

// Class Hemingway.HWInteractable_Hecate_PSV
// 0x0088 (0x0320 - 0x0298)
class AHWInteractable_Hecate_PSV final : public AActor
{
public:
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHWAbility_Hecate_PSV>   PassiveAbility;                                    // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerInteractable;                             // 0x02B9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BA[0x2];                                      // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerInteractableLifetime;                        // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           LifetimeTimerHandle;                               // 0x02C0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWaitingForDestroy;                                // 0x02C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWInteractableComponent*               InteractComponent;                                 // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SkinTagContainer;                                  // 0x02D8(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x28];                                     // 0x02F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnNewSkinTagAsset(TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset);
	void HandleOnSkinTagAssetRemoved(TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove);
	void HandleTagUpdated_AttachedActorDied(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void OnInteractionCancelled(class UHWInteractableComponent* InInteractComponent, class AActor* InteractInstigator);
	void OnInteractionCompleted(class UHWInteractableComponent* InInteractComponent, class AActor* InteractInstigator);
	void OnLifetimeExpired();
	void OnRep_IsPlayerInteractable();
	void OnRep_SkinTagContainerChanged();
	void SwapSkinTags(const struct FGameplayTag& NewSkinTag, const struct FGameplayTag& OldSkinTag);

	bool CanBeActivated() const;
	const class UHWSkinItem* GetCurrentSkin() const;
	class AHWCharacter_Base* GetHecateOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInteractable_Hecate_PSV">();
	}
	static class AHWInteractable_Hecate_PSV* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWInteractable_Hecate_PSV>();
	}
};
static_assert(alignof(AHWInteractable_Hecate_PSV) == 0x000008, "Wrong alignment on AHWInteractable_Hecate_PSV");
static_assert(sizeof(AHWInteractable_Hecate_PSV) == 0x000320, "Wrong size on AHWInteractable_Hecate_PSV");
static_assert(offsetof(AHWInteractable_Hecate_PSV, PassiveAbility) == 0x0002B0, "Member 'AHWInteractable_Hecate_PSV::PassiveAbility' has a wrong offset!");
static_assert(offsetof(AHWInteractable_Hecate_PSV, bIsActive) == 0x0002B8, "Member 'AHWInteractable_Hecate_PSV::bIsActive' has a wrong offset!");
static_assert(offsetof(AHWInteractable_Hecate_PSV, bIsPlayerInteractable) == 0x0002B9, "Member 'AHWInteractable_Hecate_PSV::bIsPlayerInteractable' has a wrong offset!");
static_assert(offsetof(AHWInteractable_Hecate_PSV, PlayerInteractableLifetime) == 0x0002BC, "Member 'AHWInteractable_Hecate_PSV::PlayerInteractableLifetime' has a wrong offset!");
static_assert(offsetof(AHWInteractable_Hecate_PSV, LifetimeTimerHandle) == 0x0002C0, "Member 'AHWInteractable_Hecate_PSV::LifetimeTimerHandle' has a wrong offset!");
static_assert(offsetof(AHWInteractable_Hecate_PSV, bWaitingForDestroy) == 0x0002C8, "Member 'AHWInteractable_Hecate_PSV::bWaitingForDestroy' has a wrong offset!");
static_assert(offsetof(AHWInteractable_Hecate_PSV, InteractComponent) == 0x0002D0, "Member 'AHWInteractable_Hecate_PSV::InteractComponent' has a wrong offset!");
static_assert(offsetof(AHWInteractable_Hecate_PSV, SkinTagContainer) == 0x0002D8, "Member 'AHWInteractable_Hecate_PSV::SkinTagContainer' has a wrong offset!");

// Class Hemingway.HWInterface_VoiceComponent
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_VoiceComponent final
{
public:
	void TriggerLocalVoiceEvent(const struct FGameplayTag& VoiceEvent);

	class UHWVoiceComponent* GetVoiceComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_VoiceComponent">();
	}
	static class IHWInterface_VoiceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_VoiceComponent>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_VoiceComponent) == 0x000001, "Wrong alignment on IHWInterface_VoiceComponent");
static_assert(sizeof(IHWInterface_VoiceComponent) == 0x000001, "Wrong size on IHWInterface_VoiceComponent");

// Class Hemingway.HWLibrary_EquipmentSystem
// 0x0000 (0x0028 - 0x0028)
class UHWLibrary_EquipmentSystem final : public UBlueprintFunctionLibrary
{
public:
	static bool EqualEqual_FHWInventorySlot(const struct FHWInventorySlot& A, const struct FHWInventorySlot& B);
	static int32 GetEquipmentLevelFromEffectContext(const struct FGameplayEffectContextHandle& ContextHandle);
	static struct FHWInventorySlot GetInventorySlotFromAbility(const struct FGameplayAbilitySpecHandle& AbilityHandle, class UHWAbilitySystemComponent* OwningAbilitySystem);
	static bool NotEqual_FHWInventorySlot(const struct FHWInventorySlot& A, const struct FHWInventorySlot& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLibrary_EquipmentSystem">();
	}
	static class UHWLibrary_EquipmentSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLibrary_EquipmentSystem>();
	}
};
static_assert(alignof(UHWLibrary_EquipmentSystem) == 0x000008, "Wrong alignment on UHWLibrary_EquipmentSystem");
static_assert(sizeof(UHWLibrary_EquipmentSystem) == 0x000028, "Wrong size on UHWLibrary_EquipmentSystem");

// Class Hemingway.HWGameplayAbility_JingWei_A04
// 0x0070 (0x0DD0 - 0x0D60)
class UHWGameplayAbility_JingWei_A04 final : public UHWGameplayAbility_Enhanced
{
public:
	class UHWAbilityTask_WaitCastStyleInput*      LandingCastStyleInputTask;                         // 0x0D60(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityTask_WaitTargetData*          LandingTargetingTask;                              // 0x0D68(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AttacksToTargetWhenLanding;                        // 0x0D70(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bConfirmedLanding;                                 // 0x0D90(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForcedLanding;                                    // 0x0D91(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartedLandingTween;                              // 0x0D92(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D93[0x1];                                      // 0x0D93(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWCollisionState                      PushedCollisionState;                              // 0x0D94(0x003C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void BP_OnLandingTargetingCancelled(const struct FGameplayAbilityTargetDataHandle& TargetingData);
	void BP_OnLandingTargetingConfirmed(const struct FGameplayAbilityTargetDataHandle& TargetingData);
	void ForceConfirmLanding();
	struct FGameplayAbilityTargetDataHandle GetBackwardDeployableTargetData();
	struct FGameplayAbilityTargetDataHandle GetBackwardProjectileTargetData();
	struct FGameplayAbilityTargetDataHandle GetTweenBackwardTargetData();
	struct FGameplayAbilityTargetDataHandle GetTweenForwardTargetData();
	void OnLandingCastStyleCancelled(const float TimeElapsed, const bool bInputReleased);
	void OnLandingCastStyleConfirmed(const float TimeElapsed, const bool bInputReleased);
	void OnLandingTargetingCancelled(const struct FGameplayAbilityTargetDataHandle& TargetingData);
	void OnLandingTargetingConfirmed(const struct FGameplayAbilityTargetDataHandle& TargetingData);
	void PopDisabledCharacterCollisions();
	void PushDisabledCharacterCollisions();
	void StartLandingTasks();
	void StopLandingTasks();

	struct FGameplayAbilityTargetDataHandle GetForwardTargetData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayAbility_JingWei_A04">();
	}
	static class UHWGameplayAbility_JingWei_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayAbility_JingWei_A04>();
	}
};
static_assert(alignof(UHWGameplayAbility_JingWei_A04) == 0x000008, "Wrong alignment on UHWGameplayAbility_JingWei_A04");
static_assert(sizeof(UHWGameplayAbility_JingWei_A04) == 0x000DD0, "Wrong size on UHWGameplayAbility_JingWei_A04");
static_assert(offsetof(UHWGameplayAbility_JingWei_A04, LandingCastStyleInputTask) == 0x000D60, "Member 'UHWGameplayAbility_JingWei_A04::LandingCastStyleInputTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_JingWei_A04, LandingTargetingTask) == 0x000D68, "Member 'UHWGameplayAbility_JingWei_A04::LandingTargetingTask' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_JingWei_A04, AttacksToTargetWhenLanding) == 0x000D70, "Member 'UHWGameplayAbility_JingWei_A04::AttacksToTargetWhenLanding' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_JingWei_A04, bConfirmedLanding) == 0x000D90, "Member 'UHWGameplayAbility_JingWei_A04::bConfirmedLanding' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_JingWei_A04, bForcedLanding) == 0x000D91, "Member 'UHWGameplayAbility_JingWei_A04::bForcedLanding' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_JingWei_A04, bStartedLandingTween) == 0x000D92, "Member 'UHWGameplayAbility_JingWei_A04::bStartedLandingTween' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_JingWei_A04, PushedCollisionState) == 0x000D94, "Member 'UHWGameplayAbility_JingWei_A04::PushedCollisionState' has a wrong offset!");

// Class Hemingway.HWLocalPlayer
// 0x0008 (0x02C0 - 0x02B8)
class UHWLocalPlayer final : public URH_LocalPlayer
{
public:
	bool                                          bWantsSpectate;                                    // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLocalPlayer">();
	}
	static class UHWLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLocalPlayer>();
	}
};
static_assert(alignof(UHWLocalPlayer) == 0x000008, "Wrong alignment on UHWLocalPlayer");
static_assert(sizeof(UHWLocalPlayer) == 0x0002C0, "Wrong size on UHWLocalPlayer");
static_assert(offsetof(UHWLocalPlayer, bWantsSpectate) == 0x0002B8, "Member 'UHWLocalPlayer::bWantsSpectate' has a wrong offset!");

// Class Hemingway.HWMinimapManager
// 0x0020 (0x02B8 - 0x0298)
class AHWMinimapManager final : public AInfo
{
public:
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWMinimapManager">();
	}
	static class AHWMinimapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWMinimapManager>();
	}
};
static_assert(alignof(AHWMinimapManager) == 0x000008, "Wrong alignment on AHWMinimapManager");
static_assert(sizeof(AHWMinimapManager) == 0x0002B8, "Wrong size on AHWMinimapManager");

// Class Hemingway.HWPassiveMeterComponent
// 0x01C0 (0x0260 - 0x00A0)
class UHWPassiveMeterComponent : public UHWActorComponent
{
public:
	TArray<struct FGameplayAttribute>             GameplayAttributesToTrack;                         // 0x00A0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x98];                                      // 0x00B0(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalPips;                                         // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FilledPips;                                        // 0x014C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowMeter;                                        // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeterFill;                                         // 0x0154(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWPassiveMeterLargePipData            LargePipData;                                      // 0x0158(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x18];                                     // 0x0178(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWPassiveGameplayTagEvent             PassiveGameplayTagEvent;                           // 0x0190(0x000C)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0x34];                                     // 0x019C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWPassiveMeterDataField>       DataFields;                                        // 0x01D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UHWInventoryManagerComponent> OwningInventoryManager;                       // 0x01E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRegisterFamiliarListeners;                        // 0x01E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWActiveFamiliarInfo>          CurrentActiveFamiliars;                            // 0x01F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAttribute>             FamiliarGameplayAttributesToTrack;                 // 0x0200(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x50];                                     // 0x0210(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastGameplayTagEvent(const struct FGameplayTag& EventGameplayTag, const int32 Stack);
	void OnActiveFamiliarsUpdated(class UHWFamiliarManagerComponent* FamiliarManager);
	void OnFamiliarAdded(const struct FHWActiveFamiliarInfo& FamiliarInfo);
	void OnFamiliarManagerChanged(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class UHWFamiliarManagerComponent* NewFamiliarManager);
	void OnFamiliarRemoved(const struct FHWActiveFamiliarInfo& FamiliarInfo);
	void OnFamiliarTrackedAttributeChanged(const struct FHWActiveFamiliarInfo& FamiliarInfo, const struct FGameplayAttribute& GameplayAttribute, float OldValue, float NewValue);
	void OnInventoryManagerChanged(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class UHWInventoryManagerComponent* NewInventoryManager);
	void OnRep_FilledPips(int32 OldFilledPips);
	void OnRep_LargePipData(const struct FHWPassiveMeterLargePipData& OldLargePipData);
	void OnRep_MeterFill(float OldMeterFill);
	void OnRep_PassiveGameplayTagEvent();
	void OnTrackedAttributeChanged(const struct FGameplayAttribute& GameplayAttribute, float OldValue, float NewValue);
	void RemoveDataField(const struct FGameplayTag& InFieldTag);
	void SetDataField(const struct FHWPassiveMeterDataField& InDataField);
	void SetDataFieldFloatValue(const struct FGameplayTag& InFieldTag, const float InFloatValue, const float InFloatValue2);
	void SetDataFieldIntValue(const struct FGameplayTag& InFieldTag, const int32 InIntValue, const int32 InIntValue2);
	void SetDataFieldObjectValue(const struct FGameplayTag& InFieldTag, class UObject* InObject);
	void SetFilledPips(int32 InFilledPips);
	void SetLargePipData(struct FHWPassiveMeterLargePipData& InLargePipData);
	void SetMeterFill(float InMeterFill);

	class UHWAbilitySystemComponent* GetAbilitySystemComponent() const;
	const TArray<struct FHWPassiveMeterDataField> GetAllDataFields() const;
	class AHWCharacterAbilitySystemActor* GetCharacterAbilitySystemActor() const;
	bool GetDataFieldByTag(const struct FGameplayTag& InFieldTag, struct FHWPassiveMeterDataField* OutDataField) const;
	int32 GetFilledPips() const;
	const struct FHWPassiveMeterLargePipData GetLargePipData() const;
	int32 GetMeterFill() const;
	class UHWInventoryManagerComponent* GetOwningInventoryManager() const;
	bool GetShouldShowMeter() const;
	int32 GetTotalPips() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPassiveMeterComponent">();
	}
	static class UHWPassiveMeterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPassiveMeterComponent>();
	}
};
static_assert(alignof(UHWPassiveMeterComponent) == 0x000008, "Wrong alignment on UHWPassiveMeterComponent");
static_assert(sizeof(UHWPassiveMeterComponent) == 0x000260, "Wrong size on UHWPassiveMeterComponent");
static_assert(offsetof(UHWPassiveMeterComponent, GameplayAttributesToTrack) == 0x0000A0, "Member 'UHWPassiveMeterComponent::GameplayAttributesToTrack' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, TotalPips) == 0x000148, "Member 'UHWPassiveMeterComponent::TotalPips' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, FilledPips) == 0x00014C, "Member 'UHWPassiveMeterComponent::FilledPips' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, bShowMeter) == 0x000150, "Member 'UHWPassiveMeterComponent::bShowMeter' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, MeterFill) == 0x000154, "Member 'UHWPassiveMeterComponent::MeterFill' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, LargePipData) == 0x000158, "Member 'UHWPassiveMeterComponent::LargePipData' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, PassiveGameplayTagEvent) == 0x000190, "Member 'UHWPassiveMeterComponent::PassiveGameplayTagEvent' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, DataFields) == 0x0001D0, "Member 'UHWPassiveMeterComponent::DataFields' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, OwningInventoryManager) == 0x0001E0, "Member 'UHWPassiveMeterComponent::OwningInventoryManager' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, bRegisterFamiliarListeners) == 0x0001E8, "Member 'UHWPassiveMeterComponent::bRegisterFamiliarListeners' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, CurrentActiveFamiliars) == 0x0001F0, "Member 'UHWPassiveMeterComponent::CurrentActiveFamiliars' has a wrong offset!");
static_assert(offsetof(UHWPassiveMeterComponent, FamiliarGameplayAttributesToTrack) == 0x000200, "Member 'UHWPassiveMeterComponent::FamiliarGameplayAttributesToTrack' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_PhysicsImpulse
// 0x0018 (0x0AD0 - 0x0AB8)
class UHWGameplayEffect_PhysicsImpulse : public UHWGameplayEffect
{
public:
	bool                                          bResetVerticalMomentum;                            // 0x0AB8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetHorizonalMomentum;                           // 0x0AB9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ABA[0x2];                                      // 0x0ABA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeInAir;                                         // 0x0ABC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLandAtGroundHeight;                               // 0x0AC0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFixedHeightImpulse;                             // 0x0AC1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC2[0x2];                                      // 0x0AC2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseHeight;                                     // 0x0AC4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalVelocity;                                // 0x0AC8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWImpulseVectorOverrideType                  ImpulseVectorOverrideType;                         // 0x0ACC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAirJuggle;                                     // 0x0ACD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseEffectCauserAsOrigin;                          // 0x0ACE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ACF[0x1];                                      // 0x0ACF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanAirJuggle() const;
	float GetHorizontalVelocity() const;
	float GetImpulseHeight() const;
	EHWImpulseVectorOverrideType GetImpulseVectorOverrideType() const;
	bool GetResetsHorizontalMomentum() const;
	bool GetResetsVerticalMomentum() const;
	float GetTimeInAir() const;
	bool IsFixedHeightImpulse() const;
	bool ShouldLandAtGroundHeight() const;
	bool ShouldUseEffectCauserAsOrigin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_PhysicsImpulse">();
	}
	static class UHWGameplayEffect_PhysicsImpulse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_PhysicsImpulse>();
	}
};
static_assert(alignof(UHWGameplayEffect_PhysicsImpulse) == 0x000008, "Wrong alignment on UHWGameplayEffect_PhysicsImpulse");
static_assert(sizeof(UHWGameplayEffect_PhysicsImpulse) == 0x000AD0, "Wrong size on UHWGameplayEffect_PhysicsImpulse");
static_assert(offsetof(UHWGameplayEffect_PhysicsImpulse, bResetVerticalMomentum) == 0x000AB8, "Member 'UHWGameplayEffect_PhysicsImpulse::bResetVerticalMomentum' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_PhysicsImpulse, bResetHorizonalMomentum) == 0x000AB9, "Member 'UHWGameplayEffect_PhysicsImpulse::bResetHorizonalMomentum' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_PhysicsImpulse, TimeInAir) == 0x000ABC, "Member 'UHWGameplayEffect_PhysicsImpulse::TimeInAir' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_PhysicsImpulse, bLandAtGroundHeight) == 0x000AC0, "Member 'UHWGameplayEffect_PhysicsImpulse::bLandAtGroundHeight' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_PhysicsImpulse, bIsFixedHeightImpulse) == 0x000AC1, "Member 'UHWGameplayEffect_PhysicsImpulse::bIsFixedHeightImpulse' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_PhysicsImpulse, ImpulseHeight) == 0x000AC4, "Member 'UHWGameplayEffect_PhysicsImpulse::ImpulseHeight' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_PhysicsImpulse, HorizontalVelocity) == 0x000AC8, "Member 'UHWGameplayEffect_PhysicsImpulse::HorizontalVelocity' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_PhysicsImpulse, ImpulseVectorOverrideType) == 0x000ACC, "Member 'UHWGameplayEffect_PhysicsImpulse::ImpulseVectorOverrideType' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_PhysicsImpulse, bCanAirJuggle) == 0x000ACD, "Member 'UHWGameplayEffect_PhysicsImpulse::bCanAirJuggle' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_PhysicsImpulse, bUseEffectCauserAsOrigin) == 0x000ACE, "Member 'UHWGameplayEffect_PhysicsImpulse::bUseEffectCauserAsOrigin' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Knockback
// 0x0010 (0x0AE0 - 0x0AD0)
class UHWGameplayEffect_Knockback : public UHWGameplayEffect_PhysicsImpulse
{
public:
	uint8                                         Pad_AD0[0x8];                                      // 0x0AD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DiminishingReturnStacks;                           // 0x0AD8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ADC[0x4];                                      // 0x0ADC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Knockback">();
	}
	static class UHWGameplayEffect_Knockback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Knockback>();
	}
};
static_assert(alignof(UHWGameplayEffect_Knockback) == 0x000008, "Wrong alignment on UHWGameplayEffect_Knockback");
static_assert(sizeof(UHWGameplayEffect_Knockback) == 0x000AE0, "Wrong size on UHWGameplayEffect_Knockback");
static_assert(offsetof(UHWGameplayEffect_Knockback, DiminishingReturnStacks) == 0x000AD8, "Member 'UHWGameplayEffect_Knockback::DiminishingReturnStacks' has a wrong offset!");

// Class Hemingway.HWPassiveMeter_NuWa
// 0x0010 (0x0270 - 0x0260)
class UHWPassiveMeter_NuWa final : public UHWPassiveMeterComponent
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleActiveGameplayEffectTimeChange(const struct FActiveGameplayEffectHandle& EffectHandle, float NewStartTime, float NewDuration);
	void RegisterEventOnWoodCooldownActivated();
	void RemoveEventsOnWoodCooldownEnded();
	void UpdateWoodPassiveMeterData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPassiveMeter_NuWa">();
	}
	static class UHWPassiveMeter_NuWa* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPassiveMeter_NuWa>();
	}
};
static_assert(alignof(UHWPassiveMeter_NuWa) == 0x000008, "Wrong alignment on UHWPassiveMeter_NuWa");
static_assert(sizeof(UHWPassiveMeter_NuWa) == 0x000270, "Wrong size on UHWPassiveMeter_NuWa");

// Class Hemingway.HWGameplayEffect_DamageImmunity
// 0x0000 (0x0AB8 - 0x0AB8)
class UHWGameplayEffect_DamageImmunity : public UHWGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_DamageImmunity">();
	}
	static class UHWGameplayEffect_DamageImmunity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_DamageImmunity>();
	}
};
static_assert(alignof(UHWGameplayEffect_DamageImmunity) == 0x000008, "Wrong alignment on UHWGameplayEffect_DamageImmunity");
static_assert(sizeof(UHWGameplayEffect_DamageImmunity) == 0x000AB8, "Wrong size on UHWGameplayEffect_DamageImmunity");

// Class Hemingway.HWPhaseLogic
// 0x0008 (0x0030 - 0x0028)
class UHWPhaseLogic : public UObject
{
public:
	TWeakObjectPtr<class AHWGameMode>             GameMode;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EndLogicBP();
	void StartLogicBP();

	class AHWTeamState* GetChaosTeamState() const;
	class AHWGameState* GetGameState() const;
	class AHWTeamState* GetOrderTeamState() const;
	class AHWTeamState* GetTeamState(const struct FGenericTeamId& TeamId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic">();
	}
	static class UHWPhaseLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic>();
	}
};
static_assert(alignof(UHWPhaseLogic) == 0x000008, "Wrong alignment on UHWPhaseLogic");
static_assert(sizeof(UHWPhaseLogic) == 0x000030, "Wrong size on UHWPhaseLogic");
static_assert(offsetof(UHWPhaseLogic, GameMode) == 0x000028, "Member 'UHWPhaseLogic::GameMode' has a wrong offset!");

// Class Hemingway.HWPhaseLogic_AssignRoles
// 0x0018 (0x0048 - 0x0030)
class UHWPhaseLogic_AssignRoles final : public UHWPhaseLogic
{
public:
	struct FGameplayTag                           RolesAssignedTransitionPhaseTag;                   // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RolesAssignedTransitionDelay;                      // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RolesAssignedTimerHandle;                          // 0x0040(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayerRolesAssigned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic_AssignRoles">();
	}
	static class UHWPhaseLogic_AssignRoles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic_AssignRoles>();
	}
};
static_assert(alignof(UHWPhaseLogic_AssignRoles) == 0x000008, "Wrong alignment on UHWPhaseLogic_AssignRoles");
static_assert(sizeof(UHWPhaseLogic_AssignRoles) == 0x000048, "Wrong size on UHWPhaseLogic_AssignRoles");
static_assert(offsetof(UHWPhaseLogic_AssignRoles, RolesAssignedTransitionPhaseTag) == 0x000030, "Member 'UHWPhaseLogic_AssignRoles::RolesAssignedTransitionPhaseTag' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_AssignRoles, RolesAssignedTransitionDelay) == 0x000038, "Member 'UHWPhaseLogic_AssignRoles::RolesAssignedTransitionDelay' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_AssignRoles, RolesAssignedTimerHandle) == 0x000040, "Member 'UHWPhaseLogic_AssignRoles::RolesAssignedTimerHandle' has a wrong offset!");

// Class Hemingway.HWPhaseLogic_Backfill
// 0x0018 (0x0048 - 0x0030)
class UHWPhaseLogic_Backfill final : public UHWPhaseLogic
{
public:
	bool                                          bAttemptingBackfill;                               // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BackfillPlayerCountTarget;                         // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalPlayerSeats;                                  // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumConnectedPlayers;                               // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumPendingKicks;                                   // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStillKickingPlayers;                              // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleKickDelegateResolved(bool bSuccess, class URH_SessionView* pSession, const struct FRH_ErrorInfo& ErrorInfo);
	void HandleSessionUpdated(class URH_SessionView* SessionView);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic_Backfill">();
	}
	static class UHWPhaseLogic_Backfill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic_Backfill>();
	}
};
static_assert(alignof(UHWPhaseLogic_Backfill) == 0x000008, "Wrong alignment on UHWPhaseLogic_Backfill");
static_assert(sizeof(UHWPhaseLogic_Backfill) == 0x000048, "Wrong size on UHWPhaseLogic_Backfill");
static_assert(offsetof(UHWPhaseLogic_Backfill, bAttemptingBackfill) == 0x000030, "Member 'UHWPhaseLogic_Backfill::bAttemptingBackfill' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_Backfill, BackfillPlayerCountTarget) == 0x000034, "Member 'UHWPhaseLogic_Backfill::BackfillPlayerCountTarget' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_Backfill, TotalPlayerSeats) == 0x000038, "Member 'UHWPhaseLogic_Backfill::TotalPlayerSeats' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_Backfill, NumConnectedPlayers) == 0x00003C, "Member 'UHWPhaseLogic_Backfill::NumConnectedPlayers' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_Backfill, NumPendingKicks) == 0x000040, "Member 'UHWPhaseLogic_Backfill::NumPendingKicks' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_Backfill, bStillKickingPlayers) == 0x000044, "Member 'UHWPhaseLogic_Backfill::bStillKickingPlayers' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_LifetimeModification
// 0x0078 (0x0B30 - 0x0AB8)
class UHWGameplayEffect_LifetimeModification : public UHWGameplayEffect
{
public:
	struct FGameplayTagContainer                  EffectTagsToModifyLifetime;                        // 0x0AB8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         FlatLifetimeDelta;                                 // 0x0AD8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentLifetimeMultiplier;                         // 0x0ADC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGameplayEffectModifierMagnitude> LifetimeModificationPowerScalingFactors; // 0x0AE0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_LifetimeModification">();
	}
	static class UHWGameplayEffect_LifetimeModification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_LifetimeModification>();
	}
};
static_assert(alignof(UHWGameplayEffect_LifetimeModification) == 0x000008, "Wrong alignment on UHWGameplayEffect_LifetimeModification");
static_assert(sizeof(UHWGameplayEffect_LifetimeModification) == 0x000B30, "Wrong size on UHWGameplayEffect_LifetimeModification");
static_assert(offsetof(UHWGameplayEffect_LifetimeModification, EffectTagsToModifyLifetime) == 0x000AB8, "Member 'UHWGameplayEffect_LifetimeModification::EffectTagsToModifyLifetime' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_LifetimeModification, FlatLifetimeDelta) == 0x000AD8, "Member 'UHWGameplayEffect_LifetimeModification::FlatLifetimeDelta' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_LifetimeModification, PercentLifetimeMultiplier) == 0x000ADC, "Member 'UHWGameplayEffect_LifetimeModification::PercentLifetimeMultiplier' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_LifetimeModification, LifetimeModificationPowerScalingFactors) == 0x000AE0, "Member 'UHWGameplayEffect_LifetimeModification::LifetimeModificationPowerScalingFactors' has a wrong offset!");

// Class Hemingway.HWPhaseLogic_BanPickDraft
// 0x0008 (0x0038 - 0x0030)
class UHWPhaseLogic_BanPickDraft final : public UHWPhaseLogic
{
public:
	TSubclassOf<class UHWDraftRules>              CharacterDraftRules;                               // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic_BanPickDraft">();
	}
	static class UHWPhaseLogic_BanPickDraft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic_BanPickDraft>();
	}
};
static_assert(alignof(UHWPhaseLogic_BanPickDraft) == 0x000008, "Wrong alignment on UHWPhaseLogic_BanPickDraft");
static_assert(sizeof(UHWPhaseLogic_BanPickDraft) == 0x000038, "Wrong size on UHWPhaseLogic_BanPickDraft");
static_assert(offsetof(UHWPhaseLogic_BanPickDraft, CharacterDraftRules) == 0x000030, "Member 'UHWPhaseLogic_BanPickDraft::CharacterDraftRules' has a wrong offset!");

// Class Hemingway.HWAbilityTask_FireAttack
// 0x0100 (0x0180 - 0x0080)
class UHWAbilityTask_FireAttack : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x80];                                      // 0x0080(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityAttackSettings*               AttackSettings;                                    // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilityTargetDataHandle       AttackAimOverride;                                 // 0x0108(0x0028)(Protected, NativeAccessSpecifierProtected)
	class UHWGameplayAbility_Enhanced*            EnhancedAbility;                                   // 0x0130(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityLevelConfig*                  AbilityLevelConfig;                                // 0x0138(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWAbilityTask_FireAttack* AttackTask, const struct FHWAbilityAttackInstance& Attack)> OnAttackStartedDel; // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilityTask_FireAttack* AttackTask, const struct FHWAbilityAttackInstance& Attack)> OnAttackEndedDel; // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTimerHandle                           FiringTimer;                                       // 0x0160(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           EndingTimer;                                       // 0x0168(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x4];                                      // 0x0170(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsFiring;                                         // 0x0174(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyEndFireWhenTaskEnds;                          // 0x0175(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_176[0xA];                                      // 0x0176(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_FireAttack* FireAttack(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FHWAbilityAttackInstance& Attack, const struct FGameplayAbilityTargetDataHandle& AttackAimOverride_0);
	static class UHWAbilityTask_FireAttack* FireAttackById(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FGameplayTag& ID, const struct FGameplayAbilityTargetDataHandle& AttackAimOverride_0);

	struct FGameplayAbilityTargetDataHandle GetAttackAim() const;
	struct FGameplayAbilityTargetDataHandle GetAttackAimOverride() const;
	struct FGameplayTag GetAttackId() const;
	struct FHWAbilityAttackInstance GetAttackInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_FireAttack">();
	}
	static class UHWAbilityTask_FireAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_FireAttack>();
	}
};
static_assert(alignof(UHWAbilityTask_FireAttack) == 0x000008, "Wrong alignment on UHWAbilityTask_FireAttack");
static_assert(sizeof(UHWAbilityTask_FireAttack) == 0x000180, "Wrong size on UHWAbilityTask_FireAttack");
static_assert(offsetof(UHWAbilityTask_FireAttack, AttackSettings) == 0x000100, "Member 'UHWAbilityTask_FireAttack::AttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_FireAttack, AttackAimOverride) == 0x000108, "Member 'UHWAbilityTask_FireAttack::AttackAimOverride' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_FireAttack, EnhancedAbility) == 0x000130, "Member 'UHWAbilityTask_FireAttack::EnhancedAbility' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_FireAttack, AbilityLevelConfig) == 0x000138, "Member 'UHWAbilityTask_FireAttack::AbilityLevelConfig' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_FireAttack, OnAttackStartedDel) == 0x000140, "Member 'UHWAbilityTask_FireAttack::OnAttackStartedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_FireAttack, OnAttackEndedDel) == 0x000150, "Member 'UHWAbilityTask_FireAttack::OnAttackEndedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_FireAttack, FiringTimer) == 0x000160, "Member 'UHWAbilityTask_FireAttack::FiringTimer' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_FireAttack, EndingTimer) == 0x000168, "Member 'UHWAbilityTask_FireAttack::EndingTimer' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_FireAttack, bIsFiring) == 0x000174, "Member 'UHWAbilityTask_FireAttack::bIsFiring' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_FireAttack, bOnlyEndFireWhenTaskEnds) == 0x000175, "Member 'UHWAbilityTask_FireAttack::bOnlyEndFireWhenTaskEnds' has a wrong offset!");

// Class Hemingway.HWAbilityTask_Attack_CollisionProxy
// 0x0020 (0x01A0 - 0x0180)
class UHWAbilityTask_Attack_CollisionProxy final : public UHWAbilityTask_FireAttack
{
public:
	class UHWAbilityAttackSettings_Collision*     CollisionProxyAttackSettings;                      // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 FollowSweepingActor;                               // 0x0188(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityCollisionProxy*               SpawnedCollisionProxy;                             // 0x0190(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleNewAvatarActor(class AActor* NewAvatarActor);
	void OnAbilityLevelChanged(const struct FGameplayAbilitySpecHandle& AbilityHandle, const int32 Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Attack_CollisionProxy">();
	}
	static class UHWAbilityTask_Attack_CollisionProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Attack_CollisionProxy>();
	}
};
static_assert(alignof(UHWAbilityTask_Attack_CollisionProxy) == 0x000008, "Wrong alignment on UHWAbilityTask_Attack_CollisionProxy");
static_assert(sizeof(UHWAbilityTask_Attack_CollisionProxy) == 0x0001A0, "Wrong size on UHWAbilityTask_Attack_CollisionProxy");
static_assert(offsetof(UHWAbilityTask_Attack_CollisionProxy, CollisionProxyAttackSettings) == 0x000180, "Member 'UHWAbilityTask_Attack_CollisionProxy::CollisionProxyAttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_CollisionProxy, FollowSweepingActor) == 0x000188, "Member 'UHWAbilityTask_Attack_CollisionProxy::FollowSweepingActor' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_CollisionProxy, SpawnedCollisionProxy) == 0x000190, "Member 'UHWAbilityTask_Attack_CollisionProxy::SpawnedCollisionProxy' has a wrong offset!");

// Class Hemingway.HWPhaseLogic_EndDraftEarly
// 0x0000 (0x0030 - 0x0030)
class UHWPhaseLogic_EndDraftEarly final : public UHWPhaseLogic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic_EndDraftEarly">();
	}
	static class UHWPhaseLogic_EndDraftEarly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic_EndDraftEarly>();
	}
};
static_assert(alignof(UHWPhaseLogic_EndDraftEarly) == 0x000008, "Wrong alignment on UHWPhaseLogic_EndDraftEarly");
static_assert(sizeof(UHWPhaseLogic_EndDraftEarly) == 0x000030, "Wrong size on UHWPhaseLogic_EndDraftEarly");

// Class Hemingway.HWPhaseLogic_EndDraftTransition
// 0x0008 (0x0038 - 0x0030)
class UHWPhaseLogic_EndDraftTransition final : public UHWPhaseLogic
{
public:
	struct FGameplayTag                           DefaultTransitionInfoTag;                          // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic_EndDraftTransition">();
	}
	static class UHWPhaseLogic_EndDraftTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic_EndDraftTransition>();
	}
};
static_assert(alignof(UHWPhaseLogic_EndDraftTransition) == 0x000008, "Wrong alignment on UHWPhaseLogic_EndDraftTransition");
static_assert(sizeof(UHWPhaseLogic_EndDraftTransition) == 0x000038, "Wrong size on UHWPhaseLogic_EndDraftTransition");
static_assert(offsetof(UHWPhaseLogic_EndDraftTransition, DefaultTransitionInfoTag) == 0x000030, "Member 'UHWPhaseLogic_EndDraftTransition::DefaultTransitionInfoTag' has a wrong offset!");

// Class Hemingway.HWPhaseLogic_EndOfMatch
// 0x0000 (0x0030 - 0x0030)
class UHWPhaseLogic_EndOfMatch : public UHWPhaseLogic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic_EndOfMatch">();
	}
	static class UHWPhaseLogic_EndOfMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic_EndOfMatch>();
	}
};
static_assert(alignof(UHWPhaseLogic_EndOfMatch) == 0x000008, "Wrong alignment on UHWPhaseLogic_EndOfMatch");
static_assert(sizeof(UHWPhaseLogic_EndOfMatch) == 0x000030, "Wrong size on UHWPhaseLogic_EndOfMatch");

// Class Hemingway.HWGameplayEffect_NoSpectateWhileDead
// 0x0000 (0x0AB8 - 0x0AB8)
class UHWGameplayEffect_NoSpectateWhileDead final : public UHWGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_NoSpectateWhileDead">();
	}
	static class UHWGameplayEffect_NoSpectateWhileDead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_NoSpectateWhileDead>();
	}
};
static_assert(alignof(UHWGameplayEffect_NoSpectateWhileDead) == 0x000008, "Wrong alignment on UHWGameplayEffect_NoSpectateWhileDead");
static_assert(sizeof(UHWGameplayEffect_NoSpectateWhileDead) == 0x000AB8, "Wrong size on UHWGameplayEffect_NoSpectateWhileDead");

// Class Hemingway.HWPhaseLogic_MatchActive
// 0x0000 (0x0030 - 0x0030)
class UHWPhaseLogic_MatchActive : public UHWPhaseLogic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic_MatchActive">();
	}
	static class UHWPhaseLogic_MatchActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic_MatchActive>();
	}
};
static_assert(alignof(UHWPhaseLogic_MatchActive) == 0x000008, "Wrong alignment on UHWPhaseLogic_MatchActive");
static_assert(sizeof(UHWPhaseLogic_MatchActive) == 0x000030, "Wrong size on UHWPhaseLogic_MatchActive");

// Class Hemingway.HWGameplayEffect_Intoxicate
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Intoxicate : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Intoxicate">();
	}
	static class UHWGameplayEffect_Intoxicate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Intoxicate>();
	}
};
static_assert(alignof(UHWGameplayEffect_Intoxicate) == 0x000008, "Wrong alignment on UHWGameplayEffect_Intoxicate");
static_assert(sizeof(UHWGameplayEffect_Intoxicate) == 0x000AC8, "Wrong size on UHWGameplayEffect_Intoxicate");

// Class Hemingway.HWPhaseLogic_Setup
// 0x0000 (0x0030 - 0x0030)
class UHWPhaseLogic_Setup : public UHWPhaseLogic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic_Setup">();
	}
	static class UHWPhaseLogic_Setup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic_Setup>();
	}
};
static_assert(alignof(UHWPhaseLogic_Setup) == 0x000008, "Wrong alignment on UHWPhaseLogic_Setup");
static_assert(sizeof(UHWPhaseLogic_Setup) == 0x000030, "Wrong size on UHWPhaseLogic_Setup");

// Class Hemingway.HWPhaseLogic_Trade
// 0x0008 (0x0038 - 0x0030)
class UHWPhaseLogic_Trade final : public UHWPhaseLogic
{
public:
	struct FGameplayTag                           SkipPhaseTransitionTag;                            // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic_Trade">();
	}
	static class UHWPhaseLogic_Trade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic_Trade>();
	}
};
static_assert(alignof(UHWPhaseLogic_Trade) == 0x000008, "Wrong alignment on UHWPhaseLogic_Trade");
static_assert(sizeof(UHWPhaseLogic_Trade) == 0x000038, "Wrong size on UHWPhaseLogic_Trade");
static_assert(offsetof(UHWPhaseLogic_Trade, SkipPhaseTransitionTag) == 0x000030, "Member 'UHWPhaseLogic_Trade::SkipPhaseTransitionTag' has a wrong offset!");

// Class Hemingway.HWPhaseLogic_WaitForConnections
// 0x0020 (0x0050 - 0x0030)
class UHWPhaseLogic_WaitForConnections final : public UHWPhaseLogic
{
public:
	struct FGameplayTag                           SuccessfulConnectionTransitionPhaseTag;            // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SuccessfulConnectionTransitionDelay;               // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllConnected;                                     // 0x003C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalPlayerSeats;                                  // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           FinishConnectingPlayersTimerHandle;                // 0x0048(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CheckForAllPlayersConnected();
	void OnPlayerConnected(class APlayerController* PlayerController);
	void OnSessionUpdated(class URH_SessionView* SessionView);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPhaseLogic_WaitForConnections">();
	}
	static class UHWPhaseLogic_WaitForConnections* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPhaseLogic_WaitForConnections>();
	}
};
static_assert(alignof(UHWPhaseLogic_WaitForConnections) == 0x000008, "Wrong alignment on UHWPhaseLogic_WaitForConnections");
static_assert(sizeof(UHWPhaseLogic_WaitForConnections) == 0x000050, "Wrong size on UHWPhaseLogic_WaitForConnections");
static_assert(offsetof(UHWPhaseLogic_WaitForConnections, SuccessfulConnectionTransitionPhaseTag) == 0x000030, "Member 'UHWPhaseLogic_WaitForConnections::SuccessfulConnectionTransitionPhaseTag' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_WaitForConnections, SuccessfulConnectionTransitionDelay) == 0x000038, "Member 'UHWPhaseLogic_WaitForConnections::SuccessfulConnectionTransitionDelay' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_WaitForConnections, bAllConnected) == 0x00003C, "Member 'UHWPhaseLogic_WaitForConnections::bAllConnected' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_WaitForConnections, TotalPlayerSeats) == 0x000040, "Member 'UHWPhaseLogic_WaitForConnections::TotalPlayerSeats' has a wrong offset!");
static_assert(offsetof(UHWPhaseLogic_WaitForConnections, FinishConnectingPlayersTimerHandle) == 0x000048, "Member 'UHWPhaseLogic_WaitForConnections::FinishConnectingPlayersTimerHandle' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Revive
// 0x0018 (0x0AD0 - 0x0AB8)
class UHWGameplayEffect_Revive final : public UHWGameplayEffect
{
public:
	float                                         ActivateReviveDelay;                               // 0x0AB8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRemoveActiveReviveEffectOnRevive;                 // 0x0ABC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipOnExecutes;                                   // 0x0ABD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ABE[0x2];                                      // 0x0ABE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            ReviveImmunityEffect;                              // 0x0AC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            ReviveHealEffect;                                  // 0x0AC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Revive">();
	}
	static class UHWGameplayEffect_Revive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Revive>();
	}
};
static_assert(alignof(UHWGameplayEffect_Revive) == 0x000008, "Wrong alignment on UHWGameplayEffect_Revive");
static_assert(sizeof(UHWGameplayEffect_Revive) == 0x000AD0, "Wrong size on UHWGameplayEffect_Revive");
static_assert(offsetof(UHWGameplayEffect_Revive, ActivateReviveDelay) == 0x000AB8, "Member 'UHWGameplayEffect_Revive::ActivateReviveDelay' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Revive, bRemoveActiveReviveEffectOnRevive) == 0x000ABC, "Member 'UHWGameplayEffect_Revive::bRemoveActiveReviveEffectOnRevive' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Revive, bSkipOnExecutes) == 0x000ABD, "Member 'UHWGameplayEffect_Revive::bSkipOnExecutes' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Revive, ReviveImmunityEffect) == 0x000AC0, "Member 'UHWGameplayEffect_Revive::ReviveImmunityEffect' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Revive, ReviveHealEffect) == 0x000AC8, "Member 'UHWGameplayEffect_Revive::ReviveHealEffect' has a wrong offset!");

// Class Hemingway.HWPingDisplayInfo
// 0x0000 (0x0028 - 0x0028)
class UHWPingDisplayInfo final : public UHWDisplayInfoData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPingDisplayInfo">();
	}
	static class UHWPingDisplayInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPingDisplayInfo>();
	}
};
static_assert(alignof(UHWPingDisplayInfo) == 0x000008, "Wrong alignment on UHWPingDisplayInfo");
static_assert(sizeof(UHWPingDisplayInfo) == 0x000028, "Wrong size on UHWPingDisplayInfo");

// Class Hemingway.HWGameplayEffect_Block
// 0x0088 (0x0B40 - 0x0AB8)
class UHWGameplayEffect_Block final : public UHWGameplayEffect
{
public:
	struct FGameplayTagRequirements               BlockTagsRequirements;                             // 0x0AB8(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Block">();
	}
	static class UHWGameplayEffect_Block* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Block>();
	}
};
static_assert(alignof(UHWGameplayEffect_Block) == 0x000008, "Wrong alignment on UHWGameplayEffect_Block");
static_assert(sizeof(UHWGameplayEffect_Block) == 0x000B40, "Wrong size on UHWGameplayEffect_Block");
static_assert(offsetof(UHWGameplayEffect_Block, BlockTagsRequirements) == 0x000AB8, "Member 'UHWGameplayEffect_Block::BlockTagsRequirements' has a wrong offset!");

// Class Hemingway.HWPingManager
// 0x0188 (0x0420 - 0x0298)
class AHWPingManager final : public AInfo
{
public:
	TSoftObjectPtr<class UDataTable>              PingConfigTableSoftPtr;                            // 0x0298(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FHWPingConfig> PingConfigs;                                     // 0x02C0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWPlayerState>          LocalPlayerState;                                  // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGuid, float>                     PlayerUUIDToLastAddPingMessageTimestamp;           // 0x0318(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         PlayerAddPingNotificationCooldown;                 // 0x0368(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class APlayerState>, struct FHWPingActionTimestamp> ActionTimestamps;        // 0x0370(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class APlayerState>, struct FTimerHandle> FloodTimerHandles;                 // 0x03C0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class AHWAutoPingWorldActor*>          AutoPingWorldActors;                               // 0x0410(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddPing(const struct FGameplayTag& PingTag, const struct FVector& PingLocation, class AActor* PingOwner, EHWPingSource PingSource, bool bSendChatNotification);
	void HandlePingActorRecycled(class AHWPingWorldActor* InPingActor);
	void MulticastSendPing(const struct FGameplayTag& PingTag, const struct FVector& PingLocation, class AActor* PingOwner, EHWPingSource PingSource);
	void OnFloodProtectionCooldownTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPingManager">();
	}
	static class AHWPingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPingManager>();
	}
};
static_assert(alignof(AHWPingManager) == 0x000008, "Wrong alignment on AHWPingManager");
static_assert(sizeof(AHWPingManager) == 0x000420, "Wrong size on AHWPingManager");
static_assert(offsetof(AHWPingManager, PingConfigTableSoftPtr) == 0x000298, "Member 'AHWPingManager::PingConfigTableSoftPtr' has a wrong offset!");
static_assert(offsetof(AHWPingManager, PingConfigs) == 0x0002C0, "Member 'AHWPingManager::PingConfigs' has a wrong offset!");
static_assert(offsetof(AHWPingManager, LocalPlayerState) == 0x000310, "Member 'AHWPingManager::LocalPlayerState' has a wrong offset!");
static_assert(offsetof(AHWPingManager, PlayerUUIDToLastAddPingMessageTimestamp) == 0x000318, "Member 'AHWPingManager::PlayerUUIDToLastAddPingMessageTimestamp' has a wrong offset!");
static_assert(offsetof(AHWPingManager, PlayerAddPingNotificationCooldown) == 0x000368, "Member 'AHWPingManager::PlayerAddPingNotificationCooldown' has a wrong offset!");
static_assert(offsetof(AHWPingManager, ActionTimestamps) == 0x000370, "Member 'AHWPingManager::ActionTimestamps' has a wrong offset!");
static_assert(offsetof(AHWPingManager, FloodTimerHandles) == 0x0003C0, "Member 'AHWPingManager::FloodTimerHandles' has a wrong offset!");
static_assert(offsetof(AHWPingManager, AutoPingWorldActors) == 0x000410, "Member 'AHWPingManager::AutoPingWorldActors' has a wrong offset!");

// Class Hemingway.HWEffectVolume
// 0x0028 (0x02F8 - 0x02D0)
class AHWEffectVolume : public AVolume
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWEffectVolumeTrackingInfo*>    TrackingInfoList;                                  // 0x02D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWEffectVolumeSettings>    EffectVolumeSettingsClass;                         // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilitySystemComponent*              AbilitySystemComponent;                            // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEffectVolume">();
	}
	static class AHWEffectVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWEffectVolume>();
	}
};
static_assert(alignof(AHWEffectVolume) == 0x000008, "Wrong alignment on AHWEffectVolume");
static_assert(sizeof(AHWEffectVolume) == 0x0002F8, "Wrong size on AHWEffectVolume");
static_assert(offsetof(AHWEffectVolume, TrackingInfoList) == 0x0002D8, "Member 'AHWEffectVolume::TrackingInfoList' has a wrong offset!");
static_assert(offsetof(AHWEffectVolume, EffectVolumeSettingsClass) == 0x0002E8, "Member 'AHWEffectVolume::EffectVolumeSettingsClass' has a wrong offset!");
static_assert(offsetof(AHWEffectVolume, AbilitySystemComponent) == 0x0002F0, "Member 'AHWEffectVolume::AbilitySystemComponent' has a wrong offset!");

// Class Hemingway.HWPlaneOfExistenceVolume
// 0x0008 (0x0300 - 0x02F8)
class AHWPlaneOfExistenceVolume final : public AHWEffectVolume
{
public:
	struct FGameplayTag                           PlaneIdentifierTag;                                // 0x02F8(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FGameplayTag GetPlaneIdentifierTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlaneOfExistenceVolume">();
	}
	static class AHWPlaneOfExistenceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPlaneOfExistenceVolume>();
	}
};
static_assert(alignof(AHWPlaneOfExistenceVolume) == 0x000008, "Wrong alignment on AHWPlaneOfExistenceVolume");
static_assert(sizeof(AHWPlaneOfExistenceVolume) == 0x000300, "Wrong size on AHWPlaneOfExistenceVolume");
static_assert(offsetof(AHWPlaneOfExistenceVolume, PlaneIdentifierTag) == 0x0002F8, "Member 'AHWPlaneOfExistenceVolume::PlaneIdentifierTag' has a wrong offset!");

// Class Hemingway.HWInventoryItem
// 0x0038 (0x01B0 - 0x0178)
class UHWInventoryItem : public UPlatformInventoryItem
{
public:
	class FText                                   ItemDisplayNameCAPS;                               // 0x0178(0x0018)(Edit, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowInItemViewer;                                 // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAlwaysOwned;                                    // 0x0191(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_192[0x2];                                      // 0x0192(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetRules                     Rules;                                             // 0x0194(0x000C)(Edit, DuplicateTransient, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AlwaysCookPriority;                                // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DevelopmentAlwaysCookPriority;                     // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NeverCookPriority;                                 // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldShowCTA;                                    // 0x01AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class FName> GetCTAPath(const class UObject* WorldContext, const TSoftObjectPtr<class UHWInventoryItem> Item, const struct FRH_ItemId& InItemId);
	static EHWItemDisabledReason GetItemDisabledReason(const struct FRH_ItemId& InItemId);
	static int32 GetItemIdOwnershipCount(const class URH_PlayerInfo* PlayerInfo, const struct FRH_ItemId& InItemId);
	static bool IsAlwaysOwnedItem(const struct FRH_ItemId& InItemId);
	static bool IsItemEnabled(const struct FRH_ItemId& InItemId, bool bCheckTempDisabled);
	static bool ShouldShowCTA(const TSoftObjectPtr<class UHWInventoryItem> Item);

	class FText GetItemDisplayNameCAPS() const;
	int32 GetOwnershipCount(const class URH_PlayerInfo* PlayerInfo, const class UHWCharacterItem* CharacterContextItem) const;
	class URHStorePurchaseRequest* GetPendingPurchaseRequest(const class UObject* WorldContextObject) const;
	class URHStoreItem* GetStoreItem(const class UObject* WorldContextObject) const;
	bool HasPendingPurchaseRequest(const class UObject* WorldContextObject) const;
	bool IsOwnedCached(const class URH_PlayerInfo* PlayerInfo, const class UHWCharacterItem* CharacterContextItem) const;
	bool IsPurchasable(const class UObject* WorldContextObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInventoryItem">();
	}
	static class UHWInventoryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInventoryItem>();
	}
};
static_assert(alignof(UHWInventoryItem) == 0x000008, "Wrong alignment on UHWInventoryItem");
static_assert(sizeof(UHWInventoryItem) == 0x0001B0, "Wrong size on UHWInventoryItem");
static_assert(offsetof(UHWInventoryItem, ItemDisplayNameCAPS) == 0x000178, "Member 'UHWInventoryItem::ItemDisplayNameCAPS' has a wrong offset!");
static_assert(offsetof(UHWInventoryItem, bShowInItemViewer) == 0x000190, "Member 'UHWInventoryItem::bShowInItemViewer' has a wrong offset!");
static_assert(offsetof(UHWInventoryItem, bIsAlwaysOwned) == 0x000191, "Member 'UHWInventoryItem::bIsAlwaysOwned' has a wrong offset!");
static_assert(offsetof(UHWInventoryItem, Rules) == 0x000194, "Member 'UHWInventoryItem::Rules' has a wrong offset!");
static_assert(offsetof(UHWInventoryItem, AlwaysCookPriority) == 0x0001A0, "Member 'UHWInventoryItem::AlwaysCookPriority' has a wrong offset!");
static_assert(offsetof(UHWInventoryItem, DevelopmentAlwaysCookPriority) == 0x0001A4, "Member 'UHWInventoryItem::DevelopmentAlwaysCookPriority' has a wrong offset!");
static_assert(offsetof(UHWInventoryItem, NeverCookPriority) == 0x0001A8, "Member 'UHWInventoryItem::NeverCookPriority' has a wrong offset!");
static_assert(offsetof(UHWInventoryItem, bShouldShowCTA) == 0x0001AC, "Member 'UHWInventoryItem::bShouldShowCTA' has a wrong offset!");

// Class Hemingway.HWApparelItem
// 0x0040 (0x01F0 - 0x01B0)
class UHWApparelItem : public UHWInventoryItem
{
public:
	int32                                         Priority;                                          // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ApparelSlot;                                       // 0x01B4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AsyncLoadPriority;                                 // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LocalPlayerAsyncLoadPriority;                      // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C4[0x2C];                                     // 0x01C4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGameplayTag GetSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWApparelItem">();
	}
	static class UHWApparelItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWApparelItem>();
	}
};
static_assert(alignof(UHWApparelItem) == 0x000008, "Wrong alignment on UHWApparelItem");
static_assert(sizeof(UHWApparelItem) == 0x0001F0, "Wrong size on UHWApparelItem");
static_assert(offsetof(UHWApparelItem, Priority) == 0x0001B0, "Member 'UHWApparelItem::Priority' has a wrong offset!");
static_assert(offsetof(UHWApparelItem, ApparelSlot) == 0x0001B4, "Member 'UHWApparelItem::ApparelSlot' has a wrong offset!");
static_assert(offsetof(UHWApparelItem, AsyncLoadPriority) == 0x0001BC, "Member 'UHWApparelItem::AsyncLoadPriority' has a wrong offset!");
static_assert(offsetof(UHWApparelItem, LocalPlayerAsyncLoadPriority) == 0x0001C0, "Member 'UHWApparelItem::LocalPlayerAsyncLoadPriority' has a wrong offset!");

// Class Hemingway.HWApparelItem_DataTable
// 0x0020 (0x0210 - 0x01F0)
class UHWApparelItem_DataTable final : public UHWApparelItem
{
public:
	TArray<struct FHWApparelSoftDataTableInfo>    AssetDataTables;                                   // 0x01F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           ApparelObjectsToInfluence;                         // 0x0200(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWApparelItem_DataTable">();
	}
	static class UHWApparelItem_DataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWApparelItem_DataTable>();
	}
};
static_assert(alignof(UHWApparelItem_DataTable) == 0x000008, "Wrong alignment on UHWApparelItem_DataTable");
static_assert(sizeof(UHWApparelItem_DataTable) == 0x000210, "Wrong size on UHWApparelItem_DataTable");
static_assert(offsetof(UHWApparelItem_DataTable, AssetDataTables) == 0x0001F0, "Member 'UHWApparelItem_DataTable::AssetDataTables' has a wrong offset!");
static_assert(offsetof(UHWApparelItem_DataTable, ApparelObjectsToInfluence) == 0x000200, "Member 'UHWApparelItem_DataTable::ApparelObjectsToInfluence' has a wrong offset!");

// Class Hemingway.HWPlayerBlockingVolume
// 0x0010 (0x02E0 - 0x02D0)
class AHWPlayerBlockingVolume final : public AVolume
{
public:
	TArray<uint8>                                 UnblockedTaskforceNumbers;                         // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerBlockingVolume">();
	}
	static class AHWPlayerBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPlayerBlockingVolume>();
	}
};
static_assert(alignof(AHWPlayerBlockingVolume) == 0x000008, "Wrong alignment on AHWPlayerBlockingVolume");
static_assert(sizeof(AHWPlayerBlockingVolume) == 0x0002E0, "Wrong size on AHWPlayerBlockingVolume");
static_assert(offsetof(AHWPlayerBlockingVolume, UnblockedTaskforceNumbers) == 0x0002D0, "Member 'AHWPlayerBlockingVolume::UnblockedTaskforceNumbers' has a wrong offset!");

// Class Hemingway.HWPlayerCameraManager
// 0x0010 (0x2410 - 0x2400)
class AHWPlayerCameraManager : public APlayerCameraManager
{
public:
	uint8                                         Pad_2400[0x4];                                     // 0x2400(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateCameraOnServerTimeout;                       // 0x2404(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2408[0x8];                                     // 0x2408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerCameraManager">();
	}
	static class AHWPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPlayerCameraManager>();
	}
};
static_assert(alignof(AHWPlayerCameraManager) == 0x000010, "Wrong alignment on AHWPlayerCameraManager");
static_assert(sizeof(AHWPlayerCameraManager) == 0x002410, "Wrong size on AHWPlayerCameraManager");
static_assert(offsetof(AHWPlayerCameraManager, UpdateCameraOnServerTimeout) == 0x002404, "Member 'AHWPlayerCameraManager::UpdateCameraOnServerTimeout' has a wrong offset!");

// Class Hemingway.HWProjectile
// 0x03F8 (0x0690 - 0x0298)
class AHWProjectile : public AActor
{
public:
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  ProjectileInstigator;                              // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHWGameplayAbility>      OwningAbility;                                     // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             OriginalSpawnTransform;                            // 0x02C0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ProjectileRecentSpawnTimer;                        // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x4];                                      // 0x0328(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AttackID;                                          // 0x032C(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInhand;                                         // 0x0334(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanDestroyOnTargetHit;                            // 0x0335(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_336[0x2];                                      // 0x0336(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTargetDataFilterHandle        DestroyOnTargetHitFilterHandle;                    // 0x0338(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTargetDataFilterHandle        DestroyOnAllyTargetHitFilterHandle;                // 0x0348(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bDestroyOnWorldHit;                                // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWDestroyProjectileReason                    DestroyProjectileReason;                           // 0x0359(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35A[0x6];                                      // 0x035A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DestroyTimer;                                      // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToFinishDestroy;                               // 0x0368(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWProjectile* Projectile, EHWDestroyProjectileReason DestroyReason)> ProjectileBeginDestroyDel; // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         ProjectileInstanceId;                              // 0x0380(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AHWPlayerController>> InterestedControllersToFlash;                  // 0x0388(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UHWProjectileMovementComponent*         ProjectileMovementComponent;                       // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ProjectileLevel;                                   // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCalculateSpeedBasedOnRangeAndLifetime;            // 0x03A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A5[0x3];                                      // 0x03A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectileRange;                                   // 0x03A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x34];                                     // 0x03AC(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    RootCollisionComponent;                            // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSeparateCollisionForTargets;                   // 0x03E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWProjectileTargetCollisionSettings   TargetCollisionSettings;                           // 0x03EC(0x001C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldTreatStructuresAsWorldHits;                 // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanHitPastMaxRange;                               // 0x0409(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanHitBehindSpawnLocation;                        // 0x040A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40B[0x5];                                      // 0x040B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         HitActors;                                         // 0x0410(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseSeparateFilterForAllies;                       // 0x0420(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTargetDataFilterHandle        AcceptableProjectileHitFilterHandle;               // 0x0428(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTargetDataFilterHandle        AllyAcceptableProjectileHitFilterHandle;           // 0x0438(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UGameplayEffect>, struct FGameplayEffectSpecHandle> OutGoingGameplayEffects; // 0x0448(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FHWEffectGroupConfig> AbilityConfigEffectGroups;                // 0x0498(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    AdditionalEffectsToCache;                          // 0x04E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayEffectContextHandle           DefaultProjectileEffectContext;                    // 0x04F8(0x0018)(NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         ProjectileExplodeOnTargetNiagaraSystem;            // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ProjectileExplodeOnTargetFxSkinningKeyword;        // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ProjectileExplodeOnWorldNiagaraSystem;             // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ProjectileExplodeOnWorldFxSkinningKeyword;         // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ProjectileExpireNiagaraSystem;                     // 0x0530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ProjectileExpireFxSkinningKeyword;                 // 0x0538(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         MuzzleFlashNiagaraSystem;                          // 0x0540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleFlashFxSkinningKeyword;                      // 0x0548(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             MuzzleFlashSFX;                                    // 0x0550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleFlashSFxSkinningKeyword;                     // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             MuzzleFlashOffset;                                 // 0x0560(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      SpawnedDestroyFxComponent;                         // 0x05C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      SpawnedMuzzleFlashFxComponent;                     // 0x05C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  HomingTarget;                                      // 0x05D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyHitHomingTarget;                              // 0x05D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreHomingTargetHitsBehindOwnerOnSpawn;         // 0x05D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequiresHomingTargetForSpawn;                     // 0x05DA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExpireWhenHomingTargetIsLost;                     // 0x05DB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHomingCanHitPastMaxRange;                         // 0x05DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLastValidHomingLocationIfHomingTargetLost;     // 0x05DD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DE[0x2];                                      // 0x05DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USplineComponent>        SplineToFollow;                                    // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LobGroundTargetLocation;                           // 0x05E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         LobGroundWarningNiagaraSystem;                     // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LobGroundWarningSkinningKeyword;                   // 0x0608(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      LobGroundWarningNiagaraComponent;                  // 0x0610(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FHWProjectileDeployableConfig> DeployableConfigs;               // 0x0618(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         ExplosionTriggerFlags;                             // 0x0668(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseTargetLocationForExplosionLocation;            // 0x0669(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseProjectedTargetLocationForExplosionLocation;   // 0x066A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66B[0x5];                                      // 0x066B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityAttackSettings_Sphere*        ExplosionAttackSettings;                           // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_678[0x18];                                     // 0x0678(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateDestroyedVisuals();
	void ApplyGameplayEffect(TArray<struct FActiveGameplayEffectHandle>* OutAppliedEffects, TSubclassOf<class UGameplayEffect> GameplayEffect, const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayEffectContextHandle& EffectContext, int32 StackCount, int32 LevelOverride);
	void ApplyGameplayEffectSpec(const struct FGameplayEffectSpecHandle& EffectSpecHandle, const struct FGameplayAbilityTargetDataHandle& TargetData);
	TArray<struct FActiveGameplayEffectHandle> ApplyGameplayEffectsWithGroupTag(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& EffectGroupTag, const struct FGameplayEffectContextHandle& EffectContext, int32 StackCount, int32 LevelOverride);
	void BeginDestroyProjectile(const EHWDestroyProjectileReason DestroyReason, const struct FHitResult& DestroyHit, const bool bDestroyImmediately);
	void BP_OnInitializeProjectile(const class UHWAbilityTask_SpawnProjectile* SpawnTask);
	void BP_OnProjectileDestroyed(const EHWDestroyProjectileReason DestroyReason, const struct FHitResult& DestroyHit);
	void BP_OnProjectileGameplayEffectsInitialized();
	class AHWDeployable* BP_SpawnDeployable(const struct FTransform& SpawnTransform, const struct FGameplayTag& DeployableConfigTag, const int32 DeployableLvl, const struct FHitResult& HitTrigger);
	float GetTargetCollisionSettingsCollisionRadius();
	void HandleOnPawnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void InitializeProjectile(const int32 InstanceId, class UHWGameplayAbility* InAbilityOwner, const class UHWAbilityAttackSettings_Projectile* InProjectileAttackSettings, const class UHWAbilityTask_SpawnProjectile* SpawnTask, const float Range);
	void MaxRangeReached(class UHWGameplayMovementComponent* MovementComponent);
	void OnDeployableBeginSpawning(class AHWDeployable* SpawnedDeployable, const struct FHWProjectileDeployableConfig& DeployableConfig, const struct FHitResult& HitTrigger);
	void OnDeployableSpawned(class AHWDeployable* SpawnedDeployable, const struct FHWProjectileDeployableConfig& DeployableConfig, const struct FHitResult& HitTrigger);
	void OnHomingTargetAcquired();
	void OnHomingTargetDestroyed(class AActor* DestroyedActor);
	void OnHomingTargetDied(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, float RespawnTimerDuration);
	void OnHomingTargetLost();
	void OnHomingTargetPlaneOfExistenceChanged(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void OnHomingTargetUntargetableStateChanged(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void OnProjectileExplosionHitTarget(const struct FGameplayAbilityTargetDataHandle& TargetData);
	void OnProjectileHitTarget(const struct FGameplayAbilityTargetDataHandle& TargetData);
	void OnProjectileTargetOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void OnProjectileWorldHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnSpawnExplosionFx(const struct FVector& ExplosionLocation, const EHWDestroyProjectileReason ExplodeReason, const struct FHitResult& ExplosionHitInfo);
	void PerformExplosionAttack(const struct FHitResult& DestroyHit);
	void ProcessProjectileTargetOverlap(class AActor* HitActor, const struct FHitResult& Hit);
	void SetHomingTarget(class AActor* Target);
	void SetProjectileLevel(int32 NewLevel);
	void SetRange(const float Range);
	void SetSpeed(float Speed);
	void SpawnMuzzleFlashVFX(const struct FVector& Location, const struct FRotator& Rotation);
	void SpawnProjectileDestroyVFX(const struct FVector& Location, const struct FRotator& Rotation);

	void CalcHighlightingTargetList(const struct FHWAttackTargetingInfo& TargetingInfo, const class UHWAbilityAttackSettings_Projectile* AttackSettings, struct FGameplayAbilityTargetDataHandle& TargetListDataHandle) const;
	void GetAllDeployableConfigForSpawnTrigger(const EHWProjectileSpawnDeployableTrigger SpawnTrigger, TArray<struct FHWProjectileDeployableConfig>* OutDeployableConfigs) const;
	class UHWApparelComponent* GetApparelComponent() const;
	const class UHWSkinItem* GetCurrentSkin() const;
	struct FGameplayEffectSpecHandle GetEffectSpecForEffect(TSubclassOf<class UGameplayEffect> GameplayEffect) const;
	struct FHWAbilityFiringInstanceId GetFiringInstanceId() const;
	class AActor* GetHomingTarget() const;
	TSoftObjectPtr<class UHWEquipmentItem> GetOriginalEquipmentItem() const;
	int32 GetProjectileInstanceId() const;
	int32 GetProjectileLevel() const;
	class UHWProjectileMovementComponent* GetProjectileMovementComponent() const;
	float GetProjectileRange() const;
	const struct FTransform GetSpawnOrigin() const;
	bool HasAoeExplosion() const;
	bool HasGameNetworkAuthority() const;
	bool HasValidHomingTarget() const;
	bool IsEnemyActor(const class AActor* OtherActor) const;
	bool IsHitInRange(const struct FHitResult& Hit, const struct FTransform& SpawnTransform, const float& Range) const;
	bool IsHomingProjectile() const;
	bool IsProjectileBeingDestroyed() const;
	struct FGameplayEffectSpecHandle MakeOutgoingSpecUsingEffectSpecMap(TSubclassOf<class UGameplayEffect> GameplayEffectClass, const struct FGameplayEffectContextHandle& Context, int32 LevelOverride) const;
	struct FGameplayEffectContextHandle MakeProjectileEffectContext() const;
	struct FGameplayEffectContextHandle MakeProjectileEffectContextWithHitResult(const struct FHitResult& HitResult) const;
	bool ShouldApplyHitEffectsToActor(class AActor* TargetActor, const struct FGameplayTargetDataFilterHandle& InAcceptableProjectileHitFilterHandle, const struct FGameplayTargetDataFilterHandle& InAllyAcceptableProjectileHitFilterHandle) const;
	bool ShouldDestroyOnTargetHit(const class AActor* OtherActor, const struct FGameplayTargetDataFilterHandle& InAllyAcceptableProjectileHitFilter, const struct FGameplayTargetDataFilterHandle& InDestroyOnTargetHitFilter) const;
	bool ShouldDestroyOnWorldHit(const class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FHitResult& Hit, const bool bIsPredicting) const;
	bool ShouldExplodeOnTrigger(const EHWDestroyProjectileReason ExplodeTrigger, const int32 AbilityLevel) const;
	bool ShouldUseTargetLocationForExplosionLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWProjectile">();
	}
	static class AHWProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWProjectile>();
	}
};
static_assert(alignof(AHWProjectile) == 0x000010, "Wrong alignment on AHWProjectile");
static_assert(sizeof(AHWProjectile) == 0x000690, "Wrong size on AHWProjectile");
static_assert(offsetof(AHWProjectile, ProjectileInstigator) == 0x0002B0, "Member 'AHWProjectile::ProjectileInstigator' has a wrong offset!");
static_assert(offsetof(AHWProjectile, OwningAbility) == 0x0002B8, "Member 'AHWProjectile::OwningAbility' has a wrong offset!");
static_assert(offsetof(AHWProjectile, OriginalSpawnTransform) == 0x0002C0, "Member 'AHWProjectile::OriginalSpawnTransform' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileRecentSpawnTimer) == 0x000320, "Member 'AHWProjectile::ProjectileRecentSpawnTimer' has a wrong offset!");
static_assert(offsetof(AHWProjectile, AttackID) == 0x00032C, "Member 'AHWProjectile::AttackID' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bIsInhand) == 0x000334, "Member 'AHWProjectile::bIsInhand' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bCanDestroyOnTargetHit) == 0x000335, "Member 'AHWProjectile::bCanDestroyOnTargetHit' has a wrong offset!");
static_assert(offsetof(AHWProjectile, DestroyOnTargetHitFilterHandle) == 0x000338, "Member 'AHWProjectile::DestroyOnTargetHitFilterHandle' has a wrong offset!");
static_assert(offsetof(AHWProjectile, DestroyOnAllyTargetHitFilterHandle) == 0x000348, "Member 'AHWProjectile::DestroyOnAllyTargetHitFilterHandle' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bDestroyOnWorldHit) == 0x000358, "Member 'AHWProjectile::bDestroyOnWorldHit' has a wrong offset!");
static_assert(offsetof(AHWProjectile, DestroyProjectileReason) == 0x000359, "Member 'AHWProjectile::DestroyProjectileReason' has a wrong offset!");
static_assert(offsetof(AHWProjectile, DestroyTimer) == 0x000360, "Member 'AHWProjectile::DestroyTimer' has a wrong offset!");
static_assert(offsetof(AHWProjectile, TimeToFinishDestroy) == 0x000368, "Member 'AHWProjectile::TimeToFinishDestroy' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileBeginDestroyDel) == 0x000370, "Member 'AHWProjectile::ProjectileBeginDestroyDel' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileInstanceId) == 0x000380, "Member 'AHWProjectile::ProjectileInstanceId' has a wrong offset!");
static_assert(offsetof(AHWProjectile, InterestedControllersToFlash) == 0x000388, "Member 'AHWProjectile::InterestedControllersToFlash' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileMovementComponent) == 0x000398, "Member 'AHWProjectile::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileLevel) == 0x0003A0, "Member 'AHWProjectile::ProjectileLevel' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bCalculateSpeedBasedOnRangeAndLifetime) == 0x0003A4, "Member 'AHWProjectile::bCalculateSpeedBasedOnRangeAndLifetime' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileRange) == 0x0003A8, "Member 'AHWProjectile::ProjectileRange' has a wrong offset!");
static_assert(offsetof(AHWProjectile, RootCollisionComponent) == 0x0003E0, "Member 'AHWProjectile::RootCollisionComponent' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bUseSeparateCollisionForTargets) == 0x0003E8, "Member 'AHWProjectile::bUseSeparateCollisionForTargets' has a wrong offset!");
static_assert(offsetof(AHWProjectile, TargetCollisionSettings) == 0x0003EC, "Member 'AHWProjectile::TargetCollisionSettings' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bShouldTreatStructuresAsWorldHits) == 0x000408, "Member 'AHWProjectile::bShouldTreatStructuresAsWorldHits' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bCanHitPastMaxRange) == 0x000409, "Member 'AHWProjectile::bCanHitPastMaxRange' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bCanHitBehindSpawnLocation) == 0x00040A, "Member 'AHWProjectile::bCanHitBehindSpawnLocation' has a wrong offset!");
static_assert(offsetof(AHWProjectile, HitActors) == 0x000410, "Member 'AHWProjectile::HitActors' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bUseSeparateFilterForAllies) == 0x000420, "Member 'AHWProjectile::bUseSeparateFilterForAllies' has a wrong offset!");
static_assert(offsetof(AHWProjectile, AcceptableProjectileHitFilterHandle) == 0x000428, "Member 'AHWProjectile::AcceptableProjectileHitFilterHandle' has a wrong offset!");
static_assert(offsetof(AHWProjectile, AllyAcceptableProjectileHitFilterHandle) == 0x000438, "Member 'AHWProjectile::AllyAcceptableProjectileHitFilterHandle' has a wrong offset!");
static_assert(offsetof(AHWProjectile, OutGoingGameplayEffects) == 0x000448, "Member 'AHWProjectile::OutGoingGameplayEffects' has a wrong offset!");
static_assert(offsetof(AHWProjectile, AbilityConfigEffectGroups) == 0x000498, "Member 'AHWProjectile::AbilityConfigEffectGroups' has a wrong offset!");
static_assert(offsetof(AHWProjectile, AdditionalEffectsToCache) == 0x0004E8, "Member 'AHWProjectile::AdditionalEffectsToCache' has a wrong offset!");
static_assert(offsetof(AHWProjectile, DefaultProjectileEffectContext) == 0x0004F8, "Member 'AHWProjectile::DefaultProjectileEffectContext' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileExplodeOnTargetNiagaraSystem) == 0x000510, "Member 'AHWProjectile::ProjectileExplodeOnTargetNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileExplodeOnTargetFxSkinningKeyword) == 0x000518, "Member 'AHWProjectile::ProjectileExplodeOnTargetFxSkinningKeyword' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileExplodeOnWorldNiagaraSystem) == 0x000520, "Member 'AHWProjectile::ProjectileExplodeOnWorldNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileExplodeOnWorldFxSkinningKeyword) == 0x000528, "Member 'AHWProjectile::ProjectileExplodeOnWorldFxSkinningKeyword' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileExpireNiagaraSystem) == 0x000530, "Member 'AHWProjectile::ProjectileExpireNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ProjectileExpireFxSkinningKeyword) == 0x000538, "Member 'AHWProjectile::ProjectileExpireFxSkinningKeyword' has a wrong offset!");
static_assert(offsetof(AHWProjectile, MuzzleFlashNiagaraSystem) == 0x000540, "Member 'AHWProjectile::MuzzleFlashNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AHWProjectile, MuzzleFlashFxSkinningKeyword) == 0x000548, "Member 'AHWProjectile::MuzzleFlashFxSkinningKeyword' has a wrong offset!");
static_assert(offsetof(AHWProjectile, MuzzleFlashSFX) == 0x000550, "Member 'AHWProjectile::MuzzleFlashSFX' has a wrong offset!");
static_assert(offsetof(AHWProjectile, MuzzleFlashSFxSkinningKeyword) == 0x000558, "Member 'AHWProjectile::MuzzleFlashSFxSkinningKeyword' has a wrong offset!");
static_assert(offsetof(AHWProjectile, MuzzleFlashOffset) == 0x000560, "Member 'AHWProjectile::MuzzleFlashOffset' has a wrong offset!");
static_assert(offsetof(AHWProjectile, SpawnedDestroyFxComponent) == 0x0005C0, "Member 'AHWProjectile::SpawnedDestroyFxComponent' has a wrong offset!");
static_assert(offsetof(AHWProjectile, SpawnedMuzzleFlashFxComponent) == 0x0005C8, "Member 'AHWProjectile::SpawnedMuzzleFlashFxComponent' has a wrong offset!");
static_assert(offsetof(AHWProjectile, HomingTarget) == 0x0005D0, "Member 'AHWProjectile::HomingTarget' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bOnlyHitHomingTarget) == 0x0005D8, "Member 'AHWProjectile::bOnlyHitHomingTarget' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bIgnoreHomingTargetHitsBehindOwnerOnSpawn) == 0x0005D9, "Member 'AHWProjectile::bIgnoreHomingTargetHitsBehindOwnerOnSpawn' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bRequiresHomingTargetForSpawn) == 0x0005DA, "Member 'AHWProjectile::bRequiresHomingTargetForSpawn' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bExpireWhenHomingTargetIsLost) == 0x0005DB, "Member 'AHWProjectile::bExpireWhenHomingTargetIsLost' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bHomingCanHitPastMaxRange) == 0x0005DC, "Member 'AHWProjectile::bHomingCanHitPastMaxRange' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bUseLastValidHomingLocationIfHomingTargetLost) == 0x0005DD, "Member 'AHWProjectile::bUseLastValidHomingLocationIfHomingTargetLost' has a wrong offset!");
static_assert(offsetof(AHWProjectile, SplineToFollow) == 0x0005E0, "Member 'AHWProjectile::SplineToFollow' has a wrong offset!");
static_assert(offsetof(AHWProjectile, LobGroundTargetLocation) == 0x0005E8, "Member 'AHWProjectile::LobGroundTargetLocation' has a wrong offset!");
static_assert(offsetof(AHWProjectile, LobGroundWarningNiagaraSystem) == 0x000600, "Member 'AHWProjectile::LobGroundWarningNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AHWProjectile, LobGroundWarningSkinningKeyword) == 0x000608, "Member 'AHWProjectile::LobGroundWarningSkinningKeyword' has a wrong offset!");
static_assert(offsetof(AHWProjectile, LobGroundWarningNiagaraComponent) == 0x000610, "Member 'AHWProjectile::LobGroundWarningNiagaraComponent' has a wrong offset!");
static_assert(offsetof(AHWProjectile, DeployableConfigs) == 0x000618, "Member 'AHWProjectile::DeployableConfigs' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ExplosionTriggerFlags) == 0x000668, "Member 'AHWProjectile::ExplosionTriggerFlags' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bUseTargetLocationForExplosionLocation) == 0x000669, "Member 'AHWProjectile::bUseTargetLocationForExplosionLocation' has a wrong offset!");
static_assert(offsetof(AHWProjectile, bUseProjectedTargetLocationForExplosionLocation) == 0x00066A, "Member 'AHWProjectile::bUseProjectedTargetLocationForExplosionLocation' has a wrong offset!");
static_assert(offsetof(AHWProjectile, ExplosionAttackSettings) == 0x000670, "Member 'AHWProjectile::ExplosionAttackSettings' has a wrong offset!");

// Class Hemingway.HWProjectile_NuWa_Inhand
// 0x0010 (0x06A0 - 0x0690)
class AHWProjectile_NuWa_Inhand final : public AHWProjectile
{
public:
	float                                         StrengthOfFireRange;                               // 0x0690(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_694[0xC];                                      // 0x0694(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWProjectile_NuWa_Inhand">();
	}
	static class AHWProjectile_NuWa_Inhand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWProjectile_NuWa_Inhand>();
	}
};
static_assert(alignof(AHWProjectile_NuWa_Inhand) == 0x000010, "Wrong alignment on AHWProjectile_NuWa_Inhand");
static_assert(sizeof(AHWProjectile_NuWa_Inhand) == 0x0006A0, "Wrong size on AHWProjectile_NuWa_Inhand");
static_assert(offsetof(AHWProjectile_NuWa_Inhand, StrengthOfFireRange) == 0x000690, "Member 'AHWProjectile_NuWa_Inhand::StrengthOfFireRange' has a wrong offset!");

// Class Hemingway.HWMapItem
// 0x0090 (0x0240 - 0x01B0)
class UHWMapItem final : public UHWInventoryItem
{
public:
	bool                                          bIsDisabled;                                       // 0x01B0(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UWorld>>          MapPersistentLevels;                               // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UWorld>>          DevOnlySubLevels;                                  // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bIsDevMap;                                         // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x17];                                     // 0x01D9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, TSoftObjectPtr<class UTexture2D>> DisplayTexturesByTag;                // 0x01F0(0x0050)(Edit, BlueprintReadOnly, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void GetAllTexturesForGameplayTag(const struct FGameplayTag& GameplayTag, TMap<struct FGameplayTag, TSoftObjectPtr<class UTexture2D>>* OutTextures) const;
	TSoftObjectPtr<class UTexture2D> GetTextureForExactGameplayTag(const struct FGameplayTag& GameplayTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWMapItem">();
	}
	static class UHWMapItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWMapItem>();
	}
};
static_assert(alignof(UHWMapItem) == 0x000008, "Wrong alignment on UHWMapItem");
static_assert(sizeof(UHWMapItem) == 0x000240, "Wrong size on UHWMapItem");
static_assert(offsetof(UHWMapItem, bIsDisabled) == 0x0001B0, "Member 'UHWMapItem::bIsDisabled' has a wrong offset!");
static_assert(offsetof(UHWMapItem, MapPersistentLevels) == 0x0001B8, "Member 'UHWMapItem::MapPersistentLevels' has a wrong offset!");
static_assert(offsetof(UHWMapItem, DevOnlySubLevels) == 0x0001C8, "Member 'UHWMapItem::DevOnlySubLevels' has a wrong offset!");
static_assert(offsetof(UHWMapItem, bIsDevMap) == 0x0001D8, "Member 'UHWMapItem::bIsDevMap' has a wrong offset!");
static_assert(offsetof(UHWMapItem, DisplayTexturesByTag) == 0x0001F0, "Member 'UHWMapItem::DisplayTexturesByTag' has a wrong offset!");

// Class Hemingway.HWProjectile_Returning
// 0x0010 (0x06A0 - 0x0690)
class AHWProjectile_Returning final : public AHWProjectile
{
public:
	bool                                          bIsReturning;                                      // 0x0690(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWProjectileReturnTrigger                    ProjectileReturnTrigger;                           // 0x0691(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTriggerReturnOnWorldHit;                          // 0x0692(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopDuringReturnOnWorldHit;                       // 0x0693(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TravelTimeBeforeReturning;                         // 0x0694(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ReturnTimer;                                       // 0x0698(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BeginProjectileReturn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWProjectile_Returning">();
	}
	static class AHWProjectile_Returning* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWProjectile_Returning>();
	}
};
static_assert(alignof(AHWProjectile_Returning) == 0x000010, "Wrong alignment on AHWProjectile_Returning");
static_assert(sizeof(AHWProjectile_Returning) == 0x0006A0, "Wrong size on AHWProjectile_Returning");
static_assert(offsetof(AHWProjectile_Returning, bIsReturning) == 0x000690, "Member 'AHWProjectile_Returning::bIsReturning' has a wrong offset!");
static_assert(offsetof(AHWProjectile_Returning, ProjectileReturnTrigger) == 0x000691, "Member 'AHWProjectile_Returning::ProjectileReturnTrigger' has a wrong offset!");
static_assert(offsetof(AHWProjectile_Returning, bTriggerReturnOnWorldHit) == 0x000692, "Member 'AHWProjectile_Returning::bTriggerReturnOnWorldHit' has a wrong offset!");
static_assert(offsetof(AHWProjectile_Returning, bStopDuringReturnOnWorldHit) == 0x000693, "Member 'AHWProjectile_Returning::bStopDuringReturnOnWorldHit' has a wrong offset!");
static_assert(offsetof(AHWProjectile_Returning, TravelTimeBeforeReturning) == 0x000694, "Member 'AHWProjectile_Returning::TravelTimeBeforeReturning' has a wrong offset!");
static_assert(offsetof(AHWProjectile_Returning, ReturnTimer) == 0x000698, "Member 'AHWProjectile_Returning::ReturnTimer' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Damage
// 0x0128 (0x0BE0 - 0x0AB8)
class UHWGameplayEffect_Damage : public UHWGameplayEffect
{
public:
	struct FGameplayTag                           DamageType;                                        // 0x0AB8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FloatingTextTagOverride;                           // 0x0AC0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SuppressDamageNumbers;                             // 0x0AC8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC9[0x7];                                      // 0x0AC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FGameplayEffectModifierMagnitude> AttackPowerScalingFactors;    // 0x0AD0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         InhandStructureMagicalAttackPowerScalingCoefficent; // 0x0B20(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InhandStructurePhysicalAttackPowerScalingCoefficent; // 0x0B24(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CritDamageCoefficent;                              // 0x0B28(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2C[0x4];                                      // 0x0B2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FGameplayEffectModifierMagnitude> LifeStealScalingFactors;      // 0x0B30(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          InflictsHitReactions;                              // 0x0B80(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B81[0x3];                                      // 0x0B81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitReactionKnockbackDistance;                      // 0x0B84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactionKnockbackVelocity;                      // 0x0B88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8C[0x4];                                      // 0x0B8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         BaseDamageStackMultiplier;                         // 0x0B90(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ScalingDamageStackMultiplier;                      // 0x0BB8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	float GetBaseDamageStackMuliplier(const int32 StackCount) const;
	struct FGameplayTag GetDamageType() const;
	struct FGameplayTag GetFloatingTextTagOverride() const;
	float GetScalingDamageStackMuliplier(const int32 StackCount) const;
	bool GetSuppressDamageNumbers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Damage">();
	}
	static class UHWGameplayEffect_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Damage>();
	}
};
static_assert(alignof(UHWGameplayEffect_Damage) == 0x000008, "Wrong alignment on UHWGameplayEffect_Damage");
static_assert(sizeof(UHWGameplayEffect_Damage) == 0x000BE0, "Wrong size on UHWGameplayEffect_Damage");
static_assert(offsetof(UHWGameplayEffect_Damage, DamageType) == 0x000AB8, "Member 'UHWGameplayEffect_Damage::DamageType' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, FloatingTextTagOverride) == 0x000AC0, "Member 'UHWGameplayEffect_Damage::FloatingTextTagOverride' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, SuppressDamageNumbers) == 0x000AC8, "Member 'UHWGameplayEffect_Damage::SuppressDamageNumbers' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, AttackPowerScalingFactors) == 0x000AD0, "Member 'UHWGameplayEffect_Damage::AttackPowerScalingFactors' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, InhandStructureMagicalAttackPowerScalingCoefficent) == 0x000B20, "Member 'UHWGameplayEffect_Damage::InhandStructureMagicalAttackPowerScalingCoefficent' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, InhandStructurePhysicalAttackPowerScalingCoefficent) == 0x000B24, "Member 'UHWGameplayEffect_Damage::InhandStructurePhysicalAttackPowerScalingCoefficent' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, CritDamageCoefficent) == 0x000B28, "Member 'UHWGameplayEffect_Damage::CritDamageCoefficent' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, LifeStealScalingFactors) == 0x000B30, "Member 'UHWGameplayEffect_Damage::LifeStealScalingFactors' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, InflictsHitReactions) == 0x000B80, "Member 'UHWGameplayEffect_Damage::InflictsHitReactions' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, HitReactionKnockbackDistance) == 0x000B84, "Member 'UHWGameplayEffect_Damage::HitReactionKnockbackDistance' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, HitReactionKnockbackVelocity) == 0x000B88, "Member 'UHWGameplayEffect_Damage::HitReactionKnockbackVelocity' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, BaseDamageStackMultiplier) == 0x000B90, "Member 'UHWGameplayEffect_Damage::BaseDamageStackMultiplier' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Damage, ScalingDamageStackMultiplier) == 0x000BB8, "Member 'UHWGameplayEffect_Damage::ScalingDamageStackMultiplier' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Execute
// 0x0000 (0x0BE0 - 0x0BE0)
class UHWGameplayEffect_Execute final : public UHWGameplayEffect_Damage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Execute">();
	}
	static class UHWGameplayEffect_Execute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Execute>();
	}
};
static_assert(alignof(UHWGameplayEffect_Execute) == 0x000008, "Wrong alignment on UHWGameplayEffect_Execute");
static_assert(sizeof(UHWGameplayEffect_Execute) == 0x000BE0, "Wrong size on UHWGameplayEffect_Execute");

// Class Hemingway.HWProjectile_Seeking
// 0x0000 (0x0690 - 0x0690)
class AHWProjectile_Seeking final : public AHWProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWProjectile_Seeking">();
	}
	static class AHWProjectile_Seeking* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWProjectile_Seeking>();
	}
};
static_assert(alignof(AHWProjectile_Seeking) == 0x000010, "Wrong alignment on AHWProjectile_Seeking");
static_assert(sizeof(AHWProjectile_Seeking) == 0x000690, "Wrong size on AHWProjectile_Seeking");

// Class Hemingway.HWQuest
// 0x00E0 (0x0290 - 0x01B0)
class UHWQuest : public UHWInventoryItem
{
public:
	class FString                                 QuestName;                                         // 0x01B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             TrackingItem;                                      // 0x01C0(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             ProgressLoot;                                      // 0x01D4(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendsProgressToClient;                            // 0x01E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x3];                                      // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         XpTableId;                                         // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWQuestTierConfig>             QuestTiers;                                        // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             RequiredCharacterChoice;                           // 0x0200(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCacheProgress;                                    // 0x0214(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InfiniteLoopSize;                                  // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCoopProgress;                                // 0x021C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D[0x3];                                      // 0x021D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCoopProgress;                                   // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisabled;                                       // 0x0224(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWActiveQuest>             ProcessingClass;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHWQuestComponent*>              QuestComponents;                                   // 0x0230(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      ModeFlagFilter;                                    // 0x0240(0x0048)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bRequireItemOwnership;                             // 0x0288(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowQuestTitle;                                   // 0x0289(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A[0x6];                                      // 0x028A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool WantsToTrackMatchForPlayer(const class AHWPlayerState* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest">();
	}
	static class UHWQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest>();
	}
};
static_assert(alignof(UHWQuest) == 0x000008, "Wrong alignment on UHWQuest");
static_assert(sizeof(UHWQuest) == 0x000290, "Wrong size on UHWQuest");
static_assert(offsetof(UHWQuest, QuestName) == 0x0001B0, "Member 'UHWQuest::QuestName' has a wrong offset!");
static_assert(offsetof(UHWQuest, TrackingItem) == 0x0001C0, "Member 'UHWQuest::TrackingItem' has a wrong offset!");
static_assert(offsetof(UHWQuest, ProgressLoot) == 0x0001D4, "Member 'UHWQuest::ProgressLoot' has a wrong offset!");
static_assert(offsetof(UHWQuest, bSendsProgressToClient) == 0x0001E8, "Member 'UHWQuest::bSendsProgressToClient' has a wrong offset!");
static_assert(offsetof(UHWQuest, XpTableId) == 0x0001EC, "Member 'UHWQuest::XpTableId' has a wrong offset!");
static_assert(offsetof(UHWQuest, QuestTiers) == 0x0001F0, "Member 'UHWQuest::QuestTiers' has a wrong offset!");
static_assert(offsetof(UHWQuest, RequiredCharacterChoice) == 0x000200, "Member 'UHWQuest::RequiredCharacterChoice' has a wrong offset!");
static_assert(offsetof(UHWQuest, bCacheProgress) == 0x000214, "Member 'UHWQuest::bCacheProgress' has a wrong offset!");
static_assert(offsetof(UHWQuest, InfiniteLoopSize) == 0x000218, "Member 'UHWQuest::InfiniteLoopSize' has a wrong offset!");
static_assert(offsetof(UHWQuest, bAllowCoopProgress) == 0x00021C, "Member 'UHWQuest::bAllowCoopProgress' has a wrong offset!");
static_assert(offsetof(UHWQuest, MaxCoopProgress) == 0x000220, "Member 'UHWQuest::MaxCoopProgress' has a wrong offset!");
static_assert(offsetof(UHWQuest, bIsDisabled) == 0x000224, "Member 'UHWQuest::bIsDisabled' has a wrong offset!");
static_assert(offsetof(UHWQuest, ProcessingClass) == 0x000228, "Member 'UHWQuest::ProcessingClass' has a wrong offset!");
static_assert(offsetof(UHWQuest, QuestComponents) == 0x000230, "Member 'UHWQuest::QuestComponents' has a wrong offset!");
static_assert(offsetof(UHWQuest, ModeFlagFilter) == 0x000240, "Member 'UHWQuest::ModeFlagFilter' has a wrong offset!");
static_assert(offsetof(UHWQuest, bRequireItemOwnership) == 0x000288, "Member 'UHWQuest::bRequireItemOwnership' has a wrong offset!");
static_assert(offsetof(UHWQuest, bShowQuestTitle) == 0x000289, "Member 'UHWQuest::bShowQuestTitle' has a wrong offset!");

// Class Hemingway.HWCameraComponent
// 0x0010 (0x0A50 - 0x0A40)
class UHWCameraComponent final : public UCameraComponent
{
public:
	float                                         MinimumOwnerDrawDistance;                          // 0x0A40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A44[0xC];                                      // 0x0A44(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCameraComponent">();
	}
	static class UHWCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCameraComponent>();
	}
};
static_assert(alignof(UHWCameraComponent) == 0x000010, "Wrong alignment on UHWCameraComponent");
static_assert(sizeof(UHWCameraComponent) == 0x000A50, "Wrong size on UHWCameraComponent");
static_assert(offsetof(UHWCameraComponent, MinimumOwnerDrawDistance) == 0x000A40, "Member 'UHWCameraComponent::MinimumOwnerDrawDistance' has a wrong offset!");

// Class Hemingway.HWQuestComponent
// 0x0010 (0x0038 - 0x0028)
class UHWQuestComponent : public UObject
{
public:
	TWeakObjectPtr<class UHWQuest>                RootQuest;                                         // 0x0028(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacterAbilitySystemActor*         WatchedASA;                                        // 0x0030(0x0008)(BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuestComponent">();
	}
	static class UHWQuestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuestComponent>();
	}
};
static_assert(alignof(UHWQuestComponent) == 0x000008, "Wrong alignment on UHWQuestComponent");
static_assert(sizeof(UHWQuestComponent) == 0x000038, "Wrong size on UHWQuestComponent");
static_assert(offsetof(UHWQuestComponent, RootQuest) == 0x000028, "Member 'UHWQuestComponent::RootQuest' has a wrong offset!");
static_assert(offsetof(UHWQuestComponent, WatchedASA) == 0x000030, "Member 'UHWQuestComponent::WatchedASA' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Root
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Root : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Root">();
	}
	static class UHWGameplayEffect_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Root>();
	}
};
static_assert(alignof(UHWGameplayEffect_Root) == 0x000008, "Wrong alignment on UHWGameplayEffect_Root");
static_assert(sizeof(UHWGameplayEffect_Root) == 0x000AC8, "Wrong size on UHWGameplayEffect_Root");

// Class Hemingway.HWQuestComponent_AscensionBooster
// 0x0008 (0x0040 - 0x0038)
class UHWQuestComponent_AscensionBooster final : public UHWQuestComponent
{
public:
	float                                         AscensionPassMultiplier;                           // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuestComponent_AscensionBooster">();
	}
	static class UHWQuestComponent_AscensionBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuestComponent_AscensionBooster>();
	}
};
static_assert(alignof(UHWQuestComponent_AscensionBooster) == 0x000008, "Wrong alignment on UHWQuestComponent_AscensionBooster");
static_assert(sizeof(UHWQuestComponent_AscensionBooster) == 0x000040, "Wrong size on UHWQuestComponent_AscensionBooster");
static_assert(offsetof(UHWQuestComponent_AscensionBooster, AscensionPassMultiplier) == 0x000038, "Member 'UHWQuestComponent_AscensionBooster::AscensionPassMultiplier' has a wrong offset!");

// Class Hemingway.HWQuestComponent_Booster
// 0x0010 (0x0048 - 0x0038)
class UHWQuestComponent_Booster final : public UHWQuestComponent
{
public:
	struct FGameplayTag                           BoosterTag;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoosterMultiplier;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuestComponent_Booster">();
	}
	static class UHWQuestComponent_Booster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuestComponent_Booster>();
	}
};
static_assert(alignof(UHWQuestComponent_Booster) == 0x000008, "Wrong alignment on UHWQuestComponent_Booster");
static_assert(sizeof(UHWQuestComponent_Booster) == 0x000048, "Wrong size on UHWQuestComponent_Booster");
static_assert(offsetof(UHWQuestComponent_Booster, BoosterTag) == 0x000038, "Member 'UHWQuestComponent_Booster::BoosterTag' has a wrong offset!");
static_assert(offsetof(UHWQuestComponent_Booster, BoosterMultiplier) == 0x000040, "Member 'UHWQuestComponent_Booster::BoosterMultiplier' has a wrong offset!");

// Class Hemingway.HWQuestComponent_ItemOwnership
// 0x0020 (0x0058 - 0x0038)
class UHWQuestComponent_ItemOwnership final : public UHWQuestComponent
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0038(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemOwnershipMultiplierSelf;                       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemOwnershipMultiplierTeam;                       // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuestComponent_ItemOwnership">();
	}
	static class UHWQuestComponent_ItemOwnership* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuestComponent_ItemOwnership>();
	}
};
static_assert(alignof(UHWQuestComponent_ItemOwnership) == 0x000008, "Wrong alignment on UHWQuestComponent_ItemOwnership");
static_assert(sizeof(UHWQuestComponent_ItemOwnership) == 0x000058, "Wrong size on UHWQuestComponent_ItemOwnership");
static_assert(offsetof(UHWQuestComponent_ItemOwnership, ItemId) == 0x000038, "Member 'UHWQuestComponent_ItemOwnership::ItemId' has a wrong offset!");
static_assert(offsetof(UHWQuestComponent_ItemOwnership, ItemOwnershipMultiplierSelf) == 0x00004C, "Member 'UHWQuestComponent_ItemOwnership::ItemOwnershipMultiplierSelf' has a wrong offset!");
static_assert(offsetof(UHWQuestComponent_ItemOwnership, ItemOwnershipMultiplierTeam) == 0x000050, "Member 'UHWQuestComponent_ItemOwnership::ItemOwnershipMultiplierTeam' has a wrong offset!");

// Class Hemingway.HWCameraModifier_Dead
// 0x0778 (0x07C0 - 0x0048)
class alignas(0x10) UHWCameraModifier_Dead : public UCameraModifier
{
public:
	struct FHWSpecialEffect                       SpecialEffect;                                     // 0x0048(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x6F8];                                     // 0x00B8(0x06F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DeathPostProcessMID;                               // 0x07B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DeathPostProcessMIDParent;                         // 0x07B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCameraModifier_Dead">();
	}
	static class UHWCameraModifier_Dead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCameraModifier_Dead>();
	}
};
static_assert(alignof(UHWCameraModifier_Dead) == 0x000010, "Wrong alignment on UHWCameraModifier_Dead");
static_assert(sizeof(UHWCameraModifier_Dead) == 0x0007C0, "Wrong size on UHWCameraModifier_Dead");
static_assert(offsetof(UHWCameraModifier_Dead, SpecialEffect) == 0x000048, "Member 'UHWCameraModifier_Dead::SpecialEffect' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_Dead, DeathPostProcessMID) == 0x0007B0, "Member 'UHWCameraModifier_Dead::DeathPostProcessMID' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_Dead, DeathPostProcessMIDParent) == 0x0007B8, "Member 'UHWCameraModifier_Dead::DeathPostProcessMIDParent' has a wrong offset!");

// Class Hemingway.HWQuestComponent_KVMultiplier
// 0x0018 (0x0050 - 0x0038)
class UHWQuestComponent_KVMultiplier final : public UHWQuestComponent
{
public:
	class FString                                 KVString;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWQuestComponent_KVMultiplierType            MultiplierType;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedMultiplier;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuestComponent_KVMultiplier">();
	}
	static class UHWQuestComponent_KVMultiplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuestComponent_KVMultiplier>();
	}
};
static_assert(alignof(UHWQuestComponent_KVMultiplier) == 0x000008, "Wrong alignment on UHWQuestComponent_KVMultiplier");
static_assert(sizeof(UHWQuestComponent_KVMultiplier) == 0x000050, "Wrong size on UHWQuestComponent_KVMultiplier");
static_assert(offsetof(UHWQuestComponent_KVMultiplier, KVString) == 0x000038, "Member 'UHWQuestComponent_KVMultiplier::KVString' has a wrong offset!");
static_assert(offsetof(UHWQuestComponent_KVMultiplier, MultiplierType) == 0x000048, "Member 'UHWQuestComponent_KVMultiplier::MultiplierType' has a wrong offset!");
static_assert(offsetof(UHWQuestComponent_KVMultiplier, FixedMultiplier) == 0x00004C, "Member 'UHWQuestComponent_KVMultiplier::FixedMultiplier' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_KnockbackTracker
// 0x0008 (0x0AC0 - 0x0AB8)
class UHWGameplayEffect_KnockbackTracker : public UHWGameplayEffect
{
public:
	bool                                          bShouldIgnoreBlockingByInstigator;                 // 0x0AB8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB9[0x7];                                      // 0x0AB9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_KnockbackTracker">();
	}
	static class UHWGameplayEffect_KnockbackTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_KnockbackTracker>();
	}
};
static_assert(alignof(UHWGameplayEffect_KnockbackTracker) == 0x000008, "Wrong alignment on UHWGameplayEffect_KnockbackTracker");
static_assert(sizeof(UHWGameplayEffect_KnockbackTracker) == 0x000AC0, "Wrong size on UHWGameplayEffect_KnockbackTracker");
static_assert(offsetof(UHWGameplayEffect_KnockbackTracker, bShouldIgnoreBlockingByInstigator) == 0x000AB8, "Member 'UHWGameplayEffect_KnockbackTracker::bShouldIgnoreBlockingByInstigator' has a wrong offset!");

// Class Hemingway.HWQuestComponent_PartyMultiplier
// 0x0060 (0x0098 - 0x0038)
class UHWQuestComponent_PartyMultiplier final : public UHWQuestComponent
{
public:
	TMap<int32, float>                            PartyMultiplier;                                   // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FString                                 PartyMultiplierKV;                                 // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuestComponent_PartyMultiplier">();
	}
	static class UHWQuestComponent_PartyMultiplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuestComponent_PartyMultiplier>();
	}
};
static_assert(alignof(UHWQuestComponent_PartyMultiplier) == 0x000008, "Wrong alignment on UHWQuestComponent_PartyMultiplier");
static_assert(sizeof(UHWQuestComponent_PartyMultiplier) == 0x000098, "Wrong size on UHWQuestComponent_PartyMultiplier");
static_assert(offsetof(UHWQuestComponent_PartyMultiplier, PartyMultiplier) == 0x000038, "Member 'UHWQuestComponent_PartyMultiplier::PartyMultiplier' has a wrong offset!");
static_assert(offsetof(UHWQuestComponent_PartyMultiplier, PartyMultiplierKV) == 0x000088, "Member 'UHWQuestComponent_PartyMultiplier::PartyMultiplierKV' has a wrong offset!");

// Class Hemingway.HWActiveQuest
// 0x0068 (0x0090 - 0x0028)
class UHWActiveQuest : public UObject
{
public:
	int32                                         CachedInventoryProgress;                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LoopingQuestFrequency;                             // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHWQuestTierConfig>             CachedQuestTiers;                                  // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FRH_LootId                             CachedProgressLoot;                                // 0x0040(0x0014)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_ItemId                             CachedTrackedItem;                                 // 0x0054(0x0014)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHWQuest>                RootQuest;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacterAbilitySystemActor*         WatchedASA;                                        // 0x0070(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHWQuestComponent*>              ActiveQuestComponents;                             // 0x0078(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentSessionProgress;                            // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SessionTransientProgress;                          // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddTransientProgress(int32 CountToIncreaseProgress);
	void AwardQuestProgress(int32 CountToIncreaseProgress);
	int32 GetCurrentQuestProgress();
	int32 GetRemainingCoopProgressAvailable(int32 CountToIncreaseProgress);
	void TrackQuestForPlayer(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

	float GetCurrentWorldTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWActiveQuest">();
	}
	static class UHWActiveQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWActiveQuest>();
	}
};
static_assert(alignof(UHWActiveQuest) == 0x000008, "Wrong alignment on UHWActiveQuest");
static_assert(sizeof(UHWActiveQuest) == 0x000090, "Wrong size on UHWActiveQuest");
static_assert(offsetof(UHWActiveQuest, CachedInventoryProgress) == 0x000028, "Member 'UHWActiveQuest::CachedInventoryProgress' has a wrong offset!");
static_assert(offsetof(UHWActiveQuest, LoopingQuestFrequency) == 0x00002C, "Member 'UHWActiveQuest::LoopingQuestFrequency' has a wrong offset!");
static_assert(offsetof(UHWActiveQuest, CachedQuestTiers) == 0x000030, "Member 'UHWActiveQuest::CachedQuestTiers' has a wrong offset!");
static_assert(offsetof(UHWActiveQuest, CachedProgressLoot) == 0x000040, "Member 'UHWActiveQuest::CachedProgressLoot' has a wrong offset!");
static_assert(offsetof(UHWActiveQuest, CachedTrackedItem) == 0x000054, "Member 'UHWActiveQuest::CachedTrackedItem' has a wrong offset!");
static_assert(offsetof(UHWActiveQuest, RootQuest) == 0x000068, "Member 'UHWActiveQuest::RootQuest' has a wrong offset!");
static_assert(offsetof(UHWActiveQuest, WatchedASA) == 0x000070, "Member 'UHWActiveQuest::WatchedASA' has a wrong offset!");
static_assert(offsetof(UHWActiveQuest, ActiveQuestComponents) == 0x000078, "Member 'UHWActiveQuest::ActiveQuestComponents' has a wrong offset!");
static_assert(offsetof(UHWActiveQuest, CurrentSessionProgress) == 0x000088, "Member 'UHWActiveQuest::CurrentSessionProgress' has a wrong offset!");
static_assert(offsetof(UHWActiveQuest, SessionTransientProgress) == 0x00008C, "Member 'UHWActiveQuest::SessionTransientProgress' has a wrong offset!");

// Class Hemingway.HWQuest_AbilityTagListener
// 0x0020 (0x00B0 - 0x0090)
class UHWQuest_AbilityTagListener final : public UHWActiveQuest
{
public:
	struct FGameplayTagContainer                  AcceptedTags;                                      // 0x0090(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void HandleAbilityEvent(int32 ProgressToAward);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_AbilityTagListener">();
	}
	static class UHWQuest_AbilityTagListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_AbilityTagListener>();
	}
};
static_assert(alignof(UHWQuest_AbilityTagListener) == 0x000008, "Wrong alignment on UHWQuest_AbilityTagListener");
static_assert(sizeof(UHWQuest_AbilityTagListener) == 0x0000B0, "Wrong size on UHWQuest_AbilityTagListener");
static_assert(offsetof(UHWQuest_AbilityTagListener, AcceptedTags) == 0x000090, "Member 'UHWQuest_AbilityTagListener::AcceptedTags' has a wrong offset!");

// Class Hemingway.HWAbilitySystemGlobals
// 0x0008 (0x02B0 - 0x02A8)
class UHWAbilitySystemGlobals final : public UAbilitySystemGlobals
{
public:
	uint8                                         Pad_2A8[0x1];                                      // 0x02A8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPredictGameplayEffects;                           // 0x02A9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AA[0x6];                                      // 0x02AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAbilityTargetingDebug(const bool bOn);

	bool IsAbilityTargetingDebugEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilitySystemGlobals">();
	}
	static class UHWAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilitySystemGlobals>();
	}
};
static_assert(alignof(UHWAbilitySystemGlobals) == 0x000008, "Wrong alignment on UHWAbilitySystemGlobals");
static_assert(sizeof(UHWAbilitySystemGlobals) == 0x0002B0, "Wrong size on UHWAbilitySystemGlobals");
static_assert(offsetof(UHWAbilitySystemGlobals, bPredictGameplayEffects) == 0x0002A9, "Member 'UHWAbilitySystemGlobals::bPredictGameplayEffects' has a wrong offset!");

// Class Hemingway.HWBotGoal
// 0x0010 (0x02A8 - 0x0298)
class AHWBotGoal final : public AActor
{
public:
	TMulticastInlineDelegate<void(class AActor* Bot)> OnGoalReached;                                 // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void TriggerOnGoalReached(class AActor* BotInstigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBotGoal">();
	}
	static class AHWBotGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWBotGoal>();
	}
};
static_assert(alignof(AHWBotGoal) == 0x000008, "Wrong alignment on AHWBotGoal");
static_assert(sizeof(AHWBotGoal) == 0x0002A8, "Wrong size on AHWBotGoal");
static_assert(offsetof(AHWBotGoal, OnGoalReached) == 0x000298, "Member 'AHWBotGoal::OnGoalReached' has a wrong offset!");

// Class Hemingway.HWQuest_AttributeByModifierReason
// 0x0060 (0x00F0 - 0x0090)
class UHWQuest_AttributeByModifierReason : public UHWActiveQuest
{
public:
	TArray<struct FHWQuestAttributeRequirements>  AttributeRequirements;                             // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_AttributeByModifierReason">();
	}
	static class UHWQuest_AttributeByModifierReason* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_AttributeByModifierReason>();
	}
};
static_assert(alignof(UHWQuest_AttributeByModifierReason) == 0x000008, "Wrong alignment on UHWQuest_AttributeByModifierReason");
static_assert(sizeof(UHWQuest_AttributeByModifierReason) == 0x0000F0, "Wrong size on UHWQuest_AttributeByModifierReason");
static_assert(offsetof(UHWQuest_AttributeByModifierReason, AttributeRequirements) == 0x000090, "Member 'UHWQuest_AttributeByModifierReason::AttributeRequirements' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Vortex
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Vortex : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Vortex">();
	}
	static class UHWGameplayEffect_Vortex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Vortex>();
	}
};
static_assert(alignof(UHWGameplayEffect_Vortex) == 0x000008, "Wrong alignment on UHWGameplayEffect_Vortex");
static_assert(sizeof(UHWGameplayEffect_Vortex) == 0x000AC8, "Wrong size on UHWGameplayEffect_Vortex");

// Class Hemingway.HWQuest_DamageByType
// 0x0088 (0x0118 - 0x0090)
class UHWQuest_DamageByType final : public UHWActiveQuest
{
public:
	struct FGameplayTagContainer                  TargetTypes;                                       // 0x0090(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AbilityIdTags;                                     // 0x00B0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AttackTags;                                        // 0x00D0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  EffectTags;                                        // 0x00F0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x1];                                      // 0x0110(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ApplyOneProgressPerInstance;                       // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTrackOnlyOnKill;                                  // 0x0112(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_113[0x5];                                      // 0x0113(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDealtDamage(const struct FDamageEventData& DamageEventData);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_DamageByType">();
	}
	static class UHWQuest_DamageByType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_DamageByType>();
	}
};
static_assert(alignof(UHWQuest_DamageByType) == 0x000008, "Wrong alignment on UHWQuest_DamageByType");
static_assert(sizeof(UHWQuest_DamageByType) == 0x000118, "Wrong size on UHWQuest_DamageByType");
static_assert(offsetof(UHWQuest_DamageByType, TargetTypes) == 0x000090, "Member 'UHWQuest_DamageByType::TargetTypes' has a wrong offset!");
static_assert(offsetof(UHWQuest_DamageByType, AbilityIdTags) == 0x0000B0, "Member 'UHWQuest_DamageByType::AbilityIdTags' has a wrong offset!");
static_assert(offsetof(UHWQuest_DamageByType, AttackTags) == 0x0000D0, "Member 'UHWQuest_DamageByType::AttackTags' has a wrong offset!");
static_assert(offsetof(UHWQuest_DamageByType, EffectTags) == 0x0000F0, "Member 'UHWQuest_DamageByType::EffectTags' has a wrong offset!");
static_assert(offsetof(UHWQuest_DamageByType, ApplyOneProgressPerInstance) == 0x000111, "Member 'UHWQuest_DamageByType::ApplyOneProgressPerInstance' has a wrong offset!");
static_assert(offsetof(UHWQuest_DamageByType, bTrackOnlyOnKill) == 0x000112, "Member 'UHWQuest_DamageByType::bTrackOnlyOnKill' has a wrong offset!");

// Class Hemingway.HWQuest_DistanceTravelled
// 0x0040 (0x00D0 - 0x0090)
class UHWQuest_DistanceTravelled final : public UHWActiveQuest
{
public:
	TWeakObjectPtr<class AHWCharacter_Base>       MovingCharacter;                                   // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           AwardTimer;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceTravelledSinceLastAward;                   // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AwardFrequency;                                    // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExcludeTeleports;                                 // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTrackDistanceWithTags;                            // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AcceptedTags;                                      // 0x00B0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void AwardAccumulatedQuestProgress();
	void OnMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_DistanceTravelled">();
	}
	static class UHWQuest_DistanceTravelled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_DistanceTravelled>();
	}
};
static_assert(alignof(UHWQuest_DistanceTravelled) == 0x000008, "Wrong alignment on UHWQuest_DistanceTravelled");
static_assert(sizeof(UHWQuest_DistanceTravelled) == 0x0000D0, "Wrong size on UHWQuest_DistanceTravelled");
static_assert(offsetof(UHWQuest_DistanceTravelled, MovingCharacter) == 0x000090, "Member 'UHWQuest_DistanceTravelled::MovingCharacter' has a wrong offset!");
static_assert(offsetof(UHWQuest_DistanceTravelled, AwardTimer) == 0x000098, "Member 'UHWQuest_DistanceTravelled::AwardTimer' has a wrong offset!");
static_assert(offsetof(UHWQuest_DistanceTravelled, DistanceTravelledSinceLastAward) == 0x0000A0, "Member 'UHWQuest_DistanceTravelled::DistanceTravelledSinceLastAward' has a wrong offset!");
static_assert(offsetof(UHWQuest_DistanceTravelled, AwardFrequency) == 0x0000A4, "Member 'UHWQuest_DistanceTravelled::AwardFrequency' has a wrong offset!");
static_assert(offsetof(UHWQuest_DistanceTravelled, bExcludeTeleports) == 0x0000A8, "Member 'UHWQuest_DistanceTravelled::bExcludeTeleports' has a wrong offset!");
static_assert(offsetof(UHWQuest_DistanceTravelled, bTrackDistanceWithTags) == 0x0000A9, "Member 'UHWQuest_DistanceTravelled::bTrackDistanceWithTags' has a wrong offset!");
static_assert(offsetof(UHWQuest_DistanceTravelled, AcceptedTags) == 0x0000B0, "Member 'UHWQuest_DistanceTravelled::AcceptedTags' has a wrong offset!");

// Class Hemingway.HWQuest_HealingByType
// 0x0040 (0x00D0 - 0x0090)
class UHWQuest_HealingByType final : public UHWActiveQuest
{
public:
	struct FGameplayTagContainer                  TargetTypes;                                       // 0x0090(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  EffectTags;                                        // 0x00B0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void OnHealingDone(const struct FHealEventData& HealEventData);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_HealingByType">();
	}
	static class UHWQuest_HealingByType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_HealingByType>();
	}
};
static_assert(alignof(UHWQuest_HealingByType) == 0x000008, "Wrong alignment on UHWQuest_HealingByType");
static_assert(sizeof(UHWQuest_HealingByType) == 0x0000D0, "Wrong size on UHWQuest_HealingByType");
static_assert(offsetof(UHWQuest_HealingByType, TargetTypes) == 0x000090, "Member 'UHWQuest_HealingByType::TargetTypes' has a wrong offset!");
static_assert(offsetof(UHWQuest_HealingByType, EffectTags) == 0x0000B0, "Member 'UHWQuest_HealingByType::EffectTags' has a wrong offset!");

// Class Hemingway.HWLibrary_AbilitySystem
// 0x0000 (0x0028 - 0x0028)
class UHWLibrary_AbilitySystem final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateLocalGameplayCue(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	static void AddHitToMultiHitTargetData(struct FHitResult& Hit, struct FGameplayAbilityTargetDataHandle& TargetDataHandleToModify, int32 TargetDataIndexToModify);
	static void AddMultiHitResultsToTargetData(struct FGameplayAbilityTargetDataHandle& TargetDataHandleToModify, const struct FGameplayAbilityTargetDataHandle& TargetDataHandleToAdd, int32 TargetDataIndexToModify, int32 TargetDataIndexToAdd);
	static void AddSingleHitTargetDataToMultiHitTargetData(struct FGameplayAbilityTargetDataHandle& TargetDataHandleToModify, const struct FGameplayAbilityTargetDataHandle& TargetDataHandleToAdd, int32 TargetDataIndexToModify, int32 TargetDataIndexToAdd);
	static class UHWAbilitySystemComponent* BP_GetHWAbilitySystem(const class AActor* Actor, bool* bSuccess);
	static void BP_MulticastSendGameplayEventToActor(class AActor* EventReciever, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	static void BP_OwningClientSendGameplayEventToActor(class AActor* EventReciever, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	static void BP_ServerSendGameplayEventToActor(class AActor* EventReciever, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	static void CalculateCooldownMultiplier(const class UHWGameplayAbility* InstigatingAbility, const float& CooldownRate, float* OutCooldownMultiplier);
	static void CalculateCooldownMultiplierForOffhands(const float& CooldownRate, float* OutCooldownMultiplier);
	static float CalculateFinalCooldownDuration(const float& BaseCooldownDuration, const float& CooldownMultiplier, const float& CooldownFlatDelta);
	static bool CanEffectApplyAttributeModifiers(class UAbilitySystemComponent* TargetASC, TSubclassOf<class UGameplayEffect> Effect, const float Level, const struct FGameplayEffectContextHandle& EffectContext);
	static void CheckAbilityForId(const class UClass* BaseAbilityClass);
	static void CloneEffectsToASC(const struct FGameplayTagContainer& EffectTypesToClone, const class UAbilitySystemComponent* FromASC, class UAbilitySystemComponent* ToASC);
	static struct FGameplayAbilityTargetDataHandle CreateAimTargetDataFromLocation(const struct FVector& AimLocation, class AActor* SourceActor, class UGameplayAbility* AbilityInstance);
	static struct FGameplayAbilityTargetDataHandle CreateAimTargetDataFromLocationInfo(const struct FHWTargetData_LocationInfo& LocationInfo, class AActor* SourceActor, class UGameplayAbility* AbilityInstance);
	static struct FGameplayAbilityTargetDataHandle CreateAimTargetDataFromSpline(const class USplineComponent* SplinePath);
	static struct FGameplayAbilityTargetDataHandle CreateAimTargetDataFromStartAndEndLocation(const struct FTransform& AimOrigin, const struct FVector& AimEndLocation, class AActor* SourceActor, class UGameplayAbility* AbilityInstance, const bool bRotateOrignToEnd, const bool bOffsetAimByLastValidHeight);
	static struct FGameplayAbilityTargetDataHandle CreateAimTargetDataFromTransform(const struct FTransform& AimLocation, class AActor* SourceActor, class UGameplayAbility* AbilityInstance);
	static struct FGameplayAbilityTargetDataHandle CreateSingleHitTargetDataFromActor(class AActor* Target, const struct FVector& TargetDataHitNormal);
	static void DeactivateLocalGameplayCue(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	static bool DoesTargetDataHaveValidTarget(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, const int32 Index_0);
	static void ExecuteLocalGameplayCue(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	static struct FGameplayEffectContextHandle GetEffectContextFromActiveEffect(const struct FActiveGameplayEffectHandle& ActiveEffectHandle);
	static struct FHWAbilityFiringInstanceId GetFiringInstanceIdFromEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static TSubclassOf<class UGameplayEffect> GetGameplayEffectClassFromEffectSpec(const struct FGameplayEffectSpecHandle& EffectSpecHandle);
	static class AActor* GetHitActorFromEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static struct FGameplayTagContainer GetInstigatingAbilityCDOAbilityTagsFromEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static const class UGameplayAbility* GetInstigatingAbilityCDOFromEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static const class UGameplayAbility* GetInstigatingAbilityInstanceFromEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static class UHWAbilitySystemComponent* GetInstigatorAbilitySystemComponentFromEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static const class UHWAbilityLevelConfig* GetLevelConfigForAbility(class UHWAbilitySystemComponent* AbilitySystem, const struct FGameplayAbilitySpecHandle& AbilityHandle, const int32 Level);
	static int32 GetLevelFromActiveEffect(const struct FActiveGameplayEffectHandle& ActiveEffectHandle);
	static float GetLevelFromEffectSpecRef(const struct FGameplayEffectSpec& EffectSpec);
	static TArray<struct FHitResult> GetMultiHitResultsFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);
	static class UHWAbilitySystemComponent* GetOriginalInstigatorAbilitySystemComponentFromEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static class UAbilitySystemComponent* GetOwningAbilitySystemFromActiveEffect(struct FActiveGameplayEffectHandle& ActiveEffectHandle);
	static class UGameplayAbility* GetPrimaryAbilityInstance(class UHWAbilitySystemComponent* AbilitySystem, const struct FGameplayAbilitySpecHandle& AbilityHandle);
	static class UGameplayAbility* GetPrimaryAbilityInstanceBasedOnEquipmentItem(class UHWAbilitySystemComponent* AbilitySystem, class UHWEquipmentItem* EquipmentItem);
	static class UGameplayAbility* GetPrimaryAbilityInstanceBasedOnInventorySlot(class UHWAbilitySystemComponent* AbilitySystem, const struct FHWInventorySlot& InventorySlot);
	static struct FVector GetTargetVectorFromEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static void GrantAbilitySetToASC(const class UHWAbilitySet* AbilitySetToGrant, class UHWAbilitySystemComponent* ASC, struct FHWAbilitySet_GrantedHandles* OutGrantedHandles);
	static bool IsActiveEffectValid(const struct FActiveGameplayEffectHandle& ActiveEffectHandle);
	static bool IsShouldIgnoreCooldownsCheatActive();
	static bool IsShouldIgnoreCostsCheatActive();
	static bool IsTaskActive(const class UGameplayTask* Task);
	static void ModifyActiveEffectStackCount(const struct FActiveGameplayEffectHandle& ActiveEffectHandle, int32 NewStackCount);
	static void ModifyGoldAttribute(class UAbilitySystemComponent* AbilitySystem, EGameplayModOp ModifierType, const float Amount, const struct FGameplayTag& GoldModReason);
	static void RemoveActiveGameplayEffectFromEffectOwner(const struct FActiveGameplayEffectHandle& ActiveEffectHandle);
	static void RemoveHitResultFromMultiHitTargetDataAt(int32 RemoveAtIndex, struct FGameplayAbilityTargetDataHandle& InTargetData, int32 TargetDataIndexToModify);
	static void RemoveMultiHitResultsFromTargetDataByTag(const class AHWCharacter_Base* InstigatingCharacter, const struct FGameplayTagContainer& GameplayTags, struct FGameplayAbilityTargetDataHandle& InTargetData, int32 TargetDataIndexToModify, bool bEnemyTargets, bool bFriendlyTargets, bool bSelfTarget, bool bCheckAllTags);
	static void SetEffectCauserOnEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle, class AActor* NewEffectCauser);
	static void SetTargetVectorOnEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FVector& TargetVector);
	static void UpdateTargetDataLocationInfo(struct FGameplayAbilityTargetDataHandle& TargetDataHandleToModify, int32 TargetDataIndexToModify, const struct FGameplayAbilityTargetingLocationInfo& SourceLoc, const struct FGameplayAbilityTargetingLocationInfo& TargetLoc, const bool bIsValid);
	static bool WasActiveEffectSuccessfullyApplied(const struct FActiveGameplayEffectHandle& ActiveEffectHandle);

	struct FGameplayTagContainer GetEffectTagsFromEffectSpec(const struct FGameplayEffectSpecHandle& EffectSpecHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLibrary_AbilitySystem">();
	}
	static class UHWLibrary_AbilitySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLibrary_AbilitySystem>();
	}
};
static_assert(alignof(UHWLibrary_AbilitySystem) == 0x000008, "Wrong alignment on UHWLibrary_AbilitySystem");
static_assert(sizeof(UHWLibrary_AbilitySystem) == 0x000028, "Wrong size on UHWLibrary_AbilitySystem");

// Class Hemingway.HWAladdinArenaManager
// 0x0080 (0x0318 - 0x0298)
class AHWAladdinArenaManager : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AHWCharacter_Base>       AladdinSkinOwner;                                  // 0x02A0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AHWCharacter_Base>> RegisteredAladdins;                              // 0x02A8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x50];                                     // 0x02B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnAladdinSkinOwnerUpdatedDelegate;                 // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnAladdinNewApparelApplicationFinished();
	void OnDeployableDestroyed(class AHWDeployable* DeployableDestroyed);
	void OnDeployableSpawned(class AHWDeployable* DeployableSpawned);
	void OnFamiliarDestroyed(const struct FHWActiveFamiliarInfo& FamiliarDestroyed);
	void OnFamiliarSpawned(const struct FHWActiveFamiliarInfo& FamiliarSpawned);
	void OnRep_AladdinSkinOwner(TWeakObjectPtr<class AHWCharacter_Base> PreviousSkinOwner);
	void RegisterAladdinSkinOwner(class AHWCharacter_Base* Aladdin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAladdinArenaManager">();
	}
	static class AHWAladdinArenaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWAladdinArenaManager>();
	}
};
static_assert(alignof(AHWAladdinArenaManager) == 0x000008, "Wrong alignment on AHWAladdinArenaManager");
static_assert(sizeof(AHWAladdinArenaManager) == 0x000318, "Wrong size on AHWAladdinArenaManager");
static_assert(offsetof(AHWAladdinArenaManager, AladdinSkinOwner) == 0x0002A0, "Member 'AHWAladdinArenaManager::AladdinSkinOwner' has a wrong offset!");
static_assert(offsetof(AHWAladdinArenaManager, RegisteredAladdins) == 0x0002A8, "Member 'AHWAladdinArenaManager::RegisteredAladdins' has a wrong offset!");
static_assert(offsetof(AHWAladdinArenaManager, OnAladdinSkinOwnerUpdatedDelegate) == 0x000308, "Member 'AHWAladdinArenaManager::OnAladdinSkinOwnerUpdatedDelegate' has a wrong offset!");

// Class Hemingway.HWQuest_TagApplicationByType
// 0x00A8 (0x0138 - 0x0090)
class UHWQuest_TagApplicationByType : public UHWActiveQuest
{
public:
	bool                                          bInSingleCast;                                     // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnSingleTarget;                                   // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequiredInSingleCast;                              // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TargetTypes;                                       // 0x0098(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AcceptedTags;                                      // 0x00B8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentEffectCount;                                // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AHWCharacter_Base>, int32> CharacterToEffectCountMap;                  // 0x00E0(0x0050)(NativeAccessSpecifierPrivate)
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0130(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnGameplayEffectApplied(const struct FGameplayEffectSpec& ActiveEffect);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_TagApplicationByType">();
	}
	static class UHWQuest_TagApplicationByType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_TagApplicationByType>();
	}
};
static_assert(alignof(UHWQuest_TagApplicationByType) == 0x000008, "Wrong alignment on UHWQuest_TagApplicationByType");
static_assert(sizeof(UHWQuest_TagApplicationByType) == 0x000138, "Wrong size on UHWQuest_TagApplicationByType");
static_assert(offsetof(UHWQuest_TagApplicationByType, bInSingleCast) == 0x000090, "Member 'UHWQuest_TagApplicationByType::bInSingleCast' has a wrong offset!");
static_assert(offsetof(UHWQuest_TagApplicationByType, bOnSingleTarget) == 0x000091, "Member 'UHWQuest_TagApplicationByType::bOnSingleTarget' has a wrong offset!");
static_assert(offsetof(UHWQuest_TagApplicationByType, RequiredInSingleCast) == 0x000094, "Member 'UHWQuest_TagApplicationByType::RequiredInSingleCast' has a wrong offset!");
static_assert(offsetof(UHWQuest_TagApplicationByType, TargetTypes) == 0x000098, "Member 'UHWQuest_TagApplicationByType::TargetTypes' has a wrong offset!");
static_assert(offsetof(UHWQuest_TagApplicationByType, AcceptedTags) == 0x0000B8, "Member 'UHWQuest_TagApplicationByType::AcceptedTags' has a wrong offset!");
static_assert(offsetof(UHWQuest_TagApplicationByType, CurrentEffectCount) == 0x0000D8, "Member 'UHWQuest_TagApplicationByType::CurrentEffectCount' has a wrong offset!");
static_assert(offsetof(UHWQuest_TagApplicationByType, CharacterToEffectCountMap) == 0x0000E0, "Member 'UHWQuest_TagApplicationByType::CharacterToEffectCountMap' has a wrong offset!");
static_assert(offsetof(UHWQuest_TagApplicationByType, FiringInstanceId) == 0x000130, "Member 'UHWQuest_TagApplicationByType::FiringInstanceId' has a wrong offset!");

// Class Hemingway.HWQuest_TimeWithTagApplied
// 0x0028 (0x00B8 - 0x0090)
class UHWQuest_TimeWithTagApplied final : public UHWActiveQuest
{
public:
	struct FGameplayTagContainer                  AcceptedTags;                                      // 0x0090(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         ApplicationStartTime;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentlyHasTagsApplied;                          // 0x00B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagAddedOrRemoved(const struct FGameplayTag& Tag, int32 TagCount, class UHWAbilitySystemComponent* AbilitySystem);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_TimeWithTagApplied">();
	}
	static class UHWQuest_TimeWithTagApplied* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_TimeWithTagApplied>();
	}
};
static_assert(alignof(UHWQuest_TimeWithTagApplied) == 0x000008, "Wrong alignment on UHWQuest_TimeWithTagApplied");
static_assert(sizeof(UHWQuest_TimeWithTagApplied) == 0x0000B8, "Wrong size on UHWQuest_TimeWithTagApplied");
static_assert(offsetof(UHWQuest_TimeWithTagApplied, AcceptedTags) == 0x000090, "Member 'UHWQuest_TimeWithTagApplied::AcceptedTags' has a wrong offset!");
static_assert(offsetof(UHWQuest_TimeWithTagApplied, ApplicationStartTime) == 0x0000B0, "Member 'UHWQuest_TimeWithTagApplied::ApplicationStartTime' has a wrong offset!");
static_assert(offsetof(UHWQuest_TimeWithTagApplied, bCurrentlyHasTagsApplied) == 0x0000B4, "Member 'UHWQuest_TimeWithTagApplied::bCurrentlyHasTagsApplied' has a wrong offset!");

// Class Hemingway.HWQuest_TimeWithTagAppliedToTargets
// 0x0038 (0x00C8 - 0x0090)
class UHWQuest_TimeWithTagAppliedToTargets : public UHWActiveQuest
{
public:
	struct FGameplayTagContainer                  AcceptedTags;                                      // 0x0090(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bCheckAllAppliedTags;                              // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWTargetWithTagsApplied>       TargetsWithTagsApplied;                            // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnGameplayEffectApplied(const struct FGameplayEffectSpec& ActiveEffect);
	void OnGameplayEffectAppliedCallback(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle);
	void OnTargetTagAddedOrRemoved(const struct FGameplayTag& Tag, int32 TagCount, class UHWAbilitySystemComponent* AbilitySystem);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_TimeWithTagAppliedToTargets">();
	}
	static class UHWQuest_TimeWithTagAppliedToTargets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_TimeWithTagAppliedToTargets>();
	}
};
static_assert(alignof(UHWQuest_TimeWithTagAppliedToTargets) == 0x000008, "Wrong alignment on UHWQuest_TimeWithTagAppliedToTargets");
static_assert(sizeof(UHWQuest_TimeWithTagAppliedToTargets) == 0x0000C8, "Wrong size on UHWQuest_TimeWithTagAppliedToTargets");
static_assert(offsetof(UHWQuest_TimeWithTagAppliedToTargets, AcceptedTags) == 0x000090, "Member 'UHWQuest_TimeWithTagAppliedToTargets::AcceptedTags' has a wrong offset!");
static_assert(offsetof(UHWQuest_TimeWithTagAppliedToTargets, bCheckAllAppliedTags) == 0x0000B0, "Member 'UHWQuest_TimeWithTagAppliedToTargets::bCheckAllAppliedTags' has a wrong offset!");
static_assert(offsetof(UHWQuest_TimeWithTagAppliedToTargets, TargetsWithTagsApplied) == 0x0000B8, "Member 'UHWQuest_TimeWithTagAppliedToTargets::TargetsWithTagsApplied' has a wrong offset!");

// Class Hemingway.HWQuest_Worshiper
// 0x0008 (0x0298 - 0x0290)
class UHWQuest_Worshiper final : public UHWQuest
{
public:
	int32                                         WORSHIPER_XP_TABLE;                                // 0x0290(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_Worshiper">();
	}
	static class UHWQuest_Worshiper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_Worshiper>();
	}
};
static_assert(alignof(UHWQuest_Worshiper) == 0x000008, "Wrong alignment on UHWQuest_Worshiper");
static_assert(sizeof(UHWQuest_Worshiper) == 0x000298, "Wrong size on UHWQuest_Worshiper");
static_assert(offsetof(UHWQuest_Worshiper, WORSHIPER_XP_TABLE) == 0x000290, "Member 'UHWQuest_Worshiper::WORSHIPER_XP_TABLE' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Anhur_A02_Push
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Anhur_A02_Push final : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Anhur_A02_Push">();
	}
	static class UHWGameplayEffect_Anhur_A02_Push* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Anhur_A02_Push>();
	}
};
static_assert(alignof(UHWGameplayEffect_Anhur_A02_Push) == 0x000008, "Wrong alignment on UHWGameplayEffect_Anhur_A02_Push");
static_assert(sizeof(UHWGameplayEffect_Anhur_A02_Push) == 0x000AC8, "Wrong size on UHWGameplayEffect_Anhur_A02_Push");

// Class Hemingway.HWRankedConfig
// 0x0328 (0x0358 - 0x0030)
class UHWRankedConfig final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UDataTable>              QueueRankTypesTable;                               // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    DefaultMuForRanks;                                 // 0x0058(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, float>                    DefaultSigmaForRanks;                              // 0x00A8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, float>                    DefaultBetaForRanks;                               // 0x00F8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         ProfilesWithSkillRating;                           // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRH_LootId                             SkillRatingLootId;                                 // 0x0158(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             SkillRatingItemId;                                 // 0x016C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultSkillRating;                                // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillRatingMmrRatio;                               // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetPullUpBonus;                                 // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetPullBackWinrateNeededPerStdDev;              // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseGainMax;                                       // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseGainMin;                                       // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WinProbabilityMin;                                 // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WinProbabilityMax;                                 // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWSkillRatingRankings>  SkillRatingRankingsAsset;                          // 0x01A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SoloEliteQueueThreshold;                           // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SoloEliteQueueKVKey;                               // 0x01D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SoloEliteQueueLossThreshold;                       // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SoloEliteQueueLossKVKey;                           // 0x01E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             EliteQueueLootId;                                  // 0x01F8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             EliteQueueItemId;                                  // 0x020C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumPartyPenalty;                               // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumIndividualPenalty;                          // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWSkillRatingDisparityRange>   SkillRatingDisparityPenalty;                       // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHWSkillRatingDisparityRange>   HighSkillRatingDisparityPenalty;                   // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FHWPartyPenaltyRanges>     PartySizePenalties;                                // 0x0248(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FHWIndividualPenaltyRanges> IndividualSRPenalties;                    // 0x0298(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         HighSkillRatingDisparityThreshold;                 // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillRatingDisparityBufferValue;                   // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, float>                            PartySizeModifier;                                 // 0x02F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 LeaderboardId;                                     // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDisplayedSize;                                  // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequestPageSize;                                   // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWRankedConfig">();
	}
	static class UHWRankedConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWRankedConfig>();
	}
};
static_assert(alignof(UHWRankedConfig) == 0x000008, "Wrong alignment on UHWRankedConfig");
static_assert(sizeof(UHWRankedConfig) == 0x000358, "Wrong size on UHWRankedConfig");
static_assert(offsetof(UHWRankedConfig, QueueRankTypesTable) == 0x000030, "Member 'UHWRankedConfig::QueueRankTypesTable' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, DefaultMuForRanks) == 0x000058, "Member 'UHWRankedConfig::DefaultMuForRanks' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, DefaultSigmaForRanks) == 0x0000A8, "Member 'UHWRankedConfig::DefaultSigmaForRanks' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, DefaultBetaForRanks) == 0x0000F8, "Member 'UHWRankedConfig::DefaultBetaForRanks' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, ProfilesWithSkillRating) == 0x000148, "Member 'UHWRankedConfig::ProfilesWithSkillRating' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, SkillRatingLootId) == 0x000158, "Member 'UHWRankedConfig::SkillRatingLootId' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, SkillRatingItemId) == 0x00016C, "Member 'UHWRankedConfig::SkillRatingItemId' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, DefaultSkillRating) == 0x000180, "Member 'UHWRankedConfig::DefaultSkillRating' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, SkillRatingMmrRatio) == 0x000184, "Member 'UHWRankedConfig::SkillRatingMmrRatio' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, TargetPullUpBonus) == 0x000188, "Member 'UHWRankedConfig::TargetPullUpBonus' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, TargetPullBackWinrateNeededPerStdDev) == 0x00018C, "Member 'UHWRankedConfig::TargetPullBackWinrateNeededPerStdDev' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, BaseGainMax) == 0x000190, "Member 'UHWRankedConfig::BaseGainMax' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, BaseGainMin) == 0x000194, "Member 'UHWRankedConfig::BaseGainMin' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, WinProbabilityMin) == 0x000198, "Member 'UHWRankedConfig::WinProbabilityMin' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, WinProbabilityMax) == 0x00019C, "Member 'UHWRankedConfig::WinProbabilityMax' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, SkillRatingRankingsAsset) == 0x0001A0, "Member 'UHWRankedConfig::SkillRatingRankingsAsset' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, SoloEliteQueueThreshold) == 0x0001C8, "Member 'UHWRankedConfig::SoloEliteQueueThreshold' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, SoloEliteQueueKVKey) == 0x0001D0, "Member 'UHWRankedConfig::SoloEliteQueueKVKey' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, SoloEliteQueueLossThreshold) == 0x0001E0, "Member 'UHWRankedConfig::SoloEliteQueueLossThreshold' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, SoloEliteQueueLossKVKey) == 0x0001E8, "Member 'UHWRankedConfig::SoloEliteQueueLossKVKey' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, EliteQueueLootId) == 0x0001F8, "Member 'UHWRankedConfig::EliteQueueLootId' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, EliteQueueItemId) == 0x00020C, "Member 'UHWRankedConfig::EliteQueueItemId' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, MaximumPartyPenalty) == 0x000220, "Member 'UHWRankedConfig::MaximumPartyPenalty' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, MaximumIndividualPenalty) == 0x000224, "Member 'UHWRankedConfig::MaximumIndividualPenalty' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, SkillRatingDisparityPenalty) == 0x000228, "Member 'UHWRankedConfig::SkillRatingDisparityPenalty' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, HighSkillRatingDisparityPenalty) == 0x000238, "Member 'UHWRankedConfig::HighSkillRatingDisparityPenalty' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, PartySizePenalties) == 0x000248, "Member 'UHWRankedConfig::PartySizePenalties' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, IndividualSRPenalties) == 0x000298, "Member 'UHWRankedConfig::IndividualSRPenalties' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, HighSkillRatingDisparityThreshold) == 0x0002E8, "Member 'UHWRankedConfig::HighSkillRatingDisparityThreshold' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, SkillRatingDisparityBufferValue) == 0x0002EC, "Member 'UHWRankedConfig::SkillRatingDisparityBufferValue' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, PartySizeModifier) == 0x0002F0, "Member 'UHWRankedConfig::PartySizeModifier' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, LeaderboardId) == 0x000340, "Member 'UHWRankedConfig::LeaderboardId' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, MaxDisplayedSize) == 0x000350, "Member 'UHWRankedConfig::MaxDisplayedSize' has a wrong offset!");
static_assert(offsetof(UHWRankedConfig, RequestPageSize) == 0x000354, "Member 'UHWRankedConfig::RequestPageSize' has a wrong offset!");

// Class Hemingway.HWAbilitySet
// 0x0040 (0x0070 - 0x0030)
class UHWAbilitySet final : public UPrimaryDataAsset
{
public:
	TArray<struct FHWEquipmentSpec>               EquipmentToGrant;                                  // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWAbilitySet_GameplayAbility>  AbilitiesToGrant;                                  // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWAbilitySet_GameplayEffect>   EffectsToGrant;                                    // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWAbilitySet_AttributeSet>     AttributesToGrant;                                 // 0x0060(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilitySet">();
	}
	static class UHWAbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilitySet>();
	}
};
static_assert(alignof(UHWAbilitySet) == 0x000008, "Wrong alignment on UHWAbilitySet");
static_assert(sizeof(UHWAbilitySet) == 0x000070, "Wrong size on UHWAbilitySet");
static_assert(offsetof(UHWAbilitySet, EquipmentToGrant) == 0x000030, "Member 'UHWAbilitySet::EquipmentToGrant' has a wrong offset!");
static_assert(offsetof(UHWAbilitySet, AbilitiesToGrant) == 0x000040, "Member 'UHWAbilitySet::AbilitiesToGrant' has a wrong offset!");
static_assert(offsetof(UHWAbilitySet, EffectsToGrant) == 0x000050, "Member 'UHWAbilitySet::EffectsToGrant' has a wrong offset!");
static_assert(offsetof(UHWAbilitySet, AttributesToGrant) == 0x000060, "Member 'UHWAbilitySet::AttributesToGrant' has a wrong offset!");

// Class Hemingway.HWRankedSubsystem
// 0x0258 (0x0288 - 0x0030)
class UHWRankedSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnRankDataLoaded;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRankConfigLoaded;                                // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	class UHWRankedConfig*                        CachedRankConfig;                                  // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWSkillRatingRankings*                 CachedSkillRatingRankings;                         // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWQueueRankTypes                      TrueSkillRankTypes;                                // 0x0068(0x0068)(Protected, NativeAccessSpecifierProtected)
	class FString                                 MatchMakingProfileId;                              // 0x00D0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTrueSkillCalculated;                              // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0xFF];                                      // 0x00E1(0x00FF)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    CalculatedPartyPenalties;                          // 0x01E0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FHWTeamPartySizes>         TeamPartyCounts;                                   // 0x0230(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bSkillRatingCalculated;                            // 0x0280(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetEliteSoloQueueLossThreshold();
	int32 GetEliteSoloQueueThreshold();
	TSoftObjectPtr<class UHWRankedConfig> GetRankedConfigByGamemode(TSubclassOf<class AHWGameMode> GameModeClass);
	void GrantEliteQueueItem(class URH_PlayerInfo* Player, const int32& SkillRating);
	void OnRankedConfigLoaded();
	void OnSkillRatingRankingsLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWRankedSubsystem">();
	}
	static class UHWRankedSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWRankedSubsystem>();
	}
};
static_assert(alignof(UHWRankedSubsystem) == 0x000008, "Wrong alignment on UHWRankedSubsystem");
static_assert(sizeof(UHWRankedSubsystem) == 0x000288, "Wrong size on UHWRankedSubsystem");
static_assert(offsetof(UHWRankedSubsystem, OnRankDataLoaded) == 0x000030, "Member 'UHWRankedSubsystem::OnRankDataLoaded' has a wrong offset!");
static_assert(offsetof(UHWRankedSubsystem, OnRankConfigLoaded) == 0x000040, "Member 'UHWRankedSubsystem::OnRankConfigLoaded' has a wrong offset!");
static_assert(offsetof(UHWRankedSubsystem, CachedRankConfig) == 0x000050, "Member 'UHWRankedSubsystem::CachedRankConfig' has a wrong offset!");
static_assert(offsetof(UHWRankedSubsystem, CachedSkillRatingRankings) == 0x000058, "Member 'UHWRankedSubsystem::CachedSkillRatingRankings' has a wrong offset!");
static_assert(offsetof(UHWRankedSubsystem, TrueSkillRankTypes) == 0x000068, "Member 'UHWRankedSubsystem::TrueSkillRankTypes' has a wrong offset!");
static_assert(offsetof(UHWRankedSubsystem, MatchMakingProfileId) == 0x0000D0, "Member 'UHWRankedSubsystem::MatchMakingProfileId' has a wrong offset!");
static_assert(offsetof(UHWRankedSubsystem, bTrueSkillCalculated) == 0x0000E0, "Member 'UHWRankedSubsystem::bTrueSkillCalculated' has a wrong offset!");
static_assert(offsetof(UHWRankedSubsystem, CalculatedPartyPenalties) == 0x0001E0, "Member 'UHWRankedSubsystem::CalculatedPartyPenalties' has a wrong offset!");
static_assert(offsetof(UHWRankedSubsystem, TeamPartyCounts) == 0x000230, "Member 'UHWRankedSubsystem::TeamPartyCounts' has a wrong offset!");
static_assert(offsetof(UHWRankedSubsystem, bSkillRatingCalculated) == 0x000280, "Member 'UHWRankedSubsystem::bSkillRatingCalculated' has a wrong offset!");

// Class Hemingway.HWReticle
// 0x0150 (0x0418 - 0x02C8)
class AHWReticle : public AGameplayAbilityWorldReticle
{
public:
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWGameplayAbility*                     OwningAbility;                                     // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTargeter*                            OwningTargeter;                                    // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWDisplayInfoComponent*                DisplayInfoComponent;                              // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AttackID;                                          // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityAimSettings*                  AimSettings;                                       // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(bool bIsTargetLockedOn)> OnTargetLockedOn;                         // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         ReticleVisiblePhaseFlags;                          // 0x0308(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldShowDuringTargetingConfirmationLockout;     // 0x0309(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReticleOrientationBehavior                   OrientationBehavior;                               // 0x030A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30B[0x5];                                      // 0x030B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWProjectileDestroyPredictionInfo     ProjectileDestroyInfo;                             // 0x0310(0x00F0)(BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EReticlePlacementBehavior                     PlacementBehavior;                                 // 0x0400(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlaceReticleOnGround;                             // 0x0401(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUsingGroundTargetingType;                       // 0x0402(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_403[0x1];                                      // 0x0403(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AHWPlayerState>          CurrentRadialPlayerSelectorTarget;                 // 0x0404(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           RadialPlayerSelectorDisplayInfoTag;                // 0x040C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnCalcReticlePlacementPosition(const struct FVector& PlacementLoc, const struct FVector& Origin, const struct FVector& EndPoint);
	void BP_OnRenderBehaviorDetermined(EReticleRenderBehavior RenderBehavior);
	void BP_OnReticleUpdate();
	void HandlePrefireTransition(bool bIsEnteringPrefire);
	void OnTargetingConfirmed();
	void OnTargetingEnded();
	void OnTargetingStarted();
	void UpdateReticleRendering(EReticleRenderBehavior RenderBehavior, class UNiagaraComponent* NiagaraComponent);
	void UpdateReticleRotation();

	struct FVector CalcCustomPlacementPosition(const class AHWTargeter* Targeter, bool* OutFoundValidPlacement) const;
	class UHWApparelComponent* GetApparelComponent() const;
	const class UHWSkinItem* GetCurrentSkin() const;
	class AActor* GetRadialPlayerSelectorTarget() const;
	bool IsSkinningReady() const;
	bool ShouldShowReticle() const;
	bool ShouldShowReticleInPhase(const EAbilityFlowPhase AbilityPhase) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWReticle">();
	}
	static class AHWReticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWReticle>();
	}
};
static_assert(alignof(AHWReticle) == 0x000008, "Wrong alignment on AHWReticle");
static_assert(sizeof(AHWReticle) == 0x000418, "Wrong size on AHWReticle");
static_assert(offsetof(AHWReticle, OwningAbility) == 0x0002D0, "Member 'AHWReticle::OwningAbility' has a wrong offset!");
static_assert(offsetof(AHWReticle, OwningTargeter) == 0x0002D8, "Member 'AHWReticle::OwningTargeter' has a wrong offset!");
static_assert(offsetof(AHWReticle, DisplayInfoComponent) == 0x0002E0, "Member 'AHWReticle::DisplayInfoComponent' has a wrong offset!");
static_assert(offsetof(AHWReticle, AttackID) == 0x0002E8, "Member 'AHWReticle::AttackID' has a wrong offset!");
static_assert(offsetof(AHWReticle, AimSettings) == 0x0002F0, "Member 'AHWReticle::AimSettings' has a wrong offset!");
static_assert(offsetof(AHWReticle, OnTargetLockedOn) == 0x0002F8, "Member 'AHWReticle::OnTargetLockedOn' has a wrong offset!");
static_assert(offsetof(AHWReticle, ReticleVisiblePhaseFlags) == 0x000308, "Member 'AHWReticle::ReticleVisiblePhaseFlags' has a wrong offset!");
static_assert(offsetof(AHWReticle, bShouldShowDuringTargetingConfirmationLockout) == 0x000309, "Member 'AHWReticle::bShouldShowDuringTargetingConfirmationLockout' has a wrong offset!");
static_assert(offsetof(AHWReticle, OrientationBehavior) == 0x00030A, "Member 'AHWReticle::OrientationBehavior' has a wrong offset!");
static_assert(offsetof(AHWReticle, ProjectileDestroyInfo) == 0x000310, "Member 'AHWReticle::ProjectileDestroyInfo' has a wrong offset!");
static_assert(offsetof(AHWReticle, PlacementBehavior) == 0x000400, "Member 'AHWReticle::PlacementBehavior' has a wrong offset!");
static_assert(offsetof(AHWReticle, bPlaceReticleOnGround) == 0x000401, "Member 'AHWReticle::bPlaceReticleOnGround' has a wrong offset!");
static_assert(offsetof(AHWReticle, bIsUsingGroundTargetingType) == 0x000402, "Member 'AHWReticle::bIsUsingGroundTargetingType' has a wrong offset!");
static_assert(offsetof(AHWReticle, CurrentRadialPlayerSelectorTarget) == 0x000404, "Member 'AHWReticle::CurrentRadialPlayerSelectorTarget' has a wrong offset!");
static_assert(offsetof(AHWReticle, RadialPlayerSelectorDisplayInfoTag) == 0x00040C, "Member 'AHWReticle::RadialPlayerSelectorDisplayInfoTag' has a wrong offset!");

// Class Hemingway.HWReticle_LockOn
// 0x0018 (0x0430 - 0x0418)
class AHWReticle_LockOn : public AHWReticle
{
public:
	class UHWWidgetComponent*                     WidgetComponent;                                   // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreeAimOffset;                                     // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterHeightOffsetPercent;                      // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterTargetZOffset;                            // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWReticle_LockOn">();
	}
	static class AHWReticle_LockOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWReticle_LockOn>();
	}
};
static_assert(alignof(AHWReticle_LockOn) == 0x000008, "Wrong alignment on AHWReticle_LockOn");
static_assert(sizeof(AHWReticle_LockOn) == 0x000430, "Wrong size on AHWReticle_LockOn");
static_assert(offsetof(AHWReticle_LockOn, WidgetComponent) == 0x000418, "Member 'AHWReticle_LockOn::WidgetComponent' has a wrong offset!");
static_assert(offsetof(AHWReticle_LockOn, FreeAimOffset) == 0x000420, "Member 'AHWReticle_LockOn::FreeAimOffset' has a wrong offset!");
static_assert(offsetof(AHWReticle_LockOn, CharacterHeightOffsetPercent) == 0x000424, "Member 'AHWReticle_LockOn::CharacterHeightOffsetPercent' has a wrong offset!");
static_assert(offsetof(AHWReticle_LockOn, CharacterTargetZOffset) == 0x000428, "Member 'AHWReticle_LockOn::CharacterTargetZOffset' has a wrong offset!");

// Class Hemingway.HWAbilityTask_Attack_Deployable
// 0x0008 (0x0188 - 0x0180)
class UHWAbilityTask_Attack_Deployable : public UHWAbilityTask_FireAttack
{
public:
	class UHWAbilityAttackSettings_Deployable*    DeployableAttackSettings;                          // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDeployableBeginSpawning(class AHWDeployable* SpawnedDeployable);
	void OnDeployableSpawned(class AHWDeployable* SpawnedDeployable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Attack_Deployable">();
	}
	static class UHWAbilityTask_Attack_Deployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Attack_Deployable>();
	}
};
static_assert(alignof(UHWAbilityTask_Attack_Deployable) == 0x000008, "Wrong alignment on UHWAbilityTask_Attack_Deployable");
static_assert(sizeof(UHWAbilityTask_Attack_Deployable) == 0x000188, "Wrong size on UHWAbilityTask_Attack_Deployable");
static_assert(offsetof(UHWAbilityTask_Attack_Deployable, DeployableAttackSettings) == 0x000180, "Member 'UHWAbilityTask_Attack_Deployable::DeployableAttackSettings' has a wrong offset!");

// Class Hemingway.HWAbilityAimSetting_Ricochet
// 0x0018 (0x00A0 - 0x0088)
class UHWAbilityAimSetting_Ricochet : public UHWAbilityAimSettings_Linear
{
public:
	TSubclassOf<class AHWDeployable>              RicochetDeployableClass;                           // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRicochetCount;                                  // 0x0090(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionRadius;                                   // 0x0094(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Bounciness;                                        // 0x0098(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitTo2DRicochet;                                // 0x009C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSetting_Ricochet">();
	}
	static class UHWAbilityAimSetting_Ricochet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSetting_Ricochet>();
	}
};
static_assert(alignof(UHWAbilityAimSetting_Ricochet) == 0x000008, "Wrong alignment on UHWAbilityAimSetting_Ricochet");
static_assert(sizeof(UHWAbilityAimSetting_Ricochet) == 0x0000A0, "Wrong size on UHWAbilityAimSetting_Ricochet");
static_assert(offsetof(UHWAbilityAimSetting_Ricochet, RicochetDeployableClass) == 0x000088, "Member 'UHWAbilityAimSetting_Ricochet::RicochetDeployableClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSetting_Ricochet, MaxRicochetCount) == 0x000090, "Member 'UHWAbilityAimSetting_Ricochet::MaxRicochetCount' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSetting_Ricochet, CollisionRadius) == 0x000094, "Member 'UHWAbilityAimSetting_Ricochet::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSetting_Ricochet, Bounciness) == 0x000098, "Member 'UHWAbilityAimSetting_Ricochet::Bounciness' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSetting_Ricochet, bLimitTo2DRicochet) == 0x00009C, "Member 'UHWAbilityAimSetting_Ricochet::bLimitTo2DRicochet' has a wrong offset!");

// Class Hemingway.HWAimSetting_Bari_Ricochet
// 0x0008 (0x00A8 - 0x00A0)
class UHWAimSetting_Bari_Ricochet final : public UHWAbilityAimSetting_Ricochet
{
public:
	int32                                         BellIndex;                                         // 0x00A0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAimSetting_Bari_Ricochet">();
	}
	static class UHWAimSetting_Bari_Ricochet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAimSetting_Bari_Ricochet>();
	}
};
static_assert(alignof(UHWAimSetting_Bari_Ricochet) == 0x000008, "Wrong alignment on UHWAimSetting_Bari_Ricochet");
static_assert(sizeof(UHWAimSetting_Bari_Ricochet) == 0x0000A8, "Wrong size on UHWAimSetting_Bari_Ricochet");
static_assert(offsetof(UHWAimSetting_Bari_Ricochet, BellIndex) == 0x0000A0, "Member 'UHWAimSetting_Bari_Ricochet::BellIndex' has a wrong offset!");

// Class Hemingway.HWReticle_Mulan_A03_WallIndicator
// 0x0110 (0x0528 - 0x0418)
class AHWReticle_Mulan_A03_WallIndicator final : public AHWReticle
{
public:
	TSubclassOf<class AHWProjectile>              ProjectileClass;                                   // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWAbility_Mulan_A03_GrappleListener> GrappleListenerClass;                    // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ProjectileWorldCollisionExtents;                   // 0x0428(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             WallIndicatorHitInfo;                              // 0x0440(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	struct FHitResult CalcPredictedWorldHit() const;
	bool IsEvolved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWReticle_Mulan_A03_WallIndicator">();
	}
	static class AHWReticle_Mulan_A03_WallIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWReticle_Mulan_A03_WallIndicator>();
	}
};
static_assert(alignof(AHWReticle_Mulan_A03_WallIndicator) == 0x000008, "Wrong alignment on AHWReticle_Mulan_A03_WallIndicator");
static_assert(sizeof(AHWReticle_Mulan_A03_WallIndicator) == 0x000528, "Wrong size on AHWReticle_Mulan_A03_WallIndicator");
static_assert(offsetof(AHWReticle_Mulan_A03_WallIndicator, ProjectileClass) == 0x000418, "Member 'AHWReticle_Mulan_A03_WallIndicator::ProjectileClass' has a wrong offset!");
static_assert(offsetof(AHWReticle_Mulan_A03_WallIndicator, GrappleListenerClass) == 0x000420, "Member 'AHWReticle_Mulan_A03_WallIndicator::GrappleListenerClass' has a wrong offset!");
static_assert(offsetof(AHWReticle_Mulan_A03_WallIndicator, ProjectileWorldCollisionExtents) == 0x000428, "Member 'AHWReticle_Mulan_A03_WallIndicator::ProjectileWorldCollisionExtents' has a wrong offset!");
static_assert(offsetof(AHWReticle_Mulan_A03_WallIndicator, WallIndicatorHitInfo) == 0x000440, "Member 'AHWReticle_Mulan_A03_WallIndicator::WallIndicatorHitInfo' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Stun
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Stun : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Stun">();
	}
	static class UHWGameplayEffect_Stun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Stun>();
	}
};
static_assert(alignof(UHWGameplayEffect_Stun) == 0x000008, "Wrong alignment on UHWGameplayEffect_Stun");
static_assert(sizeof(UHWGameplayEffect_Stun) == 0x000AC8, "Wrong size on UHWGameplayEffect_Stun");

// Class Hemingway.HWReticle_Ricochet
// 0x0068 (0x0480 - 0x0418)
class AHWReticle_Ricochet final : public AHWReticle
{
public:
	class UNiagaraSystem*                         ReticleSystem;                                     // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAssetRequestKey                       ReticleFXSkinningKey;                              // 0x0420(0x001C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DistanceScaleKey;                                  // 0x043C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReticleMaxDistance;                                // 0x0444(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ArrowIndicatorKey;                                 // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FinalRicochetIndicatorKey;                         // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStaticMeshComponent>       GrassCullMesh;                                     // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UNiagaraComponent*>              ReticleFxs;                                        // 0x0460(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           GrassCullingMeshes;                                // 0x0470(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void UpdateRicochetReticle(class UNiagaraComponent* ReticleFx, const struct FGameplayAbilityTargetDataHandle& AimDataHandle, int32 RicochetIndex, const bool bIsFinalRicochet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWReticle_Ricochet">();
	}
	static class AHWReticle_Ricochet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWReticle_Ricochet>();
	}
};
static_assert(alignof(AHWReticle_Ricochet) == 0x000008, "Wrong alignment on AHWReticle_Ricochet");
static_assert(sizeof(AHWReticle_Ricochet) == 0x000480, "Wrong size on AHWReticle_Ricochet");
static_assert(offsetof(AHWReticle_Ricochet, ReticleSystem) == 0x000418, "Member 'AHWReticle_Ricochet::ReticleSystem' has a wrong offset!");
static_assert(offsetof(AHWReticle_Ricochet, ReticleFXSkinningKey) == 0x000420, "Member 'AHWReticle_Ricochet::ReticleFXSkinningKey' has a wrong offset!");
static_assert(offsetof(AHWReticle_Ricochet, DistanceScaleKey) == 0x00043C, "Member 'AHWReticle_Ricochet::DistanceScaleKey' has a wrong offset!");
static_assert(offsetof(AHWReticle_Ricochet, ReticleMaxDistance) == 0x000444, "Member 'AHWReticle_Ricochet::ReticleMaxDistance' has a wrong offset!");
static_assert(offsetof(AHWReticle_Ricochet, ArrowIndicatorKey) == 0x000448, "Member 'AHWReticle_Ricochet::ArrowIndicatorKey' has a wrong offset!");
static_assert(offsetof(AHWReticle_Ricochet, FinalRicochetIndicatorKey) == 0x000450, "Member 'AHWReticle_Ricochet::FinalRicochetIndicatorKey' has a wrong offset!");
static_assert(offsetof(AHWReticle_Ricochet, GrassCullMesh) == 0x000458, "Member 'AHWReticle_Ricochet::GrassCullMesh' has a wrong offset!");
static_assert(offsetof(AHWReticle_Ricochet, ReticleFxs) == 0x000460, "Member 'AHWReticle_Ricochet::ReticleFxs' has a wrong offset!");
static_assert(offsetof(AHWReticle_Ricochet, GrassCullingMeshes) == 0x000470, "Member 'AHWReticle_Ricochet::GrassCullingMeshes' has a wrong offset!");

// Class Hemingway.HWReticle_VGS
// 0x0000 (0x0418 - 0x0418)
class AHWReticle_VGS final : public AHWReticle
{
public:
	void UpdateReticleDisplay(const struct FGameplayTag& DisplayTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWReticle_VGS">();
	}
	static class AHWReticle_VGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWReticle_VGS>();
	}
};
static_assert(alignof(AHWReticle_VGS) == 0x000008, "Wrong alignment on AHWReticle_VGS");
static_assert(sizeof(AHWReticle_VGS) == 0x000418, "Wrong size on AHWReticle_VGS");

// Class Hemingway.HWRoleConfig
// 0x0128 (0x0158 - 0x0030)
class UHWRoleConfig final : public UPrimaryDataAsset
{
public:
	TArray<ECharacterRole>                        ActiveRoles;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, struct FRH_ItemId>        RolePriorityItemId;                                // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FRH_LootId>        RolePriorityLootId;                                // 0x0090(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            PriorityPointsDelta;                               // 0x00E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         FillPriorityPointsDelta;                           // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbandonedMatchPriorityPointsDelta;                 // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TopSRPriorityPointsBooster;                        // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              PriorityPointsRange;                               // 0x013C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ResetPriorityOnAssignedRanks;                      // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWRoleConfig">();
	}
	static class UHWRoleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWRoleConfig>();
	}
};
static_assert(alignof(UHWRoleConfig) == 0x000008, "Wrong alignment on UHWRoleConfig");
static_assert(sizeof(UHWRoleConfig) == 0x000158, "Wrong size on UHWRoleConfig");
static_assert(offsetof(UHWRoleConfig, ActiveRoles) == 0x000030, "Member 'UHWRoleConfig::ActiveRoles' has a wrong offset!");
static_assert(offsetof(UHWRoleConfig, RolePriorityItemId) == 0x000040, "Member 'UHWRoleConfig::RolePriorityItemId' has a wrong offset!");
static_assert(offsetof(UHWRoleConfig, RolePriorityLootId) == 0x000090, "Member 'UHWRoleConfig::RolePriorityLootId' has a wrong offset!");
static_assert(offsetof(UHWRoleConfig, PriorityPointsDelta) == 0x0000E0, "Member 'UHWRoleConfig::PriorityPointsDelta' has a wrong offset!");
static_assert(offsetof(UHWRoleConfig, FillPriorityPointsDelta) == 0x000130, "Member 'UHWRoleConfig::FillPriorityPointsDelta' has a wrong offset!");
static_assert(offsetof(UHWRoleConfig, AbandonedMatchPriorityPointsDelta) == 0x000134, "Member 'UHWRoleConfig::AbandonedMatchPriorityPointsDelta' has a wrong offset!");
static_assert(offsetof(UHWRoleConfig, TopSRPriorityPointsBooster) == 0x000138, "Member 'UHWRoleConfig::TopSRPriorityPointsBooster' has a wrong offset!");
static_assert(offsetof(UHWRoleConfig, PriorityPointsRange) == 0x00013C, "Member 'UHWRoleConfig::PriorityPointsRange' has a wrong offset!");
static_assert(offsetof(UHWRoleConfig, ResetPriorityOnAssignedRanks) == 0x000148, "Member 'UHWRoleConfig::ResetPriorityOnAssignedRanks' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_AllowPassThrough
// 0x0020 (0x0AD8 - 0x0AB8)
class UHWGameplayEffect_AllowPassThrough : public UHWGameplayEffect
{
public:
	struct FGameplayTagContainer                  PassThroughCharacterTags;                          // 0x0AB8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	struct FGameplayTagContainer GetPassThroughCharacterTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_AllowPassThrough">();
	}
	static class UHWGameplayEffect_AllowPassThrough* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_AllowPassThrough>();
	}
};
static_assert(alignof(UHWGameplayEffect_AllowPassThrough) == 0x000008, "Wrong alignment on UHWGameplayEffect_AllowPassThrough");
static_assert(sizeof(UHWGameplayEffect_AllowPassThrough) == 0x000AD8, "Wrong size on UHWGameplayEffect_AllowPassThrough");
static_assert(offsetof(UHWGameplayEffect_AllowPassThrough, PassThroughCharacterTags) == 0x000AB8, "Member 'UHWGameplayEffect_AllowPassThrough::PassThroughCharacterTags' has a wrong offset!");

// Class Hemingway.HWRoleSubsystem
// 0x0188 (0x01B8 - 0x0030)
class UHWRoleSubsystem final : public UGameInstanceSubsystem
{
public:
	class UHWRoleConfig*                          RoleConfig;                                        // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWRoleAssignmentTeam>          CachedTeamsToAssign;                               // 0x0048(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnPlayerRolePreferencesSavedDel;                   // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHWPersistentPlayerId>          InFlightPlayerRequests;                            // 0x0068(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FHWPersistentPlayerId, struct FHWRolePreferenceData> CachedPlayerPreferences;        // 0x0078(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FHWPersistentPlayerId, int32>     CachedPlayerRolePriorities;                        // 0x00C8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FHWPersistentPlayerId, ECharacterRole> CachedAssignedPlayerRoles;                    // 0x0118(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FHWPersistentPlayerId, ECharacterRole> CachedPlayedPlayerRoles;                      // 0x0168(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	bool DoesPlayerHaveRolePreferences(class URH_PlayerInfo* PlayerInfo);
	void FetchLocalPlayerRolePreferences(class URH_PlayerInfo* Player, const TMulticastInlineDelegate<void(const struct FHWRolePreferenceData& RolePreferences, bool bSuccess)>& RolesFetchedDelegate);
	struct FHWRolePreferenceData GetAllCachedRolePreferences(const struct FHWPersistentPlayerId& PlayerId);
	int32 GetCachedRolePreference(const struct FHWPersistentPlayerId& PlayerId, ECharacterRole RoleTag);
	int32 GetCachedRolePriority(class URH_PlayerInfo* PlayerInfo);
	void OnLocalPlayerSettingsLoaded(bool bSuccess, const struct FRH_PlayerSettingsDataWrapper& Response, class URH_PlayerInfo* Player);
	void OnPlayerRolePreferencesSaved(bool bSuccess, const struct FRH_PlayerSettingsDataWrapper& Response, const struct FRH_ErrorInfo& ErrorInfo);
	void OnPlayerSettingsLoaded(bool bSuccess, const struct FRH_PlayerSettingsDataWrapper& Response, class URH_PlayerInfo* PlayerInfo);
	void OnRankConfigLoaded();
	void UpdateCachedPlayedRole(const struct FHWPersistentPlayerId& PlayerId, ECharacterRole RoleTag);
	void UpdateRolePreferences(class URH_PlayerInfo* Player, const struct FHWRolePreferenceData& NewRolePreferences);

	TMap<struct FHWPersistentPlayerId, ECharacterRole> GetAllCachedPlayedRoles() const;
	class UHWRoleConfig* GetRoleConfig() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWRoleSubsystem">();
	}
	static class UHWRoleSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWRoleSubsystem>();
	}
};
static_assert(alignof(UHWRoleSubsystem) == 0x000008, "Wrong alignment on UHWRoleSubsystem");
static_assert(sizeof(UHWRoleSubsystem) == 0x0001B8, "Wrong size on UHWRoleSubsystem");
static_assert(offsetof(UHWRoleSubsystem, RoleConfig) == 0x000030, "Member 'UHWRoleSubsystem::RoleConfig' has a wrong offset!");
static_assert(offsetof(UHWRoleSubsystem, CachedTeamsToAssign) == 0x000048, "Member 'UHWRoleSubsystem::CachedTeamsToAssign' has a wrong offset!");
static_assert(offsetof(UHWRoleSubsystem, OnPlayerRolePreferencesSavedDel) == 0x000058, "Member 'UHWRoleSubsystem::OnPlayerRolePreferencesSavedDel' has a wrong offset!");
static_assert(offsetof(UHWRoleSubsystem, InFlightPlayerRequests) == 0x000068, "Member 'UHWRoleSubsystem::InFlightPlayerRequests' has a wrong offset!");
static_assert(offsetof(UHWRoleSubsystem, CachedPlayerPreferences) == 0x000078, "Member 'UHWRoleSubsystem::CachedPlayerPreferences' has a wrong offset!");
static_assert(offsetof(UHWRoleSubsystem, CachedPlayerRolePriorities) == 0x0000C8, "Member 'UHWRoleSubsystem::CachedPlayerRolePriorities' has a wrong offset!");
static_assert(offsetof(UHWRoleSubsystem, CachedAssignedPlayerRoles) == 0x000118, "Member 'UHWRoleSubsystem::CachedAssignedPlayerRoles' has a wrong offset!");
static_assert(offsetof(UHWRoleSubsystem, CachedPlayedPlayerRoles) == 0x000168, "Member 'UHWRoleSubsystem::CachedPlayedPlayerRoles' has a wrong offset!");

// Class Hemingway.HWReticle_Dash
// 0x0018 (0x0430 - 0x0418)
class AHWReticle_Dash final : public AHWReticle
{
public:
	uint8                                         Pad_418[0x18];                                     // 0x0418(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnCalcDashReticlePlacementPosition(const struct FVector& PlacementLoc, const struct FVector& MaxDashEndLoc, const struct FVector& ActualEndDashLoc, const struct FVector& HitActorLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWReticle_Dash">();
	}
	static class AHWReticle_Dash* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWReticle_Dash>();
	}
};
static_assert(alignof(AHWReticle_Dash) == 0x000008, "Wrong alignment on AHWReticle_Dash");
static_assert(sizeof(AHWReticle_Dash) == 0x000430, "Wrong size on AHWReticle_Dash");

// Class Hemingway.HWSettingsVersionManager
// 0x0020 (0x0050 - 0x0030)
class UHWSettingsVersionManager final : public UDataAsset
{
public:
	TArray<struct FPlayerSettingsVersionData>     PlayerSettingsVersionHistory;                      // 0x0030(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FKeybindsVersionData>           KeybindsVersionHistory;                            // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	int32 GetCurrentKeybindsSettingsVersion() const;
	int32 GetCurrentPlayerSettingsVersion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSettingsVersionManager">();
	}
	static class UHWSettingsVersionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSettingsVersionManager>();
	}
};
static_assert(alignof(UHWSettingsVersionManager) == 0x000008, "Wrong alignment on UHWSettingsVersionManager");
static_assert(sizeof(UHWSettingsVersionManager) == 0x000050, "Wrong size on UHWSettingsVersionManager");
static_assert(offsetof(UHWSettingsVersionManager, PlayerSettingsVersionHistory) == 0x000030, "Member 'UHWSettingsVersionManager::PlayerSettingsVersionHistory' has a wrong offset!");
static_assert(offsetof(UHWSettingsVersionManager, KeybindsVersionHistory) == 0x000040, "Member 'UHWSettingsVersionManager::KeybindsVersionHistory' has a wrong offset!");

// Class Hemingway.HWShippingConsole
// 0x0000 (0x0130 - 0x0130)
class UHWShippingConsole final : public URHShippingConsole
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWShippingConsole">();
	}
	static class UHWShippingConsole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWShippingConsole>();
	}
};
static_assert(alignof(UHWShippingConsole) == 0x000008, "Wrong alignment on UHWShippingConsole");
static_assert(sizeof(UHWShippingConsole) == 0x000130, "Wrong size on UHWShippingConsole");

// Class Hemingway.HWSimpleTeamActor
// 0x0010 (0x02A8 - 0x0298)
class AHWSimpleTeamActor : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericTeamId                         TeamId;                                            // 0x02A0(0x0001)(Edit, Net, DisableEditOnInstance, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TeamID(const struct FGenericTeamId& OldTeamId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSimpleTeamActor">();
	}
	static class AHWSimpleTeamActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWSimpleTeamActor>();
	}
};
static_assert(alignof(AHWSimpleTeamActor) == 0x000008, "Wrong alignment on AHWSimpleTeamActor");
static_assert(sizeof(AHWSimpleTeamActor) == 0x0002A8, "Wrong size on AHWSimpleTeamActor");
static_assert(offsetof(AHWSimpleTeamActor, TeamId) == 0x0002A0, "Member 'AHWSimpleTeamActor::TeamId' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Cripple
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Cripple : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Cripple">();
	}
	static class UHWGameplayEffect_Cripple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Cripple>();
	}
};
static_assert(alignof(UHWGameplayEffect_Cripple) == 0x000008, "Wrong alignment on UHWGameplayEffect_Cripple");
static_assert(sizeof(UHWGameplayEffect_Cripple) == 0x000AC8, "Wrong size on UHWGameplayEffect_Cripple");

// Class Hemingway.HWSkeletalMeshActor
// 0x0018 (0x0330 - 0x0318)
class AHWSkeletalMeshActor : public ASkeletalMeshActor
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeAfterDeath;                                    // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDead;                                           // 0x0324(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DeathTimer;                                        // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActivateDeathVisuals();
	void OnRep_IsDead();
	void SetSkinnedData();
	void StartDestroy(bool bSkipTimeAfterDeath);

	class UHWApparelComponent* GetApparelComponent() const;
	const class UHWSkinItem* GetCurrentSkin() const;
	bool IsSkinningReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkeletalMeshActor">();
	}
	static class AHWSkeletalMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWSkeletalMeshActor>();
	}
};
static_assert(alignof(AHWSkeletalMeshActor) == 0x000008, "Wrong alignment on AHWSkeletalMeshActor");
static_assert(sizeof(AHWSkeletalMeshActor) == 0x000330, "Wrong size on AHWSkeletalMeshActor");
static_assert(offsetof(AHWSkeletalMeshActor, TimeAfterDeath) == 0x000320, "Member 'AHWSkeletalMeshActor::TimeAfterDeath' has a wrong offset!");
static_assert(offsetof(AHWSkeletalMeshActor, bIsDead) == 0x000324, "Member 'AHWSkeletalMeshActor::bIsDead' has a wrong offset!");
static_assert(offsetof(AHWSkeletalMeshActor, DeathTimer) == 0x000328, "Member 'AHWSkeletalMeshActor::DeathTimer' has a wrong offset!");

// Class Hemingway.HWGEMMC_CharacterMovement_WithoutDR
// 0x0000 (0x0040 - 0x0040)
class UHWGEMMC_CharacterMovement_WithoutDR final : public UHWGEModiferMagnitudeCalc_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEMMC_CharacterMovement_WithoutDR">();
	}
	static class UHWGEMMC_CharacterMovement_WithoutDR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEMMC_CharacterMovement_WithoutDR>();
	}
};
static_assert(alignof(UHWGEMMC_CharacterMovement_WithoutDR) == 0x000008, "Wrong alignment on UHWGEMMC_CharacterMovement_WithoutDR");
static_assert(sizeof(UHWGEMMC_CharacterMovement_WithoutDR) == 0x000040, "Wrong size on UHWGEMMC_CharacterMovement_WithoutDR");

// Class Hemingway.HWSkeletalMeshActor_Aladdin_A04
// 0x0008 (0x0338 - 0x0330)
class AHWSkeletalMeshActor_Aladdin_A04 final : public AHWSkeletalMeshActor
{
public:
	class AHWAladdinArenaManager*                 AladdinArena;                                      // 0x0330(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkeletalMeshActor_Aladdin_A04">();
	}
	static class AHWSkeletalMeshActor_Aladdin_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWSkeletalMeshActor_Aladdin_A04>();
	}
};
static_assert(alignof(AHWSkeletalMeshActor_Aladdin_A04) == 0x000008, "Wrong alignment on AHWSkeletalMeshActor_Aladdin_A04");
static_assert(sizeof(AHWSkeletalMeshActor_Aladdin_A04) == 0x000338, "Wrong size on AHWSkeletalMeshActor_Aladdin_A04");
static_assert(offsetof(AHWSkeletalMeshActor_Aladdin_A04, AladdinArena) == 0x000330, "Member 'AHWSkeletalMeshActor_Aladdin_A04::AladdinArena' has a wrong offset!");

// Class Hemingway.HWSkillRatingRankings
// 0x0010 (0x0040 - 0x0030)
class UHWSkillRatingRankings final : public UPrimaryDataAsset
{
public:
	TArray<struct FHWSkillRatingRank>             SkillRatingRankings;                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkillRatingRankings">();
	}
	static class UHWSkillRatingRankings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSkillRatingRankings>();
	}
};
static_assert(alignof(UHWSkillRatingRankings) == 0x000008, "Wrong alignment on UHWSkillRatingRankings");
static_assert(sizeof(UHWSkillRatingRankings) == 0x000040, "Wrong size on UHWSkillRatingRankings");
static_assert(offsetof(UHWSkillRatingRankings, SkillRatingRankings) == 0x000030, "Member 'UHWSkillRatingRankings::SkillRatingRankings' has a wrong offset!");

// Class Hemingway.HWSkinManagerSubsystem
// 0x0018 (0x0048 - 0x0030)
class UHWSkinManagerSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bConfirmedStoringSkins;                            // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinManagerSubsystem">();
	}
	static class UHWSkinManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSkinManagerSubsystem>();
	}
};
static_assert(alignof(UHWSkinManagerSubsystem) == 0x000008, "Wrong alignment on UHWSkinManagerSubsystem");
static_assert(sizeof(UHWSkinManagerSubsystem) == 0x000048, "Wrong size on UHWSkinManagerSubsystem");
static_assert(offsetof(UHWSkinManagerSubsystem, bConfirmedStoringSkins) == 0x000040, "Member 'UHWSkinManagerSubsystem::bConfirmedStoringSkins' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_DiminishingReturns
// 0x0010 (0x0AC8 - 0x0AB8)
class UHWGameplayEffect_DiminishingReturns final : public UHWGameplayEffect
{
public:
	uint8                                         Pad_AB8[0x10];                                     // 0x0AB8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_DiminishingReturns">();
	}
	static class UHWGameplayEffect_DiminishingReturns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_DiminishingReturns>();
	}
};
static_assert(alignof(UHWGameplayEffect_DiminishingReturns) == 0x000008, "Wrong alignment on UHWGameplayEffect_DiminishingReturns");
static_assert(sizeof(UHWGameplayEffect_DiminishingReturns) == 0x000AC8, "Wrong size on UHWGameplayEffect_DiminishingReturns");

// Class Hemingway.HWSkinNameBranch
// 0x0000 (0x0028 - 0x0028)
class UHWSkinNameBranch final : public UBlueprintFunctionLibrary
{
public:
	static int32 BranchOnSkinName(const class FString& InputString, bool* bIsValid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinNameBranch">();
	}
	static class UHWSkinNameBranch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSkinNameBranch>();
	}
};
static_assert(alignof(UHWSkinNameBranch) == 0x000008, "Wrong alignment on UHWSkinNameBranch");
static_assert(sizeof(UHWSkinNameBranch) == 0x000028, "Wrong size on UHWSkinNameBranch");

// Class Hemingway.HWAbilityTask_Attack_Projectile
// 0x0010 (0x0190 - 0x0180)
class UHWAbilityTask_Attack_Projectile final : public UHWAbilityTask_FireAttack
{
public:
	class UHWAbilityAttackSettings_Projectile*    ProjectileAttackSettings;                          // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 HomingTarget;                                      // 0x0188(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UHWAbilityTask_Attack_Projectile* FireHomingProjectileAttackById(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FGameplayTag& ID, class AActor* HomingTarget_0, const struct FGameplayAbilityTargetDataHandle& AimData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Attack_Projectile">();
	}
	static class UHWAbilityTask_Attack_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Attack_Projectile>();
	}
};
static_assert(alignof(UHWAbilityTask_Attack_Projectile) == 0x000008, "Wrong alignment on UHWAbilityTask_Attack_Projectile");
static_assert(sizeof(UHWAbilityTask_Attack_Projectile) == 0x000190, "Wrong size on UHWAbilityTask_Attack_Projectile");
static_assert(offsetof(UHWAbilityTask_Attack_Projectile, ProjectileAttackSettings) == 0x000180, "Member 'UHWAbilityTask_Attack_Projectile::ProjectileAttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_Projectile, HomingTarget) == 0x000188, "Member 'UHWAbilityTask_Attack_Projectile::HomingTarget' has a wrong offset!");

// Class Hemingway.HWSkinSelectAuthority
// 0x0030 (0x0BD0 - 0x0BA0)
class AHWSkinSelectAuthority final : public ADraftAuthority
{
public:
	struct FDraftPlayerIdHandle                   OwningPlayerId;                                    // 0x0BA0(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHWCharacterItem*                       CharacterItem;                                     // 0x0BB0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SkinSelectTime;                                    // 0x0BB8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHWDraftType                                  CharacterDraftType;                                // 0x0BBC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BBD[0x13];                                     // 0x0BBD(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinSelectAuthority">();
	}
	static class AHWSkinSelectAuthority* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWSkinSelectAuthority>();
	}
};
static_assert(alignof(AHWSkinSelectAuthority) == 0x000008, "Wrong alignment on AHWSkinSelectAuthority");
static_assert(sizeof(AHWSkinSelectAuthority) == 0x000BD0, "Wrong size on AHWSkinSelectAuthority");
static_assert(offsetof(AHWSkinSelectAuthority, OwningPlayerId) == 0x000BA0, "Member 'AHWSkinSelectAuthority::OwningPlayerId' has a wrong offset!");
static_assert(offsetof(AHWSkinSelectAuthority, CharacterItem) == 0x000BB0, "Member 'AHWSkinSelectAuthority::CharacterItem' has a wrong offset!");
static_assert(offsetof(AHWSkinSelectAuthority, SkinSelectTime) == 0x000BB8, "Member 'AHWSkinSelectAuthority::SkinSelectTime' has a wrong offset!");
static_assert(offsetof(AHWSkinSelectAuthority, CharacterDraftType) == 0x000BBC, "Member 'AHWSkinSelectAuthority::CharacterDraftType' has a wrong offset!");

// Class Hemingway.HWSkinSelectReplicatedActor
// 0x0038 (0x0A80 - 0x0A48)
class AHWSkinSelectReplicatedActor final : public ADraftReplicatedActor
{
public:
	class UHWCharacterItem*                       CharacterItem;                                     // 0x0A48(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A50[0x30];                                     // 0x0A50(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnPendingPurchaseReceived();
	void OnPlayerInventoryUpdated(const TArray<int32>& UpdatedInventoryIds, class URH_PlayerInfo* PlayerInfo);
	void OnRep_CharacterItem();
	void ServerRequestFullInventoryUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinSelectReplicatedActor">();
	}
	static class AHWSkinSelectReplicatedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWSkinSelectReplicatedActor>();
	}
};
static_assert(alignof(AHWSkinSelectReplicatedActor) == 0x000008, "Wrong alignment on AHWSkinSelectReplicatedActor");
static_assert(sizeof(AHWSkinSelectReplicatedActor) == 0x000A80, "Wrong size on AHWSkinSelectReplicatedActor");
static_assert(offsetof(AHWSkinSelectReplicatedActor, CharacterItem) == 0x000A48, "Member 'AHWSkinSelectReplicatedActor::CharacterItem' has a wrong offset!");

// Class Hemingway.HWSkinSelectRules
// 0x0008 (0x00A0 - 0x0098)
class UHWSkinSelectRules final : public UDraftRules
{
public:
	float                                         TimeToPick;                                        // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWDraftType                                  CharacterDraftType;                                // 0x009C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinSelectRules">();
	}
	static class UHWSkinSelectRules* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSkinSelectRules>();
	}
};
static_assert(alignof(UHWSkinSelectRules) == 0x000008, "Wrong alignment on UHWSkinSelectRules");
static_assert(sizeof(UHWSkinSelectRules) == 0x0000A0, "Wrong size on UHWSkinSelectRules");
static_assert(offsetof(UHWSkinSelectRules, TimeToPick) == 0x000098, "Member 'UHWSkinSelectRules::TimeToPick' has a wrong offset!");
static_assert(offsetof(UHWSkinSelectRules, CharacterDraftType) == 0x00009C, "Member 'UHWSkinSelectRules::CharacterDraftType' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_GrantVision
// 0x0008 (0x0AC0 - 0x0AB8)
class UHWGameplayEffect_GrantVision final : public UHWGameplayEffect
{
public:
	EHWEffectGrantedVisionType                    EffectGrantedVisionType;                           // 0x0AB8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB9[0x7];                                      // 0x0AB9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_GrantVision">();
	}
	static class UHWGameplayEffect_GrantVision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_GrantVision>();
	}
};
static_assert(alignof(UHWGameplayEffect_GrantVision) == 0x000008, "Wrong alignment on UHWGameplayEffect_GrantVision");
static_assert(sizeof(UHWGameplayEffect_GrantVision) == 0x000AC0, "Wrong size on UHWGameplayEffect_GrantVision");
static_assert(offsetof(UHWGameplayEffect_GrantVision, EffectGrantedVisionType) == 0x000AB8, "Member 'UHWGameplayEffect_GrantVision::EffectGrantedVisionType' has a wrong offset!");

// Class Hemingway.HWTargeter
// 0x0270 (0x0650 - 0x03E0)
#pragma pack(push, 0x1)
class alignas(0x10) AHWTargeter : public AGameplayAbilityTargetActor
{
public:
	uint8                                         Pad_3E0[0x4];                                      // 0x03E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHWAbilityTask_WaitTargetData> CurrentTargetingTask;                        // 0x03E4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWGameplayAbility*                     OwningHWAbility;                                   // 0x03F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CurrentlyTargetingAttacks;                         // 0x03F8(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bTargetingExpiring;                                // 0x0418(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_419[0x3];                                      // 0x0419(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastTargetingTickTimeStamp;                        // 0x041C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWTargeter* Targeter, const struct FGameplayTag& AttackID, const bool bIsValid)> OnTargetDataValidationChangedDel; // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x18];                                     // 0x0430(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       CurrentTargetingDataHandle;                        // 0x0448(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSet<TWeakObjectPtr<class AActor>>            HighlightedTargetActors;                           // 0x0470(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bCleanUpTargeterOnTargetingCancelled;              // 0x04C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastTargetWasGood;                                // 0x04C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C2[0xE];                                      // 0x04C2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetData_LocationInfo LastValidGroundAimInfo;                           // 0x04D0(0x0150)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AHWReticle>>         ReticleClasses;                                    // 0x0620(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AHWReticle*>                     Reticles;                                          // 0x0630(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bShouldShowReticle;                                // 0x0640(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_641[0x7];                                      // 0x0641(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AdjustAimLocationToGround(const class UObject* WorldContextObject, const struct FVector& Origin, const EHWGroundTargetValidationType ValidationBehavior, struct FVector* OutAdjustedLocation, const class AActor* InSourceActor, const float ManualCollisionRadius);
	static void CalcBoxTargeting(const class UObject* WorldContext, struct FBoxTargetingData& BoxTargetingData, struct FGameplayAbilityTargetDataHandle* OutTargetListDataHandle);
	static void CalcBoxTargetingByObjectType(const class UObject* WorldContext, struct FBoxTargetingData& BoxTargetingData, struct FGameplayAbilityTargetDataHandle* OutTargetListDataHandle, const ECollisionChannel ObjectTypeChannel);
	static void CalcCircularWedgeTargeting(const class UObject* WorldContext, struct FCircularWedgeTargetingData& WedgeTargetingData, struct FGameplayAbilityTargetDataHandle* OutTargetListDataHandle);
	static void CalcCircularWedgeTargetingByObjectType(const class UObject* WorldContext, struct FCircularWedgeTargetingData& WedgeTargetingData, struct FGameplayAbilityTargetDataHandle* OutTargetListDataHandle, const ECollisionChannel ObjectTypeChannel);
	static void CalcLineAttackTargeting(const class UObject* WorldContext, struct FLineAttackTargetingData& LineAttackTargetingData, struct FGameplayAbilityTargetDataHandle* OutTargetListDataHandle);
	static struct FVector CalcRadialHitLocation(const struct FVector& AimOrigin, const struct FVector& TargetLocation, const struct FVector& TargetExtent);
	static void CalcSphereTargeting(const class UObject* WorldContextObject, struct FSphereTargetingData& SphereTargetingData, struct FGameplayAbilityTargetDataHandle* OutTargetListDataHandle);
	static void CalcSphereTargetingByObjectType(const class UObject* WorldContextObject, struct FSphereTargetingData& SphereTargetingData, struct FGameplayAbilityTargetDataHandle* OutTargetListDataHandle, const ECollisionChannel ObjectTypeChannel);
	static void DrawDebugCircularWedge(const class UObject* WorldContextObject, const struct FVector& vOrigin, const struct FVector& vRotation, const float fRadius, const float fAngle, const float fHeight, const struct FColor& Color, bool bPersistentLines, float Lifetime);
	static struct FGameplayAbilityTargetDataHandle GetTargetDataHandleForType(const class UHWGameplayAbility* AbilityInstance, const struct FGameplayTag& AttackID, const ETargetDataTypeSlot Type, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, bool bBreakTargetListIntoIndividualTargetDatas);
	static int32 GetTargetDataIndexForType(const class UHWGameplayAbility* AbilityInstance, const struct FGameplayTag& AttackID, const ETargetDataTypeSlot Type);
	static bool IsInWedge(const struct FVector& TargetPosition, const float TargetCollisionRadius, const struct FVector& WedgeOrigin, const struct FVector& AimDirection, const float Angle, const float Radius, const float MinimumRadius);

	struct FGameplayAbilityTargetDataHandle CalcGroundTargetAim(struct FGameplayAbilityTargetDataHandle& TargetingAimHandle, const class UHWAbilityAimSettings_GroundTarget* AimSettings, const bool bPredicting, const bool bShowDebugAim);
	struct FGameplayAbilityTargetDataHandle CalcLockOnAim(const struct FHWAimTargetingInfo& AimTargetingInfo, struct FGameplayAbilityTargetDataHandle& TargetingAimHandle, const class UHWAbilityAimSettings_LockOn* AimSettings, const bool bShowDebugAim);
	struct FGameplayAbilityTargetDataHandle CalcSelfAim(const struct FHWAimTargetingInfo& AimTargetingInfo, struct FGameplayAbilityTargetDataHandle& TargetingAimHandle, const class UHWAbilityAimSettings_Self* AimSettings);
	class AHWReticle* CreateReticle(TSubclassOf<class AHWReticle> InReticleClass, bool bAddToReticleList);
	void DisableTargetingForAttacks(const struct FGameplayTagContainer& Attacks);
	void EnableTargetingForAttacks(const struct FGameplayTagContainer& Attacks, bool bResetCurrentTargetingAttacks, bool bEnableServerTargeting);
	void SetActorTickEnabledOnServer(bool bEnable);
	void SetTargetingExpiring(bool bExpiring);
	bool WasLastAimTargetGood();

	struct FGameplayAbilityTargetDataHandle CreateTargetingDataSnapshot() const;
	const class UHWAbilityLevelConfig* GetCurrentLevelConfig() const;
	struct FGameplayTagContainer GetCurrentlyTargetingAttacks() const;
	class AHWReticle* GetReticleByClass(TSubclassOf<class AHWReticle> InReticleClass) const;
	class AHWReticle* GetReticleById(const struct FGameplayTag& AttackID) const;
	bool IsAttackCurrrentlyTargeting(const struct FGameplayTag& AttackID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWTargeter">();
	}
	static class AHWTargeter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWTargeter>();
	}
};
#pragma pack(pop)
static_assert(alignof(AHWTargeter) == 0x000010, "Wrong alignment on AHWTargeter");
static_assert(sizeof(AHWTargeter) == 0x000650, "Wrong size on AHWTargeter");
static_assert(offsetof(AHWTargeter, CurrentTargetingTask) == 0x0003E4, "Member 'AHWTargeter::CurrentTargetingTask' has a wrong offset!");
static_assert(offsetof(AHWTargeter, OwningHWAbility) == 0x0003F0, "Member 'AHWTargeter::OwningHWAbility' has a wrong offset!");
static_assert(offsetof(AHWTargeter, CurrentlyTargetingAttacks) == 0x0003F8, "Member 'AHWTargeter::CurrentlyTargetingAttacks' has a wrong offset!");
static_assert(offsetof(AHWTargeter, bTargetingExpiring) == 0x000418, "Member 'AHWTargeter::bTargetingExpiring' has a wrong offset!");
static_assert(offsetof(AHWTargeter, LastTargetingTickTimeStamp) == 0x00041C, "Member 'AHWTargeter::LastTargetingTickTimeStamp' has a wrong offset!");
static_assert(offsetof(AHWTargeter, OnTargetDataValidationChangedDel) == 0x000420, "Member 'AHWTargeter::OnTargetDataValidationChangedDel' has a wrong offset!");
static_assert(offsetof(AHWTargeter, CurrentTargetingDataHandle) == 0x000448, "Member 'AHWTargeter::CurrentTargetingDataHandle' has a wrong offset!");
static_assert(offsetof(AHWTargeter, HighlightedTargetActors) == 0x000470, "Member 'AHWTargeter::HighlightedTargetActors' has a wrong offset!");
static_assert(offsetof(AHWTargeter, bCleanUpTargeterOnTargetingCancelled) == 0x0004C0, "Member 'AHWTargeter::bCleanUpTargeterOnTargetingCancelled' has a wrong offset!");
static_assert(offsetof(AHWTargeter, bLastTargetWasGood) == 0x0004C1, "Member 'AHWTargeter::bLastTargetWasGood' has a wrong offset!");
static_assert(offsetof(AHWTargeter, LastValidGroundAimInfo) == 0x0004D0, "Member 'AHWTargeter::LastValidGroundAimInfo' has a wrong offset!");
static_assert(offsetof(AHWTargeter, ReticleClasses) == 0x000620, "Member 'AHWTargeter::ReticleClasses' has a wrong offset!");
static_assert(offsetof(AHWTargeter, Reticles) == 0x000630, "Member 'AHWTargeter::Reticles' has a wrong offset!");
static_assert(offsetof(AHWTargeter, bShouldShowReticle) == 0x000640, "Member 'AHWTargeter::bShouldShowReticle' has a wrong offset!");

// Class Hemingway.HWCharacterAbilitySystemActor
// 0x0498 (0x0730 - 0x0298)
class alignas(0x10) AHWCharacterAbilitySystemActor final : public AInfo
{
public:
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x02B0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class AHWCharacter_Base* NewCharacterOwner)> OnCharacterOwnerChanged; // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWCharacterInfo*                       CurrentCharacterInfo;                              // 0x02C8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacter_Base*                      CharacterOwner;                                    // 0x02D0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            CharacterRestartEffect;                            // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CharacterMasteryLevel;                             // 0x02E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWDynamicSubLevelHandle               DynamicSubLevelHandle;                             // 0x02E8(0x0010)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class AHWPlayerState* NewPlayerState)> OnCurrentPlayerStateChanged; // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         CurrentPlayerState;                                // 0x0308(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AController* NewController)> OnControllerOwnershipChangedDelegate; // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySystemComponent*              AbilitySystemComponent;                            // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWCritProbability*                     CritProbability;                                   // 0x0330(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            ClassCharacterLevelingEffect;                      // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            HandleLevelEffect;                                 // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, int32>                            MapLevelXp;                                        // 0x0358(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class UHWInventoryManagerComponent* NewInventoryManager)> OnInventoryManagerChanged; // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UHWInventoryManagerComponent> InventoryManager;                             // 0x03B8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  RHPlayerUuid;                                      // 0x03C0(0x0010)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWLoadoutComponent*                    LoadoutComponent;                                  // 0x03D0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, float RespawnTimerDuration)> OnCharacterDied; // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor)> OnCharacterRespawned; // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          AwaitingRespawn;                                   // 0x0408(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExpectedRespawnTimeStamp;                          // 0x040C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAllowedToRecycleCharacter;                      // 0x0410(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_411[0x73];                                     // 0x0411(0x0073)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentMultikillCount;                             // 0x0484(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastMultikillTimestamp;                            // 0x0488(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MultikillTrackDuration;                            // 0x048C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class UHWPassiveMeterComponent* NewPassiveMeter)> OnPassiveMeterComponentChanged; // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWPassiveMeterComponent*               PassiveMeterComponent;                             // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class AHWTeamState* TeamState)> OnTeamUpdated; // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AHWTeamState*                           TeamState;                                         // 0x04B8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class UHWAutoBuyComponent* NewAutoBuy)> OnAutoBuyComponentChanged; // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class UHWAutoSkillComponent* NewAutoSkillComponent)> OnAutoSkillComponentChanged; // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWAutoSkillComponent*                  AutoSkillComponent;                                // 0x04E0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAutoBuyComponent*                    AutoBuyComponent;                                  // 0x04E8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class UHWFamiliarManagerComponent* NewFamiliarManager)> OnFamiliarManagerChanged; // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWFamiliarManagerComponent*            FamiliarManager;                                   // 0x0500(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWFamiliarComponent*                   FamiliarComponent;                                 // 0x0508(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWVisibilityComponent* VisibilityComponent)> VisibilityComponentUpdated; // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWVisibilityComponent_PlayableCharacter* VisibilityComponent;                             // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSimGameplayCueEventList               ReplicatedGameplayCues;                            // 0x0528(0x0128)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSimGameplayCueEvent>           DeferredFlashEvents;                               // 0x0650(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSimGameplayCueEvent>           UnprocessedMinimalReplicationGameplayCues;         // 0x0660(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_670[0x8];                                      // 0x0670(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIgnoreCooldowns;                                  // 0x0678(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreCosts;                                      // 0x0679(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetectingBlockedFires;                            // 0x067A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67B[0x1];                                      // 0x067B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumFireFailuresToTriggerReport;                    // 0x067C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_680[0x8];                                      // 0x0680(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastSuccessfulAbilityName;                         // 0x0688(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_698[0x60];                                     // 0x0698(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             CharSpecificItemDataTable;                         // 0x06F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWDynamicItemStoreConfigRow>   CharSpecificItemStoreConfigRows;                   // 0x0710(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWDynamicItemInfo>             GrantedDynamicItems;                               // 0x0720(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void AttemptLoadCharacterItemLevel();
	void HandleGetGodMasteryLevel(const class UHWCharacterItem* Character, const class URH_PlayerInfo* InPlayerInfo, int32 Level, float LevelProgressPercent);
	bool IgnoresAbilityForTrackingFailedFire(const class UGameplayAbility* Ability);
	void OnAbilityActivated(class UGameplayAbility* Ability);
	void OnAbilityFailedActivation(const class UGameplayAbility* Ability, const struct FGameplayTagContainer& FailedTags);
	void OnDeployableSpawned(class AHWDeployable* SpawnedDeployable);
	void OnInventoryEquipmentPurchased(class UHWEquipmentInstance* EquipmentInstance, const struct FHWInventorySlot& Slot);
	void OnReceiveOwningPlayerGodLoadout(const class UHWCharacterItem* InCharacterItem, const struct FHWGodLoadout& InGodLoadout);
	void OnReceiveOwningPlayerLoadout(const struct FHWPlayerLoadout& InPlayerLoadout);
	void OnRep_AutoBuyComponent();
	void OnRep_AutoSkillComponent();
	void OnRep_AwaitingRespawn();
	void OnRep_CharacterOwner();
	void OnRep_CurrentCharacterInfo();
	void OnRep_CurrentPlayerState();
	void OnRep_ExpectedRespawnTimeStamp();
	void OnRep_FamiliarManagerComponent();
	void OnRep_GrantedDynamicItems(const TArray<struct FHWDynamicItemInfo>& OldGrantedDynamicItems);
	void OnRep_InventoryManager();
	void OnRep_RHPlayerUuid();
	void OnRep_TeamState();
	void OnRep_VisibilityComponent();
	void OnTeamMemberAdded(class AHWPlayerState* TeamMember);
	void OnTeamMemberRemoved(class AHWPlayerState* TeamMember);
	void SetLevel(const int32 Level, const bool bForceSetXp);
	void TriggerPotentialFireBugReport(const class UGameplayAbility* Ability, const struct FGameplayTagContainer& FailedTags);

	class UAbilitySystemComponent* GetAbilitySystemComponent() const;
	class UHWAutoBuyComponent* GetAutoBuyComponent() const;
	class UHWAutoSkillComponent* GetAutoSkillComponent() const;
	int32 GetCharacterMasteryLevel() const;
	class AHWCharacter_Base* GetCharacterOwner() const;
	class UHWCritProbability* GetCritProbability() const;
	const class UHWCharacterInfo* GetCurrentCharacterInfo() const;
	const class UHWCharacterItem* GetCurrentCharacterItem() const;
	class AHWPlayerState* GetCurrentPlayerState() const;
	const class UHWSkinItem* GetCurrentSkinItem() const;
	float GetExpectedRespawnTimeRemaining() const;
	float GetExpectedRespawnTimestamp() const;
	class UHWFamiliarComponent* GetFamiliarComponent() const;
	class UHWFamiliarManagerComponent* GetFamiliarManager() const;
	class UHWAbilitySystemComponent* GetHWAbilitySystemComponent() const;
	class UHWInventoryManagerComponent* GetInventoryManager() const;
	int32 GetLevelByXp(const int32 XP) const;
	class UHWLoadoutComponent* GetLoadoutComponent() const;
	int32 GetMaxLevel() const;
	class AController* GetOwningController() const;
	class UHWPassiveMeterComponent* GetPassiveMeterComponent() const;
	struct FTransform GetRespawnTransform() const;
	int32 GetXpRequirementByLevel(const int32 Level) const;
	bool IsAIControlled() const;
	bool IsAwaitingRespawn() const;
	bool IsDebugIgnoreCooldown() const;
	bool IsDebugIgnoreCosts() const;
	bool IsFamiliar() const;
	bool IsInputCategoryAllowed(EHWAllowedInputCategory Category) const;
	bool IsLocallyControlled() const;
	bool IsPlayableCharacter() const;
	bool IsPlayerControlled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacterAbilitySystemActor">();
	}
	static class AHWCharacterAbilitySystemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacterAbilitySystemActor>();
	}
};
static_assert(alignof(AHWCharacterAbilitySystemActor) == 0x000010, "Wrong alignment on AHWCharacterAbilitySystemActor");
static_assert(sizeof(AHWCharacterAbilitySystemActor) == 0x000730, "Wrong size on AHWCharacterAbilitySystemActor");
static_assert(offsetof(AHWCharacterAbilitySystemActor, ID) == 0x0002B0, "Member 'AHWCharacterAbilitySystemActor::ID' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnCharacterOwnerChanged) == 0x0002B8, "Member 'AHWCharacterAbilitySystemActor::OnCharacterOwnerChanged' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, CurrentCharacterInfo) == 0x0002C8, "Member 'AHWCharacterAbilitySystemActor::CurrentCharacterInfo' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, CharacterOwner) == 0x0002D0, "Member 'AHWCharacterAbilitySystemActor::CharacterOwner' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, CharacterRestartEffect) == 0x0002D8, "Member 'AHWCharacterAbilitySystemActor::CharacterRestartEffect' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, CharacterMasteryLevel) == 0x0002E0, "Member 'AHWCharacterAbilitySystemActor::CharacterMasteryLevel' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, DynamicSubLevelHandle) == 0x0002E8, "Member 'AHWCharacterAbilitySystemActor::DynamicSubLevelHandle' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnCurrentPlayerStateChanged) == 0x0002F8, "Member 'AHWCharacterAbilitySystemActor::OnCurrentPlayerStateChanged' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, CurrentPlayerState) == 0x000308, "Member 'AHWCharacterAbilitySystemActor::CurrentPlayerState' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnControllerOwnershipChangedDelegate) == 0x000310, "Member 'AHWCharacterAbilitySystemActor::OnControllerOwnershipChangedDelegate' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, AbilitySystemComponent) == 0x000328, "Member 'AHWCharacterAbilitySystemActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, CritProbability) == 0x000330, "Member 'AHWCharacterAbilitySystemActor::CritProbability' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, ClassCharacterLevelingEffect) == 0x000348, "Member 'AHWCharacterAbilitySystemActor::ClassCharacterLevelingEffect' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, HandleLevelEffect) == 0x000350, "Member 'AHWCharacterAbilitySystemActor::HandleLevelEffect' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, MapLevelXp) == 0x000358, "Member 'AHWCharacterAbilitySystemActor::MapLevelXp' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnInventoryManagerChanged) == 0x0003A8, "Member 'AHWCharacterAbilitySystemActor::OnInventoryManagerChanged' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, InventoryManager) == 0x0003B8, "Member 'AHWCharacterAbilitySystemActor::InventoryManager' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, RHPlayerUuid) == 0x0003C0, "Member 'AHWCharacterAbilitySystemActor::RHPlayerUuid' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, LoadoutComponent) == 0x0003D0, "Member 'AHWCharacterAbilitySystemActor::LoadoutComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnCharacterDied) == 0x0003E8, "Member 'AHWCharacterAbilitySystemActor::OnCharacterDied' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnCharacterRespawned) == 0x0003F8, "Member 'AHWCharacterAbilitySystemActor::OnCharacterRespawned' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, AwaitingRespawn) == 0x000408, "Member 'AHWCharacterAbilitySystemActor::AwaitingRespawn' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, ExpectedRespawnTimeStamp) == 0x00040C, "Member 'AHWCharacterAbilitySystemActor::ExpectedRespawnTimeStamp' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, bIsAllowedToRecycleCharacter) == 0x000410, "Member 'AHWCharacterAbilitySystemActor::bIsAllowedToRecycleCharacter' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, CurrentMultikillCount) == 0x000484, "Member 'AHWCharacterAbilitySystemActor::CurrentMultikillCount' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, LastMultikillTimestamp) == 0x000488, "Member 'AHWCharacterAbilitySystemActor::LastMultikillTimestamp' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, MultikillTrackDuration) == 0x00048C, "Member 'AHWCharacterAbilitySystemActor::MultikillTrackDuration' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnPassiveMeterComponentChanged) == 0x000490, "Member 'AHWCharacterAbilitySystemActor::OnPassiveMeterComponentChanged' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, PassiveMeterComponent) == 0x0004A0, "Member 'AHWCharacterAbilitySystemActor::PassiveMeterComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnTeamUpdated) == 0x0004A8, "Member 'AHWCharacterAbilitySystemActor::OnTeamUpdated' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, TeamState) == 0x0004B8, "Member 'AHWCharacterAbilitySystemActor::TeamState' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnAutoBuyComponentChanged) == 0x0004C0, "Member 'AHWCharacterAbilitySystemActor::OnAutoBuyComponentChanged' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnAutoSkillComponentChanged) == 0x0004D0, "Member 'AHWCharacterAbilitySystemActor::OnAutoSkillComponentChanged' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, AutoSkillComponent) == 0x0004E0, "Member 'AHWCharacterAbilitySystemActor::AutoSkillComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, AutoBuyComponent) == 0x0004E8, "Member 'AHWCharacterAbilitySystemActor::AutoBuyComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, OnFamiliarManagerChanged) == 0x0004F0, "Member 'AHWCharacterAbilitySystemActor::OnFamiliarManagerChanged' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, FamiliarManager) == 0x000500, "Member 'AHWCharacterAbilitySystemActor::FamiliarManager' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, FamiliarComponent) == 0x000508, "Member 'AHWCharacterAbilitySystemActor::FamiliarComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, VisibilityComponentUpdated) == 0x000510, "Member 'AHWCharacterAbilitySystemActor::VisibilityComponentUpdated' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, VisibilityComponent) == 0x000520, "Member 'AHWCharacterAbilitySystemActor::VisibilityComponent' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, ReplicatedGameplayCues) == 0x000528, "Member 'AHWCharacterAbilitySystemActor::ReplicatedGameplayCues' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, DeferredFlashEvents) == 0x000650, "Member 'AHWCharacterAbilitySystemActor::DeferredFlashEvents' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, UnprocessedMinimalReplicationGameplayCues) == 0x000660, "Member 'AHWCharacterAbilitySystemActor::UnprocessedMinimalReplicationGameplayCues' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, bIgnoreCooldowns) == 0x000678, "Member 'AHWCharacterAbilitySystemActor::bIgnoreCooldowns' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, bIgnoreCosts) == 0x000679, "Member 'AHWCharacterAbilitySystemActor::bIgnoreCosts' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, bDetectingBlockedFires) == 0x00067A, "Member 'AHWCharacterAbilitySystemActor::bDetectingBlockedFires' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, NumFireFailuresToTriggerReport) == 0x00067C, "Member 'AHWCharacterAbilitySystemActor::NumFireFailuresToTriggerReport' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, LastSuccessfulAbilityName) == 0x000688, "Member 'AHWCharacterAbilitySystemActor::LastSuccessfulAbilityName' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, CharSpecificItemDataTable) == 0x0006F8, "Member 'AHWCharacterAbilitySystemActor::CharSpecificItemDataTable' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, CharSpecificItemStoreConfigRows) == 0x000710, "Member 'AHWCharacterAbilitySystemActor::CharSpecificItemStoreConfigRows' has a wrong offset!");
static_assert(offsetof(AHWCharacterAbilitySystemActor, GrantedDynamicItems) == 0x000720, "Member 'AHWCharacterAbilitySystemActor::GrantedDynamicItems' has a wrong offset!");

// Class Hemingway.HWTargeter_Interact
// 0x0000 (0x0650 - 0x0650)
class AHWTargeter_Interact final : public AHWTargeter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWTargeter_Interact">();
	}
	static class AHWTargeter_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWTargeter_Interact>();
	}
};
static_assert(alignof(AHWTargeter_Interact) == 0x000010, "Wrong alignment on AHWTargeter_Interact");
static_assert(sizeof(AHWTargeter_Interact) == 0x000650, "Wrong size on AHWTargeter_Interact");

// Class Hemingway.HWTimeSeriesDataSource
// 0x0018 (0x0040 - 0x0028)
class UHWTimeSeriesDataSource final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDataPoint(class FName SeriesId, float Time, float Value);
	void AddTimeSeries(class FName SeriesId, const class FText& SeriesName);
	void ClearData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWTimeSeriesDataSource">();
	}
	static class UHWTimeSeriesDataSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWTimeSeriesDataSource>();
	}
};
static_assert(alignof(UHWTimeSeriesDataSource) == 0x000008, "Wrong alignment on UHWTimeSeriesDataSource");
static_assert(sizeof(UHWTimeSeriesDataSource) == 0x000040, "Wrong size on UHWTimeSeriesDataSource");

// Class Hemingway.HWVectorFieldWaypointComponent
// 0x0078 (0x0118 - 0x00A0)
class UHWVectorFieldWaypointComponent final : public UActorComponent
{
public:
	bool                                          bDrawDebug;                                        // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugDrawLifetime;                                 // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugDrawArrowLength;                              // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugDrawArrowSize;                                // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugDrawZ;                                        // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugDrawThickness;                                // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint8>                                 QuantizedVectorField;                              // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FLevelGrid                             LevelGrid;                                         // 0x00C8(0x0050)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void DebugDrawField();
	void Generate(int32 tileCountX, int32 tileCountY, float endPointDistance);

	struct FVector GetAvgVectorValue(const struct FVector& Location, float Radius) const;
	struct FVector GetVectorValue(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVectorFieldWaypointComponent">();
	}
	static class UHWVectorFieldWaypointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVectorFieldWaypointComponent>();
	}
};
static_assert(alignof(UHWVectorFieldWaypointComponent) == 0x000008, "Wrong alignment on UHWVectorFieldWaypointComponent");
static_assert(sizeof(UHWVectorFieldWaypointComponent) == 0x000118, "Wrong size on UHWVectorFieldWaypointComponent");
static_assert(offsetof(UHWVectorFieldWaypointComponent, bDrawDebug) == 0x0000A0, "Member 'UHWVectorFieldWaypointComponent::bDrawDebug' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldWaypointComponent, DebugDrawLifetime) == 0x0000A4, "Member 'UHWVectorFieldWaypointComponent::DebugDrawLifetime' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldWaypointComponent, DebugDrawArrowLength) == 0x0000A8, "Member 'UHWVectorFieldWaypointComponent::DebugDrawArrowLength' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldWaypointComponent, DebugDrawArrowSize) == 0x0000AC, "Member 'UHWVectorFieldWaypointComponent::DebugDrawArrowSize' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldWaypointComponent, DebugDrawZ) == 0x0000B0, "Member 'UHWVectorFieldWaypointComponent::DebugDrawZ' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldWaypointComponent, DebugDrawThickness) == 0x0000B4, "Member 'UHWVectorFieldWaypointComponent::DebugDrawThickness' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldWaypointComponent, QuantizedVectorField) == 0x0000B8, "Member 'UHWVectorFieldWaypointComponent::QuantizedVectorField' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldWaypointComponent, LevelGrid) == 0x0000C8, "Member 'UHWVectorFieldWaypointComponent::LevelGrid' has a wrong offset!");

// Class Hemingway.HWAbilityTask_WaitForAtributeChanged_Enhanced
// 0x00F0 (0x0170 - 0x0080)
class UHWAbilityTask_WaitForAtributeChanged_Enhanced final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayAttribute& Attribute, float NewValue, float OldValue, class UAbilitySystemComponent* OwningAbilitySystem)> OnChangeDelegate; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHWWaitForAttributeChangedConfig       ConfigSetting;                                     // 0x0090(0x00D0)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x0168(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UHWAbilityTask_WaitForAtributeChanged_Enhanced* WaitForAttributeChange_Enhanced(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FHWWaitForAttributeChangedConfig& Config, class AActor* OptionalExternalOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_WaitForAtributeChanged_Enhanced">();
	}
	static class UHWAbilityTask_WaitForAtributeChanged_Enhanced* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_WaitForAtributeChanged_Enhanced>();
	}
};
static_assert(alignof(UHWAbilityTask_WaitForAtributeChanged_Enhanced) == 0x000008, "Wrong alignment on UHWAbilityTask_WaitForAtributeChanged_Enhanced");
static_assert(sizeof(UHWAbilityTask_WaitForAtributeChanged_Enhanced) == 0x000170, "Wrong size on UHWAbilityTask_WaitForAtributeChanged_Enhanced");
static_assert(offsetof(UHWAbilityTask_WaitForAtributeChanged_Enhanced, OnChangeDelegate) == 0x000080, "Member 'UHWAbilityTask_WaitForAtributeChanged_Enhanced::OnChangeDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitForAtributeChanged_Enhanced, ConfigSetting) == 0x000090, "Member 'UHWAbilityTask_WaitForAtributeChanged_Enhanced::ConfigSetting' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitForAtributeChanged_Enhanced, ExternalOwner) == 0x000168, "Member 'UHWAbilityTask_WaitForAtributeChanged_Enhanced::ExternalOwner' has a wrong offset!");

// Class Hemingway.HWVectorFieldFollowCalc
// 0x0010 (0x0040 - 0x0030)
class UHWVectorFieldFollowCalc : public UDataAsset
{
public:
	float                                         DistanceScale;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinValue;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Modifier;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVectorFieldFollowCalc">();
	}
	static class UHWVectorFieldFollowCalc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVectorFieldFollowCalc>();
	}
};
static_assert(alignof(UHWVectorFieldFollowCalc) == 0x000008, "Wrong alignment on UHWVectorFieldFollowCalc");
static_assert(sizeof(UHWVectorFieldFollowCalc) == 0x000040, "Wrong size on UHWVectorFieldFollowCalc");
static_assert(offsetof(UHWVectorFieldFollowCalc, DistanceScale) == 0x000030, "Member 'UHWVectorFieldFollowCalc::DistanceScale' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc, MinValue) == 0x000034, "Member 'UHWVectorFieldFollowCalc::MinValue' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc, MaxValue) == 0x000038, "Member 'UHWVectorFieldFollowCalc::MaxValue' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc, Modifier) == 0x00003C, "Member 'UHWVectorFieldFollowCalc::Modifier' has a wrong offset!");

// Class Hemingway.HWAbilityTask_ListenForContinousFireState
// 0x0028 (0x00A8 - 0x0080)
class UHWAbilityTask_ListenForContinousFireState final : public UAbilityTask
{
public:
	class UAbilityTask_WaitInputRelease*          WaitAbilityInputReleaseTask;                       // 0x0080(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitInputPress*            WaitAbilityInputPressedTask;                       // 0x0088(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInputPressedReal;                               // 0x0090(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInputPressedLocked;                             // 0x0091(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnforceLockoutPeriod;                             // 0x0092(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_93[0x1];                                       // 0x0093(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x0094(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityInputPressed(const float TimeWaited);
	void OnAbilityInputReleased(const float TimeHeld);
	void OnLockoutStarted();
	void OnReceivedClientInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_ListenForContinousFireState">();
	}
	static class UHWAbilityTask_ListenForContinousFireState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_ListenForContinousFireState>();
	}
};
static_assert(alignof(UHWAbilityTask_ListenForContinousFireState) == 0x000008, "Wrong alignment on UHWAbilityTask_ListenForContinousFireState");
static_assert(sizeof(UHWAbilityTask_ListenForContinousFireState) == 0x0000A8, "Wrong size on UHWAbilityTask_ListenForContinousFireState");
static_assert(offsetof(UHWAbilityTask_ListenForContinousFireState, WaitAbilityInputReleaseTask) == 0x000080, "Member 'UHWAbilityTask_ListenForContinousFireState::WaitAbilityInputReleaseTask' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_ListenForContinousFireState, WaitAbilityInputPressedTask) == 0x000088, "Member 'UHWAbilityTask_ListenForContinousFireState::WaitAbilityInputPressedTask' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_ListenForContinousFireState, bIsInputPressedReal) == 0x000090, "Member 'UHWAbilityTask_ListenForContinousFireState::bIsInputPressedReal' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_ListenForContinousFireState, bIsInputPressedLocked) == 0x000091, "Member 'UHWAbilityTask_ListenForContinousFireState::bIsInputPressedLocked' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_ListenForContinousFireState, bEnforceLockoutPeriod) == 0x000092, "Member 'UHWAbilityTask_ListenForContinousFireState::bEnforceLockoutPeriod' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_ListenForContinousFireState, StartTime) == 0x000094, "Member 'UHWAbilityTask_ListenForContinousFireState::StartTime' has a wrong offset!");

// Class Hemingway.HWVectorFieldFollowCalc_ThreatCurve
// 0x0020 (0x0060 - 0x0040)
class UHWVectorFieldFollowCalc_ThreatCurve final : public UHWVectorFieldFollowCalc
{
public:
	struct FHWAIThreatCalculation                 Calc;                                              // 0x0040(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVectorFieldFollowCalc_ThreatCurve">();
	}
	static class UHWVectorFieldFollowCalc_ThreatCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVectorFieldFollowCalc_ThreatCurve>();
	}
};
static_assert(alignof(UHWVectorFieldFollowCalc_ThreatCurve) == 0x000008, "Wrong alignment on UHWVectorFieldFollowCalc_ThreatCurve");
static_assert(sizeof(UHWVectorFieldFollowCalc_ThreatCurve) == 0x000060, "Wrong size on UHWVectorFieldFollowCalc_ThreatCurve");
static_assert(offsetof(UHWVectorFieldFollowCalc_ThreatCurve, Calc) == 0x000040, "Member 'UHWVectorFieldFollowCalc_ThreatCurve::Calc' has a wrong offset!");

// Class Hemingway.HWVectorFieldFollowCalc_Gravity
// 0x0008 (0x0048 - 0x0040)
class UHWVectorFieldFollowCalc_Gravity : public UHWVectorFieldFollowCalc
{
public:
	float                                         GValue;                                            // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVectorFieldFollowCalc_Gravity">();
	}
	static class UHWVectorFieldFollowCalc_Gravity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVectorFieldFollowCalc_Gravity>();
	}
};
static_assert(alignof(UHWVectorFieldFollowCalc_Gravity) == 0x000008, "Wrong alignment on UHWVectorFieldFollowCalc_Gravity");
static_assert(sizeof(UHWVectorFieldFollowCalc_Gravity) == 0x000048, "Wrong size on UHWVectorFieldFollowCalc_Gravity");
static_assert(offsetof(UHWVectorFieldFollowCalc_Gravity, GValue) == 0x000040, "Member 'UHWVectorFieldFollowCalc_Gravity::GValue' has a wrong offset!");

// Class Hemingway.HWVectorFieldFollowCalc_AvoidanceGravity
// 0x0008 (0x0050 - 0x0048)
class UHWVectorFieldFollowCalc_AvoidanceGravity final : public UHWVectorFieldFollowCalc_Gravity
{
public:
	float                                         MinFacingDot;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVectorFieldFollowCalc_AvoidanceGravity">();
	}
	static class UHWVectorFieldFollowCalc_AvoidanceGravity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVectorFieldFollowCalc_AvoidanceGravity>();
	}
};
static_assert(alignof(UHWVectorFieldFollowCalc_AvoidanceGravity) == 0x000008, "Wrong alignment on UHWVectorFieldFollowCalc_AvoidanceGravity");
static_assert(sizeof(UHWVectorFieldFollowCalc_AvoidanceGravity) == 0x000050, "Wrong size on UHWVectorFieldFollowCalc_AvoidanceGravity");
static_assert(offsetof(UHWVectorFieldFollowCalc_AvoidanceGravity, MinFacingDot) == 0x000048, "Member 'UHWVectorFieldFollowCalc_AvoidanceGravity::MinFacingDot' has a wrong offset!");

// Class Hemingway.HWAbilityTask_WaitQuickCastInput
// 0x0038 (0x00B8 - 0x0080)
class UHWAbilityTask_WaitQuickCastInput final : public UAbilityTask
{
public:
	class UAbilityTask_WaitInputRelease*          WaitAbilityInputReleaseTask;                       // 0x0080(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitConfirmCancel*         WaitConfirmCancelTask;                             // 0x0088(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const float InputHeldTime)> OnQuickCastConfirmed;                  // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const float InputHeldTime)> OnQuickCastCancelled;                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UHWAbilityTask_WaitQuickCastInput* WaitForQuickCastInput(class UGameplayAbility* OwningAbility, class FName TaskInstanceName);

	void OnAbilityCancelledPressed();
	void OnAbilityConfirmedPressed();
	void OnAbilityInputReleased(const float TimeHeld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_WaitQuickCastInput">();
	}
	static class UHWAbilityTask_WaitQuickCastInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_WaitQuickCastInput>();
	}
};
static_assert(alignof(UHWAbilityTask_WaitQuickCastInput) == 0x000008, "Wrong alignment on UHWAbilityTask_WaitQuickCastInput");
static_assert(sizeof(UHWAbilityTask_WaitQuickCastInput) == 0x0000B8, "Wrong size on UHWAbilityTask_WaitQuickCastInput");
static_assert(offsetof(UHWAbilityTask_WaitQuickCastInput, WaitAbilityInputReleaseTask) == 0x000080, "Member 'UHWAbilityTask_WaitQuickCastInput::WaitAbilityInputReleaseTask' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitQuickCastInput, WaitConfirmCancelTask) == 0x000088, "Member 'UHWAbilityTask_WaitQuickCastInput::WaitConfirmCancelTask' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitQuickCastInput, OnQuickCastConfirmed) == 0x000098, "Member 'UHWAbilityTask_WaitQuickCastInput::OnQuickCastConfirmed' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitQuickCastInput, OnQuickCastCancelled) == 0x0000A8, "Member 'UHWAbilityTask_WaitQuickCastInput::OnQuickCastCancelled' has a wrong offset!");

// Class Hemingway.HWVectorFieldFollowCalc_Gaussian
// 0x0010 (0x0050 - 0x0040)
class UHWVectorFieldFollowCalc_Gaussian final : public UHWVectorFieldFollowCalc
{
public:
	float                                         CurvePeak;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CenterX;                                           // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandardDeviation;                                 // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YOffset;                                           // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVectorFieldFollowCalc_Gaussian">();
	}
	static class UHWVectorFieldFollowCalc_Gaussian* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVectorFieldFollowCalc_Gaussian>();
	}
};
static_assert(alignof(UHWVectorFieldFollowCalc_Gaussian) == 0x000008, "Wrong alignment on UHWVectorFieldFollowCalc_Gaussian");
static_assert(sizeof(UHWVectorFieldFollowCalc_Gaussian) == 0x000050, "Wrong size on UHWVectorFieldFollowCalc_Gaussian");
static_assert(offsetof(UHWVectorFieldFollowCalc_Gaussian, CurvePeak) == 0x000040, "Member 'UHWVectorFieldFollowCalc_Gaussian::CurvePeak' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc_Gaussian, CenterX) == 0x000044, "Member 'UHWVectorFieldFollowCalc_Gaussian::CenterX' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc_Gaussian, StandardDeviation) == 0x000048, "Member 'UHWVectorFieldFollowCalc_Gaussian::StandardDeviation' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc_Gaussian, YOffset) == 0x00004C, "Member 'UHWVectorFieldFollowCalc_Gaussian::YOffset' has a wrong offset!");

// Class Hemingway.HWMessageFormatterContext_ItemPurchased
// 0x0010 (0x0038 - 0x0028)
class UHWMessageFormatterContext_ItemPurchased final : public UObject
{
public:
	class UHWEquipmentItem*                       PurchasedItem;                                     // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         OwnerPlayer;                                       // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWMessageFormatterContext_ItemPurchased">();
	}
	static class UHWMessageFormatterContext_ItemPurchased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWMessageFormatterContext_ItemPurchased>();
	}
};
static_assert(alignof(UHWMessageFormatterContext_ItemPurchased) == 0x000008, "Wrong alignment on UHWMessageFormatterContext_ItemPurchased");
static_assert(sizeof(UHWMessageFormatterContext_ItemPurchased) == 0x000038, "Wrong size on UHWMessageFormatterContext_ItemPurchased");
static_assert(offsetof(UHWMessageFormatterContext_ItemPurchased, PurchasedItem) == 0x000028, "Member 'UHWMessageFormatterContext_ItemPurchased::PurchasedItem' has a wrong offset!");
static_assert(offsetof(UHWMessageFormatterContext_ItemPurchased, OwnerPlayer) == 0x000030, "Member 'UHWMessageFormatterContext_ItemPurchased::OwnerPlayer' has a wrong offset!");

// Class Hemingway.HWVectorFieldFollowCalc_Sigmoid
// 0x0010 (0x0050 - 0x0040)
class UHWVectorFieldFollowCalc_Sigmoid final : public UHWVectorFieldFollowCalc
{
public:
	float                                         Tightness;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         XOffset;                                           // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YOffset;                                           // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVectorFieldFollowCalc_Sigmoid">();
	}
	static class UHWVectorFieldFollowCalc_Sigmoid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVectorFieldFollowCalc_Sigmoid>();
	}
};
static_assert(alignof(UHWVectorFieldFollowCalc_Sigmoid) == 0x000008, "Wrong alignment on UHWVectorFieldFollowCalc_Sigmoid");
static_assert(sizeof(UHWVectorFieldFollowCalc_Sigmoid) == 0x000050, "Wrong size on UHWVectorFieldFollowCalc_Sigmoid");
static_assert(offsetof(UHWVectorFieldFollowCalc_Sigmoid, Tightness) == 0x000040, "Member 'UHWVectorFieldFollowCalc_Sigmoid::Tightness' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc_Sigmoid, XOffset) == 0x000044, "Member 'UHWVectorFieldFollowCalc_Sigmoid::XOffset' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc_Sigmoid, YOffset) == 0x000048, "Member 'UHWVectorFieldFollowCalc_Sigmoid::YOffset' has a wrong offset!");

// Class Hemingway.HWVectorFieldFollowCalc_PieceWise
// 0x0030 (0x0070 - 0x0040)
class UHWVectorFieldFollowCalc_PieceWise final : public UHWVectorFieldFollowCalc
{
public:
	TArray<float>                                 X0Values;                                          // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 X1Values;                                          // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 YValues;                                           // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVectorFieldFollowCalc_PieceWise">();
	}
	static class UHWVectorFieldFollowCalc_PieceWise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVectorFieldFollowCalc_PieceWise>();
	}
};
static_assert(alignof(UHWVectorFieldFollowCalc_PieceWise) == 0x000008, "Wrong alignment on UHWVectorFieldFollowCalc_PieceWise");
static_assert(sizeof(UHWVectorFieldFollowCalc_PieceWise) == 0x000070, "Wrong size on UHWVectorFieldFollowCalc_PieceWise");
static_assert(offsetof(UHWVectorFieldFollowCalc_PieceWise, X0Values) == 0x000040, "Member 'UHWVectorFieldFollowCalc_PieceWise::X0Values' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc_PieceWise, X1Values) == 0x000050, "Member 'UHWVectorFieldFollowCalc_PieceWise::X1Values' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc_PieceWise, YValues) == 0x000060, "Member 'UHWVectorFieldFollowCalc_PieceWise::YValues' has a wrong offset!");

// Class Hemingway.HWVectorFieldFollowCalc_TowerZone
// 0x0008 (0x0048 - 0x0040)
class UHWVectorFieldFollowCalc_TowerZone final : public UHWVectorFieldFollowCalc
{
public:
	float                                         PushOutDistance;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CancelDistance;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVectorFieldFollowCalc_TowerZone">();
	}
	static class UHWVectorFieldFollowCalc_TowerZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVectorFieldFollowCalc_TowerZone>();
	}
};
static_assert(alignof(UHWVectorFieldFollowCalc_TowerZone) == 0x000008, "Wrong alignment on UHWVectorFieldFollowCalc_TowerZone");
static_assert(sizeof(UHWVectorFieldFollowCalc_TowerZone) == 0x000048, "Wrong size on UHWVectorFieldFollowCalc_TowerZone");
static_assert(offsetof(UHWVectorFieldFollowCalc_TowerZone, PushOutDistance) == 0x000040, "Member 'UHWVectorFieldFollowCalc_TowerZone::PushOutDistance' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowCalc_TowerZone, CancelDistance) == 0x000044, "Member 'UHWVectorFieldFollowCalc_TowerZone::CancelDistance' has a wrong offset!");

// Class Hemingway.HWLobby_AnimInstBase
// 0x01C0 (0x0570 - 0x03B0)
class UHWLobby_AnimInstBase : public USkinnedAnimInstance
{
public:
	bool                                          SkinningEnabled;                                   // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0xF];                                      // 0x03A9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkeletalMeshComponent*>         OwnerSkeletalMeshes;                               // 0x03B8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          isSkinningComplete;                                // 0x03C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIntroPresentationType                        IntroPresentation;                                 // 0x03C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CA[0x6];                                      // 0x03CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            s_CurveBreath;                                     // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               s_Breath_Rotation_Spine1;                          // 0x03D8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               s_Breath_Rotation_Spine2;                          // 0x03F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               s_Breath_Rotation_Neck;                            // 0x0408(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               s_Breath_Rotation_ClavicleL;                       // 0x0420(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               s_Breath_Rotation_ClavicleR;                       // 0x0438(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               s_Breath_Rotation_Head;                            // 0x0450(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                s_Breath_Scale_Spine1;                             // 0x0468(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                s_Breath_Scale_Spine2;                             // 0x0480(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                s_Breath_Scale_Neck;                               // 0x0498(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            s_CurveBlink;                                      // 0x04B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Blink_MaxRot;                                    // 0x04B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Blink_Time_Min;                                  // 0x04BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Blink_Time_Max;                                  // 0x04C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          s_EyeDartEnabled;                                  // 0x04C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C5[0x3];                                      // 0x04C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        s_EyeDart_Targets_L;                               // 0x04C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        s_EyeDart_Targets_C;                               // 0x04D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        s_EyeDart_Targets_R;                               // 0x04E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         s_EyeDart_ClampEyeRotation;                        // 0x04F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_EyeDart_InterpTime;                              // 0x04FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_EyeDart_Aim_Left;                                // 0x0500(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_EyeDart_Aim_Right;                               // 0x0504(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_EyeDart_Time_Min;                                // 0x0508(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_EyeDart_Time_Max;                                // 0x050C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          s_AimEnabled;                                      // 0x0510(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_511[0x3];                                      // 0x0511(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         s_Aim_Time_Min;                                    // 0x0514(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Aim_Time_Max;                                    // 0x0518(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Aim_Yaw_Range_Min;                               // 0x051C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Aim_Yaw_Range_Max;                               // 0x0520(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Aim_Pitch_Range_Min;                             // 0x0524(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Aim_Pitch_Range_Max;                             // 0x0528(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Aim_Yaw_Next_Min;                                // 0x052C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Aim_Yaw_Next_Max;                                // 0x0530(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Aim_Pitch_Next_Min;                              // 0x0534(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Aim_Pitch_Next_Max;                              // 0x0538(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          s_Fidget_Enabled;                                  // 0x053C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53D[0x3];                                      // 0x053D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         s_Fidget_Count;                                    // 0x0540(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Fidget_Time_Min;                                 // 0x0544(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Fidget_Time_Max;                                 // 0x0548(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          s_Variant_Enabled;                                 // 0x054C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54D[0x3];                                      // 0x054D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         s_Variant_TriggerTime_Min;                         // 0x0550(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Variant_TriggerTime_Max;                         // 0x0554(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Variant_Duration_Min;                            // 0x0558(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_Variant_Duration_Max;                            // 0x055C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_RootMotion_Alpha;                                // 0x0560(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         s_RootMotion_PlayRate;                             // 0x0564(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ABPSkinningFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLobby_AnimInstBase">();
	}
	static class UHWLobby_AnimInstBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLobby_AnimInstBase>();
	}
};
static_assert(alignof(UHWLobby_AnimInstBase) == 0x000010, "Wrong alignment on UHWLobby_AnimInstBase");
static_assert(sizeof(UHWLobby_AnimInstBase) == 0x000570, "Wrong size on UHWLobby_AnimInstBase");
static_assert(offsetof(UHWLobby_AnimInstBase, SkinningEnabled) == 0x0003A8, "Member 'UHWLobby_AnimInstBase::SkinningEnabled' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, OwnerSkeletalMeshes) == 0x0003B8, "Member 'UHWLobby_AnimInstBase::OwnerSkeletalMeshes' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, isSkinningComplete) == 0x0003C8, "Member 'UHWLobby_AnimInstBase::isSkinningComplete' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, IntroPresentation) == 0x0003C9, "Member 'UHWLobby_AnimInstBase::IntroPresentation' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_CurveBreath) == 0x0003D0, "Member 'UHWLobby_AnimInstBase::s_CurveBreath' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Breath_Rotation_Spine1) == 0x0003D8, "Member 'UHWLobby_AnimInstBase::s_Breath_Rotation_Spine1' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Breath_Rotation_Spine2) == 0x0003F0, "Member 'UHWLobby_AnimInstBase::s_Breath_Rotation_Spine2' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Breath_Rotation_Neck) == 0x000408, "Member 'UHWLobby_AnimInstBase::s_Breath_Rotation_Neck' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Breath_Rotation_ClavicleL) == 0x000420, "Member 'UHWLobby_AnimInstBase::s_Breath_Rotation_ClavicleL' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Breath_Rotation_ClavicleR) == 0x000438, "Member 'UHWLobby_AnimInstBase::s_Breath_Rotation_ClavicleR' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Breath_Rotation_Head) == 0x000450, "Member 'UHWLobby_AnimInstBase::s_Breath_Rotation_Head' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Breath_Scale_Spine1) == 0x000468, "Member 'UHWLobby_AnimInstBase::s_Breath_Scale_Spine1' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Breath_Scale_Spine2) == 0x000480, "Member 'UHWLobby_AnimInstBase::s_Breath_Scale_Spine2' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Breath_Scale_Neck) == 0x000498, "Member 'UHWLobby_AnimInstBase::s_Breath_Scale_Neck' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_CurveBlink) == 0x0004B0, "Member 'UHWLobby_AnimInstBase::s_CurveBlink' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Blink_MaxRot) == 0x0004B8, "Member 'UHWLobby_AnimInstBase::s_Blink_MaxRot' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Blink_Time_Min) == 0x0004BC, "Member 'UHWLobby_AnimInstBase::s_Blink_Time_Min' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Blink_Time_Max) == 0x0004C0, "Member 'UHWLobby_AnimInstBase::s_Blink_Time_Max' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_EyeDartEnabled) == 0x0004C4, "Member 'UHWLobby_AnimInstBase::s_EyeDartEnabled' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_EyeDart_Targets_L) == 0x0004C8, "Member 'UHWLobby_AnimInstBase::s_EyeDart_Targets_L' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_EyeDart_Targets_C) == 0x0004D8, "Member 'UHWLobby_AnimInstBase::s_EyeDart_Targets_C' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_EyeDart_Targets_R) == 0x0004E8, "Member 'UHWLobby_AnimInstBase::s_EyeDart_Targets_R' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_EyeDart_ClampEyeRotation) == 0x0004F8, "Member 'UHWLobby_AnimInstBase::s_EyeDart_ClampEyeRotation' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_EyeDart_InterpTime) == 0x0004FC, "Member 'UHWLobby_AnimInstBase::s_EyeDart_InterpTime' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_EyeDart_Aim_Left) == 0x000500, "Member 'UHWLobby_AnimInstBase::s_EyeDart_Aim_Left' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_EyeDart_Aim_Right) == 0x000504, "Member 'UHWLobby_AnimInstBase::s_EyeDart_Aim_Right' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_EyeDart_Time_Min) == 0x000508, "Member 'UHWLobby_AnimInstBase::s_EyeDart_Time_Min' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_EyeDart_Time_Max) == 0x00050C, "Member 'UHWLobby_AnimInstBase::s_EyeDart_Time_Max' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_AimEnabled) == 0x000510, "Member 'UHWLobby_AnimInstBase::s_AimEnabled' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Aim_Time_Min) == 0x000514, "Member 'UHWLobby_AnimInstBase::s_Aim_Time_Min' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Aim_Time_Max) == 0x000518, "Member 'UHWLobby_AnimInstBase::s_Aim_Time_Max' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Aim_Yaw_Range_Min) == 0x00051C, "Member 'UHWLobby_AnimInstBase::s_Aim_Yaw_Range_Min' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Aim_Yaw_Range_Max) == 0x000520, "Member 'UHWLobby_AnimInstBase::s_Aim_Yaw_Range_Max' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Aim_Pitch_Range_Min) == 0x000524, "Member 'UHWLobby_AnimInstBase::s_Aim_Pitch_Range_Min' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Aim_Pitch_Range_Max) == 0x000528, "Member 'UHWLobby_AnimInstBase::s_Aim_Pitch_Range_Max' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Aim_Yaw_Next_Min) == 0x00052C, "Member 'UHWLobby_AnimInstBase::s_Aim_Yaw_Next_Min' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Aim_Yaw_Next_Max) == 0x000530, "Member 'UHWLobby_AnimInstBase::s_Aim_Yaw_Next_Max' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Aim_Pitch_Next_Min) == 0x000534, "Member 'UHWLobby_AnimInstBase::s_Aim_Pitch_Next_Min' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Aim_Pitch_Next_Max) == 0x000538, "Member 'UHWLobby_AnimInstBase::s_Aim_Pitch_Next_Max' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Fidget_Enabled) == 0x00053C, "Member 'UHWLobby_AnimInstBase::s_Fidget_Enabled' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Fidget_Count) == 0x000540, "Member 'UHWLobby_AnimInstBase::s_Fidget_Count' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Fidget_Time_Min) == 0x000544, "Member 'UHWLobby_AnimInstBase::s_Fidget_Time_Min' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Fidget_Time_Max) == 0x000548, "Member 'UHWLobby_AnimInstBase::s_Fidget_Time_Max' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Variant_Enabled) == 0x00054C, "Member 'UHWLobby_AnimInstBase::s_Variant_Enabled' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Variant_TriggerTime_Min) == 0x000550, "Member 'UHWLobby_AnimInstBase::s_Variant_TriggerTime_Min' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Variant_TriggerTime_Max) == 0x000554, "Member 'UHWLobby_AnimInstBase::s_Variant_TriggerTime_Max' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Variant_Duration_Min) == 0x000558, "Member 'UHWLobby_AnimInstBase::s_Variant_Duration_Min' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_Variant_Duration_Max) == 0x00055C, "Member 'UHWLobby_AnimInstBase::s_Variant_Duration_Max' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_RootMotion_Alpha) == 0x000560, "Member 'UHWLobby_AnimInstBase::s_RootMotion_Alpha' has a wrong offset!");
static_assert(offsetof(UHWLobby_AnimInstBase, s_RootMotion_PlayRate) == 0x000564, "Member 'UHWLobby_AnimInstBase::s_RootMotion_PlayRate' has a wrong offset!");

// Class Hemingway.HWVectorFieldFollowerComponent
// 0x0070 (0x0110 - 0x00A0)
class UHWVectorFieldFollowerComponent final : public UActorComponent
{
public:
	float                                         MinInputSize;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxEffectors;                                      // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTurnRate;                                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleAvoidanceDistance;                         // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleAvoidanceDotProd;                          // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugSnapShot;                                    // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugSnapShotRate;                                 // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugSnapShotExtent;                               // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugSnapShotPointCount;                           // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  NoMovementFlags;                                   // 0x00C8(0x0020)(Protected, NativeAccessSpecifierProtected)
	bool                                          bIsFollowing;                                      // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugLastSnapShotTime;                             // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVectorFieldEffectorData>       Effectors;                                         // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHWVectorFieldWaypointComponent> CurrentWaypoint;                           // 0x0100(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentWaypointWeight;                             // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateFollowing();
	void AddEffectorActor(class AActor* InActor, class UHWVectorFieldFollowCalc* inCalculation, float InWeight);
	void AddEffectorActorAsObstacle(class AActor* InActor);
	void AddEffectorLocation(const struct FVector& InLocation, class UHWVectorFieldFollowCalc* inCalculation, float InWeight);
	void ClearEffectors();
	void ClearWaypoint();
	void DeactivateFollowing();
	void GenerateDebugSnapShot();
	void SetWaypoint(class AActor* inWaypointActor, float InWeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVectorFieldFollowerComponent">();
	}
	static class UHWVectorFieldFollowerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVectorFieldFollowerComponent>();
	}
};
static_assert(alignof(UHWVectorFieldFollowerComponent) == 0x000008, "Wrong alignment on UHWVectorFieldFollowerComponent");
static_assert(sizeof(UHWVectorFieldFollowerComponent) == 0x000110, "Wrong size on UHWVectorFieldFollowerComponent");
static_assert(offsetof(UHWVectorFieldFollowerComponent, MinInputSize) == 0x0000A0, "Member 'UHWVectorFieldFollowerComponent::MinInputSize' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, MaxEffectors) == 0x0000A4, "Member 'UHWVectorFieldFollowerComponent::MaxEffectors' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, MaxTurnRate) == 0x0000A8, "Member 'UHWVectorFieldFollowerComponent::MaxTurnRate' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, ObstacleAvoidanceDistance) == 0x0000AC, "Member 'UHWVectorFieldFollowerComponent::ObstacleAvoidanceDistance' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, ObstacleAvoidanceDotProd) == 0x0000B0, "Member 'UHWVectorFieldFollowerComponent::ObstacleAvoidanceDotProd' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, bDebugSnapShot) == 0x0000B4, "Member 'UHWVectorFieldFollowerComponent::bDebugSnapShot' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, DebugSnapShotRate) == 0x0000B8, "Member 'UHWVectorFieldFollowerComponent::DebugSnapShotRate' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, DebugSnapShotExtent) == 0x0000BC, "Member 'UHWVectorFieldFollowerComponent::DebugSnapShotExtent' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, DebugSnapShotPointCount) == 0x0000C0, "Member 'UHWVectorFieldFollowerComponent::DebugSnapShotPointCount' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, NoMovementFlags) == 0x0000C8, "Member 'UHWVectorFieldFollowerComponent::NoMovementFlags' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, bIsFollowing) == 0x0000E8, "Member 'UHWVectorFieldFollowerComponent::bIsFollowing' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, DebugLastSnapShotTime) == 0x0000EC, "Member 'UHWVectorFieldFollowerComponent::DebugLastSnapShotTime' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, Effectors) == 0x0000F0, "Member 'UHWVectorFieldFollowerComponent::Effectors' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, CurrentWaypoint) == 0x000100, "Member 'UHWVectorFieldFollowerComponent::CurrentWaypoint' has a wrong offset!");
static_assert(offsetof(UHWVectorFieldFollowerComponent, CurrentWaypointWeight) == 0x000108, "Member 'UHWVectorFieldFollowerComponent::CurrentWaypointWeight' has a wrong offset!");

// Class Hemingway.HWAbilityTask_WaitAbilityFire
// 0x0070 (0x00F0 - 0x0080)
class UHWAbilityTask_WaitAbilityFire final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& AbilityTags, const struct FHWAbilityFiringInstanceId& FiringInstanceId)> OnFire; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x60];                                      // 0x0090(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_WaitAbilityFire* WaitForAbilityFire(class UGameplayAbility* OwningAbility, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, bool TriggerOnce);
	static class UHWAbilityTask_WaitAbilityFire* WaitForAbilityFire_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& Query, bool TriggerOnce);

	void OnAbilityFire(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& AbilityTags, const struct FHWAbilityFiringInstanceId& FiringInstanceId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_WaitAbilityFire">();
	}
	static class UHWAbilityTask_WaitAbilityFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_WaitAbilityFire>();
	}
};
static_assert(alignof(UHWAbilityTask_WaitAbilityFire) == 0x000008, "Wrong alignment on UHWAbilityTask_WaitAbilityFire");
static_assert(sizeof(UHWAbilityTask_WaitAbilityFire) == 0x0000F0, "Wrong size on UHWAbilityTask_WaitAbilityFire");
static_assert(offsetof(UHWAbilityTask_WaitAbilityFire, OnFire) == 0x000080, "Member 'UHWAbilityTask_WaitAbilityFire::OnFire' has a wrong offset!");

// Class Hemingway.HWVoiceComponent
// 0x02B0 (0x0350 - 0x00A0)
class UHWVoiceComponent final : public UHWActorComponent
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              VoiceOverDataTable;                                // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0xF8];                                      // 0x00D0(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FGameplayTag> PurchasedItemCategoryEvents;                      // 0x01C8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGameplayTag> SpawnedDeployableCategoryEvents;                  // 0x0218(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGameplayTag> NpcKilledEvents;                                  // 0x0268(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, float>              EventTimestamps;                                   // 0x02B8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWVoiceOverQueue>              EventQueue;                                        // 0x0308(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FHWVoiceOverQueue                      ActiveEvent;                                       // 0x0318(0x0028)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FHWVoiceOverQueue& VoiceEvent)> OnVoiceEventActive;   // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AttemptPlayVoiceEvent(const struct FHWVoiceOverQueue& Event);
	void OnQueuedEventAudioFinished(class UAudioComponent* FinishedComponent);
	void SetActiveEvent(const struct FHWVoiceOverQueue& NewActiveEvent);
	void TriggerLocalEvent(const struct FGameplayTag& EventType, const class AActor* SkinnableActorOverride);

	bool CanPlayVoice(const struct FGameplayTag& EventTag, const float& ChanceToPlay) const;
	struct FHWVoiceOverQueue GetActiveEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVoiceComponent">();
	}
	static class UHWVoiceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVoiceComponent>();
	}
};
static_assert(alignof(UHWVoiceComponent) == 0x000008, "Wrong alignment on UHWVoiceComponent");
static_assert(sizeof(UHWVoiceComponent) == 0x000350, "Wrong size on UHWVoiceComponent");
static_assert(offsetof(UHWVoiceComponent, GameplayEffectClass) == 0x0000A0, "Member 'UHWVoiceComponent::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(UHWVoiceComponent, VoiceOverDataTable) == 0x0000A8, "Member 'UHWVoiceComponent::VoiceOverDataTable' has a wrong offset!");
static_assert(offsetof(UHWVoiceComponent, PurchasedItemCategoryEvents) == 0x0001C8, "Member 'UHWVoiceComponent::PurchasedItemCategoryEvents' has a wrong offset!");
static_assert(offsetof(UHWVoiceComponent, SpawnedDeployableCategoryEvents) == 0x000218, "Member 'UHWVoiceComponent::SpawnedDeployableCategoryEvents' has a wrong offset!");
static_assert(offsetof(UHWVoiceComponent, NpcKilledEvents) == 0x000268, "Member 'UHWVoiceComponent::NpcKilledEvents' has a wrong offset!");
static_assert(offsetof(UHWVoiceComponent, EventTimestamps) == 0x0002B8, "Member 'UHWVoiceComponent::EventTimestamps' has a wrong offset!");
static_assert(offsetof(UHWVoiceComponent, EventQueue) == 0x000308, "Member 'UHWVoiceComponent::EventQueue' has a wrong offset!");
static_assert(offsetof(UHWVoiceComponent, ActiveEvent) == 0x000318, "Member 'UHWVoiceComponent::ActiveEvent' has a wrong offset!");
static_assert(offsetof(UHWVoiceComponent, OnVoiceEventActive) == 0x000340, "Member 'UHWVoiceComponent::OnVoiceEventActive' has a wrong offset!");

// Class Hemingway.HWWaypoint
// 0x0080 (0x0318 - 0x0298)
class AHWWaypoint : public AActor
{
public:
	class FName                                   LaneId;                                            // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGenericTeamId                         TargetForTeamId;                                   // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWaypointPathDirectionType                    PathDirection;                                     // 0x02A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A2[0x2];                                      // 0x02A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GoalAcceptanceRadius;                              // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWWaypoint*                            Next;                                              // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWWaypoint*                            Prev;                                              // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHWWaypoint*>                    LinkedWaypoints;                                   // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class AHWWaypoint*, float>               ConnectionData;                                    // 0x02C8(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static float GetDistanceAlongRoute(class AHWWaypoint* TargetPathWaypoint, const struct FVector& QueryLocation, EWaypointPathDirectionType Direction);
	static struct FVector GetLocationAlongRoute(class AHWWaypoint* SamplePathWaypoint, float Distance, EWaypointPathDirectionType Direction);
	static float GetTotalRouteDistance(class AHWWaypoint* TargetPathWaypoint, EWaypointPathDirectionType Direction);
	static bool GetWaypointPathArray(TArray<class AHWWaypoint*>* OutResult, class AHWWaypoint* PathWaypoint, bool bReversed);
	static class AHWWaypoint* GetWaypointPathDirectionEndpoint(class AHWWaypoint* PathWaypoint, EWaypointPathDirectionType Direction);
	static class AHWWaypoint* GetWaypointPathEndpoint(class AHWWaypoint* PathWaypoint, bool bReversed);
	static bool IsPathWaypoint(class AHWWaypoint* Waypoint);
	static EWaypointPathDirectionType ReversePathDirection(EWaypointPathDirectionType Direction);

	void GetAllLinkedWaypoints(TArray<class AHWWaypoint*>* Waypoints) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWWaypoint">();
	}
	static class AHWWaypoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWWaypoint>();
	}
};
static_assert(alignof(AHWWaypoint) == 0x000008, "Wrong alignment on AHWWaypoint");
static_assert(sizeof(AHWWaypoint) == 0x000318, "Wrong size on AHWWaypoint");
static_assert(offsetof(AHWWaypoint, LaneId) == 0x000298, "Member 'AHWWaypoint::LaneId' has a wrong offset!");
static_assert(offsetof(AHWWaypoint, TargetForTeamId) == 0x0002A0, "Member 'AHWWaypoint::TargetForTeamId' has a wrong offset!");
static_assert(offsetof(AHWWaypoint, PathDirection) == 0x0002A1, "Member 'AHWWaypoint::PathDirection' has a wrong offset!");
static_assert(offsetof(AHWWaypoint, GoalAcceptanceRadius) == 0x0002A4, "Member 'AHWWaypoint::GoalAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(AHWWaypoint, Next) == 0x0002A8, "Member 'AHWWaypoint::Next' has a wrong offset!");
static_assert(offsetof(AHWWaypoint, Prev) == 0x0002B0, "Member 'AHWWaypoint::Prev' has a wrong offset!");
static_assert(offsetof(AHWWaypoint, LinkedWaypoints) == 0x0002B8, "Member 'AHWWaypoint::LinkedWaypoints' has a wrong offset!");
static_assert(offsetof(AHWWaypoint, ConnectionData) == 0x0002C8, "Member 'AHWWaypoint::ConnectionData' has a wrong offset!");

// Class Hemingway.HWWaypointSet
// 0x0068 (0x0300 - 0x0298)
class AHWWaypointSet : public AActor
{
public:
	TArray<class AHWWaypoint*>                    Waypoints;                                         // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FWaypointSetPath>    PresetPaths;                                       // 0x02A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	float                                         PathDirectionDegreesThreshold;                     // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CollectWaypoints();

	class AHWWaypoint* GetClosestWaypoint(const struct FVector& Location, TArray<class AHWWaypoint*>& WayPointsToAvoid) const;
	class AHWWaypoint* GetClosestWaypointInLane(class FName LaneId, const struct FVector& Location, TArray<class AHWWaypoint*>& WayPointsToAvoid) const;
	bool GetEndpointLanePathFromClosestPoint(class FName PathId, const struct FVector& Location, EWaypointPathDirectionType Direction, TArray<class AHWWaypoint*>& OutResults) const;
	class AHWWaypoint* GetNearGoalWaypointInLane(class FName LaneId, const struct FVector& Location, EWaypointPathDirectionType Direction, TArray<class AHWWaypoint*>& WayPointsToAvoid) const;
	bool GetPresetWaypointPath(class FName PathId, TArray<class AHWWaypoint*>& OutResults) const;
	bool GetTeamTargetPathInLane(const struct FGenericTeamId& TeamId, const struct FVector& Location, class FName PathId, TArray<class AHWWaypoint*>& OutResults) const;
	class AHWWaypoint* GetTeamTargetWaypoint(const struct FGenericTeamId& TeamId, const struct FVector& Location, bool bClosest) const;
	bool PickPathFromPresets(TArray<class AHWWaypoint*>& OutResults, const struct FVector& StartLocation, const struct FVector& EndLocation, TArray<class AHWWaypoint*>& WayPointsToAvoid) const;
	bool PickPathFromWaypoints(TArray<class AHWWaypoint*>& OutResults, const struct FVector& StartLocation, const struct FVector& EndLocation, TArray<class AHWWaypoint*>& WayPointsToAvoid) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWWaypointSet">();
	}
	static class AHWWaypointSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWWaypointSet>();
	}
};
static_assert(alignof(AHWWaypointSet) == 0x000008, "Wrong alignment on AHWWaypointSet");
static_assert(sizeof(AHWWaypointSet) == 0x000300, "Wrong size on AHWWaypointSet");
static_assert(offsetof(AHWWaypointSet, Waypoints) == 0x000298, "Member 'AHWWaypointSet::Waypoints' has a wrong offset!");
static_assert(offsetof(AHWWaypointSet, PresetPaths) == 0x0002A8, "Member 'AHWWaypointSet::PresetPaths' has a wrong offset!");
static_assert(offsetof(AHWWaypointSet, PathDirectionDegreesThreshold) == 0x0002F8, "Member 'AHWWaypointSet::PathDirectionDegreesThreshold' has a wrong offset!");

// Class Hemingway.HWAnimState_MontagePhase
// 0x0010 (0x0040 - 0x0030)
class UHWAnimState_MontagePhase : public UAnimNotifyState
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0030(0x0008)(Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSupressEndWindowEvent;                            // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimState_MontagePhase">();
	}
	static class UHWAnimState_MontagePhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimState_MontagePhase>();
	}
};
static_assert(alignof(UHWAnimState_MontagePhase) == 0x000008, "Wrong alignment on UHWAnimState_MontagePhase");
static_assert(sizeof(UHWAnimState_MontagePhase) == 0x000040, "Wrong size on UHWAnimState_MontagePhase");
static_assert(offsetof(UHWAnimState_MontagePhase, PhaseTag) == 0x000030, "Member 'UHWAnimState_MontagePhase::PhaseTag' has a wrong offset!");
static_assert(offsetof(UHWAnimState_MontagePhase, bSupressEndWindowEvent) == 0x000038, "Member 'UHWAnimState_MontagePhase::bSupressEndWindowEvent' has a wrong offset!");

// Class Hemingway.PerfCharacter
// 0x0058 (0x02F0 - 0x0298)
class APerfCharacter final : public AHirezAutomation_PerfHelper
{
public:
	uint8                                         Pad_298[0x58];                                     // 0x0298(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerfCharacter">();
	}
	static class APerfCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APerfCharacter>();
	}
};
static_assert(alignof(APerfCharacter) == 0x000008, "Wrong alignment on APerfCharacter");
static_assert(sizeof(APerfCharacter) == 0x0002F0, "Wrong size on APerfCharacter");

// Class Hemingway.HWAbilityTask_Attack_Dash
// 0x0030 (0x01B0 - 0x0180)
class UHWAbilityTask_Attack_Dash final : public UHWAbilityTask_FireAttack
{
public:
	class UHWAbilityCollisionProxy*               SpawnedCollisionProxy;                             // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWGameplayDash*                        ActiveDashInstance;                                // 0x0188(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityAttackSettings_Dash*          DashAttackSettings;                                // 0x0190(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayDash>            DashConfig;                                        // 0x0198(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationOverride;                                  // 0x01A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionEndFireDelay;                             // 0x01A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDashEnded(class UHWGameplayDash* Dash, const bool bWasInterrupted);
	void OnDashStarted(class UHWGameplayDash* Dash);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Attack_Dash">();
	}
	static class UHWAbilityTask_Attack_Dash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Attack_Dash>();
	}
};
static_assert(alignof(UHWAbilityTask_Attack_Dash) == 0x000008, "Wrong alignment on UHWAbilityTask_Attack_Dash");
static_assert(sizeof(UHWAbilityTask_Attack_Dash) == 0x0001B0, "Wrong size on UHWAbilityTask_Attack_Dash");
static_assert(offsetof(UHWAbilityTask_Attack_Dash, SpawnedCollisionProxy) == 0x000180, "Member 'UHWAbilityTask_Attack_Dash::SpawnedCollisionProxy' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_Dash, ActiveDashInstance) == 0x000188, "Member 'UHWAbilityTask_Attack_Dash::ActiveDashInstance' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_Dash, DashAttackSettings) == 0x000190, "Member 'UHWAbilityTask_Attack_Dash::DashAttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_Dash, DashConfig) == 0x000198, "Member 'UHWAbilityTask_Attack_Dash::DashConfig' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_Dash, DurationOverride) == 0x0001A0, "Member 'UHWAbilityTask_Attack_Dash::DurationOverride' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_Dash, CollisionEndFireDelay) == 0x0001A4, "Member 'UHWAbilityTask_Attack_Dash::CollisionEndFireDelay' has a wrong offset!");

// Class Hemingway.PerfVfx
// 0x0068 (0x0300 - 0x0298)
class APerfVfx final : public AHirezAutomation_PerfHelper
{
public:
	uint8                                         Pad_298[0x68];                                     // 0x0298(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerfVfx">();
	}
	static class APerfVfx* GetDefaultObj()
	{
		return GetDefaultObjImpl<APerfVfx>();
	}
};
static_assert(alignof(APerfVfx) == 0x000008, "Wrong alignment on APerfVfx");
static_assert(sizeof(APerfVfx) == 0x000300, "Wrong size on APerfVfx");

// Class Hemingway.HWGameInstanceServerBootstrapper
// 0x0000 (0x0B50 - 0x0B50)
class UHWGameInstanceServerBootstrapper final : public URH_GameInstanceServerBootstrapper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameInstanceServerBootstrapper">();
	}
	static class UHWGameInstanceServerBootstrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameInstanceServerBootstrapper>();
	}
};
static_assert(alignof(UHWGameInstanceServerBootstrapper) == 0x000008, "Wrong alignment on UHWGameInstanceServerBootstrapper");
static_assert(sizeof(UHWGameInstanceServerBootstrapper) == 0x000B50, "Wrong size on UHWGameInstanceServerBootstrapper");

// Class Hemingway.HWEquipmentComponent_Refireable
// 0x0060 (0x0098 - 0x0038)
class UHWEquipmentComponent_Refireable final : public UHWEquipmentComponent
{
public:
	struct FGameplayAbilitySpecHandle             RefireAbilityHandle;                               // 0x0038(0x0004)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWAbilityRefireInfo                   AbilityRefireInfo;                                 // 0x0040(0x0020)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWEquipmentComponent_Refireable* RefireComponent, const bool bIsRefireWindowActive, const float RefireWindowTime)> OnRefireStateChangedDelegate; // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHWRefireWindowInfo                    RefireWindowInfo;                                  // 0x0070(0x0018)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndRefireWindow();
	void OnRep_RefireWindowInfo(const struct FHWRefireWindowInfo& OldRefireWindowInfo);
	void RenewRefireWindow();
	void StartRefireWindow(const float RefireWindowTime, const struct FHWAbilityRefireInfo& RefireInfo, const bool bIsRestartingWindow);
	bool TriggerRefire(class UHWGameplayAbility* AbilityInstance);

	float GetElapsedRefireTime() const;
	float GetLastRefireTimeStamp() const;
	const struct FGameplayAbilitySpecHandle GetRefireAbilityHandle() const;
	ERefireAbilityBehavior GetRefireBehavior() const;
	float GetRefireDuration() const;
	bool IsRefireWindowActive() const;
	bool ShouldRefireOnTrigger(EHWRefireTrigger RefireTrigger) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponent_Refireable">();
	}
	static class UHWEquipmentComponent_Refireable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponent_Refireable>();
	}
};
static_assert(alignof(UHWEquipmentComponent_Refireable) == 0x000008, "Wrong alignment on UHWEquipmentComponent_Refireable");
static_assert(sizeof(UHWEquipmentComponent_Refireable) == 0x000098, "Wrong size on UHWEquipmentComponent_Refireable");
static_assert(offsetof(UHWEquipmentComponent_Refireable, RefireAbilityHandle) == 0x000038, "Member 'UHWEquipmentComponent_Refireable::RefireAbilityHandle' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Refireable, AbilityRefireInfo) == 0x000040, "Member 'UHWEquipmentComponent_Refireable::AbilityRefireInfo' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Refireable, OnRefireStateChangedDelegate) == 0x000060, "Member 'UHWEquipmentComponent_Refireable::OnRefireStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Refireable, RefireWindowInfo) == 0x000070, "Member 'UHWEquipmentComponent_Refireable::RefireWindowInfo' has a wrong offset!");

// Class Hemingway.HWAbilityAimSettings_Dummy
// 0x0000 (0x0068 - 0x0068)
class UHWAbilityAimSettings_Dummy final : public UHWAbilityAimSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSettings_Dummy">();
	}
	static class UHWAbilityAimSettings_Dummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSettings_Dummy>();
	}
};
static_assert(alignof(UHWAbilityAimSettings_Dummy) == 0x000008, "Wrong alignment on UHWAbilityAimSettings_Dummy");
static_assert(sizeof(UHWAbilityAimSettings_Dummy) == 0x000068, "Wrong size on UHWAbilityAimSettings_Dummy");

// Class Hemingway.HWAbilityAimSettings_GroundTarget
// 0x0018 (0x0080 - 0x0068)
class UHWAbilityAimSettings_GroundTarget : public UHWAbilityAimSettings
{
public:
	EHWGroundTargetValidationType                 GroundTargetValidationType;                        // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseClosestValidLocation;                          // 0x0069(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOriginAsStartTraceForClosestValidLocation;     // 0x006A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCharacterLastValidGroundLocAsLastResort;       // 0x006B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x006C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRange;                                          // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ManualCollisionRadius;                             // 0x0074(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLastValidGroundAimIfCurrentAimInvalid;         // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetManualCollisionRadius() const;
	float GetMaxRange() const;
	float GetMinRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSettings_GroundTarget">();
	}
	static class UHWAbilityAimSettings_GroundTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSettings_GroundTarget>();
	}
};
static_assert(alignof(UHWAbilityAimSettings_GroundTarget) == 0x000008, "Wrong alignment on UHWAbilityAimSettings_GroundTarget");
static_assert(sizeof(UHWAbilityAimSettings_GroundTarget) == 0x000080, "Wrong size on UHWAbilityAimSettings_GroundTarget");
static_assert(offsetof(UHWAbilityAimSettings_GroundTarget, GroundTargetValidationType) == 0x000068, "Member 'UHWAbilityAimSettings_GroundTarget::GroundTargetValidationType' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_GroundTarget, bUseClosestValidLocation) == 0x000069, "Member 'UHWAbilityAimSettings_GroundTarget::bUseClosestValidLocation' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_GroundTarget, bUseOriginAsStartTraceForClosestValidLocation) == 0x00006A, "Member 'UHWAbilityAimSettings_GroundTarget::bUseOriginAsStartTraceForClosestValidLocation' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_GroundTarget, bUseCharacterLastValidGroundLocAsLastResort) == 0x00006B, "Member 'UHWAbilityAimSettings_GroundTarget::bUseCharacterLastValidGroundLocAsLastResort' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_GroundTarget, MinRange) == 0x00006C, "Member 'UHWAbilityAimSettings_GroundTarget::MinRange' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_GroundTarget, MaxRange) == 0x000070, "Member 'UHWAbilityAimSettings_GroundTarget::MaxRange' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_GroundTarget, ManualCollisionRadius) == 0x000074, "Member 'UHWAbilityAimSettings_GroundTarget::ManualCollisionRadius' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSettings_GroundTarget, bUseLastValidGroundAimIfCurrentAimInvalid) == 0x000078, "Member 'UHWAbilityAimSettings_GroundTarget::bUseLastValidGroundAimIfCurrentAimInvalid' has a wrong offset!");

// Class Hemingway.HWBotFactory
// 0x05A0 (0x0838 - 0x0298)
class AHWBotFactory : public AActor
{
public:
	uint8                                         Pad_298[0x30];                                     // 0x0298(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AssetTags;                                         // 0x02C8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWBotFactory* BotFactory)> OnSpawnQueueStartedDel;          // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWBotFactory* BotFactory)> OnSpawnQueueEndedDel;            // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   AssociatedLane;                                    // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFactorySpawnQueueInfo                 SpawnQueue;                                        // 0x0310(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CurrentSpawnWaveTable;                             // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x1];                                      // 0x03B0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EFactorySpawnQueueRestartTriggerMethod        RestartTriggerMethod;                              // 0x03B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B2[0x2];                                      // 0x03B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialSpawnDelay;                                 // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpawningTeamNum;                                   // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxBotsActive;                                     // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumBotsActive;                                     // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCollisionHeightForSpawnPlacement;              // 0x03C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C5[0x1B];                                     // 0x03C5(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	EFactorySpawnPointSelectionMethod             SpawnPointSelectionMethod;                         // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          SpawnPoints;                                       // 0x03E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         CurrentSpawnPointIndex;                            // 0x03F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWCharacter_Base*>              BotsSpawned;                                       // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFactorySpawnedActorInfo               SpawnedActorInfo;                                  // 0x0410(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          OverrideLightingChannels;                          // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightingChannels                      SpawnedLightingChannels;                           // 0x0421(0x0001)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDebugDisableSpawning;                             // 0x0422(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_423[0x5];                                      // 0x0423(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWAISquadManager*                      CurrentSpawningSquadManager;                       // 0x0428(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFactorySpawnWaveTimeInfo              CurrentWaveSpawnTimeInfo;                          // 0x0430(0x0008)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWBotFactory* BotFactory, class AHWCharacter_Base* Bot)> OnSpawnedBotDel; // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWBotFactory* BotFactory, class AHWCharacter_Base* Bot, class AActor* Killer)> OnSpawnBotDiedDel; // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWBotFactory* BotFactory, class AActor* Causer)> OnFactoryEmptiedDel; // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWBotFactory* BotFactory, float RemainingRespawnTime)> OnFactoryWaveRespawnTimeUpdatedDel; // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWBotFactory* BotFactory, int32 NumBots)> OnFactoryNumBotsUpdatedDel; // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWBotFactory* BotFactory)> OnFactoryBotsSetDel;             // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWBotFactory* BotFactory)> OnFactoryMinimapStateChanged;    // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsSpawning;                                       // 0x04A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartSpawningImmediately;                         // 0x04A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AA[0x2];                                      // 0x04AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartingWaveIndex;                                 // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOneWaveMode;                                      // 0x04B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWBotFactory_VisibilityComponent*      VisibilityComponent;                               // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x4];                                      // 0x04C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeashOrDetectionRadius;                            // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFactoryRewardInfo>             Rewards;                                           // 0x04C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AActor>                  RewardSpawnPoint;                                  // 0x04D8(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnRewardAtTriggerActor;                        // 0x0500(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_501[0x17];                                     // 0x0501(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLevelingEnabled;                                  // 0x0518(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_519[0x3];                                      // 0x0519(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PhaseToActivateLeveling;                           // 0x051C(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanLevelActiveSpawnedBots;                        // 0x0524(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLevelingActive;                                   // 0x0525(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_526[0x2];                                      // 0x0526(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LevelUpInterval;                                   // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimerHandleLevelUp;                                // 0x0530(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LevelUpIncrement;                                  // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartingLevel;                                     // 0x053C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxLevel;                                          // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentLevel;                                      // 0x0544(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWDisplayInfoComponent*                DisplayInfoComponent;                              // 0x0548(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWDisplayInfoComponent>    DisplayInfoComponentClass;                         // 0x0550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysRequiresVisibilityToUpdateMinimap;          // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_559[0x7];                                      // 0x0559(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   GodBotPerceptionComponentClass;                    // 0x0560(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AActor>                  GodBotStart;                                       // 0x0588(0x0028)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GodBotIndex;                                       // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowGodBotRespawn;                               // 0x05B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B5[0x3];                                      // 0x05B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWAIGoal>                  GoalTreeClassOverride;                             // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class FName>        RoleToLaneMap;                                     // 0x05C0(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWAIController>         AssignedAIController;                              // 0x0610(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWPlayerState>          AssignedPlayerState;                               // 0x0618(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWCharacterItem*                       ChosenGodBotItem;                                  // 0x0620(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ChosenGodBotRole;                                  // 0x0628(0x0008)(Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ChosenGodBotLane;                                  // 0x0630(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  ChosenGodBotId;                                    // 0x0638(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  ChosenGodBotPersistentBotId;                       // 0x0648(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnGodBotAfterPreload;                          // 0x0658(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAIDifficultyConfig*                  AssignedDifficultyConfig;                          // 0x0660(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentDifficultyScaling;                          // 0x0668(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentDifficultScaleIndex;                        // 0x066C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableRecycling;                                 // 0x0670(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnAsNeeded;                                    // 0x0671(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldRecycleCharacterPawns;                      // 0x0672(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_673[0x5];                                      // 0x0673(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWRecycledPool                        RecycledPool;                                      // 0x0678(0x0168)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AHWAIController>, int32> MaxRecyclePoolSizeConfig;                        // 0x07E0(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxAbilitySystemActorPoolSize;                     // 0x0830(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_834[0x4];                                      // 0x0834(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateSpawning(const bool bKillExistingBots, bool bOverrideTimer, bool bSetLevelingActive);
	void AdvanceSpawnWaveNumber(int32 Increment);
	void DeactivateSpawning(const bool bKillExistingBots);
	void DespawnGodBot(bool bAllowRespawn);
	TSoftObjectPtr<class AActor> DetermineNextSpawnPoint();
	void DynamicallySelectGodBotCharacter();
	EFactoryMinimapState GetLocalTeamMinimapState();
	void InitializeSpawnedBotAI(class AHWCharacter_Base* characterSpawned, const struct FHWAIBotConfig& botConfig);
	void KillAllBots();
	void LevelUpBotFactory();
	void OnBotFinishedDestroy(class AHWCharacter_Base* DestroyedBot);
	void OnFactoryEmptied(class AActor* Causer);
	void OnGamePhaseStarted(const struct FGameplayTag& PhaseTag);
	void OnRep_BotsSpawned();
	void OnRep_ChosenGodBotItem();
	void OnRep_CurrentWaveSpawnTimeInfo();
	void OnRep_NumBotsActive();
	void OnSpawnBotDied(class AHWCharacter_Base* characterKilled, class AActor* Killer);
	void OnSpawnedBot(class AHWCharacter_Base* characterSpawned);
	void OnVisibilityCompMinimapStateChanged(class UHWBotFactory_VisibilityComponent* Comp);
	void ResolveBotOutOfCombatLogic(class AHWCharacter_Base* Bot);
	void RespawnGodBot();
	void SetAllowGodBotRespawn(bool bAllow);
	void SetCurrentSpawnTable(const struct FGameplayTag& SpawnTableTag, const bool bSwapAfterCurrentWaveEnds);
	void SetGodBotStart(class AActor* BotStart);
	void SetLevelingActive(bool bActive);
	void SetSpawnWaveindex(int32 newWaveIndex);
	class AHWCharacter_Base* SpawnBot(const struct FFactoryBotEntry& BotEntryToSpawn, const struct FFactorySpawnEntry& BotSpawnEntry, bool bIsRespawn);
	void SpawnGodBot(bool bIsRespawn);
	void SpawnGodBotSpecific(const class UHWCharacterItem* Item);
	void ToggleOneWaveMode(bool bOn);
	void TriggerFactoryRewards(const EFactoryRewardTrigger ETriggerType, class AActor* Killer);
	void UpdateDynamicDifficulty();

	bool AreAnyBotsAlive() const;
	struct FGameplayTagContainer GetAssetTags() const;
	TSoftObjectPtr<class AActor> GetCurrentSpawnPoint() const;
	int32 GetCurrentSpawnWaveIndex() const;
	class AHWWaypoint* GetIdentifyingWaypoint() const;
	float GetLeashOrDetectionRadius() const;
	bool GetLocalTeamCanSeeRespawnTimer() const;
	int32 GetNumBotsPastPastDistanceInLane(const float LaneDistancePercentage) const;
	int32 GetNumOfSpawnWaves() const;
	EWaypointPathDirectionType GetPathDirection() const;
	float GetRemainingWaveRespawnTime() const;
	int32 GetSpawningTeamNum() const;
	float GetWaveRespawnTime() const;
	bool HasActiveBots() const;
	bool IsActivelySpawning() const;
	bool IsAGodBotFactory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBotFactory">();
	}
	static class AHWBotFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWBotFactory>();
	}
};
static_assert(alignof(AHWBotFactory) == 0x000008, "Wrong alignment on AHWBotFactory");
static_assert(sizeof(AHWBotFactory) == 0x000838, "Wrong size on AHWBotFactory");
static_assert(offsetof(AHWBotFactory, AssetTags) == 0x0002C8, "Member 'AHWBotFactory::AssetTags' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, OnSpawnQueueStartedDel) == 0x0002E8, "Member 'AHWBotFactory::OnSpawnQueueStartedDel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, OnSpawnQueueEndedDel) == 0x0002F8, "Member 'AHWBotFactory::OnSpawnQueueEndedDel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, AssociatedLane) == 0x000308, "Member 'AHWBotFactory::AssociatedLane' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, SpawnQueue) == 0x000310, "Member 'AHWBotFactory::SpawnQueue' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, CurrentSpawnWaveTable) == 0x0003A8, "Member 'AHWBotFactory::CurrentSpawnWaveTable' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, RestartTriggerMethod) == 0x0003B1, "Member 'AHWBotFactory::RestartTriggerMethod' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, InitialSpawnDelay) == 0x0003B4, "Member 'AHWBotFactory::InitialSpawnDelay' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, SpawningTeamNum) == 0x0003B8, "Member 'AHWBotFactory::SpawningTeamNum' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, MaxBotsActive) == 0x0003BC, "Member 'AHWBotFactory::MaxBotsActive' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, NumBotsActive) == 0x0003C0, "Member 'AHWBotFactory::NumBotsActive' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bUseCollisionHeightForSpawnPlacement) == 0x0003C4, "Member 'AHWBotFactory::bUseCollisionHeightForSpawnPlacement' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, SpawnPointSelectionMethod) == 0x0003E0, "Member 'AHWBotFactory::SpawnPointSelectionMethod' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, SpawnPoints) == 0x0003E8, "Member 'AHWBotFactory::SpawnPoints' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, CurrentSpawnPointIndex) == 0x0003F8, "Member 'AHWBotFactory::CurrentSpawnPointIndex' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, BotsSpawned) == 0x000400, "Member 'AHWBotFactory::BotsSpawned' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, SpawnedActorInfo) == 0x000410, "Member 'AHWBotFactory::SpawnedActorInfo' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, OverrideLightingChannels) == 0x000420, "Member 'AHWBotFactory::OverrideLightingChannels' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, SpawnedLightingChannels) == 0x000421, "Member 'AHWBotFactory::SpawnedLightingChannels' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bDebugDisableSpawning) == 0x000422, "Member 'AHWBotFactory::bDebugDisableSpawning' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, CurrentSpawningSquadManager) == 0x000428, "Member 'AHWBotFactory::CurrentSpawningSquadManager' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, CurrentWaveSpawnTimeInfo) == 0x000430, "Member 'AHWBotFactory::CurrentWaveSpawnTimeInfo' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, OnSpawnedBotDel) == 0x000438, "Member 'AHWBotFactory::OnSpawnedBotDel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, OnSpawnBotDiedDel) == 0x000448, "Member 'AHWBotFactory::OnSpawnBotDiedDel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, OnFactoryEmptiedDel) == 0x000458, "Member 'AHWBotFactory::OnFactoryEmptiedDel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, OnFactoryWaveRespawnTimeUpdatedDel) == 0x000468, "Member 'AHWBotFactory::OnFactoryWaveRespawnTimeUpdatedDel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, OnFactoryNumBotsUpdatedDel) == 0x000478, "Member 'AHWBotFactory::OnFactoryNumBotsUpdatedDel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, OnFactoryBotsSetDel) == 0x000488, "Member 'AHWBotFactory::OnFactoryBotsSetDel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, OnFactoryMinimapStateChanged) == 0x000498, "Member 'AHWBotFactory::OnFactoryMinimapStateChanged' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bIsSpawning) == 0x0004A8, "Member 'AHWBotFactory::bIsSpawning' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bStartSpawningImmediately) == 0x0004A9, "Member 'AHWBotFactory::bStartSpawningImmediately' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, StartingWaveIndex) == 0x0004AC, "Member 'AHWBotFactory::StartingWaveIndex' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bOneWaveMode) == 0x0004B0, "Member 'AHWBotFactory::bOneWaveMode' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, VisibilityComponent) == 0x0004B8, "Member 'AHWBotFactory::VisibilityComponent' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, LeashOrDetectionRadius) == 0x0004C4, "Member 'AHWBotFactory::LeashOrDetectionRadius' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, Rewards) == 0x0004C8, "Member 'AHWBotFactory::Rewards' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, RewardSpawnPoint) == 0x0004D8, "Member 'AHWBotFactory::RewardSpawnPoint' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bSpawnRewardAtTriggerActor) == 0x000500, "Member 'AHWBotFactory::bSpawnRewardAtTriggerActor' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bLevelingEnabled) == 0x000518, "Member 'AHWBotFactory::bLevelingEnabled' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, PhaseToActivateLeveling) == 0x00051C, "Member 'AHWBotFactory::PhaseToActivateLeveling' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bCanLevelActiveSpawnedBots) == 0x000524, "Member 'AHWBotFactory::bCanLevelActiveSpawnedBots' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bLevelingActive) == 0x000525, "Member 'AHWBotFactory::bLevelingActive' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, LevelUpInterval) == 0x000528, "Member 'AHWBotFactory::LevelUpInterval' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, TimerHandleLevelUp) == 0x000530, "Member 'AHWBotFactory::TimerHandleLevelUp' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, LevelUpIncrement) == 0x000538, "Member 'AHWBotFactory::LevelUpIncrement' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, StartingLevel) == 0x00053C, "Member 'AHWBotFactory::StartingLevel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, MaxLevel) == 0x000540, "Member 'AHWBotFactory::MaxLevel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, CurrentLevel) == 0x000544, "Member 'AHWBotFactory::CurrentLevel' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, DisplayInfoComponent) == 0x000548, "Member 'AHWBotFactory::DisplayInfoComponent' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, DisplayInfoComponentClass) == 0x000550, "Member 'AHWBotFactory::DisplayInfoComponentClass' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bAlwaysRequiresVisibilityToUpdateMinimap) == 0x000558, "Member 'AHWBotFactory::bAlwaysRequiresVisibilityToUpdateMinimap' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, GodBotPerceptionComponentClass) == 0x000560, "Member 'AHWBotFactory::GodBotPerceptionComponentClass' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, GodBotStart) == 0x000588, "Member 'AHWBotFactory::GodBotStart' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, GodBotIndex) == 0x0005B0, "Member 'AHWBotFactory::GodBotIndex' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bAllowGodBotRespawn) == 0x0005B4, "Member 'AHWBotFactory::bAllowGodBotRespawn' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, GoalTreeClassOverride) == 0x0005B8, "Member 'AHWBotFactory::GoalTreeClassOverride' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, RoleToLaneMap) == 0x0005C0, "Member 'AHWBotFactory::RoleToLaneMap' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, AssignedAIController) == 0x000610, "Member 'AHWBotFactory::AssignedAIController' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, AssignedPlayerState) == 0x000618, "Member 'AHWBotFactory::AssignedPlayerState' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, ChosenGodBotItem) == 0x000620, "Member 'AHWBotFactory::ChosenGodBotItem' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, ChosenGodBotRole) == 0x000628, "Member 'AHWBotFactory::ChosenGodBotRole' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, ChosenGodBotLane) == 0x000630, "Member 'AHWBotFactory::ChosenGodBotLane' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, ChosenGodBotId) == 0x000638, "Member 'AHWBotFactory::ChosenGodBotId' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, ChosenGodBotPersistentBotId) == 0x000648, "Member 'AHWBotFactory::ChosenGodBotPersistentBotId' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bSpawnGodBotAfterPreload) == 0x000658, "Member 'AHWBotFactory::bSpawnGodBotAfterPreload' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, AssignedDifficultyConfig) == 0x000660, "Member 'AHWBotFactory::AssignedDifficultyConfig' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, CurrentDifficultyScaling) == 0x000668, "Member 'AHWBotFactory::CurrentDifficultyScaling' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, CurrentDifficultScaleIndex) == 0x00066C, "Member 'AHWBotFactory::CurrentDifficultScaleIndex' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bDisableRecycling) == 0x000670, "Member 'AHWBotFactory::bDisableRecycling' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bSpawnAsNeeded) == 0x000671, "Member 'AHWBotFactory::bSpawnAsNeeded' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, bShouldRecycleCharacterPawns) == 0x000672, "Member 'AHWBotFactory::bShouldRecycleCharacterPawns' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, RecycledPool) == 0x000678, "Member 'AHWBotFactory::RecycledPool' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, MaxRecyclePoolSizeConfig) == 0x0007E0, "Member 'AHWBotFactory::MaxRecyclePoolSizeConfig' has a wrong offset!");
static_assert(offsetof(AHWBotFactory, MaxAbilitySystemActorPoolSize) == 0x000830, "Member 'AHWBotFactory::MaxAbilitySystemActorPoolSize' has a wrong offset!");

// Class Hemingway.HWAbilityAimSetting_AimTowardsGroundTarget
// 0x0008 (0x0088 - 0x0080)
class UHWAbilityAimSetting_AimTowardsGroundTarget final : public UHWAbilityAimSettings_GroundTarget
{
public:
	class UHWAbilityAimSettings*                  AimSettings;                                       // 0x0080(0x0008)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSetting_AimTowardsGroundTarget">();
	}
	static class UHWAbilityAimSetting_AimTowardsGroundTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSetting_AimTowardsGroundTarget>();
	}
};
static_assert(alignof(UHWAbilityAimSetting_AimTowardsGroundTarget) == 0x000008, "Wrong alignment on UHWAbilityAimSetting_AimTowardsGroundTarget");
static_assert(sizeof(UHWAbilityAimSetting_AimTowardsGroundTarget) == 0x000088, "Wrong size on UHWAbilityAimSetting_AimTowardsGroundTarget");
static_assert(offsetof(UHWAbilityAimSetting_AimTowardsGroundTarget, AimSettings) == 0x000080, "Member 'UHWAbilityAimSetting_AimTowardsGroundTarget::AimSettings' has a wrong offset!");

// Class Hemingway.HWEquipmentItem
// 0x0128 (0x02D8 - 0x01B0)
class UHWEquipmentItem final : public UHWInventoryItem
{
public:
	class FName                                   DevName;                                           // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x01B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x01D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ShortDescription;                                  // 0x01E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SortingTags;                                       // 0x0200(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PrimaryStatTag;                                    // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0228(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWEquipmentInfo>        EquipmentInfo;                                     // 0x0250(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EquipmentType;                                     // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EquipmentTypeSlotCompatibilityTags;                // 0x0280(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class UHWEquipmentItem_TooltipDataBase*       TooltipData;                                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TransactionRules;                                  // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AnnounceAcquisitionTag;                            // 0x02AC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestrictAmountAllowedEquipped;                    // 0x02B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAllowedEquipped;                                // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictAmountAllowedInInventory;                 // 0x02BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD[0x3];                                      // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAllowedInInventory;                             // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeAutoConsumeIfInventoryFull;                  // 0x02C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisableAutoBuyWhenPurchasedOrSold;          // 0x02C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6[0x2];                                      // 0x02C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UHWEquipmentRecipe>> CraftingRecipes;                                // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	const struct FGameplayTag GetAnnounceAcquisitionTag() const;
	int32 GetBaseCurrencyValue() const;
	bool ShouldCommitTransaction(const EItemTransactionRule ItemTransactionRule) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentItem">();
	}
	static class UHWEquipmentItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentItem>();
	}
};
static_assert(alignof(UHWEquipmentItem) == 0x000008, "Wrong alignment on UHWEquipmentItem");
static_assert(sizeof(UHWEquipmentItem) == 0x0002D8, "Wrong size on UHWEquipmentItem");
static_assert(offsetof(UHWEquipmentItem, DevName) == 0x0001B0, "Member 'UHWEquipmentItem::DevName' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, DisplayName) == 0x0001B8, "Member 'UHWEquipmentItem::DisplayName' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, Description) == 0x0001D0, "Member 'UHWEquipmentItem::Description' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, ShortDescription) == 0x0001E8, "Member 'UHWEquipmentItem::ShortDescription' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, SortingTags) == 0x000200, "Member 'UHWEquipmentItem::SortingTags' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, PrimaryStatTag) == 0x000220, "Member 'UHWEquipmentItem::PrimaryStatTag' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, Icon) == 0x000228, "Member 'UHWEquipmentItem::Icon' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, EquipmentInfo) == 0x000250, "Member 'UHWEquipmentItem::EquipmentInfo' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, EquipmentType) == 0x000278, "Member 'UHWEquipmentItem::EquipmentType' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, EquipmentTypeSlotCompatibilityTags) == 0x000280, "Member 'UHWEquipmentItem::EquipmentTypeSlotCompatibilityTags' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, TooltipData) == 0x0002A0, "Member 'UHWEquipmentItem::TooltipData' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, TransactionRules) == 0x0002A8, "Member 'UHWEquipmentItem::TransactionRules' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, AnnounceAcquisitionTag) == 0x0002AC, "Member 'UHWEquipmentItem::AnnounceAcquisitionTag' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, bRestrictAmountAllowedEquipped) == 0x0002B4, "Member 'UHWEquipmentItem::bRestrictAmountAllowedEquipped' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, MaxAllowedEquipped) == 0x0002B8, "Member 'UHWEquipmentItem::MaxAllowedEquipped' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, bRestrictAmountAllowedInInventory) == 0x0002BC, "Member 'UHWEquipmentItem::bRestrictAmountAllowedInInventory' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, MaxAllowedInInventory) == 0x0002C0, "Member 'UHWEquipmentItem::MaxAllowedInInventory' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, bCanBeAutoConsumeIfInventoryFull) == 0x0002C4, "Member 'UHWEquipmentItem::bCanBeAutoConsumeIfInventoryFull' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, bShouldDisableAutoBuyWhenPurchasedOrSold) == 0x0002C5, "Member 'UHWEquipmentItem::bShouldDisableAutoBuyWhenPurchasedOrSold' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem, CraftingRecipes) == 0x0002C8, "Member 'UHWEquipmentItem::CraftingRecipes' has a wrong offset!");

// Class Hemingway.HWAbilityAimSetting_Custom
// 0x0058 (0x00C0 - 0x0068)
class UHWAbilityAimSetting_Custom final : public UHWAbilityAimSettings
{
public:
	TMap<struct FGameplayTag, class UHWAbilityAimSettings*> CustomAimSettings;                       // 0x0068(0x0050)(Edit, ExportObject, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         MaxAimDataNeeded;                                  // 0x00B8(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_CalcAim(const struct FHWAimTargetingInfo& AimTargetingInfo, struct FGameplayAbilityTargetDataHandle& TargetingAimHandle) const;
	struct FRotator BP_GetAimDirectionOffset(const struct FRotator& OriginalOffset) const;
	struct FVector BP_GetPositionOffset(const struct FVector& OriginalOffset) const;
	const class UHWAbilityAimSettings* GetCustomAimSetting(const struct FGameplayTag& AimSettingId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSetting_Custom">();
	}
	static class UHWAbilityAimSetting_Custom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSetting_Custom>();
	}
};
static_assert(alignof(UHWAbilityAimSetting_Custom) == 0x000008, "Wrong alignment on UHWAbilityAimSetting_Custom");
static_assert(sizeof(UHWAbilityAimSetting_Custom) == 0x0000C0, "Wrong size on UHWAbilityAimSetting_Custom");
static_assert(offsetof(UHWAbilityAimSetting_Custom, CustomAimSettings) == 0x000068, "Member 'UHWAbilityAimSetting_Custom::CustomAimSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSetting_Custom, MaxAimDataNeeded) == 0x0000B8, "Member 'UHWAbilityAimSetting_Custom::MaxAimDataNeeded' has a wrong offset!");

// Class Hemingway.HWAbilityTask_SpawnDeployable
// 0x00E0 (0x0160 - 0x0080)
class alignas(0x10) UHWAbilityTask_SpawnDeployable final : public UAbilityTask
{
public:
	class UHWAbilityAttackSettings_Deployable*    DeployableAttackSettings;                          // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0xB8];                                      // 0x0088(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWDeployable* SpawnedDeployable)> OnBeginSpawningDel;       // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWDeployable* SpawnedDeployable)> OnSpawnedDel;             // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UHWAbilityTask_SpawnDeployable* SpawnDeployableTask(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class AHWDeployable> DeployableClass, const struct FTransform& SpawnTransform, bool bAdjustToGround);
	static class UHWAbilityTask_SpawnDeployable* SpawnDeployableTaskUsingAimData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class AHWDeployable> DeployableClass, const struct FGameplayAbilityTargetDataHandle& TargetAimData, bool bAdjustToGround, const bool bUseAimOriginForSpawn, const struct FVector& SpawnLocationOffset, const bool bSimulateImmediateTickOnPhaseTimers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_SpawnDeployable">();
	}
	static class UHWAbilityTask_SpawnDeployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_SpawnDeployable>();
	}
};
static_assert(alignof(UHWAbilityTask_SpawnDeployable) == 0x000010, "Wrong alignment on UHWAbilityTask_SpawnDeployable");
static_assert(sizeof(UHWAbilityTask_SpawnDeployable) == 0x000160, "Wrong size on UHWAbilityTask_SpawnDeployable");
static_assert(offsetof(UHWAbilityTask_SpawnDeployable, DeployableAttackSettings) == 0x000080, "Member 'UHWAbilityTask_SpawnDeployable::DeployableAttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnDeployable, OnBeginSpawningDel) == 0x000140, "Member 'UHWAbilityTask_SpawnDeployable::OnBeginSpawningDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnDeployable, OnSpawnedDel) == 0x000150, "Member 'UHWAbilityTask_SpawnDeployable::OnSpawnedDel' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSetings_CloneCharacterSwap
// 0x0078 (0x02C8 - 0x0250)
class UHWAbilityAttackSetings_CloneCharacterSwap final : public UHWAbilityAttackSettings
{
public:
	class UHWFamiliarConfigSettings*              FamiliarConfig;                                    // 0x0250(0x0008)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EffectTypesToCloneFromTarget;                      // 0x0258(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EffectTypesToCloneToAndFromOwner;                  // 0x0278(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EffectTypesToRemovePostFamiliarInitialized;        // 0x0298(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultCharacterForSwap;                       // 0x02B8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            TimerEffectClass;                                  // 0x02C0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSetings_CloneCharacterSwap">();
	}
	static class UHWAbilityAttackSetings_CloneCharacterSwap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSetings_CloneCharacterSwap>();
	}
};
static_assert(alignof(UHWAbilityAttackSetings_CloneCharacterSwap) == 0x000008, "Wrong alignment on UHWAbilityAttackSetings_CloneCharacterSwap");
static_assert(sizeof(UHWAbilityAttackSetings_CloneCharacterSwap) == 0x0002C8, "Wrong size on UHWAbilityAttackSetings_CloneCharacterSwap");
static_assert(offsetof(UHWAbilityAttackSetings_CloneCharacterSwap, FamiliarConfig) == 0x000250, "Member 'UHWAbilityAttackSetings_CloneCharacterSwap::FamiliarConfig' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSetings_CloneCharacterSwap, EffectTypesToCloneFromTarget) == 0x000258, "Member 'UHWAbilityAttackSetings_CloneCharacterSwap::EffectTypesToCloneFromTarget' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSetings_CloneCharacterSwap, EffectTypesToCloneToAndFromOwner) == 0x000278, "Member 'UHWAbilityAttackSetings_CloneCharacterSwap::EffectTypesToCloneToAndFromOwner' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSetings_CloneCharacterSwap, EffectTypesToRemovePostFamiliarInitialized) == 0x000298, "Member 'UHWAbilityAttackSetings_CloneCharacterSwap::EffectTypesToRemovePostFamiliarInitialized' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSetings_CloneCharacterSwap, bUseDefaultCharacterForSwap) == 0x0002B8, "Member 'UHWAbilityAttackSetings_CloneCharacterSwap::bUseDefaultCharacterForSwap' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSetings_CloneCharacterSwap, TimerEffectClass) == 0x0002C0, "Member 'UHWAbilityAttackSetings_CloneCharacterSwap::TimerEffectClass' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_Dash
// 0x0010 (0x0480 - 0x0470)
class UHWAbilityAttackSettings_Dash final : public UHWAbilityAttackSettings_Collision
{
public:
	TSubclassOf<class UHWGameplayDash>            DashConfigurationClass;                            // 0x0468(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EndOfDashAttackId;                                 // 0x0470(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Dash">();
	}
	static class UHWAbilityAttackSettings_Dash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Dash>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Dash) == 0x000010, "Wrong alignment on UHWAbilityAttackSettings_Dash");
static_assert(sizeof(UHWAbilityAttackSettings_Dash) == 0x000480, "Wrong size on UHWAbilityAttackSettings_Dash");
static_assert(offsetof(UHWAbilityAttackSettings_Dash, DashConfigurationClass) == 0x000468, "Member 'UHWAbilityAttackSettings_Dash::DashConfigurationClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Dash, EndOfDashAttackId) == 0x000470, "Member 'UHWAbilityAttackSettings_Dash::EndOfDashAttackId' has a wrong offset!");

// Class Hemingway.HWEquipmentItem_AbilityTooltipData
// 0x0050 (0x0078 - 0x0028)
class UHWEquipmentItem_AbilityTooltipData final : public UHWEquipmentItem_TooltipDataBase
{
public:
	TArray<struct FHWEquipmentItem_AbilityTooltip_Description> DescriptionLines;                     // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHWEquipmentItem_AbilityTooltip_Detail> DetailLines;                               // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHWEquipmentItem_TooltipNamedValue> NamedValues;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHWEquipmentItem_TooltipNamedFormula> NamedFormulas;                               // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHWEquipmentItem_TooltipNamedValueScaling> NamedValueScalings;                     // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)

public:
	TArray<class FString> GetNamedValueOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentItem_AbilityTooltipData">();
	}
	static class UHWEquipmentItem_AbilityTooltipData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentItem_AbilityTooltipData>();
	}
};
static_assert(alignof(UHWEquipmentItem_AbilityTooltipData) == 0x000008, "Wrong alignment on UHWEquipmentItem_AbilityTooltipData");
static_assert(sizeof(UHWEquipmentItem_AbilityTooltipData) == 0x000078, "Wrong size on UHWEquipmentItem_AbilityTooltipData");
static_assert(offsetof(UHWEquipmentItem_AbilityTooltipData, DescriptionLines) == 0x000028, "Member 'UHWEquipmentItem_AbilityTooltipData::DescriptionLines' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem_AbilityTooltipData, DetailLines) == 0x000038, "Member 'UHWEquipmentItem_AbilityTooltipData::DetailLines' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem_AbilityTooltipData, NamedValues) == 0x000048, "Member 'UHWEquipmentItem_AbilityTooltipData::NamedValues' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem_AbilityTooltipData, NamedFormulas) == 0x000058, "Member 'UHWEquipmentItem_AbilityTooltipData::NamedFormulas' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItem_AbilityTooltipData, NamedValueScalings) == 0x000068, "Member 'UHWEquipmentItem_AbilityTooltipData::NamedValueScalings' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_Deployable
// 0x0030 (0x0280 - 0x0250)
class UHWAbilityAttackSettings_Deployable : public UHWAbilityAttackSettings
{
public:
	TSubclassOf<class AHWDeployable>              DeployableClass;                                   // 0x0250(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSpawnAtAimOrigin;                           // 0x0258(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWDeployableAttackSettingUseAimOriginForHighlighting UseAimOriginForHighlighting;               // 0x0259(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A[0x6];                                      // 0x025A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnPositionOffset;                               // 0x0260(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustToGround;                                   // 0x0278(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateImmediateTickOnPhaseTimers;               // 0x0279(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Deployable">();
	}
	static class UHWAbilityAttackSettings_Deployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Deployable>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Deployable) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_Deployable");
static_assert(sizeof(UHWAbilityAttackSettings_Deployable) == 0x000280, "Wrong size on UHWAbilityAttackSettings_Deployable");
static_assert(offsetof(UHWAbilityAttackSettings_Deployable, DeployableClass) == 0x000250, "Member 'UHWAbilityAttackSettings_Deployable::DeployableClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Deployable, bShouldSpawnAtAimOrigin) == 0x000258, "Member 'UHWAbilityAttackSettings_Deployable::bShouldSpawnAtAimOrigin' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Deployable, UseAimOriginForHighlighting) == 0x000259, "Member 'UHWAbilityAttackSettings_Deployable::UseAimOriginForHighlighting' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Deployable, SpawnPositionOffset) == 0x000260, "Member 'UHWAbilityAttackSettings_Deployable::SpawnPositionOffset' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Deployable, bAdjustToGround) == 0x000278, "Member 'UHWAbilityAttackSettings_Deployable::bAdjustToGround' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Deployable, bSimulateImmediateTickOnPhaseTimers) == 0x000279, "Member 'UHWAbilityAttackSettings_Deployable::bSimulateImmediateTickOnPhaseTimers' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_InstantShape
// 0x0028 (0x0278 - 0x0250)
class UHWAbilityAttackSettings_InstantShape : public UHWAbilityAttackSettings
{
public:
	int32                                         MaxTargetsAllowed;                                 // 0x0250(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetingLocationPriorityBehavior            LocationPriorityBehavior;                          // 0x0254(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationPriorityRadiusThreshold;                   // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWGameplayTargetDataFilter>    PriorityFilters;                                   // 0x0260(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EHWTargetingSearchType                        TargetingSearchType;                               // 0x0270(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FGameplayTargetDataFilterHandle> GetPriorityFilters(class AActor* Avatar) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_InstantShape">();
	}
	static class UHWAbilityAttackSettings_InstantShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_InstantShape>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_InstantShape) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_InstantShape");
static_assert(sizeof(UHWAbilityAttackSettings_InstantShape) == 0x000278, "Wrong size on UHWAbilityAttackSettings_InstantShape");
static_assert(offsetof(UHWAbilityAttackSettings_InstantShape, MaxTargetsAllowed) == 0x000250, "Member 'UHWAbilityAttackSettings_InstantShape::MaxTargetsAllowed' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_InstantShape, LocationPriorityBehavior) == 0x000254, "Member 'UHWAbilityAttackSettings_InstantShape::LocationPriorityBehavior' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_InstantShape, LocationPriorityRadiusThreshold) == 0x000258, "Member 'UHWAbilityAttackSettings_InstantShape::LocationPriorityRadiusThreshold' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_InstantShape, PriorityFilters) == 0x000260, "Member 'UHWAbilityAttackSettings_InstantShape::PriorityFilters' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_InstantShape, TargetingSearchType) == 0x000270, "Member 'UHWAbilityAttackSettings_InstantShape::TargetingSearchType' has a wrong offset!");

// Class Hemingway.HWAnimState_BlockActions
// 0x0028 (0x0068 - 0x0040)
class UHWAnimState_BlockActions final : public UHWAnimState_MontagePhase
{
public:
	uint8                                         ActivePresetsFlags;                                // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CustomBlockedAbilityTypes;                         // 0x0048(0x0020)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimState_BlockActions">();
	}
	static class UHWAnimState_BlockActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimState_BlockActions>();
	}
};
static_assert(alignof(UHWAnimState_BlockActions) == 0x000008, "Wrong alignment on UHWAnimState_BlockActions");
static_assert(sizeof(UHWAnimState_BlockActions) == 0x000068, "Wrong size on UHWAnimState_BlockActions");
static_assert(offsetof(UHWAnimState_BlockActions, ActivePresetsFlags) == 0x000040, "Member 'UHWAnimState_BlockActions::ActivePresetsFlags' has a wrong offset!");
static_assert(offsetof(UHWAnimState_BlockActions, CustomBlockedAbilityTypes) == 0x000048, "Member 'UHWAnimState_BlockActions::CustomBlockedAbilityTypes' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_Interact
// 0x0000 (0x0250 - 0x0250)
class UHWAbilityAttackSettings_Interact final : public UHWAbilityAttackSettings_Custom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Interact">();
	}
	static class UHWAbilityAttackSettings_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Interact>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Interact) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_Interact");
static_assert(sizeof(UHWAbilityAttackSettings_Interact) == 0x000250, "Wrong size on UHWAbilityAttackSettings_Interact");

// Class Hemingway.HWAbilityAttackSettings_Projectile
// 0x05A0 (0x07F0 - 0x0250)
class UHWAbilityAttackSettings_Projectile final : public UHWAbilityAttackSettings
{
public:
	TSubclassOf<class AHWProjectile>              ProjectileClass;                                   // 0x0250(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyProjectileOnTarget;                        // 0x0258(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnFromOwnerLocation;                           // 0x0259(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A[0x6];                                      // 0x025A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OwnerSpawnLocationOffset;                          // 0x0260(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSeparateTargetFilterForAllies;                 // 0x0278(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWGameplayTargetDataFilter            DestroyProjectileOnTargetFilter;                   // 0x0280(0x01D0)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FHWGameplayTargetDataFilter            DestroyProjectileOnAllyTargetFilter;               // 0x0450(0x01D0)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FHWGameplayTargetDataFilter            AllyAccepetableTargetFilter;                       // 0x0620(0x01D0)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	struct FGameplayTargetDataFilterHandle GetAllyAcceptableTargetFilter(class AActor* Avatar, const bool bIsPredicting) const;
	struct FGameplayTargetDataFilterHandle GetDestroyProjectileOnAllyTargetFilter(class AActor* Avatar, const bool bIsPredicting) const;
	struct FGameplayTargetDataFilterHandle GetDestroyProjectileOnTargetFilter(class AActor* Avatar, const bool bIsPredicting) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Projectile">();
	}
	static class UHWAbilityAttackSettings_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Projectile>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Projectile) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_Projectile");
static_assert(sizeof(UHWAbilityAttackSettings_Projectile) == 0x0007F0, "Wrong size on UHWAbilityAttackSettings_Projectile");
static_assert(offsetof(UHWAbilityAttackSettings_Projectile, ProjectileClass) == 0x000250, "Member 'UHWAbilityAttackSettings_Projectile::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Projectile, bDestroyProjectileOnTarget) == 0x000258, "Member 'UHWAbilityAttackSettings_Projectile::bDestroyProjectileOnTarget' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Projectile, bSpawnFromOwnerLocation) == 0x000259, "Member 'UHWAbilityAttackSettings_Projectile::bSpawnFromOwnerLocation' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Projectile, OwnerSpawnLocationOffset) == 0x000260, "Member 'UHWAbilityAttackSettings_Projectile::OwnerSpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Projectile, bUseSeparateTargetFilterForAllies) == 0x000278, "Member 'UHWAbilityAttackSettings_Projectile::bUseSeparateTargetFilterForAllies' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Projectile, DestroyProjectileOnTargetFilter) == 0x000280, "Member 'UHWAbilityAttackSettings_Projectile::DestroyProjectileOnTargetFilter' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Projectile, DestroyProjectileOnAllyTargetFilter) == 0x000450, "Member 'UHWAbilityAttackSettings_Projectile::DestroyProjectileOnAllyTargetFilter' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Projectile, AllyAccepetableTargetFilter) == 0x000620, "Member 'UHWAbilityAttackSettings_Projectile::AllyAccepetableTargetFilter' has a wrong offset!");

// Class Hemingway.HWLibrary_EventSystem
// 0x0000 (0x0028 - 0x0028)
class UHWLibrary_EventSystem final : public UBlueprintFunctionLibrary
{
public:
	static bool EqualEqual_FHWEventCharacter(const struct FHWEventCharacter& A, const struct FHWEventCharacter& B);
	static void GetCharacterItemFromEventCharacterData(const class UObject* WorldContextObject, const struct FHWEventCharacter& EventCharacter, const TDelegate<void(const struct FPrimaryAssetId& PrimaryAssetId, const class UHWCharacterItem* CharacterItem)>& Delegate);
	static void GetDisplayNameFromEventCharacterData(const class UObject* WorldContextObject, const struct FHWEventCharacter& EventCharacter, const TDelegate<void(const struct FHWEventCharacter& EventCharacter, const class FText& DisplayName, const class UHWCharacterItem* CharacterItem)>& Delegate);
	static ETeamAttitude GetLocalAttitudeTowardsEventCharacter(const class UObject* WorldContextObject, const struct FHWEventCharacter& EventCharacter);
	static void GetNameColorFromEventCharacterData(const class UObject* WorldContextObject, const struct FHWEventCharacter& EventCharacter, const TDelegate<void(const struct FHWEventCharacter& EventCharacter, const class UHWCollectionItem* NameColorItem)>& Delegate);
	static bool IsEventCharacterAnNPC(const struct FHWEventCharacter& EventCharacter);
	static bool IsEventCharacterLocalPlayer(const class UObject* WorldContextObject, const struct FHWEventCharacter& EventCharacter);
	static bool LocalPlayerMatchesEventCharacterOrIsSpectator(const class UObject* WorldContextObject, const struct FHWEventCharacter& EventCharacter);
	static bool NotEqual_FHWEventCharacter(const struct FHWEventCharacter& A, const struct FHWEventCharacter& B);
	static void PlaySoftSoundOnAccoladeAudioComponent(const class UObject* WorldContextObject, TSoftObjectPtr<class UMetaSoundSource> SoundToPlay);
	static void PlaySoundOnAccoladeAudioComponent(const class UObject* WorldContextObject, class UMetaSoundSource* SoundToPlay);
	static bool ShouldUseGodNameInsteadOfPlayerName(const class UObject* WorldContextObject);
	static void StopAccoladeAudioComponent(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLibrary_EventSystem">();
	}
	static class UHWLibrary_EventSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLibrary_EventSystem>();
	}
};
static_assert(alignof(UHWLibrary_EventSystem) == 0x000008, "Wrong alignment on UHWLibrary_EventSystem");
static_assert(sizeof(UHWLibrary_EventSystem) == 0x000028, "Wrong size on UHWLibrary_EventSystem");

// Class Hemingway.HWAbilityAttackSettings_Rectangle
// 0x0010 (0x0288 - 0x0278)
class UHWAbilityAttackSettings_Rectangle final : public UHWAbilityAttackSettings_InstantShape
{
public:
	bool                                          bIsLineAttack;                                     // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Width;                                             // 0x027C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Length;                                            // 0x0280(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x0284(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Rectangle">();
	}
	static class UHWAbilityAttackSettings_Rectangle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Rectangle>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Rectangle) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_Rectangle");
static_assert(sizeof(UHWAbilityAttackSettings_Rectangle) == 0x000288, "Wrong size on UHWAbilityAttackSettings_Rectangle");
static_assert(offsetof(UHWAbilityAttackSettings_Rectangle, bIsLineAttack) == 0x000278, "Member 'UHWAbilityAttackSettings_Rectangle::bIsLineAttack' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Rectangle, Width) == 0x00027C, "Member 'UHWAbilityAttackSettings_Rectangle::Width' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Rectangle, Length) == 0x000280, "Member 'UHWAbilityAttackSettings_Rectangle::Length' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Rectangle, Height) == 0x000284, "Member 'UHWAbilityAttackSettings_Rectangle::Height' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_Ricochet
// 0x0008 (0x0288 - 0x0280)
class UHWAbilityAttackSettings_Ricochet : public UHWAbilityAttackSettings_Deployable
{
public:
	float                                         TargetHitboxCollisionRadius;                       // 0x0280(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Ricochet">();
	}
	static class UHWAbilityAttackSettings_Ricochet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Ricochet>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Ricochet) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_Ricochet");
static_assert(sizeof(UHWAbilityAttackSettings_Ricochet) == 0x000288, "Wrong size on UHWAbilityAttackSettings_Ricochet");
static_assert(offsetof(UHWAbilityAttackSettings_Ricochet, TargetHitboxCollisionRadius) == 0x000280, "Member 'UHWAbilityAttackSettings_Ricochet::TargetHitboxCollisionRadius' has a wrong offset!");

// Class Hemingway.HWAbilityTask_WaitTargetData
// 0x0040 (0x0100 - 0x00C0)
class UHWAbilityTask_WaitTargetData final : public UAbilityTask_WaitTargetData
{
public:
	bool                                          bCancelOnFailureToConfirmTargeting;                // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyTargetActorOnTaskDestroy;                  // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C2[0x27];                                      // 0x00C2(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	EAbilityCastStyle                             CastStyle;                                         // 0x00E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitCastStyleInput*      WaitForCastStyleInputTask;                         // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPreventAbilityInputFromConfirming;                // 0x00F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCleanUpTargeterOnTargetingCancelled;              // 0x00F9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_WaitTargetData* HWWaitForTargetingData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType, TSubclassOf<class AHWTargeter> InTargeterClass, const struct FGameplayTagContainer& AttacksToTarget, const bool bCancelOnConfirmFailure, const bool bEnableServerTargeting);
	static class UHWAbilityTask_WaitTargetData* HWWaitForTargetingDataUsingActor(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType, class AHWTargeter* InTargeter, const struct FGameplayTagContainer& AttacksToTarget, const bool bCancelOnConfirmFailure, const bool bDestroyTargetActorOnTaskDestroy_0, const bool bEnableServerTargeting);
	static class UHWAbilityTask_WaitTargetData* HWWaitForTargetingDataUsingCastStyle(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class AHWTargeter* InTargeter, const struct FGameplayTagContainer& AttacksToTarget, const EAbilityCastStyle DesiredCastStyle, const bool bCancelOnConfirmFailure, const bool bDestroyTargetActorOnTaskDestroy_0, const bool bEnableServerTargeting, const bool bPreventAbilityInputFromConfirming_0, const bool bCleanUpTargeterOnTargetingCancelled_0);

	void ForceCancel();
	void ForceConfirm(bool EndTask_0);
	void OnCastStyleInputCancelled(const float InputHeldTime, const bool bInputReleased);
	void OnCastStyleInputConfirmed(const float InputHeldTime, const bool bInputReleased);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_WaitTargetData">();
	}
	static class UHWAbilityTask_WaitTargetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_WaitTargetData>();
	}
};
static_assert(alignof(UHWAbilityTask_WaitTargetData) == 0x000008, "Wrong alignment on UHWAbilityTask_WaitTargetData");
static_assert(sizeof(UHWAbilityTask_WaitTargetData) == 0x000100, "Wrong size on UHWAbilityTask_WaitTargetData");
static_assert(offsetof(UHWAbilityTask_WaitTargetData, bCancelOnFailureToConfirmTargeting) == 0x0000C0, "Member 'UHWAbilityTask_WaitTargetData::bCancelOnFailureToConfirmTargeting' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitTargetData, bDestroyTargetActorOnTaskDestroy) == 0x0000C1, "Member 'UHWAbilityTask_WaitTargetData::bDestroyTargetActorOnTaskDestroy' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitTargetData, CastStyle) == 0x0000E9, "Member 'UHWAbilityTask_WaitTargetData::CastStyle' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitTargetData, WaitForCastStyleInputTask) == 0x0000F0, "Member 'UHWAbilityTask_WaitTargetData::WaitForCastStyleInputTask' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitTargetData, bPreventAbilityInputFromConfirming) == 0x0000F8, "Member 'UHWAbilityTask_WaitTargetData::bPreventAbilityInputFromConfirming' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitTargetData, bCleanUpTargeterOnTargetingCancelled) == 0x0000F9, "Member 'UHWAbilityTask_WaitTargetData::bCleanUpTargeterOnTargetingCancelled' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_SpawnFamiliar
// 0x0008 (0x0258 - 0x0250)
class UHWAbilityAttackSettings_SpawnFamiliar final : public UHWAbilityAttackSettings
{
public:
	class UHWFamiliarConfigSettings*              FamiliarConfig;                                    // 0x0250(0x0008)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_SpawnFamiliar">();
	}
	static class UHWAbilityAttackSettings_SpawnFamiliar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_SpawnFamiliar>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_SpawnFamiliar) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_SpawnFamiliar");
static_assert(sizeof(UHWAbilityAttackSettings_SpawnFamiliar) == 0x000258, "Wrong size on UHWAbilityAttackSettings_SpawnFamiliar");
static_assert(offsetof(UHWAbilityAttackSettings_SpawnFamiliar, FamiliarConfig) == 0x000250, "Member 'UHWAbilityAttackSettings_SpawnFamiliar::FamiliarConfig' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_Sphere
// 0x0008 (0x0280 - 0x0278)
class UHWAbilityAttackSettings_Sphere final : public UHWAbilityAttackSettings_InstantShape
{
public:
	float                                         Radius;                                            // 0x0278(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Sphere">();
	}
	static class UHWAbilityAttackSettings_Sphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Sphere>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Sphere) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_Sphere");
static_assert(sizeof(UHWAbilityAttackSettings_Sphere) == 0x000280, "Wrong size on UHWAbilityAttackSettings_Sphere");
static_assert(offsetof(UHWAbilityAttackSettings_Sphere, Radius) == 0x000278, "Member 'UHWAbilityAttackSettings_Sphere::Radius' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_Trail
// 0x0020 (0x02A0 - 0x0280)
class UHWAbilityAttackSettings_Trail final : public UHWAbilityAttackSettings_Deployable
{
public:
	struct FVector                                AttachmentOffset;                                  // 0x0280(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToBottomOfCollision;                        // 0x0298(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyTrailOnAttackEnd;                          // 0x0299(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A[0x6];                                      // 0x029A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Trail">();
	}
	static class UHWAbilityAttackSettings_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Trail>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Trail) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_Trail");
static_assert(sizeof(UHWAbilityAttackSettings_Trail) == 0x0002A0, "Wrong size on UHWAbilityAttackSettings_Trail");
static_assert(offsetof(UHWAbilityAttackSettings_Trail, AttachmentOffset) == 0x000280, "Member 'UHWAbilityAttackSettings_Trail::AttachmentOffset' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Trail, bAttachToBottomOfCollision) == 0x000298, "Member 'UHWAbilityAttackSettings_Trail::bAttachToBottomOfCollision' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Trail, bDestroyTrailOnAttackEnd) == 0x000299, "Member 'UHWAbilityAttackSettings_Trail::bDestroyTrailOnAttackEnd' has a wrong offset!");

// Class Hemingway.HWAutoSkillProfile
// 0x0010 (0x0040 - 0x0030)
class UHWAutoSkillProfile : public UDataAsset
{
public:
	TArray<struct FHWAutoSkillCharacterLevelEntry> CharacterLevelingEntries;                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAutoSkillProfile">();
	}
	static class UHWAutoSkillProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAutoSkillProfile>();
	}
};
static_assert(alignof(UHWAutoSkillProfile) == 0x000008, "Wrong alignment on UHWAutoSkillProfile");
static_assert(sizeof(UHWAutoSkillProfile) == 0x000040, "Wrong size on UHWAutoSkillProfile");
static_assert(offsetof(UHWAutoSkillProfile, CharacterLevelingEntries) == 0x000030, "Member 'UHWAutoSkillProfile::CharacterLevelingEntries' has a wrong offset!");

// Class Hemingway.HWAbilityAttackSettings_Wedge
// 0x0010 (0x0288 - 0x0278)
class UHWAbilityAttackSettings_Wedge final : public UHWAbilityAttackSettings_InstantShape
{
public:
	float                                         Angle;                                             // 0x0278(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x027C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumRadius;                                     // 0x0280(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x0284(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetAngle() const;
	float GetHeight() const;
	float GetMinRadius() const;
	float GetRadius() const;
	struct FCircularWedgeTargetingData GetWedgeTargetingData(class AActor* AvatarActor, const bool bIsPredicting) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAttackSettings_Wedge">();
	}
	static class UHWAbilityAttackSettings_Wedge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAttackSettings_Wedge>();
	}
};
static_assert(alignof(UHWAbilityAttackSettings_Wedge) == 0x000008, "Wrong alignment on UHWAbilityAttackSettings_Wedge");
static_assert(sizeof(UHWAbilityAttackSettings_Wedge) == 0x000288, "Wrong size on UHWAbilityAttackSettings_Wedge");
static_assert(offsetof(UHWAbilityAttackSettings_Wedge, Angle) == 0x000278, "Member 'UHWAbilityAttackSettings_Wedge::Angle' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Wedge, Radius) == 0x00027C, "Member 'UHWAbilityAttackSettings_Wedge::Radius' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Wedge, MinimumRadius) == 0x000280, "Member 'UHWAbilityAttackSettings_Wedge::MinimumRadius' has a wrong offset!");
static_assert(offsetof(UHWAbilityAttackSettings_Wedge, Height) == 0x000284, "Member 'UHWAbilityAttackSettings_Wedge::Height' has a wrong offset!");

// Class Hemingway.HWGameAudioManagerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UHWGameAudioManagerComponent : public UHWActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameAudioManagerComponent">();
	}
	static class UHWGameAudioManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameAudioManagerComponent>();
	}
};
static_assert(alignof(UHWGameAudioManagerComponent) == 0x000008, "Wrong alignment on UHWGameAudioManagerComponent");
static_assert(sizeof(UHWGameAudioManagerComponent) == 0x0000A0, "Wrong size on UHWGameAudioManagerComponent");

// Class Hemingway.HWAbilityLevelConfig
// 0x0138 (0x0160 - 0x0028)
class UHWAbilityLevelConfig : public UObject
{
public:
	int32                                         Level;                                             // 0x0028(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownDuration;                                  // 0x002C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHWAbilityAttackInstance>       Attacks;                                           // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UHWAbilityAttackSettings*>       AttackSettings;                                    // 0x0040(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UHWAbilityAimSettings*>          AimSettings;                                       // 0x0050(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FAbilityPhaseDurations                 AbilityPhaseDurations;                             // 0x0060(0x0018)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MinAbilityPhasesDuration;                          // 0x0078(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FHWEffectGroupConfig> EffectGroupConfigs;                       // 0x0080(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         AIBaseWeight;                                      // 0x00D0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, float>              AIModifierWeights;                                 // 0x00D8(0x0050)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         AIDesiredRange;                                    // 0x0128(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AIMinimumRange;                                    // 0x012C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AIEffectRadius;                                    // 0x0130(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AIPredictionSpeed;                                 // 0x0134(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AIUsageCooldownDuration;                           // 0x0138(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAIPredictSourceLocation;                          // 0x013C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanHitCurrentAITargetOnly;                        // 0x013D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AITags;                                            // 0x0140(0x0020)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	bool CanHitCurrentAITargetOnly() const;
	float GetAbilityPhaseDuration(const EAbilityFlowPhase Phase) const;
	float GetAIBaseWeight() const;
	float GetAIDesiredRange() const;
	float GetAIEffectRadius() const;
	float GetAIMinimumRange() const;
	float GetAIModifierWeight(const struct FGameplayTag& Tag) const;
	const class UHWAbilityAimSettings* GetAimSetting(const int32 ID) const;
	const class UHWAbilityAimSettings* GetAimSettingForAttack(const struct FGameplayTag& AttackID) const;
	float GetAIPredictionSpeed() const;
	float GetAIUsageCooldownDuration() const;
	const class UHWAbilityAttackSettings* GetAttackSetting(const int32 ID) const;
	const class UHWAbilityAttackSettings* GetAttackSettingForAttack(const struct FGameplayTag& AttackID) const;
	float GetCooldownDuration() const;
	void GetEffectsForGroups(const struct FGameplayTagContainer& EffectGroupTags, const struct FGameplayTag& CurrentAttackId, TArray<TSubclassOf<class UGameplayEffect>>* OutEffects) const;
	int32 GetLevel() const;
	float GetTotalAbilityPhaseDuration() const;
	bool HasAITag(const struct FGameplayTag& Tag) const;
	bool ShouldAIPredictSourceLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityLevelConfig">();
	}
	static class UHWAbilityLevelConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityLevelConfig>();
	}
};
static_assert(alignof(UHWAbilityLevelConfig) == 0x000008, "Wrong alignment on UHWAbilityLevelConfig");
static_assert(sizeof(UHWAbilityLevelConfig) == 0x000160, "Wrong size on UHWAbilityLevelConfig");
static_assert(offsetof(UHWAbilityLevelConfig, Level) == 0x000028, "Member 'UHWAbilityLevelConfig::Level' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, CooldownDuration) == 0x00002C, "Member 'UHWAbilityLevelConfig::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, Attacks) == 0x000030, "Member 'UHWAbilityLevelConfig::Attacks' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AttackSettings) == 0x000040, "Member 'UHWAbilityLevelConfig::AttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AimSettings) == 0x000050, "Member 'UHWAbilityLevelConfig::AimSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AbilityPhaseDurations) == 0x000060, "Member 'UHWAbilityLevelConfig::AbilityPhaseDurations' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, MinAbilityPhasesDuration) == 0x000078, "Member 'UHWAbilityLevelConfig::MinAbilityPhasesDuration' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, EffectGroupConfigs) == 0x000080, "Member 'UHWAbilityLevelConfig::EffectGroupConfigs' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AIBaseWeight) == 0x0000D0, "Member 'UHWAbilityLevelConfig::AIBaseWeight' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AIModifierWeights) == 0x0000D8, "Member 'UHWAbilityLevelConfig::AIModifierWeights' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AIDesiredRange) == 0x000128, "Member 'UHWAbilityLevelConfig::AIDesiredRange' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AIMinimumRange) == 0x00012C, "Member 'UHWAbilityLevelConfig::AIMinimumRange' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AIEffectRadius) == 0x000130, "Member 'UHWAbilityLevelConfig::AIEffectRadius' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AIPredictionSpeed) == 0x000134, "Member 'UHWAbilityLevelConfig::AIPredictionSpeed' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AIUsageCooldownDuration) == 0x000138, "Member 'UHWAbilityLevelConfig::AIUsageCooldownDuration' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, bAIPredictSourceLocation) == 0x00013C, "Member 'UHWAbilityLevelConfig::bAIPredictSourceLocation' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, bCanHitCurrentAITargetOnly) == 0x00013D, "Member 'UHWAbilityLevelConfig::bCanHitCurrentAITargetOnly' has a wrong offset!");
static_assert(offsetof(UHWAbilityLevelConfig, AITags) == 0x000140, "Member 'UHWAbilityLevelConfig::AITags' has a wrong offset!");

// Class Hemingway.HWAbility_Deployable
// 0x0018 (0x0D78 - 0x0D60)
class UHWAbility_Deployable : public UHWGameplayAbility_Enhanced
{
public:
	bool                                          bShouldModifyDeployablePhaseOnAbilityPhaseChange;  // 0x0D60(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyDeployableOnEndAbility;                    // 0x0D61(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D62[0x6];                                      // 0x0D62(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    AdditionalEffectToCacheSpecs;                      // 0x0D68(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	class AHWDeployable* GetAvatarDeployableFromActorInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Deployable">();
	}
	static class UHWAbility_Deployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Deployable>();
	}
};
static_assert(alignof(UHWAbility_Deployable) == 0x000008, "Wrong alignment on UHWAbility_Deployable");
static_assert(sizeof(UHWAbility_Deployable) == 0x000D78, "Wrong size on UHWAbility_Deployable");
static_assert(offsetof(UHWAbility_Deployable, bShouldModifyDeployablePhaseOnAbilityPhaseChange) == 0x000D60, "Member 'UHWAbility_Deployable::bShouldModifyDeployablePhaseOnAbilityPhaseChange' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable, bDestroyDeployableOnEndAbility) == 0x000D61, "Member 'UHWAbility_Deployable::bDestroyDeployableOnEndAbility' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable, AdditionalEffectToCacheSpecs) == 0x000D68, "Member 'UHWAbility_Deployable::AdditionalEffectToCacheSpecs' has a wrong offset!");

// Class Hemingway.HWAbility_Deployable_BounceChain
// 0x00B8 (0x0E30 - 0x0D78)
class UHWAbility_Deployable_BounceChain : public UHWAbility_Deployable
{
public:
	class UCurveTable*                            AbilityCurveTable;                                 // 0x0D78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaxBounceCountRowName;                             // 0x0D80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxBounceCount;                                    // 0x0D88(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxHitsPerTarget;                                  // 0x0D8C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowSameConsecutiveTargets;                      // 0x0D90(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoesBounceHaveTravelTime;                         // 0x0D91(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D92[0x6];                                      // 0x0D92(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWBounceChainGameplayEffect>   FriendlyHitEffects;                                // 0x0D98(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FHWBounceChainGameplayEffect>   EnemyHitEffects;                                   // 0x0DA8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class AActor*, int32>                    PreviouslyHitTargets;                              // 0x0DB8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 PendingApplicationTarget;                          // 0x0E08(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 PreviousTarget;                                    // 0x0E10(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentBounceCount;                                // 0x0E18(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1C[0x14];                                     // 0x0E1C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyGameplayEffectToHitTarget(class AActor* HitTarget);
	void MoveDeployableToHitTarget(class AActor* HitTarget);
	void TrackHitTarget(class AActor* HitTarget);

	TArray<struct FGameplayEffectSpecHandle> MakeGameplayEffectSpecs(class AActor* HitTarget) const;
	class AActor* SelectNextHitTarget(const TArray<class AActor*>& HitTargets) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Deployable_BounceChain">();
	}
	static class UHWAbility_Deployable_BounceChain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Deployable_BounceChain>();
	}
};
static_assert(alignof(UHWAbility_Deployable_BounceChain) == 0x000008, "Wrong alignment on UHWAbility_Deployable_BounceChain");
static_assert(sizeof(UHWAbility_Deployable_BounceChain) == 0x000E30, "Wrong size on UHWAbility_Deployable_BounceChain");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, AbilityCurveTable) == 0x000D78, "Member 'UHWAbility_Deployable_BounceChain::AbilityCurveTable' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, MaxBounceCountRowName) == 0x000D80, "Member 'UHWAbility_Deployable_BounceChain::MaxBounceCountRowName' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, MaxBounceCount) == 0x000D88, "Member 'UHWAbility_Deployable_BounceChain::MaxBounceCount' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, MaxHitsPerTarget) == 0x000D8C, "Member 'UHWAbility_Deployable_BounceChain::MaxHitsPerTarget' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, bAllowSameConsecutiveTargets) == 0x000D90, "Member 'UHWAbility_Deployable_BounceChain::bAllowSameConsecutiveTargets' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, bDoesBounceHaveTravelTime) == 0x000D91, "Member 'UHWAbility_Deployable_BounceChain::bDoesBounceHaveTravelTime' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, FriendlyHitEffects) == 0x000D98, "Member 'UHWAbility_Deployable_BounceChain::FriendlyHitEffects' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, EnemyHitEffects) == 0x000DA8, "Member 'UHWAbility_Deployable_BounceChain::EnemyHitEffects' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, PreviouslyHitTargets) == 0x000DB8, "Member 'UHWAbility_Deployable_BounceChain::PreviouslyHitTargets' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, PendingApplicationTarget) == 0x000E08, "Member 'UHWAbility_Deployable_BounceChain::PendingApplicationTarget' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, PreviousTarget) == 0x000E10, "Member 'UHWAbility_Deployable_BounceChain::PreviousTarget' has a wrong offset!");
static_assert(offsetof(UHWAbility_Deployable_BounceChain, CurrentBounceCount) == 0x000E18, "Member 'UHWAbility_Deployable_BounceChain::CurrentBounceCount' has a wrong offset!");

// Class Hemingway.HWCollectionItem
// 0x0200 (0x03B0 - 0x01B0)
class UHWCollectionItem : public UHWInventoryItem
{
public:
	EHWCollectionItemType                         CollectionType;                                    // 0x01B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWQuestTrackerAwardType                      QuestTrackerAwardType;                             // 0x01B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B2[0x2];                                      // 0x01B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Rarity;                                            // 0x01B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWCollectionDescriptionData>   DescriptionDataList;                               // 0x01C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CollectionTags;                                    // 0x01D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWCharacterItem>        AssociatedCharacter;                               // 0x01F0(0x0028)(Edit, DisableEditOnInstance, AssetRegistrySearchable, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AssociatedCharacterTagName;                        // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, TSoftObjectPtr<class UNiagaraSystem>> CosmeticNiagaraSystems;                  // 0x0220(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, TSoftObjectPtr<class USoundBase>> CosmeticSounds;                              // 0x0270(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, TSoftObjectPtr<class UStaticMesh>> CosmeticStaticMeshes;                       // 0x02C0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, TSoftObjectPtr<class USkeletalMesh>> CosmeticSkeletalMeshes;                   // 0x0310(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, struct FHWCosmeticMaterialSet> CosmeticMaterials;                              // 0x0360(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	const TSoftObjectPtr<class UHWCharacterItem> GetAssociatedCharacter() const;
	const TSoftObjectPtr<class UHWCharacterItem> GetAssociatedCharacterFull(const class UObject* WorldContextObject, const struct FRH_ItemId& InItemId) const;
	EHWCollectionItemStatus GetCollectionItemStatus(const class URH_PlayerInfo* PlayerInfo, const class UHWCharacterItem* CharacterContextItem, const class UHWInventoryItem* OtherContextItem) const;
	EHWCollectionItemType GetCollectionType() const;
	struct FHWCosmeticMaterialSet GetCosmeticMaterials(const class FName AssetKey) const;
	TSoftObjectPtr<class UNiagaraSystem> GetCosmeticNiagaraSystem(const class FName AssetKey) const;
	TSoftObjectPtr<class USkeletalMesh> GetCosmeticSkeletalMesh(const class FName AssetKey) const;
	TSoftObjectPtr<class USoundBase> GetCosmeticSound(const class FName AssetKey) const;
	TSoftObjectPtr<class UStaticMesh> GetCosmeticStaticMesh(const class FName AssetKey) const;
	bool IsComingSoon() const;
	bool IsEquipped(const class UObject* WorldContextObject, const class UHWCharacterItem* EquippedToCharacter, bool bConsiderVariantSkin) const;
	bool IsUnobtainable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCollectionItem">();
	}
	static class UHWCollectionItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCollectionItem>();
	}
};
static_assert(alignof(UHWCollectionItem) == 0x000008, "Wrong alignment on UHWCollectionItem");
static_assert(sizeof(UHWCollectionItem) == 0x0003B0, "Wrong size on UHWCollectionItem");
static_assert(offsetof(UHWCollectionItem, CollectionType) == 0x0001B0, "Member 'UHWCollectionItem::CollectionType' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, QuestTrackerAwardType) == 0x0001B1, "Member 'UHWCollectionItem::QuestTrackerAwardType' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, Rarity) == 0x0001B4, "Member 'UHWCollectionItem::Rarity' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, DescriptionDataList) == 0x0001C0, "Member 'UHWCollectionItem::DescriptionDataList' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, CollectionTags) == 0x0001D0, "Member 'UHWCollectionItem::CollectionTags' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, AssociatedCharacter) == 0x0001F0, "Member 'UHWCollectionItem::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, AssociatedCharacterTagName) == 0x000218, "Member 'UHWCollectionItem::AssociatedCharacterTagName' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, CosmeticNiagaraSystems) == 0x000220, "Member 'UHWCollectionItem::CosmeticNiagaraSystems' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, CosmeticSounds) == 0x000270, "Member 'UHWCollectionItem::CosmeticSounds' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, CosmeticStaticMeshes) == 0x0002C0, "Member 'UHWCollectionItem::CosmeticStaticMeshes' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, CosmeticSkeletalMeshes) == 0x000310, "Member 'UHWCollectionItem::CosmeticSkeletalMeshes' has a wrong offset!");
static_assert(offsetof(UHWCollectionItem, CosmeticMaterials) == 0x000360, "Member 'UHWCollectionItem::CosmeticMaterials' has a wrong offset!");

// Class Hemingway.HWCharacterItem
// 0x04B8 (0x0868 - 0x03B0)
class UHWCharacterItem final : public UHWCollectionItem
{
public:
	bool                                          bIsDisabled;                                       // 0x03B0(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWCharacterInfo>        CharacterInfo;                                     // 0x03B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CharacterAssetTags;                                // 0x03E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CharacterRoleTags;                                 // 0x0400(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	int32                                         StrengthScaling;                                   // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IntelligenceScaling;                               // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefenseStart;                                      // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefensePotential;                                  // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OffenseStart;                                      // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OffensePotential;                                  // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AbilityStart;                                      // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AbilityPotential;                                  // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCharacterRoleInfo>             RoleInfo;                                          // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveTable*                            CharacterStatsTable;                               // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETextGender                                   Gender;                                            // 0x0458(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Pantheon;                                          // 0x0460(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PreviousPantheon;                                  // 0x0470(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   CharacterTitle;                                    // 0x0480(0x0018)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   CharacterTitleCaps;                                // 0x0498(0x0018)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   FlavorText;                                        // 0x04B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   LongFlavorText;                                    // 0x04C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldUseTeamIcon;                                // 0x04E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWSkinItem>             DefaultSkin;                                       // 0x04E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x10];                                     // 0x0510(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWVoicePackItem>        AssociatedVoicePack;                               // 0x0520(0x0028)(Edit, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UHWAutoSkillProfile>     AutoSkillProfile;                                  // 0x0548(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UHWAutoBuyBuildProfile>> AutoBuyProfiles;                            // 0x0570(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FHWAscensionInfo                       AscensionInfo;                                     // 0x0580(0x00B8)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             GodQuestTablePtr;                                  // 0x0638(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FHWCharacterCollectionInfo> CollectionInfoMap;                  // 0x0640(0x0050)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              GenericCollectionItemsTable;                       // 0x0690(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UHWEquipmentItem>> FrontEndGodAbilityInfo;                           // 0x06B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWEquipmentItem>        PassiveEquipmentItem;                              // 0x06C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWEquipmentItem>        BasicAttackEquipmentItem;                          // 0x06F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWAbilityItemSet>              FrontEndGodAbilitySets;                            // 0x0718(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHWAbilityItemSet                      PassiveAbilitySet;                                 // 0x0728(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHWAbilityItemSet                      BasicAttackAbilitySet;                             // 0x0738(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UHWCharacterItem>> Familiars;                                        // 0x0748(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CharacterSpecificItemsTable;                       // 0x0758(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SupportedAIRoles;                                  // 0x0780(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UHWAIGoal>>          CustomAIGoals;                                     // 0x07A0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bEnableForGodBotDynamicFill;                       // 0x07B0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWEquipmentItem>        GodBotRelicItem;                                   // 0x07B8(0x0028)(Edit, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSoftObjectPtr<class UHWAutoBuyBuildProfile>> GodBotItemProfilesByRole; // 0x07E0(0x0050)(Edit, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UHWEquipmentItem>> CompatibleTalentItems;                            // 0x0830(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  CustomLevel;                                       // 0x0840(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetAbilityPotential() const;
	int32 GetAbilityStart() const;
	void GetAllTexturesForGameplayTag(const struct FGameplayTag& GameplayTag, TMap<struct FGameplayTag, TSoftObjectPtr<class UTexture2D>>* OutTextures) const;
	void GetCharacterDescriptorTags(struct FGameplayTagContainer* OutTags) const;
	int32 GetCharacterHealerTier() const;
	float GetCharacterStat(const struct FGameplayTag& StatTag, const int32 Level) const;
	class FText GetCharacterTitle() const;
	class FText GetCharacterTitleCaps() const;
	bool GetCollectionInfo(const struct FGameplayTag& Tag, struct FHWCharacterCollectionInfo* OutCollectionInfo) const;
	const TSoftObjectPtr<class UHWCollectionItem> GetCollectionItemByItemId(const struct FRH_ItemId& InItemId) const;
	const TArray<TSoftObjectPtr<class UHWEquipmentItem>> GetCompatibleTalents() const;
	TSoftObjectPtr<class UWorld> GetCustomLevel() const;
	int32 GetDefensePotential() const;
	int32 GetDefenseStart() const;
	bool GetGodQuestEntryByCollectionItem(const class UHWCollectionItem* CollectionItem, struct FGodQuestEntry* OutQuestEntry) const;
	bool GetGodQuestEntryByCollectionItemPtr(const TSoftObjectPtr<class UHWCollectionItem> CollectionItem, struct FGodQuestEntry* OutQuestEntry) const;
	bool GetGodQuestEntryByQuestItem(const TSoftObjectPtr<class UHWQuest> QuestItem, struct FGodQuestEntry* OutQuestEntry) const;
	bool GetGodQuestEntryByQuestItemId(const struct FRH_ItemId& InQuestItemId, struct FGodQuestEntry* OutQuestEntry) const;
	int32 GetIntelligenceScaling() const;
	int32 GetOffensePotential() const;
	int32 GetOffenseStart() const;
	const struct FRH_ItemId GetOwnershipIdByCollectionItem(const class UHWCollectionItem* CollectionItem) const;
	TArray<struct FCharacterRoleInfo> GetRoleInfo() const;
	void GetSkinItemsForCharacterItem(TArray<TSoftObjectPtr<class UHWSkinItem>>* OutSkinItems) const;
	int32 GetStrengthScaling() const;
	TSoftObjectPtr<class UTexture2D> GetTextureForExactGameplayTag(const struct FGameplayTag& GameplayTag) const;
	TSoftObjectPtr<class UHWVoicePackItem> GetVoicePackItem() const;
	bool IsFavoriteGod(const class UObject* WorldContextObject) const;
	bool IsInRotation(const class UObject* WorldContextObject) const;
	void SetIsFavoriteGod(const class UObject* WorldContextObject, bool bIsFavorite) const;
	void UpdateAssociatedSkinItems() const;
	bool ValidatePantheon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacterItem">();
	}
	static class UHWCharacterItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCharacterItem>();
	}
};
static_assert(alignof(UHWCharacterItem) == 0x000008, "Wrong alignment on UHWCharacterItem");
static_assert(sizeof(UHWCharacterItem) == 0x000868, "Wrong size on UHWCharacterItem");
static_assert(offsetof(UHWCharacterItem, bIsDisabled) == 0x0003B0, "Member 'UHWCharacterItem::bIsDisabled' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CharacterInfo) == 0x0003B8, "Member 'UHWCharacterItem::CharacterInfo' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CharacterAssetTags) == 0x0003E0, "Member 'UHWCharacterItem::CharacterAssetTags' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CharacterRoleTags) == 0x000400, "Member 'UHWCharacterItem::CharacterRoleTags' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, StrengthScaling) == 0x000420, "Member 'UHWCharacterItem::StrengthScaling' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, IntelligenceScaling) == 0x000424, "Member 'UHWCharacterItem::IntelligenceScaling' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, DefenseStart) == 0x000428, "Member 'UHWCharacterItem::DefenseStart' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, DefensePotential) == 0x00042C, "Member 'UHWCharacterItem::DefensePotential' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, OffenseStart) == 0x000430, "Member 'UHWCharacterItem::OffenseStart' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, OffensePotential) == 0x000434, "Member 'UHWCharacterItem::OffensePotential' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, AbilityStart) == 0x000438, "Member 'UHWCharacterItem::AbilityStart' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, AbilityPotential) == 0x00043C, "Member 'UHWCharacterItem::AbilityPotential' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, RoleInfo) == 0x000440, "Member 'UHWCharacterItem::RoleInfo' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CharacterStatsTable) == 0x000450, "Member 'UHWCharacterItem::CharacterStatsTable' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, Gender) == 0x000458, "Member 'UHWCharacterItem::Gender' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, Pantheon) == 0x000460, "Member 'UHWCharacterItem::Pantheon' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, PreviousPantheon) == 0x000470, "Member 'UHWCharacterItem::PreviousPantheon' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CharacterTitle) == 0x000480, "Member 'UHWCharacterItem::CharacterTitle' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CharacterTitleCaps) == 0x000498, "Member 'UHWCharacterItem::CharacterTitleCaps' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, FlavorText) == 0x0004B0, "Member 'UHWCharacterItem::FlavorText' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, LongFlavorText) == 0x0004C8, "Member 'UHWCharacterItem::LongFlavorText' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, bShouldUseTeamIcon) == 0x0004E0, "Member 'UHWCharacterItem::bShouldUseTeamIcon' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, DefaultSkin) == 0x0004E8, "Member 'UHWCharacterItem::DefaultSkin' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, AssociatedVoicePack) == 0x000520, "Member 'UHWCharacterItem::AssociatedVoicePack' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, AutoSkillProfile) == 0x000548, "Member 'UHWCharacterItem::AutoSkillProfile' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, AutoBuyProfiles) == 0x000570, "Member 'UHWCharacterItem::AutoBuyProfiles' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, AscensionInfo) == 0x000580, "Member 'UHWCharacterItem::AscensionInfo' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, GodQuestTablePtr) == 0x000638, "Member 'UHWCharacterItem::GodQuestTablePtr' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CollectionInfoMap) == 0x000640, "Member 'UHWCharacterItem::CollectionInfoMap' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, GenericCollectionItemsTable) == 0x000690, "Member 'UHWCharacterItem::GenericCollectionItemsTable' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, FrontEndGodAbilityInfo) == 0x0006B8, "Member 'UHWCharacterItem::FrontEndGodAbilityInfo' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, PassiveEquipmentItem) == 0x0006C8, "Member 'UHWCharacterItem::PassiveEquipmentItem' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, BasicAttackEquipmentItem) == 0x0006F0, "Member 'UHWCharacterItem::BasicAttackEquipmentItem' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, FrontEndGodAbilitySets) == 0x000718, "Member 'UHWCharacterItem::FrontEndGodAbilitySets' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, PassiveAbilitySet) == 0x000728, "Member 'UHWCharacterItem::PassiveAbilitySet' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, BasicAttackAbilitySet) == 0x000738, "Member 'UHWCharacterItem::BasicAttackAbilitySet' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, Familiars) == 0x000748, "Member 'UHWCharacterItem::Familiars' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CharacterSpecificItemsTable) == 0x000758, "Member 'UHWCharacterItem::CharacterSpecificItemsTable' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, SupportedAIRoles) == 0x000780, "Member 'UHWCharacterItem::SupportedAIRoles' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CustomAIGoals) == 0x0007A0, "Member 'UHWCharacterItem::CustomAIGoals' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, bEnableForGodBotDynamicFill) == 0x0007B0, "Member 'UHWCharacterItem::bEnableForGodBotDynamicFill' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, GodBotRelicItem) == 0x0007B8, "Member 'UHWCharacterItem::GodBotRelicItem' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, GodBotItemProfilesByRole) == 0x0007E0, "Member 'UHWCharacterItem::GodBotItemProfilesByRole' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CompatibleTalentItems) == 0x000830, "Member 'UHWCharacterItem::CompatibleTalentItems' has a wrong offset!");
static_assert(offsetof(UHWCharacterItem, CustomLevel) == 0x000840, "Member 'UHWCharacterItem::CustomLevel' has a wrong offset!");

// Class Hemingway.HWAbility_Interact
// 0x0010 (0x0D70 - 0x0D60)
class UHWAbility_Interact final : public UHWGameplayAbility_Enhanced
{
public:
	class UHWInteractableComponent*               CurrentInteractable;                               // 0x0D60(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           InteractionTimer;                                  // 0x0D68(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAvatarDamaged(const struct FDamageEventData& DamgageEventData);
	void OnInteractionEnded(const bool bWasCancelled);

	class UHWInteractableComponent* FindClosestInteractable(const class AActor* Avatar) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Interact">();
	}
	static class UHWAbility_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Interact>();
	}
};
static_assert(alignof(UHWAbility_Interact) == 0x000008, "Wrong alignment on UHWAbility_Interact");
static_assert(sizeof(UHWAbility_Interact) == 0x000D70, "Wrong size on UHWAbility_Interact");
static_assert(offsetof(UHWAbility_Interact, CurrentInteractable) == 0x000D60, "Member 'UHWAbility_Interact::CurrentInteractable' has a wrong offset!");
static_assert(offsetof(UHWAbility_Interact, InteractionTimer) == 0x000D68, "Member 'UHWAbility_Interact::InteractionTimer' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Reflect
// 0x00A8 (0x0B60 - 0x0AB8)
class UHWGameplayEffect_Reflect final : public UHWGameplayEffect
{
public:
	struct FGameplayTagRequirements               ReflectTags;                                       // 0x0AB8(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DamageReflectPercent;                              // 0x0B40(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B44[0x4];                                      // 0x0B44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWGameplayEffect_ReflectDamage> ReflectDamageEffectClass;                     // 0x0B48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRemoveOnSuccessfulReflect;                        // 0x0B50(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDealAOEReflectDamage;                             // 0x0B51(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B52[0x6];                                      // 0x0B52(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityAttackSettings_Sphere*        AOEReflectAttackSettings;                          // 0x0B58(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Reflect">();
	}
	static class UHWGameplayEffect_Reflect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Reflect>();
	}
};
static_assert(alignof(UHWGameplayEffect_Reflect) == 0x000008, "Wrong alignment on UHWGameplayEffect_Reflect");
static_assert(sizeof(UHWGameplayEffect_Reflect) == 0x000B60, "Wrong size on UHWGameplayEffect_Reflect");
static_assert(offsetof(UHWGameplayEffect_Reflect, ReflectTags) == 0x000AB8, "Member 'UHWGameplayEffect_Reflect::ReflectTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Reflect, DamageReflectPercent) == 0x000B40, "Member 'UHWGameplayEffect_Reflect::DamageReflectPercent' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Reflect, ReflectDamageEffectClass) == 0x000B48, "Member 'UHWGameplayEffect_Reflect::ReflectDamageEffectClass' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Reflect, bRemoveOnSuccessfulReflect) == 0x000B50, "Member 'UHWGameplayEffect_Reflect::bRemoveOnSuccessfulReflect' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Reflect, bDealAOEReflectDamage) == 0x000B51, "Member 'UHWGameplayEffect_Reflect::bDealAOEReflectDamage' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Reflect, AOEReflectAttackSettings) == 0x000B58, "Member 'UHWGameplayEffect_Reflect::AOEReflectAttackSettings' has a wrong offset!");

// Class Hemingway.HWAbility_Jump
// 0x0008 (0x0D68 - 0x0D60)
class UHWAbility_Jump final : public UHWGameplayAbility_Enhanced
{
public:
	bool                                          bUseRealJump;                                      // 0x0D60(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D61[0x7];                                      // 0x0D61(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Jump">();
	}
	static class UHWAbility_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Jump>();
	}
};
static_assert(alignof(UHWAbility_Jump) == 0x000008, "Wrong alignment on UHWAbility_Jump");
static_assert(sizeof(UHWAbility_Jump) == 0x000D68, "Wrong size on UHWAbility_Jump");
static_assert(offsetof(UHWAbility_Jump, bUseRealJump) == 0x000D60, "Member 'UHWAbility_Jump::bUseRealJump' has a wrong offset!");

// Class Hemingway.HWAbility_ListenOtherAbilityFire
// 0x0018 (0x0D78 - 0x0D60)
class UHWAbility_ListenOtherAbilityFire final : public UHWGameplayAbility_Enhanced
{
public:
	struct FGameplayTag                           AbilityToListenFor;                                // 0x0D60(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AbilityToExclude;                                  // 0x0D68(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityTask_WaitAbilityFire*         WaitFireTask;                                      // 0x0D70(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnListenedAbilityFired(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& FiredAbilityTags, const struct FHWAbilityFiringInstanceId& FiringInstanceId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_ListenOtherAbilityFire">();
	}
	static class UHWAbility_ListenOtherAbilityFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_ListenOtherAbilityFire>();
	}
};
static_assert(alignof(UHWAbility_ListenOtherAbilityFire) == 0x000008, "Wrong alignment on UHWAbility_ListenOtherAbilityFire");
static_assert(sizeof(UHWAbility_ListenOtherAbilityFire) == 0x000D78, "Wrong size on UHWAbility_ListenOtherAbilityFire");
static_assert(offsetof(UHWAbility_ListenOtherAbilityFire, AbilityToListenFor) == 0x000D60, "Member 'UHWAbility_ListenOtherAbilityFire::AbilityToListenFor' has a wrong offset!");
static_assert(offsetof(UHWAbility_ListenOtherAbilityFire, AbilityToExclude) == 0x000D68, "Member 'UHWAbility_ListenOtherAbilityFire::AbilityToExclude' has a wrong offset!");
static_assert(offsetof(UHWAbility_ListenOtherAbilityFire, WaitFireTask) == 0x000D70, "Member 'UHWAbility_ListenOtherAbilityFire::WaitFireTask' has a wrong offset!");

// Class Hemingway.HWAbility_MovementSpeedOverTime
// 0x0008 (0x09C8 - 0x09C0)
class UHWAbility_MovementSpeedOverTime final : public UHWGameplayAbility
{
public:
	class FName                                   MovementName;                                      // 0x09C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_MovementSpeedOverTime">();
	}
	static class UHWAbility_MovementSpeedOverTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_MovementSpeedOverTime>();
	}
};
static_assert(alignof(UHWAbility_MovementSpeedOverTime) == 0x000008, "Wrong alignment on UHWAbility_MovementSpeedOverTime");
static_assert(sizeof(UHWAbility_MovementSpeedOverTime) == 0x0009C8, "Wrong size on UHWAbility_MovementSpeedOverTime");
static_assert(offsetof(UHWAbility_MovementSpeedOverTime, MovementName) == 0x0009C0, "Member 'UHWAbility_MovementSpeedOverTime::MovementName' has a wrong offset!");

// Class Hemingway.HWCharacter_Titan
// 0x0000 (0x13F0 - 0x13F0)
class AHWCharacter_Titan final : public AHWCharacter_NPC
{
public:
	class UHWDeployableDestructionComponent*      DeployableDestructionComponent;                    // 0x13E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Titan">();
	}
	static class AHWCharacter_Titan* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Titan>();
	}
};
static_assert(alignof(AHWCharacter_Titan) == 0x000010, "Wrong alignment on AHWCharacter_Titan");
static_assert(sizeof(AHWCharacter_Titan) == 0x0013F0, "Wrong size on AHWCharacter_Titan");
static_assert(offsetof(AHWCharacter_Titan, DeployableDestructionComponent) == 0x0013E8, "Member 'AHWCharacter_Titan::DeployableDestructionComponent' has a wrong offset!");

// Class Hemingway.HWAbility_PassiveItem
// 0x0168 (0x0ED8 - 0x0D70)
class UHWAbility_PassiveItem : public UHWAbility_Passive
{
public:
	struct FGameplayTargetDataFilter              AcceptableTargetFilter;                            // 0x0D70(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bListenForGameplayEffectAppliedToOwner;            // 0x0D90(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D91[0x7];                                      // 0x0D91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               OwnerTagRequirements;                              // 0x0D98(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bListenForGameplayEffectAppliedToTarget;           // 0x0E20(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E21[0x7];                                      // 0x0E21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               TargetTagRequirements;                             // 0x0E28(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AbilityTagsToListenFor;                            // 0x0EB0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bListenForOwnerDealtDamage;                        // 0x0ED0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED1[0x7];                                      // 0x0ED1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnGameplayEffectAppliedToOwner(const class AActor* Target, const struct FActiveGameplayEffectHandle& ActiveHandle, const struct FGameplayTagContainer& EffectAssetTags, const struct FGameplayEffectSpecHandle& EffectSpecHandle);
	void BP_OnGameplayEffectAppliedToTarget(const class AActor* Target, const struct FActiveGameplayEffectHandle& ActiveHandle, const struct FGameplayTagContainer& EffectAssetTags, const struct FGameplayEffectSpecHandle& EffectSpecHandle);
	void OnAbilityEnded(const class UGameplayAbility* EndedAbility);
	void OnAbilityFired(const struct FGameplayAbilitySpecHandle& FiredAbilityHandle, const struct FGameplayTagContainer& FiredAbilityTags, const struct FHWAbilityFiringInstanceId& FiringInstanceId);
	void OnGameplayEffectAppliedToOwner(class AActor* Owner, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle);
	void OnGameplayEffectAppliedToTarget(class AActor* Target, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle);
	void OnOwnerDealtDamage(const struct FDamageEventData& DamageEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_PassiveItem">();
	}
	static class UHWAbility_PassiveItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_PassiveItem>();
	}
};
static_assert(alignof(UHWAbility_PassiveItem) == 0x000008, "Wrong alignment on UHWAbility_PassiveItem");
static_assert(sizeof(UHWAbility_PassiveItem) == 0x000ED8, "Wrong size on UHWAbility_PassiveItem");
static_assert(offsetof(UHWAbility_PassiveItem, AcceptableTargetFilter) == 0x000D70, "Member 'UHWAbility_PassiveItem::AcceptableTargetFilter' has a wrong offset!");
static_assert(offsetof(UHWAbility_PassiveItem, bListenForGameplayEffectAppliedToOwner) == 0x000D90, "Member 'UHWAbility_PassiveItem::bListenForGameplayEffectAppliedToOwner' has a wrong offset!");
static_assert(offsetof(UHWAbility_PassiveItem, OwnerTagRequirements) == 0x000D98, "Member 'UHWAbility_PassiveItem::OwnerTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWAbility_PassiveItem, bListenForGameplayEffectAppliedToTarget) == 0x000E20, "Member 'UHWAbility_PassiveItem::bListenForGameplayEffectAppliedToTarget' has a wrong offset!");
static_assert(offsetof(UHWAbility_PassiveItem, TargetTagRequirements) == 0x000E28, "Member 'UHWAbility_PassiveItem::TargetTagRequirements' has a wrong offset!");
static_assert(offsetof(UHWAbility_PassiveItem, AbilityTagsToListenFor) == 0x000EB0, "Member 'UHWAbility_PassiveItem::AbilityTagsToListenFor' has a wrong offset!");
static_assert(offsetof(UHWAbility_PassiveItem, bListenForOwnerDealtDamage) == 0x000ED0, "Member 'UHWAbility_PassiveItem::bListenForOwnerDealtDamage' has a wrong offset!");

// Class Hemingway.HWAutoBuyComponent
// 0x0080 (0x0120 - 0x00A0)
class UHWAutoBuyComponent final : public UHWActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EHWAutoBuyState NewState)> OnAutoBuyStateChanged;                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EHWAutoBuyState                               AutoBuyState;                                      // 0x00C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x1F];                                      // 0x00C9(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class UHWEquipmentRecipe* NewRecipe)> OnNewItemStarted;      // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWAutoBuyBuildProfile*                 CurrentBuildProfile;                               // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWInventoryManagerComponent*           InventoryManager;                                  // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentEquipmentIndex;                             // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SkippedEquipmentIndexes;                           // 0x0110(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void DisableAutoBuy();
	void EnableAutoBuy();
	void EnableManualBuild();
	void OnRep_AutoBuyState();
	void OnShopVendorChanged(class UHWInventoryManagerComponent* InventoryManagerComponent, const class AHWShopVendorVolume* NewShop);
	void Server_DisableAutoBuy();

	EHWAutoBuyState GetAutoBuyState() const;
	bool IsAllowedToUseAutoBuy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAutoBuyComponent">();
	}
	static class UHWAutoBuyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAutoBuyComponent>();
	}
};
static_assert(alignof(UHWAutoBuyComponent) == 0x000008, "Wrong alignment on UHWAutoBuyComponent");
static_assert(sizeof(UHWAutoBuyComponent) == 0x000120, "Wrong size on UHWAutoBuyComponent");
static_assert(offsetof(UHWAutoBuyComponent, OnAutoBuyStateChanged) == 0x0000B8, "Member 'UHWAutoBuyComponent::OnAutoBuyStateChanged' has a wrong offset!");
static_assert(offsetof(UHWAutoBuyComponent, AutoBuyState) == 0x0000C8, "Member 'UHWAutoBuyComponent::AutoBuyState' has a wrong offset!");
static_assert(offsetof(UHWAutoBuyComponent, OnNewItemStarted) == 0x0000E8, "Member 'UHWAutoBuyComponent::OnNewItemStarted' has a wrong offset!");
static_assert(offsetof(UHWAutoBuyComponent, CurrentBuildProfile) == 0x0000F8, "Member 'UHWAutoBuyComponent::CurrentBuildProfile' has a wrong offset!");
static_assert(offsetof(UHWAutoBuyComponent, InventoryManager) == 0x000100, "Member 'UHWAutoBuyComponent::InventoryManager' has a wrong offset!");
static_assert(offsetof(UHWAutoBuyComponent, CurrentEquipmentIndex) == 0x000108, "Member 'UHWAutoBuyComponent::CurrentEquipmentIndex' has a wrong offset!");
static_assert(offsetof(UHWAutoBuyComponent, SkippedEquipmentIndexes) == 0x000110, "Member 'UHWAutoBuyComponent::SkippedEquipmentIndexes' has a wrong offset!");

// Class Hemingway.HWAbility_PassiveItem_Magis
// 0x0030 (0x0F08 - 0x0ED8)
class UHWAbility_PassiveItem_Magis : public UHWAbility_PassiveItem
{
public:
	TSubclassOf<class UHWGameplayEffect>          PermanantImmunityEffectClass;                      // 0x0ED8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayEffect>          LatentImmunityEffectClass;                         // 0x0EE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayEffect>          CooldownEffectClass;                               // 0x0EE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CooldownEffectTag;                                 // 0x0EF0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           BurstVisualEffectCue;                              // 0x0EF8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F00[0x8];                                      // 0x0F00(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_PassiveItem_Magis">();
	}
	static class UHWAbility_PassiveItem_Magis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_PassiveItem_Magis>();
	}
};
static_assert(alignof(UHWAbility_PassiveItem_Magis) == 0x000008, "Wrong alignment on UHWAbility_PassiveItem_Magis");
static_assert(sizeof(UHWAbility_PassiveItem_Magis) == 0x000F08, "Wrong size on UHWAbility_PassiveItem_Magis");
static_assert(offsetof(UHWAbility_PassiveItem_Magis, PermanantImmunityEffectClass) == 0x000ED8, "Member 'UHWAbility_PassiveItem_Magis::PermanantImmunityEffectClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_PassiveItem_Magis, LatentImmunityEffectClass) == 0x000EE0, "Member 'UHWAbility_PassiveItem_Magis::LatentImmunityEffectClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_PassiveItem_Magis, CooldownEffectClass) == 0x000EE8, "Member 'UHWAbility_PassiveItem_Magis::CooldownEffectClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_PassiveItem_Magis, CooldownEffectTag) == 0x000EF0, "Member 'UHWAbility_PassiveItem_Magis::CooldownEffectTag' has a wrong offset!");
static_assert(offsetof(UHWAbility_PassiveItem_Magis, BurstVisualEffectCue) == 0x000EF8, "Member 'UHWAbility_PassiveItem_Magis::BurstVisualEffectCue' has a wrong offset!");

// Class Hemingway.HWAbility_Push
// 0x0048 (0x0A08 - 0x09C0)
class UHWAbility_Push : public UHWGameplayAbility
{
public:
	bool                                          bAbilityEndDueToTween;                             // 0x09C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C1[0x7];                                      // 0x09C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWGameplayTween>           TweenPushClass;                                    // 0x09C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PushRange;                                         // 0x09D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TravelSpeedModifier;                               // 0x09D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BumpStunEffect;                                    // 0x09D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            OverlapDamageEffect;                               // 0x09E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             BumpSoundEffect;                                   // 0x09E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BumpSoundEffectSkinKeyword;                        // 0x09F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAbilitySystemComponent*>        AbilitySystemsHit;                                 // 0x09F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnActorBump(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnActorHandleSuccessfulBump(class AActor* SelfActor, class AActor* OtherActor);
	void OnActorInitialBump(class AActor* SelfActor, class AActor* OtherActor);
	void OnActorOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnPushEnded(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget, const EHWEndTweenReason EndTweenReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Push">();
	}
	static class UHWAbility_Push* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Push>();
	}
};
static_assert(alignof(UHWAbility_Push) == 0x000008, "Wrong alignment on UHWAbility_Push");
static_assert(sizeof(UHWAbility_Push) == 0x000A08, "Wrong size on UHWAbility_Push");
static_assert(offsetof(UHWAbility_Push, bAbilityEndDueToTween) == 0x0009C0, "Member 'UHWAbility_Push::bAbilityEndDueToTween' has a wrong offset!");
static_assert(offsetof(UHWAbility_Push, TweenPushClass) == 0x0009C8, "Member 'UHWAbility_Push::TweenPushClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_Push, PushRange) == 0x0009D0, "Member 'UHWAbility_Push::PushRange' has a wrong offset!");
static_assert(offsetof(UHWAbility_Push, TravelSpeedModifier) == 0x0009D4, "Member 'UHWAbility_Push::TravelSpeedModifier' has a wrong offset!");
static_assert(offsetof(UHWAbility_Push, BumpStunEffect) == 0x0009D8, "Member 'UHWAbility_Push::BumpStunEffect' has a wrong offset!");
static_assert(offsetof(UHWAbility_Push, OverlapDamageEffect) == 0x0009E0, "Member 'UHWAbility_Push::OverlapDamageEffect' has a wrong offset!");
static_assert(offsetof(UHWAbility_Push, BumpSoundEffect) == 0x0009E8, "Member 'UHWAbility_Push::BumpSoundEffect' has a wrong offset!");
static_assert(offsetof(UHWAbility_Push, BumpSoundEffectSkinKeyword) == 0x0009F0, "Member 'UHWAbility_Push::BumpSoundEffectSkinKeyword' has a wrong offset!");
static_assert(offsetof(UHWAbility_Push, AbilitySystemsHit) == 0x0009F8, "Member 'UHWAbility_Push::AbilitySystemsHit' has a wrong offset!");

// Class Hemingway.HWAbility_Reflect
// 0x0008 (0x0D78 - 0x0D70)
class UHWAbility_Reflect final : public UHWAbility_Passive
{
public:
	TWeakObjectPtr<class UHWAbilitySystemComponent> OwningASC;                                       // 0x0D70(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDamageBlocked(const struct FBlockDamageEventData& BlockDamageEventData);
	void OnDamageTaken(const struct FDamageEventData& DamageEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Reflect">();
	}
	static class UHWAbility_Reflect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Reflect>();
	}
};
static_assert(alignof(UHWAbility_Reflect) == 0x000008, "Wrong alignment on UHWAbility_Reflect");
static_assert(sizeof(UHWAbility_Reflect) == 0x000D78, "Wrong size on UHWAbility_Reflect");
static_assert(offsetof(UHWAbility_Reflect, OwningASC) == 0x000D70, "Member 'UHWAbility_Reflect::OwningASC' has a wrong offset!");

// Class Hemingway.HWMessageFormatterContext_VIPBoosting
// 0x0010 (0x0038 - 0x0028)
class UHWMessageFormatterContext_VIPBoosting final : public UObject
{
public:
	class FString                                 PlayerName;                                        // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWMessageFormatterContext_VIPBoosting">();
	}
	static class UHWMessageFormatterContext_VIPBoosting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWMessageFormatterContext_VIPBoosting>();
	}
};
static_assert(alignof(UHWMessageFormatterContext_VIPBoosting) == 0x000008, "Wrong alignment on UHWMessageFormatterContext_VIPBoosting");
static_assert(sizeof(UHWMessageFormatterContext_VIPBoosting) == 0x000038, "Wrong size on UHWMessageFormatterContext_VIPBoosting");
static_assert(offsetof(UHWMessageFormatterContext_VIPBoosting, PlayerName) == 0x000028, "Member 'UHWMessageFormatterContext_VIPBoosting::PlayerName' has a wrong offset!");

// Class Hemingway.HWAbility_Trail
// 0x0010 (0x0D88 - 0x0D78)
class UHWAbility_Trail final : public UHWAbility_Deployable
{
public:
	float                                         TrailHitPulsePeriod;                               // 0x0D78(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D7C[0x4];                                      // 0x0D7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           HitPulseTimer;                                     // 0x0D80(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnTrailActivated(class AHWDeployable_Trail* Trail);
	void BP_OnTrailDeactivated(class AHWDeployable_Trail* Trail);
	void OnTrailBeginOverlap(class AHWDeployable_Trail* Trail, const struct FGameplayAbilityTargetDataHandle& OverlappedTarget, const struct FHWSplineOverlapInfo& TrailOverlapInfo);
	void OnTrailEndOverlap(class AHWDeployable_Trail* Trail, const struct FGameplayAbilityTargetDataHandle& OverlappedTarget);
	void OnTrailHitPulse();
	void OnTrailStateChanged(class AHWDeployable_Trail* Trail, const bool bIsTrailActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Trail">();
	}
	static class UHWAbility_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Trail>();
	}
};
static_assert(alignof(UHWAbility_Trail) == 0x000008, "Wrong alignment on UHWAbility_Trail");
static_assert(sizeof(UHWAbility_Trail) == 0x000D88, "Wrong size on UHWAbility_Trail");
static_assert(offsetof(UHWAbility_Trail, TrailHitPulsePeriod) == 0x000D78, "Member 'UHWAbility_Trail::TrailHitPulsePeriod' has a wrong offset!");
static_assert(offsetof(UHWAbility_Trail, HitPulseTimer) == 0x000D80, "Member 'UHWAbility_Trail::HitPulseTimer' has a wrong offset!");

// Class Hemingway.HWPrimaryAssetLabel
// 0x0010 (0x0078 - 0x0068)
class UHWPrimaryAssetLabel : public UPrimaryAssetLabel
{
public:
	TArray<struct FDirectoryPath>                 AdditionalDirectoryPathsToLabel;                   // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPrimaryAssetLabel">();
	}
	static class UHWPrimaryAssetLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPrimaryAssetLabel>();
	}
};
static_assert(alignof(UHWPrimaryAssetLabel) == 0x000008, "Wrong alignment on UHWPrimaryAssetLabel");
static_assert(sizeof(UHWPrimaryAssetLabel) == 0x000078, "Wrong size on UHWPrimaryAssetLabel");
static_assert(offsetof(UHWPrimaryAssetLabel, AdditionalDirectoryPathsToLabel) == 0x000068, "Member 'UHWPrimaryAssetLabel::AdditionalDirectoryPathsToLabel' has a wrong offset!");

// Class Hemingway.HWGameplayAbility_GrantVision
// 0x0008 (0x09C8 - 0x09C0)
class UHWGameplayAbility_GrantVision final : public UHWGameplayAbility
{
public:
	uint8                                         Pad_9C0[0x8];                                      // 0x09C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayAbility_GrantVision">();
	}
	static class UHWGameplayAbility_GrantVision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayAbility_GrantVision>();
	}
};
static_assert(alignof(UHWGameplayAbility_GrantVision) == 0x000008, "Wrong alignment on UHWGameplayAbility_GrantVision");
static_assert(sizeof(UHWGameplayAbility_GrantVision) == 0x0009C8, "Wrong size on UHWGameplayAbility_GrantVision");

// Class Hemingway.HWInhandLevelConfig
// 0x0018 (0x0178 - 0x0160)
class UHWInhandLevelConfig final : public UHWAbilityLevelConfig
{
public:
	TArray<struct FAbilityPhaseDurations>         InhandPhaseDurations;                              // 0x0160(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bOnlyScalePostFireWithAttackSpeed;                 // 0x0170(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInhandLevelConfig">();
	}
	static class UHWInhandLevelConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInhandLevelConfig>();
	}
};
static_assert(alignof(UHWInhandLevelConfig) == 0x000008, "Wrong alignment on UHWInhandLevelConfig");
static_assert(sizeof(UHWInhandLevelConfig) == 0x000178, "Wrong size on UHWInhandLevelConfig");
static_assert(offsetof(UHWInhandLevelConfig, InhandPhaseDurations) == 0x000160, "Member 'UHWInhandLevelConfig::InhandPhaseDurations' has a wrong offset!");
static_assert(offsetof(UHWInhandLevelConfig, bOnlyScalePostFireWithAttackSpeed) == 0x000170, "Member 'UHWInhandLevelConfig::bOnlyScalePostFireWithAttackSpeed' has a wrong offset!");

// Class Hemingway.HWAttributeSet_Deployable
// 0x0000 (0x0140 - 0x0140)
class UHWAttributeSet_Deployable final : public UHWAttributeSet_Core
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Deployable">();
	}
	static class UHWAttributeSet_Deployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Deployable>();
	}
};
static_assert(alignof(UHWAttributeSet_Deployable) == 0x000008, "Wrong alignment on UHWAttributeSet_Deployable");
static_assert(sizeof(UHWAttributeSet_Deployable) == 0x000140, "Wrong size on UHWAttributeSet_Deployable");

// Class Hemingway.HWAbilityTask_Attack_Trail
// 0x0008 (0x0190 - 0x0188)
class UHWAbilityTask_Attack_Trail final : public UHWAbilityTask_Attack_Deployable
{
public:
	class AHWDeployable_Trail*                    Trail;                                             // 0x0188(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AHWDeployable_Trail* GetTrail() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Attack_Trail">();
	}
	static class UHWAbilityTask_Attack_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Attack_Trail>();
	}
};
static_assert(alignof(UHWAbilityTask_Attack_Trail) == 0x000008, "Wrong alignment on UHWAbilityTask_Attack_Trail");
static_assert(sizeof(UHWAbilityTask_Attack_Trail) == 0x000190, "Wrong size on UHWAbilityTask_Attack_Trail");
static_assert(offsetof(UHWAbilityTask_Attack_Trail, Trail) == 0x000188, "Member 'UHWAbilityTask_Attack_Trail::Trail' has a wrong offset!");

// Class Hemingway.HWGameplayEffectComponent_ChangeCollisionState
// 0x0040 (0x0068 - 0x0028)
class UHWGameplayEffectComponent_ChangeCollisionState final : public UHWGameplayEffectComponent
{
public:
	struct FHWCollisionState                      CollisionState;                                    // 0x0028(0x003C)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffectComponent_ChangeCollisionState">();
	}
	static class UHWGameplayEffectComponent_ChangeCollisionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffectComponent_ChangeCollisionState>();
	}
};
static_assert(alignof(UHWGameplayEffectComponent_ChangeCollisionState) == 0x000008, "Wrong alignment on UHWGameplayEffectComponent_ChangeCollisionState");
static_assert(sizeof(UHWGameplayEffectComponent_ChangeCollisionState) == 0x000068, "Wrong size on UHWGameplayEffectComponent_ChangeCollisionState");
static_assert(offsetof(UHWGameplayEffectComponent_ChangeCollisionState, CollisionState) == 0x000028, "Member 'UHWGameplayEffectComponent_ChangeCollisionState::CollisionState' has a wrong offset!");

// Class Hemingway.HWCharacter_AnimInstGod
// 0x0070 (0x0640 - 0x05D0)
class UHWCharacter_AnimInstGod : public UHWCharacter_AnimInstBase
{
public:
	float                                         LocalDirectionAngle;                               // 0x05C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PelvisCurve;                                       // 0x05CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocalDirectionAngleInterpSpeed;                    // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlendArgs                        ActiveMontageToJumpBlendTime;                      // 0x05D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsJumping;                                        // 0x05F0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanLand;                                          // 0x05F1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseNotifyJumpEnds;                                 // 0x05F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F3[0x1];                                      // 0x05F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpTimeAfterMoveCheck;                            // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           JumpCurve;                                         // 0x05F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JumpOffset;                                        // 0x0600(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x4];                                      // 0x0618(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EHWAnimCombatState                            CombatState;                                       // 0x061C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61D[0x3];                                      // 0x061D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         fCombatWarniessTimer;                              // 0x0620(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DisableTurnFromTag;                                // 0x0624(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DisableTurnFromAnimation;                          // 0x0625(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_626[0xA];                                      // 0x0626(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	EHWAnimCombatState                            LastCombatState;                                   // 0x0630(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInCombat;                                         // 0x0631(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAnimCombat;                                       // 0x0632(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_633[0x1];                                      // 0x0633(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         fCombatWarniessTimeLeft;                           // 0x0634(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_638[0x8];                                      // 0x0638(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGodASCUpdated(class UHWAbilitySystemComponent* UpdatedASC, class UHWAbilitySystemComponent* OldAbilitySystem);
	void OnStatusGodTagsUpdated(const struct FGameplayTag& UpdatedStatusTag, int32 NewStackCount);
	void TransCombatToNonCombat();
	void TransNonCombatToCombat();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_AnimInstGod">();
	}
	static class UHWCharacter_AnimInstGod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCharacter_AnimInstGod>();
	}
};
static_assert(alignof(UHWCharacter_AnimInstGod) == 0x000010, "Wrong alignment on UHWCharacter_AnimInstGod");
static_assert(sizeof(UHWCharacter_AnimInstGod) == 0x000640, "Wrong size on UHWCharacter_AnimInstGod");
static_assert(offsetof(UHWCharacter_AnimInstGod, LocalDirectionAngle) == 0x0005C8, "Member 'UHWCharacter_AnimInstGod::LocalDirectionAngle' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, PelvisCurve) == 0x0005CC, "Member 'UHWCharacter_AnimInstGod::PelvisCurve' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, LocalDirectionAngleInterpSpeed) == 0x0005D0, "Member 'UHWCharacter_AnimInstGod::LocalDirectionAngleInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, ActiveMontageToJumpBlendTime) == 0x0005D8, "Member 'UHWCharacter_AnimInstGod::ActiveMontageToJumpBlendTime' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, bIsJumping) == 0x0005F0, "Member 'UHWCharacter_AnimInstGod::bIsJumping' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, bCanLand) == 0x0005F1, "Member 'UHWCharacter_AnimInstGod::bCanLand' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, UseNotifyJumpEnds) == 0x0005F2, "Member 'UHWCharacter_AnimInstGod::UseNotifyJumpEnds' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, JumpTimeAfterMoveCheck) == 0x0005F4, "Member 'UHWCharacter_AnimInstGod::JumpTimeAfterMoveCheck' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, JumpCurve) == 0x0005F8, "Member 'UHWCharacter_AnimInstGod::JumpCurve' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, JumpOffset) == 0x000600, "Member 'UHWCharacter_AnimInstGod::JumpOffset' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, CombatState) == 0x00061C, "Member 'UHWCharacter_AnimInstGod::CombatState' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, fCombatWarniessTimer) == 0x000620, "Member 'UHWCharacter_AnimInstGod::fCombatWarniessTimer' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, DisableTurnFromTag) == 0x000624, "Member 'UHWCharacter_AnimInstGod::DisableTurnFromTag' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, DisableTurnFromAnimation) == 0x000625, "Member 'UHWCharacter_AnimInstGod::DisableTurnFromAnimation' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, LastCombatState) == 0x000630, "Member 'UHWCharacter_AnimInstGod::LastCombatState' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, bInCombat) == 0x000631, "Member 'UHWCharacter_AnimInstGod::bInCombat' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, bAnimCombat) == 0x000632, "Member 'UHWCharacter_AnimInstGod::bAnimCombat' has a wrong offset!");
static_assert(offsetof(UHWCharacter_AnimInstGod, fCombatWarniessTimeLeft) == 0x000634, "Member 'UHWCharacter_AnimInstGod::fCombatWarniessTimeLeft' has a wrong offset!");

// Class Hemingway.HWGameplayEffectComponent_ForcedFiring
// 0x0010 (0x0038 - 0x0028)
class UHWGameplayEffectComponent_ForcedFiring final : public UHWGameplayEffectComponent
{
public:
	EHWForcedCharacterFiringCategory              FiringCategory;                                    // 0x0028(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrioritizationWeight;                              // 0x002C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumFiringRate;                                 // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFiringCount;                                    // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffectComponent_ForcedFiring">();
	}
	static class UHWGameplayEffectComponent_ForcedFiring* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffectComponent_ForcedFiring>();
	}
};
static_assert(alignof(UHWGameplayEffectComponent_ForcedFiring) == 0x000008, "Wrong alignment on UHWGameplayEffectComponent_ForcedFiring");
static_assert(sizeof(UHWGameplayEffectComponent_ForcedFiring) == 0x000038, "Wrong size on UHWGameplayEffectComponent_ForcedFiring");
static_assert(offsetof(UHWGameplayEffectComponent_ForcedFiring, FiringCategory) == 0x000028, "Member 'UHWGameplayEffectComponent_ForcedFiring::FiringCategory' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_ForcedFiring, PrioritizationWeight) == 0x00002C, "Member 'UHWGameplayEffectComponent_ForcedFiring::PrioritizationWeight' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_ForcedFiring, MinimumFiringRate) == 0x000030, "Member 'UHWGameplayEffectComponent_ForcedFiring::MinimumFiringRate' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_ForcedFiring, MaxFiringCount) == 0x000034, "Member 'UHWGameplayEffectComponent_ForcedFiring::MaxFiringCount' has a wrong offset!");

// Class Hemingway.HWGameplayEffectComponent_ForcedMovement
// 0x0018 (0x0040 - 0x0028)
class UHWGameplayEffectComponent_ForcedMovement final : public UHWGameplayEffectComponent
{
public:
	struct FHWForceMovementEffectConfig           ForcedMovementConfig;                              // 0x0028(0x0018)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffectComponent_ForcedMovement">();
	}
	static class UHWGameplayEffectComponent_ForcedMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffectComponent_ForcedMovement>();
	}
};
static_assert(alignof(UHWGameplayEffectComponent_ForcedMovement) == 0x000008, "Wrong alignment on UHWGameplayEffectComponent_ForcedMovement");
static_assert(sizeof(UHWGameplayEffectComponent_ForcedMovement) == 0x000040, "Wrong size on UHWGameplayEffectComponent_ForcedMovement");
static_assert(offsetof(UHWGameplayEffectComponent_ForcedMovement, ForcedMovementConfig) == 0x000028, "Member 'UHWGameplayEffectComponent_ForcedMovement::ForcedMovementConfig' has a wrong offset!");

// Class Hemingway.HWGameplayEffectComponent_GrantEquipment
// 0x0010 (0x0038 - 0x0028)
class UHWGameplayEffectComponent_GrantEquipment final : public UHWGameplayEffectComponent
{
public:
	TArray<struct FHWEquipmentGrantSpecConfig>    EquipmentGrantConfigs;                             // 0x0028(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffectComponent_GrantEquipment">();
	}
	static class UHWGameplayEffectComponent_GrantEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffectComponent_GrantEquipment>();
	}
};
static_assert(alignof(UHWGameplayEffectComponent_GrantEquipment) == 0x000008, "Wrong alignment on UHWGameplayEffectComponent_GrantEquipment");
static_assert(sizeof(UHWGameplayEffectComponent_GrantEquipment) == 0x000038, "Wrong size on UHWGameplayEffectComponent_GrantEquipment");
static_assert(offsetof(UHWGameplayEffectComponent_GrantEquipment, EquipmentGrantConfigs) == 0x000028, "Member 'UHWGameplayEffectComponent_GrantEquipment::EquipmentGrantConfigs' has a wrong offset!");

// Class Hemingway.HWAbilityTask_GameplayGrab
// 0x00C0 (0x0140 - 0x0080)
class UHWAbilityTask_GameplayGrab final : public UAbilityTask
{
public:
	bool                                          bEndGrabOnAbilityEnd;                              // 0x0080(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndGrabOnTaskEnd;                                 // 0x0081(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWGameplayGrab* GrabInstance, class AHWCharacter_Base* GrabSource, class AHWCharacter_Base* GrabTarget, const EHWEndGrabReason EndGrabReason)> OnGrabStartedDel; // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayGrab* GrabInstance, class AHWCharacter_Base* GrabSource, class AHWCharacter_Base* GrabTarget, const EHWEndGrabReason EndGrabReason)> OnGrabEndedDel; // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UHWGameplayGrab*>                GrabInstances;                                     // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayGrab>            GrabClass;                                         // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayAbility*                       GrabInstigatingAbility;                            // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacter_Base*                      GrabInstigator;                                    // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacter_Base*                      GrabSource;                                        // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AHWCharacter_Base*>              GrabTargets;                                       // 0x00D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         DurationOverride;                                  // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGrabControlType                              GrabControlType;                                   // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED[0x53];                                      // 0x00ED(0x0053)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_GameplayGrab* PerformGameplayGrabOnTarget(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class UHWGameplayGrab> Grab, class AHWCharacter_Base* GrabSource_0, class AHWCharacter_Base* GrabTarget, const float DurationOverride_0);
	static class UHWAbilityTask_GameplayGrab* PerformGameplayGrabOnTargets(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class UHWGameplayGrab> Grab, class AHWCharacter_Base* GrabSource_0, const TArray<class AHWCharacter_Base*>& GrabTargets_0, const float DurationOverride_0);

	void HandleTagUpdated_CCImmunity(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void OnGrabEnded(class UHWGameplayGrab* Grab, const EHWEndGrabReason EndGrabReason);
	void OnGrabStarted(class UHWGameplayGrab* Grab);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_GameplayGrab">();
	}
	static class UHWAbilityTask_GameplayGrab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_GameplayGrab>();
	}
};
static_assert(alignof(UHWAbilityTask_GameplayGrab) == 0x000008, "Wrong alignment on UHWAbilityTask_GameplayGrab");
static_assert(sizeof(UHWAbilityTask_GameplayGrab) == 0x000140, "Wrong size on UHWAbilityTask_GameplayGrab");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, bEndGrabOnAbilityEnd) == 0x000080, "Member 'UHWAbilityTask_GameplayGrab::bEndGrabOnAbilityEnd' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, bEndGrabOnTaskEnd) == 0x000081, "Member 'UHWAbilityTask_GameplayGrab::bEndGrabOnTaskEnd' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, OnGrabStartedDel) == 0x000088, "Member 'UHWAbilityTask_GameplayGrab::OnGrabStartedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, OnGrabEndedDel) == 0x000098, "Member 'UHWAbilityTask_GameplayGrab::OnGrabEndedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, GrabInstances) == 0x0000A8, "Member 'UHWAbilityTask_GameplayGrab::GrabInstances' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, GrabClass) == 0x0000B8, "Member 'UHWAbilityTask_GameplayGrab::GrabClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, GrabInstigatingAbility) == 0x0000C0, "Member 'UHWAbilityTask_GameplayGrab::GrabInstigatingAbility' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, GrabInstigator) == 0x0000C8, "Member 'UHWAbilityTask_GameplayGrab::GrabInstigator' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, GrabSource) == 0x0000D0, "Member 'UHWAbilityTask_GameplayGrab::GrabSource' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, GrabTargets) == 0x0000D8, "Member 'UHWAbilityTask_GameplayGrab::GrabTargets' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, DurationOverride) == 0x0000E8, "Member 'UHWAbilityTask_GameplayGrab::DurationOverride' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayGrab, GrabControlType) == 0x0000EC, "Member 'UHWAbilityTask_GameplayGrab::GrabControlType' has a wrong offset!");

// Class Hemingway.HWGameplayEffectComponent_Immunity
// 0x0030 (0x0068 - 0x0038)
class UHWGameplayEffectComponent_Immunity final : public UImmunityGameplayEffectComponent
{
public:
	bool                                          bShouldImmuneGameplayEffectsFromSelf;              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffectCustomApplicationRequirement>> ImmunityRequirements;     // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyOnImmuned;                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bShouldRemoveWhenImmunityBlockEffect;              // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCleanseCCsOnApplication;                          // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWDeathImmunityHealthThresholdType           DeathImmunityHealthThresholdType;                  // 0x0062(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_63[0x1];                                       // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathImmunityHealthThresholdValue;                 // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffectComponent_Immunity">();
	}
	static class UHWGameplayEffectComponent_Immunity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffectComponent_Immunity>();
	}
};
static_assert(alignof(UHWGameplayEffectComponent_Immunity) == 0x000008, "Wrong alignment on UHWGameplayEffectComponent_Immunity");
static_assert(sizeof(UHWGameplayEffectComponent_Immunity) == 0x000068, "Wrong size on UHWGameplayEffectComponent_Immunity");
static_assert(offsetof(UHWGameplayEffectComponent_Immunity, bShouldImmuneGameplayEffectsFromSelf) == 0x000038, "Member 'UHWGameplayEffectComponent_Immunity::bShouldImmuneGameplayEffectsFromSelf' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_Immunity, ImmunityRequirements) == 0x000040, "Member 'UHWGameplayEffectComponent_Immunity::ImmunityRequirements' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_Immunity, EffectsToApplyOnImmuned) == 0x000050, "Member 'UHWGameplayEffectComponent_Immunity::EffectsToApplyOnImmuned' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_Immunity, bShouldRemoveWhenImmunityBlockEffect) == 0x000060, "Member 'UHWGameplayEffectComponent_Immunity::bShouldRemoveWhenImmunityBlockEffect' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_Immunity, bCleanseCCsOnApplication) == 0x000061, "Member 'UHWGameplayEffectComponent_Immunity::bCleanseCCsOnApplication' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_Immunity, DeathImmunityHealthThresholdType) == 0x000062, "Member 'UHWGameplayEffectComponent_Immunity::DeathImmunityHealthThresholdType' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectComponent_Immunity, DeathImmunityHealthThresholdValue) == 0x000064, "Member 'UHWGameplayEffectComponent_Immunity::DeathImmunityHealthThresholdValue' has a wrong offset!");

// Class Hemingway.HWSpringArmComponent
// 0x0010 (0x03B0 - 0x03A0)
class UHWSpringArmComponent final : public USpringArmComponent
{
public:
	bool                                          bUseLocalControlRotation;                          // 0x03A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCurrentLocalViewTarget;                         // 0x03A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A2[0xE];                                      // 0x03A2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSpringArmComponent">();
	}
	static class UHWSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSpringArmComponent>();
	}
};
static_assert(alignof(UHWSpringArmComponent) == 0x000010, "Wrong alignment on UHWSpringArmComponent");
static_assert(sizeof(UHWSpringArmComponent) == 0x0003B0, "Wrong size on UHWSpringArmComponent");
static_assert(offsetof(UHWSpringArmComponent, bUseLocalControlRotation) == 0x0003A0, "Member 'UHWSpringArmComponent::bUseLocalControlRotation' has a wrong offset!");
static_assert(offsetof(UHWSpringArmComponent, bIsCurrentLocalViewTarget) == 0x0003A1, "Member 'UHWSpringArmComponent::bIsCurrentLocalViewTarget' has a wrong offset!");

// Class Hemingway.HWGEExecCalc
// 0x0000 (0x0040 - 0x0040)
class UHWGEExecCalc : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEExecCalc">();
	}
	static class UHWGEExecCalc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEExecCalc>();
	}
};
static_assert(alignof(UHWGEExecCalc) == 0x000008, "Wrong alignment on UHWGEExecCalc");
static_assert(sizeof(UHWGEExecCalc) == 0x000040, "Wrong size on UHWGEExecCalc");

// Class Hemingway.HWGEExecCalc_DamageTarget
// 0x0000 (0x0040 - 0x0040)
class UHWGEExecCalc_DamageTarget : public UHWGEExecCalc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEExecCalc_DamageTarget">();
	}
	static class UHWGEExecCalc_DamageTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEExecCalc_DamageTarget>();
	}
};
static_assert(alignof(UHWGEExecCalc_DamageTarget) == 0x000008, "Wrong alignment on UHWGEExecCalc_DamageTarget");
static_assert(sizeof(UHWGEExecCalc_DamageTarget) == 0x000040, "Wrong size on UHWGEExecCalc_DamageTarget");

// Class Hemingway.HWGEExecCalc_ExecuteTarget
// 0x0000 (0x0040 - 0x0040)
class UHWGEExecCalc_ExecuteTarget final : public UHWGEExecCalc_DamageTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEExecCalc_ExecuteTarget">();
	}
	static class UHWGEExecCalc_ExecuteTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEExecCalc_ExecuteTarget>();
	}
};
static_assert(alignof(UHWGEExecCalc_ExecuteTarget) == 0x000008, "Wrong alignment on UHWGEExecCalc_ExecuteTarget");
static_assert(sizeof(UHWGEExecCalc_ExecuteTarget) == 0x000040, "Wrong size on UHWGEExecCalc_ExecuteTarget");

// Class Hemingway.HWAbilityTask_PhasedMontage
// 0x0070 (0x00F0 - 0x0080)
class UHWAbilityTask_PhasedMontage final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayTag& PhaseTag, float PhaseDuration, class UHWAbilityTask_PhasedMontage* Task)> OnMontageEnded; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bStopMontageOnInterrupt;                           // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageToPlay;                                     // 0x0098(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGameplayTag& PhaseTag, float PhaseDuration, class UHWAbilityTask_PhasedMontage* Task)> OnPhaseStarted; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& PhaseTag, float PhaseDuration, class UHWAbilityTask_PhasedMontage* Task)> OnPhaseEnded; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_PhasedMontage* PlayPhasedMontage(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay_0, float Rate, class FName StartSection, float RootMotionTranslationScale, bool StartWithRootMotionDisabled, bool ContinueMontageOnAbilityEnd, bool ContinueMontageOnAbilityCancel);

	class UAnimInstance* GetAnimInstance() const;
	class UAnimMontage* GetMontage() const;
	bool IsMontagePlaying() const;
	bool IsMontageStopped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_PhasedMontage">();
	}
	static class UHWAbilityTask_PhasedMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_PhasedMontage>();
	}
};
static_assert(alignof(UHWAbilityTask_PhasedMontage) == 0x000008, "Wrong alignment on UHWAbilityTask_PhasedMontage");
static_assert(sizeof(UHWAbilityTask_PhasedMontage) == 0x0000F0, "Wrong size on UHWAbilityTask_PhasedMontage");
static_assert(offsetof(UHWAbilityTask_PhasedMontage, OnMontageEnded) == 0x000080, "Member 'UHWAbilityTask_PhasedMontage::OnMontageEnded' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_PhasedMontage, bStopMontageOnInterrupt) == 0x000090, "Member 'UHWAbilityTask_PhasedMontage::bStopMontageOnInterrupt' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_PhasedMontage, MontageToPlay) == 0x000098, "Member 'UHWAbilityTask_PhasedMontage::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_PhasedMontage, OnPhaseStarted) == 0x0000B8, "Member 'UHWAbilityTask_PhasedMontage::OnPhaseStarted' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_PhasedMontage, OnPhaseEnded) == 0x0000C8, "Member 'UHWAbilityTask_PhasedMontage::OnPhaseEnded' has a wrong offset!");

// Class Hemingway.HWGEExecCalc_ForceKillTarget
// 0x0000 (0x0040 - 0x0040)
class UHWGEExecCalc_ForceKillTarget final : public UHWGEExecCalc_DamageTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEExecCalc_ForceKillTarget">();
	}
	static class UHWGEExecCalc_ForceKillTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEExecCalc_ForceKillTarget>();
	}
};
static_assert(alignof(UHWGEExecCalc_ForceKillTarget) == 0x000008, "Wrong alignment on UHWGEExecCalc_ForceKillTarget");
static_assert(sizeof(UHWGEExecCalc_ForceKillTarget) == 0x000040, "Wrong size on UHWGEExecCalc_ForceKillTarget");

// Class Hemingway.HWAccoladeComponent
// 0x0030 (0x00D0 - 0x00A0)
class UHWAccoladeComponent final : public UHWActorComponent
{
public:
	TMulticastInlineDelegate<void(class AHWPlayerStatsTracker* PlayerStatsTracker, const struct FGameplayTag& AccoladeTag, const struct FHWEventContext& AccoladeContext)> OnNewPlayerAccoladeAdded; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamStatsTracker* TeamStatsTracker, const struct FGameplayTag& AccoladeTag, const struct FHWEventContext& AccoladeContext)> OnNewTeamAccoladeAdded; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHWAccoladeRecord>              AccoladeRecords;                                   // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddPlayerAccoladeEvent(const struct FGameplayTag& AccoladeTag, const struct FHWEventContext& AccoladeContext);
	void AddTeamAccoladeEvent(const struct FGameplayTag& AccoladeTag, const struct FHWEventContext& AccoladeContext);
	void MulticastSendPlayerAccoladeToClient(const struct FGameplayTag& AccoladeTag, const struct FHWEventContext& AccoladeContext);
	void MulticastSendTeamAccoladeToClient(const struct FGameplayTag& AccoladeTag, const struct FHWEventContext& AccoladeContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAccoladeComponent">();
	}
	static class UHWAccoladeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAccoladeComponent>();
	}
};
static_assert(alignof(UHWAccoladeComponent) == 0x000008, "Wrong alignment on UHWAccoladeComponent");
static_assert(sizeof(UHWAccoladeComponent) == 0x0000D0, "Wrong size on UHWAccoladeComponent");
static_assert(offsetof(UHWAccoladeComponent, OnNewPlayerAccoladeAdded) == 0x0000A0, "Member 'UHWAccoladeComponent::OnNewPlayerAccoladeAdded' has a wrong offset!");
static_assert(offsetof(UHWAccoladeComponent, OnNewTeamAccoladeAdded) == 0x0000B0, "Member 'UHWAccoladeComponent::OnNewTeamAccoladeAdded' has a wrong offset!");
static_assert(offsetof(UHWAccoladeComponent, AccoladeRecords) == 0x0000C0, "Member 'UHWAccoladeComponent::AccoladeRecords' has a wrong offset!");

// Class Hemingway.HWGEExecCalc_GoldAndXP
// 0x0000 (0x0040 - 0x0040)
class UHWGEExecCalc_GoldAndXP final : public UHWGEExecCalc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEExecCalc_GoldAndXP">();
	}
	static class UHWGEExecCalc_GoldAndXP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEExecCalc_GoldAndXP>();
	}
};
static_assert(alignof(UHWGEExecCalc_GoldAndXP) == 0x000008, "Wrong alignment on UHWGEExecCalc_GoldAndXP");
static_assert(sizeof(UHWGEExecCalc_GoldAndXP) == 0x000040, "Wrong size on UHWGEExecCalc_GoldAndXP");

// Class Hemingway.HWGEExecCalc_Heal
// 0x0000 (0x0040 - 0x0040)
class UHWGEExecCalc_Heal final : public UHWGEExecCalc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEExecCalc_Heal">();
	}
	static class UHWGEExecCalc_Heal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEExecCalc_Heal>();
	}
};
static_assert(alignof(UHWGEExecCalc_Heal) == 0x000008, "Wrong alignment on UHWGEExecCalc_Heal");
static_assert(sizeof(UHWGEExecCalc_Heal) == 0x000040, "Wrong size on UHWGEExecCalc_Heal");

// Class Hemingway.HWGEExecCalc_LifetimeModification
// 0x0000 (0x0040 - 0x0040)
class UHWGEExecCalc_LifetimeModification final : public UHWGEExecCalc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEExecCalc_LifetimeModification">();
	}
	static class UHWGEExecCalc_LifetimeModification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEExecCalc_LifetimeModification>();
	}
};
static_assert(alignof(UHWGEExecCalc_LifetimeModification) == 0x000008, "Wrong alignment on UHWGEExecCalc_LifetimeModification");
static_assert(sizeof(UHWGEExecCalc_LifetimeModification) == 0x000040, "Wrong size on UHWGEExecCalc_LifetimeModification");

// Class Hemingway.HWAbilityTask_SimulatedSpawnActor
// 0x0008 (0x0088 - 0x0080)
class UHWAbilityTask_SimulatedSpawnActor : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_SimulatedSpawnActor">();
	}
	static class UHWAbilityTask_SimulatedSpawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_SimulatedSpawnActor>();
	}
};
static_assert(alignof(UHWAbilityTask_SimulatedSpawnActor) == 0x000008, "Wrong alignment on UHWAbilityTask_SimulatedSpawnActor");
static_assert(sizeof(UHWAbilityTask_SimulatedSpawnActor) == 0x000088, "Wrong size on UHWAbilityTask_SimulatedSpawnActor");

// Class Hemingway.HWAbilityTask_SpawnSpecialFXActor
// 0x00B8 (0x0140 - 0x0088)
class UHWAbilityTask_SpawnSpecialFXActor final : public UHWAbilityTask_SimulatedSpawnActor
{
public:
	TArray<TWeakObjectPtr<class APlayerController>> NetRelevantControllers;                          // 0x0088(0x0010)(Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x00A0(0x0060)(Net, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWActor_SpecialFX* SpawnedFXActor)> OnBeginSpawningDel;     // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWActor_SpecialFX* SpawnedFXActor)> OnSpawnedDel;           // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AHWActor_SpecialFX>         SpecialFXActorClass;                               // 0x0120(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnedActorLifetime;                              // 0x0128(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachToCharacterOwner;                           // 0x012C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0130(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_SpawnSpecialFXActor* SpawnSpecialFXActorTask(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class AHWActor_SpecialFX> SpecialFXActorClass_0, const struct FTransform& InSpawnTransform, float ActorLifetime, bool AttachToOwner, class FName SocketName_0);
	static class UHWAbilityTask_SpawnSpecialFXActor* SpawnSpecialFXActorTaskUsingAimData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class AHWActor_SpecialFX> SpecialFXActorClass_0, const struct FGameplayAbilityTargetDataHandle& TargetAimData, float ActorLifetime, bool bAttachToOwner, class FName SocketName_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_SpawnSpecialFXActor">();
	}
	static class UHWAbilityTask_SpawnSpecialFXActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_SpawnSpecialFXActor>();
	}
};
static_assert(alignof(UHWAbilityTask_SpawnSpecialFXActor) == 0x000010, "Wrong alignment on UHWAbilityTask_SpawnSpecialFXActor");
static_assert(sizeof(UHWAbilityTask_SpawnSpecialFXActor) == 0x000140, "Wrong size on UHWAbilityTask_SpawnSpecialFXActor");
static_assert(offsetof(UHWAbilityTask_SpawnSpecialFXActor, NetRelevantControllers) == 0x000088, "Member 'UHWAbilityTask_SpawnSpecialFXActor::NetRelevantControllers' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnSpecialFXActor, SpawnTransform) == 0x0000A0, "Member 'UHWAbilityTask_SpawnSpecialFXActor::SpawnTransform' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnSpecialFXActor, OnBeginSpawningDel) == 0x000100, "Member 'UHWAbilityTask_SpawnSpecialFXActor::OnBeginSpawningDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnSpecialFXActor, OnSpawnedDel) == 0x000110, "Member 'UHWAbilityTask_SpawnSpecialFXActor::OnSpawnedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnSpecialFXActor, SpecialFXActorClass) == 0x000120, "Member 'UHWAbilityTask_SpawnSpecialFXActor::SpecialFXActorClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnSpecialFXActor, SpawnedActorLifetime) == 0x000128, "Member 'UHWAbilityTask_SpawnSpecialFXActor::SpawnedActorLifetime' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnSpecialFXActor, bAttachToCharacterOwner) == 0x00012C, "Member 'UHWAbilityTask_SpawnSpecialFXActor::bAttachToCharacterOwner' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnSpecialFXActor, SocketName) == 0x000130, "Member 'UHWAbilityTask_SpawnSpecialFXActor::SocketName' has a wrong offset!");

// Class Hemingway.HWGEExecCalc_ManaRegen
// 0x0000 (0x0040 - 0x0040)
class UHWGEExecCalc_ManaRegen final : public UHWGEExecCalc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEExecCalc_ManaRegen">();
	}
	static class UHWGEExecCalc_ManaRegen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEExecCalc_ManaRegen>();
	}
};
static_assert(alignof(UHWGEExecCalc_ManaRegen) == 0x000008, "Wrong alignment on UHWGEExecCalc_ManaRegen");
static_assert(sizeof(UHWGEExecCalc_ManaRegen) == 0x000040, "Wrong size on UHWGEExecCalc_ManaRegen");

// Class Hemingway.HWCharacterInfo
// 0x0138 (0x0168 - 0x0030)
class UHWCharacterInfo final : public UPrimaryDataAsset
{
public:
	TSubclassOf<class AHWCharacter_Base>          CharacterClass;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CharacterTag;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySet*                          AbilitySet;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySet*                          CommonAbilitySet;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            CharacterInitializeEffectClass;                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWPassiveMeterComponent>   PassiveMeterClass;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAbilitySystemReplicationModeOverride;          // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayEffectReplicationMode                AbilitySystemReplicationModeOverride;              // 0x0061(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   CharacterLevelsHandle;                             // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            LevelUpEffectClass;                                // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWInventoryManagerComponent> InventoryManagerClass;                           // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           DefaultBehaviorTree;                               // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UBehaviorTree*> DynamicBehaviorTrees;                            // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DefaultDetectionRange;                             // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWVisibilityComponent_PlayableCharacter> DefaultVisibilityComponentClass;     // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              EmoteItemIdsByTag;                                 // 0x0110(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWFamiliarManagerComponent> FamiliarManagerComponentClass;                    // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	int32 GetEmoteItemForTag(const struct FGameplayTag& EmoteTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacterInfo">();
	}
	static class UHWCharacterInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCharacterInfo>();
	}
};
static_assert(alignof(UHWCharacterInfo) == 0x000008, "Wrong alignment on UHWCharacterInfo");
static_assert(sizeof(UHWCharacterInfo) == 0x000168, "Wrong size on UHWCharacterInfo");
static_assert(offsetof(UHWCharacterInfo, CharacterClass) == 0x000030, "Member 'UHWCharacterInfo::CharacterClass' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, CharacterTag) == 0x000038, "Member 'UHWCharacterInfo::CharacterTag' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, AbilitySet) == 0x000040, "Member 'UHWCharacterInfo::AbilitySet' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, CommonAbilitySet) == 0x000048, "Member 'UHWCharacterInfo::CommonAbilitySet' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, CharacterInitializeEffectClass) == 0x000050, "Member 'UHWCharacterInfo::CharacterInitializeEffectClass' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, PassiveMeterClass) == 0x000058, "Member 'UHWCharacterInfo::PassiveMeterClass' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, bUseAbilitySystemReplicationModeOverride) == 0x000060, "Member 'UHWCharacterInfo::bUseAbilitySystemReplicationModeOverride' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, AbilitySystemReplicationModeOverride) == 0x000061, "Member 'UHWCharacterInfo::AbilitySystemReplicationModeOverride' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, CharacterLevelsHandle) == 0x000068, "Member 'UHWCharacterInfo::CharacterLevelsHandle' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, LevelUpEffectClass) == 0x000078, "Member 'UHWCharacterInfo::LevelUpEffectClass' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, InventoryManagerClass) == 0x000080, "Member 'UHWCharacterInfo::InventoryManagerClass' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, DefaultBehaviorTree) == 0x000088, "Member 'UHWCharacterInfo::DefaultBehaviorTree' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, DynamicBehaviorTrees) == 0x0000B0, "Member 'UHWCharacterInfo::DynamicBehaviorTrees' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, DefaultDetectionRange) == 0x000100, "Member 'UHWCharacterInfo::DefaultDetectionRange' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, DefaultVisibilityComponentClass) == 0x000108, "Member 'UHWCharacterInfo::DefaultVisibilityComponentClass' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, EmoteItemIdsByTag) == 0x000110, "Member 'UHWCharacterInfo::EmoteItemIdsByTag' has a wrong offset!");
static_assert(offsetof(UHWCharacterInfo, FamiliarManagerComponentClass) == 0x000160, "Member 'UHWCharacterInfo::FamiliarManagerComponentClass' has a wrong offset!");

// Class Hemingway.HWGEExecCalc_PhysicsImpulse
// 0x0000 (0x0040 - 0x0040)
class UHWGEExecCalc_PhysicsImpulse final : public UHWGEExecCalc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEExecCalc_PhysicsImpulse">();
	}
	static class UHWGEExecCalc_PhysicsImpulse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEExecCalc_PhysicsImpulse>();
	}
};
static_assert(alignof(UHWGEExecCalc_PhysicsImpulse) == 0x000008, "Wrong alignment on UHWGEExecCalc_PhysicsImpulse");
static_assert(sizeof(UHWGEExecCalc_PhysicsImpulse) == 0x000040, "Wrong size on UHWGEExecCalc_PhysicsImpulse");

// Class Hemingway.HWGameplayCueNotify_PostProcess
// 0x0080 (0x03E8 - 0x0368)
class AHWGameplayCueNotify_PostProcess : public AHWGameplayCueNotify_Actor
{
public:
	TWeakObjectPtr<class AHWCharacter_Base>       OwningCharacter;                                   // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWSpecialEffect                       SpecialEffect;                                     // 0x0370(0x0070)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UHWFXCurveComponent*                    FxCurveComponent;                                  // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_PostProcess">();
	}
	static class AHWGameplayCueNotify_PostProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameplayCueNotify_PostProcess>();
	}
};
static_assert(alignof(AHWGameplayCueNotify_PostProcess) == 0x000008, "Wrong alignment on AHWGameplayCueNotify_PostProcess");
static_assert(sizeof(AHWGameplayCueNotify_PostProcess) == 0x0003E8, "Wrong size on AHWGameplayCueNotify_PostProcess");
static_assert(offsetof(AHWGameplayCueNotify_PostProcess, OwningCharacter) == 0x000368, "Member 'AHWGameplayCueNotify_PostProcess::OwningCharacter' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_PostProcess, SpecialEffect) == 0x000370, "Member 'AHWGameplayCueNotify_PostProcess::SpecialEffect' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_PostProcess, FxCurveComponent) == 0x0003E0, "Member 'AHWGameplayCueNotify_PostProcess::FxCurveComponent' has a wrong offset!");

// Class Hemingway.HWGameplayCueNotify_Tether
// 0x0060 (0x03C8 - 0x0368)
class AHWGameplayCueNotify_Tether : public AHWGameplayCueNotify_Actor
{
public:
	class USceneComponent*                        Root;                                              // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWTetherType                                 TetherType;                                        // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x3];                                      // 0x0371(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTetherLength;                                   // 0x0374(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  TetherInstigator;                                  // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseEffectCauserAsTetherInstigator;                // 0x0380(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               InsigatorAttachRuleLocation;                       // 0x0381(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               InsigatorAttachRuleRotation;                       // 0x0382(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               InsigatorAttachRuleScale;                          // 0x0383(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InstigatorAttachSocket;                            // 0x0384(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  TetherTarget;                                      // 0x038C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TargetAttachSocket;                                // 0x0394(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWNiagaraComponent*                    TetherBeamFX;                                      // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BeamEndPointParamName;                             // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BeamLifetimeParamName;                             // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeamLifetime;                                      // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWSplinePathMeshManagerComponent*      SplineTether;                                      // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeamTetherVisualsActivated();
	void OnBeamTetherVisualsDeactivated();
	void OnSplineTetherVisualsActivated();
	void OnSplineTetherVisualsDeactivated();
	void UpdateBeamTetherEndPoint(const struct FVector& EndPoint);
	void UpdateSplineTetherPoints(const struct FVector& StartPoint, const struct FVector& EndPoint);
	void UpdateTetherLocations();

	struct FVector GetTetherEndPoint() const;
	struct FVector GetTetherStartPoint() const;
	bool IsActorValidForTether(const class AActor* Target) const;
	bool ShouldTetherBeHidden() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_Tether">();
	}
	static class AHWGameplayCueNotify_Tether* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameplayCueNotify_Tether>();
	}
};
static_assert(alignof(AHWGameplayCueNotify_Tether) == 0x000008, "Wrong alignment on AHWGameplayCueNotify_Tether");
static_assert(sizeof(AHWGameplayCueNotify_Tether) == 0x0003C8, "Wrong size on AHWGameplayCueNotify_Tether");
static_assert(offsetof(AHWGameplayCueNotify_Tether, Root) == 0x000368, "Member 'AHWGameplayCueNotify_Tether::Root' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, TetherType) == 0x000370, "Member 'AHWGameplayCueNotify_Tether::TetherType' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, MaxTetherLength) == 0x000374, "Member 'AHWGameplayCueNotify_Tether::MaxTetherLength' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, TetherInstigator) == 0x000378, "Member 'AHWGameplayCueNotify_Tether::TetherInstigator' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, bUseEffectCauserAsTetherInstigator) == 0x000380, "Member 'AHWGameplayCueNotify_Tether::bUseEffectCauserAsTetherInstigator' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, InsigatorAttachRuleLocation) == 0x000381, "Member 'AHWGameplayCueNotify_Tether::InsigatorAttachRuleLocation' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, InsigatorAttachRuleRotation) == 0x000382, "Member 'AHWGameplayCueNotify_Tether::InsigatorAttachRuleRotation' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, InsigatorAttachRuleScale) == 0x000383, "Member 'AHWGameplayCueNotify_Tether::InsigatorAttachRuleScale' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, InstigatorAttachSocket) == 0x000384, "Member 'AHWGameplayCueNotify_Tether::InstigatorAttachSocket' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, TetherTarget) == 0x00038C, "Member 'AHWGameplayCueNotify_Tether::TetherTarget' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, TargetAttachSocket) == 0x000394, "Member 'AHWGameplayCueNotify_Tether::TargetAttachSocket' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, TetherBeamFX) == 0x0003A0, "Member 'AHWGameplayCueNotify_Tether::TetherBeamFX' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, BeamEndPointParamName) == 0x0003A8, "Member 'AHWGameplayCueNotify_Tether::BeamEndPointParamName' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, BeamLifetimeParamName) == 0x0003B0, "Member 'AHWGameplayCueNotify_Tether::BeamLifetimeParamName' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, BeamLifetime) == 0x0003B8, "Member 'AHWGameplayCueNotify_Tether::BeamLifetime' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Tether, SplineTether) == 0x0003C0, "Member 'AHWGameplayCueNotify_Tether::SplineTether' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_AttackSpeed
// 0x01E0 (0x0C98 - 0x0AB8)
class UHWGameplayEffect_AttackSpeed : public UHWGameplayEffect
{
public:
	struct FGameplayEffectModifierMagnitude       AttackSpeedModifierMagnitude;                      // 0x0AB8(0x01E0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_AttackSpeed">();
	}
	static class UHWGameplayEffect_AttackSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_AttackSpeed>();
	}
};
static_assert(alignof(UHWGameplayEffect_AttackSpeed) == 0x000008, "Wrong alignment on UHWGameplayEffect_AttackSpeed");
static_assert(sizeof(UHWGameplayEffect_AttackSpeed) == 0x000C98, "Wrong size on UHWGameplayEffect_AttackSpeed");
static_assert(offsetof(UHWGameplayEffect_AttackSpeed, AttackSpeedModifierMagnitude) == 0x000AB8, "Member 'UHWGameplayEffect_AttackSpeed::AttackSpeedModifierMagnitude' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_CCImmunity
// 0x0000 (0x0AB8 - 0x0AB8)
class UHWGameplayEffect_CCImmunity : public UHWGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_CCImmunity">();
	}
	static class UHWGameplayEffect_CCImmunity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_CCImmunity>();
	}
};
static_assert(alignof(UHWGameplayEffect_CCImmunity) == 0x000008, "Wrong alignment on UHWGameplayEffect_CCImmunity");
static_assert(sizeof(UHWGameplayEffect_CCImmunity) == 0x000AB8, "Wrong size on UHWGameplayEffect_CCImmunity");

// Class Hemingway.HWGameplayEffect_Dead
// 0x0000 (0x0AB8 - 0x0AB8)
class UHWGameplayEffect_Dead final : public UHWGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Dead">();
	}
	static class UHWGameplayEffect_Dead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Dead>();
	}
};
static_assert(alignof(UHWGameplayEffect_Dead) == 0x000008, "Wrong alignment on UHWGameplayEffect_Dead");
static_assert(sizeof(UHWGameplayEffect_Dead) == 0x000AB8, "Wrong size on UHWGameplayEffect_Dead");

// Class Hemingway.HWGameplayEffect_Disarm
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Disarm : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Disarm">();
	}
	static class UHWGameplayEffect_Disarm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Disarm>();
	}
};
static_assert(alignof(UHWGameplayEffect_Disarm) == 0x000008, "Wrong alignment on UHWGameplayEffect_Disarm");
static_assert(sizeof(UHWGameplayEffect_Disarm) == 0x000AC8, "Wrong size on UHWGameplayEffect_Disarm");

// Class Hemingway.HWGameplayEffect_Fear
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Fear : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Fear">();
	}
	static class UHWGameplayEffect_Fear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Fear>();
	}
};
static_assert(alignof(UHWGameplayEffect_Fear) == 0x000008, "Wrong alignment on UHWGameplayEffect_Fear");
static_assert(sizeof(UHWGameplayEffect_Fear) == 0x000AC8, "Wrong size on UHWGameplayEffect_Fear");

// Class Hemingway.HWGameplayEffect_Heal
// 0x0058 (0x0B10 - 0x0AB8)
class UHWGameplayEffect_Heal : public UHWGameplayEffect
{
public:
	TMap<struct FGameplayTag, struct FGameplayEffectModifierMagnitude> HealPowerScalingFactors;      // 0x0AB8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bApplyCasterHealingDealtModifers;                  // 0x0B08(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyTargetHealingTakenModifers;                  // 0x0B09(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0A[0x6];                                      // 0x0B0A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Heal">();
	}
	static class UHWGameplayEffect_Heal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Heal>();
	}
};
static_assert(alignof(UHWGameplayEffect_Heal) == 0x000008, "Wrong alignment on UHWGameplayEffect_Heal");
static_assert(sizeof(UHWGameplayEffect_Heal) == 0x000B10, "Wrong size on UHWGameplayEffect_Heal");
static_assert(offsetof(UHWGameplayEffect_Heal, HealPowerScalingFactors) == 0x000AB8, "Member 'UHWGameplayEffect_Heal::HealPowerScalingFactors' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Heal, bApplyCasterHealingDealtModifers) == 0x000B08, "Member 'UHWGameplayEffect_Heal::bApplyCasterHealingDealtModifers' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_Heal, bApplyTargetHealingTakenModifers) == 0x000B09, "Member 'UHWGameplayEffect_Heal::bApplyTargetHealingTakenModifers' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_KnockbackImmunity
// 0x0000 (0x0AB8 - 0x0AB8)
class UHWGameplayEffect_KnockbackImmunity final : public UHWGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_KnockbackImmunity">();
	}
	static class UHWGameplayEffect_KnockbackImmunity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_KnockbackImmunity>();
	}
};
static_assert(alignof(UHWGameplayEffect_KnockbackImmunity) == 0x000008, "Wrong alignment on UHWGameplayEffect_KnockbackImmunity");
static_assert(sizeof(UHWGameplayEffect_KnockbackImmunity) == 0x000AB8, "Wrong size on UHWGameplayEffect_KnockbackImmunity");

// Class Hemingway.HWGameplayEffect_LifeSteal
// 0x0000 (0x0B10 - 0x0B10)
class UHWGameplayEffect_LifeSteal final : public UHWGameplayEffect_Heal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_LifeSteal">();
	}
	static class UHWGameplayEffect_LifeSteal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_LifeSteal>();
	}
};
static_assert(alignof(UHWGameplayEffect_LifeSteal) == 0x000008, "Wrong alignment on UHWGameplayEffect_LifeSteal");
static_assert(sizeof(UHWGameplayEffect_LifeSteal) == 0x000B10, "Wrong size on UHWGameplayEffect_LifeSteal");

// Class Hemingway.HWGameplayEffect_Mesmerize
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Mesmerize final : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Mesmerize">();
	}
	static class UHWGameplayEffect_Mesmerize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Mesmerize>();
	}
};
static_assert(alignof(UHWGameplayEffect_Mesmerize) == 0x000008, "Wrong alignment on UHWGameplayEffect_Mesmerize");
static_assert(sizeof(UHWGameplayEffect_Mesmerize) == 0x000AC8, "Wrong size on UHWGameplayEffect_Mesmerize");

// Class Hemingway.HWGameplayEffect_MovementSpeedOverTime
// 0x0008 (0x0AC0 - 0x0AB8)
class UHWGameplayEffect_MovementSpeedOverTime : public UHWGameplayEffect
{
public:
	class UCurveFloat*                            MovementSpeedOverTimeCurve;                        // 0x0AB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_MovementSpeedOverTime">();
	}
	static class UHWGameplayEffect_MovementSpeedOverTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_MovementSpeedOverTime>();
	}
};
static_assert(alignof(UHWGameplayEffect_MovementSpeedOverTime) == 0x000008, "Wrong alignment on UHWGameplayEffect_MovementSpeedOverTime");
static_assert(sizeof(UHWGameplayEffect_MovementSpeedOverTime) == 0x000AC0, "Wrong size on UHWGameplayEffect_MovementSpeedOverTime");
static_assert(offsetof(UHWGameplayEffect_MovementSpeedOverTime, MovementSpeedOverTimeCurve) == 0x000AB8, "Member 'UHWGameplayEffect_MovementSpeedOverTime::MovementSpeedOverTimeCurve' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_Polymorph
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Polymorph final : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Polymorph">();
	}
	static class UHWGameplayEffect_Polymorph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Polymorph>();
	}
};
static_assert(alignof(UHWGameplayEffect_Polymorph) == 0x000008, "Wrong alignment on UHWGameplayEffect_Polymorph");
static_assert(sizeof(UHWGameplayEffect_Polymorph) == 0x000AC8, "Wrong size on UHWGameplayEffect_Polymorph");

// Class Hemingway.HWGameplayEffect_ReflectDamage
// 0x0000 (0x0BE0 - 0x0BE0)
class UHWGameplayEffect_ReflectDamage : public UHWGameplayEffect_Damage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_ReflectDamage">();
	}
	static class UHWGameplayEffect_ReflectDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_ReflectDamage>();
	}
};
static_assert(alignof(UHWGameplayEffect_ReflectDamage) == 0x000008, "Wrong alignment on UHWGameplayEffect_ReflectDamage");
static_assert(sizeof(UHWGameplayEffect_ReflectDamage) == 0x000BE0, "Wrong size on UHWGameplayEffect_ReflectDamage");

// Class Hemingway.HWGameplayEffect_Reviving
// 0x0000 (0x0AB8 - 0x0AB8)
class UHWGameplayEffect_Reviving final : public UHWGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Reviving">();
	}
	static class UHWGameplayEffect_Reviving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Reviving>();
	}
};
static_assert(alignof(UHWGameplayEffect_Reviving) == 0x000008, "Wrong alignment on UHWGameplayEffect_Reviving");
static_assert(sizeof(UHWGameplayEffect_Reviving) == 0x000AB8, "Wrong size on UHWGameplayEffect_Reviving");

// Class Hemingway.HWGameplayEffect_Silence
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Silence : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Silence">();
	}
	static class UHWGameplayEffect_Silence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Silence>();
	}
};
static_assert(alignof(UHWGameplayEffect_Silence) == 0x000008, "Wrong alignment on UHWGameplayEffect_Silence");
static_assert(sizeof(UHWGameplayEffect_Silence) == 0x000AC8, "Wrong size on UHWGameplayEffect_Silence");

// Class Hemingway.HWGameplayEffect_Taunt
// 0x0000 (0x0AC8 - 0x0AC8)
class UHWGameplayEffect_Taunt final : public UHWGameplayEffect_CC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_Taunt">();
	}
	static class UHWGameplayEffect_Taunt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_Taunt>();
	}
};
static_assert(alignof(UHWGameplayEffect_Taunt) == 0x000008, "Wrong alignment on UHWGameplayEffect_Taunt");
static_assert(sizeof(UHWGameplayEffect_Taunt) == 0x000AC8, "Wrong size on UHWGameplayEffect_Taunt");

// Class Hemingway.HWGEMMC_CharacterAttackSpeed
// 0x0040 (0x0080 - 0x0040)
class UHWGEMMC_CharacterAttackSpeed final : public UHWGEModiferMagnitudeCalc_Base
{
public:
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEMMC_CharacterAttackSpeed">();
	}
	static class UHWGEMMC_CharacterAttackSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEMMC_CharacterAttackSpeed>();
	}
};
static_assert(alignof(UHWGEMMC_CharacterAttackSpeed) == 0x000008, "Wrong alignment on UHWGEMMC_CharacterAttackSpeed");
static_assert(sizeof(UHWGEMMC_CharacterAttackSpeed) == 0x000080, "Wrong size on UHWGEMMC_CharacterAttackSpeed");

// Class Hemingway.HWGEMMC_CharacterMovement_WithDR
// 0x0000 (0x0040 - 0x0040)
class UHWGEMMC_CharacterMovement_WithDR final : public UHWGEModiferMagnitudeCalc_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEMMC_CharacterMovement_WithDR">();
	}
	static class UHWGEMMC_CharacterMovement_WithDR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEMMC_CharacterMovement_WithDR>();
	}
};
static_assert(alignof(UHWGEMMC_CharacterMovement_WithDR) == 0x000008, "Wrong alignment on UHWGEMMC_CharacterMovement_WithDR");
static_assert(sizeof(UHWGEMMC_CharacterMovement_WithDR) == 0x000040, "Wrong size on UHWGEMMC_CharacterMovement_WithDR");

// Class Hemingway.HWGEMMC_Cooldown_AbilitySwap
// 0x0000 (0x00B0 - 0x00B0)
class UHWGEMMC_Cooldown_AbilitySwap final : public UHWGEMMC_Cooldown
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGEMMC_Cooldown_AbilitySwap">();
	}
	static class UHWGEMMC_Cooldown_AbilitySwap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGEMMC_Cooldown_AbilitySwap>();
	}
};
static_assert(alignof(UHWGEMMC_Cooldown_AbilitySwap) == 0x000008, "Wrong alignment on UHWGEMMC_Cooldown_AbilitySwap");
static_assert(sizeof(UHWGEMMC_Cooldown_AbilitySwap) == 0x0000B0, "Wrong size on UHWGEMMC_Cooldown_AbilitySwap");

// Class Hemingway.HWGameplayEffectUIBuffData
// 0x0058 (0x0080 - 0x0028)
class UHWGameplayEffectUIBuffData final : public UGameplayEffectUIData
{
public:
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SmallIcon;                                         // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffectUIBuffData">();
	}
	static class UHWGameplayEffectUIBuffData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffectUIBuffData>();
	}
};
static_assert(alignof(UHWGameplayEffectUIBuffData) == 0x000008, "Wrong alignment on UHWGameplayEffectUIBuffData");
static_assert(sizeof(UHWGameplayEffectUIBuffData) == 0x000080, "Wrong size on UHWGameplayEffectUIBuffData");
static_assert(offsetof(UHWGameplayEffectUIBuffData, DisplayName) == 0x000028, "Member 'UHWGameplayEffectUIBuffData::DisplayName' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectUIBuffData, Description) == 0x000040, "Member 'UHWGameplayEffectUIBuffData::Description' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffectUIBuffData, SmallIcon) == 0x000058, "Member 'UHWGameplayEffectUIBuffData::SmallIcon' has a wrong offset!");

// Class Hemingway.HWAbilitySystemComponent
// 0x0868 (0x1AC0 - 0x1258)
class UHWAbilitySystemComponent : public UAbilitySystemComponent
{
public:
	TMulticastInlineDelegate<void(class AActor* NewAvatar)> OnNewAvatarActorDelegate;                // 0x1258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1268[0x130];                                   // 0x1268(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalConfirmInputPressedTimeStamp;                 // 0x1398(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAbilityConfirmInputPressed;                     // 0x139C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139D[0x3];                                     // 0x139D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalCancelInputPressedTimeStamp;                  // 0x13A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAbilityCancelInputPressed;                      // 0x13A4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13A5[0x14B];                                   // 0x13A5(0x014B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecHandle>     DelayedActivationAbilitiesUntilAvatarAlive;        // 0x14F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FGameplayAbilitySpecHandle& AbilityHandle, const int32 Level)> OnAbilityLevelChangedDelegate; // 0x1500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHWInventorySlot& AbilitySlot, bool IsUnlocked)> OnAbilityUnlockedDelegate; // 0x1510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1520[0x50];                                    // 0x1520(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& AbilityTags, const struct FHWAbilityFiringInstanceId& FiringInstanceId)> AbilityStartFireCallbacks; // 0x1570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& AbilityTags, const struct FHWAbilityFiringInstanceId& FiringInstanceId)> AbilityFiredCallbacks; // 0x1580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWAbilitySystemComponent* AbilitySystem, const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& AbilityTags, const EAbilityFlowPhase PrevPhase, const EAbilityFlowPhase NextPhase)> OnAbilityPhaseChangedDel; // 0x1590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& AbilityTags)> OnAbilityContinousRefireDel; // 0x15A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UGameplayEffect* ModifiedEffectDef, const float NewLifetime)> OnEffectLifetimeModifiedDel; // 0x15B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayEffectSpec& EffectSpec, const struct FGameplayEffectSpec& EffectBeingModified, const float InCooldownMultiplier, const float InCooldownFlatDelta)> OnAttemptAdjustLifetimeDurationDel; // 0x15C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWDeployable* SpawnedDeployable)> OnDeployableSpawnedDel;   // 0x15D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TMulticastInlineDelegate<void(const struct FGameplayEffectSpec& ActiveGameplayEffect)>> OnQuestEffectAppliedDelegates; // 0x15E0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TMulticastInlineDelegate<void(int32 ProgressToAward)>> OnAbilityProgressedQuestDelegates; // 0x1630(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, const bool bDamageImmune)> OnAttemptToHitDelegate; // 0x1680(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHitResult& HitResult, const struct FDamageEventData& DamageEventData)> OnHitDelegate; // 0x1690(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDamageEventData& DamageEventData)> OnDamagedDelegate; // 0x16A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDamageEventData& DamageEventData)> OnDealtDamageDelegate; // 0x16B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FBlockDamageEventData& DamageEventData)> OnBlockedDamageDelegate; // 0x16C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHealEventData& HealEventData)> OnHealedDelegate;     // 0x16D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHealEventData& HealEventData)> OnDealtHealDelegate;  // 0x16E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStealthToTargetUpdateDelegate;                   // 0x16F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDamageEventData& KillEventData)> OnKillCommittedDelegate; // 0x1700(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FAssistEventData& AssistEventData)> OnAssistCommittedDelegate; // 0x1710(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDamageEventData& DeathEventData)> OnAvatarDeathDelegate; // 0x1720(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1730[0x18];                                    // 0x1730(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseDamageValue)> OnAdjustBaseDamageToTarget; // 0x1748(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseDamageValue)> OnAdjustDamageToTarget; // 0x1758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseDamageValue)> OnAdjustDamageReceived; // 0x1768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, const struct FGameplayTag& ScalingTypeTag, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BasePowerScalingValue)> OnAdjustAttackPowerScalingDelegate; // 0x1778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const EHWAttributeModifierEnum PenModifierType, const float BasePenValue)> OnAdjustPenetrationDelegate; // 0x1788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseCritMultiplier)> OnAdjustCritDamageMultiplierToTarget; // 0x1798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseCritMultiplier)> OnAdjustCritDamageMultiplierReceived; // 0x17A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FHealCalcInfo& HealCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseHealValue)> OnAdjustHealToSelf; // 0x17B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FHealCalcInfo& HealCalcInfo, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseHealValue)> OnAdjustHealToTarget; // 0x17C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FHealCalcInfo& HealCalcInfo, const struct FGameplayTag& ScalingTypeTag, class UHWAbilitySystemComponent* BroadcastingAbilitySystemComponent, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseHealScalingValue)> OnAdjustHealPowerScalingDelegate; // 0x17D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FGoldXpCalcInfo& CalcInfo, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseGoldValue)> OnAdjustGoldRecievedDelegate; // 0x17E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTagContainer& EffectTags, const struct FGoldXpCalcInfo& CalcInfo, const EHWAdjustAttributeEventType AdjustAttributeEventType, const float BaseXpValue)> OnAdjustXpRecievedDelegate; // 0x17F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<EHWAdjustAttributeEventType, struct FHWAdjustAttributeEventEntry> AdjustAttributeOnEventMap; // 0x1808(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FDamageEventData>               DamageTakenEventDataStack;                         // 0x1858(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHealEventData>                 HealReceivedEventDataStack;                        // 0x1868(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1878[0x8];                                     // 0x1878(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWDiminishingReturnsTracker>   DR_Trackers;                                       // 0x1880(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1890[0x10];                                    // 0x1890(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGameplayAbilitySpecHandle& PreviousTargetingHandle, const struct FGameplayAbilitySpecHandle& CurrentTargetingHandle)> OnTargetingAbilityChanged; // 0x18A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             CurrentTargetingAbilityHandle;                     // 0x18B0(0x0004)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             DefaultTargetingAbilityHandle;                     // 0x18B4(0x0004)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWInventorySlot                       DefaultTargetingAbilitySlot;                       // 0x18B8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTargetingAbilityPendingActivation;                // 0x18C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTargetingAbilityQueuedForActivation;              // 0x18C5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C6[0x2];                                     // 0x18C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               ActivationFailureQueuedTargetingRequirements;      // 0x18C8(0x0088)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAbilitySpecHandle>     QueuedAbilityFireSpecHandles;                      // 0x1950(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWForcedCharacterFiringInfo>   ForcedFiringInfos;                                 // 0x1960(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FHWSimulatedSpawnActorTaskList         SimulatedSpawnActorTasks;                          // 0x1970(0x0128)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A98[0x4];                                     // 0x1A98(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilitySpecHandle             CurrentAnimatingAbilitySpecHandle;                 // 0x1A9C(0x0004)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilityActivationInfo         CurrentAnimatingAbilityActivationInfo;             // 0x1AA0(0x0020)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void AbilityCancelInputPressed();
	void AbilityCancelInputReleased();
	void AbilityConfirmInputPressed();
	void AbilityConfirmInputReleased();
	void AbilityInputTagPressed(const struct FGameplayTag& InputTag);
	void AbilityInputTagReleased(const struct FGameplayTag& InputTag);
	void AddActiveEffectDynamicIgnoreTag(const struct FActiveGameplayEffectHandle& ActiveHandle, const struct FGameplayTag& Tag);
	void AddActiveEffectDynamicRequireTag(const struct FActiveGameplayEffectHandle& ActiveHandle, const struct FGameplayTag& Tag);
	void AddDynamicGameplayTag(const struct FGameplayTag& Tag, bool bShouldReplicate);
	void AddDynamicGameplayTags(const struct FGameplayTagContainer& Tags, bool bShouldReplicate);
	void AddForcedFiringInfo(const struct FHWForcedCharacterFiringInfo& ForcedFiringInfo);
	void AdjustSubscribedAttributeFromCombatEvent(EHWAdjustAttributeEventType EventType, EHWAttributeModifierEnum AttributeToAdjust, const float PreMultiplyAdditiveDelta, const float CoefficientMultiplier, const float PostMultiplyAdditiveDelta);
	void BP_GetActiveEffectsTimeRemainingAndDuration(const struct FGameplayEffectQuery& Query, TArray<float>* TimesRemaining, TArray<float>* Durations);
	void CalculateForcedFiring(const float DeltaTime);
	void CancelAbilitiesBasedOnTriggerTag(const struct FGameplayTag& TriggerTag);
	void CancelAbilitiesBasedOnTriggerTags(const struct FGameplayTagContainer& TriggerTags);
	void CancelAbilitiesWithTags(const struct FGameplayTagContainer& WithTags, const struct FGameplayTagContainer& WithoutTags, class UGameplayAbility* AbilityToIngnore);
	void CancelTargetingAbilities();
	void ClientAbilityLevelChanged(const struct FGameplayAbilitySpecHandle& AbilityHandle, const int32 Level);
	void ClientCancelAllAbilities();
	void ClientExecuteGameplayCuesAtLocation(const struct FGameplayTagContainer& InTags, const struct FVector_NetQuantize& InLocation, float Magnitude);
	void ClientMarkAbilityBuffering(const struct FGameplayAbilitySpecHandle& AbilityToBuffer, const struct FGameplayAbilityActivationInfo& ActivationInfo);
	void ClientSendGameplayEventToAvatar(const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	void ClientSetReplicatedEventWithPayload(EAbilityGenericReplicatedEvent EventType, const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FPredictionKey& AbilityOriginalPredictionKey, const struct FVector_NetQuantize100& VectorPayload, const struct FGameplayAbilityTargetDataHandle& TargetDataPayload);
	void ClientTransitionToAbilityPhase(const struct FGameplayAbilitySpecHandle& AbilityToEnd, const struct FGameplayAbilityActivationInfo& ActivationInfo, EAbilityFlowPhase PhaseToEnter, const float TimingError);
	int32 GetAbilityLevel(const struct FGameplayAbilitySpecHandle& AbilityHandle);
	void HandleActiveGameplayEffectStackChange(const struct FActiveGameplayEffectHandle& EffectHandle, int32 NewStackCount, int32 PreviousStackCount);
	void HandleAnyGameplayEffectRemoved(const struct FActiveGameplayEffect& ActiveGameplayEffect);
	void HandleTagUpdated_ForceUseDefaultTargetingAbility(const struct FGameplayTag& CallbackTag, int32 Count);
	void MulticastAbilityUnlocked(const struct FHWInventorySlot& AbilitySlot, bool IsUnlocked);
	void MulticastExecuteGameplayCuesAtLocation(const struct FGameplayTagContainer& InTags, const struct FVector_NetQuantize& InLocation, float Magnitude);
	void NotifyAbilityQuestEvent(const struct FGameplayTag& QuestTag, int32 ProgressToAward);
	void OnRep_DefaultTargetingAbilityHandle(const struct FGameplayAbilitySpecHandle& PrevDefaultTargetingAbilityHandle);
	void QueueTargetingAbility(const struct FGameplayAbilitySpecHandle& AbilityHandle, const bool bForceSet);
	void RefreshActiveGameplayEffect(const struct FActiveGameplayEffectHandle& EffectHandle);
	TMulticastInlineDelegate<void(int32 ProgressToAward)> RegisterAbilityQuestListener(const struct FGameplayTag& QuestTag);
	TMulticastInlineDelegate<void(const struct FGameplayEffectSpec& ActiveGameplayEffect)> RegisterOnQuestEffectAppliedDelegate(const struct FGameplayTag& EffectTag);
	void RegisterTagListener(const struct FGameplayTag& Tag, EGameplayTagEventType EventType, TDelegate<void(const struct FGameplayTag& Tag, int32 TagCount, class UHWAbilitySystemComponent* AbilitySystem)> Delegate);
	void RemoveActiveEffectDynamicIgnoreTag(const struct FActiveGameplayEffectHandle& ActiveHandle, const struct FGameplayTag& Tag);
	void RemoveActiveEffectDynamicRequireTag(const struct FActiveGameplayEffectHandle& ActiveHandle, const struct FGameplayTag& Tag);
	void RemoveDynamicGameplayTag(const struct FGameplayTag& Tag, bool bShouldReplicate);
	void RemoveDynamicGameplayTags(const struct FGameplayTagContainer& Tags, bool bShouldReplicate);
	void RemoveForcedFiringInfo(const struct FActiveGameplayEffectHandle& ForcedMovementEffectHandle);
	void ServerCancelTargetingAbility(const struct FGameplayAbilitySpecHandle& AbilityToCancel);
	void ServerSetAbilityLevel(const struct FGameplayAbilitySpecHandle& AbilityHandle, const int32 Level);
	void SetAbilityLevel(const struct FGameplayAbilitySpecHandle& AbilityHandle, const int32 Level);
	bool SetActiveEffectDuration(const struct FActiveGameplayEffectHandle& Handle, float NewDuration);

	bool CanActivateAbility(const struct FGameplayAbilitySpecHandle& AbilityHandle, struct FGameplayTagContainer* OutFailureTags) const;
	TArray<struct FGameplayAbilitySpecHandle> GetAbilitySpecHandlesWithInputTag(const struct FGameplayTag& InputTag) const;
	class AHWCharacterAbilitySystemActor* GetAbilitySystemActorOwner() const;
	class UHWGameplayAbility* GetAbilityWithInputTag(const struct FGameplayTag& InputTag) const;
	EAbilityCastStyle GetCastStyleForAbilityWithInputTag(const struct FGameplayTag& InputTag) const;
	struct FHWAbilityFiringInstanceId GetCurrentFiringInstanceIdForAbility(const struct FGameplayAbilitySpecHandle& AbilityHandle) const;
	class UHWEquipmentInstance* GetEquipmentInstanceFromAbility(const struct FGameplayAbilitySpecHandle& AbilityHandle) const;
	bool HasForcedFiringEffects() const;
	bool IsAbilityCancelInputPressed(const bool bCheckWasPressedThisTick) const;
	bool IsAbilityConfirmInputPressed(const bool bCheckWasPressedThisTick) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilitySystemComponent">();
	}
	static class UHWAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilitySystemComponent>();
	}
};
static_assert(alignof(UHWAbilitySystemComponent) == 0x000008, "Wrong alignment on UHWAbilitySystemComponent");
static_assert(sizeof(UHWAbilitySystemComponent) == 0x001AC0, "Wrong size on UHWAbilitySystemComponent");
static_assert(offsetof(UHWAbilitySystemComponent, OnNewAvatarActorDelegate) == 0x001258, "Member 'UHWAbilitySystemComponent::OnNewAvatarActorDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, LocalConfirmInputPressedTimeStamp) == 0x001398, "Member 'UHWAbilitySystemComponent::LocalConfirmInputPressedTimeStamp' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, bIsAbilityConfirmInputPressed) == 0x00139C, "Member 'UHWAbilitySystemComponent::bIsAbilityConfirmInputPressed' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, LocalCancelInputPressedTimeStamp) == 0x0013A0, "Member 'UHWAbilitySystemComponent::LocalCancelInputPressedTimeStamp' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, bIsAbilityCancelInputPressed) == 0x0013A4, "Member 'UHWAbilitySystemComponent::bIsAbilityCancelInputPressed' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, DelayedActivationAbilitiesUntilAvatarAlive) == 0x0014F0, "Member 'UHWAbilitySystemComponent::DelayedActivationAbilitiesUntilAvatarAlive' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAbilityLevelChangedDelegate) == 0x001500, "Member 'UHWAbilitySystemComponent::OnAbilityLevelChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAbilityUnlockedDelegate) == 0x001510, "Member 'UHWAbilitySystemComponent::OnAbilityUnlockedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, AbilityStartFireCallbacks) == 0x001570, "Member 'UHWAbilitySystemComponent::AbilityStartFireCallbacks' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, AbilityFiredCallbacks) == 0x001580, "Member 'UHWAbilitySystemComponent::AbilityFiredCallbacks' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAbilityPhaseChangedDel) == 0x001590, "Member 'UHWAbilitySystemComponent::OnAbilityPhaseChangedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAbilityContinousRefireDel) == 0x0015A0, "Member 'UHWAbilitySystemComponent::OnAbilityContinousRefireDel' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnEffectLifetimeModifiedDel) == 0x0015B0, "Member 'UHWAbilitySystemComponent::OnEffectLifetimeModifiedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAttemptAdjustLifetimeDurationDel) == 0x0015C0, "Member 'UHWAbilitySystemComponent::OnAttemptAdjustLifetimeDurationDel' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnDeployableSpawnedDel) == 0x0015D0, "Member 'UHWAbilitySystemComponent::OnDeployableSpawnedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnQuestEffectAppliedDelegates) == 0x0015E0, "Member 'UHWAbilitySystemComponent::OnQuestEffectAppliedDelegates' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAbilityProgressedQuestDelegates) == 0x001630, "Member 'UHWAbilitySystemComponent::OnAbilityProgressedQuestDelegates' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAttemptToHitDelegate) == 0x001680, "Member 'UHWAbilitySystemComponent::OnAttemptToHitDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnHitDelegate) == 0x001690, "Member 'UHWAbilitySystemComponent::OnHitDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnDamagedDelegate) == 0x0016A0, "Member 'UHWAbilitySystemComponent::OnDamagedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnDealtDamageDelegate) == 0x0016B0, "Member 'UHWAbilitySystemComponent::OnDealtDamageDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnBlockedDamageDelegate) == 0x0016C0, "Member 'UHWAbilitySystemComponent::OnBlockedDamageDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnHealedDelegate) == 0x0016D0, "Member 'UHWAbilitySystemComponent::OnHealedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnDealtHealDelegate) == 0x0016E0, "Member 'UHWAbilitySystemComponent::OnDealtHealDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnStealthToTargetUpdateDelegate) == 0x0016F0, "Member 'UHWAbilitySystemComponent::OnStealthToTargetUpdateDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnKillCommittedDelegate) == 0x001700, "Member 'UHWAbilitySystemComponent::OnKillCommittedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAssistCommittedDelegate) == 0x001710, "Member 'UHWAbilitySystemComponent::OnAssistCommittedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAvatarDeathDelegate) == 0x001720, "Member 'UHWAbilitySystemComponent::OnAvatarDeathDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustBaseDamageToTarget) == 0x001748, "Member 'UHWAbilitySystemComponent::OnAdjustBaseDamageToTarget' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustDamageToTarget) == 0x001758, "Member 'UHWAbilitySystemComponent::OnAdjustDamageToTarget' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustDamageReceived) == 0x001768, "Member 'UHWAbilitySystemComponent::OnAdjustDamageReceived' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustAttackPowerScalingDelegate) == 0x001778, "Member 'UHWAbilitySystemComponent::OnAdjustAttackPowerScalingDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustPenetrationDelegate) == 0x001788, "Member 'UHWAbilitySystemComponent::OnAdjustPenetrationDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustCritDamageMultiplierToTarget) == 0x001798, "Member 'UHWAbilitySystemComponent::OnAdjustCritDamageMultiplierToTarget' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustCritDamageMultiplierReceived) == 0x0017A8, "Member 'UHWAbilitySystemComponent::OnAdjustCritDamageMultiplierReceived' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustHealToSelf) == 0x0017B8, "Member 'UHWAbilitySystemComponent::OnAdjustHealToSelf' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustHealToTarget) == 0x0017C8, "Member 'UHWAbilitySystemComponent::OnAdjustHealToTarget' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustHealPowerScalingDelegate) == 0x0017D8, "Member 'UHWAbilitySystemComponent::OnAdjustHealPowerScalingDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustGoldRecievedDelegate) == 0x0017E8, "Member 'UHWAbilitySystemComponent::OnAdjustGoldRecievedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnAdjustXpRecievedDelegate) == 0x0017F8, "Member 'UHWAbilitySystemComponent::OnAdjustXpRecievedDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, AdjustAttributeOnEventMap) == 0x001808, "Member 'UHWAbilitySystemComponent::AdjustAttributeOnEventMap' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, DamageTakenEventDataStack) == 0x001858, "Member 'UHWAbilitySystemComponent::DamageTakenEventDataStack' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, HealReceivedEventDataStack) == 0x001868, "Member 'UHWAbilitySystemComponent::HealReceivedEventDataStack' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, DR_Trackers) == 0x001880, "Member 'UHWAbilitySystemComponent::DR_Trackers' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, OnTargetingAbilityChanged) == 0x0018A0, "Member 'UHWAbilitySystemComponent::OnTargetingAbilityChanged' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, CurrentTargetingAbilityHandle) == 0x0018B0, "Member 'UHWAbilitySystemComponent::CurrentTargetingAbilityHandle' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, DefaultTargetingAbilityHandle) == 0x0018B4, "Member 'UHWAbilitySystemComponent::DefaultTargetingAbilityHandle' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, DefaultTargetingAbilitySlot) == 0x0018B8, "Member 'UHWAbilitySystemComponent::DefaultTargetingAbilitySlot' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, bTargetingAbilityPendingActivation) == 0x0018C4, "Member 'UHWAbilitySystemComponent::bTargetingAbilityPendingActivation' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, bTargetingAbilityQueuedForActivation) == 0x0018C5, "Member 'UHWAbilitySystemComponent::bTargetingAbilityQueuedForActivation' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, ActivationFailureQueuedTargetingRequirements) == 0x0018C8, "Member 'UHWAbilitySystemComponent::ActivationFailureQueuedTargetingRequirements' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, QueuedAbilityFireSpecHandles) == 0x001950, "Member 'UHWAbilitySystemComponent::QueuedAbilityFireSpecHandles' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, ForcedFiringInfos) == 0x001960, "Member 'UHWAbilitySystemComponent::ForcedFiringInfos' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, SimulatedSpawnActorTasks) == 0x001970, "Member 'UHWAbilitySystemComponent::SimulatedSpawnActorTasks' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, CurrentAnimatingAbilitySpecHandle) == 0x001A9C, "Member 'UHWAbilitySystemComponent::CurrentAnimatingAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystemComponent, CurrentAnimatingAbilityActivationInfo) == 0x001AA0, "Member 'UHWAbilitySystemComponent::CurrentAnimatingAbilityActivationInfo' has a wrong offset!");

// Class Hemingway.HWAbilitySystem_Deployable
// 0x0068 (0x1B28 - 0x1AC0)
class UHWAbilitySystem_Deployable final : public UHWAbilitySystemComponent
{
public:
	TMap<TSubclassOf<class UGameplayEffect>, struct FGameplayEffectSpecHandle> EffectSpecMap;        // 0x1AC0(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FGameplayEffectContextHandle           DefaultDeployableEffectContext;                    // 0x1B10(0x0018)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilitySystem_Deployable">();
	}
	static class UHWAbilitySystem_Deployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilitySystem_Deployable>();
	}
};
static_assert(alignof(UHWAbilitySystem_Deployable) == 0x000008, "Wrong alignment on UHWAbilitySystem_Deployable");
static_assert(sizeof(UHWAbilitySystem_Deployable) == 0x001B28, "Wrong size on UHWAbilitySystem_Deployable");
static_assert(offsetof(UHWAbilitySystem_Deployable, EffectSpecMap) == 0x001AC0, "Member 'UHWAbilitySystem_Deployable::EffectSpecMap' has a wrong offset!");
static_assert(offsetof(UHWAbilitySystem_Deployable, DefaultDeployableEffectContext) == 0x001B10, "Member 'UHWAbilitySystem_Deployable::DefaultDeployableEffectContext' has a wrong offset!");

// Class Hemingway.HWGameplayCueManager
// 0x0100 (0x03E0 - 0x02E0)
class UHWGameplayCueManager final : public UGameplayCueManager
{
public:
	uint8                                         Pad_2E0[0xF0];                                     // 0x02E0(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetType>              ManagedPrimaryAssetTypes;                          // 0x03D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueManager">();
	}
	static class UHWGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayCueManager>();
	}
};
static_assert(alignof(UHWGameplayCueManager) == 0x000008, "Wrong alignment on UHWGameplayCueManager");
static_assert(sizeof(UHWGameplayCueManager) == 0x0003E0, "Wrong size on UHWGameplayCueManager");
static_assert(offsetof(UHWGameplayCueManager, ManagedPrimaryAssetTypes) == 0x0003D0, "Member 'UHWGameplayCueManager::ManagedPrimaryAssetTypes' has a wrong offset!");

// Class Hemingway.HWTargeter_Dummy
// 0x0000 (0x0650 - 0x0650)
class AHWTargeter_Dummy final : public AHWTargeter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWTargeter_Dummy">();
	}
	static class AHWTargeter_Dummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWTargeter_Dummy>();
	}
};
static_assert(alignof(AHWTargeter_Dummy) == 0x000010, "Wrong alignment on AHWTargeter_Dummy");
static_assert(sizeof(AHWTargeter_Dummy) == 0x000650, "Wrong size on AHWTargeter_Dummy");

// Class Hemingway.HWReticle_MapAdjust
// 0x0070 (0x0488 - 0x0418)
class AHWReticle_MapAdjust final : public AHWReticle
{
public:
	float                                         ReticleRadius;                                     // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LargeStepScalar;                                   // 0x041C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmallStepScalar;                                   // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSteps;                                          // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustAwayFromWorldGeo;                           // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustToOutsideOfStructures;                      // 0x0429(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42A[0x2];                                      // 0x042A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhoenixRadiusScalar;                               // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x58];                                     // 0x0430(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWReticle_MapAdjust">();
	}
	static class AHWReticle_MapAdjust* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWReticle_MapAdjust>();
	}
};
static_assert(alignof(AHWReticle_MapAdjust) == 0x000008, "Wrong alignment on AHWReticle_MapAdjust");
static_assert(sizeof(AHWReticle_MapAdjust) == 0x000488, "Wrong size on AHWReticle_MapAdjust");
static_assert(offsetof(AHWReticle_MapAdjust, ReticleRadius) == 0x000418, "Member 'AHWReticle_MapAdjust::ReticleRadius' has a wrong offset!");
static_assert(offsetof(AHWReticle_MapAdjust, LargeStepScalar) == 0x00041C, "Member 'AHWReticle_MapAdjust::LargeStepScalar' has a wrong offset!");
static_assert(offsetof(AHWReticle_MapAdjust, SmallStepScalar) == 0x000420, "Member 'AHWReticle_MapAdjust::SmallStepScalar' has a wrong offset!");
static_assert(offsetof(AHWReticle_MapAdjust, MaxSteps) == 0x000424, "Member 'AHWReticle_MapAdjust::MaxSteps' has a wrong offset!");
static_assert(offsetof(AHWReticle_MapAdjust, bAdjustAwayFromWorldGeo) == 0x000428, "Member 'AHWReticle_MapAdjust::bAdjustAwayFromWorldGeo' has a wrong offset!");
static_assert(offsetof(AHWReticle_MapAdjust, bAdjustToOutsideOfStructures) == 0x000429, "Member 'AHWReticle_MapAdjust::bAdjustToOutsideOfStructures' has a wrong offset!");
static_assert(offsetof(AHWReticle_MapAdjust, PhoenixRadiusScalar) == 0x00042C, "Member 'AHWReticle_MapAdjust::PhoenixRadiusScalar' has a wrong offset!");

// Class Hemingway.HWAbilityTask_Attack_CloneCharacterSwap
// 0x0060 (0x01E0 - 0x0180)
class UHWAbilityTask_Attack_CloneCharacterSwap final : public UHWAbilityTask_FireAttack
{
public:
	class UHWAbilityAttackSetings_CloneCharacterSwap* GodSwapAttackSettings;                         // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCurrentlySwappedToFamiliar;                     // 0x0188(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWCharacter_Base*                      StoredOriginalCharacter;                           // 0x0190(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacterAbilitySystemActor*         StoredOriginalAbilitySystemActor;                  // 0x0198(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVisibilityData*                        VisibilityDataToHideOriginal;                      // 0x01A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWActiveFamiliarHandle                ActiveFamiliarHandle;                              // 0x01A8(0x000C)(NoDestructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_GameplayGrab*            CharacterSwapGrabTask;                             // 0x01B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UHWGameplayGrab>            CharacterSwapGrabClass;                            // 0x01C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SwapBackTimer;                                     // 0x01D0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleFamiliarMovementModeChanged(class ACharacter* FamiliarCharacter, const EMovementMode PrevMovementMode, const uint8 PreviousCustomMode);
	void OnFamiliarDied(const struct FHWActiveFamiliarHandle& FamiliarHandle, const struct FHWActiveFamiliarInfo& FamiliarInfo, const struct FDamageEventData& DamageReceivedEvent);
	void OnGameplayEffectAppliedToFamiliar(class UAbilitySystemComponent* SourceASC, const struct FGameplayEffectSpec& EffectSpec, const struct FActiveGameplayEffectHandle& AppliedEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Attack_CloneCharacterSwap">();
	}
	static class UHWAbilityTask_Attack_CloneCharacterSwap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Attack_CloneCharacterSwap>();
	}
};
static_assert(alignof(UHWAbilityTask_Attack_CloneCharacterSwap) == 0x000008, "Wrong alignment on UHWAbilityTask_Attack_CloneCharacterSwap");
static_assert(sizeof(UHWAbilityTask_Attack_CloneCharacterSwap) == 0x0001E0, "Wrong size on UHWAbilityTask_Attack_CloneCharacterSwap");
static_assert(offsetof(UHWAbilityTask_Attack_CloneCharacterSwap, GodSwapAttackSettings) == 0x000180, "Member 'UHWAbilityTask_Attack_CloneCharacterSwap::GodSwapAttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_CloneCharacterSwap, bIsCurrentlySwappedToFamiliar) == 0x000188, "Member 'UHWAbilityTask_Attack_CloneCharacterSwap::bIsCurrentlySwappedToFamiliar' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_CloneCharacterSwap, StoredOriginalCharacter) == 0x000190, "Member 'UHWAbilityTask_Attack_CloneCharacterSwap::StoredOriginalCharacter' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_CloneCharacterSwap, StoredOriginalAbilitySystemActor) == 0x000198, "Member 'UHWAbilityTask_Attack_CloneCharacterSwap::StoredOriginalAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_CloneCharacterSwap, VisibilityDataToHideOriginal) == 0x0001A0, "Member 'UHWAbilityTask_Attack_CloneCharacterSwap::VisibilityDataToHideOriginal' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_CloneCharacterSwap, ActiveFamiliarHandle) == 0x0001A8, "Member 'UHWAbilityTask_Attack_CloneCharacterSwap::ActiveFamiliarHandle' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_CloneCharacterSwap, CharacterSwapGrabTask) == 0x0001B8, "Member 'UHWAbilityTask_Attack_CloneCharacterSwap::CharacterSwapGrabTask' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_CloneCharacterSwap, CharacterSwapGrabClass) == 0x0001C0, "Member 'UHWAbilityTask_Attack_CloneCharacterSwap::CharacterSwapGrabClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_CloneCharacterSwap, SwapBackTimer) == 0x0001D0, "Member 'UHWAbilityTask_Attack_CloneCharacterSwap::SwapBackTimer' has a wrong offset!");

// Class Hemingway.HWAbilityTask_Attack_Custom
// 0x0008 (0x0188 - 0x0180)
class UHWAbilityTask_Attack_Custom final : public UHWAbilityTask_FireAttack
{
public:
	class UHWAbilityAttackSettings_Custom*        CustomAttackSettings;                              // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Attack_Custom">();
	}
	static class UHWAbilityTask_Attack_Custom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Attack_Custom>();
	}
};
static_assert(alignof(UHWAbilityTask_Attack_Custom) == 0x000008, "Wrong alignment on UHWAbilityTask_Attack_Custom");
static_assert(sizeof(UHWAbilityTask_Attack_Custom) == 0x000188, "Wrong size on UHWAbilityTask_Attack_Custom");
static_assert(offsetof(UHWAbilityTask_Attack_Custom, CustomAttackSettings) == 0x000180, "Member 'UHWAbilityTask_Attack_Custom::CustomAttackSettings' has a wrong offset!");

// Class Hemingway.HWAbilityTask_Attack_InstantShape
// 0x0008 (0x0188 - 0x0180)
class UHWAbilityTask_Attack_InstantShape final : public UHWAbilityTask_FireAttack
{
public:
	class UHWAbilityAttackSettings_InstantShape*  InstantShapeAttackSettings;                        // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Attack_InstantShape">();
	}
	static class UHWAbilityTask_Attack_InstantShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Attack_InstantShape>();
	}
};
static_assert(alignof(UHWAbilityTask_Attack_InstantShape) == 0x000008, "Wrong alignment on UHWAbilityTask_Attack_InstantShape");
static_assert(sizeof(UHWAbilityTask_Attack_InstantShape) == 0x000188, "Wrong size on UHWAbilityTask_Attack_InstantShape");
static_assert(offsetof(UHWAbilityTask_Attack_InstantShape, InstantShapeAttackSettings) == 0x000180, "Member 'UHWAbilityTask_Attack_InstantShape::InstantShapeAttackSettings' has a wrong offset!");

// Class Hemingway.HWAbilityTask_Attack_SpawnFamiliar
// 0x0018 (0x0198 - 0x0180)
class UHWAbilityTask_Attack_SpawnFamiliar final : public UHWAbilityTask_FireAttack
{
public:
	class UHWAbilityAttackSettings_SpawnFamiliar* FamiliarAttackSettings;                            // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHWActiveFamiliarHandle>        SpawnedFamiliars;                                  // 0x0188(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	const TArray<struct FHWActiveFamiliarHandle> GetSpawnedFamiliars() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Attack_SpawnFamiliar">();
	}
	static class UHWAbilityTask_Attack_SpawnFamiliar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Attack_SpawnFamiliar>();
	}
};
static_assert(alignof(UHWAbilityTask_Attack_SpawnFamiliar) == 0x000008, "Wrong alignment on UHWAbilityTask_Attack_SpawnFamiliar");
static_assert(sizeof(UHWAbilityTask_Attack_SpawnFamiliar) == 0x000198, "Wrong size on UHWAbilityTask_Attack_SpawnFamiliar");
static_assert(offsetof(UHWAbilityTask_Attack_SpawnFamiliar, FamiliarAttackSettings) == 0x000180, "Member 'UHWAbilityTask_Attack_SpawnFamiliar::FamiliarAttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Attack_SpawnFamiliar, SpawnedFamiliars) == 0x000188, "Member 'UHWAbilityTask_Attack_SpawnFamiliar::SpawnedFamiliars' has a wrong offset!");

// Class Hemingway.HWAbilityTask_AbilityPhaseTransition
// 0x0018 (0x0098 - 0x0080)
class UHWAbilityTask_AbilityPhaseTransition final : public UAbilityTask
{
public:
	EAbilityFlowPhase                             PhaseTransition;                                   // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionTime;                                    // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_AbilityPhaseTransition* SetAbilityPhaseTransitionTimer(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EAbilityFlowPhase PhaseTransition_0, float TransitionTime_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_AbilityPhaseTransition">();
	}
	static class UHWAbilityTask_AbilityPhaseTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_AbilityPhaseTransition>();
	}
};
static_assert(alignof(UHWAbilityTask_AbilityPhaseTransition) == 0x000008, "Wrong alignment on UHWAbilityTask_AbilityPhaseTransition");
static_assert(sizeof(UHWAbilityTask_AbilityPhaseTransition) == 0x000098, "Wrong size on UHWAbilityTask_AbilityPhaseTransition");
static_assert(offsetof(UHWAbilityTask_AbilityPhaseTransition, PhaseTransition) == 0x000080, "Member 'UHWAbilityTask_AbilityPhaseTransition::PhaseTransition' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_AbilityPhaseTransition, TransitionTime) == 0x000084, "Member 'UHWAbilityTask_AbilityPhaseTransition::TransitionTime' has a wrong offset!");

// Class Hemingway.HWAbilityTask_GameplayFlight
// 0x0080 (0x0100 - 0x0080)
class UHWAbilityTask_GameplayFlight final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class UHWGameplayFlight* FlightInstance, class AHWCharacter_Base* FlightTarget)> OnFlightStartedDel; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayFlight* FlightInstance, class AHWCharacter_Base* FlightTarget)> OnTweenAscentStartedDel; // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayFlight* FlightInstance, class AHWCharacter_Base* FlightTarget)> OnTweenAscentEndedDel; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayFlight* FlightInstance, class AHWCharacter_Base* FlightTarget)> OnTweenDescentStartedDel; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayFlight* FlightInstance, class AHWCharacter_Base* FlightTarget)> OnTweenDescentEndedDel; // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayFlight* FlightInstance, class AHWCharacter_Base* FlightTarget, const EHWEndFlightReason EndFlightReason)> OnFlightEndedDel; // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWGameplayFlight*                      FlightInstance;                                    // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayFlight>          FlightClass;                                       // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacter_Base*                      Target;                                            // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AscentDurationOverride;                            // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DescentDurationOverride;                           // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UHWAbilityTask_GameplayFlight* EnterGameplayFlight(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class UHWGameplayFlight> Flight, class AHWCharacter_Base* Target_0, const float AscentDurationOverride_0);

	void ActivateFlightAscentTween();
	void ActivateFlightDescentTween(const struct FGameplayAbilityTargetDataHandle& AimData);
	void OnFlightEnded(class UHWGameplayFlight* Flight, const EHWEndFlightReason EndFlightReason);
	void OnFlightStarted(class UHWGameplayFlight* Flight);
	void OnTweenAscentEnded(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget, const EHWEndTweenReason EndTweenReason);
	void OnTweenAscentStarted(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget);
	void OnTweenDescentEnded(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget, const EHWEndTweenReason EndTweenReason);
	void OnTweenDescentStarted(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_GameplayFlight">();
	}
	static class UHWAbilityTask_GameplayFlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_GameplayFlight>();
	}
};
static_assert(alignof(UHWAbilityTask_GameplayFlight) == 0x000008, "Wrong alignment on UHWAbilityTask_GameplayFlight");
static_assert(sizeof(UHWAbilityTask_GameplayFlight) == 0x000100, "Wrong size on UHWAbilityTask_GameplayFlight");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, OnFlightStartedDel) == 0x000080, "Member 'UHWAbilityTask_GameplayFlight::OnFlightStartedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, OnTweenAscentStartedDel) == 0x000090, "Member 'UHWAbilityTask_GameplayFlight::OnTweenAscentStartedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, OnTweenAscentEndedDel) == 0x0000A0, "Member 'UHWAbilityTask_GameplayFlight::OnTweenAscentEndedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, OnTweenDescentStartedDel) == 0x0000B0, "Member 'UHWAbilityTask_GameplayFlight::OnTweenDescentStartedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, OnTweenDescentEndedDel) == 0x0000C0, "Member 'UHWAbilityTask_GameplayFlight::OnTweenDescentEndedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, OnFlightEndedDel) == 0x0000D0, "Member 'UHWAbilityTask_GameplayFlight::OnFlightEndedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, FlightInstance) == 0x0000E0, "Member 'UHWAbilityTask_GameplayFlight::FlightInstance' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, FlightClass) == 0x0000E8, "Member 'UHWAbilityTask_GameplayFlight::FlightClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, Target) == 0x0000F0, "Member 'UHWAbilityTask_GameplayFlight::Target' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, AscentDurationOverride) == 0x0000F8, "Member 'UHWAbilityTask_GameplayFlight::AscentDurationOverride' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayFlight, DescentDurationOverride) == 0x0000FC, "Member 'UHWAbilityTask_GameplayFlight::DescentDurationOverride' has a wrong offset!");

// Class Hemingway.HWAbilityTask_GameplayTween
// 0x0090 (0x0110 - 0x0080)
class UHWAbilityTask_GameplayTween final : public UAbilityTask
{
public:
	bool                                          bEndTweenOnAbilityEnd;                             // 0x0080(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndTweenOnTaskEnd;                                // 0x0081(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget)> OnTweenStartedDel; // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* TweenTarget, const EHWEndTweenReason EndTweenReason)> OnTweenEndedDel; // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UHWGameplayTween*>               TweenInstances;                                    // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayTween>           TweenClass;                                        // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x00C0(0x0028)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWCharacter_Base*>              Targets;                                           // 0x00F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         DurationOverride;                                  // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0xC];                                      // 0x0104(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_GameplayTween* PerformGameplayTweenOnTarget(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class UHWGameplayTween> Tween, const struct FGameplayAbilityTargetDataHandle& TargetData, class AHWCharacter_Base* Target, const float DurationOverride_0);
	static class UHWAbilityTask_GameplayTween* PerformGameplayTweenOnTargets(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class UHWGameplayTween> Tween, const struct FGameplayAbilityTargetDataHandle& TargetData, const TArray<class AHWCharacter_Base*>& Targets_0, const float DurationOverride_0, const bool bUseSameTweenLocForAllTargets);

	void HandleTagUpdated_CCImmunity(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void OnTweenEnded(class UHWGameplayTween* Tween, const EHWEndTweenReason EndTweenReason);
	void OnTweenStarted(class UHWGameplayTween* Tween);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_GameplayTween">();
	}
	static class UHWAbilityTask_GameplayTween* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_GameplayTween>();
	}
};
static_assert(alignof(UHWAbilityTask_GameplayTween) == 0x000008, "Wrong alignment on UHWAbilityTask_GameplayTween");
static_assert(sizeof(UHWAbilityTask_GameplayTween) == 0x000110, "Wrong size on UHWAbilityTask_GameplayTween");
static_assert(offsetof(UHWAbilityTask_GameplayTween, bEndTweenOnAbilityEnd) == 0x000080, "Member 'UHWAbilityTask_GameplayTween::bEndTweenOnAbilityEnd' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayTween, bEndTweenOnTaskEnd) == 0x000081, "Member 'UHWAbilityTask_GameplayTween::bEndTweenOnTaskEnd' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayTween, OnTweenStartedDel) == 0x000088, "Member 'UHWAbilityTask_GameplayTween::OnTweenStartedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayTween, OnTweenEndedDel) == 0x000098, "Member 'UHWAbilityTask_GameplayTween::OnTweenEndedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayTween, TweenInstances) == 0x0000A8, "Member 'UHWAbilityTask_GameplayTween::TweenInstances' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayTween, TweenClass) == 0x0000B8, "Member 'UHWAbilityTask_GameplayTween::TweenClass' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayTween, TargetDataHandle) == 0x0000C0, "Member 'UHWAbilityTask_GameplayTween::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayTween, Targets) == 0x0000F0, "Member 'UHWAbilityTask_GameplayTween::Targets' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_GameplayTween, DurationOverride) == 0x000100, "Member 'UHWAbilityTask_GameplayTween::DurationOverride' has a wrong offset!");

// Class Hemingway.HWAbilityTask_MovementSpeedOverTime
// 0x0028 (0x00F0 - 0x00C8)
class UHWAbilityTask_MovementSpeedOverTime final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MovementSpeedOverTimeCurve;                        // 0x00E0(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bProcessAsSlow;                                    // 0x00E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStrafeBackpedalImmunity;                          // 0x00E9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClientPredictive;                                 // 0x00EA(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EB[0x1];                                       // 0x00EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimePassed;                                        // 0x00EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UHWAbilityTask_MovementSpeedOverTime* ApplyMovementSpeedOverTime(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UCurveFloat* MovementSpeedOverTimeCurve_0, float Duration_0, bool bProcessAsSlow_0, bool bClientPredictive_0, bool bStrafeBackpedalImmunity_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_MovementSpeedOverTime">();
	}
	static class UHWAbilityTask_MovementSpeedOverTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_MovementSpeedOverTime>();
	}
};
static_assert(alignof(UHWAbilityTask_MovementSpeedOverTime) == 0x000008, "Wrong alignment on UHWAbilityTask_MovementSpeedOverTime");
static_assert(sizeof(UHWAbilityTask_MovementSpeedOverTime) == 0x0000F0, "Wrong size on UHWAbilityTask_MovementSpeedOverTime");
static_assert(offsetof(UHWAbilityTask_MovementSpeedOverTime, OnFinish) == 0x0000C8, "Member 'UHWAbilityTask_MovementSpeedOverTime::OnFinish' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_MovementSpeedOverTime, Duration) == 0x0000D8, "Member 'UHWAbilityTask_MovementSpeedOverTime::Duration' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_MovementSpeedOverTime, MovementSpeedOverTimeCurve) == 0x0000E0, "Member 'UHWAbilityTask_MovementSpeedOverTime::MovementSpeedOverTimeCurve' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_MovementSpeedOverTime, bProcessAsSlow) == 0x0000E8, "Member 'UHWAbilityTask_MovementSpeedOverTime::bProcessAsSlow' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_MovementSpeedOverTime, bStrafeBackpedalImmunity) == 0x0000E9, "Member 'UHWAbilityTask_MovementSpeedOverTime::bStrafeBackpedalImmunity' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_MovementSpeedOverTime, bClientPredictive) == 0x0000EA, "Member 'UHWAbilityTask_MovementSpeedOverTime::bClientPredictive' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_MovementSpeedOverTime, TimePassed) == 0x0000EC, "Member 'UHWAbilityTask_MovementSpeedOverTime::TimePassed' has a wrong offset!");

// Class Hemingway.HWAbilityTask_SpawnProjectile
// 0x00A8 (0x0130 - 0x0088)
class UHWAbilityTask_SpawnProjectile final : public UHWAbilityTask_SimulatedSpawnActor
{
public:
	TArray<TWeakObjectPtr<class AHWPlayerController>> NetRelevantControllers;                        // 0x0088(0x0010)(Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         ProjectileInstanceId;                              // 0x0098(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0xC];                                       // 0x009C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       AimDataHandle;                                     // 0x00A8(0x0028)(Net, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWProjectile* SpawnedProjectile)> OnBeginSpawningDel;       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWProjectile* SpawnedProjectile)> OnSpawnedDel;             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWAbilityAttackSettings_Projectile*    ProjectileAttackSettings;                          // 0x00F0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInhand;                                         // 0x00F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  HomingTarget;                                      // 0x00FC(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackID;                                          // 0x0104(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GenericVector1;                                    // 0x0110(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_SpawnProjectile* SpawnProjectileTask(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const class UHWAbilityAttackSettings_Projectile* ProjectileAttackSettings_0, const struct FGameplayAbilityTargetDataHandle& TargetAimData, class AActor* HomingTarget_0);

	bool IsInhandProjectile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_SpawnProjectile">();
	}
	static class UHWAbilityTask_SpawnProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_SpawnProjectile>();
	}
};
static_assert(alignof(UHWAbilityTask_SpawnProjectile) == 0x000008, "Wrong alignment on UHWAbilityTask_SpawnProjectile");
static_assert(sizeof(UHWAbilityTask_SpawnProjectile) == 0x000130, "Wrong size on UHWAbilityTask_SpawnProjectile");
static_assert(offsetof(UHWAbilityTask_SpawnProjectile, NetRelevantControllers) == 0x000088, "Member 'UHWAbilityTask_SpawnProjectile::NetRelevantControllers' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnProjectile, ProjectileInstanceId) == 0x000098, "Member 'UHWAbilityTask_SpawnProjectile::ProjectileInstanceId' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnProjectile, AimDataHandle) == 0x0000A8, "Member 'UHWAbilityTask_SpawnProjectile::AimDataHandle' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnProjectile, OnBeginSpawningDel) == 0x0000D0, "Member 'UHWAbilityTask_SpawnProjectile::OnBeginSpawningDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnProjectile, OnSpawnedDel) == 0x0000E0, "Member 'UHWAbilityTask_SpawnProjectile::OnSpawnedDel' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnProjectile, ProjectileAttackSettings) == 0x0000F0, "Member 'UHWAbilityTask_SpawnProjectile::ProjectileAttackSettings' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnProjectile, bIsInhand) == 0x0000F8, "Member 'UHWAbilityTask_SpawnProjectile::bIsInhand' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnProjectile, HomingTarget) == 0x0000FC, "Member 'UHWAbilityTask_SpawnProjectile::HomingTarget' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnProjectile, AttackID) == 0x000104, "Member 'UHWAbilityTask_SpawnProjectile::AttackID' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_SpawnProjectile, GenericVector1) == 0x000110, "Member 'UHWAbilityTask_SpawnProjectile::GenericVector1' has a wrong offset!");

// Class Hemingway.HWAbilityTask_WaitAbilityEnd
// 0x0078 (0x00F8 - 0x0080)
class UHWAbilityTask_WaitAbilityEnd final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const class UGameplayAbility* EndedAbility)> OnEnd;                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x68];                                      // 0x0090(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHWAbilityTask_WaitAbilityEnd* WaitForAbilityEnd(class UGameplayAbility* OwningAbility, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, bool TriggerOnce);
	static class UHWAbilityTask_WaitAbilityEnd* WaitForAbilityEnd_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& Query, bool TriggerOnce);

	void OnAbilityEnd(const struct FAbilityEndedData& AbilityEndData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_WaitAbilityEnd">();
	}
	static class UHWAbilityTask_WaitAbilityEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_WaitAbilityEnd>();
	}
};
static_assert(alignof(UHWAbilityTask_WaitAbilityEnd) == 0x000008, "Wrong alignment on UHWAbilityTask_WaitAbilityEnd");
static_assert(sizeof(UHWAbilityTask_WaitAbilityEnd) == 0x0000F8, "Wrong size on UHWAbilityTask_WaitAbilityEnd");
static_assert(offsetof(UHWAbilityTask_WaitAbilityEnd, OnEnd) == 0x000080, "Member 'UHWAbilityTask_WaitAbilityEnd::OnEnd' has a wrong offset!");

// Class Hemingway.HWAbilityTask_WaitForRefire
// 0x0050 (0x00D0 - 0x0080)
class UHWAbilityTask_WaitForRefire final : public UAbilityTask
{
public:
	class UAbilityTask_WaitInputPress*            WaitForAbilityInputPressTask;                      // 0x0080(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWEquipmentComponent_Refireable* RefireComponent, const struct FHWAbilityRefireInfo& RefireInfo, const float ElapsedRefireTime)> OnRefireDelegate; // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         RefireWindowDuration;                              // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWAbilityRefireInfo                   RefireInfo;                                        // 0x00A8(0x0020)(Protected, NativeAccessSpecifierProtected)
	class UHWEquipmentComponent_Refireable*       RefireComponent;                                   // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UHWAbilityTask_WaitForRefire* WaitForRefire(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const float RefireWindowTime, const struct FHWAbilityRefireInfo& RefireInfo_0);

	class UHWEquipmentComponent_Refireable* GetRefireComponent();
	void OnAbilityInputPressed(float TimeWaited);
	void OnLocalRefireConfirmCallback();
	void TriggerRefire();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_WaitForRefire">();
	}
	static class UHWAbilityTask_WaitForRefire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_WaitForRefire>();
	}
};
static_assert(alignof(UHWAbilityTask_WaitForRefire) == 0x000008, "Wrong alignment on UHWAbilityTask_WaitForRefire");
static_assert(sizeof(UHWAbilityTask_WaitForRefire) == 0x0000D0, "Wrong size on UHWAbilityTask_WaitForRefire");
static_assert(offsetof(UHWAbilityTask_WaitForRefire, WaitForAbilityInputPressTask) == 0x000080, "Member 'UHWAbilityTask_WaitForRefire::WaitForAbilityInputPressTask' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitForRefire, OnRefireDelegate) == 0x000090, "Member 'UHWAbilityTask_WaitForRefire::OnRefireDelegate' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitForRefire, RefireWindowDuration) == 0x0000A0, "Member 'UHWAbilityTask_WaitForRefire::RefireWindowDuration' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitForRefire, RefireInfo) == 0x0000A8, "Member 'UHWAbilityTask_WaitForRefire::RefireInfo' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_WaitForRefire, RefireComponent) == 0x0000C8, "Member 'UHWAbilityTask_WaitForRefire::RefireComponent' has a wrong offset!");

// Class Hemingway.HWEnvQueryGenerator_TugOfWarSafeZone
// 0x00B0 (0x0140 - 0x0090)
class UHWEnvQueryGenerator_TugOfWarSafeZone final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              SearchExtent;                                      // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderIntValue                SearchDivisions;                                   // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ZOffset;                                           // 0x0100(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           SourceActor;                                       // 0x0138(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEnvQueryGenerator_TugOfWarSafeZone">();
	}
	static class UHWEnvQueryGenerator_TugOfWarSafeZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEnvQueryGenerator_TugOfWarSafeZone>();
	}
};
static_assert(alignof(UHWEnvQueryGenerator_TugOfWarSafeZone) == 0x000008, "Wrong alignment on UHWEnvQueryGenerator_TugOfWarSafeZone");
static_assert(sizeof(UHWEnvQueryGenerator_TugOfWarSafeZone) == 0x000140, "Wrong size on UHWEnvQueryGenerator_TugOfWarSafeZone");
static_assert(offsetof(UHWEnvQueryGenerator_TugOfWarSafeZone, SearchExtent) == 0x000090, "Member 'UHWEnvQueryGenerator_TugOfWarSafeZone::SearchExtent' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryGenerator_TugOfWarSafeZone, SearchDivisions) == 0x0000C8, "Member 'UHWEnvQueryGenerator_TugOfWarSafeZone::SearchDivisions' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryGenerator_TugOfWarSafeZone, ZOffset) == 0x000100, "Member 'UHWEnvQueryGenerator_TugOfWarSafeZone::ZOffset' has a wrong offset!");
static_assert(offsetof(UHWEnvQueryGenerator_TugOfWarSafeZone, SourceActor) == 0x000138, "Member 'UHWEnvQueryGenerator_TugOfWarSafeZone::SourceActor' has a wrong offset!");

// Class Hemingway.HWAnimNotify_MontagePhase
// 0x0098 (0x00D0 - 0x0038)
class UHWAnimNotify_MontagePhase : public UAnimNotify
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0038(0x0008)(Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExclusive;                                      // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               OwnedTagRequirements;                              // 0x0048(0x0088)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimNotify_MontagePhase">();
	}
	static class UHWAnimNotify_MontagePhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimNotify_MontagePhase>();
	}
};
static_assert(alignof(UHWAnimNotify_MontagePhase) == 0x000008, "Wrong alignment on UHWAnimNotify_MontagePhase");
static_assert(sizeof(UHWAnimNotify_MontagePhase) == 0x0000D0, "Wrong size on UHWAnimNotify_MontagePhase");
static_assert(offsetof(UHWAnimNotify_MontagePhase, PhaseTag) == 0x000038, "Member 'UHWAnimNotify_MontagePhase::PhaseTag' has a wrong offset!");
static_assert(offsetof(UHWAnimNotify_MontagePhase, bIsExclusive) == 0x000040, "Member 'UHWAnimNotify_MontagePhase::bIsExclusive' has a wrong offset!");
static_assert(offsetof(UHWAnimNotify_MontagePhase, OwnedTagRequirements) == 0x000048, "Member 'UHWAnimNotify_MontagePhase::OwnedTagRequirements' has a wrong offset!");

// Class Hemingway.HWAnimNotify_AbilityPhaseTransition
// 0x0008 (0x00D8 - 0x00D0)
class UHWAnimNotify_AbilityPhaseTransition final : public UHWAnimNotify_MontagePhase
{
public:
	EAbilityFlowPhase                             DesiredAbilityPhaseTransition;                     // 0x00D0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimNotify_AbilityPhaseTransition">();
	}
	static class UHWAnimNotify_AbilityPhaseTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimNotify_AbilityPhaseTransition>();
	}
};
static_assert(alignof(UHWAnimNotify_AbilityPhaseTransition) == 0x000008, "Wrong alignment on UHWAnimNotify_AbilityPhaseTransition");
static_assert(sizeof(UHWAnimNotify_AbilityPhaseTransition) == 0x0000D8, "Wrong size on UHWAnimNotify_AbilityPhaseTransition");
static_assert(offsetof(UHWAnimNotify_AbilityPhaseTransition, DesiredAbilityPhaseTransition) == 0x0000D0, "Member 'UHWAnimNotify_AbilityPhaseTransition::DesiredAbilityPhaseTransition' has a wrong offset!");

// Class Hemingway.HWAnimState_AbilityPhaseTransition
// 0x0008 (0x0048 - 0x0040)
class UHWAnimState_AbilityPhaseTransition final : public UHWAnimState_MontagePhase
{
public:
	EAbilityFlowPhase                             DesiredAbilityPhaseTransitionAtStateStart;         // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityFlowPhase                             DesiredAbilityPhaseTransitionAtStateEnd;           // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnimState_AbilityPhaseTransition">();
	}
	static class UHWAnimState_AbilityPhaseTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnimState_AbilityPhaseTransition>();
	}
};
static_assert(alignof(UHWAnimState_AbilityPhaseTransition) == 0x000008, "Wrong alignment on UHWAnimState_AbilityPhaseTransition");
static_assert(sizeof(UHWAnimState_AbilityPhaseTransition) == 0x000048, "Wrong size on UHWAnimState_AbilityPhaseTransition");
static_assert(offsetof(UHWAnimState_AbilityPhaseTransition, DesiredAbilityPhaseTransitionAtStateStart) == 0x000040, "Member 'UHWAnimState_AbilityPhaseTransition::DesiredAbilityPhaseTransitionAtStateStart' has a wrong offset!");
static_assert(offsetof(UHWAnimState_AbilityPhaseTransition, DesiredAbilityPhaseTransitionAtStateEnd) == 0x000041, "Member 'UHWAnimState_AbilityPhaseTransition::DesiredAbilityPhaseTransitionAtStateEnd' has a wrong offset!");

// Class Hemingway.HWAssetManager
// 0x00F8 (0x08C8 - 0x07D0)
class UHWAssetManager final : public UPInv_AssetManager
{
public:
	bool                                          bUnloadAssetsOnMapChange;                          // 0x07D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D1[0x7];                                      // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PrimaryAssetTypesToUnloadOnMapChange;              // 0x07D8(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FName>                           BundleNamesToUnloadOnMapChange;                    // 0x07E8(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FName>                           BundleNamesToLoadOnMapChange;                      // 0x07F8(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_808[0xC0];                                     // 0x0808(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAssetManager">();
	}
	static class UHWAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAssetManager>();
	}
};
static_assert(alignof(UHWAssetManager) == 0x000008, "Wrong alignment on UHWAssetManager");
static_assert(sizeof(UHWAssetManager) == 0x0008C8, "Wrong size on UHWAssetManager");
static_assert(offsetof(UHWAssetManager, bUnloadAssetsOnMapChange) == 0x0007D0, "Member 'UHWAssetManager::bUnloadAssetsOnMapChange' has a wrong offset!");
static_assert(offsetof(UHWAssetManager, PrimaryAssetTypesToUnloadOnMapChange) == 0x0007D8, "Member 'UHWAssetManager::PrimaryAssetTypesToUnloadOnMapChange' has a wrong offset!");
static_assert(offsetof(UHWAssetManager, BundleNamesToUnloadOnMapChange) == 0x0007E8, "Member 'UHWAssetManager::BundleNamesToUnloadOnMapChange' has a wrong offset!");
static_assert(offsetof(UHWAssetManager, BundleNamesToLoadOnMapChange) == 0x0007F8, "Member 'UHWAssetManager::BundleNamesToLoadOnMapChange' has a wrong offset!");

// Class Hemingway.HWCharacterAssetLabel
// 0x0028 (0x00A0 - 0x0078)
class UHWCharacterAssetLabel final : public UHWPrimaryAssetLabel
{
public:
	class UHWCharacterItem*                       CharacterItem;                                     // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         DefaultCharacterDirectoryStubs;                    // 0x0080(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, EditConst, NativeAccessSpecifierPrivate)
	class FString                                 GodReplacementString;                              // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacterAssetLabel">();
	}
	static class UHWCharacterAssetLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCharacterAssetLabel>();
	}
};
static_assert(alignof(UHWCharacterAssetLabel) == 0x000008, "Wrong alignment on UHWCharacterAssetLabel");
static_assert(sizeof(UHWCharacterAssetLabel) == 0x0000A0, "Wrong size on UHWCharacterAssetLabel");
static_assert(offsetof(UHWCharacterAssetLabel, CharacterItem) == 0x000078, "Member 'UHWCharacterAssetLabel::CharacterItem' has a wrong offset!");
static_assert(offsetof(UHWCharacterAssetLabel, DefaultCharacterDirectoryStubs) == 0x000080, "Member 'UHWCharacterAssetLabel::DefaultCharacterDirectoryStubs' has a wrong offset!");
static_assert(offsetof(UHWCharacterAssetLabel, GodReplacementString) == 0x000090, "Member 'UHWCharacterAssetLabel::GodReplacementString' has a wrong offset!");

// Class Hemingway.HWSkinAssetLabel
// 0x0048 (0x00C0 - 0x0078)
class UHWSkinAssetLabel final : public UHWPrimaryAssetLabel
{
public:
	class UHWSkinItem*                            SkinItem;                                          // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SkinId;                                            // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         DefaultSkinDirectoryStubs;                         // 0x0090(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, EditConst, NativeAccessSpecifierPrivate)
	class FString                                 GodReplacementString;                              // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SkinReplacementString;                             // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinAssetLabel">();
	}
	static class UHWSkinAssetLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSkinAssetLabel>();
	}
};
static_assert(alignof(UHWSkinAssetLabel) == 0x000008, "Wrong alignment on UHWSkinAssetLabel");
static_assert(sizeof(UHWSkinAssetLabel) == 0x0000C0, "Wrong size on UHWSkinAssetLabel");
static_assert(offsetof(UHWSkinAssetLabel, SkinItem) == 0x000078, "Member 'UHWSkinAssetLabel::SkinItem' has a wrong offset!");
static_assert(offsetof(UHWSkinAssetLabel, SkinId) == 0x000080, "Member 'UHWSkinAssetLabel::SkinId' has a wrong offset!");
static_assert(offsetof(UHWSkinAssetLabel, DefaultSkinDirectoryStubs) == 0x000090, "Member 'UHWSkinAssetLabel::DefaultSkinDirectoryStubs' has a wrong offset!");
static_assert(offsetof(UHWSkinAssetLabel, GodReplacementString) == 0x0000A0, "Member 'UHWSkinAssetLabel::GodReplacementString' has a wrong offset!");
static_assert(offsetof(UHWSkinAssetLabel, SkinReplacementString) == 0x0000B0, "Member 'UHWSkinAssetLabel::SkinReplacementString' has a wrong offset!");

// Class Hemingway.HWDraftReplicatedActor
// 0x0050 (0x0A98 - 0x0A48)
class AHWDraftReplicatedActor final : public ADraftReplicatedActor
{
public:
	uint8                                         Pad_A48[0x38];                                     // 0x0A48(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        BenchChoices;                                      // 0x0A80(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowClientOwnershipChecks;                       // 0x0A90(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGiveOwnershipOnFailedInventory;                   // 0x0A91(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasRerolled;                                      // 0x0A92(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A93[0x5];                                      // 0x0A93(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnPendingPurchaseReceived();
	void OnRep_BenchChoices();
	void RequestReroll();
	void RequestSelectTaskWithRandomChoice();
	void ServerCheatRequestRandomCharacterWithHealerTier(const struct FDraftTaskId& TaskId, EHWDraftHealerRequirement HealerRequirement);
	void ServerRequestFullInventoryUpdate();
	void ServerRequestReroll(const struct FDraftTaskId& TaskId);
	void ServerRequestSelectWithRandomChoice(const struct FDraftTaskId& TaskId);

	EHWDraftType GetDraftType() const;
	bool HasRerolled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDraftReplicatedActor">();
	}
	static class AHWDraftReplicatedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDraftReplicatedActor>();
	}
};
static_assert(alignof(AHWDraftReplicatedActor) == 0x000008, "Wrong alignment on AHWDraftReplicatedActor");
static_assert(sizeof(AHWDraftReplicatedActor) == 0x000A98, "Wrong size on AHWDraftReplicatedActor");
static_assert(offsetof(AHWDraftReplicatedActor, BenchChoices) == 0x000A80, "Member 'AHWDraftReplicatedActor::BenchChoices' has a wrong offset!");
static_assert(offsetof(AHWDraftReplicatedActor, bAllowClientOwnershipChecks) == 0x000A90, "Member 'AHWDraftReplicatedActor::bAllowClientOwnershipChecks' has a wrong offset!");
static_assert(offsetof(AHWDraftReplicatedActor, bGiveOwnershipOnFailedInventory) == 0x000A91, "Member 'AHWDraftReplicatedActor::bGiveOwnershipOnFailedInventory' has a wrong offset!");
static_assert(offsetof(AHWDraftReplicatedActor, bHasRerolled) == 0x000A92, "Member 'AHWDraftReplicatedActor::bHasRerolled' has a wrong offset!");

// Class Hemingway.HWCameraModifier_RotationOverTime
// 0x0040 (0x0088 - 0x0048)
class UHWCameraModifier_RotationOverTime final : public UCameraModifier
{
public:
	TWeakObjectPtr<class AHWCharacter_Base>       CachedTargetCharacter;                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CachedInitialRotation;                             // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               DesiredEndRotation;                                // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimePassed;                                        // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeRotationOverTime(const struct FRotator& InDesiredEndRotation, const float InDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCameraModifier_RotationOverTime">();
	}
	static class UHWCameraModifier_RotationOverTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCameraModifier_RotationOverTime>();
	}
};
static_assert(alignof(UHWCameraModifier_RotationOverTime) == 0x000008, "Wrong alignment on UHWCameraModifier_RotationOverTime");
static_assert(sizeof(UHWCameraModifier_RotationOverTime) == 0x000088, "Wrong size on UHWCameraModifier_RotationOverTime");
static_assert(offsetof(UHWCameraModifier_RotationOverTime, CachedTargetCharacter) == 0x000048, "Member 'UHWCameraModifier_RotationOverTime::CachedTargetCharacter' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_RotationOverTime, CachedInitialRotation) == 0x000050, "Member 'UHWCameraModifier_RotationOverTime::CachedInitialRotation' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_RotationOverTime, DesiredEndRotation) == 0x000068, "Member 'UHWCameraModifier_RotationOverTime::DesiredEndRotation' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_RotationOverTime, Duration) == 0x000080, "Member 'UHWCameraModifier_RotationOverTime::Duration' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_RotationOverTime, TimePassed) == 0x000084, "Member 'UHWCameraModifier_RotationOverTime::TimePassed' has a wrong offset!");

// Class Hemingway.HWCameraModifier_ModifiedFollowVelocity
// 0x0048 (0x0090 - 0x0048)
class UHWCameraModifier_ModifiedFollowVelocity final : public UCameraModifier
{
public:
	class FName                                   SocketToTrack;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TrackingVelocityMultiplier;                        // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWCharacter_Base>       CachedTargetCharacter;                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CachedPreviousCameraLocation;                      // 0x0060(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackingElapsedTime;                               // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnModifierDisabled;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCameraModifier_ModifiedFollowVelocity">();
	}
	static class UHWCameraModifier_ModifiedFollowVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCameraModifier_ModifiedFollowVelocity>();
	}
};
static_assert(alignof(UHWCameraModifier_ModifiedFollowVelocity) == 0x000008, "Wrong alignment on UHWCameraModifier_ModifiedFollowVelocity");
static_assert(sizeof(UHWCameraModifier_ModifiedFollowVelocity) == 0x000090, "Wrong size on UHWCameraModifier_ModifiedFollowVelocity");
static_assert(offsetof(UHWCameraModifier_ModifiedFollowVelocity, SocketToTrack) == 0x000048, "Member 'UHWCameraModifier_ModifiedFollowVelocity::SocketToTrack' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_ModifiedFollowVelocity, TrackingVelocityMultiplier) == 0x000050, "Member 'UHWCameraModifier_ModifiedFollowVelocity::TrackingVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_ModifiedFollowVelocity, CachedTargetCharacter) == 0x000058, "Member 'UHWCameraModifier_ModifiedFollowVelocity::CachedTargetCharacter' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_ModifiedFollowVelocity, CachedPreviousCameraLocation) == 0x000060, "Member 'UHWCameraModifier_ModifiedFollowVelocity::CachedPreviousCameraLocation' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_ModifiedFollowVelocity, TrackingElapsedTime) == 0x000078, "Member 'UHWCameraModifier_ModifiedFollowVelocity::TrackingElapsedTime' has a wrong offset!");
static_assert(offsetof(UHWCameraModifier_ModifiedFollowVelocity, OnModifierDisabled) == 0x000080, "Member 'UHWCameraModifier_ModifiedFollowVelocity::OnModifierDisabled' has a wrong offset!");

// Class Hemingway.HWAutoBuildProfile_GodBuilder
// 0x0010 (0x0088 - 0x0078)
class UHWAutoBuildProfile_GodBuilder final : public UHWAutoBuyBuildProfile
{
public:
	struct FGuid                                  GodBuilderProfileId;                               // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAutoBuildProfile_GodBuilder">();
	}
	static class UHWAutoBuildProfile_GodBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAutoBuildProfile_GodBuilder>();
	}
};
static_assert(alignof(UHWAutoBuildProfile_GodBuilder) == 0x000008, "Wrong alignment on UHWAutoBuildProfile_GodBuilder");
static_assert(sizeof(UHWAutoBuildProfile_GodBuilder) == 0x000088, "Wrong size on UHWAutoBuildProfile_GodBuilder");
static_assert(offsetof(UHWAutoBuildProfile_GodBuilder, GodBuilderProfileId) == 0x000078, "Member 'UHWAutoBuildProfile_GodBuilder::GodBuilderProfileId' has a wrong offset!");

// Class Hemingway.HWAutoSkillComponent
// 0x0048 (0x00E8 - 0x00A0)
class UHWAutoSkillComponent final : public UHWActorComponent
{
public:
	uint8                                         Pad_A0[0x11];                                      // 0x00A0(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEnabled;                                        // 0x00B1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAutoSkillProfile*                    AutoSkillProfile;                                  // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHWInventoryManagerComponent> InventoryManager;                             // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilitySystemComponent*              OwningASC;                                         // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAutoSkillLevelIndex;                        // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableAutoSkill();
	void EnableAutoSkill();
	void OnInventoryManagerChanged(class AHWCharacterAbilitySystemActor* CharASA, class UHWInventoryManagerComponent* InventoryManagerComp);
	void ServerSetAutoSkillState(const bool bEnable);

	bool CanUseAutoSkill() const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAutoSkillComponent">();
	}
	static class UHWAutoSkillComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAutoSkillComponent>();
	}
};
static_assert(alignof(UHWAutoSkillComponent) == 0x000008, "Wrong alignment on UHWAutoSkillComponent");
static_assert(sizeof(UHWAutoSkillComponent) == 0x0000E8, "Wrong size on UHWAutoSkillComponent");
static_assert(offsetof(UHWAutoSkillComponent, bIsEnabled) == 0x0000B1, "Member 'UHWAutoSkillComponent::bIsEnabled' has a wrong offset!");
static_assert(offsetof(UHWAutoSkillComponent, AutoSkillProfile) == 0x0000B8, "Member 'UHWAutoSkillComponent::AutoSkillProfile' has a wrong offset!");
static_assert(offsetof(UHWAutoSkillComponent, InventoryManager) == 0x0000D0, "Member 'UHWAutoSkillComponent::InventoryManager' has a wrong offset!");
static_assert(offsetof(UHWAutoSkillComponent, OwningASC) == 0x0000D8, "Member 'UHWAutoSkillComponent::OwningASC' has a wrong offset!");
static_assert(offsetof(UHWAutoSkillComponent, CurrentAutoSkillLevelIndex) == 0x0000E0, "Member 'UHWAutoSkillComponent::CurrentAutoSkillLevelIndex' has a wrong offset!");

// Class Hemingway.HWAutoSkillProfile_GodBuilder
// 0x0010 (0x0050 - 0x0040)
class UHWAutoSkillProfile_GodBuilder final : public UHWAutoSkillProfile
{
public:
	struct FGuid                                  GodBuilderProfileId;                               // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAutoSkillProfile_GodBuilder">();
	}
	static class UHWAutoSkillProfile_GodBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAutoSkillProfile_GodBuilder>();
	}
};
static_assert(alignof(UHWAutoSkillProfile_GodBuilder) == 0x000008, "Wrong alignment on UHWAutoSkillProfile_GodBuilder");
static_assert(sizeof(UHWAutoSkillProfile_GodBuilder) == 0x000050, "Wrong size on UHWAutoSkillProfile_GodBuilder");
static_assert(offsetof(UHWAutoSkillProfile_GodBuilder, GodBuilderProfileId) == 0x000040, "Member 'UHWAutoSkillProfile_GodBuilder::GodBuilderProfileId' has a wrong offset!");

// Class Hemingway.HWCharacterMovementComponent
// 0x02A0 (0x11F0 - 0x0F50)
class UHWCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_F48[0x68];                                     // 0x0F48(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedBaseMovementSpeedValue;                      // 0x0FB0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CachedMovementSpeedDiminishingReturnPercentAttributeValue; // 0x0FB4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CachedBaseMovementSpeedModifierPercentAttributeValue; // 0x0FB8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CachedInhandMoveSpeedPenaltyPercentAttributeValue; // 0x0FBC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CachedGroundSpeedForwardPercentAttributeValue;     // 0x0FC0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CachedGroundSpeedBackpedalPercentAttributeValue;   // 0x0FC4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CachedGroundSpeedStrafePercentAttributeValue;      // 0x0FC8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWantsInHandSlow;                                  // 0x0FCC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCachedHasInHandSlowTags;                          // 0x0FCD(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FCE[0x42];                                     // 0x0FCE(0x0042)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BotDesiredSpeedRatio;                              // 0x1010(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumMaxMoveSpeed;                               // 0x1014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHWDiminishingReturnThresholdInfo> BaseMovementSpeedDRThresholds;                  // 0x1018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         MovementSpeedDRThreshold;                          // 0x1028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeedDRAdditive;                           // 0x102C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnTweenEndedDelegate;                              // 0x1030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWGameplayTween*                       CurrentTween;                                      // 0x1040(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWGameplayTween*                       PendingTween;                                      // 0x1048(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWTweenEndEvent                       TweenEndEvent;                                     // 0x1050(0x000C)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_105C[0x4];                                     // 0x105C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWGameplayTween*                       LastReceievedTween;                                // 0x1060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWGameplayFlight* Flight)> OnFlightStartedDelegate;         // 0x1068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWGameplayFlight*                      CurrentFlight;                                     // 0x1078(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWGameplayFlight*                      PendingFlight;                                     // 0x1080(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWGameplayGrab* Grab)> OnGrabStartedDelegate;               // 0x1088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWGameplayGrab*                        CurrentGrab;                                       // 0x1098(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWGameplayGrab*                        PendingGrab;                                       // 0x10A0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ClientEndDashExpiredTrigger;                       // 0x10A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A9[0x3];                                     // 0x10A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  ActorDashStoppedOn;                                // 0x10AC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B4[0x4];                                     // 0x10B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWGameplayDash*                        CurrentDash;                                       // 0x10B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWGameplayDash*                        PendingDash;                                       // 0x10C0(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWGameplayDash*                        LastReceievedDash;                                 // 0x10C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWPreviousDashInfo                    PreviousDashInfo;                                  // 0x10D0(0x0028)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWPriorityQueueDashNode>       DashPriorityQueue;                                 // 0x10F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPendingDashSetThisTick;                           // 0x1108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPendingDashClearedThisTick;                       // 0x1109(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_110A[0x6];                                     // 0x110A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EHWEndLevitationReason EndLevitationReason)> OnLevitationEndedDelegate; // 0x1110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWGameplayLevitate*                    CurrentLevitation;                                 // 0x1120(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWGameplayLevitate*                    PendingLevitation;                                 // 0x1128(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHWCharacterCapsuleComponent*>   MonitoredCurrentlyOverlappedCharacters;            // 0x1130(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UHWCharacterCapsuleComponent*>   CharactersToForceBlockDuringIgnore;                // 0x1140(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1150[0x8];                                     // 0x1150(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallImpactSpeed;                                   // 0x1158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_115C[0x4];                                     // 0x115C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWForcedCharacterMovementInfo> ForcedMovementInfos;                               // 0x1160(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWLastValidGroundLocationForPoE> LastValidGroundLocationsPerPlaneOfExistence;     // 0x1170(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsCurrentGroundLocationValid;                     // 0x1180(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1181[0x3];                                     // 0x1181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseGravityOverride;                            // 0x1184(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWMovementSpeedOverTimeMove           CurrentMovementSpeedOverTimeMoveSlow;              // 0x1188(0x0030)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHWMovementSpeedOverTimeMove           CurrentMovementSpeedOverTimeMoveBuff;              // 0x11B8(0x0030)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIgnoreFirstPendingMoveForRootMotion;              // 0x11E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E9[0x7];                                     // 0x11E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddForceMovementInfo(const struct FHWForcedCharacterMovementInfo& ForcedMoveInfo);
	class UHWGameplayDash* AttemptStartDash(TSubclassOf<class UHWGameplayDash> Dash, class AActor* Instigator, class UGameplayAbility* InstigatingAbility, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, const float DurationOverride, const struct FRotator& DashRotation);
	void ClientEndDashCollidedTrigger(const struct FHWDashEndInfo& EndInfo, const struct FPredictionKey& PredictionKey);
	void EndAllCurrentAndPendingCustomMovement(const struct FHWEndCustomMovementRules& EndCustomMovementRules);
	void EndFlight();
	void EndGrab();
	void EndTween();
	void ForceClientPendingDashUpdate(class UHWGameplayDash* ServerCurrentPendingDash);
	void OnAttributeSystemAssigned(class UHWAbilitySystemComponent* AbilitySystem, class UHWAbilitySystemComponent* OldAbilitySystem);
	void OnInhandTagAddedOrRemoved(const struct FGameplayTag& Tag, int32 TagCount, class UHWAbilitySystemComponent* AbilitySystem);
	void OnRep_ClientEndDashExpiredTrigger();
	void OnRep_PendingDash();
	void OnRep_PendingFlight();
	void OnRep_PendingGrab();
	void OnRep_PendingLevitation();
	void OnRep_PendingTween();
	void RemoveForceMovementInfo(const struct FActiveGameplayEffectHandle& ForcedMovementEffectHandle);
	void ServerEndDashCollided(const struct FHWDashEndInfo& DashEndInfo);
	class UHWGameplayFlight* StartFlight(TSubclassOf<class UHWGameplayFlight> Flight, class AActor* Instigator, class UGameplayAbility* InstigatingAbility, const float AscentDurationOverride);
	class UHWGameplayGrab* StartGrab(TSubclassOf<class UHWGameplayGrab> Grab, struct FHWGrabInfo* GrabInfo, class UHWAbilityTask_GameplayGrab* GrabTask);
	class UHWGameplayTween* StartNonAbilityTween(TSubclassOf<class UHWGameplayTween> Tween, const struct FGameplayAbilityTargetDataHandle& TargetData, class AActor* Instigator, const float DurationOverride, struct FVector* TargetDest, class AActor* FollowTarget, bool bShouldMaintainCharacterCollision);
	class UHWGameplayTween* StartTween(TSubclassOf<class UHWGameplayTween> Tween, const struct FGameplayAbilityTargetDataHandle& TargetData, class AActor* Instigator, class UGameplayAbility* InstigatingAbility, const float DurationOverride, class UHWAbilityTask_GameplayTween* TaskSource);

	class AActor* GetActorDashStoppedOn() const;
	EHWCustomMovementMode GetCurrentCustomMovementMode() const;
	class UHWGameplayDash* GetCurrentDash() const;
	class UHWGameplayFlight* GetCurrentFlight() const;
	class UHWGameplayGrab* GetCurrentGrab() const;
	EHWLevitationState GetCurrentLevitationState() const;
	class UHWGameplayTween* GetCurrentTween() const;
	struct FVector GetLastValidGroundLocation(const struct FGameplayTag& PlaneOfExistence) const;
	float GetMaxSpeedWithoutGroundModifier() const;
	const class UHWGameplayGrab* GetPendingGrab() const;
	const class UHWGameplayTween* GetPendingTween() const;
	bool HasValidGroundLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacterMovementComponent">();
	}
	static class UHWCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCharacterMovementComponent>();
	}
};
static_assert(alignof(UHWCharacterMovementComponent) == 0x000010, "Wrong alignment on UHWCharacterMovementComponent");
static_assert(sizeof(UHWCharacterMovementComponent) == 0x0011F0, "Wrong size on UHWCharacterMovementComponent");
static_assert(offsetof(UHWCharacterMovementComponent, CachedBaseMovementSpeedValue) == 0x000FB0, "Member 'UHWCharacterMovementComponent::CachedBaseMovementSpeedValue' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CachedMovementSpeedDiminishingReturnPercentAttributeValue) == 0x000FB4, "Member 'UHWCharacterMovementComponent::CachedMovementSpeedDiminishingReturnPercentAttributeValue' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CachedBaseMovementSpeedModifierPercentAttributeValue) == 0x000FB8, "Member 'UHWCharacterMovementComponent::CachedBaseMovementSpeedModifierPercentAttributeValue' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CachedInhandMoveSpeedPenaltyPercentAttributeValue) == 0x000FBC, "Member 'UHWCharacterMovementComponent::CachedInhandMoveSpeedPenaltyPercentAttributeValue' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CachedGroundSpeedForwardPercentAttributeValue) == 0x000FC0, "Member 'UHWCharacterMovementComponent::CachedGroundSpeedForwardPercentAttributeValue' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CachedGroundSpeedBackpedalPercentAttributeValue) == 0x000FC4, "Member 'UHWCharacterMovementComponent::CachedGroundSpeedBackpedalPercentAttributeValue' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CachedGroundSpeedStrafePercentAttributeValue) == 0x000FC8, "Member 'UHWCharacterMovementComponent::CachedGroundSpeedStrafePercentAttributeValue' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, bWantsInHandSlow) == 0x000FCC, "Member 'UHWCharacterMovementComponent::bWantsInHandSlow' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, bCachedHasInHandSlowTags) == 0x000FCD, "Member 'UHWCharacterMovementComponent::bCachedHasInHandSlowTags' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, BotDesiredSpeedRatio) == 0x001010, "Member 'UHWCharacterMovementComponent::BotDesiredSpeedRatio' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, MinimumMaxMoveSpeed) == 0x001014, "Member 'UHWCharacterMovementComponent::MinimumMaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, BaseMovementSpeedDRThresholds) == 0x001018, "Member 'UHWCharacterMovementComponent::BaseMovementSpeedDRThresholds' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, MovementSpeedDRThreshold) == 0x001028, "Member 'UHWCharacterMovementComponent::MovementSpeedDRThreshold' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, MovementSpeedDRAdditive) == 0x00102C, "Member 'UHWCharacterMovementComponent::MovementSpeedDRAdditive' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, OnTweenEndedDelegate) == 0x001030, "Member 'UHWCharacterMovementComponent::OnTweenEndedDelegate' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CurrentTween) == 0x001040, "Member 'UHWCharacterMovementComponent::CurrentTween' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, PendingTween) == 0x001048, "Member 'UHWCharacterMovementComponent::PendingTween' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, TweenEndEvent) == 0x001050, "Member 'UHWCharacterMovementComponent::TweenEndEvent' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, LastReceievedTween) == 0x001060, "Member 'UHWCharacterMovementComponent::LastReceievedTween' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, OnFlightStartedDelegate) == 0x001068, "Member 'UHWCharacterMovementComponent::OnFlightStartedDelegate' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CurrentFlight) == 0x001078, "Member 'UHWCharacterMovementComponent::CurrentFlight' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, PendingFlight) == 0x001080, "Member 'UHWCharacterMovementComponent::PendingFlight' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, OnGrabStartedDelegate) == 0x001088, "Member 'UHWCharacterMovementComponent::OnGrabStartedDelegate' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CurrentGrab) == 0x001098, "Member 'UHWCharacterMovementComponent::CurrentGrab' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, PendingGrab) == 0x0010A0, "Member 'UHWCharacterMovementComponent::PendingGrab' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, ClientEndDashExpiredTrigger) == 0x0010A8, "Member 'UHWCharacterMovementComponent::ClientEndDashExpiredTrigger' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, ActorDashStoppedOn) == 0x0010AC, "Member 'UHWCharacterMovementComponent::ActorDashStoppedOn' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CurrentDash) == 0x0010B8, "Member 'UHWCharacterMovementComponent::CurrentDash' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, PendingDash) == 0x0010C0, "Member 'UHWCharacterMovementComponent::PendingDash' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, LastReceievedDash) == 0x0010C8, "Member 'UHWCharacterMovementComponent::LastReceievedDash' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, PreviousDashInfo) == 0x0010D0, "Member 'UHWCharacterMovementComponent::PreviousDashInfo' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, DashPriorityQueue) == 0x0010F8, "Member 'UHWCharacterMovementComponent::DashPriorityQueue' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, bPendingDashSetThisTick) == 0x001108, "Member 'UHWCharacterMovementComponent::bPendingDashSetThisTick' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, bPendingDashClearedThisTick) == 0x001109, "Member 'UHWCharacterMovementComponent::bPendingDashClearedThisTick' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, OnLevitationEndedDelegate) == 0x001110, "Member 'UHWCharacterMovementComponent::OnLevitationEndedDelegate' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CurrentLevitation) == 0x001120, "Member 'UHWCharacterMovementComponent::CurrentLevitation' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, PendingLevitation) == 0x001128, "Member 'UHWCharacterMovementComponent::PendingLevitation' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, MonitoredCurrentlyOverlappedCharacters) == 0x001130, "Member 'UHWCharacterMovementComponent::MonitoredCurrentlyOverlappedCharacters' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CharactersToForceBlockDuringIgnore) == 0x001140, "Member 'UHWCharacterMovementComponent::CharactersToForceBlockDuringIgnore' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, WallImpactSpeed) == 0x001158, "Member 'UHWCharacterMovementComponent::WallImpactSpeed' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, ForcedMovementInfos) == 0x001160, "Member 'UHWCharacterMovementComponent::ForcedMovementInfos' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, LastValidGroundLocationsPerPlaneOfExistence) == 0x001170, "Member 'UHWCharacterMovementComponent::LastValidGroundLocationsPerPlaneOfExistence' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, bIsCurrentGroundLocationValid) == 0x001180, "Member 'UHWCharacterMovementComponent::bIsCurrentGroundLocationValid' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, ImpulseGravityOverride) == 0x001184, "Member 'UHWCharacterMovementComponent::ImpulseGravityOverride' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CurrentMovementSpeedOverTimeMoveSlow) == 0x001188, "Member 'UHWCharacterMovementComponent::CurrentMovementSpeedOverTimeMoveSlow' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, CurrentMovementSpeedOverTimeMoveBuff) == 0x0011B8, "Member 'UHWCharacterMovementComponent::CurrentMovementSpeedOverTimeMoveBuff' has a wrong offset!");
static_assert(offsetof(UHWCharacterMovementComponent, bIgnoreFirstPendingMoveForRootMotion) == 0x0011E8, "Member 'UHWCharacterMovementComponent::bIgnoreFirstPendingMoveForRootMotion' has a wrong offset!");

// Class Hemingway.HWCharacter_NPC_Structure_WithBeam
// 0x0010 (0x1400 - 0x13F0)
class AHWCharacter_NPC_Structure_WithBeam : public AHWCharacter_NPC
{
public:
	TSubclassOf<class UGameplayEffect>            TargetingBeamEffect;                               // 0x13E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAbilitySystemComponent> CurrentBeamTarget;                                 // 0x13F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            ActiveBeamEffectHandle;                            // 0x13F8(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_NPC_Structure_WithBeam">();
	}
	static class AHWCharacter_NPC_Structure_WithBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_NPC_Structure_WithBeam>();
	}
};
static_assert(alignof(AHWCharacter_NPC_Structure_WithBeam) == 0x000010, "Wrong alignment on AHWCharacter_NPC_Structure_WithBeam");
static_assert(sizeof(AHWCharacter_NPC_Structure_WithBeam) == 0x001400, "Wrong size on AHWCharacter_NPC_Structure_WithBeam");
static_assert(offsetof(AHWCharacter_NPC_Structure_WithBeam, TargetingBeamEffect) == 0x0013E8, "Member 'AHWCharacter_NPC_Structure_WithBeam::TargetingBeamEffect' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC_Structure_WithBeam, CurrentBeamTarget) == 0x0013F0, "Member 'AHWCharacter_NPC_Structure_WithBeam::CurrentBeamTarget' has a wrong offset!");
static_assert(offsetof(AHWCharacter_NPC_Structure_WithBeam, ActiveBeamEffectHandle) == 0x0013F8, "Member 'AHWCharacter_NPC_Structure_WithBeam::ActiveBeamEffectHandle' has a wrong offset!");

// Class Hemingway.HWChatManagerMessageFormatter
// 0x0000 (0x0028 - 0x0028)
class UHWChatManagerMessageFormatter : public UObject
{
public:
	class FText FormatText(const class FText& InUnformattedText, const class UObject* ContextObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWChatManagerMessageFormatter">();
	}
	static class UHWChatManagerMessageFormatter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWChatManagerMessageFormatter>();
	}
};
static_assert(alignof(UHWChatManagerMessageFormatter) == 0x000008, "Wrong alignment on UHWChatManagerMessageFormatter");
static_assert(sizeof(UHWChatManagerMessageFormatter) == 0x000028, "Wrong size on UHWChatManagerMessageFormatter");

// Class Hemingway.HWChatManagerFormatter_ItemPurchased
// 0x0000 (0x0028 - 0x0028)
class UHWChatManagerFormatter_ItemPurchased final : public UHWChatManagerMessageFormatter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWChatManagerFormatter_ItemPurchased">();
	}
	static class UHWChatManagerFormatter_ItemPurchased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWChatManagerFormatter_ItemPurchased>();
	}
};
static_assert(alignof(UHWChatManagerFormatter_ItemPurchased) == 0x000008, "Wrong alignment on UHWChatManagerFormatter_ItemPurchased");
static_assert(sizeof(UHWChatManagerFormatter_ItemPurchased) == 0x000028, "Wrong size on UHWChatManagerFormatter_ItemPurchased");

// Class Hemingway.HWChatManagerFormatter_VIPBoosting
// 0x0000 (0x0028 - 0x0028)
class UHWChatManagerFormatter_VIPBoosting final : public UHWChatManagerMessageFormatter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWChatManagerFormatter_VIPBoosting">();
	}
	static class UHWChatManagerFormatter_VIPBoosting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWChatManagerFormatter_VIPBoosting>();
	}
};
static_assert(alignof(UHWChatManagerFormatter_VIPBoosting) == 0x000008, "Wrong alignment on UHWChatManagerFormatter_VIPBoosting");
static_assert(sizeof(UHWChatManagerFormatter_VIPBoosting) == 0x000028, "Wrong size on UHWChatManagerFormatter_VIPBoosting");

// Class Hemingway.HWApparelComponent
// 0x0180 (0x0220 - 0x00A0)
class UHWApparelComponent final : public UActorComponent
{
public:
	struct FHWAppliedApparelKeyGenerator          KeyGenerator;                                      // 0x00A0(0x0004)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x3C];                                      // 0x00A4(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FHWAppliedApparelKey, class UHWApparelItem*> AppliedApparelMap;                      // 0x00E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bApparelAssetMapDirty;                             // 0x0130(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FHWAppliedApparelKey> SlotToApparelKeyMap;                              // 0x0138(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UHWApparelItem*>                 ApparelAssets;                                     // 0x0188(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bNoApparel;                                        // 0x0198(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyApparelOnDedicatedServer;                    // 0x0199(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClientAuthoritativeLocalApparel;                  // 0x019A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19B[0x5];                                      // 0x019B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWApparelItem*>                 LocalApparelAssets;                                // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	EHWApparelComponentState                      State;                                             // 0x01B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasAppliedApparelInstancesOnce;                   // 0x01B1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B2[0x6E];                                     // 0x01B2(0x006E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ApplyApparelAsset(class UHWApparelItem* ApparelAsset, struct FHWAppliedApparelKey* OutKey);
	void OnRep_ApparelAssets();
	bool RemoveApparelAsset(const struct FHWAppliedApparelKey& InKey);
	void TryToMarkAsNoApparel();

	struct FHWSkinnedMetaSoundInfo GetSkinnedAudio(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWSkinnedMaterialInfo GetSkinnedMaterial(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWMontageInfo GetSkinnedMontage(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWSkinnedNiagaraInfo GetSkinnedNiagaraSystem(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWDataAssetInfo GetSkinnedOptionalDataAsset(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWSkinnedSkeletalMeshInfo GetSkinnedSkeletalMesh(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWSkinnedStaticMeshInfo GetSkinnedStaticMesh(const struct FAssetRequestKey& AssetRequest) const;
	bool IsApparelApplicationPending() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWApparelComponent">();
	}
	static class UHWApparelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWApparelComponent>();
	}
};
static_assert(alignof(UHWApparelComponent) == 0x000008, "Wrong alignment on UHWApparelComponent");
static_assert(sizeof(UHWApparelComponent) == 0x000220, "Wrong size on UHWApparelComponent");
static_assert(offsetof(UHWApparelComponent, KeyGenerator) == 0x0000A0, "Member 'UHWApparelComponent::KeyGenerator' has a wrong offset!");
static_assert(offsetof(UHWApparelComponent, AppliedApparelMap) == 0x0000E0, "Member 'UHWApparelComponent::AppliedApparelMap' has a wrong offset!");
static_assert(offsetof(UHWApparelComponent, bApparelAssetMapDirty) == 0x000130, "Member 'UHWApparelComponent::bApparelAssetMapDirty' has a wrong offset!");
static_assert(offsetof(UHWApparelComponent, SlotToApparelKeyMap) == 0x000138, "Member 'UHWApparelComponent::SlotToApparelKeyMap' has a wrong offset!");
static_assert(offsetof(UHWApparelComponent, ApparelAssets) == 0x000188, "Member 'UHWApparelComponent::ApparelAssets' has a wrong offset!");
static_assert(offsetof(UHWApparelComponent, bNoApparel) == 0x000198, "Member 'UHWApparelComponent::bNoApparel' has a wrong offset!");
static_assert(offsetof(UHWApparelComponent, bApplyApparelOnDedicatedServer) == 0x000199, "Member 'UHWApparelComponent::bApplyApparelOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(UHWApparelComponent, bClientAuthoritativeLocalApparel) == 0x00019A, "Member 'UHWApparelComponent::bClientAuthoritativeLocalApparel' has a wrong offset!");
static_assert(offsetof(UHWApparelComponent, LocalApparelAssets) == 0x0001A0, "Member 'UHWApparelComponent::LocalApparelAssets' has a wrong offset!");
static_assert(offsetof(UHWApparelComponent, State) == 0x0001B0, "Member 'UHWApparelComponent::State' has a wrong offset!");
static_assert(offsetof(UHWApparelComponent, bHasAppliedApparelInstancesOnce) == 0x0001B1, "Member 'UHWApparelComponent::bHasAppliedApparelInstancesOnce' has a wrong offset!");

// Class Hemingway.HWDynamicSubLevelComponent
// 0x0010 (0x00B0 - 0x00A0)
class UHWDynamicSubLevelComponent final : public UActorComponent
{
public:
	TArray<struct FHWDynamicSubLevelEntry>        DynamicSubLevels;                                  // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDynamicSubLevelComponent">();
	}
	static class UHWDynamicSubLevelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDynamicSubLevelComponent>();
	}
};
static_assert(alignof(UHWDynamicSubLevelComponent) == 0x000008, "Wrong alignment on UHWDynamicSubLevelComponent");
static_assert(sizeof(UHWDynamicSubLevelComponent) == 0x0000B0, "Wrong size on UHWDynamicSubLevelComponent");
static_assert(offsetof(UHWDynamicSubLevelComponent, DynamicSubLevels) == 0x0000A0, "Member 'UHWDynamicSubLevelComponent::DynamicSubLevels' has a wrong offset!");

// Class Hemingway.HWGeometryCollectionComponent
// 0x0000 (0x0BE0 - 0x0BE0)
class UHWGeometryCollectionComponent final : public UGeometryCollectionComponent
{
public:
	class FName                                   SkinningKeyword;                                   // 0x0BD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGeometryCollectionComponent">();
	}
	static class UHWGeometryCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGeometryCollectionComponent>();
	}
};
static_assert(alignof(UHWGeometryCollectionComponent) == 0x000010, "Wrong alignment on UHWGeometryCollectionComponent");
static_assert(sizeof(UHWGeometryCollectionComponent) == 0x000BE0, "Wrong size on UHWGeometryCollectionComponent");
static_assert(offsetof(UHWGeometryCollectionComponent, SkinningKeyword) == 0x000BD8, "Member 'UHWGeometryCollectionComponent::SkinningKeyword' has a wrong offset!");

// Class Hemingway.HWGroundTargetingPlacementBlockerComponent
// 0x0000 (0x06F0 - 0x06F0)
class UHWGroundTargetingPlacementBlockerComponent final : public UHWStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGroundTargetingPlacementBlockerComponent">();
	}
	static class UHWGroundTargetingPlacementBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGroundTargetingPlacementBlockerComponent>();
	}
};
static_assert(alignof(UHWGroundTargetingPlacementBlockerComponent) == 0x000010, "Wrong alignment on UHWGroundTargetingPlacementBlockerComponent");
static_assert(sizeof(UHWGroundTargetingPlacementBlockerComponent) == 0x0006F0, "Wrong size on UHWGroundTargetingPlacementBlockerComponent");

// Class Hemingway.HWInWorldTextWidgetComponent
// 0x0040 (0x0730 - 0x06F0)
class UHWInWorldTextWidgetComponent final : public UWidgetComponent
{
public:
	TMulticastInlineDelegate<void(const class FText& NewInWorldText)> OnInWorldTextUpdated;          // 0x06E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   InWorldText;                                       // 0x06F8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           InWorldTextFontStyleTag;                           // 0x0710(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           InWorldTextFontColorTag;                           // 0x0718(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWrapText;                                         // 0x0720(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_721[0x3];                                      // 0x0721(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WrapTextAt;                                        // 0x0724(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_728[0x8];                                      // 0x0728(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInWorldText(const class FText& NewInWorldText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInWorldTextWidgetComponent">();
	}
	static class UHWInWorldTextWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInWorldTextWidgetComponent>();
	}
};
static_assert(alignof(UHWInWorldTextWidgetComponent) == 0x000010, "Wrong alignment on UHWInWorldTextWidgetComponent");
static_assert(sizeof(UHWInWorldTextWidgetComponent) == 0x000730, "Wrong size on UHWInWorldTextWidgetComponent");
static_assert(offsetof(UHWInWorldTextWidgetComponent, OnInWorldTextUpdated) == 0x0006E8, "Member 'UHWInWorldTextWidgetComponent::OnInWorldTextUpdated' has a wrong offset!");
static_assert(offsetof(UHWInWorldTextWidgetComponent, InWorldText) == 0x0006F8, "Member 'UHWInWorldTextWidgetComponent::InWorldText' has a wrong offset!");
static_assert(offsetof(UHWInWorldTextWidgetComponent, InWorldTextFontStyleTag) == 0x000710, "Member 'UHWInWorldTextWidgetComponent::InWorldTextFontStyleTag' has a wrong offset!");
static_assert(offsetof(UHWInWorldTextWidgetComponent, InWorldTextFontColorTag) == 0x000718, "Member 'UHWInWorldTextWidgetComponent::InWorldTextFontColorTag' has a wrong offset!");
static_assert(offsetof(UHWInWorldTextWidgetComponent, bWrapText) == 0x000720, "Member 'UHWInWorldTextWidgetComponent::bWrapText' has a wrong offset!");
static_assert(offsetof(UHWInWorldTextWidgetComponent, WrapTextAt) == 0x000724, "Member 'UHWInWorldTextWidgetComponent::WrapTextAt' has a wrong offset!");

// Class Hemingway.HWLoadoutComponent
// 0x02B0 (0x0350 - 0x00A0)
class UHWLoadoutComponent final : public UHWActorComponent
{
public:
	uint8                                         Pad_A0[0x40];                                      // 0x00A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWCharacterItem*                       CharacterItem;                                     // 0x00E0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWSkinItem*                            SkinItem;                                          // 0x00E8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWVoicePackItem*                       VoicePackItem;                                     // 0x00F0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x78];                                      // 0x00F8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(TScriptInterface<class IHWInterface_LoadoutManagement> LoadoutOwner, const class UHWCollectionItem* NewGlobalEmoteItem, const int32 SlotIndex)> OnCosmeticItemUpdatedDelegate; // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<EHWCollectionItemType, int32>            CosmeticInventoryConfig;                           // 0x0180(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FHWCosmeticLoadoutInventory            CosmeticInventory;                                 // 0x01D0(0x0170)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSkinningTargetChanged(class AActor* NewSkinningTarget);
	void OnRep_CharacterItem();
	void OnRep_SkinItem();
	void OnRep_VoicePackItem();
	void ServerLoadCosmeticItems(const TArray<struct FHWCosmeticLoadoutInfo>& Cosmetics);

	void GetAssetBundleForCosmeticTypes(const TArray<EHWCollectionItemType>& CosmeticTypes, TArray<class FName>* OutBundles) const;
	const class UHWCollectionItem* GetCosmeticItem(EHWCollectionItemType CosmeticItemType, int32 SlotIndex) const;
	const class UHWCharacterItem* GetCurrentCharacterItem() const;
	const class UHWSkinItem* GetCurrentSkinItem() const;
	const class UHWVoicePackItem* GetCurrentVoicePackItem() const;
	bool IsLocalOnlyCosmetic(const EHWCollectionItemType CosmeticType) const;
	void LogCosmeticInventory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLoadoutComponent">();
	}
	static class UHWLoadoutComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLoadoutComponent>();
	}
};
static_assert(alignof(UHWLoadoutComponent) == 0x000008, "Wrong alignment on UHWLoadoutComponent");
static_assert(sizeof(UHWLoadoutComponent) == 0x000350, "Wrong size on UHWLoadoutComponent");
static_assert(offsetof(UHWLoadoutComponent, CharacterItem) == 0x0000E0, "Member 'UHWLoadoutComponent::CharacterItem' has a wrong offset!");
static_assert(offsetof(UHWLoadoutComponent, SkinItem) == 0x0000E8, "Member 'UHWLoadoutComponent::SkinItem' has a wrong offset!");
static_assert(offsetof(UHWLoadoutComponent, VoicePackItem) == 0x0000F0, "Member 'UHWLoadoutComponent::VoicePackItem' has a wrong offset!");
static_assert(offsetof(UHWLoadoutComponent, OnCosmeticItemUpdatedDelegate) == 0x000170, "Member 'UHWLoadoutComponent::OnCosmeticItemUpdatedDelegate' has a wrong offset!");
static_assert(offsetof(UHWLoadoutComponent, CosmeticInventoryConfig) == 0x000180, "Member 'UHWLoadoutComponent::CosmeticInventoryConfig' has a wrong offset!");
static_assert(offsetof(UHWLoadoutComponent, CosmeticInventory) == 0x0001D0, "Member 'UHWLoadoutComponent::CosmeticInventory' has a wrong offset!");

// Class Hemingway.HWProjectileMovementComponent
// 0x00E0 (0x03E0 - 0x0300)
class UHWProjectileMovementComponent final : public UHWGameplayMovementComponent
{
public:
	class AHWProjectile*                          ProjectileOwner;                                   // 0x0300(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopSimulatingOnBlockingHit;                      // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialSpawnTransform;                             // 0x0310(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastSparseDelegateProperty_             OnProjectileTargetOverlap;                         // 0x0370(0x0001)(BlueprintVisible, BlueprintReadOnly, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_371[0x13];                                     // 0x0371(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTimeBeforeTrackingHomingTarget;               // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StickingToTargetDistanceThreshold;                 // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePredictiveHoming;                              // 0x038C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldSeekToLocation;                             // 0x038D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38E[0x2];                                      // 0x038E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HomingSeekLocation;                                // 0x0390(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSpawnRotationAsInitialTrajectory;              // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HomingInitialTrajectoryAdjustment;                 // 0x03B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         HomingYawTurnStrength;                             // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingPitchTurnStrength;                           // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RampUpTurnStrengthThreshold;                       // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingDistanceThresholdToForceRotation;            // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSplineFollowingProjectile;                      // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHomingTargetLocation(const struct FVector& DesiredHomingLocation, const bool bShouldSeekToLocation_0);
	void SetRotationDirectlyToHomingTarget();
	void SetVelocityDirectlyToHomingTarget();

	struct FVector GetHomingDirection() const;
	struct FVector GetHomingTargetLocation() const;
	bool IsHomingToLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWProjectileMovementComponent">();
	}
	static class UHWProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWProjectileMovementComponent>();
	}
};
static_assert(alignof(UHWProjectileMovementComponent) == 0x000010, "Wrong alignment on UHWProjectileMovementComponent");
static_assert(sizeof(UHWProjectileMovementComponent) == 0x0003E0, "Wrong size on UHWProjectileMovementComponent");
static_assert(offsetof(UHWProjectileMovementComponent, ProjectileOwner) == 0x000300, "Member 'UHWProjectileMovementComponent::ProjectileOwner' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, bStopSimulatingOnBlockingHit) == 0x000308, "Member 'UHWProjectileMovementComponent::bStopSimulatingOnBlockingHit' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, InitialSpawnTransform) == 0x000310, "Member 'UHWProjectileMovementComponent::InitialSpawnTransform' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, OnProjectileTargetOverlap) == 0x000370, "Member 'UHWProjectileMovementComponent::OnProjectileTargetOverlap' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, DelayTimeBeforeTrackingHomingTarget) == 0x000384, "Member 'UHWProjectileMovementComponent::DelayTimeBeforeTrackingHomingTarget' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, StickingToTargetDistanceThreshold) == 0x000388, "Member 'UHWProjectileMovementComponent::StickingToTargetDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, bUsePredictiveHoming) == 0x00038C, "Member 'UHWProjectileMovementComponent::bUsePredictiveHoming' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, bShouldSeekToLocation) == 0x00038D, "Member 'UHWProjectileMovementComponent::bShouldSeekToLocation' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, HomingSeekLocation) == 0x000390, "Member 'UHWProjectileMovementComponent::HomingSeekLocation' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, bUseSpawnRotationAsInitialTrajectory) == 0x0003A8, "Member 'UHWProjectileMovementComponent::bUseSpawnRotationAsInitialTrajectory' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, HomingInitialTrajectoryAdjustment) == 0x0003B0, "Member 'UHWProjectileMovementComponent::HomingInitialTrajectoryAdjustment' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, HomingYawTurnStrength) == 0x0003C8, "Member 'UHWProjectileMovementComponent::HomingYawTurnStrength' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, HomingPitchTurnStrength) == 0x0003CC, "Member 'UHWProjectileMovementComponent::HomingPitchTurnStrength' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, RampUpTurnStrengthThreshold) == 0x0003D0, "Member 'UHWProjectileMovementComponent::RampUpTurnStrengthThreshold' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, HomingDistanceThresholdToForceRotation) == 0x0003D4, "Member 'UHWProjectileMovementComponent::HomingDistanceThresholdToForceRotation' has a wrong offset!");
static_assert(offsetof(UHWProjectileMovementComponent, bIsSplineFollowingProjectile) == 0x0003D8, "Member 'UHWProjectileMovementComponent::bIsSplineFollowingProjectile' has a wrong offset!");

// Class Hemingway.HWSkeletalMeshComponent
// 0x0140 (0x1260 - 0x1120)
class UHWSkeletalMeshComponent final : public USkinnableSkeletalMeshComponent
{
public:
	float                                         AudioComponentFadeOutDuration;                     // 0x1120(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1124[0x4];                                     // 0x1124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bMeshSwapped)> OnTemporaryMeshSwap;                           // 0x1128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1138[0x18];                                    // 0x1138(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     CachedDefaultSkinMaterial;                         // 0x1150(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             CachedDefaultSkinMaterialMulti;                    // 0x1158(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         OldForcedLodLevel;                                 // 0x1168(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkeletonFrozen;                                   // 0x116C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_116D[0x3];                                     // 0x116D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UMaterialInterface* NewOverlayMaterial, const struct FGameplayTag& PriorityTag, int32 PriorityModifier)> OnMaterialOverlayAddedDelegate; // 0x1170(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHWMaterialOverlayData& Data)> OnMaterialOverlayPreremovalDelegate; // 0x1180(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1190[0x10];                                    // 0x1190(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DefaultMaterials;                                  // 0x11A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultOverlayMaterial;                            // 0x11A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultOverlayMaterialAssetKeyName;                // 0x11B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   OverlayMaterialTagPriorities;                      // 0x11B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         OverlayMaterialPriorityIncrement;                  // 0x11C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11CC[0x4];                                     // 0x11CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWMaterialOverlayData>         OverlayMaterialStack;                              // 0x11D0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         OverlayStackIndex;                                 // 0x11E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E4[0x4];                                     // 0x11E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              OverlayGameplayParametersTable;                    // 0x11E8(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           OverlayScalarParameterNames;                       // 0x1210(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           OverlayVectorParameterNames;                       // 0x1220(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1230[0x10];                                    // 0x1230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              VXGLayer;                                          // 0x1240(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VXGRequestKey;                                     // 0x1248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyStencil;                                     // 0x1250(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1251[0xF];                                     // 0x1251(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FHWMaterialOverlayHandle AddOverlayMaterial(class UMaterialInterface* NewOverlayMaterial, const struct FGameplayTag& PriorityTag, int32 PriorityModifier);
	void ApplyNewMaterialWithOldMaterialsTextures(class UMaterialInterface* NewMaterialTemplate, bool bClearOverlayMaterials, bool SwapDiffuse, bool SwapNormal, bool SwapP1, class FName DiffuseMapParameterName, class FName NormalMapParameterName, class FName P1ParameterName);
	void FreezeSkeleton(bool bFreeze);
	void HandleOnDeath(const struct FDamageEventData& DeathEventData);
	void ReapplyVXGOnSkinApplied();
	void RemoveOverlayMaterial(struct FHWMaterialOverlayHandle& Handle);

	bool IsOverlayMaterialActive(const struct FHWMaterialOverlayHandle& Handle) const;
	bool IsUsingTemporaryMeshOverride() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkeletalMeshComponent">();
	}
	static class UHWSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSkeletalMeshComponent>();
	}
};
static_assert(alignof(UHWSkeletalMeshComponent) == 0x000010, "Wrong alignment on UHWSkeletalMeshComponent");
static_assert(sizeof(UHWSkeletalMeshComponent) == 0x001260, "Wrong size on UHWSkeletalMeshComponent");
static_assert(offsetof(UHWSkeletalMeshComponent, AudioComponentFadeOutDuration) == 0x001120, "Member 'UHWSkeletalMeshComponent::AudioComponentFadeOutDuration' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OnTemporaryMeshSwap) == 0x001128, "Member 'UHWSkeletalMeshComponent::OnTemporaryMeshSwap' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, CachedDefaultSkinMaterial) == 0x001150, "Member 'UHWSkeletalMeshComponent::CachedDefaultSkinMaterial' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, CachedDefaultSkinMaterialMulti) == 0x001158, "Member 'UHWSkeletalMeshComponent::CachedDefaultSkinMaterialMulti' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OldForcedLodLevel) == 0x001168, "Member 'UHWSkeletalMeshComponent::OldForcedLodLevel' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, bSkeletonFrozen) == 0x00116C, "Member 'UHWSkeletalMeshComponent::bSkeletonFrozen' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OnMaterialOverlayAddedDelegate) == 0x001170, "Member 'UHWSkeletalMeshComponent::OnMaterialOverlayAddedDelegate' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OnMaterialOverlayPreremovalDelegate) == 0x001180, "Member 'UHWSkeletalMeshComponent::OnMaterialOverlayPreremovalDelegate' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, DefaultMaterials) == 0x0011A0, "Member 'UHWSkeletalMeshComponent::DefaultMaterials' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, DefaultOverlayMaterial) == 0x0011A8, "Member 'UHWSkeletalMeshComponent::DefaultOverlayMaterial' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, DefaultOverlayMaterialAssetKeyName) == 0x0011B0, "Member 'UHWSkeletalMeshComponent::DefaultOverlayMaterialAssetKeyName' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OverlayMaterialTagPriorities) == 0x0011B8, "Member 'UHWSkeletalMeshComponent::OverlayMaterialTagPriorities' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OverlayMaterialPriorityIncrement) == 0x0011C8, "Member 'UHWSkeletalMeshComponent::OverlayMaterialPriorityIncrement' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OverlayMaterialStack) == 0x0011D0, "Member 'UHWSkeletalMeshComponent::OverlayMaterialStack' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OverlayStackIndex) == 0x0011E0, "Member 'UHWSkeletalMeshComponent::OverlayStackIndex' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OverlayGameplayParametersTable) == 0x0011E8, "Member 'UHWSkeletalMeshComponent::OverlayGameplayParametersTable' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OverlayScalarParameterNames) == 0x001210, "Member 'UHWSkeletalMeshComponent::OverlayScalarParameterNames' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, OverlayVectorParameterNames) == 0x001220, "Member 'UHWSkeletalMeshComponent::OverlayVectorParameterNames' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, VXGLayer) == 0x001240, "Member 'UHWSkeletalMeshComponent::VXGLayer' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, VXGRequestKey) == 0x001248, "Member 'UHWSkeletalMeshComponent::VXGRequestKey' has a wrong offset!");
static_assert(offsetof(UHWSkeletalMeshComponent, bApplyStencil) == 0x001250, "Member 'UHWSkeletalMeshComponent::bApplyStencil' has a wrong offset!");

// Class Hemingway.HWVgsComponent
// 0x0060 (0x0100 - 0x00A0)
class UHWVgsComponent final : public UHWActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWVoicePackItem*                       VoicePackItem;                                     // 0x00B0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SkinTagContainer;                                  // 0x00B8(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x28];                                      // 0x00D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnNewSkinTagAsset(TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset);
	void HandleOnSkinTagAssetRemoved(TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove);
	void OnRep_SkinTagContainerChanged();
	void OnRep_VoicePackItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVgsComponent">();
	}
	static class UHWVgsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVgsComponent>();
	}
};
static_assert(alignof(UHWVgsComponent) == 0x000008, "Wrong alignment on UHWVgsComponent");
static_assert(sizeof(UHWVgsComponent) == 0x000100, "Wrong size on UHWVgsComponent");
static_assert(offsetof(UHWVgsComponent, VoicePackItem) == 0x0000B0, "Member 'UHWVgsComponent::VoicePackItem' has a wrong offset!");
static_assert(offsetof(UHWVgsComponent, SkinTagContainer) == 0x0000B8, "Member 'UHWVgsComponent::SkinTagContainer' has a wrong offset!");

// Class Hemingway.HWVisibilityComponent_PlayableCharacter
// 0x0010 (0x02B0 - 0x02A0)
class UHWVisibilityComponent_PlayableCharacter : public UHWVisibilityComponent
{
public:
	float                                         FieldOfViewRange;                                  // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RevealedFromDistance;                              // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWCachedProximityVisibilityState             CachedVisibilityState;                             // 0x02A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CacheProximityVisibleState();
	void HandleAbilitySystemUpdated(class UHWAbilitySystemComponent* AbilitySystem);
	void HandleCharacterChanged(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class AHWCharacter_Base* NewCharacterOwner);
	void HandleCharacterTeamUpdated(class AHWCharacterAbilitySystemActor* OwningAbilitySystemActor, class AHWTeamState* InTeamState);
	void HandleTagUpdated_CharacterVisibilityHide(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void InvalidateCachedVisibilityState();
	void OnLocalControllerTeamUpdated(class AController* LocalController, const struct FGenericTeamId& TeamId);
	void OnOwnerTeamChanged(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class AHWTeamState* TeamState);
	void OnOwningPlayerStateChanged(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class AHWPlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVisibilityComponent_PlayableCharacter">();
	}
	static class UHWVisibilityComponent_PlayableCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVisibilityComponent_PlayableCharacter>();
	}
};
static_assert(alignof(UHWVisibilityComponent_PlayableCharacter) == 0x000008, "Wrong alignment on UHWVisibilityComponent_PlayableCharacter");
static_assert(sizeof(UHWVisibilityComponent_PlayableCharacter) == 0x0002B0, "Wrong size on UHWVisibilityComponent_PlayableCharacter");
static_assert(offsetof(UHWVisibilityComponent_PlayableCharacter, FieldOfViewRange) == 0x0002A0, "Member 'UHWVisibilityComponent_PlayableCharacter::FieldOfViewRange' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent_PlayableCharacter, RevealedFromDistance) == 0x0002A4, "Member 'UHWVisibilityComponent_PlayableCharacter::RevealedFromDistance' has a wrong offset!");
static_assert(offsetof(UHWVisibilityComponent_PlayableCharacter, CachedVisibilityState) == 0x0002A8, "Member 'UHWVisibilityComponent_PlayableCharacter::CachedVisibilityState' has a wrong offset!");

// Class Hemingway.HWDisplayInfoManager
// 0x00E8 (0x0110 - 0x0028)
class UHWDisplayInfoManager final : public UObject
{
public:
	TMulticastInlineDelegate<void(const struct FHWDisplayInfo& AddedDisplayInfo)> OnDisplayInfoAdded; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHWDisplayInfo& RemovedDisplayInfo)> OnDisplayInfoRemoved; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHWDisplayInfo& HiddenDisplayInfo)> OnDisplayInfoHidden; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHWDisplayInfo& ShownDisplayInfo)> OnDisplayInfoShown; // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0xA8];                                      // 0x0068(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddDisplayInfo(struct FHWDisplayInfo& DisplayInfo, bool bIsInstant);
	void HideDisplayInfo(int32 DisplayInfoId);
	void RemoveActorDisplayInfos(class AActor* InActor);
	void RemoveDisplayInfo(int32 DisplayInfoId);
	void SetDisplayInfoLifespan(int32 DisplayInfoId, float NewLifespan);
	void ShowDisplayInfo(int32 DisplayInfoId);

	bool GetDisplayInfo(int32 DisplayInfoId, struct FHWDisplayInfo* OutDisplayInfo, float* OutRemainingTime) const;
	void GetDisplayInfos(TArray<struct FHWDisplayInfo>* OutDisplayInfos) const;
	bool IsDisplayInfoIdValid(int32 DisplayInfoId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDisplayInfoManager">();
	}
	static class UHWDisplayInfoManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDisplayInfoManager>();
	}
};
static_assert(alignof(UHWDisplayInfoManager) == 0x000008, "Wrong alignment on UHWDisplayInfoManager");
static_assert(sizeof(UHWDisplayInfoManager) == 0x000110, "Wrong size on UHWDisplayInfoManager");
static_assert(offsetof(UHWDisplayInfoManager, OnDisplayInfoAdded) == 0x000028, "Member 'UHWDisplayInfoManager::OnDisplayInfoAdded' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoManager, OnDisplayInfoRemoved) == 0x000038, "Member 'UHWDisplayInfoManager::OnDisplayInfoRemoved' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoManager, OnDisplayInfoHidden) == 0x000048, "Member 'UHWDisplayInfoManager::OnDisplayInfoHidden' has a wrong offset!");
static_assert(offsetof(UHWDisplayInfoManager, OnDisplayInfoShown) == 0x000058, "Member 'UHWDisplayInfoManager::OnDisplayInfoShown' has a wrong offset!");

// Class Hemingway.HWEquipmentComponent_AbilitySwap
// 0x0090 (0x00C8 - 0x0038)
class UHWEquipmentComponent_AbilitySwap final : public UHWEquipmentComponent
{
public:
	class UHWEquipmentComponentSettings_AbilitySwap* AbilitySwapSettings;                            // 0x0038(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             SwapAbilityHandle;                                 // 0x0040(0x0004)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWAbilitySwapInfo                     AbilitySwapInfo;                                   // 0x0048(0x0040)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AccruedAdditionalCooldownCost;                     // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWInventorySlot                       CachedOwningAbilitySlot;                           // 0x008C(0x000C)(Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UHWEquipmentComponent_AbilitySwap* AbilitySwapComponent, const bool bIsSwapWindowActive, const float SwapWindowTime)> OnAbilitySwapStateChangedDelegate; // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHWAbilitySwapWindowInfo               AbilitySwapWindowInfo;                             // 0x00A8(0x0018)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AccrueAdditionalCooldownCost(const int32 AbilitySwapIndex);
	void EndAbilitySwapWindow();
	void OnRep_AbilitySwapWindowInfo();
	void Server_SwapAbilitySlots(const struct FHWAbilitySwapInfo& SwapInfo);
	void StartAbilitySwapWindow();
	bool SwapAbilitySlots(const struct FHWAbilitySwapInfo& SwapInfo);
	bool TriggerAbilitySwap(class UHWGameplayAbility* AbilityInstance, const int32 AbilitySwapIndex);

	EHWAbilitySwapBehavior GetAbilitySwapBehavior() const;
	float GetAbilitySwapWindowDuration() const;
	float GetElapsedAbilitySwapWindowTime() const;
	bool IsAbilitySwapWindowActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponent_AbilitySwap">();
	}
	static class UHWEquipmentComponent_AbilitySwap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponent_AbilitySwap>();
	}
};
static_assert(alignof(UHWEquipmentComponent_AbilitySwap) == 0x000008, "Wrong alignment on UHWEquipmentComponent_AbilitySwap");
static_assert(sizeof(UHWEquipmentComponent_AbilitySwap) == 0x0000C8, "Wrong size on UHWEquipmentComponent_AbilitySwap");
static_assert(offsetof(UHWEquipmentComponent_AbilitySwap, AbilitySwapSettings) == 0x000038, "Member 'UHWEquipmentComponent_AbilitySwap::AbilitySwapSettings' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_AbilitySwap, SwapAbilityHandle) == 0x000040, "Member 'UHWEquipmentComponent_AbilitySwap::SwapAbilityHandle' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_AbilitySwap, AbilitySwapInfo) == 0x000048, "Member 'UHWEquipmentComponent_AbilitySwap::AbilitySwapInfo' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_AbilitySwap, AccruedAdditionalCooldownCost) == 0x000088, "Member 'UHWEquipmentComponent_AbilitySwap::AccruedAdditionalCooldownCost' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_AbilitySwap, CachedOwningAbilitySlot) == 0x00008C, "Member 'UHWEquipmentComponent_AbilitySwap::CachedOwningAbilitySlot' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_AbilitySwap, OnAbilitySwapStateChangedDelegate) == 0x000098, "Member 'UHWEquipmentComponent_AbilitySwap::OnAbilitySwapStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_AbilitySwap, AbilitySwapWindowInfo) == 0x0000A8, "Member 'UHWEquipmentComponent_AbilitySwap::AbilitySwapWindowInfo' has a wrong offset!");

// Class Hemingway.HWEquipmentComponent_Ammo
// 0x0030 (0x0068 - 0x0038)
class UHWEquipmentComponent_Ammo final : public UHWEquipmentComponent
{
public:
	TMulticastInlineDelegate<void(class UHWEquipmentComponent_Ammo* AmmoComponent, const class UHWEquipmentComponentSettings_Ammo* AmmoSettings, const int32 PreviousAmmoCount, const int32 NewAmmoCount)> OnAmmoChangedDelegate; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         AmmoCount;                                         // 0x0048(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            ActiveRegenAmmoCooldownEffectHandle;               // 0x004C(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RemainingCooldownTimePrePause;                     // 0x0060(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAmmoRegenPaused;                                  // 0x0064(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConsumeAllAmmo(const bool bSkipCooldown);
	void ConsumeAmmo(const int32 Amount, const bool bSkipCooldown);
	bool DoesAmmoRegenerateOverTime();
	void GrantAmmo(const int32 Amount);
	void HandleEquipmentLevelChanged(class UHWEquipmentInstance* Equipment, const int32 PreviousLevel);
	void OnAmmoChanged(const int32 OldAmmoAmount);
	void OnRefillTagUpdated(const struct FGameplayTag& Tag, const int32 Count);
	void OnRep_AmmoRegenPaused();
	void OnRep_RemainingCooldownTimePrePause();
	void PauseRegenAmmoCooldown();
	void RefillAllAmmo();
	void SetAmmoCount(const int32 NewAmmoCount);

	bool CanSellWholeStack() const;
	int32 GetAmmoCount() const;
	int32 GetAmmoMax() const;
	float GetTimeRemainingWhenPaused() const;
	bool HasEnoughAmmo() const;
	bool HasMaxAmmo() const;
	bool IsRegenAmmoCooldownPaused() const;
	bool ShouldManuallyConsumeAmmo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponent_Ammo">();
	}
	static class UHWEquipmentComponent_Ammo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponent_Ammo>();
	}
};
static_assert(alignof(UHWEquipmentComponent_Ammo) == 0x000008, "Wrong alignment on UHWEquipmentComponent_Ammo");
static_assert(sizeof(UHWEquipmentComponent_Ammo) == 0x000068, "Wrong size on UHWEquipmentComponent_Ammo");
static_assert(offsetof(UHWEquipmentComponent_Ammo, OnAmmoChangedDelegate) == 0x000038, "Member 'UHWEquipmentComponent_Ammo::OnAmmoChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Ammo, AmmoCount) == 0x000048, "Member 'UHWEquipmentComponent_Ammo::AmmoCount' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Ammo, ActiveRegenAmmoCooldownEffectHandle) == 0x00004C, "Member 'UHWEquipmentComponent_Ammo::ActiveRegenAmmoCooldownEffectHandle' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Ammo, RemainingCooldownTimePrePause) == 0x000060, "Member 'UHWEquipmentComponent_Ammo::RemainingCooldownTimePrePause' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Ammo, bAmmoRegenPaused) == 0x000064, "Member 'UHWEquipmentComponent_Ammo::bAmmoRegenPaused' has a wrong offset!");

// Class Hemingway.HWEquipmentComponent_FiringInstanceTracker
// 0x0010 (0x0048 - 0x0038)
class UHWEquipmentComponent_FiringInstanceTracker final : public UHWEquipmentComponent
{
public:
	TArray<struct FHWFiringInstanceTracker>       TrackerList;                                       // 0x0038(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void PurgeOldTrackers();
	bool TrackFiringInstance(const struct FHWAbilityFiringInstanceId& InstanceId, const class UAbilitySystemComponent* TargetASC, const TSubclassOf<class UGameplayEffect> EffectClass, int32* OutCount);

	bool IsFiringInstanceTracked(const struct FHWAbilityFiringInstanceId& InstanceId, const class UAbilitySystemComponent* TargetASC, const TSubclassOf<class UGameplayEffect> EffectClass) const;
	bool IsTrackedCustom(const struct FHWFiringInstanceTracker& InstanceTracker) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponent_FiringInstanceTracker">();
	}
	static class UHWEquipmentComponent_FiringInstanceTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponent_FiringInstanceTracker>();
	}
};
static_assert(alignof(UHWEquipmentComponent_FiringInstanceTracker) == 0x000008, "Wrong alignment on UHWEquipmentComponent_FiringInstanceTracker");
static_assert(sizeof(UHWEquipmentComponent_FiringInstanceTracker) == 0x000048, "Wrong size on UHWEquipmentComponent_FiringInstanceTracker");
static_assert(offsetof(UHWEquipmentComponent_FiringInstanceTracker, TrackerList) == 0x000038, "Member 'UHWEquipmentComponent_FiringInstanceTracker::TrackerList' has a wrong offset!");

// Class Hemingway.HWEquipmentComponent_Stacks
// 0x0020 (0x0058 - 0x0038)
class UHWEquipmentComponent_Stacks final : public UHWEquipmentComponent
{
public:
	TMulticastInlineDelegate<void(class UHWEquipmentInstance* OwningEquipment, class UHWEquipmentComponent_Stacks* StackComponent)> OnStackCountChangedDel; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0048(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            StackEffectHandle;                                 // 0x004C(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddStacks(int32 Amount);
	void OnRep_StackCount();
	void RemoveAllStacks();
	void RemoveStacks(int32 Amount);
	void SetStacks(int32 Amount);

	int32 GetMaxStackCount() const;
	int32 GetStackCount() const;
	bool HasMaxStacks() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponent_Stacks">();
	}
	static class UHWEquipmentComponent_Stacks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponent_Stacks>();
	}
};
static_assert(alignof(UHWEquipmentComponent_Stacks) == 0x000008, "Wrong alignment on UHWEquipmentComponent_Stacks");
static_assert(sizeof(UHWEquipmentComponent_Stacks) == 0x000058, "Wrong size on UHWEquipmentComponent_Stacks");
static_assert(offsetof(UHWEquipmentComponent_Stacks, OnStackCountChangedDel) == 0x000038, "Member 'UHWEquipmentComponent_Stacks::OnStackCountChangedDel' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Stacks, StackCount) == 0x000048, "Member 'UHWEquipmentComponent_Stacks::StackCount' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Stacks, StackEffectHandle) == 0x00004C, "Member 'UHWEquipmentComponent_Stacks::StackEffectHandle' has a wrong offset!");

// Class Hemingway.HWEquipmentInfo
// 0x00B0 (0x00E0 - 0x0030)
class UHWEquipmentInfo final : public UPrimaryDataAsset
{
public:
	class FName                                   DevName;                                           // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHWEquipmentComponentSettings*>  EquipmentComponentSettings;                        // 0x0038(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            CharacterLevelRequirementMap;                      // 0x0048(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bRequiresSkillPointToLevel;                        // 0x0098(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartingLevel;                                     // 0x009C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAbilityForMaxLevel;                            // 0x00A0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxLevel;                                          // 0x00A4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGenerateLevelRequirementsBasedOnAbilityAssetTags; // 0x00A8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWGameplayAbility>         Ability;                                           // 0x00B0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHWEquipmentInfo_EffectInfo>    EffectsToGrant;                                    // 0x00B8(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DisplayInputTagOverride;                           // 0x00C8(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTagOverride;                                  // 0x00D0(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWEquipmentItem*                       ListenerEquipmentItem;                             // 0x00D8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TSubclassOf<class UHWGameplayAbility> GetAbilityClass() const;
	TArray<struct FHWEquipmentInfo_EffectInfo> GetEffectsToGrantInfo() const;
	int32 GetMaxLevel() const;
	bool UsesEquipmentComponent(TSubclassOf<class UHWEquipmentComponent> ComponentClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentInfo">();
	}
	static class UHWEquipmentInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentInfo>();
	}
};
static_assert(alignof(UHWEquipmentInfo) == 0x000008, "Wrong alignment on UHWEquipmentInfo");
static_assert(sizeof(UHWEquipmentInfo) == 0x0000E0, "Wrong size on UHWEquipmentInfo");
static_assert(offsetof(UHWEquipmentInfo, DevName) == 0x000030, "Member 'UHWEquipmentInfo::DevName' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, EquipmentComponentSettings) == 0x000038, "Member 'UHWEquipmentInfo::EquipmentComponentSettings' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, CharacterLevelRequirementMap) == 0x000048, "Member 'UHWEquipmentInfo::CharacterLevelRequirementMap' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, bRequiresSkillPointToLevel) == 0x000098, "Member 'UHWEquipmentInfo::bRequiresSkillPointToLevel' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, StartingLevel) == 0x00009C, "Member 'UHWEquipmentInfo::StartingLevel' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, bUseAbilityForMaxLevel) == 0x0000A0, "Member 'UHWEquipmentInfo::bUseAbilityForMaxLevel' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, MaxLevel) == 0x0000A4, "Member 'UHWEquipmentInfo::MaxLevel' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, bGenerateLevelRequirementsBasedOnAbilityAssetTags) == 0x0000A8, "Member 'UHWEquipmentInfo::bGenerateLevelRequirementsBasedOnAbilityAssetTags' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, Ability) == 0x0000B0, "Member 'UHWEquipmentInfo::Ability' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, EffectsToGrant) == 0x0000B8, "Member 'UHWEquipmentInfo::EffectsToGrant' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, DisplayInputTagOverride) == 0x0000C8, "Member 'UHWEquipmentInfo::DisplayInputTagOverride' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, InputTagOverride) == 0x0000D0, "Member 'UHWEquipmentInfo::InputTagOverride' has a wrong offset!");
static_assert(offsetof(UHWEquipmentInfo, ListenerEquipmentItem) == 0x0000D8, "Member 'UHWEquipmentInfo::ListenerEquipmentItem' has a wrong offset!");

// Class Hemingway.HWEquipmentItem_TooltipNamedValueConfig
// 0x0000 (0x0028 - 0x0028)
class UHWEquipmentItem_TooltipNamedValueConfig final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentItem_TooltipNamedValueConfig">();
	}
	static class UHWEquipmentItem_TooltipNamedValueConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentItem_TooltipNamedValueConfig>();
	}
};
static_assert(alignof(UHWEquipmentItem_TooltipNamedValueConfig) == 0x000008, "Wrong alignment on UHWEquipmentItem_TooltipNamedValueConfig");
static_assert(sizeof(UHWEquipmentItem_TooltipNamedValueConfig) == 0x000028, "Wrong size on UHWEquipmentItem_TooltipNamedValueConfig");

// Class Hemingway.HWEquipmentRecipe
// 0x0028 (0x0058 - 0x0030)
class UHWEquipmentRecipe final : public UPrimaryDataAsset
{
public:
	class UHWEquipmentItem*                       EquipmentToCraft;                                  // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldCost;                                          // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelRequirement;                                  // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHWEquipmentItem*>               EquipmentIngredients;                              // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EHWAutoBuyFailureSkipType                     AutoBuyFailureSkipType;                            // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentRecipe">();
	}
	static class UHWEquipmentRecipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentRecipe>();
	}
};
static_assert(alignof(UHWEquipmentRecipe) == 0x000008, "Wrong alignment on UHWEquipmentRecipe");
static_assert(sizeof(UHWEquipmentRecipe) == 0x000058, "Wrong size on UHWEquipmentRecipe");
static_assert(offsetof(UHWEquipmentRecipe, EquipmentToCraft) == 0x000030, "Member 'UHWEquipmentRecipe::EquipmentToCraft' has a wrong offset!");
static_assert(offsetof(UHWEquipmentRecipe, GoldCost) == 0x000038, "Member 'UHWEquipmentRecipe::GoldCost' has a wrong offset!");
static_assert(offsetof(UHWEquipmentRecipe, LevelRequirement) == 0x00003C, "Member 'UHWEquipmentRecipe::LevelRequirement' has a wrong offset!");
static_assert(offsetof(UHWEquipmentRecipe, EquipmentIngredients) == 0x000040, "Member 'UHWEquipmentRecipe::EquipmentIngredients' has a wrong offset!");
static_assert(offsetof(UHWEquipmentRecipe, AutoBuyFailureSkipType) == 0x000050, "Member 'UHWEquipmentRecipe::AutoBuyFailureSkipType' has a wrong offset!");

// Class Hemingway.HWInventoryManagerComponent
// 0x0338 (0x03D8 - 0x00A0)
class UHWInventoryManagerComponent final : public UHWActorComponent
{
public:
	struct FHWInventoryList                       Inventory;                                         // 0x00A0(0x0170)(Net, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, int32>              InventorySlotConfig;                               // 0x0210(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<struct FHWInventorySlot, struct FGameplayTag> EquipPointInputTagMap;                        // 0x0260(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWInventoryManagerComponent* InventoryManager, class UHWEquipmentInstance* EquipmentInstance, const struct FHWInventorySlot& Slot, const EHWInventoryChangeReason InventoryChangeReason)> OnInventoryEquipmentChangedDel; // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWEquipmentInstance* EquipmentInstance, const struct FHWInventorySlot& Slot)> OnInventoryEquipmentPurchasedDel; // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWEquipmentInstance* EquipmentInstanceSlot1AfterSwap, const struct FHWInventorySlot& Slot1, class UHWEquipmentInstance* EquipmentInstanceSlot2AfterSwap, const struct FHWInventorySlot& Slot2)> OnInventoryEquipmentSwappedDel; // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWDelayedEquipmentSwap>        DelayedEquipmentSwaps;                             // 0x02F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UHWEquipmentInstance* EquipmentChanged, const int32 PreviousLevel)> OnAnyEquipmentLevelChanged; // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHWEquipmentLevelingRecord>     EquipmentLevelingRecords;                          // 0x0318(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UHWEquipmentComponent*>          EquipmentComponents;                               // 0x0328(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x4];                                      // 0x0338(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EHWInventorySortBehavior                      SortingBehavior;                                   // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSortInProgress;                                 // 0x0340(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAutoSortEnabled;                                // 0x0341(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_342[0x6];                                      // 0x0342(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWInventoryManagerComponent* InventoryManager, const class AHWShopVendorVolume* NewShop)> OnShopVendorChangedDelegate; // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AHWShopVendorVolume*                    CurrentShop;                                       // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ShoppingPreventionTags;                            // 0x0360(0x0020)(Protected, NativeAccessSpecifierProtected)
	bool                                          bIsCurrentlyDead;                                  // 0x0380(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCurrentlyTransacting;                           // 0x0381(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_382[0x6];                                      // 0x0382(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWEquipmentInstance*>           EquipmentCraftedInCurrentTransaction;              // 0x0388(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHWInventoryTransaction>        TransactionHistory;                                // 0x0398(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bHasTransactionsAvailable;                         // 0x03A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bHasTransactionsAvailable)> OnInventoryTransactionsAvailableDel; // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MaxActiveItemsAllowed;                             // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWActiveItemInput>             ActiveItemInputs;                                  // 0x03C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static bool CanEquipmentUseSlotType(const class UObject* WorldContextObject, const struct FGameplayTag& EquipmentType, const struct FGameplayTag& SlotType);

	void AddInventoryTransaction(const struct FHWInventoryTransaction& InTransaction);
	void BeginTransactionRecord();
	class UHWEquipmentInstance* CraftEquipment(const class UHWEquipmentRecipe* RecipeToCraft, const struct FHWInventorySlot& DesiredInventorySlot, TArray<EHWCraftingFailureReason>* OutFailureReasons, struct FHWInventoryTransaction* OutTransaction, const bool bCraftMissingIngredients);
	class UHWEquipmentInstance* CreateAndEquipEquipment(const struct FHWEquipmentSpec& EquipmentSpec, const EHWInventoryChangeReason InventoryChangeReason);
	class UHWEquipmentInstance* CreateAndStoreEquipment(const struct FHWEquipmentSpec& EquipmentSpec, const EHWInventoryChangeReason InventoryChangeReason);
	void DestroyEquipment(class UHWEquipmentInstance* EquipmentToDestroy, const EHWInventoryChangeReason InventoryChangeReason);
	bool DestroyEquipmentInSlot(const struct FHWInventorySlot& Slot, const EHWInventoryChangeReason InventoryChangeReason);
	void EndTransactionRecord();
	bool EquipEquipment(class UHWEquipmentInstance* EquipmentInstance, const struct FHWInventorySlot& DesiredInventorySlot, const EHWInventoryChangeReason InventoryChangeReason);
	void OnDelayedSwapAbilityPhaseChanged(class UHWAbilitySystemComponent* AbilitySystem, const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& AbilityTags, const EAbilityFlowPhase PrevPhase, const EAbilityFlowPhase NextPhase);
	void OnEquipmentLevelChanged(class UHWEquipmentInstance* EquipmentChanged, const int32 PreviousLevel);
	void OnRep_CurrentShop();
	void OnRep_HasTransactionsAvailable();
	void OnTransactionAbilityCooldown(class UHWEquipmentInstance* EquipmentInstance, const class UHWGameplayAbility_Enhanced* AbilityOnCooldown);
	void OnTransactionAbilityFired(class UHWEquipmentInstance* EquipmentInstance, const class UHWGameplayAbility_Enhanced* FiredAbility);
	float RefundAllSkillPoints();
	void ResetEquipmentTargeters();
	class UHWEquipmentInstance* RetrieveAndRemoveEquipment(const struct FHWInventorySlot& Slot, const EHWInventoryChangeReason InventoryChangeReason);
	void Server_PurchaseEquipment(const class UHWEquipmentRecipe* EquipmentRecipe, const struct FHWInventorySlot& DesiredInventorySlot, const bool bPurchaseMissingIngredients);
	void Server_SellEquipment(class UHWEquipmentInstance* EquipmentToSell);
	void Server_SwapAbilitySlots(const struct FHWAbilitySwapInfo& SwapInfo);
	void Server_SwapActiveItemInput(class UHWEquipmentInstance* EquipmentInstance, const struct FGameplayTag& DesiredActiveItemInput);
	void Server_SwapEquipmentInSlots(const struct FHWInventorySlot& Slot1, const struct FHWInventorySlot& Slot2);
	void Server_UndoLastInventoryTransaction();
	void ServerSetAutoSort(const bool bEnabled);
	void ServerSetEquipmentLevel(class UHWEquipmentInstance* Equipment, const int32 DesiredLevel);
	void SetDeadStatus(bool bIsDead);
	void SetOverlappedShop(const class AHWShopVendorVolume* ShopVendor);
	bool StoreEquipment(class UHWEquipmentInstance* EquipmentInstance, const struct FHWInventorySlot& DesiredInventorySlot, const EHWInventoryChangeReason InventoryChangeReason);
	bool SwapAbilitySlots(const struct FHWAbilitySwapInfo& SwapInfo);
	void SwapActiveItemInput(class UHWEquipmentInstance* EquipmentInstance, const struct FGameplayTag& DesiredActiveItemInput);
	void SwapEquipmentAssignedInputTags(const struct FHWInventorySlot& Slot1, const struct FHWInventorySlot& Slot2);
	bool SwapEquipmentInSlots(const struct FHWInventorySlot& Slot1, const struct FHWInventorySlot& Slot2, const int32 DelayEquipmentSwapForPhases);
	void UndoAllInventoryTransactions();
	void UndoLastInventoryTransaction();
	class UHWEquipmentInstance* UnEquipEquipment(const struct FHWInventorySlot& Slot, const EHWInventoryChangeReason InventoryChangeReason);

	float CalculateSaleGoldValue(const class UHWEquipmentItem* EquipmentItem, const class AHWGameMode* currentGameMode, bool bItemCraftedInCurrentTransaction) const;
	struct FHWCanCraftInfo CanCraftEquipment(const class UHWEquipmentRecipe* RecipeToCraft, const struct FHWInventorySlot& DesiredInventorySlot) const;
	bool CanEquipEquipment(const class UHWEquipmentItem* EquipmentItemBeingEquipped) const;
	bool CanStoreEquipment(const class UHWEquipmentItem* EquipmentItemBeingStored) const;
	struct FHWInventorySlot FindAvailableSlotBaseOnEquipmentType(const struct FGameplayTag& EquipmentType, bool bWantsEquipPoint) const;
	EAbilityCastStyle GetAbilityCastStyle(const struct FGameplayTag& InputTag) const;
	const class AHWShopVendorVolume* GetCurrentShop() const;
	int32 GetEquipmentCount(const class UHWEquipmentItem* EquipmentItem) const;
	int32 GetEquipmentCountBasedOnEquipPoint(const struct FGameplayTag& EquipPoint) const;
	int32 GetEquipmentCountBasedOnType(const struct FGameplayTag& EquipmentType) const;
	int32 GetEquipmentSellPrice(class UHWEquipmentInstance* EquipmentToSell) const;
	struct FGameplayTag GetInputTagForInventorySlot(const struct FHWInventorySlot& InventorySlot) const;
	float GetItemResalePercentage(const class UHWEquipmentItem* EquipmentItem, const class AHWGameMode* currentGameMode, bool bItemCraftedInCurrentTransaction) const;
	const TArray<struct FHWEquipmentLevelingRecord> GetLevelingRecords() const;
	const struct FGameplayTagContainer GetShoppingPreventionTags() const;
	bool HasTransactionsAvailable() const;
	bool IsAutoSortingEnabled() const;
	bool IsCraftingInProgress() const;
	bool IsInShop() const;
	bool IsInventorySwapInProgress() const;
	bool IsShoppingAllowed() const;
	void LogCurrentInventory() const;
	class UHWEquipmentInstance* RetrieveEquipment(const struct FHWInventorySlot& Slot) const;
	class UHWEquipmentInstance* RetrieveEquipmentByEquipmentItem(const class UHWEquipmentItem* EquipmentItem, const TArray<class UHWEquipmentInstance*>& EquipmentToIgnore) const;
	TArray<class UHWEquipmentInstance*> RetrieveEquipmentsByEffectHandle(const struct FActiveGameplayEffectHandle& EffectHandle) const;
	TArray<class UHWEquipmentInstance*> RetrieveEquipmentsBySlotType(const struct FGameplayTag& EquipmentType) const;
	bool ShouldBeInTransaction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInventoryManagerComponent">();
	}
	static class UHWInventoryManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInventoryManagerComponent>();
	}
};
static_assert(alignof(UHWInventoryManagerComponent) == 0x000008, "Wrong alignment on UHWInventoryManagerComponent");
static_assert(sizeof(UHWInventoryManagerComponent) == 0x0003D8, "Wrong size on UHWInventoryManagerComponent");
static_assert(offsetof(UHWInventoryManagerComponent, Inventory) == 0x0000A0, "Member 'UHWInventoryManagerComponent::Inventory' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, InventorySlotConfig) == 0x000210, "Member 'UHWInventoryManagerComponent::InventorySlotConfig' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, EquipPointInputTagMap) == 0x000260, "Member 'UHWInventoryManagerComponent::EquipPointInputTagMap' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, OnInventoryEquipmentChangedDel) == 0x0002C0, "Member 'UHWInventoryManagerComponent::OnInventoryEquipmentChangedDel' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, OnInventoryEquipmentPurchasedDel) == 0x0002D0, "Member 'UHWInventoryManagerComponent::OnInventoryEquipmentPurchasedDel' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, OnInventoryEquipmentSwappedDel) == 0x0002E0, "Member 'UHWInventoryManagerComponent::OnInventoryEquipmentSwappedDel' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, DelayedEquipmentSwaps) == 0x0002F8, "Member 'UHWInventoryManagerComponent::DelayedEquipmentSwaps' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, OnAnyEquipmentLevelChanged) == 0x000308, "Member 'UHWInventoryManagerComponent::OnAnyEquipmentLevelChanged' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, EquipmentLevelingRecords) == 0x000318, "Member 'UHWInventoryManagerComponent::EquipmentLevelingRecords' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, EquipmentComponents) == 0x000328, "Member 'UHWInventoryManagerComponent::EquipmentComponents' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, SortingBehavior) == 0x00033C, "Member 'UHWInventoryManagerComponent::SortingBehavior' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, bIsSortInProgress) == 0x000340, "Member 'UHWInventoryManagerComponent::bIsSortInProgress' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, bIsAutoSortEnabled) == 0x000341, "Member 'UHWInventoryManagerComponent::bIsAutoSortEnabled' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, OnShopVendorChangedDelegate) == 0x000348, "Member 'UHWInventoryManagerComponent::OnShopVendorChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, CurrentShop) == 0x000358, "Member 'UHWInventoryManagerComponent::CurrentShop' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, ShoppingPreventionTags) == 0x000360, "Member 'UHWInventoryManagerComponent::ShoppingPreventionTags' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, bIsCurrentlyDead) == 0x000380, "Member 'UHWInventoryManagerComponent::bIsCurrentlyDead' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, bIsCurrentlyTransacting) == 0x000381, "Member 'UHWInventoryManagerComponent::bIsCurrentlyTransacting' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, EquipmentCraftedInCurrentTransaction) == 0x000388, "Member 'UHWInventoryManagerComponent::EquipmentCraftedInCurrentTransaction' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, TransactionHistory) == 0x000398, "Member 'UHWInventoryManagerComponent::TransactionHistory' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, bHasTransactionsAvailable) == 0x0003A8, "Member 'UHWInventoryManagerComponent::bHasTransactionsAvailable' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, OnInventoryTransactionsAvailableDel) == 0x0003B0, "Member 'UHWInventoryManagerComponent::OnInventoryTransactionsAvailableDel' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, MaxActiveItemsAllowed) == 0x0003C0, "Member 'UHWInventoryManagerComponent::MaxActiveItemsAllowed' has a wrong offset!");
static_assert(offsetof(UHWInventoryManagerComponent, ActiveItemInputs) == 0x0003C8, "Member 'UHWInventoryManagerComponent::ActiveItemInputs' has a wrong offset!");

// Class Hemingway.HWActor_SpecialFX
// 0x0020 (0x02C8 - 0x02A8)
class AHWActor_SpecialFX : public AHWSimpleTeamActor
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHideWhenOwnerIsHidden;                            // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWOnSpawnFXActorParams>        ActivateOnSpawnFX;                                 // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void SetHideWhenOwnerIsHidden(bool bShouldHide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWActor_SpecialFX">();
	}
	static class AHWActor_SpecialFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWActor_SpecialFX>();
	}
};
static_assert(alignof(AHWActor_SpecialFX) == 0x000008, "Wrong alignment on AHWActor_SpecialFX");
static_assert(sizeof(AHWActor_SpecialFX) == 0x0002C8, "Wrong size on AHWActor_SpecialFX");
static_assert(offsetof(AHWActor_SpecialFX, bHideWhenOwnerIsHidden) == 0x0002B0, "Member 'AHWActor_SpecialFX::bHideWhenOwnerIsHidden' has a wrong offset!");
static_assert(offsetof(AHWActor_SpecialFX, ActivateOnSpawnFX) == 0x0002B8, "Member 'AHWActor_SpecialFX::ActivateOnSpawnFX' has a wrong offset!");

// Class Hemingway.HWSpecialFXManager
// 0x0000 (0x0028 - 0x0028)
class UHWSpecialFXManager final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSpecialFXManager">();
	}
	static class UHWSpecialFXManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSpecialFXManager>();
	}
};
static_assert(alignof(UHWSpecialFXManager) == 0x000008, "Wrong alignment on UHWSpecialFXManager");
static_assert(sizeof(UHWSpecialFXManager) == 0x000028, "Wrong size on UHWSpecialFXManager");

// Class Hemingway.HWDeployableMovementComponent
// 0x0000 (0x0300 - 0x0300)
class UHWDeployableMovementComponent : public UHWGameplayMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployableMovementComponent">();
	}
	static class UHWDeployableMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDeployableMovementComponent>();
	}
};
static_assert(alignof(UHWDeployableMovementComponent) == 0x000010, "Wrong alignment on UHWDeployableMovementComponent");
static_assert(sizeof(UHWDeployableMovementComponent) == 0x000300, "Wrong size on UHWDeployableMovementComponent");

// Class Hemingway.HWDeployableMovementComponent_LobWithRoll
// 0x0010 (0x0310 - 0x0300)
class UHWDeployableMovementComponent_LobWithRoll final : public UHWDeployableMovementComponent
{
public:
	bool                                          bLandingSpeedClampApplied;                         // 0x0300(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RollLifeSpan;                                      // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployableMovementComponent_LobWithRoll">();
	}
	static class UHWDeployableMovementComponent_LobWithRoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDeployableMovementComponent_LobWithRoll>();
	}
};
static_assert(alignof(UHWDeployableMovementComponent_LobWithRoll) == 0x000010, "Wrong alignment on UHWDeployableMovementComponent_LobWithRoll");
static_assert(sizeof(UHWDeployableMovementComponent_LobWithRoll) == 0x000310, "Wrong size on UHWDeployableMovementComponent_LobWithRoll");
static_assert(offsetof(UHWDeployableMovementComponent_LobWithRoll, bLandingSpeedClampApplied) == 0x000300, "Member 'UHWDeployableMovementComponent_LobWithRoll::bLandingSpeedClampApplied' has a wrong offset!");
static_assert(offsetof(UHWDeployableMovementComponent_LobWithRoll, RollLifeSpan) == 0x000304, "Member 'UHWDeployableMovementComponent_LobWithRoll::RollLifeSpan' has a wrong offset!");

// Class Hemingway.HWDeployable_Growing
// 0x0020 (0x04E8 - 0x04C8)
class AHWDeployable_Growing final : public AHWDeployable
{
public:
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentScale;                                      // 0x04D0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinXSize;                                          // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxXSize;                                          // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PropertyToScale;                                   // 0x04DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BlockRefireOnServer;                               // 0x04E4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E5[0x3];                                      // 0x04E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetCurrentScaleTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Growing">();
	}
	static class AHWDeployable_Growing* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Growing>();
	}
};
static_assert(alignof(AHWDeployable_Growing) == 0x000008, "Wrong alignment on AHWDeployable_Growing");
static_assert(sizeof(AHWDeployable_Growing) == 0x0004E8, "Wrong size on AHWDeployable_Growing");
static_assert(offsetof(AHWDeployable_Growing, CurrentScale) == 0x0004D0, "Member 'AHWDeployable_Growing::CurrentScale' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Growing, MinXSize) == 0x0004D4, "Member 'AHWDeployable_Growing::MinXSize' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Growing, MaxXSize) == 0x0004D8, "Member 'AHWDeployable_Growing::MaxXSize' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Growing, PropertyToScale) == 0x0004DC, "Member 'AHWDeployable_Growing::PropertyToScale' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Growing, BlockRefireOnServer) == 0x0004E4, "Member 'AHWDeployable_Growing::BlockRefireOnServer' has a wrong offset!");

// Class Hemingway.HWWallPushCollisionComponent
// 0x0000 (0x05B0 - 0x05B0)
class UHWWallPushCollisionComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWWallPushCollisionComponent">();
	}
	static class UHWWallPushCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWWallPushCollisionComponent>();
	}
};
static_assert(alignof(UHWWallPushCollisionComponent) == 0x000010, "Wrong alignment on UHWWallPushCollisionComponent");
static_assert(sizeof(UHWWallPushCollisionComponent) == 0x0005B0, "Wrong size on UHWWallPushCollisionComponent");

// Class Hemingway.HWDeployable_WithVision
// 0x0038 (0x0500 - 0x04C8)
class AHWDeployable_WithVision : public AHWDeployable
{
public:
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWVisibilityComponent*                 VisibilityComponent;                               // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleCollision;                                  // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLineOfSightCheckRequired;                         // 0x04E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWVisibilityComponent* VisibilityComponent)> VisibilityComponentUpdated; // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USphereComponent*                       VisionRangeCollision;                              // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnVisionRangeBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void OnVisionRangeEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_WithVision">();
	}
	static class AHWDeployable_WithVision* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_WithVision>();
	}
};
static_assert(alignof(AHWDeployable_WithVision) == 0x000008, "Wrong alignment on AHWDeployable_WithVision");
static_assert(sizeof(AHWDeployable_WithVision) == 0x000500, "Wrong size on AHWDeployable_WithVision");
static_assert(offsetof(AHWDeployable_WithVision, VisibilityComponent) == 0x0004D0, "Member 'AHWDeployable_WithVision::VisibilityComponent' has a wrong offset!");
static_assert(offsetof(AHWDeployable_WithVision, CapsuleCollision) == 0x0004D8, "Member 'AHWDeployable_WithVision::CapsuleCollision' has a wrong offset!");
static_assert(offsetof(AHWDeployable_WithVision, bLineOfSightCheckRequired) == 0x0004E0, "Member 'AHWDeployable_WithVision::bLineOfSightCheckRequired' has a wrong offset!");
static_assert(offsetof(AHWDeployable_WithVision, VisibilityComponentUpdated) == 0x0004E8, "Member 'AHWDeployable_WithVision::VisibilityComponentUpdated' has a wrong offset!");
static_assert(offsetof(AHWDeployable_WithVision, VisionRangeCollision) == 0x0004F8, "Member 'AHWDeployable_WithVision::VisionRangeCollision' has a wrong offset!");

// Class Hemingway.HWDeployable_Ward
// 0x00B0 (0x05B0 - 0x0500)
class AHWDeployable_Ward : public AHWDeployable_WithVision
{
public:
	float                                         CachedStartTime;                                   // 0x0500(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_504[0x4];                                      // 0x0504(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWDisplayInfoComponent*                DisplayInfoComponent;                              // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWDisplayInfoComponent>    DisplayInfoComponentClass;                         // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            WardPreviewEffect;                                 // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviewWhenFirstPlacedDuration;                    // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_524[0x1C];                                     // 0x0524(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  GrassCollisionActorReference;                      // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWSkeletalMeshComponent*               WardMeshComponent;                                 // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWCollectionItem*                      CurrentWardSkin;                                   // 0x0550(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          DefaultWardMesh;                                   // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WardMeshSkinningKey;                               // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             DefaultWardMaterialsFriendly;                      // 0x0568(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   WardFriendlyMaterialSkinningKey;                   // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             DefaultWardMaterialsEnemy;                         // 0x0580(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   WardEnemyMaterialSkinningKey;                      // 0x0590(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMetaSoundSource*                       DefaultWardSoundDeploy;                            // 0x0598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMetaSoundSource*                       DefaultWardSoundDeath;                             // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWardSkinningEnabled;                              // 0x05A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A9[0x7];                                      // 0x05A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class UHWCollectionItem* GetWardSkin();
	TSoftObjectPtr<class USoundBase> GetWardSkinnedSound(class FName WardSoundSkinningKey);
	void OnWardAcquiredNewEnemyVisibility(class UHWVisibilityComponent* NewlyVisibleEnemyVisComp);
	void SetGrassCollisionActor(class AActor* GrassCollisionActor);
	void UpdateWardSkinVisuals(const class UHWCollectionItem* WardSkin);

	class AActor* GetGrassCollisionActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Ward">();
	}
	static class AHWDeployable_Ward* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Ward>();
	}
};
static_assert(alignof(AHWDeployable_Ward) == 0x000008, "Wrong alignment on AHWDeployable_Ward");
static_assert(sizeof(AHWDeployable_Ward) == 0x0005B0, "Wrong size on AHWDeployable_Ward");
static_assert(offsetof(AHWDeployable_Ward, CachedStartTime) == 0x000500, "Member 'AHWDeployable_Ward::CachedStartTime' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, DisplayInfoComponent) == 0x000508, "Member 'AHWDeployable_Ward::DisplayInfoComponent' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, DisplayInfoComponentClass) == 0x000510, "Member 'AHWDeployable_Ward::DisplayInfoComponentClass' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, WardPreviewEffect) == 0x000518, "Member 'AHWDeployable_Ward::WardPreviewEffect' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, PreviewWhenFirstPlacedDuration) == 0x000520, "Member 'AHWDeployable_Ward::PreviewWhenFirstPlacedDuration' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, GrassCollisionActorReference) == 0x000540, "Member 'AHWDeployable_Ward::GrassCollisionActorReference' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, WardMeshComponent) == 0x000548, "Member 'AHWDeployable_Ward::WardMeshComponent' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, CurrentWardSkin) == 0x000550, "Member 'AHWDeployable_Ward::CurrentWardSkin' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, DefaultWardMesh) == 0x000558, "Member 'AHWDeployable_Ward::DefaultWardMesh' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, WardMeshSkinningKey) == 0x000560, "Member 'AHWDeployable_Ward::WardMeshSkinningKey' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, DefaultWardMaterialsFriendly) == 0x000568, "Member 'AHWDeployable_Ward::DefaultWardMaterialsFriendly' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, WardFriendlyMaterialSkinningKey) == 0x000578, "Member 'AHWDeployable_Ward::WardFriendlyMaterialSkinningKey' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, DefaultWardMaterialsEnemy) == 0x000580, "Member 'AHWDeployable_Ward::DefaultWardMaterialsEnemy' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, WardEnemyMaterialSkinningKey) == 0x000590, "Member 'AHWDeployable_Ward::WardEnemyMaterialSkinningKey' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, DefaultWardSoundDeploy) == 0x000598, "Member 'AHWDeployable_Ward::DefaultWardSoundDeploy' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, DefaultWardSoundDeath) == 0x0005A0, "Member 'AHWDeployable_Ward::DefaultWardSoundDeath' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Ward, bWardSkinningEnabled) == 0x0005A8, "Member 'AHWDeployable_Ward::bWardSkinningEnabled' has a wrong offset!");

// Class Hemingway.HWFamiliarComponent
// 0x0020 (0x00C0 - 0x00A0)
class UHWFamiliarComponent final : public UHWActorComponent
{
public:
	struct FHWActiveFamiliarHandle                FamiliarHandle;                                    // 0x00A0(0x000C)(Net, NoDestructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x14];                                      // 0x00AC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FHWActiveFamiliarHandle GetFamiliarHandle() const;
	class AHWCharacterAbilitySystemActor* GetFamiliarOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWFamiliarComponent">();
	}
	static class UHWFamiliarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWFamiliarComponent>();
	}
};
static_assert(alignof(UHWFamiliarComponent) == 0x000008, "Wrong alignment on UHWFamiliarComponent");
static_assert(sizeof(UHWFamiliarComponent) == 0x0000C0, "Wrong size on UHWFamiliarComponent");
static_assert(offsetof(UHWFamiliarComponent, FamiliarHandle) == 0x0000A0, "Member 'UHWFamiliarComponent::FamiliarHandle' has a wrong offset!");

// Class Hemingway.HWFamiliarManagerComponent
// 0x0230 (0x02D0 - 0x00A0)
class UHWFamiliarManagerComponent final : public UHWActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FHWActiveFamiliarHandle& FamiliarHandle, const struct FHWActiveFamiliarInfo& FamiliarInfo)> OnFamiliarSpawnedDelegate; // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHWActiveFamiliarHandle& FamiliarHandle, const struct FHWActiveFamiliarInfo& FamiliarInfo, const struct FDamageEventData& DamageReceivedEvent)> OnFamiliarDiedDelegate; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWFamiliarManagerComponent* FamiliarManagerComponent)> ActiveFamiliarsUpdated; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHWActiveFamiliarInfo>          ActiveFamiliars;                                   // 0x00D8(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWActiveFamiliarInfo>          PersistentFamiliars;                               // 0x00E8(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AHWAISquadManager>          SquadManagerClass;                                 // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWAISquadManager>       SquadManager;                                      // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRecyclingEnabled;                               // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldKeepAbilitySystemActorRelevantToClient;     // 0x0109(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldRecycleCharacterPawns;                      // 0x010A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B[0x5];                                      // 0x010B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWRecycledPool                        RecyclePool;                                       // 0x0110(0x0168)(Edit, Net, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AHWAIController>, int32> MaxControllerRecyclePoolSizeConfig;              // 0x0278(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxAbilitySystemActorPoolSize;                     // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyFamiliar(const struct FHWActiveFamiliarHandle& FamiliarHandle, const bool bSkipTimeAfterDeath);
	void OnFamiliarLifetimeExpired(const struct FHWActiveFamiliarHandle& FamiliarHandle);
	void OnFamiliarPawnFinishedDestroy(class AHWCharacter_Base* DestroyedFamiliarPawn);
	void OnOwnerDied(const struct FDamageEventData& DeathEventData);
	void OnRep_ActiveFamiliars();
	struct FHWActiveFamiliarHandle SpawnFamiliar(const class UHWFamiliarConfigSettings* FamiliarConfig, const struct FTransform& SpawnTransform, struct FHWFamiliarSpawnParams* FamiliarSpawnParams, const struct FGameplayAbilitySpecHandle& AbilityHandle);

	bool BP_GetFamiliarInfo(const struct FHWActiveFamiliarHandle& Handle, struct FHWActiveFamiliarInfo* FamiliarInfo) const;
	const TArray<struct FHWActiveFamiliarInfo> GetActiveFamiliars() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWFamiliarManagerComponent">();
	}
	static class UHWFamiliarManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWFamiliarManagerComponent>();
	}
};
static_assert(alignof(UHWFamiliarManagerComponent) == 0x000008, "Wrong alignment on UHWFamiliarManagerComponent");
static_assert(sizeof(UHWFamiliarManagerComponent) == 0x0002D0, "Wrong size on UHWFamiliarManagerComponent");
static_assert(offsetof(UHWFamiliarManagerComponent, OnFamiliarSpawnedDelegate) == 0x0000A8, "Member 'UHWFamiliarManagerComponent::OnFamiliarSpawnedDelegate' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, OnFamiliarDiedDelegate) == 0x0000B8, "Member 'UHWFamiliarManagerComponent::OnFamiliarDiedDelegate' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, ActiveFamiliarsUpdated) == 0x0000C8, "Member 'UHWFamiliarManagerComponent::ActiveFamiliarsUpdated' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, ActiveFamiliars) == 0x0000D8, "Member 'UHWFamiliarManagerComponent::ActiveFamiliars' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, PersistentFamiliars) == 0x0000E8, "Member 'UHWFamiliarManagerComponent::PersistentFamiliars' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, SquadManagerClass) == 0x0000F8, "Member 'UHWFamiliarManagerComponent::SquadManagerClass' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, SquadManager) == 0x000100, "Member 'UHWFamiliarManagerComponent::SquadManager' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, bIsRecyclingEnabled) == 0x000108, "Member 'UHWFamiliarManagerComponent::bIsRecyclingEnabled' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, bShouldKeepAbilitySystemActorRelevantToClient) == 0x000109, "Member 'UHWFamiliarManagerComponent::bShouldKeepAbilitySystemActorRelevantToClient' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, bShouldRecycleCharacterPawns) == 0x00010A, "Member 'UHWFamiliarManagerComponent::bShouldRecycleCharacterPawns' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, RecyclePool) == 0x000110, "Member 'UHWFamiliarManagerComponent::RecyclePool' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, MaxControllerRecyclePoolSizeConfig) == 0x000278, "Member 'UHWFamiliarManagerComponent::MaxControllerRecyclePoolSizeConfig' has a wrong offset!");
static_assert(offsetof(UHWFamiliarManagerComponent, MaxAbilitySystemActorPoolSize) == 0x0002C8, "Member 'UHWFamiliarManagerComponent::MaxAbilitySystemActorPoolSize' has a wrong offset!");

// Class Hemingway.HWGameplayCueNotify_Burst
// 0x0008 (0x03B0 - 0x03A8)
class UHWGameplayCueNotify_Burst : public UGameplayCueNotify_Burst
{
public:
	bool                                          bShouldVisibilityComponentControlCue;              // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_Burst">();
	}
	static class UHWGameplayCueNotify_Burst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayCueNotify_Burst>();
	}
};
static_assert(alignof(UHWGameplayCueNotify_Burst) == 0x000008, "Wrong alignment on UHWGameplayCueNotify_Burst");
static_assert(sizeof(UHWGameplayCueNotify_Burst) == 0x0003B0, "Wrong size on UHWGameplayCueNotify_Burst");
static_assert(offsetof(UHWGameplayCueNotify_Burst, bShouldVisibilityComponentControlCue) == 0x0003A8, "Member 'UHWGameplayCueNotify_Burst::bShouldVisibilityComponentControlCue' has a wrong offset!");

// Class Hemingway.HWGameplayCueNotify_HitImpact
// 0x0000 (0x0050 - 0x0050)
class UHWGameplayCueNotify_HitImpact final : public UGameplayCueNotify_HitImpact
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_HitImpact">();
	}
	static class UHWGameplayCueNotify_HitImpact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayCueNotify_HitImpact>();
	}
};
static_assert(alignof(UHWGameplayCueNotify_HitImpact) == 0x000008, "Wrong alignment on UHWGameplayCueNotify_HitImpact");
static_assert(sizeof(UHWGameplayCueNotify_HitImpact) == 0x000050, "Wrong size on UHWGameplayCueNotify_HitImpact");

// Class Hemingway.HWGameplayCueNotify_Looping
// 0x0018 (0x0FE0 - 0x0FC8)
class AHWGameplayCueNotify_Looping : public AGameplayCueNotify_Looping
{
public:
	uint8                                         Pad_FC8[0x8];                                      // 0x0FC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldVisibilityComponentManageCue;               // 0x0FD0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD1[0xB];                                      // 0x0FD1(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bGroundCue;                                        // 0x0FDC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWFriendlyEnemyReferenceActorChoice          FriendlyEnemyReferenceActorChoice;                 // 0x0FDD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideForSpectator;                                 // 0x0FDE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FDF[0x1];                                      // 0x0FDF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLocalOwnerVisibilityComponentUpdated(class UHWVisibilityComponent* VisibilityComponent);
	void HandleLocalOwnerVisibilityUpdated(class UHWVisibilityComponent* VisibilityComponent);
	void SetSkinnedData();

	class UHWApparelComponent* GetApparelComponent() const;
	const class UHWSkinItem* GetCurrentSkin() const;
	bool IsSkinningReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_Looping">();
	}
	static class AHWGameplayCueNotify_Looping* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameplayCueNotify_Looping>();
	}
};
static_assert(alignof(AHWGameplayCueNotify_Looping) == 0x000008, "Wrong alignment on AHWGameplayCueNotify_Looping");
static_assert(sizeof(AHWGameplayCueNotify_Looping) == 0x000FE0, "Wrong size on AHWGameplayCueNotify_Looping");
static_assert(offsetof(AHWGameplayCueNotify_Looping, bShouldVisibilityComponentManageCue) == 0x000FD0, "Member 'AHWGameplayCueNotify_Looping::bShouldVisibilityComponentManageCue' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Looping, bGroundCue) == 0x000FDC, "Member 'AHWGameplayCueNotify_Looping::bGroundCue' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Looping, FriendlyEnemyReferenceActorChoice) == 0x000FDD, "Member 'AHWGameplayCueNotify_Looping::FriendlyEnemyReferenceActorChoice' has a wrong offset!");
static_assert(offsetof(AHWGameplayCueNotify_Looping, bHideForSpectator) == 0x000FDE, "Member 'AHWGameplayCueNotify_Looping::bHideForSpectator' has a wrong offset!");

// Class Hemingway.HWGameplayCueNotify_Static
// 0x0000 (0x0040 - 0x0040)
class UHWGameplayCueNotify_Static final : public UGameplayCueNotify_Static
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayCueNotify_Static">();
	}
	static class UHWGameplayCueNotify_Static* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayCueNotify_Static>();
	}
};
static_assert(alignof(UHWGameplayCueNotify_Static) == 0x000008, "Wrong alignment on UHWGameplayCueNotify_Static");
static_assert(sizeof(UHWGameplayCueNotify_Static) == 0x000040, "Wrong size on UHWGameplayCueNotify_Static");

// Class Hemingway.HWGameplayFlight
// 0x06B8 (0x06E0 - 0x0028)
class UHWGameplayFlight final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWCharacterMovementComponent*          CharacterMovementComponent;                        // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             FlyingCharacter;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Instigator;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayAbility*                       InstigatingAbility;                                // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FlightIdTag;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         AbilityPredictionKey;                              // 0x0058(0x0018)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWGameplayFlight* Flight, const EHWEndFlightReason EndFlightReason)> OnFlightEndedDelegate; // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsFlightActive;                                   // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAscentActive;                                   // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMidFlightActive;                                // 0x0082(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDescentActive;                                  // 0x0083(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAscentServerComplete;                           // 0x0084(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FlightOrigin;                                      // 0x0088(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CharacterStartingRotation;                         // 0x00A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EFlightAscentType                             FlightAscentType;                                  // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AscentDuration;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        AscentHeight;                                      // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFlightHorizontalSpeedType                    AscentHorizontalSpeedType;                         // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWFlightMoveSpeedValues               AscentHorizontalMaxSpeedModifier;                  // 0x00CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHWFlightMoveSpeedValues               AbsoluteAscentHorizontalMaxSpeed;                  // 0x00D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSnapVelocityToRelativeMaxSpeedOnEndAscent;        // 0x00E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClampAscentToMaxHeight;                           // 0x00E5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCameraInfluenceForAscent;                      // 0x00E6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E7[0x1];                                       // 0x00E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWFlightCameraInfluenceSpeedPercentages AscentCameraInfluenceSpeedPercentages;           // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AscentHorizontalSpeedDampening;                    // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AscentTurningDegreesPerSecond;                     // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFlightHorizontalSpeedType                    MidFlightSpeedType;                                // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWFlightMoveSpeedValues               MidFlightHorizontalMaxSpeedModifier;               // 0x00FC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHWFlightMoveSpeedValues               AbsoluteMidFlightHorizontalMaxSpeed;               // 0x0108(0x000C)(Edit, BlueprintVisible, Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseCameraInfluenceForMidFlight;                   // 0x0114(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWFlightCameraInfluenceSpeedPercentages MidFlightCameraInfluenceSpeedPercentages;        // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MidFlightHorizontalSpeedDampening;                 // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MidFlightTurningDegreesPerSecond;                  // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AscentEndTime;                                     // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FlightAscentCurve;                                 // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayTween>           FlightAscentTweenClass;                            // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AscentTweenEndHeight;                              // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWGameplayTween>           FlightDescentTweenClass;                           // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInheritedTagContainer                 FlightCancelTags;                                  // 0x0150(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 FlightBlockTags;                                   // 0x01B0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 TagsToApplyWhileFlying;                            // 0x0210(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyWhileFlying;                         // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    EffectsAppliedWhileFlying;                         // 0x0280(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 AscentCancelTags;                                  // 0x0290(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 AscentBlockTags;                                   // 0x02F0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 TagsToApplyWhileAscending;                         // 0x0350(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyWhileAscending;                      // 0x03B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    EffectsAppliedWhileAscending;                      // 0x03C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 MidFlightCancelTags;                               // 0x03D0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 MidFlightBlockTags;                                // 0x0430(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 TagsToApplyWhileMidFlight;                         // 0x0490(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyWhileMidFlight;                      // 0x04F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    EffectsAppliedWhileMidFlight;                      // 0x0500(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBodyInstance                          FlightCollision;                                   // 0x0510(0x0190)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	EFlightCollisionProfileChoice                 FlightProfileChoice;                               // 0x06A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A1[0x3];                                      // 0x06A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWCollisionState                      PushedCollisionState;                              // 0x06A4(0x003C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	bool bIsUsingCustomProfile();
	void EndFlight(const EHWEndFlightReason EndFlightReason, const EHWEndFlightBehavior EndFlightBehavior);
	void EndFlightAscent();
	void EndMidFlight();
	void OnFlightAscentEnded();
	void OnFlightAscentStarted();
	void OnFlightDescentEnded(const EHWEndFlightReason EndFlightReason);
	void OnFlightDescentStarted();
	void OnTweenEnded();
	void StartFlight();
	void StartFlightAscent();
	void StartFlightDescent();
	void StartMidFlight();

	double GetAscentDestinationHeight() const;
	float GetAscentHorizontalMaxSpeed() const;
	float GetAscentSpeed() const;
	struct FGameplayTag GetFlightIdTag() const;
	struct FVector GetFlightOrigin() const;
	class ACharacter* GetFlyingCharacter() const;
	float GetHorizontalMaxSpeed() const;
	float GetMidFlightHorizontalMaxSpeed() const;
	float GetMoveSpeedValueBasedOnMovementDirection(const struct FHWFlightMoveSpeedValues& MoveSpeedValues) const;
	float GetTurningDegreesPerSecond() const;
	bool HasForcedMovement() const;
	bool IsAscentActive() const;
	bool IsAscentServerComplete() const;
	bool IsDescentActive() const;
	bool IsFlightActive() const;
	bool IsMidFlightActive() const;
	bool ShouldCalcRotation() const;
	bool ShouldCalcVelocity() const;
	bool ShouldClampAscentToMaxHeight() const;
	bool ShouldEndAscent() const;
	bool ShouldIgnoreClientCorrections() const;
	bool UsesCurveBasedAscent() const;
	bool UsesPhysicsBasedAscent() const;
	bool UsesTweenBasedAscent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayFlight">();
	}
	static class UHWGameplayFlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayFlight>();
	}
};
static_assert(alignof(UHWGameplayFlight) == 0x000008, "Wrong alignment on UHWGameplayFlight");
static_assert(sizeof(UHWGameplayFlight) == 0x0006E0, "Wrong size on UHWGameplayFlight");
static_assert(offsetof(UHWGameplayFlight, CharacterMovementComponent) == 0x000030, "Member 'UHWGameplayFlight::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlyingCharacter) == 0x000038, "Member 'UHWGameplayFlight::FlyingCharacter' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, Instigator) == 0x000040, "Member 'UHWGameplayFlight::Instigator' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, InstigatingAbility) == 0x000048, "Member 'UHWGameplayFlight::InstigatingAbility' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlightIdTag) == 0x000050, "Member 'UHWGameplayFlight::FlightIdTag' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AbilityPredictionKey) == 0x000058, "Member 'UHWGameplayFlight::AbilityPredictionKey' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, OnFlightEndedDelegate) == 0x000070, "Member 'UHWGameplayFlight::OnFlightEndedDelegate' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, bIsFlightActive) == 0x000080, "Member 'UHWGameplayFlight::bIsFlightActive' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, bIsAscentActive) == 0x000081, "Member 'UHWGameplayFlight::bIsAscentActive' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, bIsMidFlightActive) == 0x000082, "Member 'UHWGameplayFlight::bIsMidFlightActive' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, bIsDescentActive) == 0x000083, "Member 'UHWGameplayFlight::bIsDescentActive' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, bIsAscentServerComplete) == 0x000084, "Member 'UHWGameplayFlight::bIsAscentServerComplete' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlightOrigin) == 0x000088, "Member 'UHWGameplayFlight::FlightOrigin' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, CharacterStartingRotation) == 0x0000A0, "Member 'UHWGameplayFlight::CharacterStartingRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlightAscentType) == 0x0000B8, "Member 'UHWGameplayFlight::FlightAscentType' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentDuration) == 0x0000BC, "Member 'UHWGameplayFlight::AscentDuration' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentHeight) == 0x0000C0, "Member 'UHWGameplayFlight::AscentHeight' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentHorizontalSpeedType) == 0x0000C8, "Member 'UHWGameplayFlight::AscentHorizontalSpeedType' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentHorizontalMaxSpeedModifier) == 0x0000CC, "Member 'UHWGameplayFlight::AscentHorizontalMaxSpeedModifier' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AbsoluteAscentHorizontalMaxSpeed) == 0x0000D8, "Member 'UHWGameplayFlight::AbsoluteAscentHorizontalMaxSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, bSnapVelocityToRelativeMaxSpeedOnEndAscent) == 0x0000E4, "Member 'UHWGameplayFlight::bSnapVelocityToRelativeMaxSpeedOnEndAscent' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, bClampAscentToMaxHeight) == 0x0000E5, "Member 'UHWGameplayFlight::bClampAscentToMaxHeight' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, bUseCameraInfluenceForAscent) == 0x0000E6, "Member 'UHWGameplayFlight::bUseCameraInfluenceForAscent' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentCameraInfluenceSpeedPercentages) == 0x0000E8, "Member 'UHWGameplayFlight::AscentCameraInfluenceSpeedPercentages' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentHorizontalSpeedDampening) == 0x0000F0, "Member 'UHWGameplayFlight::AscentHorizontalSpeedDampening' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentTurningDegreesPerSecond) == 0x0000F4, "Member 'UHWGameplayFlight::AscentTurningDegreesPerSecond' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, MidFlightSpeedType) == 0x0000F8, "Member 'UHWGameplayFlight::MidFlightSpeedType' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, MidFlightHorizontalMaxSpeedModifier) == 0x0000FC, "Member 'UHWGameplayFlight::MidFlightHorizontalMaxSpeedModifier' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AbsoluteMidFlightHorizontalMaxSpeed) == 0x000108, "Member 'UHWGameplayFlight::AbsoluteMidFlightHorizontalMaxSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, bUseCameraInfluenceForMidFlight) == 0x000114, "Member 'UHWGameplayFlight::bUseCameraInfluenceForMidFlight' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, MidFlightCameraInfluenceSpeedPercentages) == 0x000118, "Member 'UHWGameplayFlight::MidFlightCameraInfluenceSpeedPercentages' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, MidFlightHorizontalSpeedDampening) == 0x000120, "Member 'UHWGameplayFlight::MidFlightHorizontalSpeedDampening' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, MidFlightTurningDegreesPerSecond) == 0x000124, "Member 'UHWGameplayFlight::MidFlightTurningDegreesPerSecond' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentEndTime) == 0x000128, "Member 'UHWGameplayFlight::AscentEndTime' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlightAscentCurve) == 0x000130, "Member 'UHWGameplayFlight::FlightAscentCurve' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlightAscentTweenClass) == 0x000138, "Member 'UHWGameplayFlight::FlightAscentTweenClass' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentTweenEndHeight) == 0x000140, "Member 'UHWGameplayFlight::AscentTweenEndHeight' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlightDescentTweenClass) == 0x000148, "Member 'UHWGameplayFlight::FlightDescentTweenClass' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlightCancelTags) == 0x000150, "Member 'UHWGameplayFlight::FlightCancelTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlightBlockTags) == 0x0001B0, "Member 'UHWGameplayFlight::FlightBlockTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, TagsToApplyWhileFlying) == 0x000210, "Member 'UHWGameplayFlight::TagsToApplyWhileFlying' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, EffectsToApplyWhileFlying) == 0x000270, "Member 'UHWGameplayFlight::EffectsToApplyWhileFlying' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, EffectsAppliedWhileFlying) == 0x000280, "Member 'UHWGameplayFlight::EffectsAppliedWhileFlying' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentCancelTags) == 0x000290, "Member 'UHWGameplayFlight::AscentCancelTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, AscentBlockTags) == 0x0002F0, "Member 'UHWGameplayFlight::AscentBlockTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, TagsToApplyWhileAscending) == 0x000350, "Member 'UHWGameplayFlight::TagsToApplyWhileAscending' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, EffectsToApplyWhileAscending) == 0x0003B0, "Member 'UHWGameplayFlight::EffectsToApplyWhileAscending' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, EffectsAppliedWhileAscending) == 0x0003C0, "Member 'UHWGameplayFlight::EffectsAppliedWhileAscending' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, MidFlightCancelTags) == 0x0003D0, "Member 'UHWGameplayFlight::MidFlightCancelTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, MidFlightBlockTags) == 0x000430, "Member 'UHWGameplayFlight::MidFlightBlockTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, TagsToApplyWhileMidFlight) == 0x000490, "Member 'UHWGameplayFlight::TagsToApplyWhileMidFlight' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, EffectsToApplyWhileMidFlight) == 0x0004F0, "Member 'UHWGameplayFlight::EffectsToApplyWhileMidFlight' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, EffectsAppliedWhileMidFlight) == 0x000500, "Member 'UHWGameplayFlight::EffectsAppliedWhileMidFlight' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlightCollision) == 0x000510, "Member 'UHWGameplayFlight::FlightCollision' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, FlightProfileChoice) == 0x0006A0, "Member 'UHWGameplayFlight::FlightProfileChoice' has a wrong offset!");
static_assert(offsetof(UHWGameplayFlight, PushedCollisionState) == 0x0006A4, "Member 'UHWGameplayFlight::PushedCollisionState' has a wrong offset!");

// Class Hemingway.HWGameplayGrab
// 0x0498 (0x04C0 - 0x0028)
class UHWGameplayGrab : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWCharacterMovementComponent*          CharacterMovementComponent;                        // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacter_Base*                      GrabTarget;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacter_Base*                      GrabSource;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacter_Base*                      GrabInstigator;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayAbility*                       InstigatingAbility;                                // 0x0050(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTargetCCImmune;                                 // 0x0058(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         InstigatingAbilityPredictionKey;                   // 0x0060(0x0018)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           GrabIdTag;                                         // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGrabControlType                              GrabControlType;                                   // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGrabInterruptType                            GrabInterruptType;                                 // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWEndGrabBehavior                            InterruptExistingGrabBehavior;                     // 0x0082(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWEndGrabBehavior                            EndGrabBehavior;                                   // 0x0083(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeInterruptedByNewGrab;                        // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeInterruptedByNewTween;                       // 0x0085(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeInterruptedByKnockback;                      // 0x0086(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBePurifiedByGrabTarget;                        // 0x0087(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RelativeRotation;                                  // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldGrabOccurIfTargetPurified;                  // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndGrabFrontOffset;                                // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyDismountVelocity;                            // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSourceRotationForDismountDirection;            // 0x00A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DismountDirectionOffset;                           // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         EndGrabVelocityOffset;                             // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DismountMomentumPercent;                           // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClampToMaxSpeedForDismountMomentum;               // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideDismountVelocityZ;                        // 0x00D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DismountVelocityZOverride;                         // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UHWGameplayGrab* Grab)> OnGrabStartedDelegate;               // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayGrab* Grab, const EHWEndGrabReason EndGrabReason)> OnGrabEndedDelegate; // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsGrabActive;                                     // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndTime;                                           // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGrabRotationType                             GrabRotationType;                                  // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMatchControlRotationToGrabSource;                 // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreLookInput;                                  // 0x0109(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A[0x6];                                      // 0x010A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SourceStartingLocation;                            // 0x0110(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetStartingLocation;                            // 0x0128(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               SourceStartingRotation;                            // 0x0140(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               TargetStartingRotation;                            // 0x0158(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x18];                                     // 0x0170(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GrabAttachmentSocketName;                          // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGrabPositionType                             GrabPositionType;                                  // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GrabPositionCustomAngle;                           // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GrabPositionDistance;                              // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GrabPositionHeight;                                // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMaintainOriginalHeight;                           // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAvoidSourceCollisionRadius;                       // 0x01A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAvoidTargetCollisionRadius;                       // 0x01A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachToMeshOnServer;                             // 0x01A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInheritedTagContainer                 CancelTags;                                        // 0x01A8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 BlockTags;                                         // 0x0208(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 TagsToApplyWhileGrabbed;                           // 0x0268(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyWhileGrabbed;                        // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    EffectsAppliedWhileGrabbed;                        // 0x02D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBodyInstance                          GrabCollision;                                     // 0x02E8(0x0190)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	EGrabCollisionProfileChoice                   GrabProfileChoice;                                 // 0x0478(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x3];                                      // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWCollisionState                      PushedCollisionState;                              // 0x047C(0x003C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool bIsUsingCustomProfile();
	struct FVector CalcGrabVelocity(float DeltaTime);
	void EndGrab(const EHWEndGrabReason InEndGrabReason, const EHWEndGrabBehavior InEndGrabBehavior);
	EHWEndGrabBehavior GetInterruptExistingGrabBehavior();
	void OnGrabEnded(const EHWEndGrabReason EndGrabReason);
	void OnGrabStarted();
	void StartGrab();

	bool CanBeInterruptedByKnockback() const;
	bool CanBeInterruptedByNewGrab() const;
	bool CanBeInterruptedByNewTween() const;
	bool CanBePurifiedByGrabTarget() const;
	struct FVector GetCurrentGrabLocation() const;
	EHWEndGrabBehavior GetEndGrabBehavior() const;
	float GetGrabCompletionPercentage() const;
	EGrabControlType GetGrabControlType() const;
	struct FGameplayTag GetGrabIdTag() const;
	class AHWCharacter_Base* GetGrabInstigator() const;
	EGrabInterruptType GetGrabInterruptType() const;
	struct FVector GetGrabLocationOffset() const;
	struct FVector GetGrabLocationOffsetInLocalSpace() const;
	class AHWCharacter_Base* GetGrabSourceCharacter() const;
	class AHWCharacter_Base* GetGrabTargetCharacter() const;
	class UGameplayAbility* GetInstigatingAbility() const;
	bool HasDismountVelocity() const;
	bool HasValidGrabMovement() const;
	bool HasVerticalDismountVelocity() const;
	bool IsActive() const;
	bool IsPositionTypeUsingCustomAngle() const;
	bool ShouldEndGrab() const;
	bool ShouldLockRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayGrab">();
	}
	static class UHWGameplayGrab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayGrab>();
	}
};
static_assert(alignof(UHWGameplayGrab) == 0x000008, "Wrong alignment on UHWGameplayGrab");
static_assert(sizeof(UHWGameplayGrab) == 0x0004C0, "Wrong size on UHWGameplayGrab");
static_assert(offsetof(UHWGameplayGrab, CharacterMovementComponent) == 0x000030, "Member 'UHWGameplayGrab::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabTarget) == 0x000038, "Member 'UHWGameplayGrab::GrabTarget' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabSource) == 0x000040, "Member 'UHWGameplayGrab::GrabSource' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabInstigator) == 0x000048, "Member 'UHWGameplayGrab::GrabInstigator' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, InstigatingAbility) == 0x000050, "Member 'UHWGameplayGrab::InstigatingAbility' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bIsTargetCCImmune) == 0x000058, "Member 'UHWGameplayGrab::bIsTargetCCImmune' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, InstigatingAbilityPredictionKey) == 0x000060, "Member 'UHWGameplayGrab::InstigatingAbilityPredictionKey' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabIdTag) == 0x000078, "Member 'UHWGameplayGrab::GrabIdTag' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabControlType) == 0x000080, "Member 'UHWGameplayGrab::GrabControlType' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabInterruptType) == 0x000081, "Member 'UHWGameplayGrab::GrabInterruptType' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, InterruptExistingGrabBehavior) == 0x000082, "Member 'UHWGameplayGrab::InterruptExistingGrabBehavior' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, EndGrabBehavior) == 0x000083, "Member 'UHWGameplayGrab::EndGrabBehavior' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bCanBeInterruptedByNewGrab) == 0x000084, "Member 'UHWGameplayGrab::bCanBeInterruptedByNewGrab' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bCanBeInterruptedByNewTween) == 0x000085, "Member 'UHWGameplayGrab::bCanBeInterruptedByNewTween' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bCanBeInterruptedByKnockback) == 0x000086, "Member 'UHWGameplayGrab::bCanBeInterruptedByKnockback' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bCanBePurifiedByGrabTarget) == 0x000087, "Member 'UHWGameplayGrab::bCanBePurifiedByGrabTarget' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, RelativeRotation) == 0x000088, "Member 'UHWGameplayGrab::RelativeRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bShouldGrabOccurIfTargetPurified) == 0x0000A0, "Member 'UHWGameplayGrab::bShouldGrabOccurIfTargetPurified' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, EndGrabFrontOffset) == 0x0000A4, "Member 'UHWGameplayGrab::EndGrabFrontOffset' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bApplyDismountVelocity) == 0x0000A8, "Member 'UHWGameplayGrab::bApplyDismountVelocity' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bUseSourceRotationForDismountDirection) == 0x0000A9, "Member 'UHWGameplayGrab::bUseSourceRotationForDismountDirection' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, DismountDirectionOffset) == 0x0000B0, "Member 'UHWGameplayGrab::DismountDirectionOffset' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, EndGrabVelocityOffset) == 0x0000C8, "Member 'UHWGameplayGrab::EndGrabVelocityOffset' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, DismountMomentumPercent) == 0x0000CC, "Member 'UHWGameplayGrab::DismountMomentumPercent' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bClampToMaxSpeedForDismountMomentum) == 0x0000D0, "Member 'UHWGameplayGrab::bClampToMaxSpeedForDismountMomentum' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bOverrideDismountVelocityZ) == 0x0000D1, "Member 'UHWGameplayGrab::bOverrideDismountVelocityZ' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, DismountVelocityZOverride) == 0x0000D4, "Member 'UHWGameplayGrab::DismountVelocityZOverride' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, OnGrabStartedDelegate) == 0x0000D8, "Member 'UHWGameplayGrab::OnGrabStartedDelegate' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, OnGrabEndedDelegate) == 0x0000E8, "Member 'UHWGameplayGrab::OnGrabEndedDelegate' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bIsGrabActive) == 0x0000F8, "Member 'UHWGameplayGrab::bIsGrabActive' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, EndTime) == 0x0000FC, "Member 'UHWGameplayGrab::EndTime' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, Duration) == 0x000100, "Member 'UHWGameplayGrab::Duration' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabRotationType) == 0x000104, "Member 'UHWGameplayGrab::GrabRotationType' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bMatchControlRotationToGrabSource) == 0x000108, "Member 'UHWGameplayGrab::bMatchControlRotationToGrabSource' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bIgnoreLookInput) == 0x000109, "Member 'UHWGameplayGrab::bIgnoreLookInput' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, SourceStartingLocation) == 0x000110, "Member 'UHWGameplayGrab::SourceStartingLocation' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, TargetStartingLocation) == 0x000128, "Member 'UHWGameplayGrab::TargetStartingLocation' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, SourceStartingRotation) == 0x000140, "Member 'UHWGameplayGrab::SourceStartingRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, TargetStartingRotation) == 0x000158, "Member 'UHWGameplayGrab::TargetStartingRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabAttachmentSocketName) == 0x000188, "Member 'UHWGameplayGrab::GrabAttachmentSocketName' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabPositionType) == 0x000190, "Member 'UHWGameplayGrab::GrabPositionType' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabPositionCustomAngle) == 0x000194, "Member 'UHWGameplayGrab::GrabPositionCustomAngle' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabPositionDistance) == 0x000198, "Member 'UHWGameplayGrab::GrabPositionDistance' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabPositionHeight) == 0x00019C, "Member 'UHWGameplayGrab::GrabPositionHeight' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bMaintainOriginalHeight) == 0x0001A0, "Member 'UHWGameplayGrab::bMaintainOriginalHeight' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bAvoidSourceCollisionRadius) == 0x0001A1, "Member 'UHWGameplayGrab::bAvoidSourceCollisionRadius' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bAvoidTargetCollisionRadius) == 0x0001A2, "Member 'UHWGameplayGrab::bAvoidTargetCollisionRadius' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, bAttachToMeshOnServer) == 0x0001A3, "Member 'UHWGameplayGrab::bAttachToMeshOnServer' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, CancelTags) == 0x0001A8, "Member 'UHWGameplayGrab::CancelTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, BlockTags) == 0x000208, "Member 'UHWGameplayGrab::BlockTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, TagsToApplyWhileGrabbed) == 0x000268, "Member 'UHWGameplayGrab::TagsToApplyWhileGrabbed' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, EffectsToApplyWhileGrabbed) == 0x0002C8, "Member 'UHWGameplayGrab::EffectsToApplyWhileGrabbed' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, EffectsAppliedWhileGrabbed) == 0x0002D8, "Member 'UHWGameplayGrab::EffectsAppliedWhileGrabbed' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabCollision) == 0x0002E8, "Member 'UHWGameplayGrab::GrabCollision' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, GrabProfileChoice) == 0x000478, "Member 'UHWGameplayGrab::GrabProfileChoice' has a wrong offset!");
static_assert(offsetof(UHWGameplayGrab, PushedCollisionState) == 0x00047C, "Member 'UHWGameplayGrab::PushedCollisionState' has a wrong offset!");

// Class Hemingway.HWGameplayTween
// 0x0488 (0x04B0 - 0x0028)
class UHWGameplayTween : public UObject
{
public:
	uint8                                         Pad_28[0x4];                                       // 0x0028(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EHWEndTweenReason                             ReasonTweenEnded;                                  // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWCharacterMovementComponent*          CharacterMovementComponent;                        // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             TweeningCharacter;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Instigator;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayAbility*                       InstigatingAbility;                                // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETweenType                                    TweenType;                                         // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAdjustActorTweenLocationToGround;                 // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAvoidSelfAndTargetCollisionRadius;                // 0x0052(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLerpRotationToTargetActorRotation;                // 0x0053(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSnapRotationToTargetActorRotationAtEnd;           // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLerpRotationToCustomRotation;                     // 0x0055(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TweenIdTag;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         AbilityPredictionKey;                              // 0x0060(0x0018)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWEndTweenBehavior                           TweenBehaviorOnInterrupted;                        // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeInterruptedByNewTween;                       // 0x0079(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeInterruptedByKnockback;                      // 0x007A(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBePurifiedByTweenTarget;                       // 0x007B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanTweenToNewPlaneOfExistence;                    // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWGameplayTween* Tween)> OnTweenStartedDelegate;            // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWGameplayTween* Tween, const EHWEndTweenReason EndTweenReason)> OnTweenEndedDelegate; // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsTweenActive;                                    // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndTime;                                           // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTweenWithFixedSpeed;                              // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TweenSpeedOverride;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            VerticalArcCurve;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TweenVariableSpeedCurve;                           // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetCameraPitchAtEnd;                            // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldRotationMatchMovementDirection;             // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnorePitchAxis;                                  // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreYawAxis;                                    // 0x00CB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreRollAxis;                                   // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationInterpFromStartUntilPercentage;            // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationInterpAfterPercentageUntilEnd;             // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLockPawnRotation;                                 // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldSafelyReturnToPlayAreaOnTweenEnd;           // 0x00F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldOffsetGroundTarget;                         // 0x00FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FB[0x5];                                       // 0x00FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TweenDestination;                                  // 0x0100(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  TweenTargetActor;                                  // 0x0118(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TweenOrigin;                                       // 0x0120(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHWTweenStartLocationBehavior                 TweenStartLocationBehavior;                        // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CharacterStartingRotation;                         // 0x0140(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               CameraStartingRotation;                            // 0x0158(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          StartingUseControllerDesiredRotation;              // 0x0170(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CustomEndRotation;                                 // 0x0178(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         TweenTargetDistance;                               // 0x0190(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGainMaxInputSpeedOnTweenEnd;                      // 0x0194(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWAbilityCancelTagRequirement         CancelTags;                                        // 0x0198(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 BlockTags;                                         // 0x01D8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInheritedTagContainer                 TagsToApplyWhileTweening;                          // 0x0238(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyWhileTweening;                       // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    EffectsAppliedWhileTweening;                       // 0x02A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBodyInstance                          TweeningCollision;                                 // 0x02B8(0x0190)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	ETweenCollisionProfileChoice                  TweeningProfileChoice;                             // 0x0448(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndTweenOnCollision;                              // 0x0449(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44A[0x2];                                      // 0x044A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWCollisionState                      PushedCollisionState;                              // 0x044C(0x003C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplinePath;                                        // 0x0488(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSplineEndsAtGroundZ;                              // 0x0490(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_491[0x1F];                                     // 0x0491(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool bIsUsingCustomProfile();
	bool CanBeInterruptedByKnockback();
	bool CanBeInterruptedByNewTween();
	void EndTween(const EHWEndTweenReason EndTweenReason, const EHWEndTweenBehavior EndTweenBehavior);
	void OnCharacterBump(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnTweenEnded(const EHWEndTweenReason EndTweenReason);
	void OnTweenStarted();
	void SetLockPawnRotation(bool bShouldLockPawnRotation);
	void StartTween();

	struct FRotator CalcCharacterRotation() const;
	bool CanBePurifiedByTweenTarget() const;
	bool CanTweenToNewPlaneOfExistence() const;
	struct FVector GetCurrentTweenLocation() const;
	struct FVector GetFinalTweenDestination() const;
	const class USplineComponent* GetSplinePath() const;
	EHWEndTweenBehavior GetTweenBehaviorOnInterrupted(const EHWEndTweenReason EndTweenReason) const;
	float GetTweenCompletionPercentage() const;
	struct FGameplayTag GetTweenId() const;
	class ACharacter* GetTweeningCharacter() const;
	struct FVector GetTweenOrigin() const;
	ETweenType GetTweenType() const;
	float GetVerticalArcHeight(const float TweenPercentage) const;
	bool IsActive() const;
	bool ShouldEndTween() const;
	bool ShouldGainMaxInputSpeedOnTweenEnd() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayTween">();
	}
	static class UHWGameplayTween* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayTween>();
	}
};
static_assert(alignof(UHWGameplayTween) == 0x000008, "Wrong alignment on UHWGameplayTween");
static_assert(sizeof(UHWGameplayTween) == 0x0004B0, "Wrong size on UHWGameplayTween");
static_assert(offsetof(UHWGameplayTween, ReasonTweenEnded) == 0x00002C, "Member 'UHWGameplayTween::ReasonTweenEnded' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, CharacterMovementComponent) == 0x000030, "Member 'UHWGameplayTween::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweeningCharacter) == 0x000038, "Member 'UHWGameplayTween::TweeningCharacter' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, Instigator) == 0x000040, "Member 'UHWGameplayTween::Instigator' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, InstigatingAbility) == 0x000048, "Member 'UHWGameplayTween::InstigatingAbility' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweenType) == 0x000050, "Member 'UHWGameplayTween::TweenType' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bAdjustActorTweenLocationToGround) == 0x000051, "Member 'UHWGameplayTween::bAdjustActorTweenLocationToGround' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bAvoidSelfAndTargetCollisionRadius) == 0x000052, "Member 'UHWGameplayTween::bAvoidSelfAndTargetCollisionRadius' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bLerpRotationToTargetActorRotation) == 0x000053, "Member 'UHWGameplayTween::bLerpRotationToTargetActorRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bSnapRotationToTargetActorRotationAtEnd) == 0x000054, "Member 'UHWGameplayTween::bSnapRotationToTargetActorRotationAtEnd' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bLerpRotationToCustomRotation) == 0x000055, "Member 'UHWGameplayTween::bLerpRotationToCustomRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweenIdTag) == 0x000058, "Member 'UHWGameplayTween::TweenIdTag' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, AbilityPredictionKey) == 0x000060, "Member 'UHWGameplayTween::AbilityPredictionKey' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweenBehaviorOnInterrupted) == 0x000078, "Member 'UHWGameplayTween::TweenBehaviorOnInterrupted' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bCanBeInterruptedByNewTween) == 0x000079, "Member 'UHWGameplayTween::bCanBeInterruptedByNewTween' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bCanBeInterruptedByKnockback) == 0x00007A, "Member 'UHWGameplayTween::bCanBeInterruptedByKnockback' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bCanBePurifiedByTweenTarget) == 0x00007B, "Member 'UHWGameplayTween::bCanBePurifiedByTweenTarget' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bCanTweenToNewPlaneOfExistence) == 0x00007C, "Member 'UHWGameplayTween::bCanTweenToNewPlaneOfExistence' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, OnTweenStartedDelegate) == 0x000080, "Member 'UHWGameplayTween::OnTweenStartedDelegate' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, OnTweenEndedDelegate) == 0x000090, "Member 'UHWGameplayTween::OnTweenEndedDelegate' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bIsTweenActive) == 0x0000A0, "Member 'UHWGameplayTween::bIsTweenActive' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, EndTime) == 0x0000A4, "Member 'UHWGameplayTween::EndTime' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, Duration) == 0x0000A8, "Member 'UHWGameplayTween::Duration' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bTweenWithFixedSpeed) == 0x0000AC, "Member 'UHWGameplayTween::bTweenWithFixedSpeed' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweenSpeedOverride) == 0x0000B0, "Member 'UHWGameplayTween::TweenSpeedOverride' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, VerticalArcCurve) == 0x0000B8, "Member 'UHWGameplayTween::VerticalArcCurve' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweenVariableSpeedCurve) == 0x0000C0, "Member 'UHWGameplayTween::TweenVariableSpeedCurve' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bResetCameraPitchAtEnd) == 0x0000C8, "Member 'UHWGameplayTween::bResetCameraPitchAtEnd' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bShouldRotationMatchMovementDirection) == 0x0000C9, "Member 'UHWGameplayTween::bShouldRotationMatchMovementDirection' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bIgnorePitchAxis) == 0x0000CA, "Member 'UHWGameplayTween::bIgnorePitchAxis' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bIgnoreYawAxis) == 0x0000CB, "Member 'UHWGameplayTween::bIgnoreYawAxis' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bIgnoreRollAxis) == 0x0000CC, "Member 'UHWGameplayTween::bIgnoreRollAxis' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, RotationInterpFromStartUntilPercentage) == 0x0000D0, "Member 'UHWGameplayTween::RotationInterpFromStartUntilPercentage' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, RotationInterpAfterPercentageUntilEnd) == 0x0000D4, "Member 'UHWGameplayTween::RotationInterpAfterPercentageUntilEnd' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bLockPawnRotation) == 0x0000F8, "Member 'UHWGameplayTween::bLockPawnRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bShouldSafelyReturnToPlayAreaOnTweenEnd) == 0x0000F9, "Member 'UHWGameplayTween::bShouldSafelyReturnToPlayAreaOnTweenEnd' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bShouldOffsetGroundTarget) == 0x0000FA, "Member 'UHWGameplayTween::bShouldOffsetGroundTarget' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweenDestination) == 0x000100, "Member 'UHWGameplayTween::TweenDestination' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweenTargetActor) == 0x000118, "Member 'UHWGameplayTween::TweenTargetActor' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweenOrigin) == 0x000120, "Member 'UHWGameplayTween::TweenOrigin' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweenStartLocationBehavior) == 0x000138, "Member 'UHWGameplayTween::TweenStartLocationBehavior' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, CharacterStartingRotation) == 0x000140, "Member 'UHWGameplayTween::CharacterStartingRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, CameraStartingRotation) == 0x000158, "Member 'UHWGameplayTween::CameraStartingRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, StartingUseControllerDesiredRotation) == 0x000170, "Member 'UHWGameplayTween::StartingUseControllerDesiredRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, CustomEndRotation) == 0x000178, "Member 'UHWGameplayTween::CustomEndRotation' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweenTargetDistance) == 0x000190, "Member 'UHWGameplayTween::TweenTargetDistance' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bGainMaxInputSpeedOnTweenEnd) == 0x000194, "Member 'UHWGameplayTween::bGainMaxInputSpeedOnTweenEnd' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, CancelTags) == 0x000198, "Member 'UHWGameplayTween::CancelTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, BlockTags) == 0x0001D8, "Member 'UHWGameplayTween::BlockTags' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TagsToApplyWhileTweening) == 0x000238, "Member 'UHWGameplayTween::TagsToApplyWhileTweening' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, EffectsToApplyWhileTweening) == 0x000298, "Member 'UHWGameplayTween::EffectsToApplyWhileTweening' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, EffectsAppliedWhileTweening) == 0x0002A8, "Member 'UHWGameplayTween::EffectsAppliedWhileTweening' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweeningCollision) == 0x0002B8, "Member 'UHWGameplayTween::TweeningCollision' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, TweeningProfileChoice) == 0x000448, "Member 'UHWGameplayTween::TweeningProfileChoice' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bEndTweenOnCollision) == 0x000449, "Member 'UHWGameplayTween::bEndTweenOnCollision' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, PushedCollisionState) == 0x00044C, "Member 'UHWGameplayTween::PushedCollisionState' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, SplinePath) == 0x000488, "Member 'UHWGameplayTween::SplinePath' has a wrong offset!");
static_assert(offsetof(UHWGameplayTween, bSplineEndsAtGroundZ) == 0x000490, "Member 'UHWGameplayTween::bSplineEndsAtGroundZ' has a wrong offset!");

// Class Hemingway.HWSettingsSaveGame
// 0x0070 (0x0300 - 0x0290)
class UHWSettingsSaveGame final : public URHSettingsSaveGame
{
public:
	struct FHWLocalPlayerPreferences              SavedLocalPlayerPreferences;                       // 0x0290(0x0018)(NativeAccessSpecifierPublic)
	int32                                         PSOCacheClearVersion;                              // 0x02A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      SavedSettingVersions;                              // 0x02B0(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSettingsSaveGame">();
	}
	static class UHWSettingsSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSettingsSaveGame>();
	}
};
static_assert(alignof(UHWSettingsSaveGame) == 0x000008, "Wrong alignment on UHWSettingsSaveGame");
static_assert(sizeof(UHWSettingsSaveGame) == 0x000300, "Wrong size on UHWSettingsSaveGame");
static_assert(offsetof(UHWSettingsSaveGame, SavedLocalPlayerPreferences) == 0x000290, "Member 'UHWSettingsSaveGame::SavedLocalPlayerPreferences' has a wrong offset!");
static_assert(offsetof(UHWSettingsSaveGame, PSOCacheClearVersion) == 0x0002A8, "Member 'UHWSettingsSaveGame::PSOCacheClearVersion' has a wrong offset!");
static_assert(offsetof(UHWSettingsSaveGame, SavedSettingVersions) == 0x0002B0, "Member 'UHWSettingsSaveGame::SavedSettingVersions' has a wrong offset!");

// Class Hemingway.HWGameUserSettings
// 0x00D0 (0x0710 - 0x0640)
class UHWGameUserSettings final : public URHGameUserSettings
{
public:
	uint8                                         Pad_640[0x8];                                      // 0x0640(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWLocalPlayerPreferences              LocalPlayerPreferences;                            // 0x0648(0x0018)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_660[0x50];                                     // 0x0660(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinResolutionX;                                    // 0x06B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinResolutionY;                                    // 0x06B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B8[0x50];                                     // 0x06B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinPSOCacheClearVersion;                           // 0x0708(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetAudioInputDevicesAsText(TArray<class FText>* OutAudioInputDevices);
	void GetReflexModeAsInt(int32* OutReflexMode);
	void GetSupportedResolutionsAsText(TArray<class FText>* OutSupportedResolutions);

	int32 GetCurrentAudioInputDeviceIndex() const;
	int32 GetCurrentResolutionIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameUserSettings">();
	}
	static class UHWGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameUserSettings>();
	}
};
static_assert(alignof(UHWGameUserSettings) == 0x000008, "Wrong alignment on UHWGameUserSettings");
static_assert(sizeof(UHWGameUserSettings) == 0x000710, "Wrong size on UHWGameUserSettings");
static_assert(offsetof(UHWGameUserSettings, LocalPlayerPreferences) == 0x000648, "Member 'UHWGameUserSettings::LocalPlayerPreferences' has a wrong offset!");
static_assert(offsetof(UHWGameUserSettings, MinResolutionX) == 0x0006B0, "Member 'UHWGameUserSettings::MinResolutionX' has a wrong offset!");
static_assert(offsetof(UHWGameUserSettings, MinResolutionY) == 0x0006B4, "Member 'UHWGameUserSettings::MinResolutionY' has a wrong offset!");
static_assert(offsetof(UHWGameUserSettings, MinPSOCacheClearVersion) == 0x000708, "Member 'UHWGameUserSettings::MinPSOCacheClearVersion' has a wrong offset!");

// Class Hemingway.HWGameplayEffect_ShieldOwner
// 0x0040 (0x0AF8 - 0x0AB8)
class UHWGameplayEffect_ShieldOwner : public UHWGameplayEffect
{
public:
	TArray<struct FGameplayEffectModifierMagnitude> InitialShieldHealthFactors;                      // 0x0AB8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectModifierMagnitude> MaxShieldHealthFactors;                          // 0x0AC8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectModifierMagnitude> MaxLifetimeFactors;                              // 0x0AD8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ShieldEffectTag;                                   // 0x0AE8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EShieldType                                   ShieldType;                                        // 0x0AF0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReplaceOnReapplication;                           // 0x0AF1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetMaxHealthEqualToInitial;                       // 0x0AF2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF3[0x5];                                      // 0x0AF3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGameplayTag GetShieldEffectTag() const;
	EShieldType GetShieldType() const;
	bool ShouldReplaceOnReapplication() const;
	bool ShouldSetMaxHealthEqualToInitial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayEffect_ShieldOwner">();
	}
	static class UHWGameplayEffect_ShieldOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayEffect_ShieldOwner>();
	}
};
static_assert(alignof(UHWGameplayEffect_ShieldOwner) == 0x000008, "Wrong alignment on UHWGameplayEffect_ShieldOwner");
static_assert(sizeof(UHWGameplayEffect_ShieldOwner) == 0x000AF8, "Wrong size on UHWGameplayEffect_ShieldOwner");
static_assert(offsetof(UHWGameplayEffect_ShieldOwner, InitialShieldHealthFactors) == 0x000AB8, "Member 'UHWGameplayEffect_ShieldOwner::InitialShieldHealthFactors' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_ShieldOwner, MaxShieldHealthFactors) == 0x000AC8, "Member 'UHWGameplayEffect_ShieldOwner::MaxShieldHealthFactors' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_ShieldOwner, MaxLifetimeFactors) == 0x000AD8, "Member 'UHWGameplayEffect_ShieldOwner::MaxLifetimeFactors' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_ShieldOwner, ShieldEffectTag) == 0x000AE8, "Member 'UHWGameplayEffect_ShieldOwner::ShieldEffectTag' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_ShieldOwner, ShieldType) == 0x000AF0, "Member 'UHWGameplayEffect_ShieldOwner::ShieldType' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_ShieldOwner, bReplaceOnReapplication) == 0x000AF1, "Member 'UHWGameplayEffect_ShieldOwner::bReplaceOnReapplication' has a wrong offset!");
static_assert(offsetof(UHWGameplayEffect_ShieldOwner, bSetMaxHealthEqualToInitial) == 0x000AF2, "Member 'UHWGameplayEffect_ShieldOwner::bSetMaxHealthEqualToInitial' has a wrong offset!");

// Class Hemingway.HWShieldInstance
// 0x0070 (0x0098 - 0x0028)
class UHWShieldInstance final : public UObject
{
public:
	TMulticastInlineDelegate<void(class UHWShieldInstance* ShieldInstance, float NewHealth)> OnShieldHealthChangeDel; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UHWShieldInstance* ShieldInstance)> OnShieldDestroyedDel;    // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWShieldManagerComponent*              ShieldManagerComponent;                            // 0x0048(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ShieldEffectTag;                                   // 0x0070(0x0008)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentShieldHealth;                               // 0x0078(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxShieldHealth;                                   // 0x007C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLifetime;                                       // 0x0080(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CreationTimestamp;                                 // 0x0084(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifetimeLastModifiedTimestamp;                     // 0x0088(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PredictedExpirationTimestamp;                      // 0x008C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EShieldType                                   ShieldType;                                        // 0x0090(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddShieldHealth(const float ShieldHealthToAdd);
	void ExtendLifetime(const float SecondsToAdd);
	void OnRep_CurrentShieldHealth();
	void RemoveShield();
	void RemoveShieldLifetimeExpired(const struct FGameplayEffectRemovalInfo& RemovalInfo);
	void SetLifetime(const float NewLifetime);
	void SetShieldHealth(const float NewShieldHealth);
	void ShortenLifetime(const float SecondsToSubtract);
	float SubtractShieldHealth(const float ShieldHealthToSubtract);

	struct FActiveGameplayEffectHandle GetActiveShieldEffectHandle() const;
	float GetCurrentLifetime() const;
	float GetCurrentShieldHealth() const;
	float GetMaxLifetime() const;
	float GetMaxShieldHealth() const;
	struct FGameplayTag GetShieldEffectTag() const;
	class UHWAbilitySystemComponent* GetShieldGranterASC() const;
	class UHWShieldManagerComponent* GetShieldManagerComponent() const;
	EShieldType GetShieldType() const;
	bool HasLifetime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWShieldInstance">();
	}
	static class UHWShieldInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWShieldInstance>();
	}
};
static_assert(alignof(UHWShieldInstance) == 0x000008, "Wrong alignment on UHWShieldInstance");
static_assert(sizeof(UHWShieldInstance) == 0x000098, "Wrong size on UHWShieldInstance");
static_assert(offsetof(UHWShieldInstance, OnShieldHealthChangeDel) == 0x000028, "Member 'UHWShieldInstance::OnShieldHealthChangeDel' has a wrong offset!");
static_assert(offsetof(UHWShieldInstance, OnShieldDestroyedDel) == 0x000038, "Member 'UHWShieldInstance::OnShieldDestroyedDel' has a wrong offset!");
static_assert(offsetof(UHWShieldInstance, ShieldManagerComponent) == 0x000048, "Member 'UHWShieldInstance::ShieldManagerComponent' has a wrong offset!");
static_assert(offsetof(UHWShieldInstance, ShieldEffectTag) == 0x000070, "Member 'UHWShieldInstance::ShieldEffectTag' has a wrong offset!");
static_assert(offsetof(UHWShieldInstance, CurrentShieldHealth) == 0x000078, "Member 'UHWShieldInstance::CurrentShieldHealth' has a wrong offset!");
static_assert(offsetof(UHWShieldInstance, MaxShieldHealth) == 0x00007C, "Member 'UHWShieldInstance::MaxShieldHealth' has a wrong offset!");
static_assert(offsetof(UHWShieldInstance, MaxLifetime) == 0x000080, "Member 'UHWShieldInstance::MaxLifetime' has a wrong offset!");
static_assert(offsetof(UHWShieldInstance, CreationTimestamp) == 0x000084, "Member 'UHWShieldInstance::CreationTimestamp' has a wrong offset!");
static_assert(offsetof(UHWShieldInstance, LifetimeLastModifiedTimestamp) == 0x000088, "Member 'UHWShieldInstance::LifetimeLastModifiedTimestamp' has a wrong offset!");
static_assert(offsetof(UHWShieldInstance, PredictedExpirationTimestamp) == 0x00008C, "Member 'UHWShieldInstance::PredictedExpirationTimestamp' has a wrong offset!");
static_assert(offsetof(UHWShieldInstance, ShieldType) == 0x000090, "Member 'UHWShieldInstance::ShieldType' has a wrong offset!");

// Class Hemingway.HWGameInstance
// 0x00D0 (0x03F8 - 0x0328)
class UHWGameInstance final : public URHGameInstance
{
public:
	class UHWTagManager*                          TagManager;                                        // 0x0328(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         NetworkFailureSessionIds;                          // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x58];                                     // 0x0340(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWGetGud*                              GetGudInstance;                                    // 0x0398(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x58];                                     // 0x03A0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearDisconnectErrorCode();
	void ClearTravelErrorCode();
	void NetworkFailureEvent(class UWorld* InWorld, class UNetDriver* InNetDriver, ENetworkFailure InFailureType, const class FString& InErrorDescription);
	void OnActiveSessionChanged(class URH_JoinedSession* OldSesion, class URH_JoinedSession* JoinedSession);
	void OnSessionUpdated(class URH_SessionView* SessionView);
	void SetAllMuted(const struct FGuid& PlayerUuid, bool bIsMuted);
	void SetDisconnectErrorCode(const class FText& ErrorCode);
	void SetPingsMuted(const struct FGuid& PlayerUuid, bool bIsMuted);
	void SetTextMuted(const struct FGuid& PlayerUuid, bool bIsMuted);
	void SetTravelErrorCode(const class FText& ErrorCode);
	void SetVGSMuted(const struct FGuid& PlayerUuid, bool bIsMuted);
	void TravelFailureEvent(class UWorld* InWorld, ETravelFailure InFailureType, const class FString& InErrorDescription);

	bool GetDisconnectErrorCode(class FText* OutDisconnectError) const;
	const TArray<class FString> GetNetworkFailureSessionIds() const;
	struct FRHPlayerMuteFlags GetPlayerMuteFlags(const struct FGuid& PlayerUuid) const;
	class UHWTagManager* GetTagManager() const;
	bool GetTravelErrorCode(class FText* OutDisconnectError) const;
	bool IsAllMuted(const struct FGuid& PlayerUuid) const;
	bool IsGm() const;
	bool IsPingsMuted(const struct FGuid& PlayerUuid) const;
	bool IsTextMuted(const struct FGuid& PlayerUuid) const;
	bool IsVGSMuted(const struct FGuid& PlayerUuid) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameInstance">();
	}
	static class UHWGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameInstance>();
	}
};
static_assert(alignof(UHWGameInstance) == 0x000008, "Wrong alignment on UHWGameInstance");
static_assert(sizeof(UHWGameInstance) == 0x0003F8, "Wrong size on UHWGameInstance");
static_assert(offsetof(UHWGameInstance, TagManager) == 0x000328, "Member 'UHWGameInstance::TagManager' has a wrong offset!");
static_assert(offsetof(UHWGameInstance, NetworkFailureSessionIds) == 0x000330, "Member 'UHWGameInstance::NetworkFailureSessionIds' has a wrong offset!");
static_assert(offsetof(UHWGameInstance, GetGudInstance) == 0x000398, "Member 'UHWGameInstance::GetGudInstance' has a wrong offset!");

// Class Hemingway.HWPlayerStart
// 0x0010 (0x02D8 - 0x02C8)
class AHWPlayerStart final : public APlayerStart
{
public:
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericTeamId                         SpawnForTeamId;                                    // 0x02D0(0x0001)(Edit, BlueprintVisible, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterRole                                PreferredRole;                                     // 0x02D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D2[0x2];                                      // 0x02D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PreferredSpawnOrderIndex;                          // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerStart">();
	}
	static class AHWPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPlayerStart>();
	}
};
static_assert(alignof(AHWPlayerStart) == 0x000008, "Wrong alignment on AHWPlayerStart");
static_assert(sizeof(AHWPlayerStart) == 0x0002D8, "Wrong size on AHWPlayerStart");
static_assert(offsetof(AHWPlayerStart, SpawnForTeamId) == 0x0002D0, "Member 'AHWPlayerStart::SpawnForTeamId' has a wrong offset!");
static_assert(offsetof(AHWPlayerStart, PreferredRole) == 0x0002D1, "Member 'AHWPlayerStart::PreferredRole' has a wrong offset!");
static_assert(offsetof(AHWPlayerStart, PreferredSpawnOrderIndex) == 0x0002D4, "Member 'AHWPlayerStart::PreferredSpawnOrderIndex' has a wrong offset!");

// Class Hemingway.HWRespawnManager
// 0x00D0 (0x0368 - 0x0298)
class AHWRespawnManager final : public AInfo
{
public:
	TMulticastInlineDelegate<void(class AHWPlayerState* RespawnedPlayer)> OnPlayerRespawnedDelegate; // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	class AHWGameMode*                            AuthorityGameMode;                                 // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FHWPersistentPlayerId, struct FHWRespawnData> DelayRespawns;                         // 0x02B0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWRespawnData>                 PendingRespawns;                                   // 0x0300(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSet<struct FHWPersistentPlayerId>            PendingSpawnPlayerIDs;                             // 0x0310(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         MaximumRespawnsPerFrame;                           // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanRespawnPlayer(class AController* Player);
	void ForceRespawn(class AHWPlayerState* Player);
	void PostAddPlayerToRespawnQueue(const struct FHWRespawnData& Data);
	void PostRespawnPlayer(class AController* Player);
	void PreAddPlayerToRespawnQueue(class AHWPlayerState* PlayerState);
	void TryToAddPlayerToRespawnQueue(class AHWPlayerState* PlayerState, bool ShouldForce);

	bool CanAddPlayerToRespawnQueue(class AHWPlayerState* PlayerState, bool bForce) const;
	class AHWGameMode* GetGameMode() const;
	bool IsPlayerInRespawnQueue(const class AHWPlayerState* PlayerState, float* OutRespawnTimeRemaining) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWRespawnManager">();
	}
	static class AHWRespawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWRespawnManager>();
	}
};
static_assert(alignof(AHWRespawnManager) == 0x000008, "Wrong alignment on AHWRespawnManager");
static_assert(sizeof(AHWRespawnManager) == 0x000368, "Wrong size on AHWRespawnManager");
static_assert(offsetof(AHWRespawnManager, OnPlayerRespawnedDelegate) == 0x000298, "Member 'AHWRespawnManager::OnPlayerRespawnedDelegate' has a wrong offset!");
static_assert(offsetof(AHWRespawnManager, AuthorityGameMode) == 0x0002A8, "Member 'AHWRespawnManager::AuthorityGameMode' has a wrong offset!");
static_assert(offsetof(AHWRespawnManager, DelayRespawns) == 0x0002B0, "Member 'AHWRespawnManager::DelayRespawns' has a wrong offset!");
static_assert(offsetof(AHWRespawnManager, PendingRespawns) == 0x000300, "Member 'AHWRespawnManager::PendingRespawns' has a wrong offset!");
static_assert(offsetof(AHWRespawnManager, PendingSpawnPlayerIDs) == 0x000310, "Member 'AHWRespawnManager::PendingSpawnPlayerIDs' has a wrong offset!");
static_assert(offsetof(AHWRespawnManager, MaximumRespawnsPerFrame) == 0x000360, "Member 'AHWRespawnManager::MaximumRespawnsPerFrame' has a wrong offset!");

// Class Hemingway.HWTeamState
// 0x0230 (0x04C8 - 0x0298)
class AHWTeamState final : public AInfo
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* NewMember)> OnTeamMemberAdded;               // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* OldMember)> OnTeamMemberRemoved;             // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTeamMembersUpdated;                              // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* Team, class AHWPlayerState* TeamMember, const struct FDamageEventData& KillEventData)> OnTeamMemberCommittedKillDelegate; // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* Team, class AHWPlayerState* TeamMember, const struct FAssistEventData& AssistEventData)> OnTeamMemberCommittedAssistDelegate; // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* Team, class AHWPlayerState* TeamMember, const struct FDamageEventData& DeathEventData)> OnTeamMemberDiedDelegate; // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x0300(0x0001)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWPlayerState*>                 TeamMembers;                                       // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState)> OnTeamStructuresUpdated;           // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AHWBotFactory*>                  TeamStructures;                                    // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState)> OnNPCFactoriesUpdated;             // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AHWBotFactory*>                  NPCFactories;                                      // 0x0350(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class AHWBotFactory*>                  GodBotFactories;                                   // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, class AHWTeamStatsTracker* TeamStatsTracker)> OnTeamStatsTrackerReplicated; // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AHWTeamStatsTracker>     TeamStatsTracker;                                  // 0x0380(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWPawnMinimapState>            TeamNPCMinimapState;                               // 0x03A0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, int32 NumYesVotes, int32 NumNoVotes)> OnTeamSurrenderVotesUpdated; // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, const EHWVoteResult Result)> OnTeamSurrenderResolved; // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x60];                                     // 0x03D0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, int32 NumYesVotes, int32 NumNoVotes)> OnTeamPauseVotesUpdated; // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, const EHWVoteResult Result)> OnTeamPauseVoteResolved; // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x60];                                     // 0x0450(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWFountain*                            Fountain;                                          // 0x04B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x10];                                     // 0x04B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnGamePhaseEnded(const struct FGameplayTag& CurrentPhase);
	void MulticastBroadcastPauseVoteResolved(const EHWVoteResult Result);
	void MulticastBroadcastPauseVotesUpdated(int32 NumYesVotes, int32 NumNoVotes);
	void MulticastBroadcastSurrenderResolved(const EHWVoteResult Result);
	void MulticastBroadcastSurrenderVotesUpdated(int32 NumYesVotes, int32 NumNoVotes);
	void OnRep_NPCFactories();
	void OnRep_TeamID(const struct FGenericTeamId& OldTeamId);
	void OnRep_TeamMembers();
	void OnRep_TeamMinimap();
	void OnRep_TeamStatsTracker();
	void OnRep_TeamStructures();
	void OnTeamMemberCommittedAssist(const struct FAssistEventData& AssistEventData);
	void OnTeamMemberCommittedKill(const struct FDamageEventData& KillEventData);
	void OnTeamMemberDied(const struct FDamageEventData& DeathEventData);
	void SetGenericTeamId(const struct FGenericTeamId& NewTeamId);

	void GetAllCharacters(TArray<class AHWCharacter_Base*>* outCharacters) const;
	class AHWCharacter_Base* GetClosestMemberWithinRange(const struct FVector& SourceLocation, float Radius, const struct FGameplayTagContainer& tagsToIgnore) const;
	class AHWCharacter_Base* GetClosestTeamStructure(const struct FVector& QueryLocation, float* outDistance) const;
	struct FGenericTeamId GetGenericTeamId() const;
	int32 GetGodMemberAliveCount() const;
	float GetGodMemberAvgHealthPctWithinRange(const struct FVector& SourceLocation, const float Radius) const;
	int32 GetGodMemberCountThatAreFocusedOnTarget(const class AHWCharacter_Base* SourceCharacter, const class AHWCharacter_Base* TargetCharacter, bool bIncludeSource) const;
	int32 GetGodMemberCountWithinRange(const struct FVector& SourceLocation, float Radius) const;
	float GetGodMemberTotalHealthPctWithinRange(const struct FVector& SourceLocation, const float Radius) const;
	int32 GetMemberCountWithinRange(const struct FVector& SourceLocation, float Radius, const struct FGameplayTagContainer& tagsToIgnore) const;
	void GetMembersWithinRange(const struct FVector& SourceLocation, const float Radius, const struct FGameplayTagContainer& tagsToIgnore, TArray<class AHWCharacter_Base*>* outTargets) const;
	void GetMembersWithinRangeAndViewCone(const struct FVector& SourceLocation, const struct FRotator& SourceRotation, const float Radius, const float PerceptionConeAngle, const struct FGameplayTagContainer& tagsToIgnore, TArray<class AHWCharacter_Base*>* outTargets) const;
	int32 GetMinionAggroCount(const class AHWCharacter_Base* Target) const;
	TArray<class AHWBotFactory*> GetNPCFactories() const;
	class AHWBotFactory* GetNPCFactoryForLane(class FName LaneId) const;
	class AHWFountain* GetTeamFountain() const;
	TArray<class AHWPlayerState*> GetTeamMembers() const;
	class AHWTeamStatsTracker* GetTeamStatsTracker() const;
	int32 GetTeamStructureCountByTag(const struct FGameplayTag& Tag) const;
	TArray<class AHWBotFactory*> GetTeamStructures() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWTeamState">();
	}
	static class AHWTeamState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWTeamState>();
	}
};
static_assert(alignof(AHWTeamState) == 0x000008, "Wrong alignment on AHWTeamState");
static_assert(sizeof(AHWTeamState) == 0x0004C8, "Wrong size on AHWTeamState");
static_assert(offsetof(AHWTeamState, OnTeamMemberAdded) == 0x0002A0, "Member 'AHWTeamState::OnTeamMemberAdded' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamMemberRemoved) == 0x0002B0, "Member 'AHWTeamState::OnTeamMemberRemoved' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamMembersUpdated) == 0x0002C0, "Member 'AHWTeamState::OnTeamMembersUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamMemberCommittedKillDelegate) == 0x0002D0, "Member 'AHWTeamState::OnTeamMemberCommittedKillDelegate' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamMemberCommittedAssistDelegate) == 0x0002E0, "Member 'AHWTeamState::OnTeamMemberCommittedAssistDelegate' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamMemberDiedDelegate) == 0x0002F0, "Member 'AHWTeamState::OnTeamMemberDiedDelegate' has a wrong offset!");
static_assert(offsetof(AHWTeamState, TeamId) == 0x000300, "Member 'AHWTeamState::TeamId' has a wrong offset!");
static_assert(offsetof(AHWTeamState, TeamMembers) == 0x000308, "Member 'AHWTeamState::TeamMembers' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamStructuresUpdated) == 0x000320, "Member 'AHWTeamState::OnTeamStructuresUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamState, TeamStructures) == 0x000330, "Member 'AHWTeamState::TeamStructures' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnNPCFactoriesUpdated) == 0x000340, "Member 'AHWTeamState::OnNPCFactoriesUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamState, NPCFactories) == 0x000350, "Member 'AHWTeamState::NPCFactories' has a wrong offset!");
static_assert(offsetof(AHWTeamState, GodBotFactories) == 0x000360, "Member 'AHWTeamState::GodBotFactories' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamStatsTrackerReplicated) == 0x000370, "Member 'AHWTeamState::OnTeamStatsTrackerReplicated' has a wrong offset!");
static_assert(offsetof(AHWTeamState, TeamStatsTracker) == 0x000380, "Member 'AHWTeamState::TeamStatsTracker' has a wrong offset!");
static_assert(offsetof(AHWTeamState, TeamNPCMinimapState) == 0x0003A0, "Member 'AHWTeamState::TeamNPCMinimapState' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamSurrenderVotesUpdated) == 0x0003B0, "Member 'AHWTeamState::OnTeamSurrenderVotesUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamSurrenderResolved) == 0x0003C0, "Member 'AHWTeamState::OnTeamSurrenderResolved' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamPauseVotesUpdated) == 0x000430, "Member 'AHWTeamState::OnTeamPauseVotesUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamState, OnTeamPauseVoteResolved) == 0x000440, "Member 'AHWTeamState::OnTeamPauseVoteResolved' has a wrong offset!");
static_assert(offsetof(AHWTeamState, Fountain) == 0x0004B0, "Member 'AHWTeamState::Fountain' has a wrong offset!");

// Class Hemingway.HWBotArenaGoalOutro
// 0x0040 (0x0068 - 0x0028)
class UHWBotArenaGoalOutro : public UObject
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    OutroEffects;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         OutroTime;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKillBotOnFinished;                                // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DieCueOverride;                                    // 0x0040(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  Bot;                                               // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOutroTimerExpired();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBotArenaGoalOutro">();
	}
	static class UHWBotArenaGoalOutro* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBotArenaGoalOutro>();
	}
};
static_assert(alignof(UHWBotArenaGoalOutro) == 0x000008, "Wrong alignment on UHWBotArenaGoalOutro");
static_assert(sizeof(UHWBotArenaGoalOutro) == 0x000068, "Wrong size on UHWBotArenaGoalOutro");
static_assert(offsetof(UHWBotArenaGoalOutro, OutroEffects) == 0x000028, "Member 'UHWBotArenaGoalOutro::OutroEffects' has a wrong offset!");
static_assert(offsetof(UHWBotArenaGoalOutro, OutroTime) == 0x000038, "Member 'UHWBotArenaGoalOutro::OutroTime' has a wrong offset!");
static_assert(offsetof(UHWBotArenaGoalOutro, bKillBotOnFinished) == 0x00003C, "Member 'UHWBotArenaGoalOutro::bKillBotOnFinished' has a wrong offset!");
static_assert(offsetof(UHWBotArenaGoalOutro, DieCueOverride) == 0x000040, "Member 'UHWBotArenaGoalOutro::DieCueOverride' has a wrong offset!");
static_assert(offsetof(UHWBotArenaGoalOutro, Bot) == 0x000048, "Member 'UHWBotArenaGoalOutro::Bot' has a wrong offset!");

// Class Hemingway.HWGameMode_Conquest
// 0x0060 (0x0F20 - 0x0EC0)
class AHWGameMode_Conquest : public AHWGameMode
{
public:
	float                                         KillXpRewardBaseValue;                             // 0x0EC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillXpRewardLevelMultiplier;                       // 0x0EC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillXpRewardInferiorVictimReduction;               // 0x0EC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillXpRewardSuperiorVictimBonus;                   // 0x0ECC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillGoldRewardBaseValue;                           // 0x0ED0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillGoldRewardKillStreakMultiplier;                // 0x0ED4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillGoldRewardInferiorVictimReduction;             // 0x0ED8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillGoldRewardSuperiorVictimBonus;                 // 0x0EDC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillGoldRewardMinimum;                             // 0x0EE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillGoldRewardMaximum;                             // 0x0EE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KillGoldRewardFirstBloodBonus;                     // 0x0EE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerKillAssistPooledXpSharingPercent;            // 0x0EEC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerKillAssistPooledGoldSharingPercent;          // 0x0EF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAssistXpRewardMultiplier;                    // 0x0EF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerAssistGoldRewardMultiplier;                  // 0x0EF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NpcKillAssistPooledXpSharingPercent;               // 0x0EFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NpcAssistXpRewardMultiplier;                       // 0x0F00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NpcKillAssistPooledGoldSharingPercent;             // 0x0F04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NpcAssistGoldRewardMultiplier;                     // 0x0F08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastHitBonusGoldPercent;                           // 0x0F0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnDurationLevelMultiplier;                    // 0x0F10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnDurationMinimum;                            // 0x0F14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnDurationOvertimeThreshold;                  // 0x0F18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnDurationOvertimeConversionRate;             // 0x0F1C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameMode_Conquest">();
	}
	static class AHWGameMode_Conquest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameMode_Conquest>();
	}
};
static_assert(alignof(AHWGameMode_Conquest) == 0x000008, "Wrong alignment on AHWGameMode_Conquest");
static_assert(sizeof(AHWGameMode_Conquest) == 0x000F20, "Wrong size on AHWGameMode_Conquest");
static_assert(offsetof(AHWGameMode_Conquest, KillXpRewardBaseValue) == 0x000EC0, "Member 'AHWGameMode_Conquest::KillXpRewardBaseValue' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, KillXpRewardLevelMultiplier) == 0x000EC4, "Member 'AHWGameMode_Conquest::KillXpRewardLevelMultiplier' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, KillXpRewardInferiorVictimReduction) == 0x000EC8, "Member 'AHWGameMode_Conquest::KillXpRewardInferiorVictimReduction' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, KillXpRewardSuperiorVictimBonus) == 0x000ECC, "Member 'AHWGameMode_Conquest::KillXpRewardSuperiorVictimBonus' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, KillGoldRewardBaseValue) == 0x000ED0, "Member 'AHWGameMode_Conquest::KillGoldRewardBaseValue' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, KillGoldRewardKillStreakMultiplier) == 0x000ED4, "Member 'AHWGameMode_Conquest::KillGoldRewardKillStreakMultiplier' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, KillGoldRewardInferiorVictimReduction) == 0x000ED8, "Member 'AHWGameMode_Conquest::KillGoldRewardInferiorVictimReduction' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, KillGoldRewardSuperiorVictimBonus) == 0x000EDC, "Member 'AHWGameMode_Conquest::KillGoldRewardSuperiorVictimBonus' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, KillGoldRewardMinimum) == 0x000EE0, "Member 'AHWGameMode_Conquest::KillGoldRewardMinimum' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, KillGoldRewardMaximum) == 0x000EE4, "Member 'AHWGameMode_Conquest::KillGoldRewardMaximum' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, KillGoldRewardFirstBloodBonus) == 0x000EE8, "Member 'AHWGameMode_Conquest::KillGoldRewardFirstBloodBonus' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, PlayerKillAssistPooledXpSharingPercent) == 0x000EEC, "Member 'AHWGameMode_Conquest::PlayerKillAssistPooledXpSharingPercent' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, PlayerKillAssistPooledGoldSharingPercent) == 0x000EF0, "Member 'AHWGameMode_Conquest::PlayerKillAssistPooledGoldSharingPercent' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, PlayerAssistXpRewardMultiplier) == 0x000EF4, "Member 'AHWGameMode_Conquest::PlayerAssistXpRewardMultiplier' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, PlayerAssistGoldRewardMultiplier) == 0x000EF8, "Member 'AHWGameMode_Conquest::PlayerAssistGoldRewardMultiplier' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, NpcKillAssistPooledXpSharingPercent) == 0x000EFC, "Member 'AHWGameMode_Conquest::NpcKillAssistPooledXpSharingPercent' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, NpcAssistXpRewardMultiplier) == 0x000F00, "Member 'AHWGameMode_Conquest::NpcAssistXpRewardMultiplier' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, NpcKillAssistPooledGoldSharingPercent) == 0x000F04, "Member 'AHWGameMode_Conquest::NpcKillAssistPooledGoldSharingPercent' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, NpcAssistGoldRewardMultiplier) == 0x000F08, "Member 'AHWGameMode_Conquest::NpcAssistGoldRewardMultiplier' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, LastHitBonusGoldPercent) == 0x000F0C, "Member 'AHWGameMode_Conquest::LastHitBonusGoldPercent' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, RespawnDurationLevelMultiplier) == 0x000F10, "Member 'AHWGameMode_Conquest::RespawnDurationLevelMultiplier' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, RespawnDurationMinimum) == 0x000F14, "Member 'AHWGameMode_Conquest::RespawnDurationMinimum' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, RespawnDurationOvertimeThreshold) == 0x000F18, "Member 'AHWGameMode_Conquest::RespawnDurationOvertimeThreshold' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Conquest, RespawnDurationOvertimeConversionRate) == 0x000F1C, "Member 'AHWGameMode_Conquest::RespawnDurationOvertimeConversionRate' has a wrong offset!");

// Class Hemingway.HWGameMode_Arena
// 0x0110 (0x1030 - 0x0F20)
class AHWGameMode_Arena : public AHWGameMode_Conquest
{
public:
	TMulticastInlineDelegate<void(int32 TeamId)>  MinionsReachedGoal;                                // 0x0F20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         StartingTicketCount;                               // 0x0F30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KillsToSpawnSiegeMinion;                           // 0x0F34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinionTicketReward;                                // 0x0F38(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SiegeMinionTicketReward;                           // 0x0F3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GodKillTicketReward;                               // 0x0F40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxMinionAssistTime;                               // 0x0F44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumCatchupXPMembers;                               // 0x0F48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CatchupXPStartTime;                                // 0x0F4C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KillstreakNumForEffect;                            // 0x0F50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F54[0x4];                                      // 0x0F54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWBotArenaGoalOutro>       BotGoalOutroClass;                                 // 0x0F58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHWBotArenaGoalOutro*>           ActiveBotOutros;                                   // 0x0F60(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GodKillGameplayCues;                               // 0x0F70(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  MinionKillGameplayCues;                            // 0x0F90(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  MinionPortalScoreGameplayCues;                     // 0x0FB0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  MinotaurPortalScoreGameplayCues;                   // 0x0FD0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         EndPhaseTicketThreshold;                           // 0x0FF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumWaveRespawnTime;                            // 0x0FF4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseWaveRespawnTime;                               // 0x0FF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AddedDominatingRespawnTime;                        // 0x0FFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DominatingPointsRange;                             // 0x1000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinTicketCountForDominationFormula;                // 0x1004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHWAITugOfWarManager>       AITugOfWarManagerClass;                            // 0x1008(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWAITugOfWarManager*                   AITugOfWarManager;                                 // 0x1010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerKillVictimKillStreakGoldRewardModifier;      // 0x1018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerKillVictimDeathStreakGoldRewardModifier;     // 0x101C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerKillVictimKillStreakMaxCount;                // 0x1020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerKillVictimDeathStreakMaxCount;               // 0x1024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseXpPlayerKillReward;                            // 0x1028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         XpPerVictimPlayerLevelKillReward;                  // 0x102C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BotGoalReached(class AActor* Bot);
	void Defeat(const struct FGenericTeamId& Team);

	class AHWAITugOfWarManager* GetTugOfWarManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameMode_Arena">();
	}
	static class AHWGameMode_Arena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameMode_Arena>();
	}
};
static_assert(alignof(AHWGameMode_Arena) == 0x000008, "Wrong alignment on AHWGameMode_Arena");
static_assert(sizeof(AHWGameMode_Arena) == 0x001030, "Wrong size on AHWGameMode_Arena");
static_assert(offsetof(AHWGameMode_Arena, MinionsReachedGoal) == 0x000F20, "Member 'AHWGameMode_Arena::MinionsReachedGoal' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, StartingTicketCount) == 0x000F30, "Member 'AHWGameMode_Arena::StartingTicketCount' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, KillsToSpawnSiegeMinion) == 0x000F34, "Member 'AHWGameMode_Arena::KillsToSpawnSiegeMinion' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, MinionTicketReward) == 0x000F38, "Member 'AHWGameMode_Arena::MinionTicketReward' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, SiegeMinionTicketReward) == 0x000F3C, "Member 'AHWGameMode_Arena::SiegeMinionTicketReward' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, GodKillTicketReward) == 0x000F40, "Member 'AHWGameMode_Arena::GodKillTicketReward' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, MaxMinionAssistTime) == 0x000F44, "Member 'AHWGameMode_Arena::MaxMinionAssistTime' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, NumCatchupXPMembers) == 0x000F48, "Member 'AHWGameMode_Arena::NumCatchupXPMembers' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, CatchupXPStartTime) == 0x000F4C, "Member 'AHWGameMode_Arena::CatchupXPStartTime' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, KillstreakNumForEffect) == 0x000F50, "Member 'AHWGameMode_Arena::KillstreakNumForEffect' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, BotGoalOutroClass) == 0x000F58, "Member 'AHWGameMode_Arena::BotGoalOutroClass' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, ActiveBotOutros) == 0x000F60, "Member 'AHWGameMode_Arena::ActiveBotOutros' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, GodKillGameplayCues) == 0x000F70, "Member 'AHWGameMode_Arena::GodKillGameplayCues' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, MinionKillGameplayCues) == 0x000F90, "Member 'AHWGameMode_Arena::MinionKillGameplayCues' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, MinionPortalScoreGameplayCues) == 0x000FB0, "Member 'AHWGameMode_Arena::MinionPortalScoreGameplayCues' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, MinotaurPortalScoreGameplayCues) == 0x000FD0, "Member 'AHWGameMode_Arena::MinotaurPortalScoreGameplayCues' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, EndPhaseTicketThreshold) == 0x000FF0, "Member 'AHWGameMode_Arena::EndPhaseTicketThreshold' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, MinimumWaveRespawnTime) == 0x000FF4, "Member 'AHWGameMode_Arena::MinimumWaveRespawnTime' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, BaseWaveRespawnTime) == 0x000FF8, "Member 'AHWGameMode_Arena::BaseWaveRespawnTime' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, AddedDominatingRespawnTime) == 0x000FFC, "Member 'AHWGameMode_Arena::AddedDominatingRespawnTime' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, DominatingPointsRange) == 0x001000, "Member 'AHWGameMode_Arena::DominatingPointsRange' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, MinTicketCountForDominationFormula) == 0x001004, "Member 'AHWGameMode_Arena::MinTicketCountForDominationFormula' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, AITugOfWarManagerClass) == 0x001008, "Member 'AHWGameMode_Arena::AITugOfWarManagerClass' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, AITugOfWarManager) == 0x001010, "Member 'AHWGameMode_Arena::AITugOfWarManager' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, PlayerKillVictimKillStreakGoldRewardModifier) == 0x001018, "Member 'AHWGameMode_Arena::PlayerKillVictimKillStreakGoldRewardModifier' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, PlayerKillVictimDeathStreakGoldRewardModifier) == 0x00101C, "Member 'AHWGameMode_Arena::PlayerKillVictimDeathStreakGoldRewardModifier' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, PlayerKillVictimKillStreakMaxCount) == 0x001020, "Member 'AHWGameMode_Arena::PlayerKillVictimKillStreakMaxCount' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, PlayerKillVictimDeathStreakMaxCount) == 0x001024, "Member 'AHWGameMode_Arena::PlayerKillVictimDeathStreakMaxCount' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, BaseXpPlayerKillReward) == 0x001028, "Member 'AHWGameMode_Arena::BaseXpPlayerKillReward' has a wrong offset!");
static_assert(offsetof(AHWGameMode_Arena, XpPerVictimPlayerLevelKillReward) == 0x00102C, "Member 'AHWGameMode_Arena::XpPerVictimPlayerLevelKillReward' has a wrong offset!");

// Class Hemingway.HWCharacter_Aladdin
// 0x0010 (0x1450 - 0x1440)
class AHWCharacter_Aladdin final : public AHWCharacter_Smite_God
{
public:
	struct FHWAladdinWallRunVisualInfo            WallRunVisualInfo;                                 // 0x1440(0x0002)(BlueprintVisible, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1442[0xE];                                     // 0x1442(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_WallRunVisualInfo();
	void RegisterSelfWithArenaManager();
	void SetWallRunVisualInfo(const struct FHWAladdinWallRunVisualInfo& VisualInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Aladdin">();
	}
	static class AHWCharacter_Aladdin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Aladdin>();
	}
};
static_assert(alignof(AHWCharacter_Aladdin) == 0x000010, "Wrong alignment on AHWCharacter_Aladdin");
static_assert(sizeof(AHWCharacter_Aladdin) == 0x001450, "Wrong size on AHWCharacter_Aladdin");
static_assert(offsetof(AHWCharacter_Aladdin, WallRunVisualInfo) == 0x001440, "Member 'AHWCharacter_Aladdin::WallRunVisualInfo' has a wrong offset!");

// Class Hemingway.HWAttributeSet_Amaterasu
// 0x0018 (0x07C0 - 0x07A8)
class UHWAttributeSet_Amaterasu final : public UHWAttributeSet_God
{
public:
	struct FGameplayAttributeData                 StoredDamage;                                      // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         MirrorMaxGlowRadius;                               // 0x07B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MirrorGlowAmount;                                  // 0x07BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRep_StoredDamage(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Amaterasu">();
	}
	static class UHWAttributeSet_Amaterasu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Amaterasu>();
	}
};
static_assert(alignof(UHWAttributeSet_Amaterasu) == 0x000008, "Wrong alignment on UHWAttributeSet_Amaterasu");
static_assert(sizeof(UHWAttributeSet_Amaterasu) == 0x0007C0, "Wrong size on UHWAttributeSet_Amaterasu");
static_assert(offsetof(UHWAttributeSet_Amaterasu, StoredDamage) == 0x0007A8, "Member 'UHWAttributeSet_Amaterasu::StoredDamage' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Amaterasu, MirrorMaxGlowRadius) == 0x0007B8, "Member 'UHWAttributeSet_Amaterasu::MirrorMaxGlowRadius' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Amaterasu, MirrorGlowAmount) == 0x0007BC, "Member 'UHWAttributeSet_Amaterasu::MirrorGlowAmount' has a wrong offset!");

// Class Hemingway.HWAbility_Anhur_A02_Push
// 0x0000 (0x0A08 - 0x0A08)
class UHWAbility_Anhur_A02_Push final : public UHWAbility_Push
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Anhur_A02_Push">();
	}
	static class UHWAbility_Anhur_A02_Push* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Anhur_A02_Push>();
	}
};
static_assert(alignof(UHWAbility_Anhur_A02_Push) == 0x000008, "Wrong alignment on UHWAbility_Anhur_A02_Push");
static_assert(sizeof(UHWAbility_Anhur_A02_Push) == 0x000A08, "Wrong size on UHWAbility_Anhur_A02_Push");

// Class Hemingway.HWCharacter_Apollo
// 0x0020 (0x1460 - 0x1440)
class AHWCharacter_Apollo final : public AHWCharacter_Smite_God
{
public:
	TArray<struct FHWApolloA04HitchHikerInfo>     HitchHikers;                                       // 0x1440(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxHitchHikers;                                    // 0x1450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1454[0xC];                                     // 0x1454(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateHitchHikerVisuals(const struct FHWApolloA04HitchHikerInfo& HitchHikerInfo);
	void AddHitchHiker(const class AHWCharacter_Base* HitchHiker, class UHWAbilityTask_GameplayGrab* ChariotGrabTask);
	void DeactivateHitchHikerVisuals(const struct FHWApolloA04HitchHikerInfo& HitchHikerInfo);
	void OnRep_HitchHikers(const TArray<struct FHWApolloA04HitchHikerInfo>& PrevHitchHikers);
	struct FHWApolloA04HitchHikerInfo RemoveHitchHiker(const class AHWCharacter_Base* HitchHiker);

	int32 GetMaxHitchHikers() const;
	int32 GetNumOfActiveHitchHikers() const;
	bool HasAvailableHitchHikerSpot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Apollo">();
	}
	static class AHWCharacter_Apollo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Apollo>();
	}
};
static_assert(alignof(AHWCharacter_Apollo) == 0x000010, "Wrong alignment on AHWCharacter_Apollo");
static_assert(sizeof(AHWCharacter_Apollo) == 0x001460, "Wrong size on AHWCharacter_Apollo");
static_assert(offsetof(AHWCharacter_Apollo, HitchHikers) == 0x001440, "Member 'AHWCharacter_Apollo::HitchHikers' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Apollo, MaxHitchHikers) == 0x001450, "Member 'AHWCharacter_Apollo::MaxHitchHikers' has a wrong offset!");

// Class Hemingway.HWAbility_Awilix_B01
// 0x00B8 (0x0E40 - 0x0D88)
class UHWAbility_Awilix_B01 final : public UHWAbility_Leap
{
public:
	uint8                                         Pad_D88[0x78];                                     // 0x0D88(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CurrentlyActiveOffhands;                           // 0x0E00(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AbilitiesThatDoNotInterrupt;                       // 0x0E20(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnAnotherAbilityActivated(class UGameplayAbility* ActivatedAbility);
	void OnAnotherAbilityEnded(class UGameplayAbility* EndedAbility);
	void OnBlockingTagsUpdated(const struct FGameplayTag& Tag, int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Awilix_B01">();
	}
	static class UHWAbility_Awilix_B01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Awilix_B01>();
	}
};
static_assert(alignof(UHWAbility_Awilix_B01) == 0x000008, "Wrong alignment on UHWAbility_Awilix_B01");
static_assert(sizeof(UHWAbility_Awilix_B01) == 0x000E40, "Wrong size on UHWAbility_Awilix_B01");
static_assert(offsetof(UHWAbility_Awilix_B01, CurrentlyActiveOffhands) == 0x000E00, "Member 'UHWAbility_Awilix_B01::CurrentlyActiveOffhands' has a wrong offset!");
static_assert(offsetof(UHWAbility_Awilix_B01, AbilitiesThatDoNotInterrupt) == 0x000E20, "Member 'UHWAbility_Awilix_B01::AbilitiesThatDoNotInterrupt' has a wrong offset!");

// Class Hemingway.HWAttributeSet_Bacchus
// 0x0018 (0x07C0 - 0x07A8)
class UHWAttributeSet_Bacchus final : public UHWAttributeSet_God
{
public:
	struct FGameplayAttributeData                 Drunkenness;                                       // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         MaxDrunkenness;                                    // 0x07B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Drunkenness(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Bacchus">();
	}
	static class UHWAttributeSet_Bacchus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Bacchus>();
	}
};
static_assert(alignof(UHWAttributeSet_Bacchus) == 0x000008, "Wrong alignment on UHWAttributeSet_Bacchus");
static_assert(sizeof(UHWAttributeSet_Bacchus) == 0x0007C0, "Wrong size on UHWAttributeSet_Bacchus");
static_assert(offsetof(UHWAttributeSet_Bacchus, Drunkenness) == 0x0007A8, "Member 'UHWAttributeSet_Bacchus::Drunkenness' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Bacchus, MaxDrunkenness) == 0x0007B8, "Member 'UHWAttributeSet_Bacchus::MaxDrunkenness' has a wrong offset!");

// Class Hemingway.HWAttackSetting_Bari_Ricochet
// 0x0008 (0x0290 - 0x0288)
class UHWAttackSetting_Bari_Ricochet final : public UHWAbilityAttackSettings_Ricochet
{
public:
	int32                                         BellIndex;                                         // 0x0288(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttackSetting_Bari_Ricochet">();
	}
	static class UHWAttackSetting_Bari_Ricochet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttackSetting_Bari_Ricochet>();
	}
};
static_assert(alignof(UHWAttackSetting_Bari_Ricochet) == 0x000008, "Wrong alignment on UHWAttackSetting_Bari_Ricochet");
static_assert(sizeof(UHWAttackSetting_Bari_Ricochet) == 0x000290, "Wrong size on UHWAttackSetting_Bari_Ricochet");
static_assert(offsetof(UHWAttackSetting_Bari_Ricochet, BellIndex) == 0x000288, "Member 'UHWAttackSetting_Bari_Ricochet::BellIndex' has a wrong offset!");

// Class Hemingway.HWAttributeSet_Bari
// 0x0030 (0x07D8 - 0x07A8)
class UHWAttributeSet_Bari final : public UHWAttributeSet_God
{
public:
	struct FGameplayAttributeData                 Spirit;                                            // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpiritPerTime;                                     // 0x07B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxSpirit;                                         // 0x07C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_MaxSpirit(const struct FGameplayAttributeData& OldValue);
	void OnRep_Spirit(const struct FGameplayAttributeData& OldValue);
	void OnRep_SpiritPerTime(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Bari">();
	}
	static class UHWAttributeSet_Bari* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Bari>();
	}
};
static_assert(alignof(UHWAttributeSet_Bari) == 0x000008, "Wrong alignment on UHWAttributeSet_Bari");
static_assert(sizeof(UHWAttributeSet_Bari) == 0x0007D8, "Wrong size on UHWAttributeSet_Bari");
static_assert(offsetof(UHWAttributeSet_Bari, Spirit) == 0x0007A8, "Member 'UHWAttributeSet_Bari::Spirit' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Bari, SpiritPerTime) == 0x0007B8, "Member 'UHWAttributeSet_Bari::SpiritPerTime' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Bari, MaxSpirit) == 0x0007C8, "Member 'UHWAttributeSet_Bari::MaxSpirit' has a wrong offset!");

// Class Hemingway.HWDeployable_Bari_A01
// 0x0058 (0x0520 - 0x04C8)
class AHWDeployable_Bari_A01 final : public AHWDeployable
{
public:
	class USphereComponent*                       BellCollision;                                     // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWBariBellState                              BellState;                                         // 0x04D0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWDeployableMovementComponent*         MovementComponent;                                 // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWBariBellPushInfo                    PushInfo;                                          // 0x04E0(0x0018)(BlueprintVisible, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxDistance;                                       // 0x04F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           RollingCollisionAttackTag;                         // 0x04FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnhanced;                                       // 0x0504(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_505[0x3];                                      // 0x0505(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnhancedCollisionRadius;                           // 0x0508(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWBariBellRecallInfo                  BellRecallInfo;                                    // 0x0510(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_BellState(const EHWBariBellState OldBellState);
	void OnRep_IsEnhanced();
	void OnRep_PushInfo();
	void PushBell();
	void RecallToBari(const struct FHWBariBellRecallInfo& recallInfo);
	void SetBellState(const EHWBariBellState State);
	void SetIsEnhanced(const bool bEnableEnhancement);

	float GetEnhancedCollisionRadius() const;
	struct FVector GetRecallLocation(const struct FVector& RecallOrigin) const;
	struct FVector GetRecallVelocity() const;
	bool IsEnhanced() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Bari_A01">();
	}
	static class AHWDeployable_Bari_A01* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Bari_A01>();
	}
};
static_assert(alignof(AHWDeployable_Bari_A01) == 0x000008, "Wrong alignment on AHWDeployable_Bari_A01");
static_assert(sizeof(AHWDeployable_Bari_A01) == 0x000520, "Wrong size on AHWDeployable_Bari_A01");
static_assert(offsetof(AHWDeployable_Bari_A01, BellCollision) == 0x0004C8, "Member 'AHWDeployable_Bari_A01::BellCollision' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Bari_A01, BellState) == 0x0004D0, "Member 'AHWDeployable_Bari_A01::BellState' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Bari_A01, MovementComponent) == 0x0004D8, "Member 'AHWDeployable_Bari_A01::MovementComponent' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Bari_A01, PushInfo) == 0x0004E0, "Member 'AHWDeployable_Bari_A01::PushInfo' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Bari_A01, MaxDistance) == 0x0004F8, "Member 'AHWDeployable_Bari_A01::MaxDistance' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Bari_A01, RollingCollisionAttackTag) == 0x0004FC, "Member 'AHWDeployable_Bari_A01::RollingCollisionAttackTag' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Bari_A01, bIsEnhanced) == 0x000504, "Member 'AHWDeployable_Bari_A01::bIsEnhanced' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Bari_A01, EnhancedCollisionRadius) == 0x000508, "Member 'AHWDeployable_Bari_A01::EnhancedCollisionRadius' has a wrong offset!");
static_assert(offsetof(AHWDeployable_Bari_A01, BellRecallInfo) == 0x000510, "Member 'AHWDeployable_Bari_A01::BellRecallInfo' has a wrong offset!");

// Class Hemingway.HWDeployable_Cabrakan_A04
// 0x0000 (0x0548 - 0x0548)
class AHWDeployable_Cabrakan_A04 final : public AHWDeployable_Wall
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Cabrakan_A04">();
	}
	static class AHWDeployable_Cabrakan_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Cabrakan_A04>();
	}
};
static_assert(alignof(AHWDeployable_Cabrakan_A04) == 0x000008, "Wrong alignment on AHWDeployable_Cabrakan_A04");
static_assert(sizeof(AHWDeployable_Cabrakan_A04) == 0x000548, "Wrong size on AHWDeployable_Cabrakan_A04");

// Class Hemingway.HWAttributeSet_Danzaburou
// 0x0010 (0x07B8 - 0x07A8)
class UHWAttributeSet_Danzaburou final : public UHWAttributeSet_God
{
public:
	struct FGameplayAttributeData                 CloneSpawnChance;                                  // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_CloneSpawnChance(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Danzaburou">();
	}
	static class UHWAttributeSet_Danzaburou* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Danzaburou>();
	}
};
static_assert(alignof(UHWAttributeSet_Danzaburou) == 0x000008, "Wrong alignment on UHWAttributeSet_Danzaburou");
static_assert(sizeof(UHWAttributeSet_Danzaburou) == 0x0007B8, "Wrong size on UHWAttributeSet_Danzaburou");
static_assert(offsetof(UHWAttributeSet_Danzaburou, CloneSpawnChance) == 0x0007A8, "Member 'UHWAttributeSet_Danzaburou::CloneSpawnChance' has a wrong offset!");

// Class Hemingway.HWCharacter_Danzaburou
// 0x0220 (0x1660 - 0x1440)
class AHWCharacter_Danzaburou final : public AHWCharacter_Smite_God
{
public:
	bool                                          bIsInLeafForm;                                     // 0x1440(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1441[0x7];                                     // 0x1441(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AHWSkeletalMeshActor>       LeafMeshClass;                                     // 0x1448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWSkeletalMeshActor_Danzaburou_Decoy*  LeafMeshActor;                                     // 0x1450(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInRocketForm;                                   // 0x1458(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1459[0x7];                                     // 0x1459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AHWSkeletalMeshActor>       RocketMeshClass;                                   // 0x1460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWSkeletalMeshActor*                   RocketMeshActor;                                   // 0x1468(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHWGameplayTargetDataFilter_Stealth    A04VisibilityFilter;                               // 0x1470(0x01E8)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UVisibilityData*                        VisibilityDataToHideDanza;                         // 0x1658(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActivateLeafFormVisuals();
	void ActivateRocketFormVisuals();
	void DeactivateLeafFormVisuals();
	void DeactivateRocketFormVisuals();
	void OnRep_IsInLeafForm();
	void OnRep_IsInRocketForm();
	void SetLeafFormEnabled(const bool bEnable);
	void SetRocketFormEnabled(const bool bEnable);

	bool IsInLeafForm() const;
	bool IsInRocketForm() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_Danzaburou">();
	}
	static class AHWCharacter_Danzaburou* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_Danzaburou>();
	}
};
static_assert(alignof(AHWCharacter_Danzaburou) == 0x000010, "Wrong alignment on AHWCharacter_Danzaburou");
static_assert(sizeof(AHWCharacter_Danzaburou) == 0x001660, "Wrong size on AHWCharacter_Danzaburou");
static_assert(offsetof(AHWCharacter_Danzaburou, bIsInLeafForm) == 0x001440, "Member 'AHWCharacter_Danzaburou::bIsInLeafForm' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Danzaburou, LeafMeshClass) == 0x001448, "Member 'AHWCharacter_Danzaburou::LeafMeshClass' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Danzaburou, LeafMeshActor) == 0x001450, "Member 'AHWCharacter_Danzaburou::LeafMeshActor' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Danzaburou, bIsInRocketForm) == 0x001458, "Member 'AHWCharacter_Danzaburou::bIsInRocketForm' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Danzaburou, RocketMeshClass) == 0x001460, "Member 'AHWCharacter_Danzaburou::RocketMeshClass' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Danzaburou, RocketMeshActor) == 0x001468, "Member 'AHWCharacter_Danzaburou::RocketMeshActor' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Danzaburou, A04VisibilityFilter) == 0x001470, "Member 'AHWCharacter_Danzaburou::A04VisibilityFilter' has a wrong offset!");
static_assert(offsetof(AHWCharacter_Danzaburou, VisibilityDataToHideDanza) == 0x001658, "Member 'AHWCharacter_Danzaburou::VisibilityDataToHideDanza' has a wrong offset!");

// Class Hemingway.HWSkeletalMeshActor_Danzaburou_Decoy
// 0x0018 (0x0348 - 0x0330)
class AHWSkeletalMeshActor_Danzaburou_Decoy final : public AHWSkeletalMeshActor
{
public:
	bool                                          bIsDanzaburou;                                     // 0x0330(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x3];                                      // 0x0331(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialAngle;                                      // 0x0334(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDecoySpeed;                                     // 0x0338(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketToFollowForHeightMovement;                   // 0x033C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLeafActivated();
	bool ShouldUpdateVelocity();
	void UpdateVelocity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkeletalMeshActor_Danzaburou_Decoy">();
	}
	static class AHWSkeletalMeshActor_Danzaburou_Decoy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWSkeletalMeshActor_Danzaburou_Decoy>();
	}
};
static_assert(alignof(AHWSkeletalMeshActor_Danzaburou_Decoy) == 0x000008, "Wrong alignment on AHWSkeletalMeshActor_Danzaburou_Decoy");
static_assert(sizeof(AHWSkeletalMeshActor_Danzaburou_Decoy) == 0x000348, "Wrong size on AHWSkeletalMeshActor_Danzaburou_Decoy");
static_assert(offsetof(AHWSkeletalMeshActor_Danzaburou_Decoy, bIsDanzaburou) == 0x000330, "Member 'AHWSkeletalMeshActor_Danzaburou_Decoy::bIsDanzaburou' has a wrong offset!");
static_assert(offsetof(AHWSkeletalMeshActor_Danzaburou_Decoy, InitialAngle) == 0x000334, "Member 'AHWSkeletalMeshActor_Danzaburou_Decoy::InitialAngle' has a wrong offset!");
static_assert(offsetof(AHWSkeletalMeshActor_Danzaburou_Decoy, MinDecoySpeed) == 0x000338, "Member 'AHWSkeletalMeshActor_Danzaburou_Decoy::MinDecoySpeed' has a wrong offset!");
static_assert(offsetof(AHWSkeletalMeshActor_Danzaburou_Decoy, SocketToFollowForHeightMovement) == 0x00033C, "Member 'AHWSkeletalMeshActor_Danzaburou_Decoy::SocketToFollowForHeightMovement' has a wrong offset!");

// Class Hemingway.HWAbility_Hades_A03
// 0x0000 (0x0D60 - 0x0D60)
class UHWAbility_Hades_A03 final : public UHWGameplayAbility_Enhanced
{
public:
	struct FGameplayAbilityTargetDataHandle CreateAimDataAtCharacterLocation(class AHWCharacter_Base* Character);
	struct FGameplayAbilityTargetDataHandle GetBlightedEnemiesAtDetonate(const struct FGameplayAbilityTargetDataHandle& DetonateTargetData, const float DetonateRadius);
	void GetCascadedBlightedEnemies(TArray<class AActor*>* OutBlightedEnemies, const float HadesDetonateRadius, const float EnemyDetonateRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Hades_A03">();
	}
	static class UHWAbility_Hades_A03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Hades_A03>();
	}
};
static_assert(alignof(UHWAbility_Hades_A03) == 0x000008, "Wrong alignment on UHWAbility_Hades_A03");
static_assert(sizeof(UHWAbility_Hades_A03) == 0x000D60, "Wrong size on UHWAbility_Hades_A03");

// Class Hemingway.HWAbility_Hecate_PSV
// 0x00A8 (0x0E08 - 0x0D60)
class UHWAbility_Hecate_PSV final : public UHWGameplayAbility_Enhanced
{
public:
	TMap<TWeakObjectPtr<class AActor>, class AHWInteractable_Hecate_PSV*> ActiveInteractables;       // 0x0D60(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AHWInteractable_Hecate_PSV> HecateInteractableClass;                           // 0x0DB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWCharacter_NPC>        CurrentActiveStructureEnchantment;                 // 0x0DB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AHWBotFactory>>   TrackedStructureFactories;                         // 0x0DC0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            StructureBuffEffectClass;                          // 0x0DD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            StructureBuffEffectHandle;                         // 0x0DD8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHWCharacter_Base>       CurrentActivePlayerEnchantment;                    // 0x0DE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            PlayerBuffEffectClass;                             // 0x0DE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            SelfBuffEffectClass;                               // 0x0DF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            PlayerBuffEffectHandle;                            // 0x0DF8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            SelfBuffEffectHandle;                              // 0x0E00(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAllyCommittedKill(class AHWTeamState* Team, class AHWPlayerState* Player, const struct FDamageEventData& KillEventData);
	void OnAllyInteracted(class AHWCharacter_Base* PlayerCharacter);
	void OnHecateTeamUpdated(class AHWCharacterAbilitySystemActor* AbilitySystemActor, class AHWTeamState* NewTeamState);
	void OnNewStructureSpawned(class AHWBotFactory* factory, class AHWCharacter_Base* spawnedStructure);
	void OnStructureDied(class AHWBotFactory* BotFactory, class AHWCharacter_Base* Structure, class AActor* Killer);
	void OnStructureInteracted(class AHWCharacter_NPC* Structure, class AHWInteractable_Hecate_PSV* Interactable);
	void OnTeamStructuresUpdated(class AHWTeamState* TeamState);
	void RemoveTrackedStructure(class AHWCharacter_Base* Structure);
	void RemoveTrackedStructures();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Hecate_PSV">();
	}
	static class UHWAbility_Hecate_PSV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Hecate_PSV>();
	}
};
static_assert(alignof(UHWAbility_Hecate_PSV) == 0x000008, "Wrong alignment on UHWAbility_Hecate_PSV");
static_assert(sizeof(UHWAbility_Hecate_PSV) == 0x000E08, "Wrong size on UHWAbility_Hecate_PSV");
static_assert(offsetof(UHWAbility_Hecate_PSV, ActiveInteractables) == 0x000D60, "Member 'UHWAbility_Hecate_PSV::ActiveInteractables' has a wrong offset!");
static_assert(offsetof(UHWAbility_Hecate_PSV, HecateInteractableClass) == 0x000DB0, "Member 'UHWAbility_Hecate_PSV::HecateInteractableClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_Hecate_PSV, CurrentActiveStructureEnchantment) == 0x000DB8, "Member 'UHWAbility_Hecate_PSV::CurrentActiveStructureEnchantment' has a wrong offset!");
static_assert(offsetof(UHWAbility_Hecate_PSV, TrackedStructureFactories) == 0x000DC0, "Member 'UHWAbility_Hecate_PSV::TrackedStructureFactories' has a wrong offset!");
static_assert(offsetof(UHWAbility_Hecate_PSV, StructureBuffEffectClass) == 0x000DD0, "Member 'UHWAbility_Hecate_PSV::StructureBuffEffectClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_Hecate_PSV, StructureBuffEffectHandle) == 0x000DD8, "Member 'UHWAbility_Hecate_PSV::StructureBuffEffectHandle' has a wrong offset!");
static_assert(offsetof(UHWAbility_Hecate_PSV, CurrentActivePlayerEnchantment) == 0x000DE0, "Member 'UHWAbility_Hecate_PSV::CurrentActivePlayerEnchantment' has a wrong offset!");
static_assert(offsetof(UHWAbility_Hecate_PSV, PlayerBuffEffectClass) == 0x000DE8, "Member 'UHWAbility_Hecate_PSV::PlayerBuffEffectClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_Hecate_PSV, SelfBuffEffectClass) == 0x000DF0, "Member 'UHWAbility_Hecate_PSV::SelfBuffEffectClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_Hecate_PSV, PlayerBuffEffectHandle) == 0x000DF8, "Member 'UHWAbility_Hecate_PSV::PlayerBuffEffectHandle' has a wrong offset!");
static_assert(offsetof(UHWAbility_Hecate_PSV, SelfBuffEffectHandle) == 0x000E00, "Member 'UHWAbility_Hecate_PSV::SelfBuffEffectHandle' has a wrong offset!");

// Class Hemingway.HWGameplayAbility_HunBatz_Psv
// 0x00B0 (0x0E20 - 0x0D70)
class UHWGameplayAbility_HunBatz_Psv final : public UHWAbility_Passive
{
public:
	struct FGameplayTagContainer                  ValidAbilityTypes;                                 // 0x0D70(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayEffect>          BuffIconGameplayEffect;                            // 0x0D90(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D98[0x8];                                      // 0x0D98(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETriggerSourceType                            TriggerSource;                                     // 0x0DA0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA1[0x7F];                                     // 0x0DA1(0x007F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttemptToBeginConsume(const struct FGameplayTagContainer& EffectTags, const struct FDamageCalcInfo& DamageCalcInfo, const bool bDamageImmune);
	void AttemptToEndConsume(const struct FHitResult& HitResult, const struct FDamageEventData& DamageEventData);
	void OnAbilityCommited(class UGameplayAbility* Ability);
	void OnAvatarDeath(const struct FDamageEventData& DeathEventData);
	void OnConsumeStack();

	bool ValidTriggerSource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayAbility_HunBatz_Psv">();
	}
	static class UHWGameplayAbility_HunBatz_Psv* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayAbility_HunBatz_Psv>();
	}
};
static_assert(alignof(UHWGameplayAbility_HunBatz_Psv) == 0x000008, "Wrong alignment on UHWGameplayAbility_HunBatz_Psv");
static_assert(sizeof(UHWGameplayAbility_HunBatz_Psv) == 0x000E20, "Wrong size on UHWGameplayAbility_HunBatz_Psv");
static_assert(offsetof(UHWGameplayAbility_HunBatz_Psv, ValidAbilityTypes) == 0x000D70, "Member 'UHWGameplayAbility_HunBatz_Psv::ValidAbilityTypes' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_HunBatz_Psv, BuffIconGameplayEffect) == 0x000D90, "Member 'UHWGameplayAbility_HunBatz_Psv::BuffIconGameplayEffect' has a wrong offset!");
static_assert(offsetof(UHWGameplayAbility_HunBatz_Psv, TriggerSource) == 0x000DA0, "Member 'UHWGameplayAbility_HunBatz_Psv::TriggerSource' has a wrong offset!");

// Class Hemingway.HWAbility_Izanami_Passive
// 0x0028 (0x0D98 - 0x0D70)
class UHWAbility_Izanami_Passive final : public UHWAbility_Passive
{
public:
	TArray<struct FIzanamiPassiveTrackedDamageInstance> RecentDamageInstancesPriorityQueue;          // 0x0D70(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           StackRecalculationTimer;                           // 0x0D80(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentStacksBasedOnRecentDamage;                  // 0x0D88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentStacksBasedOnHealth;                        // 0x0D8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxStackCount;                                     // 0x0D90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageInstanceTrackingLifetime;                    // 0x0D94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyNewEffectStackCount();
	int32 CalculateDeservedStackCountBasedOnCurrentHealth();
	int32 CalculateDeservedStackCountBasedOnRecentDamage(const float TotalRecentDamage);
	void OnDamageReceived(const struct FDamageEventData& DamageEventData);
	void UpdateStackCountFromCurrentHealth();
	void UpdateStackCountFromRecentDamage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Izanami_Passive">();
	}
	static class UHWAbility_Izanami_Passive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Izanami_Passive>();
	}
};
static_assert(alignof(UHWAbility_Izanami_Passive) == 0x000008, "Wrong alignment on UHWAbility_Izanami_Passive");
static_assert(sizeof(UHWAbility_Izanami_Passive) == 0x000D98, "Wrong size on UHWAbility_Izanami_Passive");
static_assert(offsetof(UHWAbility_Izanami_Passive, RecentDamageInstancesPriorityQueue) == 0x000D70, "Member 'UHWAbility_Izanami_Passive::RecentDamageInstancesPriorityQueue' has a wrong offset!");
static_assert(offsetof(UHWAbility_Izanami_Passive, StackRecalculationTimer) == 0x000D80, "Member 'UHWAbility_Izanami_Passive::StackRecalculationTimer' has a wrong offset!");
static_assert(offsetof(UHWAbility_Izanami_Passive, CurrentStacksBasedOnRecentDamage) == 0x000D88, "Member 'UHWAbility_Izanami_Passive::CurrentStacksBasedOnRecentDamage' has a wrong offset!");
static_assert(offsetof(UHWAbility_Izanami_Passive, CurrentStacksBasedOnHealth) == 0x000D8C, "Member 'UHWAbility_Izanami_Passive::CurrentStacksBasedOnHealth' has a wrong offset!");
static_assert(offsetof(UHWAbility_Izanami_Passive, MaxStackCount) == 0x000D90, "Member 'UHWAbility_Izanami_Passive::MaxStackCount' has a wrong offset!");
static_assert(offsetof(UHWAbility_Izanami_Passive, DamageInstanceTrackingLifetime) == 0x000D94, "Member 'UHWAbility_Izanami_Passive::DamageInstanceTrackingLifetime' has a wrong offset!");

// Class Hemingway.HWGameplayAbility_JingWei_A03
// 0x0000 (0x0D60 - 0x0D60)
class UHWGameplayAbility_JingWei_A03 final : public UHWGameplayAbility_Enhanced
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayAbility_JingWei_A03">();
	}
	static class UHWGameplayAbility_JingWei_A03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayAbility_JingWei_A03>();
	}
};
static_assert(alignof(UHWGameplayAbility_JingWei_A03) == 0x000008, "Wrong alignment on UHWGameplayAbility_JingWei_A03");
static_assert(sizeof(UHWGameplayAbility_JingWei_A03) == 0x000D60, "Wrong size on UHWGameplayAbility_JingWei_A03");

// Class Hemingway.HWGameplayDash_JingWei_A03
// 0x0008 (0x07F8 - 0x07F0)
class UHWGameplayDash_JingWei_A03 final : public UHWGameplayDash
{
public:
	float                                         TimeInAir;                                         // 0x07F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameplayDash_JingWei_A03">();
	}
	static class UHWGameplayDash_JingWei_A03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameplayDash_JingWei_A03>();
	}
};
static_assert(alignof(UHWGameplayDash_JingWei_A03) == 0x000008, "Wrong alignment on UHWGameplayDash_JingWei_A03");
static_assert(sizeof(UHWGameplayDash_JingWei_A03) == 0x0007F8, "Wrong size on UHWGameplayDash_JingWei_A03");
static_assert(offsetof(UHWGameplayDash_JingWei_A03, TimeInAir) == 0x0007F0, "Member 'UHWGameplayDash_JingWei_A03::TimeInAir' has a wrong offset!");

// Class Hemingway.HWAbilityAimSetting_Kali_A02
// 0x0010 (0x0090 - 0x0080)
class UHWAbilityAimSetting_Kali_A02 final : public UHWAbilityAimSettings_GroundTarget
{
public:
	int32                                         KaliA02ProjectileIndex;                            // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileSpeed;                                   // 0x0084(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeflectionAmount;                                  // 0x0088(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartSpacing;                                      // 0x008C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSetting_Kali_A02">();
	}
	static class UHWAbilityAimSetting_Kali_A02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSetting_Kali_A02>();
	}
};
static_assert(alignof(UHWAbilityAimSetting_Kali_A02) == 0x000008, "Wrong alignment on UHWAbilityAimSetting_Kali_A02");
static_assert(sizeof(UHWAbilityAimSetting_Kali_A02) == 0x000090, "Wrong size on UHWAbilityAimSetting_Kali_A02");
static_assert(offsetof(UHWAbilityAimSetting_Kali_A02, KaliA02ProjectileIndex) == 0x000080, "Member 'UHWAbilityAimSetting_Kali_A02::KaliA02ProjectileIndex' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSetting_Kali_A02, ProjectileSpeed) == 0x000084, "Member 'UHWAbilityAimSetting_Kali_A02::ProjectileSpeed' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSetting_Kali_A02, DeflectionAmount) == 0x000088, "Member 'UHWAbilityAimSetting_Kali_A02::DeflectionAmount' has a wrong offset!");
static_assert(offsetof(UHWAbilityAimSetting_Kali_A02, StartSpacing) == 0x00008C, "Member 'UHWAbilityAimSetting_Kali_A02::StartSpacing' has a wrong offset!");

// Class Hemingway.HWProjectile_Kali_A02
// 0x0000 (0x0690 - 0x0690)
class AHWProjectile_Kali_A02 final : public AHWProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWProjectile_Kali_A02">();
	}
	static class AHWProjectile_Kali_A02* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWProjectile_Kali_A02>();
	}
};
static_assert(alignof(AHWProjectile_Kali_A02) == 0x000010, "Wrong alignment on AHWProjectile_Kali_A02");
static_assert(sizeof(AHWProjectile_Kali_A02) == 0x000690, "Wrong size on AHWProjectile_Kali_A02");

// Class Hemingway.HWAttributeSet_Mordred
// 0x0028 (0x07D0 - 0x07A8)
class UHWAttributeSet_Mordred final : public UHWAttributeSet_God
{
public:
	struct FGameplayAttributeData                 Wrath;                                             // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WrathPerTime;                                      // 0x07B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         MaxWrath;                                          // 0x07C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7CC[0x4];                                      // 0x07CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Wrath(const struct FGameplayAttributeData& OldValue);
	void OnRep_WrathPerTime(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Mordred">();
	}
	static class UHWAttributeSet_Mordred* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Mordred>();
	}
};
static_assert(alignof(UHWAttributeSet_Mordred) == 0x000008, "Wrong alignment on UHWAttributeSet_Mordred");
static_assert(sizeof(UHWAttributeSet_Mordred) == 0x0007D0, "Wrong size on UHWAttributeSet_Mordred");
static_assert(offsetof(UHWAttributeSet_Mordred, Wrath) == 0x0007A8, "Member 'UHWAttributeSet_Mordred::Wrath' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Mordred, WrathPerTime) == 0x0007B8, "Member 'UHWAttributeSet_Mordred::WrathPerTime' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Mordred, MaxWrath) == 0x0007C8, "Member 'UHWAttributeSet_Mordred::MaxWrath' has a wrong offset!");

// Class Hemingway.HWAbilityAimSetting_Morrigan_A04
// 0x0000 (0x0068 - 0x0068)
class UHWAbilityAimSetting_Morrigan_A04 final : public UHWAbilityAimSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityAimSetting_Morrigan_A04">();
	}
	static class UHWAbilityAimSetting_Morrigan_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityAimSetting_Morrigan_A04>();
	}
};
static_assert(alignof(UHWAbilityAimSetting_Morrigan_A04) == 0x000008, "Wrong alignment on UHWAbilityAimSetting_Morrigan_A04");
static_assert(sizeof(UHWAbilityAimSetting_Morrigan_A04) == 0x000068, "Wrong size on UHWAbilityAimSetting_Morrigan_A04");

// Class Hemingway.HWAbility_Morrigan_Item_Changeling
// 0x0038 (0x0D98 - 0x0D60)
class UHWAbility_Morrigan_Item_Changeling final : public UHWGameplayAbility_Enhanced
{
public:
	TMulticastInlineDelegate<void()>              OnChangelingTargetDataUpdated;                     // 0x0D60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D70[0x28];                                     // 0x0D70(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class UHWCharacterItem* GetChangelingTargetCharacterItem() const;
	bool HasValidChangelingTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Morrigan_Item_Changeling">();
	}
	static class UHWAbility_Morrigan_Item_Changeling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Morrigan_Item_Changeling>();
	}
};
static_assert(alignof(UHWAbility_Morrigan_Item_Changeling) == 0x000008, "Wrong alignment on UHWAbility_Morrigan_Item_Changeling");
static_assert(sizeof(UHWAbility_Morrigan_Item_Changeling) == 0x000D98, "Wrong size on UHWAbility_Morrigan_Item_Changeling");
static_assert(offsetof(UHWAbility_Morrigan_Item_Changeling, OnChangelingTargetDataUpdated) == 0x000D60, "Member 'UHWAbility_Morrigan_Item_Changeling::OnChangelingTargetDataUpdated' has a wrong offset!");

// Class Hemingway.HWAbility_Mulan_A03_GrappleListener
// 0x0178 (0x0ED8 - 0x0D60)
class UHWAbility_Mulan_A03_GrappleListener final : public UHWGameplayAbility_Enhanced
{
public:
	struct FGameplayTagContainer                  TagsToBlockMulanFromGrappling;                     // 0x0D60(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWGameplayTween>           MulanGrappleTween;                                 // 0x0D80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMulanGrappling;                                 // 0x0D88(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D89[0x7];                                      // 0x0D89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWMulanGrappleInfo                    CurrentGrappleInfo;                                // 0x0D90(0x00F8)(BlueprintVisible, Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           GrappleTimerHandle;                                // 0x0E88(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityTask_GameplayTween*           MulanGrappleTweenTask;                             // 0x0E90(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterGrappleDelayTime;                         // 0x0E98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SeperationDistance;                                // 0x0E9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GodGrappleTime;                                    // 0x0EA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA4[0x4];                                      // 0x0EA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWGameplayTween>           CharacterGrappleTween;                             // 0x0EA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWAbilityTask_GameplayTween*           GrappleTargetTweenTask;                            // 0x0EB0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldApplyGrappleEndHit;                         // 0x0EB8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EB9[0x3];                                      // 0x0EB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallTravelPercent;                                 // 0x0EBC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallTweenSpeed;                                    // 0x0EC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinWallGrappleDistance;                            // 0x0EC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLongWallGrapple;                                // 0x0EC8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC9[0x3];                                      // 0x0EC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LongWallAnimDistanceThreshold;                     // 0x0ECC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   GrappleMontageSectionName;                         // 0x0ED0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClearGrapple();
	void OnGrappleEnded();
	void OnGrappleTargetTweenEnded(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* GrappleTarget, const EHWEndTweenReason EndTweenReason);
	void OnGrappleTargetTweenStarted(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* GrappleTarget);
	void OnMulanGrappleTweenEnded(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* Mulan, const EHWEndTweenReason EndTweenReason);
	void OnMulanGrappleTweenStarted(class UHWGameplayTween* TweenInstance, class AHWCharacter_Base* Mulan);
	void StartCharacterGrapple();
	void StartWallGrapple();

	float CalcGrappleDistance(const class AHWCharacter_Base* Mulan, const struct FHWMulanGrappleInfo& GrappleInfo) const;
	bool CanGrappleToTarget(const struct FHWMulanGrappleInfo& Info) const;
	bool CanMulanGrapple() const;
	bool FindValidGrappleLoc(const class AHWCharacter_Base* TweenCharacter, const struct FVector& StartLoc, const struct FVector& InitialEndLoc, const struct FVector& TweenDirection, const float Range, const bool bIsWallGrapple, struct FVector* OutValidLocation) const;
	bool IsMulanGrappling() const;
	bool IsValidGrappleWall(const class AActor* HitActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Mulan_A03_GrappleListener">();
	}
	static class UHWAbility_Mulan_A03_GrappleListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Mulan_A03_GrappleListener>();
	}
};
static_assert(alignof(UHWAbility_Mulan_A03_GrappleListener) == 0x000008, "Wrong alignment on UHWAbility_Mulan_A03_GrappleListener");
static_assert(sizeof(UHWAbility_Mulan_A03_GrappleListener) == 0x000ED8, "Wrong size on UHWAbility_Mulan_A03_GrappleListener");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, TagsToBlockMulanFromGrappling) == 0x000D60, "Member 'UHWAbility_Mulan_A03_GrappleListener::TagsToBlockMulanFromGrappling' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, MulanGrappleTween) == 0x000D80, "Member 'UHWAbility_Mulan_A03_GrappleListener::MulanGrappleTween' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, bIsMulanGrappling) == 0x000D88, "Member 'UHWAbility_Mulan_A03_GrappleListener::bIsMulanGrappling' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, CurrentGrappleInfo) == 0x000D90, "Member 'UHWAbility_Mulan_A03_GrappleListener::CurrentGrappleInfo' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, GrappleTimerHandle) == 0x000E88, "Member 'UHWAbility_Mulan_A03_GrappleListener::GrappleTimerHandle' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, MulanGrappleTweenTask) == 0x000E90, "Member 'UHWAbility_Mulan_A03_GrappleListener::MulanGrappleTweenTask' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, CharacterGrappleDelayTime) == 0x000E98, "Member 'UHWAbility_Mulan_A03_GrappleListener::CharacterGrappleDelayTime' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, SeperationDistance) == 0x000E9C, "Member 'UHWAbility_Mulan_A03_GrappleListener::SeperationDistance' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, GodGrappleTime) == 0x000EA0, "Member 'UHWAbility_Mulan_A03_GrappleListener::GodGrappleTime' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, CharacterGrappleTween) == 0x000EA8, "Member 'UHWAbility_Mulan_A03_GrappleListener::CharacterGrappleTween' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, GrappleTargetTweenTask) == 0x000EB0, "Member 'UHWAbility_Mulan_A03_GrappleListener::GrappleTargetTweenTask' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, bShouldApplyGrappleEndHit) == 0x000EB8, "Member 'UHWAbility_Mulan_A03_GrappleListener::bShouldApplyGrappleEndHit' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, WallTravelPercent) == 0x000EBC, "Member 'UHWAbility_Mulan_A03_GrappleListener::WallTravelPercent' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, WallTweenSpeed) == 0x000EC0, "Member 'UHWAbility_Mulan_A03_GrappleListener::WallTweenSpeed' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, MinWallGrappleDistance) == 0x000EC4, "Member 'UHWAbility_Mulan_A03_GrappleListener::MinWallGrappleDistance' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, bIsLongWallGrapple) == 0x000EC8, "Member 'UHWAbility_Mulan_A03_GrappleListener::bIsLongWallGrapple' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, LongWallAnimDistanceThreshold) == 0x000ECC, "Member 'UHWAbility_Mulan_A03_GrappleListener::LongWallAnimDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UHWAbility_Mulan_A03_GrappleListener, GrappleMontageSectionName) == 0x000ED0, "Member 'UHWAbility_Mulan_A03_GrappleListener::GrappleMontageSectionName' has a wrong offset!");

// Class Hemingway.HWEquipmentComponent_Mulan_Evolution
// 0x0020 (0x0058 - 0x0038)
class UHWEquipmentComponent_Mulan_Evolution final : public UHWEquipmentComponent
{
public:
	TMulticastInlineDelegate<void(class UHWEquipmentComponent_Mulan_Evolution* EvolutionComponent)> OnEvolutionXPChangedDelegate; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EHWMulanEvolutionState                        CurrentEvolution;                                  // 0x0048(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentEvolutionXP;                                // 0x004C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            Evolution3StatsEffectHandle;                       // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyEvolutionStatusEffect();
	void Devolve();
	void Evolve();
	void OnDealtDamaged(const struct FDamageEventData& DamageEventData);
	void OnRep_CurrentEvolutionXP();
	void SetEvolution(const EHWMulanEvolutionState Evolution);

	float GetCurrentEvolutionXP() const;
	EHWMulanEvolutionState GetEvolutionState() const;
	float GetEvolutionXPThreshold(const EHWMulanEvolutionState EvolveState) const;
	float GetXPNeededForNextEvolutionThreshold() const;
	bool IsInEvolution(const EHWMulanEvolutionState Evolution) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentComponent_Mulan_Evolution">();
	}
	static class UHWEquipmentComponent_Mulan_Evolution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentComponent_Mulan_Evolution>();
	}
};
static_assert(alignof(UHWEquipmentComponent_Mulan_Evolution) == 0x000008, "Wrong alignment on UHWEquipmentComponent_Mulan_Evolution");
static_assert(sizeof(UHWEquipmentComponent_Mulan_Evolution) == 0x000058, "Wrong size on UHWEquipmentComponent_Mulan_Evolution");
static_assert(offsetof(UHWEquipmentComponent_Mulan_Evolution, OnEvolutionXPChangedDelegate) == 0x000038, "Member 'UHWEquipmentComponent_Mulan_Evolution::OnEvolutionXPChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Mulan_Evolution, CurrentEvolution) == 0x000048, "Member 'UHWEquipmentComponent_Mulan_Evolution::CurrentEvolution' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Mulan_Evolution, CurrentEvolutionXP) == 0x00004C, "Member 'UHWEquipmentComponent_Mulan_Evolution::CurrentEvolutionXP' has a wrong offset!");
static_assert(offsetof(UHWEquipmentComponent_Mulan_Evolution, Evolution3StatsEffectHandle) == 0x000050, "Member 'UHWEquipmentComponent_Mulan_Evolution::Evolution3StatsEffectHandle' has a wrong offset!");

// Class Hemingway.HWAbility_Neith_A03
// 0x0000 (0x0D60 - 0x0D60)
class UHWAbility_Neith_A03 final : public UHWGameplayAbility_Enhanced
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Neith_A03">();
	}
	static class UHWAbility_Neith_A03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Neith_A03>();
	}
};
static_assert(alignof(UHWAbility_Neith_A03) == 0x000008, "Wrong alignment on UHWAbility_Neith_A03");
static_assert(sizeof(UHWAbility_Neith_A03) == 0x000D60, "Wrong size on UHWAbility_Neith_A03");

// Class Hemingway.HWProjectile_Neith_A01
// 0x0010 (0x06A0 - 0x0690)
class AHWProjectile_Neith_A01 final : public AHWProjectile
{
public:
	uint8                                         Pad_690[0x10];                                     // 0x0690(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWProjectile_Neith_A01">();
	}
	static class AHWProjectile_Neith_A01* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWProjectile_Neith_A01>();
	}
};
static_assert(alignof(AHWProjectile_Neith_A01) == 0x000010, "Wrong alignment on AHWProjectile_Neith_A01");
static_assert(sizeof(AHWProjectile_Neith_A01) == 0x0006A0, "Wrong size on AHWProjectile_Neith_A01");

// Class Hemingway.HWReticle_Neith_A04
// 0x0000 (0x0430 - 0x0430)
class AHWReticle_Neith_A04 final : public AHWReticle_LockOn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWReticle_Neith_A04">();
	}
	static class AHWReticle_Neith_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWReticle_Neith_A04>();
	}
};
static_assert(alignof(AHWReticle_Neith_A04) == 0x000008, "Wrong alignment on AHWReticle_Neith_A04");
static_assert(sizeof(AHWReticle_Neith_A04) == 0x000430, "Wrong size on AHWReticle_Neith_A04");

// Class Hemingway.HWReticle_Neith_Weave
// 0x0018 (0x0430 - 0x0418)
class AHWReticle_Neith_Weave final : public AHWReticle
{
public:
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWDeployable_Neith_Weave*>      TargetingNeithWeaveDeployables;                    // 0x0420(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWReticle_Neith_Weave">();
	}
	static class AHWReticle_Neith_Weave* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWReticle_Neith_Weave>();
	}
};
static_assert(alignof(AHWReticle_Neith_Weave) == 0x000008, "Wrong alignment on AHWReticle_Neith_Weave");
static_assert(sizeof(AHWReticle_Neith_Weave) == 0x000430, "Wrong size on AHWReticle_Neith_Weave");
static_assert(offsetof(AHWReticle_Neith_Weave, TargetingNeithWeaveDeployables) == 0x000420, "Member 'AHWReticle_Neith_Weave::TargetingNeithWeaveDeployables' has a wrong offset!");

// Class Hemingway.HWAbility_NuWa_A03
// 0x0000 (0x0D60 - 0x0D60)
class UHWAbility_NuWa_A03 final : public UHWGameplayAbility_Enhanced
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_NuWa_A03">();
	}
	static class UHWAbility_NuWa_A03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_NuWa_A03>();
	}
};
static_assert(alignof(UHWAbility_NuWa_A03) == 0x000008, "Wrong alignment on UHWAbility_NuWa_A03");
static_assert(sizeof(UHWAbility_NuWa_A03) == 0x000D60, "Wrong size on UHWAbility_NuWa_A03");

// Class Hemingway.HWCharacter_NuWa_ClaySoldier
// 0x0000 (0x13F0 - 0x13F0)
class AHWCharacter_NuWa_ClaySoldier final : public AHWCharacter_NPC
{
public:
	void ActivateLocalTargetingVFX(const bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_NuWa_ClaySoldier">();
	}
	static class AHWCharacter_NuWa_ClaySoldier* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_NuWa_ClaySoldier>();
	}
};
static_assert(alignof(AHWCharacter_NuWa_ClaySoldier) == 0x000010, "Wrong alignment on AHWCharacter_NuWa_ClaySoldier");
static_assert(sizeof(AHWCharacter_NuWa_ClaySoldier) == 0x0013F0, "Wrong size on AHWCharacter_NuWa_ClaySoldier");

// Class Hemingway.HWReticle_NuWa_A03
// 0x0018 (0x0430 - 0x0418)
class AHWReticle_NuWa_A03 final : public AHWReticle
{
public:
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWCharacter_NuWa_ClaySoldier*>  TargetingNuWaClaySoldiers;                         // 0x0420(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWReticle_NuWa_A03">();
	}
	static class AHWReticle_NuWa_A03* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWReticle_NuWa_A03>();
	}
};
static_assert(alignof(AHWReticle_NuWa_A03) == 0x000008, "Wrong alignment on AHWReticle_NuWa_A03");
static_assert(sizeof(AHWReticle_NuWa_A03) == 0x000430, "Wrong size on AHWReticle_NuWa_A03");
static_assert(offsetof(AHWReticle_NuWa_A03, TargetingNuWaClaySoldiers) == 0x000420, "Member 'AHWReticle_NuWa_A03::TargetingNuWaClaySoldiers' has a wrong offset!");

// Class Hemingway.HWDeployable_Pele_A02
// 0x0008 (0x04D0 - 0x04C8)
class AHWDeployable_Pele_A02 final : public AHWDeployable
{
public:
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeployable_Pele_A02">();
	}
	static class AHWDeployable_Pele_A02* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWDeployable_Pele_A02>();
	}
};
static_assert(alignof(AHWDeployable_Pele_A02) == 0x000008, "Wrong alignment on AHWDeployable_Pele_A02");
static_assert(sizeof(AHWDeployable_Pele_A02) == 0x0004D0, "Wrong size on AHWDeployable_Pele_A02");

// Class Hemingway.HWAbility_Sol_A02
// 0x0010 (0x0D70 - 0x0D60)
class UHWAbility_Sol_A02 final : public UHWGameplayAbility_Enhanced
{
public:
	bool                                          bInhandSwappedSuccessfully;                        // 0x0D60(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D61[0x7];                                      // 0x0D61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWEquipmentItem*                       A02Inhand;                                         // 0x0D68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Sol_A02">();
	}
	static class UHWAbility_Sol_A02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Sol_A02>();
	}
};
static_assert(alignof(UHWAbility_Sol_A02) == 0x000008, "Wrong alignment on UHWAbility_Sol_A02");
static_assert(sizeof(UHWAbility_Sol_A02) == 0x000D70, "Wrong size on UHWAbility_Sol_A02");
static_assert(offsetof(UHWAbility_Sol_A02, bInhandSwappedSuccessfully) == 0x000D60, "Member 'UHWAbility_Sol_A02::bInhandSwappedSuccessfully' has a wrong offset!");
static_assert(offsetof(UHWAbility_Sol_A02, A02Inhand) == 0x000D68, "Member 'UHWAbility_Sol_A02::A02Inhand' has a wrong offset!");

// Class Hemingway.HWAbility_Sol_A04
// 0x0038 (0x0D98 - 0x0D60)
class UHWAbility_Sol_A04 final : public UHWGameplayAbility_Enhanced
{
public:
	int32                                         TotalRefireAmount;                                 // 0x0D60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RefireCount;                                       // 0x0D64(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeployableAttackRefirePeriod;                      // 0x0D68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D6C[0xC];                                      // 0x0D6C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerDeployableAttackTargeterDistance;           // 0x0D78(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargeterMovementDistanceSinceLastFire;             // 0x0D7C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastDeployableLocation;                            // 0x0D80(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Sol_A04">();
	}
	static class UHWAbility_Sol_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Sol_A04>();
	}
};
static_assert(alignof(UHWAbility_Sol_A04) == 0x000008, "Wrong alignment on UHWAbility_Sol_A04");
static_assert(sizeof(UHWAbility_Sol_A04) == 0x000D98, "Wrong size on UHWAbility_Sol_A04");
static_assert(offsetof(UHWAbility_Sol_A04, TotalRefireAmount) == 0x000D60, "Member 'UHWAbility_Sol_A04::TotalRefireAmount' has a wrong offset!");
static_assert(offsetof(UHWAbility_Sol_A04, RefireCount) == 0x000D64, "Member 'UHWAbility_Sol_A04::RefireCount' has a wrong offset!");
static_assert(offsetof(UHWAbility_Sol_A04, DeployableAttackRefirePeriod) == 0x000D68, "Member 'UHWAbility_Sol_A04::DeployableAttackRefirePeriod' has a wrong offset!");
static_assert(offsetof(UHWAbility_Sol_A04, TriggerDeployableAttackTargeterDistance) == 0x000D78, "Member 'UHWAbility_Sol_A04::TriggerDeployableAttackTargeterDistance' has a wrong offset!");
static_assert(offsetof(UHWAbility_Sol_A04, TargeterMovementDistanceSinceLastFire) == 0x000D7C, "Member 'UHWAbility_Sol_A04::TargeterMovementDistanceSinceLastFire' has a wrong offset!");
static_assert(offsetof(UHWAbility_Sol_A04, LastDeployableLocation) == 0x000D80, "Member 'UHWAbility_Sol_A04::LastDeployableLocation' has a wrong offset!");

// Class Hemingway.HWAttributeSet_Sol
// 0x0018 (0x07C0 - 0x07A8)
class UHWAttributeSet_Sol final : public UHWAttributeSet_God
{
public:
	struct FGameplayAttributeData                 Heat;                                              // 0x07A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         MaxHeat;                                           // 0x07B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Heat(const struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAttributeSet_Sol">();
	}
	static class UHWAttributeSet_Sol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAttributeSet_Sol>();
	}
};
static_assert(alignof(UHWAttributeSet_Sol) == 0x000008, "Wrong alignment on UHWAttributeSet_Sol");
static_assert(sizeof(UHWAttributeSet_Sol) == 0x0007C0, "Wrong size on UHWAttributeSet_Sol");
static_assert(offsetof(UHWAttributeSet_Sol, Heat) == 0x0007A8, "Member 'UHWAttributeSet_Sol::Heat' has a wrong offset!");
static_assert(offsetof(UHWAttributeSet_Sol, MaxHeat) == 0x0007B8, "Member 'UHWAttributeSet_Sol::MaxHeat' has a wrong offset!");

// Class Hemingway.HWTargeter_Sol_A04
// 0x0020 (0x0670 - 0x0650)
class AHWTargeter_Sol_A04 final : public AHWTargeter
{
public:
	TWeakObjectPtr<class UHWAbility_Sol_A04>      OwningSolA04Ability;                               // 0x0648(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_650[0x20];                                     // 0x0650(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWTargeter_Sol_A04">();
	}
	static class AHWTargeter_Sol_A04* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWTargeter_Sol_A04>();
	}
};
static_assert(alignof(AHWTargeter_Sol_A04) == 0x000010, "Wrong alignment on AHWTargeter_Sol_A04");
static_assert(sizeof(AHWTargeter_Sol_A04) == 0x000670, "Wrong size on AHWTargeter_Sol_A04");
static_assert(offsetof(AHWTargeter_Sol_A04, OwningSolA04Ability) == 0x000648, "Member 'AHWTargeter_Sol_A04::OwningSolA04Ability' has a wrong offset!");

// Class Hemingway.HWAbilityTask_Thantos_A02_MarkedMovementSpeed
// 0x0018 (0x0098 - 0x0080)
class UHWAbilityTask_Thantos_A02_MarkedMovementSpeed final : public UAbilityTask
{
public:
	class UHWAbility_Thanatos_A02_MarkedMovementSpeed* owningThanatosA02;                            // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AHWTeamState*>                   OpposingTeams;                                     // 0x0088(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UHWAbilityTask_Thantos_A02_MarkedMovementSpeed* MarkedMovementSpeedTask(class UGameplayAbility* OwningAbility, class FName TaskInstanceName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbilityTask_Thantos_A02_MarkedMovementSpeed">();
	}
	static class UHWAbilityTask_Thantos_A02_MarkedMovementSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbilityTask_Thantos_A02_MarkedMovementSpeed>();
	}
};
static_assert(alignof(UHWAbilityTask_Thantos_A02_MarkedMovementSpeed) == 0x000008, "Wrong alignment on UHWAbilityTask_Thantos_A02_MarkedMovementSpeed");
static_assert(sizeof(UHWAbilityTask_Thantos_A02_MarkedMovementSpeed) == 0x000098, "Wrong size on UHWAbilityTask_Thantos_A02_MarkedMovementSpeed");
static_assert(offsetof(UHWAbilityTask_Thantos_A02_MarkedMovementSpeed, owningThanatosA02) == 0x000080, "Member 'UHWAbilityTask_Thantos_A02_MarkedMovementSpeed::owningThanatosA02' has a wrong offset!");
static_assert(offsetof(UHWAbilityTask_Thantos_A02_MarkedMovementSpeed, OpposingTeams) == 0x000088, "Member 'UHWAbilityTask_Thantos_A02_MarkedMovementSpeed::OpposingTeams' has a wrong offset!");

// Class Hemingway.HWAbility_Thanatos_A02_MarkedMovementSpeed
// 0x0040 (0x0DB0 - 0x0D70)
class UHWAbility_Thanatos_A02_MarkedMovementSpeed final : public UHWAbility_Passive
{
public:
	TWeakObjectPtr<class UHWEquipmentInstance>    ThanatosUltimateEquipmentInstance;                 // 0x0D70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWGameplayEffect_Execute>  ThanatosExecuteEffectClass;                        // 0x0D78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHWCharacter_Smite_God*>         LowHealthList;                                     // 0x0D80(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         DefaultExecuteThreshold;                           // 0x0D90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultMovespeedBonus;                             // 0x0D94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveTable*                            ThanatosUltimateCurveTable;                        // 0x0D98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveTable*                            ThanatosA02CurveTable;                             // 0x0DA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumAdditionalMoveSpeedPct;                     // 0x0DA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumFrontAngleDeg;                              // 0x0DAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetExecuteThresholdByAbilityLevel(const int32 AbilityLevel) const;
	float GetMoveSpeedBonusByAbilityLevel(const int32 AbilityLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAbility_Thanatos_A02_MarkedMovementSpeed">();
	}
	static class UHWAbility_Thanatos_A02_MarkedMovementSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAbility_Thanatos_A02_MarkedMovementSpeed>();
	}
};
static_assert(alignof(UHWAbility_Thanatos_A02_MarkedMovementSpeed) == 0x000008, "Wrong alignment on UHWAbility_Thanatos_A02_MarkedMovementSpeed");
static_assert(sizeof(UHWAbility_Thanatos_A02_MarkedMovementSpeed) == 0x000DB0, "Wrong size on UHWAbility_Thanatos_A02_MarkedMovementSpeed");
static_assert(offsetof(UHWAbility_Thanatos_A02_MarkedMovementSpeed, ThanatosUltimateEquipmentInstance) == 0x000D70, "Member 'UHWAbility_Thanatos_A02_MarkedMovementSpeed::ThanatosUltimateEquipmentInstance' has a wrong offset!");
static_assert(offsetof(UHWAbility_Thanatos_A02_MarkedMovementSpeed, ThanatosExecuteEffectClass) == 0x000D78, "Member 'UHWAbility_Thanatos_A02_MarkedMovementSpeed::ThanatosExecuteEffectClass' has a wrong offset!");
static_assert(offsetof(UHWAbility_Thanatos_A02_MarkedMovementSpeed, LowHealthList) == 0x000D80, "Member 'UHWAbility_Thanatos_A02_MarkedMovementSpeed::LowHealthList' has a wrong offset!");
static_assert(offsetof(UHWAbility_Thanatos_A02_MarkedMovementSpeed, DefaultExecuteThreshold) == 0x000D90, "Member 'UHWAbility_Thanatos_A02_MarkedMovementSpeed::DefaultExecuteThreshold' has a wrong offset!");
static_assert(offsetof(UHWAbility_Thanatos_A02_MarkedMovementSpeed, DefaultMovespeedBonus) == 0x000D94, "Member 'UHWAbility_Thanatos_A02_MarkedMovementSpeed::DefaultMovespeedBonus' has a wrong offset!");
static_assert(offsetof(UHWAbility_Thanatos_A02_MarkedMovementSpeed, ThanatosUltimateCurveTable) == 0x000D98, "Member 'UHWAbility_Thanatos_A02_MarkedMovementSpeed::ThanatosUltimateCurveTable' has a wrong offset!");
static_assert(offsetof(UHWAbility_Thanatos_A02_MarkedMovementSpeed, ThanatosA02CurveTable) == 0x000DA0, "Member 'UHWAbility_Thanatos_A02_MarkedMovementSpeed::ThanatosA02CurveTable' has a wrong offset!");
static_assert(offsetof(UHWAbility_Thanatos_A02_MarkedMovementSpeed, MaximumAdditionalMoveSpeedPct) == 0x000DA8, "Member 'UHWAbility_Thanatos_A02_MarkedMovementSpeed::MaximumAdditionalMoveSpeedPct' has a wrong offset!");
static_assert(offsetof(UHWAbility_Thanatos_A02_MarkedMovementSpeed, MinimumFrontAngleDeg) == 0x000DAC, "Member 'UHWAbility_Thanatos_A02_MarkedMovementSpeed::MinimumFrontAngleDeg' has a wrong offset!");

// Class Hemingway.HWCharacter_NPC_Vulcan_InfernoCannon
// 0x0010 (0x1410 - 0x1400)
class AHWCharacter_NPC_Vulcan_InfernoCannon final : public AHWCharacter_NPC_Structure_WithBeam
{
public:
	TWeakObjectPtr<class AActor>                  CurrentTarget;                                     // 0x1400(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1408[0x8];                                     // 0x1408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCharacter_NPC_Vulcan_InfernoCannon">();
	}
	static class AHWCharacter_NPC_Vulcan_InfernoCannon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWCharacter_NPC_Vulcan_InfernoCannon>();
	}
};
static_assert(alignof(AHWCharacter_NPC_Vulcan_InfernoCannon) == 0x000010, "Wrong alignment on AHWCharacter_NPC_Vulcan_InfernoCannon");
static_assert(sizeof(AHWCharacter_NPC_Vulcan_InfernoCannon) == 0x001410, "Wrong size on AHWCharacter_NPC_Vulcan_InfernoCannon");
static_assert(offsetof(AHWCharacter_NPC_Vulcan_InfernoCannon, CurrentTarget) == 0x001400, "Member 'AHWCharacter_NPC_Vulcan_InfernoCannon::CurrentTarget' has a wrong offset!");

// Class Hemingway.HWProjectile_Vulcan_A02_Thumper
// 0x0010 (0x06A0 - 0x0690)
class AHWProjectile_Vulcan_A02_Thumper final : public AHWProjectile
{
public:
	class UHWFamiliarConfigSettings*              ThumperConfig;                                     // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_698[0x8];                                      // 0x0698(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWProjectile_Vulcan_A02_Thumper">();
	}
	static class AHWProjectile_Vulcan_A02_Thumper* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWProjectile_Vulcan_A02_Thumper>();
	}
};
static_assert(alignof(AHWProjectile_Vulcan_A02_Thumper) == 0x000010, "Wrong alignment on AHWProjectile_Vulcan_A02_Thumper");
static_assert(sizeof(AHWProjectile_Vulcan_A02_Thumper) == 0x0006A0, "Wrong size on AHWProjectile_Vulcan_A02_Thumper");
static_assert(offsetof(AHWProjectile_Vulcan_A02_Thumper, ThumperConfig) == 0x000690, "Member 'AHWProjectile_Vulcan_A02_Thumper::ThumperConfig' has a wrong offset!");

// Class Hemingway.HWLibrary_Animation
// 0x0000 (0x0028 - 0x0028)
class UHWLibrary_Animation final : public UBlueprintFunctionLibrary
{
public:
	static struct FBoxSphereBounds CalculateBoundsSkelMesh(class USkeletalMeshComponent* SkeletalMeshComponent);
	static void CalculateGodActorBounds(class AActor* Actor, struct FVector* Origin, struct FVector* BoxExtent);
	static struct FVector CalculateLocationBetweenActorsWithOffset(class AActor* FiringActor, class AActor* TargetActor, float NormalOffset, float ZOffset);
	static class UAnimMontage* ModifyMontageBlendSettings(class UAnimMontage* OriginalMontage, const struct FMontageBlendSettings& BlendInSettings, const struct FMontageBlendSettings& BlendOutSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLibrary_Animation">();
	}
	static class UHWLibrary_Animation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLibrary_Animation>();
	}
};
static_assert(alignof(UHWLibrary_Animation) == 0x000008, "Wrong alignment on UHWLibrary_Animation");
static_assert(sizeof(UHWLibrary_Animation) == 0x000028, "Wrong size on UHWLibrary_Animation");

// Class Hemingway.HWTagManager
// 0x0148 (0x0170 - 0x0028)
class UHWTagManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              AbilityTypeBlockCancelAbilityTableSoftPtr;         // 0x0038(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             AbilityTypeBlockCancelAbilityTable;                // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              TagTriggerBlockCancelAbilityTableSoftPtr;          // 0x0068(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TagTriggerBlockCancelAbilityTable;                 // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   TriggerTags;                                       // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              InventorySlotConfigTableSoftPtr;                   // 0x00A8(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FGameplayTagContainer> SlotConfigMap;                           // 0x00D0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              StealthRevealRulesTableSoftPtr;                    // 0x0120(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             StealthRevealRulesTable;                           // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  RevealRuleTriggerTags;                             // 0x0150(0x0020)(Protected, NativeAccessSpecifierProtected)

public:
	void GetActivatedRevealRulesForTags(const struct FGameplayTagContainer& ApplicableRevealRuleTags, const struct FGameplayTagContainer& TagTriggers, const class AActor* SelfActor, const class AActor* ObservingActor, struct FGameplayTagContainer* OutActivatedRevealRuleTags) const;
	void GetActivationBlockedTagsBasedOnAbilityTypes(const struct FGameplayTagContainer& AbilityTypeTags, struct FGameplayTagContainer* OutActivationBlockedTags) const;
	void GetAllowedEquipmentForSlot(const struct FGameplayTag& SlotType, struct FGameplayTagContainer* OutAllowEquipmentTypes) const;
	void GetAllowedSlotsForEquipmentType(const struct FGameplayTag& EquipmentType, struct FGameplayTagContainer* OutAllowSlotTypes) const;
	const struct FGameplayTagContainer GetAllRevealRuleTriggerTags() const;
	const TArray<struct FGameplayTag> GetAllTriggerTags() const;
	void GetBlockTagsBasedOnAbilityTypes(const struct FGameplayTagContainer& AbilityTypeTags, struct FGameplayTagContainer* OutBlockTags, class UHWAbilitySystemComponent* OwningAbilitySystem) const;
	void GetBlockTagsBasedOnTriggerTags(const struct FGameplayTagContainer& TagTriggers, struct FGameplayTagContainer* OutBlockTags) const;
	void GetCancelTagsBasedOnAbilityTypes(const struct FGameplayTagContainer& AbilityTypeTags, struct FGameplayTagContainer* OutCancelTags) const;
	void GetCancelTagsBasedOnTriggerTags(const struct FGameplayTagContainer& TagTriggers, struct FHWAbilityCancelTagRequirement* OutCancelTags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWTagManager">();
	}
	static class UHWTagManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWTagManager>();
	}
};
static_assert(alignof(UHWTagManager) == 0x000008, "Wrong alignment on UHWTagManager");
static_assert(sizeof(UHWTagManager) == 0x000170, "Wrong size on UHWTagManager");
static_assert(offsetof(UHWTagManager, AbilityTypeBlockCancelAbilityTableSoftPtr) == 0x000038, "Member 'UHWTagManager::AbilityTypeBlockCancelAbilityTableSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWTagManager, AbilityTypeBlockCancelAbilityTable) == 0x000060, "Member 'UHWTagManager::AbilityTypeBlockCancelAbilityTable' has a wrong offset!");
static_assert(offsetof(UHWTagManager, TagTriggerBlockCancelAbilityTableSoftPtr) == 0x000068, "Member 'UHWTagManager::TagTriggerBlockCancelAbilityTableSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWTagManager, TagTriggerBlockCancelAbilityTable) == 0x000090, "Member 'UHWTagManager::TagTriggerBlockCancelAbilityTable' has a wrong offset!");
static_assert(offsetof(UHWTagManager, TriggerTags) == 0x000098, "Member 'UHWTagManager::TriggerTags' has a wrong offset!");
static_assert(offsetof(UHWTagManager, InventorySlotConfigTableSoftPtr) == 0x0000A8, "Member 'UHWTagManager::InventorySlotConfigTableSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWTagManager, SlotConfigMap) == 0x0000D0, "Member 'UHWTagManager::SlotConfigMap' has a wrong offset!");
static_assert(offsetof(UHWTagManager, StealthRevealRulesTableSoftPtr) == 0x000120, "Member 'UHWTagManager::StealthRevealRulesTableSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWTagManager, StealthRevealRulesTable) == 0x000148, "Member 'UHWTagManager::StealthRevealRulesTable' has a wrong offset!");
static_assert(offsetof(UHWTagManager, RevealRuleTriggerTags) == 0x000150, "Member 'UHWTagManager::RevealRuleTriggerTags' has a wrong offset!");

// Class Hemingway.HWCameraMod_Blendable
// 0x0000 (0x0048 - 0x0048)
class UHWCameraMod_Blendable final : public UCameraModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCameraMod_Blendable">();
	}
	static class UHWCameraMod_Blendable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCameraMod_Blendable>();
	}
};
static_assert(alignof(UHWCameraMod_Blendable) == 0x000008, "Wrong alignment on UHWCameraMod_Blendable");
static_assert(sizeof(UHWCameraMod_Blendable) == 0x000048, "Wrong size on UHWCameraMod_Blendable");

// Class Hemingway.HWPlayerMappableKeySettings
// 0x0040 (0x00C8 - 0x0088)
class UHWPlayerMappableKeySettings final : public UPlayerMappableKeySettings
{
public:
	uint8                                         Pad_88[0x1];                                       // 0x0088(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         AffectedBySettings;                                // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         AllowedRebinds;                                    // 0x008A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsesKeyConsumptionRules;                          // 0x008B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWPlayerMappableKeySettings*>   SubKeySettings;                                    // 0x0090(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UInputModifier*>                 ModifiersToAppend;                                 // 0x00A0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UInputTrigger*>                  TriggersToAppend;                                  // 0x00B0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	EHWInputTriggerKeyConsumePolicy               KeyConsumePolicy;                                  // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTriggerOnlyOnce;                                  // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerMappableKeySettings">();
	}
	static class UHWPlayerMappableKeySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPlayerMappableKeySettings>();
	}
};
static_assert(alignof(UHWPlayerMappableKeySettings) == 0x000008, "Wrong alignment on UHWPlayerMappableKeySettings");
static_assert(sizeof(UHWPlayerMappableKeySettings) == 0x0000C8, "Wrong size on UHWPlayerMappableKeySettings");
static_assert(offsetof(UHWPlayerMappableKeySettings, AffectedBySettings) == 0x000089, "Member 'UHWPlayerMappableKeySettings::AffectedBySettings' has a wrong offset!");
static_assert(offsetof(UHWPlayerMappableKeySettings, AllowedRebinds) == 0x00008A, "Member 'UHWPlayerMappableKeySettings::AllowedRebinds' has a wrong offset!");
static_assert(offsetof(UHWPlayerMappableKeySettings, bUsesKeyConsumptionRules) == 0x00008B, "Member 'UHWPlayerMappableKeySettings::bUsesKeyConsumptionRules' has a wrong offset!");
static_assert(offsetof(UHWPlayerMappableKeySettings, SubKeySettings) == 0x000090, "Member 'UHWPlayerMappableKeySettings::SubKeySettings' has a wrong offset!");
static_assert(offsetof(UHWPlayerMappableKeySettings, ModifiersToAppend) == 0x0000A0, "Member 'UHWPlayerMappableKeySettings::ModifiersToAppend' has a wrong offset!");
static_assert(offsetof(UHWPlayerMappableKeySettings, TriggersToAppend) == 0x0000B0, "Member 'UHWPlayerMappableKeySettings::TriggersToAppend' has a wrong offset!");
static_assert(offsetof(UHWPlayerMappableKeySettings, KeyConsumePolicy) == 0x0000C0, "Member 'UHWPlayerMappableKeySettings::KeyConsumePolicy' has a wrong offset!");
static_assert(offsetof(UHWPlayerMappableKeySettings, bTriggerOnlyOnce) == 0x0000C1, "Member 'UHWPlayerMappableKeySettings::bTriggerOnlyOnce' has a wrong offset!");

// Class Hemingway.HWEnhancedPlayerInput
// 0x0130 (0x0C48 - 0x0B18)
class UHWEnhancedPlayerInput final : public URHPlayerInput
{
public:
	TMulticastInlineDelegate<void(EHWInputHardwareType CurrentHardwareType)> OnPlayerInputRebuilt;   // 0x0B18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FKey& Key, EInputEvent InputEvent)> OnKeyStateChanged; // 0x0B28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FKey& Key, EInputEvent InputEvent)> PostKeyHandled;   // 0x0B38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B48[0x8];                                      // 0x0B48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, TWeakObjectPtr<class UHWInputTriggerToggle>> ToggleTriggers;                         // 0x0B50(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BA0[0x18];                                     // 0x0BA0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const TArray<struct FKey>& SwapKeys, bool bIsSwapActionActive)> OnSwapActionStateChanged; // 0x0BB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHWSwapActionState>             SwapActions;                                       // 0x0BC8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD8[0x69];                                     // 0x0BD8(0x0069)(Fixing Size After Last Property [ Dumper-7 ])
	EHWSOCDPolicy                                 SOCDPolicy;                                        // 0x0C41(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C42[0x6];                                      // 0x0C42(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyContextAgnosticSettings();
	void Input_SwapActionStateChange(int32 InActionId, bool bIsActive);
	void Input_TriggerOff(int32 InActionId);
	void OnControlMappingRebuilt();

	EHWInputHardwareType GetCurrentInputHardwareType() const;
	void GetInputTagKeys(const struct FGameplayTag& InputTag, TArray<struct FKey>* OutMouseKeyboardKeys, TArray<struct FKey>* OutGamepadKeys) const;
	TArray<struct FKey> GetInputTagKeysOfState(const struct FGameplayTag& InputTag, ERH_INPUT_STATE InputState) const;
	EHWInputHardwareType GetLastKnownControllerHardware() const;
	bool IsSwapActiveForKey(const struct FKey& Key) const;
	bool IsSwapKey(const struct FKey& Key) const;
	bool UsesSOCDPolicy(const EHWSOCDPolicy InSOCDPolicty) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEnhancedPlayerInput">();
	}
	static class UHWEnhancedPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEnhancedPlayerInput>();
	}
};
static_assert(alignof(UHWEnhancedPlayerInput) == 0x000008, "Wrong alignment on UHWEnhancedPlayerInput");
static_assert(sizeof(UHWEnhancedPlayerInput) == 0x000C48, "Wrong size on UHWEnhancedPlayerInput");
static_assert(offsetof(UHWEnhancedPlayerInput, OnPlayerInputRebuilt) == 0x000B18, "Member 'UHWEnhancedPlayerInput::OnPlayerInputRebuilt' has a wrong offset!");
static_assert(offsetof(UHWEnhancedPlayerInput, OnKeyStateChanged) == 0x000B28, "Member 'UHWEnhancedPlayerInput::OnKeyStateChanged' has a wrong offset!");
static_assert(offsetof(UHWEnhancedPlayerInput, PostKeyHandled) == 0x000B38, "Member 'UHWEnhancedPlayerInput::PostKeyHandled' has a wrong offset!");
static_assert(offsetof(UHWEnhancedPlayerInput, ToggleTriggers) == 0x000B50, "Member 'UHWEnhancedPlayerInput::ToggleTriggers' has a wrong offset!");
static_assert(offsetof(UHWEnhancedPlayerInput, OnSwapActionStateChanged) == 0x000BB8, "Member 'UHWEnhancedPlayerInput::OnSwapActionStateChanged' has a wrong offset!");
static_assert(offsetof(UHWEnhancedPlayerInput, SwapActions) == 0x000BC8, "Member 'UHWEnhancedPlayerInput::SwapActions' has a wrong offset!");
static_assert(offsetof(UHWEnhancedPlayerInput, SOCDPolicy) == 0x000C41, "Member 'UHWEnhancedPlayerInput::SOCDPolicy' has a wrong offset!");

// Class Hemingway.HWInputComponent
// 0x0000 (0x0160 - 0x0160)
class UHWInputComponent final : public UEnhancedInputComponent
{
public:
	void AddInputMappings(const class UHWInputConfig* InputConfig, class UEnhancedInputLocalPlayerSubsystem* InputSubsystem) const;
	struct FKey GetKeyMappedToTag(const class UHWInputConfig* InputConfig, const struct FGameplayTag& InputTag) const;
	void RemoveInputMappings(const class UHWInputConfig* InputConfig, class UEnhancedInputLocalPlayerSubsystem* InputSubsystem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInputComponent">();
	}
	static class UHWInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInputComponent>();
	}
};
static_assert(alignof(UHWInputComponent) == 0x000008, "Wrong alignment on UHWInputComponent");
static_assert(sizeof(UHWInputComponent) == 0x000160, "Wrong size on UHWInputComponent");

// Class Hemingway.HWInputConfig
// 0x0048 (0x0078 - 0x0030)
class UHWInputConfig final : public UDataAsset
{
public:
	struct FGameplayTag                           MappingContextTag;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWInputAction>                 NativeInputActions;                                // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHWInputAction>                 AbilityInputActions;                               // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHWInputAction>                 UIInputActions;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHWInputAction>                 VGSInputActions;                                   // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	const class UInputAction* FindAbilityInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const;
	const class UInputAction* FindNativeInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const;
	const class UInputAction* FindUIInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const;
	const class UInputAction* FindVGSInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const;
	bool IsAbilityInputAction(const class UInputAction* InputAction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInputConfig">();
	}
	static class UHWInputConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInputConfig>();
	}
};
static_assert(alignof(UHWInputConfig) == 0x000008, "Wrong alignment on UHWInputConfig");
static_assert(sizeof(UHWInputConfig) == 0x000078, "Wrong size on UHWInputConfig");
static_assert(offsetof(UHWInputConfig, MappingContextTag) == 0x000030, "Member 'UHWInputConfig::MappingContextTag' has a wrong offset!");
static_assert(offsetof(UHWInputConfig, NativeInputActions) == 0x000038, "Member 'UHWInputConfig::NativeInputActions' has a wrong offset!");
static_assert(offsetof(UHWInputConfig, AbilityInputActions) == 0x000048, "Member 'UHWInputConfig::AbilityInputActions' has a wrong offset!");
static_assert(offsetof(UHWInputConfig, UIInputActions) == 0x000058, "Member 'UHWInputConfig::UIInputActions' has a wrong offset!");
static_assert(offsetof(UHWInputConfig, VGSInputActions) == 0x000068, "Member 'UHWInputConfig::VGSInputActions' has a wrong offset!");

// Class Hemingway.HWInputTriggerToggle
// 0x0028 (0x0078 - 0x0050)
class UHWInputTriggerToggle final : public UInputTrigger
{
public:
	bool                                          bToggleOffOnRelease;                               // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        TriggerDuration;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToggleOffOnChordComplete;                         // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x17];                                      // 0x0061(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInputTriggerToggle">();
	}
	static class UHWInputTriggerToggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInputTriggerToggle>();
	}
};
static_assert(alignof(UHWInputTriggerToggle) == 0x000008, "Wrong alignment on UHWInputTriggerToggle");
static_assert(sizeof(UHWInputTriggerToggle) == 0x000078, "Wrong size on UHWInputTriggerToggle");
static_assert(offsetof(UHWInputTriggerToggle, bToggleOffOnRelease) == 0x000050, "Member 'UHWInputTriggerToggle::bToggleOffOnRelease' has a wrong offset!");
static_assert(offsetof(UHWInputTriggerToggle, TriggerDuration) == 0x000058, "Member 'UHWInputTriggerToggle::TriggerDuration' has a wrong offset!");
static_assert(offsetof(UHWInputTriggerToggle, bToggleOffOnChordComplete) == 0x000060, "Member 'UHWInputTriggerToggle::bToggleOffOnChordComplete' has a wrong offset!");

// Class Hemingway.HWInputTriggerChord
// 0x0030 (0x0088 - 0x0058)
class UHWInputTriggerChord final : public UInputTriggerChordAction
{
public:
	uint8                                         Pad_58[0x4];                                       // 0x0058(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EHWInputTriggerKeyConsumePolicy               ConsumePolicy;                                     // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D[0x1B];                                      // 0x005D(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTriggerOnlyOnce;                                  // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0xF];                                       // 0x0079(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInputTriggerChord">();
	}
	static class UHWInputTriggerChord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInputTriggerChord>();
	}
};
static_assert(alignof(UHWInputTriggerChord) == 0x000008, "Wrong alignment on UHWInputTriggerChord");
static_assert(sizeof(UHWInputTriggerChord) == 0x000088, "Wrong size on UHWInputTriggerChord");
static_assert(offsetof(UHWInputTriggerChord, ConsumePolicy) == 0x00005C, "Member 'UHWInputTriggerChord::ConsumePolicy' has a wrong offset!");
static_assert(offsetof(UHWInputTriggerChord, bTriggerOnlyOnce) == 0x000078, "Member 'UHWInputTriggerChord::bTriggerOnlyOnce' has a wrong offset!");

// Class Hemingway.HWInputTriggerSingle
// 0x0030 (0x0080 - 0x0050)
class UHWInputTriggerSingle final : public UInputTrigger
{
public:
	uint8                                         Pad_50[0x4];                                       // 0x0050(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EHWInputTriggerKeyConsumePolicy               ConsumePolicy;                                     // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x1B];                                      // 0x0055(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTriggerOnlyOnce;                                  // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInputTriggerSingle">();
	}
	static class UHWInputTriggerSingle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWInputTriggerSingle>();
	}
};
static_assert(alignof(UHWInputTriggerSingle) == 0x000008, "Wrong alignment on UHWInputTriggerSingle");
static_assert(sizeof(UHWInputTriggerSingle) == 0x000080, "Wrong size on UHWInputTriggerSingle");
static_assert(offsetof(UHWInputTriggerSingle, ConsumePolicy) == 0x000054, "Member 'UHWInputTriggerSingle::ConsumePolicy' has a wrong offset!");
static_assert(offsetof(UHWInputTriggerSingle, bTriggerOnlyOnce) == 0x000070, "Member 'UHWInputTriggerSingle::bTriggerOnlyOnce' has a wrong offset!");

// Class Hemingway.HWMappingContextComponent
// 0x00D0 (0x00F8 - 0x0028)
class UHWMappingContextComponent final : public UObject
{
public:
	TSoftObjectPtr<class UDataTable>              MappingContextTableSoftPtr;                        // 0x0028(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FHWMappingContextData> MappingContextsData;                     // 0x0050(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UInputMappingContext*> DirtyMappingContexts;                     // 0x00A8(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	bool LoadKeybindSettings();

	bool HasDirtyRebinds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWMappingContextComponent">();
	}
	static class UHWMappingContextComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWMappingContextComponent>();
	}
};
static_assert(alignof(UHWMappingContextComponent) == 0x000008, "Wrong alignment on UHWMappingContextComponent");
static_assert(sizeof(UHWMappingContextComponent) == 0x0000F8, "Wrong size on UHWMappingContextComponent");
static_assert(offsetof(UHWMappingContextComponent, MappingContextTableSoftPtr) == 0x000028, "Member 'UHWMappingContextComponent::MappingContextTableSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWMappingContextComponent, MappingContextsData) == 0x000050, "Member 'UHWMappingContextComponent::MappingContextsData' has a wrong offset!");
static_assert(offsetof(UHWMappingContextComponent, DirtyMappingContexts) == 0x0000A8, "Member 'UHWMappingContextComponent::DirtyMappingContexts' has a wrong offset!");

// Class Hemingway.HWInterface_Controller
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_Controller final
{
public:
	void ClientSetControllerRotation(const struct FRotator& NewRotation, bool bResetCamera);

	class AHWCharacterAbilitySystemActor* GetAbilitySystemActor() const;
	class UHWAbilitySystemComponent* GetAbilitySystemComponent() const;
	class AActor* GetStartSpot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_Controller">();
	}
	static class IHWInterface_Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_Controller>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_Controller) == 0x000001, "Wrong alignment on IHWInterface_Controller");
static_assert(sizeof(IHWInterface_Controller) == 0x000001, "Wrong size on IHWInterface_Controller");

// Class Hemingway.HWInterface_LoadoutManagement
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_LoadoutManagement final
{
public:
	class UHWLoadoutComponent* GetLoadoutComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_LoadoutManagement">();
	}
	static class IHWInterface_LoadoutManagement* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_LoadoutManagement>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_LoadoutManagement) == 0x000001, "Wrong alignment on IHWInterface_LoadoutManagement");
static_assert(sizeof(IHWInterface_LoadoutManagement) == 0x000001, "Wrong size on IHWInterface_LoadoutManagement");

// Class Hemingway.HWAnnouncerPackItem
// 0x00A8 (0x0458 - 0x03B0)
class UHWAnnouncerPackItem final : public UHWCollectionItem
{
public:
	bool                                          bIsDefaultAnnouncer;                               // 0x03B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FAssetRequestKey, TSoftObjectPtr<class UMetaSoundSource>> AnnouncerCues;             // 0x03B8(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<struct FAssetRequestKey, TSoftObjectPtr<class UMetaSoundSource>> SkinnedAnnouncerCues;      // 0x0408(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	TSoftObjectPtr<class UMetaSoundSource> GetAnnouncerCue(const struct FAssetRequestKey& AssetKey) const;
	const TMap<struct FAssetRequestKey, TSoftObjectPtr<class UMetaSoundSource>> GetSkinnedAnnouncerCues() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWAnnouncerPackItem">();
	}
	static class UHWAnnouncerPackItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWAnnouncerPackItem>();
	}
};
static_assert(alignof(UHWAnnouncerPackItem) == 0x000008, "Wrong alignment on UHWAnnouncerPackItem");
static_assert(sizeof(UHWAnnouncerPackItem) == 0x000458, "Wrong size on UHWAnnouncerPackItem");
static_assert(offsetof(UHWAnnouncerPackItem, bIsDefaultAnnouncer) == 0x0003B0, "Member 'UHWAnnouncerPackItem::bIsDefaultAnnouncer' has a wrong offset!");
static_assert(offsetof(UHWAnnouncerPackItem, AnnouncerCues) == 0x0003B8, "Member 'UHWAnnouncerPackItem::AnnouncerCues' has a wrong offset!");
static_assert(offsetof(UHWAnnouncerPackItem, SkinnedAnnouncerCues) == 0x000408, "Member 'UHWAnnouncerPackItem::SkinnedAnnouncerCues' has a wrong offset!");

// Class Hemingway.HWBundleItem
// 0x0000 (0x03B0 - 0x03B0)
class UHWBundleItem final : public UHWCollectionItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWBundleItem">();
	}
	static class UHWBundleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWBundleItem>();
	}
};
static_assert(alignof(UHWBundleItem) == 0x000008, "Wrong alignment on UHWBundleItem");
static_assert(sizeof(UHWBundleItem) == 0x0003B0, "Wrong size on UHWBundleItem");

// Class Hemingway.HWMusicPackItem
// 0x0050 (0x0400 - 0x03B0)
class UHWMusicPackItem final : public UHWCollectionItem
{
public:
	TMap<struct FAssetRequestKey, TSoftObjectPtr<class UMetaSoundSource>> MusicSoundCues;            // 0x03B0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	TSoftObjectPtr<class UMetaSoundSource> GetSoundCue(const struct FAssetRequestKey& AssetKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWMusicPackItem">();
	}
	static class UHWMusicPackItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWMusicPackItem>();
	}
};
static_assert(alignof(UHWMusicPackItem) == 0x000008, "Wrong alignment on UHWMusicPackItem");
static_assert(sizeof(UHWMusicPackItem) == 0x000400, "Wrong size on UHWMusicPackItem");
static_assert(offsetof(UHWMusicPackItem, MusicSoundCues) == 0x0003B0, "Member 'UHWMusicPackItem::MusicSoundCues' has a wrong offset!");

// Class Hemingway.HWSeasonItem
// 0x0128 (0x04D8 - 0x03B0)
class UHWSeasonItem final : public UHWCollectionItem
{
public:
	class FText                                   LongDescription;                                   // 0x03B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   PurchaseConfirmationDescription;                   // 0x03C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         StoreItemVendorId;                                 // 0x03E0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRH_ItemId                             SpentTokensTrackerItemId;                          // 0x03E4(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpentTokensXpTableId;                              // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EndTimeOfSeason;                                   // 0x0400(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              LockedSeasonHubImage;                              // 0x0410(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              UnlockedSeasonHubImage;                            // 0x0438(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              LockedSeasonImage;                                 // 0x0460(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              UnlockedSeasonImage;                               // 0x0488(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              LargeSeasonSplashImage;                            // 0x04B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetPointsRequiredForPage(const class UObject* WorldContextObject, int32 PageIndex) const;
	int32 GetSeasonItemCount(const class UObject* WorldContextObject) const;
	int32 GetSeasonItemOwned(const class UObject* WorldContextObject) const;
	int64 GetSecondsRemainingInSeason(const class UObject* WorldContextObject) const;
	struct FRH_ItemId GetSpentTokensTrackerItemId() const;
	int32 GetTotalPagesCount(const class UObject* WorldContextObject) const;
	int32 GetUnlockedPagesCount(const class UObject* WorldContextObject) const;
	bool IsSeasonFullyCompleted(const class UObject* WorldContextObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSeasonItem">();
	}
	static class UHWSeasonItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSeasonItem>();
	}
};
static_assert(alignof(UHWSeasonItem) == 0x000008, "Wrong alignment on UHWSeasonItem");
static_assert(sizeof(UHWSeasonItem) == 0x0004D8, "Wrong size on UHWSeasonItem");
static_assert(offsetof(UHWSeasonItem, LongDescription) == 0x0003B0, "Member 'UHWSeasonItem::LongDescription' has a wrong offset!");
static_assert(offsetof(UHWSeasonItem, PurchaseConfirmationDescription) == 0x0003C8, "Member 'UHWSeasonItem::PurchaseConfirmationDescription' has a wrong offset!");
static_assert(offsetof(UHWSeasonItem, StoreItemVendorId) == 0x0003E0, "Member 'UHWSeasonItem::StoreItemVendorId' has a wrong offset!");
static_assert(offsetof(UHWSeasonItem, SpentTokensTrackerItemId) == 0x0003E4, "Member 'UHWSeasonItem::SpentTokensTrackerItemId' has a wrong offset!");
static_assert(offsetof(UHWSeasonItem, SpentTokensXpTableId) == 0x0003F8, "Member 'UHWSeasonItem::SpentTokensXpTableId' has a wrong offset!");
static_assert(offsetof(UHWSeasonItem, EndTimeOfSeason) == 0x000400, "Member 'UHWSeasonItem::EndTimeOfSeason' has a wrong offset!");
static_assert(offsetof(UHWSeasonItem, LockedSeasonHubImage) == 0x000410, "Member 'UHWSeasonItem::LockedSeasonHubImage' has a wrong offset!");
static_assert(offsetof(UHWSeasonItem, UnlockedSeasonHubImage) == 0x000438, "Member 'UHWSeasonItem::UnlockedSeasonHubImage' has a wrong offset!");
static_assert(offsetof(UHWSeasonItem, LockedSeasonImage) == 0x000460, "Member 'UHWSeasonItem::LockedSeasonImage' has a wrong offset!");
static_assert(offsetof(UHWSeasonItem, UnlockedSeasonImage) == 0x000488, "Member 'UHWSeasonItem::UnlockedSeasonImage' has a wrong offset!");
static_assert(offsetof(UHWSeasonItem, LargeSeasonSplashImage) == 0x0004B0, "Member 'UHWSeasonItem::LargeSeasonSplashImage' has a wrong offset!");

// Class Hemingway.HWSkinItem
// 0x0178 (0x0528 - 0x03B0)
class UHWSkinItem final : public UHWCollectionItem
{
public:
	TArray<TSubclassOf<class UHWSkinEvoEvalComponent>> SkinEvoEvalCompTemplates;                     // 0x03B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PreviewActor;                                      // 0x03C0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UHWLobbyGodAnimationInfo> PreviewAnimationConfig;                           // 0x03E8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UHWApparelItem>>  ApparelAssets;                                     // 0x0410(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UHWVoicePackItem>        AssociatedVoicePack;                               // 0x0420(0x0028)(Edit, DisableEditOnInstance, AssetRegistrySearchable, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UHWCharacterItem>> OtherCompatibleAssociatedCharacterItems;          // 0x0448(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UHWSkinItem>             AssociatedBaseSkin;                                // 0x0458(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UHWSkinItem>             PreviousEvolutionTierSkin;                         // 0x0480(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UHWSkinItem>             NextEvolutionTierSkin;                             // 0x04A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLegacyMeshRotationOffset;                      // 0x04D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UHWCharacterItem*, TSoftObjectPtr<class UHWSkinItem>> FamiliarSkinMap;                // 0x04D8(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static void SortSkinListByDisplayName(TArray<TSoftObjectPtr<class UHWSkinItem>>& SkinList);
	static void SortSkinListByFriendlyName(TArray<TSoftObjectPtr<class UHWSkinItem>>& SkinList);
	static const TSoftObjectPtr<class UHWCharacterItem> StaticGetAssociatedCharacter(const TSoftObjectPtr<class UHWSkinItem>& Skin);

	TArray<TSoftObjectPtr<class UHWApparelItem>> GetApparelAssets() const;
	TSoftObjectPtr<class UHWSkinItem> GetAssociatedBaseSkin() const;
	TSoftObjectPtr<class UHWSkinItem> GetNextEvolutionSkin() const;
	TArray<TSoftObjectPtr<class UHWCharacterItem>> GetOtherCompatibleAssociatedCharacterItems() const;
	TSoftClassPtr<class UClass> GetPreviewActor() const;
	TSoftObjectPtr<class UHWSkinItem> GetPreviousEvolutionSkin() const;
	TSoftObjectPtr<class UHWVoicePackItem> GetVoicePackItem() const;
	bool HasSkinVariants(class UObject* WorldContext, bool bPlayableOnly) const;
	bool IsBaseSkinOfVariant(const class UHWSkinItem* VariantSkin) const;
	bool IsDefaultSkin() const;
	bool IsMasterySkin() const;
	bool IsOwnedCachedOrDefault(const class URH_PlayerInfo* PlayerInfo) const;
	bool IsVariantOfBaseSkin(const class UHWSkinItem* BaseSkin) const;
	bool IsVariantSkin() const;
	bool ShouldUseLegacyMeshRotationOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinItem">();
	}
	static class UHWSkinItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSkinItem>();
	}
};
static_assert(alignof(UHWSkinItem) == 0x000008, "Wrong alignment on UHWSkinItem");
static_assert(sizeof(UHWSkinItem) == 0x000528, "Wrong size on UHWSkinItem");
static_assert(offsetof(UHWSkinItem, SkinEvoEvalCompTemplates) == 0x0003B0, "Member 'UHWSkinItem::SkinEvoEvalCompTemplates' has a wrong offset!");
static_assert(offsetof(UHWSkinItem, PreviewActor) == 0x0003C0, "Member 'UHWSkinItem::PreviewActor' has a wrong offset!");
static_assert(offsetof(UHWSkinItem, PreviewAnimationConfig) == 0x0003E8, "Member 'UHWSkinItem::PreviewAnimationConfig' has a wrong offset!");
static_assert(offsetof(UHWSkinItem, ApparelAssets) == 0x000410, "Member 'UHWSkinItem::ApparelAssets' has a wrong offset!");
static_assert(offsetof(UHWSkinItem, AssociatedVoicePack) == 0x000420, "Member 'UHWSkinItem::AssociatedVoicePack' has a wrong offset!");
static_assert(offsetof(UHWSkinItem, OtherCompatibleAssociatedCharacterItems) == 0x000448, "Member 'UHWSkinItem::OtherCompatibleAssociatedCharacterItems' has a wrong offset!");
static_assert(offsetof(UHWSkinItem, AssociatedBaseSkin) == 0x000458, "Member 'UHWSkinItem::AssociatedBaseSkin' has a wrong offset!");
static_assert(offsetof(UHWSkinItem, PreviousEvolutionTierSkin) == 0x000480, "Member 'UHWSkinItem::PreviousEvolutionTierSkin' has a wrong offset!");
static_assert(offsetof(UHWSkinItem, NextEvolutionTierSkin) == 0x0004A8, "Member 'UHWSkinItem::NextEvolutionTierSkin' has a wrong offset!");
static_assert(offsetof(UHWSkinItem, bUseLegacyMeshRotationOffset) == 0x0004D0, "Member 'UHWSkinItem::bUseLegacyMeshRotationOffset' has a wrong offset!");
static_assert(offsetof(UHWSkinItem, FamiliarSkinMap) == 0x0004D8, "Member 'UHWSkinItem::FamiliarSkinMap' has a wrong offset!");

// Class Hemingway.HWVoicePackItem
// 0x0010 (0x01C0 - 0x01B0)
class UHWVoicePackItem final : public UHWInventoryItem
{
public:
	TArray<struct FDataTableInfo>                 VoicePackEntries;                                  // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static void SortSkinListByDisplayName(TArray<TSoftObjectPtr<class UHWVoicePackItem>>& VoicePackList);
	static void SortSkinListByFriendlyName(TArray<TSoftObjectPtr<class UHWVoicePackItem>>& VoicePackList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWVoicePackItem">();
	}
	static class UHWVoicePackItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWVoicePackItem>();
	}
};
static_assert(alignof(UHWVoicePackItem) == 0x000008, "Wrong alignment on UHWVoicePackItem");
static_assert(sizeof(UHWVoicePackItem) == 0x0001C0, "Wrong size on UHWVoicePackItem");
static_assert(offsetof(UHWVoicePackItem, VoicePackEntries) == 0x0001B0, "Member 'UHWVoicePackItem::VoicePackEntries' has a wrong offset!");

// Class Hemingway.HWPingWorldActor
// 0x0038 (0x02D0 - 0x0298)
class AHWPingWorldActor final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWDisplayInfoComponent*                DisplayInfoComponent;                              // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWDisplayInfoComponent>    DisplayInfoComponentClass;                         // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x20];                                     // 0x02B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecycleActor();
	void SetPingDuration(float Duration);

	class UHWDisplayInfoComponent* GetDisplayInfoComponent() const;
	struct FGameplayTag GetPingTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPingWorldActor">();
	}
	static class AHWPingWorldActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPingWorldActor>();
	}
};
static_assert(alignof(AHWPingWorldActor) == 0x000008, "Wrong alignment on AHWPingWorldActor");
static_assert(sizeof(AHWPingWorldActor) == 0x0002D0, "Wrong size on AHWPingWorldActor");
static_assert(offsetof(AHWPingWorldActor, DisplayInfoComponent) == 0x0002A0, "Member 'AHWPingWorldActor::DisplayInfoComponent' has a wrong offset!");
static_assert(offsetof(AHWPingWorldActor, DisplayInfoComponentClass) == 0x0002A8, "Member 'AHWPingWorldActor::DisplayInfoComponentClass' has a wrong offset!");

// Class Hemingway.HWDeferredPlayerControllerWorkComponent
// 0x0008 (0x00A8 - 0x00A0)
class UHWDeferredPlayerControllerWorkComponent final : public UHWActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWDeferredPlayerControllerWorkComponent">();
	}
	static class UHWDeferredPlayerControllerWorkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWDeferredPlayerControllerWorkComponent>();
	}
};
static_assert(alignof(UHWDeferredPlayerControllerWorkComponent) == 0x000008, "Wrong alignment on UHWDeferredPlayerControllerWorkComponent");
static_assert(sizeof(UHWDeferredPlayerControllerWorkComponent) == 0x0000A8, "Wrong size on UHWDeferredPlayerControllerWorkComponent");

// Class Hemingway.HWPlayerController
// 0x0678 (0x0FF8 - 0x0980)
class AHWPlayerController : public ARHPlayerController
{
public:
	uint8                                         Pad_980[0x30];                                     // 0x0980(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWDeferredPlayerControllerWorkComponent* DeferredWorkComponent;                           // 0x09B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasInitiallyTransferred;                          // 0x09B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B9[0x7];                                      // 0x09B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bIsTargeterReticleVisible)> OnTargeterReticleVisibilityChanged; // 0x09C0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UHWInputConfig*                         ControllerInputConfig;                             // 0x09D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRegisterInputActions;                             // 0x09D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D9[0x7];                                      // 0x09D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                BoundInputHandles;                                 // 0x09E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ConsoleMouseCursorWidgetSoftPtr;                   // 0x09F0(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            ConsoleMouseCursorWidget;                          // 0x0A18(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A20[0x78];                                     // 0x0A20(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* HWPlayerState)> OnHWPlayerStateReplicated;   // 0x0A98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWCharacterAbilitySystemActor* NewASActor)> OnAbilitySystemActorReplicated; // 0x0AA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         AbilitySystemActor;                                // 0x0AB8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC0[0x4];                                      // 0x0AC0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AHWTeamState>            CurrentABSActorTeamState;                          // 0x0AC4(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ACC[0x4];                                      // 0x0ACC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AController* Controller, const struct FGenericTeamId& TeamId)> OnTeamChangedDelegate; // 0x0AD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADraftReplicatedActor* DraftActor)> OnDraftActorAddedDel;    // 0x0AE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF0[0x68];                                     // 0x0AF0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, TWeakObjectPtr<class ADraftReplicatedActor>> DraftActors;                      // 0x0B58(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_BA8[0x20];                                     // 0x0BA8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWCheatComponent>          CheatComponentClass;                               // 0x0BC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWCheatComponent*                      CheatComponent;                                    // 0x0BD0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHWItemStoreManagerComponent> ItemStoreManagerComponentClass;                  // 0x0BD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWItemStoreManagerComponent*           ItemStoreManagerComponent;                         // 0x0BE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWControlModule*                       ControlModule;                                     // 0x0BE8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHWVGSMenuTagToGameplayEventTag> VGSMenuTagToGameplayEventTagMap;                  // 0x0BF0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSimProjectileFlashEventList           FlashEventLists;                                   // 0x0C00(0x0128)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D28[0x18];                                     // 0x0D28(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuestReplicatedEventList              QuestFlashEventList;                               // 0x0D40(0x0128)(Net, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQuestReplicatedEvent>          QuestsPendingWrite;                                // 0x0E68(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQuestReplicatedEvent>          QuestsBeingWritten;                                // 0x0E78(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsWritingQuestProgress;                           // 0x0E88(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E89[0x3];                                      // 0x0E89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PendingAchievementWrites;                          // 0x0E8C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FRH_ItemId, struct FQuestReplicatedEvent> CachedQuestInventoryProgressMap;           // 0x0E90(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_EE0[0x4];                                      // 0x0EE0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCachedIsUIRelevant;                               // 0x0EE4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCachedIsOnlyASpector;                             // 0x0EE5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EE6[0x2];                                      // 0x0EE6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnPlayerControllerIsUIRelevantDel;                 // 0x0EE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EF8[0x18];                                     // 0x0EF8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnablePlayCallSuggestion;                         // 0x0F10(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F11[0x7];                                      // 0x0F11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWPlayCallSuggestionManager*           PlayCallSuggestionManager;                         // 0x0F18(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AimCurve;                                          // 0x0F20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            AimCurveDown;                                      // 0x0F28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RestrictedPitchCurve;                              // 0x0F30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RestrictedPitchCurveForcedDown;                    // 0x0F38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCinematicCameraModeActive;                      // 0x0F40(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F41[0x7];                                      // 0x0F41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bUpdatedHasSurrenderVoted)> OnHasSurrenderVotedUpdated;       // 0x0F48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHasSurrenderVoted;                                // 0x0F58(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F59[0x7];                                      // 0x0F59(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bUpdatedHasPauseVoted)> OnHasPauseVotedUpdated;               // 0x0F60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHasPauseVoted;                                    // 0x0F70(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F71[0x7];                                      // 0x0F71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TrackedStatName;                                   // 0x0F78(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTrackingStat;                                   // 0x0F80(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F81[0x7];                                      // 0x0F81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDebugFloatHistory                     TrackedStatHistory;                                // 0x0F88(0x0020)(Protected, NativeAccessSpecifierProtected)
	struct FVector                                CachedViewTargetLocation;                          // 0x0FA8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetectingAFK;                                     // 0x0FC0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC1[0x3];                                      // 0x0FC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AFKWarningThreshold;                               // 0x0FC4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           AFKWarningTimerHandle;                             // 0x0FC8(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AFKThreshold;                                      // 0x0FD0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD4[0x4];                                      // 0x0FD4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           AFKTimerHandle;                                    // 0x0FD8(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE0[0x18];                                     // 0x0FE0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsLocalPlayerOnlyASpectator(const class UObject* WorldContextObject);
	static bool IsOnlyASpectator(const class APlayerController* PlayerController);

	void ActivateBooster(const struct FGameplayTag& BoosterTag);
	void AddLogMarker(const class FString& MarkerText);
	void AntiCheatClientMessageToServer(const TArray<uint8>& Data);
	void AntiCheatServerMessageToClient(const TArray<uint8>& Data);
	void AudioInputDeviceChanged();
	void BroadcastClientCombatEvent(const struct FHWCombatEvent& CombatEvent);
	bool CancelCharacterSelection();
	void CheckForAFK();
	void ClientDisplayAFKWarning();
	void ClientNotifyBackfillStateUpdated(const struct FHWBackfillQueueInfo& BackfillQueueInfo);
	void ClientRequestIdToken();
	void HandleABSActorTeamUpdated(class AHWCharacterAbilitySystemActor* CharacterAbilitySystemActor, class AHWTeamState* TeamState);
	void HandleControllerVibrationUpdated();
	void HandleCurrentVGSMenuIdUpdated(const struct FGameplayTag& MenuId);
	void HandleEffectsQualitySettingUpdated();
	void HandleInvokeVGSAction(const struct FGameplayTag& ActionId);
	void HandleOnTeamPauseVoteResolved(class AHWTeamState* TeamState, const EHWVoteResult Result);
	void HandleOnTeamSurrenderResolved(class AHWTeamState* TeamState, const EHWVoteResult Result);
	void HandlePushToTalkSettingUpdated();
	void HandleVGSManagerReplicated(class AHWVGSManager* VGSManager);
	void HandleVoiceChatEnabledSettingUpdated();
	void InitAFKDetection(float KickAfterDuration, float WarnAfterDuration);
	void Input_UIInputTagHeld(const struct FGameplayTag& InputTag);
	void Input_UIInputTagPressed(const struct FGameplayTag& InputTag);
	void Input_UIInputTagReleased(const struct FGameplayTag& InputTag);
	void Input_VGSInputTagHeld(const struct FGameplayTag& InputTag);
	void Input_VGSInputTagPressed(const struct FGameplayTag& InputTag);
	void Input_VGSInputTagReleased(const struct FGameplayTag& InputTag);
	bool IsInputBound(const struct FGameplayTag& InputTag, ERH_INPUT_STATE InputState);
	void KickAFKPlayer();
	void LocalPlayerSpectate(bool bWillSpectate);
	void MicrophoneVolumeSettingChanged();
	void NotifyBackfillStateUpdated(const struct FHWBackfillQueueInfo& BackfillQueueInfo);
	void OnConsoleMouseCursorWidgetLoaded();
	void OnCurrentlyPossessedPawnChanged(class APawn* PreviousPossessedPawn, class APawn* CurrentPossessedPawn);
	void OnDraftActorDestroyed(class AActor* DestroyedActor);
	void OnQuestProgressWritten(bool bSuccess);
	void OnRep_AbilitySystemActor(class AHWCharacterAbilitySystemActor* OldAbilitySystemActor);
	void OnRep_bHasPauseVoted();
	void OnRep_bHasSurrenderVoted();
	void OnWorldTimeSecondsReplicated();
	bool RequestCharacterReselect();
	void RequestIdToken();
	void ResetAFKTimer();
	void Server_ActivateBooster(const struct FGameplayTag& BoosterTag);
	void ServerAddTeamPing(const struct FGameplayTag& PingTag, const struct FVector& PingLocation, EHWPingSource PingSource, bool bSendChatNotification);
	void ServerCancelCharacterSelection();
	void ServerDebugChangeCameraMode(EHWCameraMode CameraMode);
	void ServerRequestCharacterReselect();
	void ServerRequestUnpause();
	void ServerSetActiveAspect(const struct FRH_ItemId& AspectItemId);
	void ServerSetInputType(ECommonInputType InputType);
	void ServerSetSRValue(int32 InSRValue);
	void ServerSubmitPauseVote(const EHWVoteState PauseVote);
	void ServerSubmitSurrenderVote(const EHWVoteState SurrenderVote);
	void ServerTogglePlayCallSuggestion(bool bEnabled);
	void ServerUpdateEquipmentCastMode(const struct FHWInventorySlot& InventorySlot, const EAbilityCastStyle& CastMode);
	void ServerValidateIdToken(const class FString& ProductUserId, const class FString& JsonWebToken);
	void ServerVGSTriggerAction(const struct FGameplayTag& VGSTag);
	void SetActiveControlModule(TSubclassOf<class UHWControlModule> ControlModClass);
	void SetAllowedInputCategories(EHWAllowedInputCategory AllowedCategories);
	void SubmitPauseVote(const EHWVoteState PauseVote);
	void SubmitSurrenderVote(const EHWVoteState SurrenderVote);
	void ToggleCinematicCameraMode(bool bActive);
	void TogglePlayCallSuggestion(bool bEnabled);
	void TrackSingleStat(const class FName& StatName);
	void UpdateEquipmentCastMode(const struct FHWInventorySlot& InventorySlot, const EAbilityCastStyle& CastMode);
	void UpdateTrackedStatGraph();
	void WarnAFKPlayer();

	bool CanCancelCharacterSelection() const;
	bool CanReselectCharacterNow() const;
	class AHWCharacterAbilitySystemActor* GetAbilitySystemActor() const;
	class UHWControlModule* GetActiveControlModule() const;
	ECommonInputType GetCurrentInputType() const;
	bool GetHasPauseVoted() const;
	bool GetHasSurrenderVoted() const;
	class UHWEnhancedPlayerInput* GetHWEnhancedPlayerInput() const;
	class UHWItemStoreManagerComponent* GetItemStoreManagerComponent() const;
	class AHWPlayCallSuggestionManager* GetPlayCallSuggestionManager() const;
	bool IsCinematicCameraModeActive() const;
	bool IsGm() const;
	bool IsInputCategoryAllowed(EHWAllowedInputCategory Category) const;
	bool IsUIRelevant() const;
	bool IsUIRelevantOrSpectator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerController">();
	}
	static class AHWPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPlayerController>();
	}
};
static_assert(alignof(AHWPlayerController) == 0x000008, "Wrong alignment on AHWPlayerController");
static_assert(sizeof(AHWPlayerController) == 0x000FF8, "Wrong size on AHWPlayerController");
static_assert(offsetof(AHWPlayerController, DeferredWorkComponent) == 0x0009B0, "Member 'AHWPlayerController::DeferredWorkComponent' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bHasInitiallyTransferred) == 0x0009B8, "Member 'AHWPlayerController::bHasInitiallyTransferred' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, OnTargeterReticleVisibilityChanged) == 0x0009C0, "Member 'AHWPlayerController::OnTargeterReticleVisibilityChanged' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, ControllerInputConfig) == 0x0009D0, "Member 'AHWPlayerController::ControllerInputConfig' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bRegisterInputActions) == 0x0009D8, "Member 'AHWPlayerController::bRegisterInputActions' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, BoundInputHandles) == 0x0009E0, "Member 'AHWPlayerController::BoundInputHandles' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, ConsoleMouseCursorWidgetSoftPtr) == 0x0009F0, "Member 'AHWPlayerController::ConsoleMouseCursorWidgetSoftPtr' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, ConsoleMouseCursorWidget) == 0x000A18, "Member 'AHWPlayerController::ConsoleMouseCursorWidget' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, OnHWPlayerStateReplicated) == 0x000A98, "Member 'AHWPlayerController::OnHWPlayerStateReplicated' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, OnAbilitySystemActorReplicated) == 0x000AA8, "Member 'AHWPlayerController::OnAbilitySystemActorReplicated' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, AbilitySystemActor) == 0x000AB8, "Member 'AHWPlayerController::AbilitySystemActor' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, CurrentABSActorTeamState) == 0x000AC4, "Member 'AHWPlayerController::CurrentABSActorTeamState' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, OnTeamChangedDelegate) == 0x000AD0, "Member 'AHWPlayerController::OnTeamChangedDelegate' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, OnDraftActorAddedDel) == 0x000AE0, "Member 'AHWPlayerController::OnDraftActorAddedDel' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, DraftActors) == 0x000B58, "Member 'AHWPlayerController::DraftActors' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, CheatComponentClass) == 0x000BC8, "Member 'AHWPlayerController::CheatComponentClass' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, CheatComponent) == 0x000BD0, "Member 'AHWPlayerController::CheatComponent' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, ItemStoreManagerComponentClass) == 0x000BD8, "Member 'AHWPlayerController::ItemStoreManagerComponentClass' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, ItemStoreManagerComponent) == 0x000BE0, "Member 'AHWPlayerController::ItemStoreManagerComponent' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, ControlModule) == 0x000BE8, "Member 'AHWPlayerController::ControlModule' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, VGSMenuTagToGameplayEventTagMap) == 0x000BF0, "Member 'AHWPlayerController::VGSMenuTagToGameplayEventTagMap' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, FlashEventLists) == 0x000C00, "Member 'AHWPlayerController::FlashEventLists' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, QuestFlashEventList) == 0x000D40, "Member 'AHWPlayerController::QuestFlashEventList' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, QuestsPendingWrite) == 0x000E68, "Member 'AHWPlayerController::QuestsPendingWrite' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, QuestsBeingWritten) == 0x000E78, "Member 'AHWPlayerController::QuestsBeingWritten' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bIsWritingQuestProgress) == 0x000E88, "Member 'AHWPlayerController::bIsWritingQuestProgress' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, PendingAchievementWrites) == 0x000E8C, "Member 'AHWPlayerController::PendingAchievementWrites' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, CachedQuestInventoryProgressMap) == 0x000E90, "Member 'AHWPlayerController::CachedQuestInventoryProgressMap' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bCachedIsUIRelevant) == 0x000EE4, "Member 'AHWPlayerController::bCachedIsUIRelevant' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bCachedIsOnlyASpector) == 0x000EE5, "Member 'AHWPlayerController::bCachedIsOnlyASpector' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, OnPlayerControllerIsUIRelevantDel) == 0x000EE8, "Member 'AHWPlayerController::OnPlayerControllerIsUIRelevantDel' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bEnablePlayCallSuggestion) == 0x000F10, "Member 'AHWPlayerController::bEnablePlayCallSuggestion' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, PlayCallSuggestionManager) == 0x000F18, "Member 'AHWPlayerController::PlayCallSuggestionManager' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, AimCurve) == 0x000F20, "Member 'AHWPlayerController::AimCurve' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, AimCurveDown) == 0x000F28, "Member 'AHWPlayerController::AimCurveDown' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, RestrictedPitchCurve) == 0x000F30, "Member 'AHWPlayerController::RestrictedPitchCurve' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, RestrictedPitchCurveForcedDown) == 0x000F38, "Member 'AHWPlayerController::RestrictedPitchCurveForcedDown' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bIsCinematicCameraModeActive) == 0x000F40, "Member 'AHWPlayerController::bIsCinematicCameraModeActive' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, OnHasSurrenderVotedUpdated) == 0x000F48, "Member 'AHWPlayerController::OnHasSurrenderVotedUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bHasSurrenderVoted) == 0x000F58, "Member 'AHWPlayerController::bHasSurrenderVoted' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, OnHasPauseVotedUpdated) == 0x000F60, "Member 'AHWPlayerController::OnHasPauseVotedUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bHasPauseVoted) == 0x000F70, "Member 'AHWPlayerController::bHasPauseVoted' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, TrackedStatName) == 0x000F78, "Member 'AHWPlayerController::TrackedStatName' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bIsTrackingStat) == 0x000F80, "Member 'AHWPlayerController::bIsTrackingStat' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, TrackedStatHistory) == 0x000F88, "Member 'AHWPlayerController::TrackedStatHistory' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, CachedViewTargetLocation) == 0x000FA8, "Member 'AHWPlayerController::CachedViewTargetLocation' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, bDetectingAFK) == 0x000FC0, "Member 'AHWPlayerController::bDetectingAFK' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, AFKWarningThreshold) == 0x000FC4, "Member 'AHWPlayerController::AFKWarningThreshold' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, AFKWarningTimerHandle) == 0x000FC8, "Member 'AHWPlayerController::AFKWarningTimerHandle' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, AFKThreshold) == 0x000FD0, "Member 'AHWPlayerController::AFKThreshold' has a wrong offset!");
static_assert(offsetof(AHWPlayerController, AFKTimerHandle) == 0x000FD8, "Member 'AHWPlayerController::AFKTimerHandle' has a wrong offset!");

// Class Hemingway.HWPlayerController_Smite
// 0x0170 (0x1168 - 0x0FF8)
class AHWPlayerController_Smite : public AHWPlayerController
{
public:
	uint8                                         Pad_FF8[0x4];                                      // 0x0FF8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadTurnAccelTarget;                            // 0x0FFC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadTurnAccelSpeed;                             // 0x1000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadTurnAccelExponent;                          // 0x1004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1008[0x20];                                    // 0x1008(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHWCameraModifier_Dead>     DeathPostProcessCamModClass;                       // 0x1028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraModifier*                        DeathPostProcessCamMod;                            // 0x1030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1038[0x8];                                     // 0x1038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bIsDeathSpectating)> OnDeathSpectatorStatusChanged;           // 0x1040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsDeathSpectating;                                // 0x1050(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1051[0x7];                                     // 0x1051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraModifier>            DeathSpecatorCameraModClass;                       // 0x1058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraModifier*                        DeathSpectatorCameraMod;                           // 0x1060(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              IntoxicatedRotationError;                          // 0x1068(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        CameraPitchAim;                                    // 0x1078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRestrictedCameraPitch;                         // 0x1080(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1081[0x1F];                                    // 0x1081(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraZoomSmoothSpeed;                             // 0x10A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraZoomSpeed;                                   // 0x10A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A8[0x4];                                     // 0x10A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpringArmLength;                                   // 0x10AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpringArmLengthBase;                               // 0x10B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B4[0x4];                                     // 0x10B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SocketOffset;                                      // 0x10B8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SocketOffsetBase;                                  // 0x10D0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClassicSpringArmLength;                            // 0x10E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClassicSpringArmLengthBase;                        // 0x10EC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ClassicSocketOffset;                               // 0x10F0(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ClassicSocketOffsetBase;                           // 0x1108(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClassicFOV;                                        // 0x1120(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAspectRatioAxisConstraint                    ClassicFOVConstraint;                              // 0x1124(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1125[0x3];                                     // 0x1125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActionSpringArmLength;                             // 0x1128(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActionSpringArmLengthBase;                         // 0x112C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ActionSocketOffset;                                // 0x1130(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ActionSocketOffsetBase;                            // 0x1148(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActionFOV;                                         // 0x1160(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAspectRatioAxisConstraint                    ActionFOVConstraint;                               // 0x1164(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1165[0x3];                                     // 0x1165(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Input_DeathSpecatorLook(const struct FInputActionValue& InputActionValue);
	void OnDeathSpectatorStatusChange(const bool bEnabled);
	void OnRep_IsDeathSpectating();
	void OnRep_UseRestrictedCameraPitch();
	void PushCamSettingsToViewTarget();
	void ServerSetUseRestrictedCameraPitch(bool bRestrictCamera);
	void SetMaxZoom(float NewMaxZoom);
	void SetMinZoom(float NewMinZoom);
	void SetRestrictedCameraPitchInterpSpeedOverride(float NewInterpSpeedOverride, float Time);
	void SetZoomPercent(float NewZoomPercent);
	void UpdateActionCamSetting();
	void UpdateRestrictCameraPitch();

	float GetMaxZoom() const;
	float GetMinZoom() const;
	class UHWPlayerSettingsSubsystem* GetPlayerSettingsSubsystem() const;
	class UHWSystemSettingsSubsystem* GetSystemSettingsSubsystem() const;
	float GetZoomPercent() const;
	bool IsCharacterForcedToAimDown() const;
	bool IsInRestrictedCamPitch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerController_Smite">();
	}
	static class AHWPlayerController_Smite* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPlayerController_Smite>();
	}
};
static_assert(alignof(AHWPlayerController_Smite) == 0x000008, "Wrong alignment on AHWPlayerController_Smite");
static_assert(sizeof(AHWPlayerController_Smite) == 0x001168, "Wrong size on AHWPlayerController_Smite");
static_assert(offsetof(AHWPlayerController_Smite, GamepadTurnAccelTarget) == 0x000FFC, "Member 'AHWPlayerController_Smite::GamepadTurnAccelTarget' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, GamepadTurnAccelSpeed) == 0x001000, "Member 'AHWPlayerController_Smite::GamepadTurnAccelSpeed' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, GamepadTurnAccelExponent) == 0x001004, "Member 'AHWPlayerController_Smite::GamepadTurnAccelExponent' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, DeathPostProcessCamModClass) == 0x001028, "Member 'AHWPlayerController_Smite::DeathPostProcessCamModClass' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, DeathPostProcessCamMod) == 0x001030, "Member 'AHWPlayerController_Smite::DeathPostProcessCamMod' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, OnDeathSpectatorStatusChanged) == 0x001040, "Member 'AHWPlayerController_Smite::OnDeathSpectatorStatusChanged' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, bIsDeathSpectating) == 0x001050, "Member 'AHWPlayerController_Smite::bIsDeathSpectating' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, DeathSpecatorCameraModClass) == 0x001058, "Member 'AHWPlayerController_Smite::DeathSpecatorCameraModClass' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, DeathSpectatorCameraMod) == 0x001060, "Member 'AHWPlayerController_Smite::DeathSpectatorCameraMod' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, IntoxicatedRotationError) == 0x001068, "Member 'AHWPlayerController_Smite::IntoxicatedRotationError' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, CameraPitchAim) == 0x001078, "Member 'AHWPlayerController_Smite::CameraPitchAim' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, bUseRestrictedCameraPitch) == 0x001080, "Member 'AHWPlayerController_Smite::bUseRestrictedCameraPitch' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, CameraZoomSmoothSpeed) == 0x0010A0, "Member 'AHWPlayerController_Smite::CameraZoomSmoothSpeed' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, CameraZoomSpeed) == 0x0010A4, "Member 'AHWPlayerController_Smite::CameraZoomSpeed' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, SpringArmLength) == 0x0010AC, "Member 'AHWPlayerController_Smite::SpringArmLength' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, SpringArmLengthBase) == 0x0010B0, "Member 'AHWPlayerController_Smite::SpringArmLengthBase' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, SocketOffset) == 0x0010B8, "Member 'AHWPlayerController_Smite::SocketOffset' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, SocketOffsetBase) == 0x0010D0, "Member 'AHWPlayerController_Smite::SocketOffsetBase' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ClassicSpringArmLength) == 0x0010E8, "Member 'AHWPlayerController_Smite::ClassicSpringArmLength' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ClassicSpringArmLengthBase) == 0x0010EC, "Member 'AHWPlayerController_Smite::ClassicSpringArmLengthBase' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ClassicSocketOffset) == 0x0010F0, "Member 'AHWPlayerController_Smite::ClassicSocketOffset' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ClassicSocketOffsetBase) == 0x001108, "Member 'AHWPlayerController_Smite::ClassicSocketOffsetBase' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ClassicFOV) == 0x001120, "Member 'AHWPlayerController_Smite::ClassicFOV' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ClassicFOVConstraint) == 0x001124, "Member 'AHWPlayerController_Smite::ClassicFOVConstraint' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ActionSpringArmLength) == 0x001128, "Member 'AHWPlayerController_Smite::ActionSpringArmLength' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ActionSpringArmLengthBase) == 0x00112C, "Member 'AHWPlayerController_Smite::ActionSpringArmLengthBase' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ActionSocketOffset) == 0x001130, "Member 'AHWPlayerController_Smite::ActionSocketOffset' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ActionSocketOffsetBase) == 0x001148, "Member 'AHWPlayerController_Smite::ActionSocketOffsetBase' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ActionFOV) == 0x001160, "Member 'AHWPlayerController_Smite::ActionFOV' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Smite, ActionFOVConstraint) == 0x001164, "Member 'AHWPlayerController_Smite::ActionFOVConstraint' has a wrong offset!");

// Class Hemingway.HWPlayerController_Spectator
// 0x0180 (0x1178 - 0x0FF8)
class AHWPlayerController_Spectator : public AHWPlayerController
{
public:
	float                                         NetRelevancyViewDistanceSquared;                   // 0x0FF8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FFC[0x1D];                                     // 0x0FFC(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCameraFocused;                                  // 0x1019(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePlayerCameraViewpoint;                         // 0x101A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101B[0x9];                                     // 0x101B(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraZoomSmoothSpeed;                             // 0x1024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraZoomSpeed;                                   // 0x1028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_102C[0x8];                                     // 0x102C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpectatorSpringArmLengthBase;                      // 0x1034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpectatorSpringArmLengthZoomed;                    // 0x1038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_103C[0x1C];                                    // 0x103C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpectatorTargetOffsetBase;                         // 0x1058(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SpectatorTargetOffsetZoomed;                       // 0x1070(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1088[0x4];                                     // 0x1088(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpectatorCameraFOVBase;                            // 0x108C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpectatorCameraFOVZoomed;                          // 0x1090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1094[0x4];                                     // 0x1094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpectatorFixedPitchBase;                           // 0x1098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpectatorFixedPitchZoomed;                         // 0x109C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAngleFromChaosBaseInOverheadView;               // 0x10A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A4[0x1];                                     // 0x10A4(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideViewDistanceScale;                        // 0x10A5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10A6[0x2];                                     // 0x10A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewDistanceScale;                                 // 0x10A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10AC[0x4];                                     // 0x10AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideForceLOD;                                 // 0x10B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10B1[0x3];                                     // 0x10B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ForceLOD;                                          // 0x10B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10B8[0x4];                                     // 0x10B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideLODDistanceScale;                         // 0x10BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10BD[0x3];                                     // 0x10BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LODDistanceScale;                                  // 0x10C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C4[0x4];                                     // 0x10C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideGrassCullDistanceScale;                   // 0x10C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C9[0x3];                                     // 0x10C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrassCullDistanceScale;                            // 0x10CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D0[0x4];                                     // 0x10D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideFoliageCullDistanceScale;                 // 0x10D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D5[0x3];                                     // 0x10D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FoliageCullDistanceScale;                          // 0x10D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10DC[0x4];                                     // 0x10DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* NewPlayerState)> OnSpectatorViewTargetChanged; // 0x10E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	int32                                         nSpectateTargetIndex;                              // 0x10F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F4[0x4];                                     // 0x10F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpectateTargetInfo                    CachedSpectateTargetInfo;                          // 0x10F8(0x0048)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	double                                        LastAutoSelectSpectateTargetTimestamp;             // 0x1140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        AutoSelectSpectateTargetPeriod;                    // 0x1148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        SpectateTargetSwapOnDeathDelayInSecs;              // 0x1150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1158[0x8];                                     // 0x1158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DemoSmallJumpForward;                              // 0x1160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DemoSmallJumpBackward;                             // 0x1164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DemoLargeJumpForward;                              // 0x1168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DemoLargeJumpBackward;                             // 0x116C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DemoSpeedUpAmount;                                 // 0x1170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DemoSpeedDownAmount;                               // 0x1174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DumpSpectatorDebugInfo();
	void OnRep_IsCameraFocused();
	void OnRep_SpectateTargetIndex();
	void OnSpectateTargetCanSpectateStatusChanged(class AHWCharacter_Base* TargetCharacter, const bool bCanSpectate);
	void RequestMinimapCanvasWidgetDebugDump();
	void ResetDisplayInfos();
	void SelectNextViewTarget();
	void SelectPrevViewTarget();
	void SelectViewTargetByIndex(int32 Index_0);
	void SelectViewTargetByPlayerState(class AHWPlayerState* Target);
	void ServerCycleNextSpectatorTarget(bool Reverse);
	void ServerRequestSpectatorTarget(int32 DesiredSpectateIndex);
	void ServerRequestSpectatorTargetByPlayerState(class AHWPlayerState* Target);
	void ServerSetCameraFocused(bool Enabled);
	void ToggleCameraFocused();
	void TogglePlayerCameraView();

	float GetCurrentCameraZoom() const;
	class AHWPlayerState* GetTargetPlayerState() const;
	bool IsCameraFocused() const;
	bool IsSpectatingPlayerView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerController_Spectator">();
	}
	static class AHWPlayerController_Spectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPlayerController_Spectator>();
	}
};
static_assert(alignof(AHWPlayerController_Spectator) == 0x000008, "Wrong alignment on AHWPlayerController_Spectator");
static_assert(sizeof(AHWPlayerController_Spectator) == 0x001178, "Wrong size on AHWPlayerController_Spectator");
static_assert(offsetof(AHWPlayerController_Spectator, NetRelevancyViewDistanceSquared) == 0x000FF8, "Member 'AHWPlayerController_Spectator::NetRelevancyViewDistanceSquared' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, bIsCameraFocused) == 0x001019, "Member 'AHWPlayerController_Spectator::bIsCameraFocused' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, bUsePlayerCameraViewpoint) == 0x00101A, "Member 'AHWPlayerController_Spectator::bUsePlayerCameraViewpoint' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, CameraZoomSmoothSpeed) == 0x001024, "Member 'AHWPlayerController_Spectator::CameraZoomSmoothSpeed' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, CameraZoomSpeed) == 0x001028, "Member 'AHWPlayerController_Spectator::CameraZoomSpeed' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, SpectatorSpringArmLengthBase) == 0x001034, "Member 'AHWPlayerController_Spectator::SpectatorSpringArmLengthBase' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, SpectatorSpringArmLengthZoomed) == 0x001038, "Member 'AHWPlayerController_Spectator::SpectatorSpringArmLengthZoomed' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, SpectatorTargetOffsetBase) == 0x001058, "Member 'AHWPlayerController_Spectator::SpectatorTargetOffsetBase' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, SpectatorTargetOffsetZoomed) == 0x001070, "Member 'AHWPlayerController_Spectator::SpectatorTargetOffsetZoomed' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, SpectatorCameraFOVBase) == 0x00108C, "Member 'AHWPlayerController_Spectator::SpectatorCameraFOVBase' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, SpectatorCameraFOVZoomed) == 0x001090, "Member 'AHWPlayerController_Spectator::SpectatorCameraFOVZoomed' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, SpectatorFixedPitchBase) == 0x001098, "Member 'AHWPlayerController_Spectator::SpectatorFixedPitchBase' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, SpectatorFixedPitchZoomed) == 0x00109C, "Member 'AHWPlayerController_Spectator::SpectatorFixedPitchZoomed' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, MaxAngleFromChaosBaseInOverheadView) == 0x0010A0, "Member 'AHWPlayerController_Spectator::MaxAngleFromChaosBaseInOverheadView' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, bOverrideViewDistanceScale) == 0x0010A5, "Member 'AHWPlayerController_Spectator::bOverrideViewDistanceScale' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, ViewDistanceScale) == 0x0010A8, "Member 'AHWPlayerController_Spectator::ViewDistanceScale' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, bOverrideForceLOD) == 0x0010B0, "Member 'AHWPlayerController_Spectator::bOverrideForceLOD' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, ForceLOD) == 0x0010B4, "Member 'AHWPlayerController_Spectator::ForceLOD' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, bOverrideLODDistanceScale) == 0x0010BC, "Member 'AHWPlayerController_Spectator::bOverrideLODDistanceScale' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, LODDistanceScale) == 0x0010C0, "Member 'AHWPlayerController_Spectator::LODDistanceScale' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, bOverrideGrassCullDistanceScale) == 0x0010C8, "Member 'AHWPlayerController_Spectator::bOverrideGrassCullDistanceScale' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, GrassCullDistanceScale) == 0x0010CC, "Member 'AHWPlayerController_Spectator::GrassCullDistanceScale' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, bOverrideFoliageCullDistanceScale) == 0x0010D4, "Member 'AHWPlayerController_Spectator::bOverrideFoliageCullDistanceScale' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, FoliageCullDistanceScale) == 0x0010D8, "Member 'AHWPlayerController_Spectator::FoliageCullDistanceScale' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, OnSpectatorViewTargetChanged) == 0x0010E0, "Member 'AHWPlayerController_Spectator::OnSpectatorViewTargetChanged' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, nSpectateTargetIndex) == 0x0010F0, "Member 'AHWPlayerController_Spectator::nSpectateTargetIndex' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, CachedSpectateTargetInfo) == 0x0010F8, "Member 'AHWPlayerController_Spectator::CachedSpectateTargetInfo' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, LastAutoSelectSpectateTargetTimestamp) == 0x001140, "Member 'AHWPlayerController_Spectator::LastAutoSelectSpectateTargetTimestamp' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, AutoSelectSpectateTargetPeriod) == 0x001148, "Member 'AHWPlayerController_Spectator::AutoSelectSpectateTargetPeriod' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, SpectateTargetSwapOnDeathDelayInSecs) == 0x001150, "Member 'AHWPlayerController_Spectator::SpectateTargetSwapOnDeathDelayInSecs' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, DemoSmallJumpForward) == 0x001160, "Member 'AHWPlayerController_Spectator::DemoSmallJumpForward' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, DemoSmallJumpBackward) == 0x001164, "Member 'AHWPlayerController_Spectator::DemoSmallJumpBackward' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, DemoLargeJumpForward) == 0x001168, "Member 'AHWPlayerController_Spectator::DemoLargeJumpForward' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, DemoLargeJumpBackward) == 0x00116C, "Member 'AHWPlayerController_Spectator::DemoLargeJumpBackward' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, DemoSpeedUpAmount) == 0x001170, "Member 'AHWPlayerController_Spectator::DemoSpeedUpAmount' has a wrong offset!");
static_assert(offsetof(AHWPlayerController_Spectator, DemoSpeedDownAmount) == 0x001174, "Member 'AHWPlayerController_Spectator::DemoSpeedDownAmount' has a wrong offset!");

// Class Hemingway.HWPlayerState
// 0x0288 (0x0618 - 0x0390)
class AHWPlayerState : public ARHPlayerState
{
public:
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, const struct FGuid& NewUuid)> OnRHPlayerUuidReplicated; // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsGM;                                             // 0x03B0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EOSProductUserIdString;                            // 0x03B8(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, class AHWCharacterAbilitySystemActor* NewASActor)> OnAbilitySystemActorChanged; // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, EAbilityCastStyle NewAbilityCastStyle)> OnAbilityCastStyleChanged; // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 InDoubleTapToFireSetting)> OnDoubleTapToFireSettingChanged; // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         AbilitySystemActor;                                // 0x0400(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityCastStyle                             AbilityCastStyle;                                  // 0x0408(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DoubleTapToFireSettingValue;                       // 0x040C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWCharacterItem*                       DraftCharacterChoice;                              // 0x0410(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWSkinItem>             DraftSkinChoice;                                   // 0x0418(0x0028)(Net, Transient, RepNotify, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWEquipmentItem>        DraftTalentChoice;                                 // 0x0440(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, const class UHWCharacterItem* Choice)> OnDraftCharacterChoiceReplicated; // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, TSoftObjectPtr<class UHWSkinItem> Choice)> OnDraftSkinChoiceReplicated; // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, class AHWPlayerStatsTracker* PlayerStatsTracker)> OnPlayerStatsTrackerReplicated; // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AHWPlayerStatsTracker>   PlayerStatsTracker;                                // 0x0498(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x10];                                     // 0x04A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState)> OnUIRelevantPlayerStateChangedDel; // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C0[0x18];                                     // 0x04C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUIRelevant;                                       // 0x04D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(ECharacterRole AssignedRole)> OnAssignedRoleChanged;               // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHWAssignedRolesMapWrapper& CachedPlayerPlayedRoles)> OnAllPlayedRolesUpdated; // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ECharacterRole                                AssignedRole;                                      // 0x0500(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAssignedRoleRetrieved;                            // 0x0501(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_502[0x6];                                      // 0x0502(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWAssignedRolesMapWrapper             CachedPlayerPlayedRoles;                           // 0x0508(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnClientLoadStateChanged;                          // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EHWClientLoadState                            PlayerClientLoadState;                             // 0x0538(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_539[0xF];                                      // 0x0539(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraParameterCollection*            NiagaraOpacitySettingsCollection;                  // 0x0548(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraParameterCollection*            NiagaraGeneralSettingsCollection;                  // 0x0550(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x38];                                     // 0x0558(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWPlayerState*>                 PlayersRejectedTradeList;                          // 0x0590(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	EHWTradeRequestResult                         LastTradeResultReceived;                           // 0x05A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A1[0x7];                                      // 0x05A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, bool bNewIsOvertakenByAI)> OnAIOvertakeStatusChanged; // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsOvertakenByAI;                                  // 0x05B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B9[0x3];                                      // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CachedPhaseOnDisconnect;                           // 0x05BC(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisconnectedDuration;                              // 0x05C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentDisconnectedStartTime;                      // 0x05C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, const struct FHWRankData& RankData)> OnRankDataChanged; // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHWRankData                            RankData;                                          // 0x05E0(0x0008)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, float StartingSkillRating)> OnStartingSkillRatingSet; // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         StartingSkillRating;                               // 0x05F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x14];                                     // 0x05FC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	EHWVIPOwnershipLevel                          VIPOwnershipLevel;                                 // 0x0610(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x7];                                      // 0x0611(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePlayerRolesAssigned();
	void Multicast_ForceUpdateCharacterPawn(class APawn* NewPawn);
	void MulticastReceiveTradeRequestResult(class AHWPlayerState* RequestingPlayerState, class AHWPlayerState* TargetPlayerState, EHWTradeRequestType TradeType, EHWTradeRequestResult TradeResult, const struct FPGame_ReplicatedTimerId& TimerId);
	void On3DTargeterEnabledSettingUpdated();
	void OnAutoSkillComponentUpdated(class AHWCharacterAbilitySystemActor* CharAbilitySysActor, class UHWAutoSkillComponent* AutoSkillComponent);
	void OnAutoSkillSettingUpdated();
	void OnDisableJumpSettingUpdated();
	void OnDistanceLineIndicatorSettingUpdated();
	void OnGodBuildLoaded(bool bSuccessfullyRetrieved, const struct FHWGodBuild& GodBuild, const bool bEnableAutoBuy, const bool bEnableAutoSkill);
	void OnGroundTargetHelperSettingUpdated();
	void OnNonLocalClientLoadStateChanged();
	void OnPlayerSettingsInitialized();
	void OnRep_AbilityCastStyle();
	void OnRep_AbilitySystemActor();
	void OnRep_AllPlayedRoles();
	void OnRep_AssignedRole();
	void OnRep_DoubleTapToFireSetting();
	void OnRep_DraftCharacterChoice();
	void OnRep_DraftSkinChoice();
	void OnRep_IsOvertakenByAI();
	void OnRep_PlayerStatsTracker();
	void OnRep_RankData();
	void OnRep_RejectedTradeList();
	void OnRep_StartingSkillRating();
	void OnRep_VIPOwnershipLevel();
	void OnSeamlessTravelStart(class UWorld* CurrentWorld, const class FString& LevelName);
	void OnVFXEffectsQualitySettingsUpdated();
	void OnVFXOpacitySettingsUpdated();
	void ServerAutoUpgradeSystemBuildSelected(const struct FGuid& SelectedBuildId, const bool bEnableAutoBuy, const bool bEnableAutoSkill);
	void ServerDeclineCharacterSwap(class AHWPlayerState* TargetPlayerState);
	void ServerDeclineRoleSwap(class AHWPlayerState* TargetPlayerState);
	void ServerRequestCharacterRole(ECharacterRole CharacterRole);
	void ServerRequestCharacterSwap(class AHWPlayerState* TargetPlayerState);
	void ServerRequestDraftCharacterChoice(const class UHWCharacterItem* Choice);
	void ServerRequestDraftSkinChoice(const class UHWSkinItem* Choice);
	void ServerRequestRoleSwap(class AHWPlayerState* TargetPlayerState);
	void ServerSetAbilityCastStyle(EAbilityCastStyle DesiredCastStyle);
	void ServerSetClientLoadedStatus(EHWClientLoadState ClientLoadState);
	void ServerSetDoubleTapToFireSetting(int32 DesiredDoubleTapToFireSettingValue);
	void ServerSetupManualBuild(const bool bEnableAutoSkill);
	void SetAbilitySystemActor(class AHWCharacterAbilitySystemActor* NewActor);
	void SetDraftCharacterChoice(const class UHWCharacterItem* NewChoice);
	void SetSkillRatingDelta(int32 InSkillRatingDelta);
	void SetStartingSkillRating(int32 InStartingSkillRating);
	void TryToBroadCastUIRelevantInfoHasChanged();
	void UpdateCastMode();
	void UpdateDoubleTapToFireSetting();

	bool CanRequestTradeWith(const class AHWPlayerState* TradeTarget) const;
	EAbilityCastStyle GetAbilityCastStyle() const;
	class UAbilitySystemComponent* GetAbilitySystemComponent() const;
	class AActor* GetActorBase() const;
	struct FHWAssignedRolesMapWrapper GetAllPlayedRoles() const;
	ECharacterRole GetAssignedRole() const;
	class AHWCharacterAbilitySystemActor* GetCharacterAbilitySystemActor() const;
	class AHWCharacter_Base* GetCharacterBase() const;
	const class UHWCharacterItem* GetDraftCharacterChoice() const;
	class UHWAbilitySystemComponent* GetHWAbilitySystemComponent() const;
	bool GetIsOvertakenByAI() const;
	EHWTradeRequestResult GetLastTradeResultReceived() const;
	const struct FHWPersistentPlayerId GetPersistentPlayerId() const;
	class AHWPlayerStatsTracker* GetPlayerStatsTracker() const;
	const struct FHWRankData GetRankData() const;
	int32 GetSkillRatingDelta() const;
	int32 GetStartingSkillRating() const;
	class AHWTeamState* GetTeam() const;
	bool IsJumpDisabled() const;
	bool IsUIRelevant() const;
	bool MatchesPersistentPlayerId(const struct FHWPersistentPlayerId& ComparisonId) const;
	void ServerSendChatEntry(const struct FHWChatEntry& ChatEntry) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerState">();
	}
	static class AHWPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPlayerState>();
	}
};
static_assert(alignof(AHWPlayerState) == 0x000008, "Wrong alignment on AHWPlayerState");
static_assert(sizeof(AHWPlayerState) == 0x000618, "Wrong size on AHWPlayerState");
static_assert(offsetof(AHWPlayerState, OnRHPlayerUuidReplicated) == 0x0003A0, "Member 'AHWPlayerState::OnRHPlayerUuidReplicated' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, bIsGM) == 0x0003B0, "Member 'AHWPlayerState::bIsGM' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, EOSProductUserIdString) == 0x0003B8, "Member 'AHWPlayerState::EOSProductUserIdString' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnAbilitySystemActorChanged) == 0x0003D0, "Member 'AHWPlayerState::OnAbilitySystemActorChanged' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnAbilityCastStyleChanged) == 0x0003E0, "Member 'AHWPlayerState::OnAbilityCastStyleChanged' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnDoubleTapToFireSettingChanged) == 0x0003F0, "Member 'AHWPlayerState::OnDoubleTapToFireSettingChanged' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, AbilitySystemActor) == 0x000400, "Member 'AHWPlayerState::AbilitySystemActor' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, AbilityCastStyle) == 0x000408, "Member 'AHWPlayerState::AbilityCastStyle' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, DoubleTapToFireSettingValue) == 0x00040C, "Member 'AHWPlayerState::DoubleTapToFireSettingValue' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, DraftCharacterChoice) == 0x000410, "Member 'AHWPlayerState::DraftCharacterChoice' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, DraftSkinChoice) == 0x000418, "Member 'AHWPlayerState::DraftSkinChoice' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, DraftTalentChoice) == 0x000440, "Member 'AHWPlayerState::DraftTalentChoice' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnDraftCharacterChoiceReplicated) == 0x000468, "Member 'AHWPlayerState::OnDraftCharacterChoiceReplicated' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnDraftSkinChoiceReplicated) == 0x000478, "Member 'AHWPlayerState::OnDraftSkinChoiceReplicated' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnPlayerStatsTrackerReplicated) == 0x000488, "Member 'AHWPlayerState::OnPlayerStatsTrackerReplicated' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, PlayerStatsTracker) == 0x000498, "Member 'AHWPlayerState::PlayerStatsTracker' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnUIRelevantPlayerStateChangedDel) == 0x0004B0, "Member 'AHWPlayerState::OnUIRelevantPlayerStateChangedDel' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, bUIRelevant) == 0x0004D8, "Member 'AHWPlayerState::bUIRelevant' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnAssignedRoleChanged) == 0x0004E0, "Member 'AHWPlayerState::OnAssignedRoleChanged' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnAllPlayedRolesUpdated) == 0x0004F0, "Member 'AHWPlayerState::OnAllPlayedRolesUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, AssignedRole) == 0x000500, "Member 'AHWPlayerState::AssignedRole' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, bAssignedRoleRetrieved) == 0x000501, "Member 'AHWPlayerState::bAssignedRoleRetrieved' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, CachedPlayerPlayedRoles) == 0x000508, "Member 'AHWPlayerState::CachedPlayerPlayedRoles' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnClientLoadStateChanged) == 0x000528, "Member 'AHWPlayerState::OnClientLoadStateChanged' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, PlayerClientLoadState) == 0x000538, "Member 'AHWPlayerState::PlayerClientLoadState' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, NiagaraOpacitySettingsCollection) == 0x000548, "Member 'AHWPlayerState::NiagaraOpacitySettingsCollection' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, NiagaraGeneralSettingsCollection) == 0x000550, "Member 'AHWPlayerState::NiagaraGeneralSettingsCollection' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, PlayersRejectedTradeList) == 0x000590, "Member 'AHWPlayerState::PlayersRejectedTradeList' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, LastTradeResultReceived) == 0x0005A0, "Member 'AHWPlayerState::LastTradeResultReceived' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnAIOvertakeStatusChanged) == 0x0005A8, "Member 'AHWPlayerState::OnAIOvertakeStatusChanged' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, bIsOvertakenByAI) == 0x0005B8, "Member 'AHWPlayerState::bIsOvertakenByAI' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, CachedPhaseOnDisconnect) == 0x0005BC, "Member 'AHWPlayerState::CachedPhaseOnDisconnect' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, DisconnectedDuration) == 0x0005C4, "Member 'AHWPlayerState::DisconnectedDuration' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, CurrentDisconnectedStartTime) == 0x0005C8, "Member 'AHWPlayerState::CurrentDisconnectedStartTime' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnRankDataChanged) == 0x0005D0, "Member 'AHWPlayerState::OnRankDataChanged' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, RankData) == 0x0005E0, "Member 'AHWPlayerState::RankData' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, OnStartingSkillRatingSet) == 0x0005E8, "Member 'AHWPlayerState::OnStartingSkillRatingSet' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, StartingSkillRating) == 0x0005F8, "Member 'AHWPlayerState::StartingSkillRating' has a wrong offset!");
static_assert(offsetof(AHWPlayerState, VIPOwnershipLevel) == 0x000610, "Member 'AHWPlayerState::VIPOwnershipLevel' has a wrong offset!");

// Class Hemingway.HWQuestSubsystem
// 0x02A8 (0x02D8 - 0x0030)
class UHWQuestSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<class UHWQuest*>                       CachedActiveQuests;                                // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UHWCharacterItem*, struct FQuestContainer> CachedActiveGodQuests;                     // 0x0040(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHWQuest*>                       FullListOfQuests;                                  // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class UHWCharacterItem*, struct FQuestContainer> FullListOfGodQuests;                       // 0x00A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FPlayerActiveQuests>            ActivePlayerQuests;                                // 0x00F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 QuestVendorIds;                                    // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              QuestsTableSoftPtr;                                // 0x0118(0x0028)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              DailyQuestsTableSoftPtr;                           // 0x0140(0x0028)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UHWQuest>>        QuestItemsToLoad;                                  // 0x0168(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UDataTable>>      QuestTablesToLoad;                                 // 0x0178(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class UDataTable*>                       LoadedQuestTables;                                 // 0x0188(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class UHWCharacterItem*, TSoftObjectPtr<class UDataTable>> GodQuestTables;                  // 0x01D8(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x28];                                     // 0x0228(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuestBatchSubmissionFrequency;                     // 0x0250(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x2C];                                     // 0x0254(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FPlayerQuestPendingInventory> PendingInventoryOrders;                  // 0x0280(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetQuestTierByCount(const class UObject* WorldContextObject, const class UHWQuest* QuestItem, int32 ProgressCount);

	void ActivateQuests();
	void FinishMatchAndFlushQuests();
	void InitializeQuestsForPlayer(class AHWPlayerState* Player);
	void OnInventoryCachedForPlayer(bool bSuccessfullyLoaded);
	void OnRHSessionChanged(class URH_JoinedSession* OldSession, class URH_JoinedSession* ActiveSession);
	void QueueNewQuestInventoryRequest(const struct FGuid& RHPlayerId, class URH_PlayerOrderEntry* RHPlayerOrder);
	void QueueNewQuestInventoryRequests(const struct FGuid& RHPlayerId, const TArray<class URH_PlayerOrderEntry*>& RHPlayerOrders);
	void ThreadSafeSubmitPendingInventoryRequests();
	void TimerBatchQuestUpdates();

	bool FindGodQuestEntry(struct FGodQuestEntry* OutGodQuestEntry, const class UHWCharacterItem* CharacterItem, const class UHWQuest* QuestItem) const;
	const class UHWQuest* GetQuest(const struct FRH_ItemId& QuestItemId, const class UHWCharacterItem* CharacterItem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuestSubsystem">();
	}
	static class UHWQuestSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuestSubsystem>();
	}
};
static_assert(alignof(UHWQuestSubsystem) == 0x000008, "Wrong alignment on UHWQuestSubsystem");
static_assert(sizeof(UHWQuestSubsystem) == 0x0002D8, "Wrong size on UHWQuestSubsystem");
static_assert(offsetof(UHWQuestSubsystem, CachedActiveQuests) == 0x000030, "Member 'UHWQuestSubsystem::CachedActiveQuests' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, CachedActiveGodQuests) == 0x000040, "Member 'UHWQuestSubsystem::CachedActiveGodQuests' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, FullListOfQuests) == 0x000098, "Member 'UHWQuestSubsystem::FullListOfQuests' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, FullListOfGodQuests) == 0x0000A8, "Member 'UHWQuestSubsystem::FullListOfGodQuests' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, ActivePlayerQuests) == 0x0000F8, "Member 'UHWQuestSubsystem::ActivePlayerQuests' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, QuestVendorIds) == 0x000108, "Member 'UHWQuestSubsystem::QuestVendorIds' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, QuestsTableSoftPtr) == 0x000118, "Member 'UHWQuestSubsystem::QuestsTableSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, DailyQuestsTableSoftPtr) == 0x000140, "Member 'UHWQuestSubsystem::DailyQuestsTableSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, QuestItemsToLoad) == 0x000168, "Member 'UHWQuestSubsystem::QuestItemsToLoad' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, QuestTablesToLoad) == 0x000178, "Member 'UHWQuestSubsystem::QuestTablesToLoad' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, LoadedQuestTables) == 0x000188, "Member 'UHWQuestSubsystem::LoadedQuestTables' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, GodQuestTables) == 0x0001D8, "Member 'UHWQuestSubsystem::GodQuestTables' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, QuestBatchSubmissionFrequency) == 0x000250, "Member 'UHWQuestSubsystem::QuestBatchSubmissionFrequency' has a wrong offset!");
static_assert(offsetof(UHWQuestSubsystem, PendingInventoryOrders) == 0x000280, "Member 'UHWQuestSubsystem::PendingInventoryOrders' has a wrong offset!");

// Class Hemingway.HWQuest_BotProficiency
// 0x0008 (0x0098 - 0x0090)
class UHWQuest_BotProficiency final : public UHWActiveQuest
{
public:
	struct FGameplayTag                           AwardAfterPhase;                                   // 0x0090(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GamePhaseEnded(const struct FGameplayTag& EndingPhaseTag);
	int32 GetBotProficiencyFor(const class AHWPlayerController* TrackedPlayer);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_BotProficiency">();
	}
	static class UHWQuest_BotProficiency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_BotProficiency>();
	}
};
static_assert(alignof(UHWQuest_BotProficiency) == 0x000008, "Wrong alignment on UHWQuest_BotProficiency");
static_assert(sizeof(UHWQuest_BotProficiency) == 0x000098, "Wrong size on UHWQuest_BotProficiency");
static_assert(offsetof(UHWQuest_BotProficiency, AwardAfterPhase) == 0x000090, "Member 'UHWQuest_BotProficiency::AwardAfterPhase' has a wrong offset!");

// Class Hemingway.HWQuest_KillsByType
// 0x0090 (0x0120 - 0x0090)
class UHWQuest_KillsByType : public UHWActiveQuest
{
public:
	struct FGameplayTagRequirements               TargetRequirements;                                // 0x0090(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bTrackAssists;                                     // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTrackKills;                                       // 0x0119(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerAssistGranted(const struct FAssistEventData& AssistEventData);
	void OnPlayerKillGranted(const struct FDamageEventData& KillEventData);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_KillsByType">();
	}
	static class UHWQuest_KillsByType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_KillsByType>();
	}
};
static_assert(alignof(UHWQuest_KillsByType) == 0x000008, "Wrong alignment on UHWQuest_KillsByType");
static_assert(sizeof(UHWQuest_KillsByType) == 0x000120, "Wrong size on UHWQuest_KillsByType");
static_assert(offsetof(UHWQuest_KillsByType, TargetRequirements) == 0x000090, "Member 'UHWQuest_KillsByType::TargetRequirements' has a wrong offset!");
static_assert(offsetof(UHWQuest_KillsByType, bTrackAssists) == 0x000118, "Member 'UHWQuest_KillsByType::bTrackAssists' has a wrong offset!");
static_assert(offsetof(UHWQuest_KillsByType, bTrackKills) == 0x000119, "Member 'UHWQuest_KillsByType::bTrackKills' has a wrong offset!");

// Class Hemingway.HWQuest_LastPlayerAlive
// 0x0000 (0x0090 - 0x0090)
class UHWQuest_LastPlayerAlive final : public UHWActiveQuest
{
public:
	void OnPlayerDied(const struct FDamageEventData& KillEventData);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_LastPlayerAlive">();
	}
	static class UHWQuest_LastPlayerAlive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_LastPlayerAlive>();
	}
};
static_assert(alignof(UHWQuest_LastPlayerAlive) == 0x000008, "Wrong alignment on UHWQuest_LastPlayerAlive");
static_assert(sizeof(UHWQuest_LastPlayerAlive) == 0x000090, "Wrong size on UHWQuest_LastPlayerAlive");

// Class Hemingway.HWQuest_MatchesCompleteMinLevel
// 0x0010 (0x00A0 - 0x0090)
class UHWQuest_MatchesCompleteMinLevel : public UHWActiveQuest
{
public:
	int32                                         MatchLevel;                                        // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RequiresWins;                                      // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AwardAfterPhase;                                   // 0x0098(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GamePhaseEnded(const struct FGameplayTag& EndingPhaseTag);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_MatchesCompleteMinLevel">();
	}
	static class UHWQuest_MatchesCompleteMinLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_MatchesCompleteMinLevel>();
	}
};
static_assert(alignof(UHWQuest_MatchesCompleteMinLevel) == 0x000008, "Wrong alignment on UHWQuest_MatchesCompleteMinLevel");
static_assert(sizeof(UHWQuest_MatchesCompleteMinLevel) == 0x0000A0, "Wrong size on UHWQuest_MatchesCompleteMinLevel");
static_assert(offsetof(UHWQuest_MatchesCompleteMinLevel, MatchLevel) == 0x000090, "Member 'UHWQuest_MatchesCompleteMinLevel::MatchLevel' has a wrong offset!");
static_assert(offsetof(UHWQuest_MatchesCompleteMinLevel, RequiresWins) == 0x000094, "Member 'UHWQuest_MatchesCompleteMinLevel::RequiresWins' has a wrong offset!");
static_assert(offsetof(UHWQuest_MatchesCompleteMinLevel, AwardAfterPhase) == 0x000098, "Member 'UHWQuest_MatchesCompleteMinLevel::AwardAfterPhase' has a wrong offset!");

// Class Hemingway.HWQuest_MatchesPlayedInRole
// 0x0010 (0x00A0 - 0x0090)
class UHWQuest_MatchesPlayedInRole final : public UHWActiveQuest
{
public:
	ECharacterRole                                PlayedRole;                                        // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RequiresWins;                                      // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AwardAfterPhase;                                   // 0x0094(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GamePhaseEnded(const struct FGameplayTag& EndingPhaseTag);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_MatchesPlayedInRole">();
	}
	static class UHWQuest_MatchesPlayedInRole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_MatchesPlayedInRole>();
	}
};
static_assert(alignof(UHWQuest_MatchesPlayedInRole) == 0x000008, "Wrong alignment on UHWQuest_MatchesPlayedInRole");
static_assert(sizeof(UHWQuest_MatchesPlayedInRole) == 0x0000A0, "Wrong size on UHWQuest_MatchesPlayedInRole");
static_assert(offsetof(UHWQuest_MatchesPlayedInRole, PlayedRole) == 0x000090, "Member 'UHWQuest_MatchesPlayedInRole::PlayedRole' has a wrong offset!");
static_assert(offsetof(UHWQuest_MatchesPlayedInRole, RequiresWins) == 0x000091, "Member 'UHWQuest_MatchesPlayedInRole::RequiresWins' has a wrong offset!");
static_assert(offsetof(UHWQuest_MatchesPlayedInRole, AwardAfterPhase) == 0x000094, "Member 'UHWQuest_MatchesPlayedInRole::AwardAfterPhase' has a wrong offset!");

// Class Hemingway.HWQuest_TimeInMatch
// 0x0010 (0x00A0 - 0x0090)
class UHWQuest_TimeInMatch final : public UHWActiveQuest
{
public:
	float                                         SecondsPerPoint;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WinMultiplier;                                     // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AwardAfterPhase;                                   // 0x0098(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 CalculateNumberOfPointsToAward(float TimeInMatch, bool bWon);
	void GamePhaseEnded(const struct FGameplayTag& EndingPhaseTag);
	void TrackQuestForPlayer_Implementation(const class UHWQuest* TrackedQuest, class AHWCharacterAbilitySystemActor* CharAbSysActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQuest_TimeInMatch">();
	}
	static class UHWQuest_TimeInMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQuest_TimeInMatch>();
	}
};
static_assert(alignof(UHWQuest_TimeInMatch) == 0x000008, "Wrong alignment on UHWQuest_TimeInMatch");
static_assert(sizeof(UHWQuest_TimeInMatch) == 0x0000A0, "Wrong size on UHWQuest_TimeInMatch");
static_assert(offsetof(UHWQuest_TimeInMatch, SecondsPerPoint) == 0x000090, "Member 'UHWQuest_TimeInMatch::SecondsPerPoint' has a wrong offset!");
static_assert(offsetof(UHWQuest_TimeInMatch, WinMultiplier) == 0x000094, "Member 'UHWQuest_TimeInMatch::WinMultiplier' has a wrong offset!");
static_assert(offsetof(UHWQuest_TimeInMatch, AwardAfterPhase) == 0x000098, "Member 'UHWQuest_TimeInMatch::AwardAfterPhase' has a wrong offset!");

// Class Hemingway.HWPartyManager
// 0x0000 (0x0290 - 0x0290)
class UHWPartyManager final : public URHPartyManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPartyManager">();
	}
	static class UHWPartyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPartyManager>();
	}
};
static_assert(alignof(UHWPartyManager) == 0x000008, "Wrong alignment on UHWPartyManager");
static_assert(sizeof(UHWPartyManager) == 0x000290, "Wrong size on UHWPartyManager");

// Class Hemingway.HWQueueDataFactory
// 0x0020 (0x02F0 - 0x02D0)
class UHWQueueDataFactory final : public URHQueueDataFactory
{
public:
	bool                                          bUsingAltQueue;                                    // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x17];                                     // 0x02D1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLackOfPvEProgressRedirects;                       // 0x02E8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCustomBotEnabled;                               // 0x02E9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EA[0x6];                                      // 0x02EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCustomBot(int32 TeamNum, const struct FRH_ItemId& CharacterItemId, const EHWBotDifficulty& Difficulty);
	bool AssessQueueItemOwnershipRequirement(const class FString& InQueuId, TDelegate<void(const class FString& QueueId, const bool bItemOwned)> Delegate);
	void FillTeamWithRandomBots(int32 TeamNum, EHWBotDifficulty Difficulty);
	void HandlePartyUpdated();
	void HandlePartyUpdatedWithPartyMemberData(const struct FRH_PartyMemberData& PartyMemberData);
	void HandlePartyUpdatedWithUUID(const struct FGuid& PlayerId);
	void HandlePlayerDataReceived();
	void HandleSelectedQueueItemOwnershipCheckCompleted(const class FString& QueueId, bool bItemOwned);
	void RemoveCustomBot(int32 TeamNum, const struct FRH_ItemId& CharacterItemId, const EHWBotDifficulty& Difficulty);
	void SwapTeamCustomBot(int32 TeamNum, const struct FRH_ItemId& CharacterItemId, const EHWBotDifficulty& Difficulty, int32 TeamToSwapTo);

	ERHQueueDisplayState AssessPartySizeForRankedQueue(class URH_MatchmakingQueueInfo* InQueueInfo) const;
	bool GetCurrentCustomLobbyBotConfig(struct FHWCustomBotConfig_Game* OutCustomBotConfig) const;
	void GetCustomLobbyGameModeInfos(TArray<struct FHWGameModeInfo>* OutGameModeInfos) const;
	bool GetCustomSessionGameModeInfo(class URH_SessionView* InSession, struct FHWGameModeInfo* OutGameModeInfo) const;
	class FString GetSavedSelectedQueue() const;
	TArray<class URH_MatchmakingQueueInfo*> GetSortedQueues() const;
	bool IsCustomBotEnabled() const;
	bool IsQueueIdValid(const class FString& InQueueId) const;
	bool IsRankedQueue(class URH_MatchmakingQueueInfo* InQueueInfo) const;
	bool IsRankedQueueById(const class FString& InQueueId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWQueueDataFactory">();
	}
	static class UHWQueueDataFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWQueueDataFactory>();
	}
};
static_assert(alignof(UHWQueueDataFactory) == 0x000008, "Wrong alignment on UHWQueueDataFactory");
static_assert(sizeof(UHWQueueDataFactory) == 0x0002F0, "Wrong size on UHWQueueDataFactory");
static_assert(offsetof(UHWQueueDataFactory, bUsingAltQueue) == 0x0002D0, "Member 'UHWQueueDataFactory::bUsingAltQueue' has a wrong offset!");
static_assert(offsetof(UHWQueueDataFactory, bLackOfPvEProgressRedirects) == 0x0002E8, "Member 'UHWQueueDataFactory::bLackOfPvEProgressRedirects' has a wrong offset!");
static_assert(offsetof(UHWQueueDataFactory, bIsCustomBotEnabled) == 0x0002E9, "Member 'UHWQueueDataFactory::bIsCustomBotEnabled' has a wrong offset!");

// Class Hemingway.HWLibrary_RallyHere
// 0x0000 (0x0028 - 0x0028)
class UHWLibrary_RallyHere final : public UBlueprintFunctionLibrary
{
public:
	static void BLUEPRINT_ClientFillLoot(const class UObject* WorldContextObject, const struct FRH_LootId& LootId, int32 Quantity, const TDelegate<void(const class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerOrderEntry*>& OrderEntries, const struct FRHAPI_PlayerOrder& OrderResult)>& Delegate, bool bRollbackOnFailure);
	static void BLUEPRINT_CreateAndRequestPlayerOrder(class URH_PlayerInfo* PlayerInfo, ERHAPI_PlayerOrderEntryType OrderType, const struct FRH_LootId& LootId, int32 Quantity, const class FString& TransactionId, const TDelegate<void(const class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerOrderEntry*>& OrderEntries, const struct FRHAPI_PlayerOrder& OrderResult)>& Delegate);
	static void BLUEPRINT_GetExpirationDateForItem(const struct FRH_ItemId& ItemId, const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(const struct FDateTime& ExpirationDate)> Delegate);
	static void BLUEPRINT_GetOwnedAmountForItem(const struct FRH_ItemId& ItemId, const class URH_PlayerInfo* PlayerInfo, const TDelegate<void(int32 InstanceCount)> Delegate);
	static void BLUEPRINT_RequestPlayerOrder(class URH_PlayerInfo* PlayerInfo, class URH_PlayerOrderEntry* PlayerOrder, const TDelegate<void(const class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerOrderEntry*>& OrderEntries, const struct FRHAPI_PlayerOrder& OrderResult)>& Delegate);
	static void BLUEPRINT_RequestPlayerOrders(class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerOrderEntry*>& PlayerOrders, const TDelegate<void(const class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerOrderEntry*>& OrderEntries, const struct FRHAPI_PlayerOrder& OrderResult)>& Delegate, bool bRollbackOnFailure);
	static class URH_PlayerOrderEntry* CreatePlayerOrder(ERHAPI_PlayerOrderEntryType OrderType, const struct FRH_LootId& LootId, int32 Quantity, const class FString& TransactionId);
	static void EmitErrorEvent(const class UObject* WorldContextObject, const class FString& EventName, const TArray<struct FHWEventParameterPair>& EventParameters);
	static class URH_JoinedSession* GetActiveSession(const class UObject* WorldContextObject);
	static bool GetActiveSessionTeam(const class URH_JoinedSession* ActiveSession, int32 TeamNum, struct FRHAPI_SessionTeam* OutTeam);
	static struct FDateTime GetCachedExpirationDateForItem(const struct FRH_ItemId& ItemId, const class URH_PlayerInfo* PlayerInfo);
	static int32 GetCachedOwnedAmountForItem(const struct FRH_ItemId& ItemId, const class URH_PlayerInfo* PlayerInfo);
	static class URH_JoinedSession* GetJoinedSessionAsDedicatedServer(const class UGameInstance* GameInstance);
	static class URH_JoinedSession* GetJoinedSessionAsLocalPlayer(const class APlayerController* LocalPlayerController);
	static bool GetLevelInfo(const class UObject* WorldContextObject, const int32& TableId, const int32& XpPoints, struct FHWLevelInfo* OutLevelInfo);
	static bool GetXpPoints(const class UObject* WorldContextObject, const int32& ItemId, int32* XpPoints);
	static bool GetXpTable(const class UObject* WorldContextObject, int32 XpTableId, struct FRHAPI_XpTable* OutXpTable);
	static bool GetXpTableBreakpoints(const class UObject* WorldContextObject, const int32& TableId, TArray<int32>* OutTierBreakpoints);
	static bool GetXpTableFromItem(const class UObject* WorldContextObject, class URHStoreItem* ProgressStoreItem, struct FRHAPI_XpTable* OutXpTable);
	static bool IsInMatchmakeSession(const class URH_JoinedSession* JoinedSession);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLibrary_RallyHere">();
	}
	static class UHWLibrary_RallyHere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLibrary_RallyHere>();
	}
};
static_assert(alignof(UHWLibrary_RallyHere) == 0x000008, "Wrong alignment on UHWLibrary_RallyHere");
static_assert(sizeof(UHWLibrary_RallyHere) == 0x000028, "Wrong size on UHWLibrary_RallyHere");

// Class Hemingway.HWLocalPlayerSessionSubsystem
// 0x0000 (0x0428 - 0x0428)
class UHWLocalPlayerSessionSubsystem final : public URH_LocalPlayerSessionSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLocalPlayerSessionSubsystem">();
	}
	static class UHWLocalPlayerSessionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLocalPlayerSessionSubsystem>();
	}
};
static_assert(alignof(UHWLocalPlayerSessionSubsystem) == 0x000008, "Wrong alignment on UHWLocalPlayerSessionSubsystem");
static_assert(sizeof(UHWLocalPlayerSessionSubsystem) == 0x000428, "Wrong size on UHWLocalPlayerSessionSubsystem");

// Class Hemingway.HWPlayerInfo
// 0x0090 (0x0188 - 0x00F8)
class UHWPlayerInfo final : public URH_PlayerInfo
{
public:
	TMulticastInlineDelegate<void()>              OnLegacyNameStatusUpdatedDelegate;                 // 0x00F8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHasLegacyName;                                    // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLegacyName;                                    // 0x0109(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSettingsLoaded;                                   // 0x010A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B[0x5];                                      // 0x010B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnCachedPlayerLevelUpdated;                        // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnCachedPlayerSkillRatingUpdated;                  // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x50];                                     // 0x0138(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateCachedPlayerSkillRating(bool bForceRefresh);

	int32 GetCachedPlayerLevel() const;
	int32 GetCurrentQueueCachedPlayerSkillRating() const;
	bool HasReceivedInventory() const;
	void UpdatePlayerInventory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerInfo">();
	}
	static class UHWPlayerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPlayerInfo>();
	}
};
static_assert(alignof(UHWPlayerInfo) == 0x000008, "Wrong alignment on UHWPlayerInfo");
static_assert(sizeof(UHWPlayerInfo) == 0x000188, "Wrong size on UHWPlayerInfo");
static_assert(offsetof(UHWPlayerInfo, OnLegacyNameStatusUpdatedDelegate) == 0x0000F8, "Member 'UHWPlayerInfo::OnLegacyNameStatusUpdatedDelegate' has a wrong offset!");
static_assert(offsetof(UHWPlayerInfo, bHasLegacyName) == 0x000108, "Member 'UHWPlayerInfo::bHasLegacyName' has a wrong offset!");
static_assert(offsetof(UHWPlayerInfo, bUseLegacyName) == 0x000109, "Member 'UHWPlayerInfo::bUseLegacyName' has a wrong offset!");
static_assert(offsetof(UHWPlayerInfo, bSettingsLoaded) == 0x00010A, "Member 'UHWPlayerInfo::bSettingsLoaded' has a wrong offset!");
static_assert(offsetof(UHWPlayerInfo, OnCachedPlayerLevelUpdated) == 0x000110, "Member 'UHWPlayerInfo::OnCachedPlayerLevelUpdated' has a wrong offset!");
static_assert(offsetof(UHWPlayerInfo, OnCachedPlayerSkillRatingUpdated) == 0x000128, "Member 'UHWPlayerInfo::OnCachedPlayerSkillRatingUpdated' has a wrong offset!");

// Class Hemingway.HWHasEnoughCurrencyHelper
// 0x0090 (0x00B8 - 0x0028)
class UHWHasEnoughCurrencyHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSoftObjectPtr<class UPlatformInventoryItem>, int32> CurrencyPrices;                        // 0x0038(0x0050)(NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0090(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWStoreSubsystem*                      StoreSubsystem;                                    // 0x0098(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UPlatformInventoryItem>> AffordableCurrencies;                       // 0x00A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWHasEnoughCurrencyHelper">();
	}
	static class UHWHasEnoughCurrencyHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWHasEnoughCurrencyHelper>();
	}
};
static_assert(alignof(UHWHasEnoughCurrencyHelper) == 0x000008, "Wrong alignment on UHWHasEnoughCurrencyHelper");
static_assert(sizeof(UHWHasEnoughCurrencyHelper) == 0x0000B8, "Wrong size on UHWHasEnoughCurrencyHelper");
static_assert(offsetof(UHWHasEnoughCurrencyHelper, CurrencyPrices) == 0x000038, "Member 'UHWHasEnoughCurrencyHelper::CurrencyPrices' has a wrong offset!");
static_assert(offsetof(UHWHasEnoughCurrencyHelper, Quantity) == 0x000088, "Member 'UHWHasEnoughCurrencyHelper::Quantity' has a wrong offset!");
static_assert(offsetof(UHWHasEnoughCurrencyHelper, PlayerInfo) == 0x000090, "Member 'UHWHasEnoughCurrencyHelper::PlayerInfo' has a wrong offset!");
static_assert(offsetof(UHWHasEnoughCurrencyHelper, StoreSubsystem) == 0x000098, "Member 'UHWHasEnoughCurrencyHelper::StoreSubsystem' has a wrong offset!");
static_assert(offsetof(UHWHasEnoughCurrencyHelper, AffordableCurrencies) == 0x0000A0, "Member 'UHWHasEnoughCurrencyHelper::AffordableCurrencies' has a wrong offset!");

// Class Hemingway.HWGetAvailablePricesHelper
// 0x0060 (0x0088 - 0x0028)
class UHWGetAvailablePricesHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URHStoreItem*                           StoreItem;                                         // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWStoreSubsystem*                      StoreSubsystem;                                    // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URHStoreItemPrice*>              AvailablePrices;                                   // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AffordablePriceGroups;                             // 0x0060(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGetAvailablePricesHelper">();
	}
	static class UHWGetAvailablePricesHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGetAvailablePricesHelper>();
	}
};
static_assert(alignof(UHWGetAvailablePricesHelper) == 0x000008, "Wrong alignment on UHWGetAvailablePricesHelper");
static_assert(sizeof(UHWGetAvailablePricesHelper) == 0x000088, "Wrong size on UHWGetAvailablePricesHelper");
static_assert(offsetof(UHWGetAvailablePricesHelper, StoreItem) == 0x000038, "Member 'UHWGetAvailablePricesHelper::StoreItem' has a wrong offset!");
static_assert(offsetof(UHWGetAvailablePricesHelper, PlayerInfo) == 0x000040, "Member 'UHWGetAvailablePricesHelper::PlayerInfo' has a wrong offset!");
static_assert(offsetof(UHWGetAvailablePricesHelper, StoreSubsystem) == 0x000048, "Member 'UHWGetAvailablePricesHelper::StoreSubsystem' has a wrong offset!");
static_assert(offsetof(UHWGetAvailablePricesHelper, AvailablePrices) == 0x000050, "Member 'UHWGetAvailablePricesHelper::AvailablePrices' has a wrong offset!");
static_assert(offsetof(UHWGetAvailablePricesHelper, AffordablePriceGroups) == 0x000060, "Member 'UHWGetAvailablePricesHelper::AffordablePriceGroups' has a wrong offset!");

// Class Hemingway.HWStoreItem
// 0x0000 (0x00C0 - 0x00C0)
class UHWStoreItem final : public URHStoreItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWStoreItem">();
	}
	static class UHWStoreItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWStoreItem>();
	}
};
static_assert(alignof(UHWStoreItem) == 0x000008, "Wrong alignment on UHWStoreItem");
static_assert(sizeof(UHWStoreItem) == 0x0000C0, "Wrong size on UHWStoreItem");

// Class Hemingway.HWInterface_Skinnable
// 0x0000 (0x0000 - 0x0000)
class IHWInterface_Skinnable final
{
public:
	class UHWApparelComponent* GetApparelComponent() const;
	const class UHWSkinItem* GetCurrentSkin() const;
	struct FHWSkinnedMetaSoundInfo GetSkinnedAudioInfo(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWSkinnedMaterialInfo GetSkinnedMaterialInfo(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWMontageInfo GetSkinnedMontage(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWSkinnedNiagaraInfo GetSkinnedNiagaraInfo(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWSkinnedSkeletalMeshInfo GetSkinnedSkeletalMeshInfo(const struct FAssetRequestKey& AssetRequest) const;
	struct FHWSkinnedStaticMeshInfo GetSkinnedStaticMeshInfo(const struct FAssetRequestKey& AssetRequest) const;
	bool IsSkinningReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWInterface_Skinnable">();
	}
	static class IHWInterface_Skinnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWInterface_Skinnable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWInterface_Skinnable) == 0x000001, "Wrong alignment on IHWInterface_Skinnable");
static_assert(sizeof(IHWInterface_Skinnable) == 0x000001, "Wrong size on IHWInterface_Skinnable");

// Class Hemingway.HWNiagaraComponent
// 0x0020 (0x0830 - 0x0810)
class UHWNiagaraComponent : public UNiagaraComponent
{
public:
	class FName                                   SkinningKeyword;                                   // 0x0810(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class IHWInterface_Skinnable> OwnerInterfaceSkinnable;                          // 0x0818(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_828[0x8];                                      // 0x0828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PerformSkinUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWNiagaraComponent">();
	}
	static class UHWNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWNiagaraComponent>();
	}
};
static_assert(alignof(UHWNiagaraComponent) == 0x000010, "Wrong alignment on UHWNiagaraComponent");
static_assert(sizeof(UHWNiagaraComponent) == 0x000830, "Wrong size on UHWNiagaraComponent");
static_assert(offsetof(UHWNiagaraComponent, SkinningKeyword) == 0x000810, "Member 'UHWNiagaraComponent::SkinningKeyword' has a wrong offset!");
static_assert(offsetof(UHWNiagaraComponent, OwnerInterfaceSkinnable) == 0x000818, "Member 'UHWNiagaraComponent::OwnerInterfaceSkinnable' has a wrong offset!");

// Class Hemingway.HWSkinnablePreviewActor
// 0x0168 (0x0480 - 0x0318)
class AHWSkinnablePreviewActor : public ASkeletalMeshActor
{
public:
	uint8                                         Pad_318[0x20];                                     // 0x0318(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LobbyLocationTag;                                  // 0x0338(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdditionalCameraOffset;                            // 0x0340(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TranslationOffset;                                 // 0x0358(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x0370(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SkinTagContainer;                                  // 0x0388(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x28];                                     // 0x03A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWLoadoutComponent*                    LoadoutComponent;                                  // 0x03D0(0x0008)(Edit, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnNewApparelApplicationFinishedDelegate;           // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USkinObjectManagerComponent*            SkinsManagerComponent;                             // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWApparelComponent*                    ApparelComponent;                                  // 0x03F0(0x0008)(Edit, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowOnApparelApplication;                         // 0x03F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWVoiceComponent*                      VoiceComponent;                                    // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PedestalStaticMeshComponent;                       // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            PedestalMesh;                                      // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CachedPedestalTransform;                           // 0x0420(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AnimateActorUpDown();
	void ApplyCharacterItemToLoadout(const class UHWCharacterItem* CharacterItem);
	void ApplyOffsets();
	void ApplySkinItemToLoadout(const class UHWSkinItem* SkinItem);
	void HandleOnNewSkinTagAsset(TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset);
	void HandleOnSkinTagAssetRemoved(TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove);
	void OnRep_ApparelComponent();
	void OnRep_SkinTagContainerChanged();
	void SetIntroPresentationType(EIntroPresentationType Type);
	void SetShowOnApparelApplication(bool bValue);
	void SwapSkinTags(const struct FGameplayTag& NewSkinTag, const struct FGameplayTag& OldSkinTag);
	void TriggerLocalVoiceEvent(const struct FGameplayTag& VoiceEvent);
	void TriggerVoiceEvent(const struct FGameplayTag& VoiceEvent, const struct FGameplayTag& AudienceOverride);
	void UpdatePedestal();

	class UHWVoiceComponent* GetVoiceComponent() const;
	bool IsSkinningReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinnablePreviewActor">();
	}
	static class AHWSkinnablePreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWSkinnablePreviewActor>();
	}
};
static_assert(alignof(AHWSkinnablePreviewActor) == 0x000010, "Wrong alignment on AHWSkinnablePreviewActor");
static_assert(sizeof(AHWSkinnablePreviewActor) == 0x000480, "Wrong size on AHWSkinnablePreviewActor");
static_assert(offsetof(AHWSkinnablePreviewActor, LobbyLocationTag) == 0x000338, "Member 'AHWSkinnablePreviewActor::LobbyLocationTag' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, AdditionalCameraOffset) == 0x000340, "Member 'AHWSkinnablePreviewActor::AdditionalCameraOffset' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, TranslationOffset) == 0x000358, "Member 'AHWSkinnablePreviewActor::TranslationOffset' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, RotationOffset) == 0x000370, "Member 'AHWSkinnablePreviewActor::RotationOffset' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, SkinTagContainer) == 0x000388, "Member 'AHWSkinnablePreviewActor::SkinTagContainer' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, LoadoutComponent) == 0x0003D0, "Member 'AHWSkinnablePreviewActor::LoadoutComponent' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, OnNewApparelApplicationFinishedDelegate) == 0x0003D8, "Member 'AHWSkinnablePreviewActor::OnNewApparelApplicationFinishedDelegate' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, SkinsManagerComponent) == 0x0003E8, "Member 'AHWSkinnablePreviewActor::SkinsManagerComponent' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, ApparelComponent) == 0x0003F0, "Member 'AHWSkinnablePreviewActor::ApparelComponent' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, bShowOnApparelApplication) == 0x0003F8, "Member 'AHWSkinnablePreviewActor::bShowOnApparelApplication' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, VoiceComponent) == 0x000400, "Member 'AHWSkinnablePreviewActor::VoiceComponent' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, PedestalStaticMeshComponent) == 0x000408, "Member 'AHWSkinnablePreviewActor::PedestalStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, PedestalMesh) == 0x000410, "Member 'AHWSkinnablePreviewActor::PedestalMesh' has a wrong offset!");
static_assert(offsetof(AHWSkinnablePreviewActor, CachedPedestalTransform) == 0x000420, "Member 'AHWSkinnablePreviewActor::CachedPedestalTransform' has a wrong offset!");

// Class Hemingway.HWSkinEvoEvalComponent_Abilities
// 0x0018 (0x0158 - 0x0140)
class UHWSkinEvoEvalComponent_Abilities final : public UHWSkinEvoEvalComponent
{
public:
	TArray<struct FHWSkinTagAbilityEntry>         AbilitySkinTagEntries;                             // 0x0140(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAbilityFired(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FGameplayTagContainer& AbilityTags, const struct FHWAbilityFiringInstanceId& FiringInstanceId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinEvoEvalComponent_Abilities">();
	}
	static class UHWSkinEvoEvalComponent_Abilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSkinEvoEvalComponent_Abilities>();
	}
};
static_assert(alignof(UHWSkinEvoEvalComponent_Abilities) == 0x000008, "Wrong alignment on UHWSkinEvoEvalComponent_Abilities");
static_assert(sizeof(UHWSkinEvoEvalComponent_Abilities) == 0x000158, "Wrong size on UHWSkinEvoEvalComponent_Abilities");
static_assert(offsetof(UHWSkinEvoEvalComponent_Abilities, AbilitySkinTagEntries) == 0x000140, "Member 'UHWSkinEvoEvalComponent_Abilities::AbilitySkinTagEntries' has a wrong offset!");

// Class Hemingway.HWSkinEvoEvalComponent_CharacterLevel
// 0x0010 (0x0150 - 0x0140)
class UHWSkinEvoEvalComponent_CharacterLevel : public UHWSkinEvoEvalComponent
{
public:
	TArray<struct FHWSkinTagCharacterLevelEntry>  CharacterLevelSkinTagEntries;                      // 0x0140(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void HandleCharacterLevelChanged(const int32 PreviousCharacterLevel, const int32 NewCharacterLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSkinEvoEvalComponent_CharacterLevel">();
	}
	static class UHWSkinEvoEvalComponent_CharacterLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSkinEvoEvalComponent_CharacterLevel>();
	}
};
static_assert(alignof(UHWSkinEvoEvalComponent_CharacterLevel) == 0x000008, "Wrong alignment on UHWSkinEvoEvalComponent_CharacterLevel");
static_assert(sizeof(UHWSkinEvoEvalComponent_CharacterLevel) == 0x000150, "Wrong size on UHWSkinEvoEvalComponent_CharacterLevel");
static_assert(offsetof(UHWSkinEvoEvalComponent_CharacterLevel, CharacterLevelSkinTagEntries) == 0x000140, "Member 'UHWSkinEvoEvalComponent_CharacterLevel::CharacterLevelSkinTagEntries' has a wrong offset!");

// Class Hemingway.HWGameStatsTracker
// 0x0038 (0x02D0 - 0x0298)
class AHWGameStatsTracker final : public AInfo
{
public:
	TArray<class AHWPlayerStatsTracker*>          PlayerStatsTrackers;                               // 0x0298(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AHWTeamStatsTracker*>            TeamStatsTrackers;                                 // 0x02A8(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAnnouncementComponent*               AnnouncementComponent;                             // 0x02C8(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_AnnouncementComponent();

	class UHWAnnouncementComponent* GetAnnouncementComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameStatsTracker">();
	}
	static class AHWGameStatsTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGameStatsTracker>();
	}
};
static_assert(alignof(AHWGameStatsTracker) == 0x000008, "Wrong alignment on AHWGameStatsTracker");
static_assert(sizeof(AHWGameStatsTracker) == 0x0002D0, "Wrong size on AHWGameStatsTracker");
static_assert(offsetof(AHWGameStatsTracker, PlayerStatsTrackers) == 0x000298, "Member 'AHWGameStatsTracker::PlayerStatsTrackers' has a wrong offset!");
static_assert(offsetof(AHWGameStatsTracker, TeamStatsTrackers) == 0x0002A8, "Member 'AHWGameStatsTracker::TeamStatsTrackers' has a wrong offset!");
static_assert(offsetof(AHWGameStatsTracker, AnnouncementComponent) == 0x0002C8, "Member 'AHWGameStatsTracker::AnnouncementComponent' has a wrong offset!");

// Class Hemingway.HWPlayerStatsTracker
// 0x0298 (0x0530 - 0x0298)
class AHWPlayerStatsTracker final : public AInfo
{
public:
	TWeakObjectPtr<class AHWPlayerState>          PlayerState;                                       // 0x0298(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnPlayerKillsUpdated; // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnPlayerAssistsUpdated; // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnPlayerDeathsUpdated; // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         Kills;                                             // 0x02D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Assists;                                           // 0x02D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Deaths;                                            // 0x02D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnKillStreakUpdated; // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         KillStreak;                                        // 0x02F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnDeathStreakUpdated; // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         DeathStreak;                                       // 0x0308(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StreakModifier;                                    // 0x030C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnMinionsKilled; // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnFireGiantsKilled; // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnGoldFuriesKilled; // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnTowersKilledUpdated; // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnPhoenixesKilledUpdated; // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnTitansKilledUpdated; // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MinionsKilled;                                     // 0x0370(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FireGiantsKilled;                                  // 0x0374(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GoldFuriesKilled;                                  // 0x0378(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TowersKilled;                                      // 0x037C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PhoenixesKilled;                                   // 0x0380(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TitansKilled;                                      // 0x0384(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnTotalGoldEarnedUpdated; // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         TotalGoldEarned;                                   // 0x0398(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, int32 OldStat, int32 NewStat)> OnTotalXPEarnedUpdated; // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         TotalXPEarned;                                     // 0x03B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWAccoladeComponent* AccoladeComponent)> OnAccoladeComponentUpdated; // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWAccoladeComponent*                   AccoladeComponent;                                 // 0x03C8(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, float OldStat, float NewStat)> OnDamageTakenUpdated; // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, float OldStat, float NewStat)> OnStructureDamageUpdated; // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, float OldStat, float NewStat)> OnTotalDamageUpdated; // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, float OldStat, float NewStat)> OnDamageMitigatedUpdated; // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, float OldStat, float NewStat)> OnTotalMinionDamageUpdated; // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, float OldStat, float NewStat)> OnTotalNPCDamageUpdated; // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, float OldStat, float NewStat)> OnTotalSelfHealingUpdated; // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWPlayerState* PlayerState, float OldStat, float NewStat)> OnTotalAllyHealingUpdated; // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x54];                                     // 0x0450(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageTaken;                                       // 0x04A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StructureDamage;                                   // 0x04A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageMitigated;                                   // 0x04AC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalDamage;                                       // 0x04B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalMinionDamage;                                 // 0x04B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalNPCDamage;                                    // 0x04B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalSelfHealing;                                  // 0x04BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalAllyHealing;                                  // 0x04C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C4[0x14];                                     // 0x04C4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WardsPlaced;                                       // 0x04D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DC[0x4];                                      // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    BackendStatMap;                                    // 0x04E0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void AddAllyHealingGrantedForAbility(const struct FGameplayTag& AbilityTag, float HealingGranted);
	void AddAssists(int32 AssistsToAdd);
	void AddDamageDealtForAbility(const struct FGameplayTag& AbilityTag, float DamageDealt);
	void AddDamageMitigated(float MitigatedDamage);
	void AddDamageTaken(float IncomingDamage);
	void AddDeaths(int32 DeathsToAdd);
	void AddHealingReceived(float ReceivedHealing);
	void AddKills(int32 KillsToAdd);
	void AddMinionDamageForAbility(const struct FGameplayTag& AbilityTag, float DamageDealt);
	void AddNPCDamageForAbility(const struct FGameplayTag& AbilityTag, float DamageDealt);
	void AddSelfHealingGrantedForAbility(const struct FGameplayTag& AbilityTag, float HealingGranted);
	void AddStatusDuration(const struct FGameplayTag& StatusToTrack, float IncrementalValue);
	void AddStructureDamage(float DamageToStructure);
	void AddTimeSpentDead(float TimeDead);
	void AddToDeathStreak(int32 DeathsToAdd);
	void AddToKillStreak(int32 KillsToAdd);
	void AddWardCount(int32 NumWardsToAdd);
	struct FGameplayTagContainer GetAllyHealingAbilities();
	struct FGameplayTagContainer GetCombatStatusTagList();
	struct FGameplayTagContainer GetDamageDealtAbilities();
	struct FGameplayTagContainer GetMinionDamageAbilities();
	struct FGameplayTagContainer GetNPCDamageAbilities();
	struct FGameplayTagContainer GetSelfHealingAbilities();
	int32 GetTotalHealingReceived();
	void IncrementBackendStat(const class FString& Key, float Value);
	void IncrementStreakModifier();
	void OnRep_AccoladeComponent();
	void OnRep_Assists(int32 OldAssists);
	void OnRep_DamageMitigated(float OldDamageMitigated);
	void OnRep_DamageTaken(float OldDamageTaken);
	void OnRep_Deaths(int32 OldDeaths);
	void OnRep_DeathStreak(int32 OldDeathStreak);
	void OnRep_FireGiantsKilled(int32 OldFireGiantsKilled);
	void OnRep_GoldFuriesKilled(int32 OldGoldFuriesKilled);
	void OnRep_Kills(int32 OldKills);
	void OnRep_KillStreak(int32 OldKillStreak);
	void OnRep_MinionsKilled(int32 OldMinionsKilled);
	void OnRep_PhoenixesKilled(int32 OldPhoenixesKilled);
	void OnRep_StructureDamage(float OldStructureDamage);
	void OnRep_TitansKilled(int32 OldTitansKilled);
	void OnRep_TotalAllyHealing(float OldTotalAllyHealing);
	void OnRep_TotalDamage(float OldTotalDamage);
	void OnRep_TotalGoldEarned(float OldTotalGoldEarned);
	void OnRep_TotalMinionDamage(float OldTotalMinionDamage);
	void OnRep_TotalNPCDamage(float OldTotalNPCDamage);
	void OnRep_TotalSelfHealing(float OldTotalSelfHealing);
	void OnRep_TotalXPEarned(float OldTotalXPEarned);
	void OnRep_TowersKilled(int32 OldTowersKilled);
	void ResetBackendStat(const class FString& Key);
	void SetAssists(int32 NewAssists);
	void SetDeaths(int32 NewDeaths);
	void SetDeathStreak(int32 NewDeathStreak);
	void SetKills(int32 NewKills);
	void SetKillStreak(int32 NewKillStreak);
	void SetStreakModifier(int32 InStreakModifier);
	void UpdateTotalGoldEarned(const float GoldToAdd);
	void UpdateTotalXPEarned(const float XPToAdd);

	class UHWAccoladeComponent* GetAccoladeComponent() const;
	int32 GetAssists() const;
	float GetBackendStatValue(const class FString& Key) const;
	int32 GetDeaths() const;
	int32 GetDeathStreak() const;
	int32 GetKills() const;
	int32 GetKillStreak() const;
	int32 GetStreakModifier() const;
	float GetTimeSpentDead() const;
	int32 GetTotalAllyHealingGranted() const;
	int32 GetTotalALlyHealingGrantedForAbility(const struct FGameplayTag& AbilityTag) const;
	int32 GetTotalDamageDealt() const;
	int32 GetTotalDamageDealtForAbility(const struct FGameplayTag& AbilityTag) const;
	int32 GetTotalDamageMitigated() const;
	int32 GetTotalDamageTaken() const;
	float GetTotalGoldEarned() const;
	int32 GetTotalMinionDamage() const;
	int32 GetTotalMinionDamageForAbility(const struct FGameplayTag& AbilityTag) const;
	int32 GetTotalNPCDamage() const;
	int32 GetTotalNPCDamageForAbility(const struct FGameplayTag& AbilityTag) const;
	int32 GetTotalSelfHealingGranted() const;
	int32 GetTotalSelfHealingGrantedForAbility(const struct FGameplayTag& AbilityTag) const;
	float GetTotalStatusDuration(const struct FGameplayTag& RelevantStat) const;
	int32 GetTotalStructureDamage() const;
	int32 GetTotalWardsPlaced() const;
	float GetTotalXPEarned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerStatsTracker">();
	}
	static class AHWPlayerStatsTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWPlayerStatsTracker>();
	}
};
static_assert(alignof(AHWPlayerStatsTracker) == 0x000008, "Wrong alignment on AHWPlayerStatsTracker");
static_assert(sizeof(AHWPlayerStatsTracker) == 0x000530, "Wrong size on AHWPlayerStatsTracker");
static_assert(offsetof(AHWPlayerStatsTracker, PlayerState) == 0x000298, "Member 'AHWPlayerStatsTracker::PlayerState' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnPlayerKillsUpdated) == 0x0002A0, "Member 'AHWPlayerStatsTracker::OnPlayerKillsUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnPlayerAssistsUpdated) == 0x0002B0, "Member 'AHWPlayerStatsTracker::OnPlayerAssistsUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnPlayerDeathsUpdated) == 0x0002C0, "Member 'AHWPlayerStatsTracker::OnPlayerDeathsUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, Kills) == 0x0002D0, "Member 'AHWPlayerStatsTracker::Kills' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, Assists) == 0x0002D4, "Member 'AHWPlayerStatsTracker::Assists' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, Deaths) == 0x0002D8, "Member 'AHWPlayerStatsTracker::Deaths' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnKillStreakUpdated) == 0x0002E0, "Member 'AHWPlayerStatsTracker::OnKillStreakUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, KillStreak) == 0x0002F0, "Member 'AHWPlayerStatsTracker::KillStreak' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnDeathStreakUpdated) == 0x0002F8, "Member 'AHWPlayerStatsTracker::OnDeathStreakUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, DeathStreak) == 0x000308, "Member 'AHWPlayerStatsTracker::DeathStreak' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, StreakModifier) == 0x00030C, "Member 'AHWPlayerStatsTracker::StreakModifier' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnMinionsKilled) == 0x000310, "Member 'AHWPlayerStatsTracker::OnMinionsKilled' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnFireGiantsKilled) == 0x000320, "Member 'AHWPlayerStatsTracker::OnFireGiantsKilled' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnGoldFuriesKilled) == 0x000330, "Member 'AHWPlayerStatsTracker::OnGoldFuriesKilled' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnTowersKilledUpdated) == 0x000340, "Member 'AHWPlayerStatsTracker::OnTowersKilledUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnPhoenixesKilledUpdated) == 0x000350, "Member 'AHWPlayerStatsTracker::OnPhoenixesKilledUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnTitansKilledUpdated) == 0x000360, "Member 'AHWPlayerStatsTracker::OnTitansKilledUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, MinionsKilled) == 0x000370, "Member 'AHWPlayerStatsTracker::MinionsKilled' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, FireGiantsKilled) == 0x000374, "Member 'AHWPlayerStatsTracker::FireGiantsKilled' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, GoldFuriesKilled) == 0x000378, "Member 'AHWPlayerStatsTracker::GoldFuriesKilled' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, TowersKilled) == 0x00037C, "Member 'AHWPlayerStatsTracker::TowersKilled' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, PhoenixesKilled) == 0x000380, "Member 'AHWPlayerStatsTracker::PhoenixesKilled' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, TitansKilled) == 0x000384, "Member 'AHWPlayerStatsTracker::TitansKilled' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnTotalGoldEarnedUpdated) == 0x000388, "Member 'AHWPlayerStatsTracker::OnTotalGoldEarnedUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, TotalGoldEarned) == 0x000398, "Member 'AHWPlayerStatsTracker::TotalGoldEarned' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnTotalXPEarnedUpdated) == 0x0003A0, "Member 'AHWPlayerStatsTracker::OnTotalXPEarnedUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, TotalXPEarned) == 0x0003B0, "Member 'AHWPlayerStatsTracker::TotalXPEarned' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnAccoladeComponentUpdated) == 0x0003B8, "Member 'AHWPlayerStatsTracker::OnAccoladeComponentUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, AccoladeComponent) == 0x0003C8, "Member 'AHWPlayerStatsTracker::AccoladeComponent' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnDamageTakenUpdated) == 0x0003D0, "Member 'AHWPlayerStatsTracker::OnDamageTakenUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnStructureDamageUpdated) == 0x0003E0, "Member 'AHWPlayerStatsTracker::OnStructureDamageUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnTotalDamageUpdated) == 0x0003F0, "Member 'AHWPlayerStatsTracker::OnTotalDamageUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnDamageMitigatedUpdated) == 0x000400, "Member 'AHWPlayerStatsTracker::OnDamageMitigatedUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnTotalMinionDamageUpdated) == 0x000410, "Member 'AHWPlayerStatsTracker::OnTotalMinionDamageUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnTotalNPCDamageUpdated) == 0x000420, "Member 'AHWPlayerStatsTracker::OnTotalNPCDamageUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnTotalSelfHealingUpdated) == 0x000430, "Member 'AHWPlayerStatsTracker::OnTotalSelfHealingUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, OnTotalAllyHealingUpdated) == 0x000440, "Member 'AHWPlayerStatsTracker::OnTotalAllyHealingUpdated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, DamageTaken) == 0x0004A4, "Member 'AHWPlayerStatsTracker::DamageTaken' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, StructureDamage) == 0x0004A8, "Member 'AHWPlayerStatsTracker::StructureDamage' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, DamageMitigated) == 0x0004AC, "Member 'AHWPlayerStatsTracker::DamageMitigated' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, TotalDamage) == 0x0004B0, "Member 'AHWPlayerStatsTracker::TotalDamage' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, TotalMinionDamage) == 0x0004B4, "Member 'AHWPlayerStatsTracker::TotalMinionDamage' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, TotalNPCDamage) == 0x0004B8, "Member 'AHWPlayerStatsTracker::TotalNPCDamage' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, TotalSelfHealing) == 0x0004BC, "Member 'AHWPlayerStatsTracker::TotalSelfHealing' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, TotalAllyHealing) == 0x0004C0, "Member 'AHWPlayerStatsTracker::TotalAllyHealing' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, WardsPlaced) == 0x0004D8, "Member 'AHWPlayerStatsTracker::WardsPlaced' has a wrong offset!");
static_assert(offsetof(AHWPlayerStatsTracker, BackendStatMap) == 0x0004E0, "Member 'AHWPlayerStatsTracker::BackendStatMap' has a wrong offset!");

// Class Hemingway.HWTeamStatsTracker
// 0x0110 (0x03A8 - 0x0298)
class AHWTeamStatsTracker final : public AInfo
{
public:
	TWeakObjectPtr<class AHWTeamState>            TeamState;                                         // 0x0298(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, int32 NewStat)> OnTeamKillsUpdated; // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, int32 NewStat)> OnTeamDeathsUpdated; // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, int32 NewStat)> OnTeamAssistsUpdated; // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, int32 NewStat)> OnTeamGoldEarnedUpdated; // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, int32 NewStat)> OnTeamXPEarnedUpdated; // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, int32 NewStat)> OnGoldFuryKillsUpdated; // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, int32 NewStat)> OnFireGiantKillsUpdated; // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, int32 NewStat)> OnPyromancerKillsUpdated; // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         GoldFuryKills;                                     // 0x0320(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FireGiantKills;                                    // 0x0324(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PyromancerKills;                                   // 0x0328(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UHWAccoladeComponent* AccoladeComponent)> OnAccoladeComponentUpdated; // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHWAccoladeComponent*                   AccoladeComponent;                                 // 0x0340(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AHWTeamState* TeamState, const struct FGameplayTag& StatTag, class AHWPlayerState* PlayerState)> OnTopStatUpdated; // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FHWTopTeamStat> TopStatsPlayers;                                // 0x0358(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void AddFireGiantKills(int32 KillsToAdd);
	void AddGoldFuryKills(int32 KillsToAdd);
	void AddPyromancerKills(int32 KillsToAdd);
	void HandleDamageMitigatedUpdated(class AHWPlayerState* PlayerState, float OldDamageMitigated, float NewDamageMitigated);
	void HandlePlayerAssistsUpdated(class AHWPlayerState* PlayerState, int32 OldAssists, int32 NewAssists);
	void HandlePlayerDeathsUpdated(class AHWPlayerState* PlayerState, int32 OldDeaths, int32 NewDeaths);
	void HandlePlayerKillsUpdated(class AHWPlayerState* PlayerState, int32 OldKills, int32 NewKills);
	void HandlePlayerStatsReplicated(class AHWPlayerState* PlayerState, class AHWPlayerStatsTracker* PlayerStats);
	void HandleTeamMembersUpdated();
	void HandleTotalDamageDealtUpdated(class AHWPlayerState* PlayerState, float OldTotalDamageDealt, float NewTotalDamageDealt);
	void HandleTotalGoldEarnedUpdated(class AHWPlayerState* PlayerState, int32 OldTotalGoldEarned, int32 NewTotalGoldEarned);
	void HandleTotalXPEarnedUpdated(class AHWPlayerState* PlayerState, int32 OldTotalGoldEarned, int32 NewTotalGoldEarned);
	void OnRep_AccoladeComponent();
	void OnRep_FireGiantKills();
	void OnRep_GoldFuryKills();
	void OnRep_PyromancerKills();
	void OnRep_TeamState();
	void SetFireGiantKills(int32 NewKillNum);
	void SetGoldFuryKills(int32 NewKillNum);
	void SetPyromancerKills(int32 NewKillNum);

	class UHWAccoladeComponent* GetAccoladeComponent() const;
	int32 GetFireGiantKills() const;
	int32 GetGoldFuryKills() const;
	int32 GetPyromancerKills() const;
	int32 GetTeamAssists() const;
	int32 GetTeamDeaths() const;
	int32 GetTeamEarnedGold() const;
	int32 GetTeamEarnedXP() const;
	int32 GetTeamKills() const;
	class AHWPlayerState* GetTopStatsPlayer(const struct FGameplayTag& StatToCheck) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWTeamStatsTracker">();
	}
	static class AHWTeamStatsTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWTeamStatsTracker>();
	}
};
static_assert(alignof(AHWTeamStatsTracker) == 0x000008, "Wrong alignment on AHWTeamStatsTracker");
static_assert(sizeof(AHWTeamStatsTracker) == 0x0003A8, "Wrong size on AHWTeamStatsTracker");
static_assert(offsetof(AHWTeamStatsTracker, TeamState) == 0x000298, "Member 'AHWTeamStatsTracker::TeamState' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, OnTeamKillsUpdated) == 0x0002A0, "Member 'AHWTeamStatsTracker::OnTeamKillsUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, OnTeamDeathsUpdated) == 0x0002B0, "Member 'AHWTeamStatsTracker::OnTeamDeathsUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, OnTeamAssistsUpdated) == 0x0002C0, "Member 'AHWTeamStatsTracker::OnTeamAssistsUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, OnTeamGoldEarnedUpdated) == 0x0002D0, "Member 'AHWTeamStatsTracker::OnTeamGoldEarnedUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, OnTeamXPEarnedUpdated) == 0x0002E0, "Member 'AHWTeamStatsTracker::OnTeamXPEarnedUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, OnGoldFuryKillsUpdated) == 0x0002F0, "Member 'AHWTeamStatsTracker::OnGoldFuryKillsUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, OnFireGiantKillsUpdated) == 0x000300, "Member 'AHWTeamStatsTracker::OnFireGiantKillsUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, OnPyromancerKillsUpdated) == 0x000310, "Member 'AHWTeamStatsTracker::OnPyromancerKillsUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, GoldFuryKills) == 0x000320, "Member 'AHWTeamStatsTracker::GoldFuryKills' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, FireGiantKills) == 0x000324, "Member 'AHWTeamStatsTracker::FireGiantKills' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, PyromancerKills) == 0x000328, "Member 'AHWTeamStatsTracker::PyromancerKills' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, OnAccoladeComponentUpdated) == 0x000330, "Member 'AHWTeamStatsTracker::OnAccoladeComponentUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, AccoladeComponent) == 0x000340, "Member 'AHWTeamStatsTracker::AccoladeComponent' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, OnTopStatUpdated) == 0x000348, "Member 'AHWTeamStatsTracker::OnTopStatUpdated' has a wrong offset!");
static_assert(offsetof(AHWTeamStatsTracker, TopStatsPlayers) == 0x000358, "Member 'AHWTeamStatsTracker::TopStatsPlayers' has a wrong offset!");

// Class Hemingway.HWCallToActionItemHandler
// 0x0000 (0x0028 - 0x0028)
class UHWCallToActionItemHandler : public UObject
{
public:
	TArray<class FName> GetCTAPath(const class UObject* WorldContext, const struct FRH_ItemInventory& Item);
	bool ShouldShowCTA(const class UObject* WorldContext, const struct FRH_ItemInventory& Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCallToActionItemHandler">();
	}
	static class UHWCallToActionItemHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCallToActionItemHandler>();
	}
};
static_assert(alignof(UHWCallToActionItemHandler) == 0x000008, "Wrong alignment on UHWCallToActionItemHandler");
static_assert(sizeof(UHWCallToActionItemHandler) == 0x000028, "Wrong size on UHWCallToActionItemHandler");

// Class Hemingway.HWCallToActionConfig
// 0x0020 (0x0050 - 0x0030)
class UHWCallToActionConfig final : public UDataAsset
{
public:
	TArray<struct FHWCallToActionItemHandlerMap>  ItemHandlers;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHWCallToActionLootConfigMap>   LootConfigs;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCallToActionConfig">();
	}
	static class UHWCallToActionConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCallToActionConfig>();
	}
};
static_assert(alignof(UHWCallToActionConfig) == 0x000008, "Wrong alignment on UHWCallToActionConfig");
static_assert(sizeof(UHWCallToActionConfig) == 0x000050, "Wrong size on UHWCallToActionConfig");
static_assert(offsetof(UHWCallToActionConfig, ItemHandlers) == 0x000030, "Member 'UHWCallToActionConfig::ItemHandlers' has a wrong offset!");
static_assert(offsetof(UHWCallToActionConfig, LootConfigs) == 0x000040, "Member 'UHWCallToActionConfig::LootConfigs' has a wrong offset!");

// Class Hemingway.HWCallToActionSubsystem
// 0x00D8 (0x0108 - 0x0030)
class UHWCallToActionSubsystem final : public ULocalPlayerSubsystem
{
public:
	TSoftObjectPtr<class UDataTable>              GenericCollectionItemSoftPtr;                      // 0x0030(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UHWCallToActionConfig>   CallToActionConfigPtr;                             // 0x0058(0x0028)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHWCallToActionConfig*                  CallToActionConfig;                                // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x5];                                       // 0x0088(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWPlatformBool                        bAreCTAsEnabled;                                   // 0x008D(0x0003)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	struct FHWPlatformBool                        bAllowFreshInstallAutoClear;                       // 0x0090(0x0003)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_93[0x1];                                       // 0x0093(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreshInstallAutoClearInterval;                     // 0x0094(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x70];                                      // 0x0098(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString PathToString(const TArray<class FName>& CTAPath);

	void HandleGodSubsystemReady();
	void HandleInventoryLoaded(bool bSuccess);
	void HandleInventoryUpdated(const TArray<int32>& UpdatedInventoryIds, class URH_PlayerInfo* PlayerInfo);
	void HandleStoreVendorsLoaded();
	int32 RegisterCTAActiveChildrenCountChanged(const TArray<class FName>& CTAPath, TDelegate<void(int32 ActiveChildrenCount)> Callback);
	bool RegisterCTASeenAmountChanged(const TArray<class FName>& CTAPath, TDelegate<void(int32 InventoryAmount, int32 SeenAmount)> Callback);
	bool RegisterCTAStateChanged(const TArray<class FName>& CTAPath, TDelegate<void(bool bIsCTAActive)> Callback);
	void ResetAllCTAs();
	bool SetCTASeen(const TArray<class FName>& CTAPath, bool bSetChildrenSeen);
	int32 SetCTASeenAmount(const TArray<class FName>& CTAPath, int32 SeenAmount);
	int32 UnregisterCTAActiveChildrenCountChanged(const TArray<class FName>& CTAPath, const class UObject* CallbackObj);
	bool UnregisterCTASeenAmountChanged(const TArray<class FName>& CTAPath, const class UObject* CallbackObj);
	bool UnregisterCTAStateChanged(const TArray<class FName>& CTAPath, const class UObject* CallbackObj);

	int32 GetCTAActiveChildrenCount(const TArray<class FName>& CTAPath) const;
	bool GetCTAStateAndAmounts(const TArray<class FName>& CTAPath, int32* OutInventoryAmount, int32* OutSeenAmount, int32* OutActiveChildrenCount) const;
	bool IsCTAActive(const TArray<class FName>& CTAPath) const;
	void LogAllActiveCTAs() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCallToActionSubsystem">();
	}
	static class UHWCallToActionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCallToActionSubsystem>();
	}
};
static_assert(alignof(UHWCallToActionSubsystem) == 0x000008, "Wrong alignment on UHWCallToActionSubsystem");
static_assert(sizeof(UHWCallToActionSubsystem) == 0x000108, "Wrong size on UHWCallToActionSubsystem");
static_assert(offsetof(UHWCallToActionSubsystem, GenericCollectionItemSoftPtr) == 0x000030, "Member 'UHWCallToActionSubsystem::GenericCollectionItemSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWCallToActionSubsystem, CallToActionConfigPtr) == 0x000058, "Member 'UHWCallToActionSubsystem::CallToActionConfigPtr' has a wrong offset!");
static_assert(offsetof(UHWCallToActionSubsystem, CallToActionConfig) == 0x000080, "Member 'UHWCallToActionSubsystem::CallToActionConfig' has a wrong offset!");
static_assert(offsetof(UHWCallToActionSubsystem, bAreCTAsEnabled) == 0x00008D, "Member 'UHWCallToActionSubsystem::bAreCTAsEnabled' has a wrong offset!");
static_assert(offsetof(UHWCallToActionSubsystem, bAllowFreshInstallAutoClear) == 0x000090, "Member 'UHWCallToActionSubsystem::bAllowFreshInstallAutoClear' has a wrong offset!");
static_assert(offsetof(UHWCallToActionSubsystem, FreshInstallAutoClearInterval) == 0x000094, "Member 'UHWCallToActionSubsystem::FreshInstallAutoClearInterval' has a wrong offset!");

// Class Hemingway.HWCTAItemHandler_AssociatedCharacter
// 0x0018 (0x0040 - 0x0028)
class UHWCTAItemHandler_AssociatedCharacter final : public UHWCallToActionItemHandler
{
public:
	struct FGameplayTag                           AssociatedCharacterTag;                            // 0x0028(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           PathSuffix;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCTAItemHandler_AssociatedCharacter">();
	}
	static class UHWCTAItemHandler_AssociatedCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCTAItemHandler_AssociatedCharacter>();
	}
};
static_assert(alignof(UHWCTAItemHandler_AssociatedCharacter) == 0x000008, "Wrong alignment on UHWCTAItemHandler_AssociatedCharacter");
static_assert(sizeof(UHWCTAItemHandler_AssociatedCharacter) == 0x000040, "Wrong size on UHWCTAItemHandler_AssociatedCharacter");
static_assert(offsetof(UHWCTAItemHandler_AssociatedCharacter, AssociatedCharacterTag) == 0x000028, "Member 'UHWCTAItemHandler_AssociatedCharacter::AssociatedCharacterTag' has a wrong offset!");
static_assert(offsetof(UHWCTAItemHandler_AssociatedCharacter, PathSuffix) == 0x000030, "Member 'UHWCTAItemHandler_AssociatedCharacter::PathSuffix' has a wrong offset!");

// Class Hemingway.HWCrashSubsystem
// 0x0018 (0x0048 - 0x0030)
class UHWCrashSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWPlayerController*                    CachedPlayerController;                            // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHWCharacterAbilitySystemActor*         CachedASActor;                                     // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAbilitySystemActorReplicated(class AHWCharacterAbilitySystemActor* NewASActor);
	void OnCharacterItemUpdated(TScriptInterface<class IHWInterface_LoadoutManagement> LoadoutOwner, const class UHWCharacterItem* NewCharacterItem);
	void OnGameStateUpdate(const class AHWGameState* GameState);
	void OnSkinItemUpdated(TScriptInterface<class IHWInterface_LoadoutManagement> LoadoutOwner, const class UHWSkinItem* NewSkinItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWCrashSubsystem">();
	}
	static class UHWCrashSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWCrashSubsystem>();
	}
};
static_assert(alignof(UHWCrashSubsystem) == 0x000008, "Wrong alignment on UHWCrashSubsystem");
static_assert(sizeof(UHWCrashSubsystem) == 0x000048, "Wrong size on UHWCrashSubsystem");
static_assert(offsetof(UHWCrashSubsystem, CachedPlayerController) == 0x000038, "Member 'UHWCrashSubsystem::CachedPlayerController' has a wrong offset!");
static_assert(offsetof(UHWCrashSubsystem, CachedASActor) == 0x000040, "Member 'UHWCrashSubsystem::CachedASActor' has a wrong offset!");

// Class Hemingway.ItemInfoContainer
// 0x0038 (0x0060 - 0x0028)
class UItemInfoContainer final : public UObject
{
public:
	struct FHWItemStoreItemInfo                   ItemInfo;                                          // 0x0028(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInfoContainer">();
	}
	static class UItemInfoContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemInfoContainer>();
	}
};
static_assert(alignof(UItemInfoContainer) == 0x000008, "Wrong alignment on UItemInfoContainer");
static_assert(sizeof(UItemInfoContainer) == 0x000060, "Wrong size on UItemInfoContainer");
static_assert(offsetof(UItemInfoContainer, ItemInfo) == 0x000028, "Member 'UItemInfoContainer::ItemInfo' has a wrong offset!");

// Class Hemingway.HWEquipmentItemSubsystem
// 0x0200 (0x0230 - 0x0030)
class UHWEquipmentItemSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnItemStoreItemListLoaded;                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UHWEquipmentItem>> AllItemList;                                      // 0x0050(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UHWEquipmentItem>> HiddenItemList;                                   // 0x0060(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UHWEquipmentItem>> FilteredItemList;                                 // 0x0070(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UHWEquipmentItem>> DisabledItemList;                                 // 0x0080(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UDataTable*                             ItemDataTable;                                     // 0x0090(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPrimaryAssetId, struct FHWEquipmentItemCraftingInfo> CraftingInfoMap;               // 0x00A0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FHWDynamicItemInfo& NewDynamicItem)> OnDynamicItemAdded; // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHWDynamicItemInfo& OldDynamicItem)> OnDynamicItemRemoved; // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHWDynamicItemInfo>             DynamicItemList;                                   // 0x0110(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UHWEquipmentItemSortingConfig> SortingConfig;                               // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRHAPI_Vendor                          ItemsVendor;                                       // 0x0130(0x00F8)(Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           WaitForLocalPlayerLoginSubsystemHandle;            // 0x0228(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnItemsVendorReceived(bool bSuccessfullyLoaded);
	void OnRHSessionChanged(class URH_JoinedSession* OldSession, class URH_JoinedSession* ActiveSession);
	void OnSettingsChanged(class URH_ConfigSubsystem* ConfigSubsytem);

	bool IsGodSpecificItem(const struct FRH_ItemId& ItemId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEquipmentItemSubsystem">();
	}
	static class UHWEquipmentItemSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEquipmentItemSubsystem>();
	}
};
static_assert(alignof(UHWEquipmentItemSubsystem) == 0x000008, "Wrong alignment on UHWEquipmentItemSubsystem");
static_assert(sizeof(UHWEquipmentItemSubsystem) == 0x000230, "Wrong size on UHWEquipmentItemSubsystem");
static_assert(offsetof(UHWEquipmentItemSubsystem, OnItemStoreItemListLoaded) == 0x000040, "Member 'UHWEquipmentItemSubsystem::OnItemStoreItemListLoaded' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, AllItemList) == 0x000050, "Member 'UHWEquipmentItemSubsystem::AllItemList' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, HiddenItemList) == 0x000060, "Member 'UHWEquipmentItemSubsystem::HiddenItemList' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, FilteredItemList) == 0x000070, "Member 'UHWEquipmentItemSubsystem::FilteredItemList' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, DisabledItemList) == 0x000080, "Member 'UHWEquipmentItemSubsystem::DisabledItemList' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, ItemDataTable) == 0x000090, "Member 'UHWEquipmentItemSubsystem::ItemDataTable' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, CraftingInfoMap) == 0x0000A0, "Member 'UHWEquipmentItemSubsystem::CraftingInfoMap' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, OnDynamicItemAdded) == 0x0000F0, "Member 'UHWEquipmentItemSubsystem::OnDynamicItemAdded' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, OnDynamicItemRemoved) == 0x000100, "Member 'UHWEquipmentItemSubsystem::OnDynamicItemRemoved' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, DynamicItemList) == 0x000110, "Member 'UHWEquipmentItemSubsystem::DynamicItemList' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, SortingConfig) == 0x000120, "Member 'UHWEquipmentItemSubsystem::SortingConfig' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, ItemsVendor) == 0x000130, "Member 'UHWEquipmentItemSubsystem::ItemsVendor' has a wrong offset!");
static_assert(offsetof(UHWEquipmentItemSubsystem, WaitForLocalPlayerLoginSubsystemHandle) == 0x000228, "Member 'UHWEquipmentItemSubsystem::WaitForLocalPlayerLoginSubsystemHandle' has a wrong offset!");

// Class Hemingway.HWGameModeInfoSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UHWGameModeInfoSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<struct FGameplayTag, struct FHWGameModeInfo> CachedGameModeInfo;                            // 0x0030(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              GameModeInfoSoftPtr;                               // 0x0080(0x0028)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UHWCharacterItem>> GodItemsToLoad;                                   // 0x00A8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetGameModeInfoByTag(const struct FGameplayTag& InfoTag, struct FHWGameModeInfo* OutInfo) const;
	bool GetGameModeInfoFromActiveSession(struct FHWGameModeInfo* OutGameModeInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGameModeInfoSubsystem">();
	}
	static class UHWGameModeInfoSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGameModeInfoSubsystem>();
	}
};
static_assert(alignof(UHWGameModeInfoSubsystem) == 0x000008, "Wrong alignment on UHWGameModeInfoSubsystem");
static_assert(sizeof(UHWGameModeInfoSubsystem) == 0x0000E0, "Wrong size on UHWGameModeInfoSubsystem");
static_assert(offsetof(UHWGameModeInfoSubsystem, CachedGameModeInfo) == 0x000030, "Member 'UHWGameModeInfoSubsystem::CachedGameModeInfo' has a wrong offset!");
static_assert(offsetof(UHWGameModeInfoSubsystem, GameModeInfoSoftPtr) == 0x000080, "Member 'UHWGameModeInfoSubsystem::GameModeInfoSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWGameModeInfoSubsystem, GodItemsToLoad) == 0x0000A8, "Member 'UHWGameModeInfoSubsystem::GodItemsToLoad' has a wrong offset!");

// Class Hemingway.HWGodBuilderSubsystem
// 0x0208 (0x0238 - 0x0030)
class UHWGodBuilderSubsystem final : public UGameInstanceSubsystem
{
public:
	class URH_GuideSearch*                        CurrentSearch;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x1A8];                                     // 0x0038(0x01A8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FRH_ItemId, struct FGuid>         GodPrimaryBuildOverrideMap;                        // 0x01E0(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FHWPlatformBool                        bUseGodBuilder;                                    // 0x0230(0x0003)(Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHWPlatformBool                        bUseSanitizer;                                     // 0x0233(0x0003)(Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_236[0x2];                                      // 0x0236(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetCachedPrimaryBuild(struct FHWGodBuild* OutGodBuild);
	void OnLocalPlayerPinnedBuildUpdated(const class UHWCharacterItem* CharacterItem, const struct FGuid& BuildGuid);
	bool ShouldUseGodBuilder();

	EHWCachedBuildType GetCachedBuildType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGodBuilderSubsystem">();
	}
	static class UHWGodBuilderSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWGodBuilderSubsystem>();
	}
};
static_assert(alignof(UHWGodBuilderSubsystem) == 0x000008, "Wrong alignment on UHWGodBuilderSubsystem");
static_assert(sizeof(UHWGodBuilderSubsystem) == 0x000238, "Wrong size on UHWGodBuilderSubsystem");
static_assert(offsetof(UHWGodBuilderSubsystem, CurrentSearch) == 0x000030, "Member 'UHWGodBuilderSubsystem::CurrentSearch' has a wrong offset!");
static_assert(offsetof(UHWGodBuilderSubsystem, GodPrimaryBuildOverrideMap) == 0x0001E0, "Member 'UHWGodBuilderSubsystem::GodPrimaryBuildOverrideMap' has a wrong offset!");
static_assert(offsetof(UHWGodBuilderSubsystem, bUseGodBuilder) == 0x000230, "Member 'UHWGodBuilderSubsystem::bUseGodBuilder' has a wrong offset!");
static_assert(offsetof(UHWGodBuilderSubsystem, bUseSanitizer) == 0x000233, "Member 'UHWGodBuilderSubsystem::bUseSanitizer' has a wrong offset!");

// Class Hemingway.HWLeaderboardEntry
// 0x0020 (0x0048 - 0x0028)
class UHWLeaderboardEntry final : public UObject
{
public:
	int32                                         Rank;                                              // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  PlayerUuid;                                        // 0x002C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        StatValue;                                         // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLeaderboardEntry">();
	}
	static class UHWLeaderboardEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLeaderboardEntry>();
	}
};
static_assert(alignof(UHWLeaderboardEntry) == 0x000008, "Wrong alignment on UHWLeaderboardEntry");
static_assert(sizeof(UHWLeaderboardEntry) == 0x000048, "Wrong size on UHWLeaderboardEntry");
static_assert(offsetof(UHWLeaderboardEntry, Rank) == 0x000028, "Member 'UHWLeaderboardEntry::Rank' has a wrong offset!");
static_assert(offsetof(UHWLeaderboardEntry, PlayerUuid) == 0x00002C, "Member 'UHWLeaderboardEntry::PlayerUuid' has a wrong offset!");
static_assert(offsetof(UHWLeaderboardEntry, StatValue) == 0x000040, "Member 'UHWLeaderboardEntry::StatValue' has a wrong offset!");

// Class Hemingway.HWLeaderboardSubsystem
// 0x0148 (0x0178 - 0x0030)
class UHWLeaderboardSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class FString, int32>                    LeaderboardIdToIndex;                              // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         LeaderboardIds;                                    // 0x0080(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x50];                                      // 0x0090(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FHWLeaderboardDataContainer> LeaderBoardDataContainers;               // 0x00E0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class FString                                 LastReceivedLeaderboardId;                         // 0x0130(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UHWLeaderboardConfig>    LeaderboardConfig;                                 // 0x0140(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FHWLeaderboardDataContainer CreateLeaderboardDataContainer(const class FString& LeaderboardId, struct FRH_LeaderboardResults* Results);
	void ExecuteAllDelegates(const bool bSuccess, const class FString& LeaderboardId, const struct FHWLeaderboardDataContainer& Container);
	bool FindDivision(const struct FHWLeaderboardDataContainer& LeaderboardDataContainer, const TArray<struct FHWSkillRatingRank>& Ranks, int32 StatValue, struct FHWSkillRatingDivision* OutSkillRatingDivision);
	bool FindDivisionFromCache(const class FString& LeaderboardId, int32 StatValue, struct FHWSkillRatingDivision* OutSkillRatingDivision);
	bool FindRank(const struct FHWLeaderboardDataContainer& LeaderboardDataContainer, const TArray<struct FHWSkillRatingRank>& Ranks, int32 StatValue, struct FHWSkillRatingRank* OutSkillRatingRank);
	bool FindRankFromCache(const class FString& LeaderboardId, int32 StatValue, struct FHWSkillRatingRank* OutSkillRatingRank);
	int32 FindRankIndex(const struct FHWLeaderboardDataContainer& LeaderboardDataContainer, const TArray<struct FHWSkillRatingRank>& Ranks, int32 StatValue);
	bool GetCachedLeaderboard(const class FString& LeaderboardId, struct FHWLeaderboardDataContainer* OutLeaderboardDataContainer);
	class FString GetLastReceivedLeaderboardId();
	bool GetLeaderboardDataConfig(const class FString& LeaderboardId, struct FHWLeaderboardDataConfig* OutLeaderboardDataConfig);
	TArray<class FString> GetLeaderboardIds();
	void InitializeLeaderboardConfigDatas();
	void OnLeaderboardConfigLoaded();
	void OnRankedConfigsLoaded();
	void RequestAsyncLeaderboard(const class FString& LeaderboardId);

	class URH_LeaderboardSubsystem* GetRHLeaderboardSubsystem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLeaderboardSubsystem">();
	}
	static class UHWLeaderboardSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLeaderboardSubsystem>();
	}
};
static_assert(alignof(UHWLeaderboardSubsystem) == 0x000008, "Wrong alignment on UHWLeaderboardSubsystem");
static_assert(sizeof(UHWLeaderboardSubsystem) == 0x000178, "Wrong size on UHWLeaderboardSubsystem");
static_assert(offsetof(UHWLeaderboardSubsystem, LeaderboardIdToIndex) == 0x000030, "Member 'UHWLeaderboardSubsystem::LeaderboardIdToIndex' has a wrong offset!");
static_assert(offsetof(UHWLeaderboardSubsystem, LeaderboardIds) == 0x000080, "Member 'UHWLeaderboardSubsystem::LeaderboardIds' has a wrong offset!");
static_assert(offsetof(UHWLeaderboardSubsystem, LeaderBoardDataContainers) == 0x0000E0, "Member 'UHWLeaderboardSubsystem::LeaderBoardDataContainers' has a wrong offset!");
static_assert(offsetof(UHWLeaderboardSubsystem, LastReceivedLeaderboardId) == 0x000130, "Member 'UHWLeaderboardSubsystem::LastReceivedLeaderboardId' has a wrong offset!");
static_assert(offsetof(UHWLeaderboardSubsystem, LeaderboardConfig) == 0x000140, "Member 'UHWLeaderboardSubsystem::LeaderboardConfig' has a wrong offset!");

// Class Hemingway.HWLocalPlayerInventorySubsystem
// 0x0068 (0x0098 - 0x0030)
class UHWLocalPlayerInventorySubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_30[0x61];                                      // 0x0030(0x0061)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableCheckDivineLegacyLink;                      // 0x0091(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableCheckDivineLegacyLinkWeb;                   // 0x0092(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnLinkedPlatformsLoaded(const TArray<class URH_PlayerPlatformInfo*>& Platforms);
	void HandleOnLocalPlayerInventoryLoaded(const TArray<int32>& UpdatedInventoryIds, class URH_PlayerInfo* PlayerInfo);
	void HandleOnLocalPlayerInventoryUpdated(const TArray<int32>& UpdatedInventoryIds, class URH_PlayerInfo* PlayerInfo);
	void HandleOnLoginComplete(const struct FRH_LoginResult& LoginResult);
	void OnDoSmite1Link();
	void OnPlayedSMITE();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWLocalPlayerInventorySubsystem">();
	}
	static class UHWLocalPlayerInventorySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWLocalPlayerInventorySubsystem>();
	}
};
static_assert(alignof(UHWLocalPlayerInventorySubsystem) == 0x000008, "Wrong alignment on UHWLocalPlayerInventorySubsystem");
static_assert(sizeof(UHWLocalPlayerInventorySubsystem) == 0x000098, "Wrong size on UHWLocalPlayerInventorySubsystem");
static_assert(offsetof(UHWLocalPlayerInventorySubsystem, bEnableCheckDivineLegacyLink) == 0x000091, "Member 'UHWLocalPlayerInventorySubsystem::bEnableCheckDivineLegacyLink' has a wrong offset!");
static_assert(offsetof(UHWLocalPlayerInventorySubsystem, bEnableCheckDivineLegacyLinkWeb) == 0x000092, "Member 'UHWLocalPlayerInventorySubsystem::bEnableCheckDivineLegacyLinkWeb' has a wrong offset!");

// Class Hemingway.HWMatchDataSubsystem
// 0x0218 (0x0248 - 0x0030)
class UHWMatchDataSubsystem final : public UGameInstanceSubsystem
{
public:
	TSoftObjectPtr<class UStringTable>            CombatLogSTSoftPtr;                                // 0x0030(0x0028)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsChatLogEnabled;                                 // 0x0078(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0xF];                                       // 0x0079(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWChatLogAzureResults                 ChatLogAzureResults;                               // 0x0088(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0xA0];                                      // 0x0098(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWInstanceInfo_PlayerDataList         PlayerData;                                        // 0x0138(0x00A0)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FHWTeamPlayersSnapshot>         TeamPlayersSnapshot;                               // 0x01D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         InitialTeamSize;                                   // 0x01E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMatchRecordingDemo;                             // 0x01EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1ED[0x3];                                      // 0x01ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DemoFlagItemId;                                    // 0x01F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LevelThresholdForNewPlayerDemos;                   // 0x01F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentChanceToDemoRecordUnderLevel;               // 0x01F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              RHBotIdsTable;                                     // 0x0200(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x20];                                     // 0x0228(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CombatLogLobbyEvent(EPlayerEventType LobbyEventType, const struct FGuid& PlayerGuid, const class UHWCharacterItem* LobbyChar, const int32& TeamId, const class FString& ItemNameOverride);
	bool DoesMatchSupportBotFill();
	struct FHWInstanceInfo_PlayerDataList GetMatchComposition();
	void HandleDemoStoppedRecording(class UWorld* World);
	void OnCheckedPlayerLevelForDemo(class URH_PlayerInfo* PlayerInfo, const TArray<struct FRHAPI_InventoryLevel>& InventoryLevels);
	void OnDemoFlagOwnershipChecked(bool bIsOwned, class URHStoreItem* CatalogItem);
	void OnEquipmentPurchased(class UHWEquipmentInstance* EquipmentInstance, const struct FHWInventorySlot& Slot);
	void OnPlayerHoveredLobbyPick(const struct FHWPersistentPlayerId& PlayerGuid, const class UHWCharacterItem* HoveredPick, const int32& TeamId);
	void OnRHSessionChanged(class URH_JoinedSession* OldSession, class URH_JoinedSession* ActiveSession);
	void UpdateMatchComposition(const struct FHWInstanceInfo_PlayerDataList& InPlayerData);
	void UpdateTeamPlayer(const struct FGenericTeamId& TeamId, const struct FHWTeamPlayer& InTeamPlayer);

	bool GetCachedTeamPlayer(const class AHWPlayerState* PlayerState, struct FHWTeamPlayer* OutTeamPlayer) const;
	const TArray<struct FHWTeamPlayersSnapshot> GetCachedTeamPlayersSnapshot() const;
	bool GetCachedTeamPlayersSnapshotForTeam(const struct FGenericTeamId& TeamId, struct FHWTeamPlayersSnapshot* OutTeamPlayersSnapshot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWMatchDataSubsystem">();
	}
	static class UHWMatchDataSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWMatchDataSubsystem>();
	}
};
static_assert(alignof(UHWMatchDataSubsystem) == 0x000008, "Wrong alignment on UHWMatchDataSubsystem");
static_assert(sizeof(UHWMatchDataSubsystem) == 0x000248, "Wrong size on UHWMatchDataSubsystem");
static_assert(offsetof(UHWMatchDataSubsystem, CombatLogSTSoftPtr) == 0x000030, "Member 'UHWMatchDataSubsystem::CombatLogSTSoftPtr' has a wrong offset!");
static_assert(offsetof(UHWMatchDataSubsystem, bIsChatLogEnabled) == 0x000078, "Member 'UHWMatchDataSubsystem::bIsChatLogEnabled' has a wrong offset!");
static_assert(offsetof(UHWMatchDataSubsystem, ChatLogAzureResults) == 0x000088, "Member 'UHWMatchDataSubsystem::ChatLogAzureResults' has a wrong offset!");
static_assert(offsetof(UHWMatchDataSubsystem, PlayerData) == 0x000138, "Member 'UHWMatchDataSubsystem::PlayerData' has a wrong offset!");
static_assert(offsetof(UHWMatchDataSubsystem, TeamPlayersSnapshot) == 0x0001D8, "Member 'UHWMatchDataSubsystem::TeamPlayersSnapshot' has a wrong offset!");
static_assert(offsetof(UHWMatchDataSubsystem, InitialTeamSize) == 0x0001E8, "Member 'UHWMatchDataSubsystem::InitialTeamSize' has a wrong offset!");
static_assert(offsetof(UHWMatchDataSubsystem, bIsMatchRecordingDemo) == 0x0001EC, "Member 'UHWMatchDataSubsystem::bIsMatchRecordingDemo' has a wrong offset!");
static_assert(offsetof(UHWMatchDataSubsystem, DemoFlagItemId) == 0x0001F0, "Member 'UHWMatchDataSubsystem::DemoFlagItemId' has a wrong offset!");
static_assert(offsetof(UHWMatchDataSubsystem, LevelThresholdForNewPlayerDemos) == 0x0001F4, "Member 'UHWMatchDataSubsystem::LevelThresholdForNewPlayerDemos' has a wrong offset!");
static_assert(offsetof(UHWMatchDataSubsystem, PercentChanceToDemoRecordUnderLevel) == 0x0001F8, "Member 'UHWMatchDataSubsystem::PercentChanceToDemoRecordUnderLevel' has a wrong offset!");
static_assert(offsetof(UHWMatchDataSubsystem, RHBotIdsTable) == 0x000200, "Member 'UHWMatchDataSubsystem::RHBotIdsTable' has a wrong offset!");

// Class Hemingway.HWPlayerSettingsSubsystem
// 0x02C0 (0x02F0 - 0x0030)
class UHWPlayerSettingsSubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_30[0xB8];                                      // 0x0030(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URHSettingsInfoBase*>            CachedSettingsInfos;                               // 0x00E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x158];                                     // 0x00F8(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWMappingContextComponent*             MappingContextComponent;                           // 0x0250(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHWPlayerSettingsKeybinds_ContextEntry> CachedKeybindsData;                        // 0x0258(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x30];                                     // 0x0268(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWPlayerData                          CachedPlayerData;                                  // 0x0298(0x0028)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SettingsVersionManagerPath;                        // 0x02C8(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHWSettingsVersionManager*              SettingsVersionManager;                            // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CreatePlayerSettingUpdatedCallback(const class FName SettingName, const struct FHWSettingDelegateStruct& Delegate);
	void RemovePlayerSettingUpdatedCallback(const class FName SettingName, const class UObject* CallbackOwner);

	const TArray<struct FRH_ItemId> GetFavoriteGodItemIds() const;
	struct FDateTime GetLastSeenOrderTime() const;
	class UHWMappingContextComponent* GetMappingContextComponent() const;
	class FString GetSelectedQueueId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWPlayerSettingsSubsystem">();
	}
	static class UHWPlayerSettingsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWPlayerSettingsSubsystem>();
	}
};
static_assert(alignof(UHWPlayerSettingsSubsystem) == 0x000008, "Wrong alignment on UHWPlayerSettingsSubsystem");
static_assert(sizeof(UHWPlayerSettingsSubsystem) == 0x0002F0, "Wrong size on UHWPlayerSettingsSubsystem");
static_assert(offsetof(UHWPlayerSettingsSubsystem, CachedSettingsInfos) == 0x0000E8, "Member 'UHWPlayerSettingsSubsystem::CachedSettingsInfos' has a wrong offset!");
static_assert(offsetof(UHWPlayerSettingsSubsystem, MappingContextComponent) == 0x000250, "Member 'UHWPlayerSettingsSubsystem::MappingContextComponent' has a wrong offset!");
static_assert(offsetof(UHWPlayerSettingsSubsystem, CachedKeybindsData) == 0x000258, "Member 'UHWPlayerSettingsSubsystem::CachedKeybindsData' has a wrong offset!");
static_assert(offsetof(UHWPlayerSettingsSubsystem, CachedPlayerData) == 0x000298, "Member 'UHWPlayerSettingsSubsystem::CachedPlayerData' has a wrong offset!");
static_assert(offsetof(UHWPlayerSettingsSubsystem, SettingsVersionManagerPath) == 0x0002C8, "Member 'UHWPlayerSettingsSubsystem::SettingsVersionManagerPath' has a wrong offset!");
static_assert(offsetof(UHWPlayerSettingsSubsystem, SettingsVersionManager) == 0x0002E8, "Member 'UHWPlayerSettingsSubsystem::SettingsVersionManager' has a wrong offset!");

// Class Hemingway.HWSettingsInfo_AudioDevice
// 0x0008 (0x0190 - 0x0188)
class UHWSettingsInfo_AudioDevice : public URHSettingsInfoBase
{
public:
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSettingApplied();
	void OnSettingSaved();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSettingsInfo_AudioDevice">();
	}
	static class UHWSettingsInfo_AudioDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSettingsInfo_AudioDevice>();
	}
};
static_assert(alignof(UHWSettingsInfo_AudioDevice) == 0x000008, "Wrong alignment on UHWSettingsInfo_AudioDevice");
static_assert(sizeof(UHWSettingsInfo_AudioDevice) == 0x000190, "Wrong size on UHWSettingsInfo_AudioDevice");

// Class Hemingway.HWSettingsSubsystemInterface
// 0x0000 (0x0000 - 0x0000)
class IHWSettingsSubsystemInterface final
{
public:
	bool GetSettingAsBool(class FName Name_0, bool* OutBool) const;
	bool GetSettingAsFloat(class FName Name_0, float* OutFloat) const;
	bool GetSettingAsInt(class FName Name_0, int32* OutInt) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSettingsSubsystemInterface">();
	}
	static class IHWSettingsSubsystemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHWSettingsSubsystemInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHWSettingsSubsystemInterface) == 0x000001, "Wrong alignment on IHWSettingsSubsystemInterface");
static_assert(sizeof(IHWSettingsSubsystemInterface) == 0x000001, "Wrong size on IHWSettingsSubsystemInterface");

// Class Hemingway.HWSystemSettingsSubsystem
// 0x00C0 (0x00F0 - 0x0030)
class UHWSystemSettingsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xAC];                                      // 0x0030(0x00AC)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWPlatformBool                        bAllowSettingsBackendSave;                         // 0x00DC(0x0003)(Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_DF[0x1];                                       // 0x00DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URHSettingsInfoBase*>            CachedSettingsInfos;                               // 0x00E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void CreateSystemSettingUpdatedCallback(const class FName SettingName, const struct FHWSettingDelegateStruct& Delegate);
	void HandleSettingApplied(class FName Name_0);
	void RemoveSystemSettingUpdatedCallback(const class FName SettingName, const class UObject* CallbackOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWSystemSettingsSubsystem">();
	}
	static class UHWSystemSettingsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWSystemSettingsSubsystem>();
	}
};
static_assert(alignof(UHWSystemSettingsSubsystem) == 0x000008, "Wrong alignment on UHWSystemSettingsSubsystem");
static_assert(sizeof(UHWSystemSettingsSubsystem) == 0x0000F0, "Wrong size on UHWSystemSettingsSubsystem");
static_assert(offsetof(UHWSystemSettingsSubsystem, bAllowSettingsBackendSave) == 0x0000DC, "Member 'UHWSystemSettingsSubsystem::bAllowSettingsBackendSave' has a wrong offset!");
static_assert(offsetof(UHWSystemSettingsSubsystem, CachedSettingsInfos) == 0x0000E0, "Member 'UHWSystemSettingsSubsystem::CachedSettingsInfos' has a wrong offset!");

// Class Hemingway.HWUpscalerSubsystem
// 0x0008 (0x0038 - 0x0030)
class UHWUpscalerSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAAMethodSettingChanged();
	void HandleDLSSFrameGenSettingChanged();
	void HandleDLSSSettingChanged();
	void HandleFSRFrameGenSettingChanged();
	void HandleFSRSettingChanged();
	void HandleUpscalersKVChanged(const struct FGameplayTag& AppSettingTag, bool bValue);
	void HandleXeSSSettingChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWUpscalerSubsystem">();
	}
	static class UHWUpscalerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWUpscalerSubsystem>();
	}
};
static_assert(alignof(UHWUpscalerSubsystem) == 0x000008, "Wrong alignment on UHWUpscalerSubsystem");
static_assert(sizeof(UHWUpscalerSubsystem) == 0x000038, "Wrong size on UHWUpscalerSubsystem");

// Class Hemingway.VisibilityData
// 0x0200 (0x0228 - 0x0028)
class UVisibilityData final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWGameplayTargetDataFilter_Stealth    StealthFilter;                                     // 0x0040(0x01E8)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void HandleActiveGameplayEffectAdded(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpec& EffectSpec, const struct FActiveGameplayEffectHandle& EffectHandle);
	void HandleAnyGameplayEffectRemoved(const struct FActiveGameplayEffect& ActiveGameplayEffect);
	void HandleInstigatorStealthToTargetUpdate();
	void OnRep_StealthFilter();

	uint8 GetStealthStatusToTarget(const class AActor* ObservingActor) const;
	bool IsTargetTypeVisibleToEntireTeam(const class AHWTeamState* ObservingTeamState) const;
	bool ShouldIgnoreTeamVisibilitySharing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibilityData">();
	}
	static class UVisibilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisibilityData>();
	}
};
static_assert(alignof(UVisibilityData) == 0x000008, "Wrong alignment on UVisibilityData");
static_assert(sizeof(UVisibilityData) == 0x000228, "Wrong size on UVisibilityData");
static_assert(offsetof(UVisibilityData, StealthFilter) == 0x000040, "Member 'UVisibilityData::StealthFilter' has a wrong offset!");

// Class Hemingway.HWEffectVolumeSettings
// 0x0010 (0x0038 - 0x0028)
class UHWEffectVolumeSettings final : public UObject
{
public:
	TArray<TSubclassOf<class UHWEffectVolumeEffectInfo>> VolumeEffectInfoClassList;                  // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEffectVolumeSettings">();
	}
	static class UHWEffectVolumeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEffectVolumeSettings>();
	}
};
static_assert(alignof(UHWEffectVolumeSettings) == 0x000008, "Wrong alignment on UHWEffectVolumeSettings");
static_assert(sizeof(UHWEffectVolumeSettings) == 0x000038, "Wrong size on UHWEffectVolumeSettings");
static_assert(offsetof(UHWEffectVolumeSettings, VolumeEffectInfoClassList) == 0x000028, "Member 'UHWEffectVolumeSettings::VolumeEffectInfoClassList' has a wrong offset!");

// Class Hemingway.HWEffectVolumeEffectInfo
// 0x0010 (0x0038 - 0x0028)
class UHWEffectVolumeEffectInfo final : public UObject
{
public:
	TSubclassOf<class UHWGameplayEffect>          GameplayEffectClass;                               // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVolumeApplicationTiming                      ApplicationGameplayEffectTiming;                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RemoveGameplayEffectOnLeavingVolume;               // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWEffectVolumeEffectInfo">();
	}
	static class UHWEffectVolumeEffectInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHWEffectVolumeEffectInfo>();
	}
};
static_assert(alignof(UHWEffectVolumeEffectInfo) == 0x000008, "Wrong alignment on UHWEffectVolumeEffectInfo");
static_assert(sizeof(UHWEffectVolumeEffectInfo) == 0x000038, "Wrong size on UHWEffectVolumeEffectInfo");
static_assert(offsetof(UHWEffectVolumeEffectInfo, GameplayEffectClass) == 0x000028, "Member 'UHWEffectVolumeEffectInfo::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(UHWEffectVolumeEffectInfo, ApplicationGameplayEffectTiming) == 0x000030, "Member 'UHWEffectVolumeEffectInfo::ApplicationGameplayEffectTiming' has a wrong offset!");
static_assert(offsetof(UHWEffectVolumeEffectInfo, RemoveGameplayEffectOnLeavingVolume) == 0x000034, "Member 'UHWEffectVolumeEffectInfo::RemoveGameplayEffectOnLeavingVolume' has a wrong offset!");

// Class Hemingway.HWGroundTargetingPlacementBlockerMeshActor
// 0x0008 (0x02B0 - 0x02A8)
class AHWGroundTargetingPlacementBlockerMeshActor final : public AStaticMeshActor
{
public:
	class UHWGroundTargetingPlacementBlockerComponent* TargetingBlockerComponent;                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HWGroundTargetingPlacementBlockerMeshActor">();
	}
	static class AHWGroundTargetingPlacementBlockerMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHWGroundTargetingPlacementBlockerMeshActor>();
	}
};
static_assert(alignof(AHWGroundTargetingPlacementBlockerMeshActor) == 0x000008, "Wrong alignment on AHWGroundTargetingPlacementBlockerMeshActor");
static_assert(sizeof(AHWGroundTargetingPlacementBlockerMeshActor) == 0x0002B0, "Wrong size on AHWGroundTargetingPlacementBlockerMeshActor");
static_assert(offsetof(AHWGroundTargetingPlacementBlockerMeshActor, TargetingBlockerComponent) == 0x0002A8, "Member 'AHWGroundTargetingPlacementBlockerMeshActor::TargetingBlockerComponent' has a wrong offset!");

}

