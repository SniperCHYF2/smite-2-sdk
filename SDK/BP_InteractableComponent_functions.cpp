#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_InteractableComponent

#include "Basic.hpp"

#include "BP_InteractableComponent_classes.hpp"
#include "BP_InteractableComponent_parameters.hpp"


namespace SDK
{

// Function BP_InteractableComponent.BP_InteractableComponent_C.DisplayErrorMessage
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      ErrorMessage_0                                         (BlueprintVisible, BlueprintReadOnly, Parm)

void UBP_InteractableComponent_C::DisplayErrorMessage(const class FText& ErrorMessage_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "DisplayErrorMessage");

	Params::BP_InteractableComponent_C_DisplayErrorMessage Parms{};

	Parms.ErrorMessage_0 = std::move(ErrorMessage_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.EndInteraction
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           InteractInstigator                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const bool                              bWasCancelled                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::EndInteraction(class AActor* InteractInstigator, const bool bWasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "EndInteraction");

	Params::BP_InteractableComponent_C_EndInteraction Parms{};

	Parms.InteractInstigator = InteractInstigator;
	Parms.bWasCancelled = bWasCancelled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.ExecuteUbergraph_BP_InteractableComponent
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::ExecuteUbergraph_BP_InteractableComponent(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "ExecuteUbergraph_BP_InteractableComponent");

	Params::BP_InteractableComponent_C_ExecuteUbergraph_BP_InteractableComponent Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.GetInteractionWidget
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_InteractableComponent_C::GetInteractionWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "GetInteractionWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.GetTeamInfamy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   TeamId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EJungleTribes                           Tribe                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_TribeRenown*                  Infamy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::GetTeamInfamy(int32 TeamId, EJungleTribes Tribe, struct FS_TribeRenown* Infamy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "GetTeamInfamy");

	Params::BP_InteractableComponent_C_GetTeamInfamy Parms{};

	Parms.TeamId = TeamId;
	Parms.Tribe = Tribe;

	UObject::ProcessEvent(Func, &Parms);

	if (Infamy != nullptr)
		*Infamy = std::move(Parms.Infamy);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.IsClientOnCooldown
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   IsOnCooldown                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::IsClientOnCooldown(bool* IsOnCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "IsClientOnCooldown");

	Params::BP_InteractableComponent_C_IsClientOnCooldown Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsOnCooldown != nullptr)
		*IsOnCooldown = Parms.IsOnCooldown;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.MulticastDisplayErrorMessage
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Instigator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FText&                      ErrorMessage_0                                         (BlueprintVisible, BlueprintReadOnly, Parm)

void UBP_InteractableComponent_C::MulticastDisplayErrorMessage(class AActor* Instigator, const class FText& ErrorMessage_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "MulticastDisplayErrorMessage");

	Params::BP_InteractableComponent_C_MulticastDisplayErrorMessage Parms{};

	Parms.Instigator = Instigator;
	Parms.ErrorMessage_0 = std::move(ErrorMessage_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.OnInteractFieldBeginOverlap
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UBP_InteractableComponent_C::OnInteractFieldBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "OnInteractFieldBeginOverlap");

	Params::BP_InteractableComponent_C_OnInteractFieldBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.OnInteractFieldEndOverlap
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::OnInteractFieldEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "OnInteractFieldEndOverlap");

	Params::BP_InteractableComponent_C_OnInteractFieldEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UBP_InteractableComponent_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.SetCancelVisual
// (BlueprintCallable, BlueprintEvent)

void UBP_InteractableComponent_C::SetCancelVisual()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "SetCancelVisual");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.StartInteraction
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           InteractInstigator                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::StartInteraction(class AActor* InteractInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "StartInteraction");

	Params::BP_InteractableComponent_C_StartInteraction Parms{};

	Parms.InteractInstigator = InteractInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.UpdateCooldownSwitch
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::UpdateCooldownSwitch(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "UpdateCooldownSwitch");

	Params::BP_InteractableComponent_C_UpdateCooldownSwitch Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.UpdateInteractHUDWidget
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_InteractableComponent_C::UpdateInteractHUDWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "UpdateInteractHUDWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.UpdateOwningTeam
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentOwningTeam_0                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::UpdateOwningTeam(int32 CurrentOwningTeam_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "UpdateOwningTeam");

	Params::BP_InteractableComponent_C_UpdateOwningTeam Parms{};

	Parms.CurrentOwningTeam_0 = CurrentOwningTeam_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.UpdatePromptVisuals
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              bShowPrompt                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::UpdatePromptVisuals(const bool bShowPrompt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "UpdatePromptVisuals");

	Params::BP_InteractableComponent_C_UpdatePromptVisuals Parms{};

	Parms.bShowPrompt = bShowPrompt;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.CanEverInteractWith
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class AActor*                     InteractInstigator                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_InteractableComponent_C::CanEverInteractWith(const class AActor* InteractInstigator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "CanEverInteractWith");

	Params::BP_InteractableComponent_C_CanEverInteractWith Parms{};

	Parms.InteractInstigator = InteractInstigator;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.CanInteractWith
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class AActor*                     InteractInstigator                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_InteractableComponent_C::CanInteractWith(const class AActor* InteractInstigator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "CanInteractWith");

	Params::BP_InteractableComponent_C_CanInteractWith Parms{};

	Parms.InteractInstigator = InteractInstigator;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.CheckCooldownTag
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           TeamMemberActor                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasMatchingCooldownTag                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::CheckCooldownTag(class AActor* TeamMemberActor, bool* HasMatchingCooldownTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "CheckCooldownTag");

	Params::BP_InteractableComponent_C_CheckCooldownTag Parms{};

	Parms.TeamMemberActor = TeamMemberActor;

	UObject::ProcessEvent(Func, &Parms);

	if (HasMatchingCooldownTag != nullptr)
		*HasMatchingCooldownTag = Parms.HasMatchingCooldownTag;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.CheckInteractCompatibility
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           Instigator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsCompatible                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::CheckInteractCompatibility(class AActor* Instigator, bool* IsCompatible) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "CheckInteractCompatibility");

	Params::BP_InteractableComponent_C_CheckInteractCompatibility Parms{};

	Parms.Instigator = Instigator;

	UObject::ProcessEvent(Func, &Parms);

	if (IsCompatible != nullptr)
		*IsCompatible = Parms.IsCompatible;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.CheckOverrideTag
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           TeamMemberActor                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   InteractionAllowed                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::CheckOverrideTag(class AActor* TeamMemberActor, bool* InteractionAllowed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "CheckOverrideTag");

	Params::BP_InteractableComponent_C_CheckOverrideTag Parms{};

	Parms.TeamMemberActor = TeamMemberActor;

	UObject::ProcessEvent(Func, &Parms);

	if (InteractionAllowed != nullptr)
		*InteractionAllowed = Parms.InteractionAllowed;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.CheckRenownLevel
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           TeamMemberActor                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   InteractionAllowed                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::CheckRenownLevel(class AActor* TeamMemberActor, bool* InteractionAllowed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "CheckRenownLevel");

	Params::BP_InteractableComponent_C_CheckRenownLevel Parms{};

	Parms.TeamMemberActor = TeamMemberActor;

	UObject::ProcessEvent(Func, &Parms);

	if (InteractionAllowed != nullptr)
		*InteractionAllowed = Parms.InteractionAllowed;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.CheckTag
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           TeamMemberActor                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasMatchingTag                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::CheckTag(class AActor* TeamMemberActor, bool* HasMatchingTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "CheckTag");

	Params::BP_InteractableComponent_C_CheckTag Parms{};

	Parms.TeamMemberActor = TeamMemberActor;

	UObject::ProcessEvent(Func, &Parms);

	if (HasMatchingTag != nullptr)
		*HasMatchingTag = Parms.HasMatchingTag;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.CheckTeams
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           TeamMemberActor                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   InteractionAllowed                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::CheckTeams(class AActor* TeamMemberActor, bool* InteractionAllowed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "CheckTeams");

	Params::BP_InteractableComponent_C_CheckTeams Parms{};

	Parms.TeamMemberActor = TeamMemberActor;

	UObject::ProcessEvent(Func, &Parms);

	if (InteractionAllowed != nullptr)
		*InteractionAllowed = Parms.InteractionAllowed;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.GetCooldownInfoForWidget
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           TeamMemberActor                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// float*                                  CooldownDuration                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 TotalCooldownDuration                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::GetCooldownInfoForWidget(class AActor* TeamMemberActor, float* CooldownDuration, double* TotalCooldownDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "GetCooldownInfoForWidget");

	Params::BP_InteractableComponent_C_GetCooldownInfoForWidget Parms{};

	Parms.TeamMemberActor = TeamMemberActor;

	UObject::ProcessEvent(Func, &Parms);

	if (CooldownDuration != nullptr)
		*CooldownDuration = Parms.CooldownDuration;

	if (TotalCooldownDuration != nullptr)
		*TotalCooldownDuration = Parms.TotalCooldownDuration;
}


// Function BP_InteractableComponent.BP_InteractableComponent_C.GetOwningTeam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32*                                  OwningTeam                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_InteractableComponent_C::GetOwningTeam(int32* OwningTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_InteractableComponent_C", "GetOwningTeam");

	Params::BP_InteractableComponent_C_GetOwningTeam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OwningTeam != nullptr)
		*OwningTeam = Parms.OwningTeam;
}

}

