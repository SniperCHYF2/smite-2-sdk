#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hemingway

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Hemingway_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Engine_structs.hpp"
#include "DataTableSkinsCommon_structs.hpp"
#include "RallyHereAPI_structs.hpp"
#include "AIModule_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "BanPickDraftCommon_structs.hpp"
#include "RallyHereIntegration_structs.hpp"
#include "CommonInput_structs.hpp"
#include "NetCore_structs.hpp"
#include "Niagara_structs.hpp"
#include "InputCore_structs.hpp"
#include "RallyHereStart_structs.hpp"


namespace SDK::Params
{

// Function Hemingway.HWCharacter_AnimInstBase.DetermineSkinnedFiringMontageTag
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_AnimInstBase_DetermineSkinnedFiringMontageTag final
{
public:
	struct FGameplayTag                           SourceIdTag;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstBase_DetermineSkinnedFiringMontageTag) == 0x000004, "Wrong alignment on HWCharacter_AnimInstBase_DetermineSkinnedFiringMontageTag");
static_assert(sizeof(HWCharacter_AnimInstBase_DetermineSkinnedFiringMontageTag) == 0x000008, "Wrong size on HWCharacter_AnimInstBase_DetermineSkinnedFiringMontageTag");
static_assert(offsetof(HWCharacter_AnimInstBase_DetermineSkinnedFiringMontageTag, SourceIdTag) == 0x000000, "Member 'HWCharacter_AnimInstBase_DetermineSkinnedFiringMontageTag::SourceIdTag' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstBase.GetJumpMovingTime
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_AnimInstBase_GetJumpMovingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstBase_GetJumpMovingTime) == 0x000004, "Wrong alignment on HWCharacter_AnimInstBase_GetJumpMovingTime");
static_assert(sizeof(HWCharacter_AnimInstBase_GetJumpMovingTime) == 0x000004, "Wrong size on HWCharacter_AnimInstBase_GetJumpMovingTime");
static_assert(offsetof(HWCharacter_AnimInstBase_GetJumpMovingTime, ReturnValue) == 0x000000, "Member 'HWCharacter_AnimInstBase_GetJumpMovingTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstBase.OnCharacterASCUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_AnimInstBase_OnCharacterASCUpdated final
{
public:
	class UHWAbilitySystemComponent*              UpdatedASC;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OldAbilitySystem;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstBase_OnCharacterASCUpdated) == 0x000008, "Wrong alignment on HWCharacter_AnimInstBase_OnCharacterASCUpdated");
static_assert(sizeof(HWCharacter_AnimInstBase_OnCharacterASCUpdated) == 0x000010, "Wrong size on HWCharacter_AnimInstBase_OnCharacterASCUpdated");
static_assert(offsetof(HWCharacter_AnimInstBase_OnCharacterASCUpdated, UpdatedASC) == 0x000000, "Member 'HWCharacter_AnimInstBase_OnCharacterASCUpdated::UpdatedASC' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstBase_OnCharacterASCUpdated, OldAbilitySystem) == 0x000008, "Member 'HWCharacter_AnimInstBase_OnCharacterASCUpdated::OldAbilitySystem' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstBase.OnMovementModeUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_AnimInstBase_OnMovementModeUpdated final
{
public:
	class ACharacter*                             NewCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_AnimInstBase_OnMovementModeUpdated) == 0x000008, "Wrong alignment on HWCharacter_AnimInstBase_OnMovementModeUpdated");
static_assert(sizeof(HWCharacter_AnimInstBase_OnMovementModeUpdated) == 0x000010, "Wrong size on HWCharacter_AnimInstBase_OnMovementModeUpdated");
static_assert(offsetof(HWCharacter_AnimInstBase_OnMovementModeUpdated, NewCharacter) == 0x000000, "Member 'HWCharacter_AnimInstBase_OnMovementModeUpdated::NewCharacter' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstBase_OnMovementModeUpdated, PrevMovementMode) == 0x000008, "Member 'HWCharacter_AnimInstBase_OnMovementModeUpdated::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstBase_OnMovementModeUpdated, PreviousCustomMode) == 0x000009, "Member 'HWCharacter_AnimInstBase_OnMovementModeUpdated::PreviousCustomMode' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstBase.OnStatusTagsUpdated
// 0x000C (0x000C - 0x0000)
struct HWCharacter_AnimInstBase_OnStatusTagsUpdated final
{
public:
	struct FGameplayTag                           UpdatedStatusTag;                                  // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStackCount;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstBase_OnStatusTagsUpdated) == 0x000004, "Wrong alignment on HWCharacter_AnimInstBase_OnStatusTagsUpdated");
static_assert(sizeof(HWCharacter_AnimInstBase_OnStatusTagsUpdated) == 0x00000C, "Wrong size on HWCharacter_AnimInstBase_OnStatusTagsUpdated");
static_assert(offsetof(HWCharacter_AnimInstBase_OnStatusTagsUpdated, UpdatedStatusTag) == 0x000000, "Member 'HWCharacter_AnimInstBase_OnStatusTagsUpdated::UpdatedStatusTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstBase_OnStatusTagsUpdated, NewStackCount) == 0x000008, "Member 'HWCharacter_AnimInstBase_OnStatusTagsUpdated::NewStackCount' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstBase.TryToTriggerTurnInPlaceAnimation
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_AnimInstBase_TryToTriggerTurnInPlaceAnimation final
{
public:
	EHWAnimTurninPLace                            AnimationVariant;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTime;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstBase_TryToTriggerTurnInPlaceAnimation) == 0x000004, "Wrong alignment on HWCharacter_AnimInstBase_TryToTriggerTurnInPlaceAnimation");
static_assert(sizeof(HWCharacter_AnimInstBase_TryToTriggerTurnInPlaceAnimation) == 0x000008, "Wrong size on HWCharacter_AnimInstBase_TryToTriggerTurnInPlaceAnimation");
static_assert(offsetof(HWCharacter_AnimInstBase_TryToTriggerTurnInPlaceAnimation, AnimationVariant) == 0x000000, "Member 'HWCharacter_AnimInstBase_TryToTriggerTurnInPlaceAnimation::AnimationVariant' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstBase_TryToTriggerTurnInPlaceAnimation, DelayTime) == 0x000004, "Member 'HWCharacter_AnimInstBase_TryToTriggerTurnInPlaceAnimation::DelayTime' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstBase.GetCharacterMovementMode
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_AnimInstBase_GetCharacterMovementMode final
{
public:
	EMovementMode                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstBase_GetCharacterMovementMode) == 0x000001, "Wrong alignment on HWCharacter_AnimInstBase_GetCharacterMovementMode");
static_assert(sizeof(HWCharacter_AnimInstBase_GetCharacterMovementMode) == 0x000001, "Wrong size on HWCharacter_AnimInstBase_GetCharacterMovementMode");
static_assert(offsetof(HWCharacter_AnimInstBase_GetCharacterMovementMode, ReturnValue) == 0x000000, "Member 'HWCharacter_AnimInstBase_GetCharacterMovementMode::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstBase.GetSkinnedFiringMontageTag
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag final
{
public:
	struct FGameplayTag                           SourceIdTag;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OriginalFiringMontageTag;                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag) == 0x000004, "Wrong alignment on HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag");
static_assert(sizeof(HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag) == 0x000018, "Wrong size on HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag");
static_assert(offsetof(HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag, SourceIdTag) == 0x000000, "Member 'HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag::SourceIdTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag, OriginalFiringMontageTag) == 0x000008, "Member 'HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag::OriginalFiringMontageTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag, ReturnValue) == 0x000010, "Member 'HWCharacter_AnimInstBase_GetSkinnedFiringMontageTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstBase.GetSkinnedTargetingMontageTag
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag final
{
public:
	struct FGameplayTag                           SourceIdTag;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OriginalTargetingMontageTag;                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag) == 0x000004, "Wrong alignment on HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag");
static_assert(sizeof(HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag) == 0x000018, "Wrong size on HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag");
static_assert(offsetof(HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag, SourceIdTag) == 0x000000, "Member 'HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag::SourceIdTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag, OriginalTargetingMontageTag) == 0x000008, "Member 'HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag::OriginalTargetingMontageTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag, ReturnValue) == 0x000010, "Member 'HWCharacter_AnimInstBase_GetSkinnedTargetingMontageTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings.CalcAim
// 0x00B0 (0x00B0 - 0x0000)
struct HWAbilityAimSettings_CalcAim final
{
public:
	struct FHWAimTargetingInfo                    AimTargetingInfo;                                  // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetingAimHandle;                                // 0x0080(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityAimSettings_CalcAim) == 0x000010, "Wrong alignment on HWAbilityAimSettings_CalcAim");
static_assert(sizeof(HWAbilityAimSettings_CalcAim) == 0x0000B0, "Wrong size on HWAbilityAimSettings_CalcAim");
static_assert(offsetof(HWAbilityAimSettings_CalcAim, AimTargetingInfo) == 0x000000, "Member 'HWAbilityAimSettings_CalcAim::AimTargetingInfo' has a wrong offset!");
static_assert(offsetof(HWAbilityAimSettings_CalcAim, TargetingAimHandle) == 0x000080, "Member 'HWAbilityAimSettings_CalcAim::TargetingAimHandle' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings.GetAimDirectionOffset
// 0x0018 (0x0018 - 0x0000)
struct HWAbilityAimSettings_GetAimDirectionOffset final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_GetAimDirectionOffset) == 0x000008, "Wrong alignment on HWAbilityAimSettings_GetAimDirectionOffset");
static_assert(sizeof(HWAbilityAimSettings_GetAimDirectionOffset) == 0x000018, "Wrong size on HWAbilityAimSettings_GetAimDirectionOffset");
static_assert(offsetof(HWAbilityAimSettings_GetAimDirectionOffset, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_GetAimDirectionOffset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings.GetPositionOffset
// 0x0018 (0x0018 - 0x0000)
struct HWAbilityAimSettings_GetPositionOffset final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_GetPositionOffset) == 0x000008, "Wrong alignment on HWAbilityAimSettings_GetPositionOffset");
static_assert(sizeof(HWAbilityAimSettings_GetPositionOffset) == 0x000018, "Wrong size on HWAbilityAimSettings_GetPositionOffset");
static_assert(offsetof(HWAbilityAimSettings_GetPositionOffset, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_GetPositionOffset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings.ShouldAdjustStartAimToGround
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityAimSettings_ShouldAdjustStartAimToGround final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_ShouldAdjustStartAimToGround) == 0x000001, "Wrong alignment on HWAbilityAimSettings_ShouldAdjustStartAimToGround");
static_assert(sizeof(HWAbilityAimSettings_ShouldAdjustStartAimToGround) == 0x000001, "Wrong size on HWAbilityAimSettings_ShouldAdjustStartAimToGround");
static_assert(offsetof(HWAbilityAimSettings_ShouldAdjustStartAimToGround, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_ShouldAdjustStartAimToGround::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings.ShouldOffsetAimByLastValidHeight
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityAimSettings_ShouldOffsetAimByLastValidHeight final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_ShouldOffsetAimByLastValidHeight) == 0x000001, "Wrong alignment on HWAbilityAimSettings_ShouldOffsetAimByLastValidHeight");
static_assert(sizeof(HWAbilityAimSettings_ShouldOffsetAimByLastValidHeight) == 0x000001, "Wrong size on HWAbilityAimSettings_ShouldOffsetAimByLastValidHeight");
static_assert(offsetof(HWAbilityAimSettings_ShouldOffsetAimByLastValidHeight, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_ShouldOffsetAimByLastValidHeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings.ShouldUseClientCachedAim
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityAimSettings_ShouldUseClientCachedAim final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_ShouldUseClientCachedAim) == 0x000001, "Wrong alignment on HWAbilityAimSettings_ShouldUseClientCachedAim");
static_assert(sizeof(HWAbilityAimSettings_ShouldUseClientCachedAim) == 0x000001, "Wrong size on HWAbilityAimSettings_ShouldUseClientCachedAim");
static_assert(offsetof(HWAbilityAimSettings_ShouldUseClientCachedAim, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_ShouldUseClientCachedAim::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings.ShouldUseClientCachedTargetList
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityAimSettings_ShouldUseClientCachedTargetList final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_ShouldUseClientCachedTargetList) == 0x000001, "Wrong alignment on HWAbilityAimSettings_ShouldUseClientCachedTargetList");
static_assert(sizeof(HWAbilityAimSettings_ShouldUseClientCachedTargetList) == 0x000001, "Wrong size on HWAbilityAimSettings_ShouldUseClientCachedTargetList");
static_assert(offsetof(HWAbilityAimSettings_ShouldUseClientCachedTargetList, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_ShouldUseClientCachedTargetList::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings.ShouldUseControllerRotation
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityAimSettings_ShouldUseControllerRotation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_ShouldUseControllerRotation) == 0x000001, "Wrong alignment on HWAbilityAimSettings_ShouldUseControllerRotation");
static_assert(sizeof(HWAbilityAimSettings_ShouldUseControllerRotation) == 0x000001, "Wrong size on HWAbilityAimSettings_ShouldUseControllerRotation");
static_assert(offsetof(HWAbilityAimSettings_ShouldUseControllerRotation, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_ShouldUseControllerRotation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings.ShouldUseSourceActorRotation
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityAimSettings_ShouldUseSourceActorRotation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_ShouldUseSourceActorRotation) == 0x000001, "Wrong alignment on HWAbilityAimSettings_ShouldUseSourceActorRotation");
static_assert(sizeof(HWAbilityAimSettings_ShouldUseSourceActorRotation) == 0x000001, "Wrong size on HWAbilityAimSettings_ShouldUseSourceActorRotation");
static_assert(offsetof(HWAbilityAimSettings_ShouldUseSourceActorRotation, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_ShouldUseSourceActorRotation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings_EightWayMovement.GetMaxRange
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAimSettings_EightWayMovement_GetMaxRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_EightWayMovement_GetMaxRange) == 0x000004, "Wrong alignment on HWAbilityAimSettings_EightWayMovement_GetMaxRange");
static_assert(sizeof(HWAbilityAimSettings_EightWayMovement_GetMaxRange) == 0x000004, "Wrong size on HWAbilityAimSettings_EightWayMovement_GetMaxRange");
static_assert(offsetof(HWAbilityAimSettings_EightWayMovement_GetMaxRange, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_EightWayMovement_GetMaxRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings_Self.GetManualCollisionRadius
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAimSettings_Self_GetManualCollisionRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_Self_GetManualCollisionRadius) == 0x000004, "Wrong alignment on HWAbilityAimSettings_Self_GetManualCollisionRadius");
static_assert(sizeof(HWAbilityAimSettings_Self_GetManualCollisionRadius) == 0x000004, "Wrong size on HWAbilityAimSettings_Self_GetManualCollisionRadius");
static_assert(offsetof(HWAbilityAimSettings_Self_GetManualCollisionRadius, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_Self_GetManualCollisionRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings.GetAcceptableTargetFilter
// 0x0020 (0x0020 - 0x0000)
struct HWAbilityAttackSettings_GetAcceptableTargetFilter final
{
public:
	class AActor*                                 Avatar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPredicting;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTargetDataFilterHandle        ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_GetAcceptableTargetFilter) == 0x000008, "Wrong alignment on HWAbilityAttackSettings_GetAcceptableTargetFilter");
static_assert(sizeof(HWAbilityAttackSettings_GetAcceptableTargetFilter) == 0x000020, "Wrong size on HWAbilityAttackSettings_GetAcceptableTargetFilter");
static_assert(offsetof(HWAbilityAttackSettings_GetAcceptableTargetFilter, Avatar) == 0x000000, "Member 'HWAbilityAttackSettings_GetAcceptableTargetFilter::Avatar' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_GetAcceptableTargetFilter, bIsPredicting) == 0x000008, "Member 'HWAbilityAttackSettings_GetAcceptableTargetFilter::bIsPredicting' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_GetAcceptableTargetFilter, ReturnValue) == 0x000010, "Member 'HWAbilityAttackSettings_GetAcceptableTargetFilter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings.GetAttackType
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityAttackSettings_GetAttackType final
{
public:
	EAbilityAttackType                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_GetAttackType) == 0x000001, "Wrong alignment on HWAbilityAttackSettings_GetAttackType");
static_assert(sizeof(HWAbilityAttackSettings_GetAttackType) == 0x000001, "Wrong size on HWAbilityAttackSettings_GetAttackType");
static_assert(offsetof(HWAbilityAttackSettings_GetAttackType, ReturnValue) == 0x000000, "Member 'HWAbilityAttackSettings_GetAttackType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings.GetEffectsForGroups
// 0x0030 (0x0030 - 0x0000)
struct HWAbilityAttackSettings_GetEffectsForGroups final
{
public:
	struct FGameplayTagContainer                  EffectGroupTags;                                   // 0x0000(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    OutEffects;                                        // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_GetEffectsForGroups) == 0x000008, "Wrong alignment on HWAbilityAttackSettings_GetEffectsForGroups");
static_assert(sizeof(HWAbilityAttackSettings_GetEffectsForGroups) == 0x000030, "Wrong size on HWAbilityAttackSettings_GetEffectsForGroups");
static_assert(offsetof(HWAbilityAttackSettings_GetEffectsForGroups, EffectGroupTags) == 0x000000, "Member 'HWAbilityAttackSettings_GetEffectsForGroups::EffectGroupTags' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_GetEffectsForGroups, OutEffects) == 0x000020, "Member 'HWAbilityAttackSettings_GetEffectsForGroups::OutEffects' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.AddMinimapModifier
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_AddMinimapModifier final
{
public:
	EHWMinimapModifier                            Modifier;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_AddMinimapModifier) == 0x000001, "Wrong alignment on HWCharacter_Base_AddMinimapModifier");
static_assert(sizeof(HWCharacter_Base_AddMinimapModifier) == 0x000001, "Wrong size on HWCharacter_Base_AddMinimapModifier");
static_assert(offsetof(HWCharacter_Base_AddMinimapModifier, Modifier) == 0x000000, "Member 'HWCharacter_Base_AddMinimapModifier::Modifier' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.AddOrUpdateBlendable
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_Base_AddOrUpdateBlendable final
{
public:
	TScriptInterface<class IBlendableInterface>   InBlendableObject;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWeight;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_Base_AddOrUpdateBlendable) == 0x000008, "Wrong alignment on HWCharacter_Base_AddOrUpdateBlendable");
static_assert(sizeof(HWCharacter_Base_AddOrUpdateBlendable) == 0x000018, "Wrong size on HWCharacter_Base_AddOrUpdateBlendable");
static_assert(offsetof(HWCharacter_Base_AddOrUpdateBlendable, InBlendableObject) == 0x000000, "Member 'HWCharacter_Base_AddOrUpdateBlendable::InBlendableObject' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_AddOrUpdateBlendable, InWeight) == 0x000010, "Member 'HWCharacter_Base_AddOrUpdateBlendable::InWeight' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.ApplyBotControl
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_Base_ApplyBotControl final
{
public:
	struct FVector                                InputVector;                                       // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_ApplyBotControl) == 0x000008, "Wrong alignment on HWCharacter_Base_ApplyBotControl");
static_assert(sizeof(HWCharacter_Base_ApplyBotControl) == 0x000018, "Wrong size on HWCharacter_Base_ApplyBotControl");
static_assert(offsetof(HWCharacter_Base_ApplyBotControl, InputVector) == 0x000000, "Member 'HWCharacter_Base_ApplyBotControl::InputVector' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.DidJustTeleport
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_DidJustTeleport final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_DidJustTeleport) == 0x000001, "Wrong alignment on HWCharacter_Base_DidJustTeleport");
static_assert(sizeof(HWCharacter_Base_DidJustTeleport) == 0x000001, "Wrong size on HWCharacter_Base_DidJustTeleport");
static_assert(offsetof(HWCharacter_Base_DidJustTeleport, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_DidJustTeleport::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetCameraPitchLimits
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_GetCameraPitchLimits final
{
public:
	double                                        PitchMin;                                          // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        PitchMax;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetCameraPitchLimits) == 0x000008, "Wrong alignment on HWCharacter_Base_GetCameraPitchLimits");
static_assert(sizeof(HWCharacter_Base_GetCameraPitchLimits) == 0x000010, "Wrong size on HWCharacter_Base_GetCameraPitchLimits");
static_assert(offsetof(HWCharacter_Base_GetCameraPitchLimits, PitchMin) == 0x000000, "Member 'HWCharacter_Base_GetCameraPitchLimits::PitchMin' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetCameraPitchLimits, PitchMax) == 0x000008, "Member 'HWCharacter_Base_GetCameraPitchLimits::PitchMax' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetCurrentTeleportEndLocation
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_Base_GetCurrentTeleportEndLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetCurrentTeleportEndLocation) == 0x000008, "Wrong alignment on HWCharacter_Base_GetCurrentTeleportEndLocation");
static_assert(sizeof(HWCharacter_Base_GetCurrentTeleportEndLocation) == 0x000018, "Wrong size on HWCharacter_Base_GetCurrentTeleportEndLocation");
static_assert(offsetof(HWCharacter_Base_GetCurrentTeleportEndLocation, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetCurrentTeleportEndLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetCurrentTeleportStartLocation
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_Base_GetCurrentTeleportStartLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetCurrentTeleportStartLocation) == 0x000008, "Wrong alignment on HWCharacter_Base_GetCurrentTeleportStartLocation");
static_assert(sizeof(HWCharacter_Base_GetCurrentTeleportStartLocation) == 0x000018, "Wrong size on HWCharacter_Base_GetCurrentTeleportStartLocation");
static_assert(offsetof(HWCharacter_Base_GetCurrentTeleportStartLocation, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetCurrentTeleportStartLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandelTagUpdated_UseControllerRotationYaw
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandelTagUpdated_UseControllerRotationYaw final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandelTagUpdated_UseControllerRotationYaw) == 0x000004, "Wrong alignment on HWCharacter_Base_HandelTagUpdated_UseControllerRotationYaw");
static_assert(sizeof(HWCharacter_Base_HandelTagUpdated_UseControllerRotationYaw) == 0x00000C, "Wrong size on HWCharacter_Base_HandelTagUpdated_UseControllerRotationYaw");
static_assert(offsetof(HWCharacter_Base_HandelTagUpdated_UseControllerRotationYaw, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandelTagUpdated_UseControllerRotationYaw::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandelTagUpdated_UseControllerRotationYaw, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandelTagUpdated_UseControllerRotationYaw::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleAbilitySystemUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_HandleAbilitySystemUpdated final
{
public:
	class UHWAbilitySystemComponent*              NewAbilitySystem;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OldAbilitySystem;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleAbilitySystemUpdated) == 0x000008, "Wrong alignment on HWCharacter_Base_HandleAbilitySystemUpdated");
static_assert(sizeof(HWCharacter_Base_HandleAbilitySystemUpdated) == 0x000010, "Wrong size on HWCharacter_Base_HandleAbilitySystemUpdated");
static_assert(offsetof(HWCharacter_Base_HandleAbilitySystemUpdated, NewAbilitySystem) == 0x000000, "Member 'HWCharacter_Base_HandleAbilitySystemUpdated::NewAbilitySystem' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleAbilitySystemUpdated, OldAbilitySystem) == 0x000008, "Member 'HWCharacter_Base_HandleAbilitySystemUpdated::OldAbilitySystem' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleOnNewSkinTagAsset
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_HandleOnNewSkinTagAsset final
{
public:
	TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleOnNewSkinTagAsset) == 0x000008, "Wrong alignment on HWCharacter_Base_HandleOnNewSkinTagAsset");
static_assert(sizeof(HWCharacter_Base_HandleOnNewSkinTagAsset) == 0x000010, "Wrong size on HWCharacter_Base_HandleOnNewSkinTagAsset");
static_assert(offsetof(HWCharacter_Base_HandleOnNewSkinTagAsset, NewSkinTagAsset) == 0x000000, "Member 'HWCharacter_Base_HandleOnNewSkinTagAsset::NewSkinTagAsset' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleOnSkinTagAssetRemoved
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_HandleOnSkinTagAssetRemoved final
{
public:
	TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove;                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleOnSkinTagAssetRemoved) == 0x000008, "Wrong alignment on HWCharacter_Base_HandleOnSkinTagAssetRemoved");
static_assert(sizeof(HWCharacter_Base_HandleOnSkinTagAssetRemoved) == 0x000010, "Wrong size on HWCharacter_Base_HandleOnSkinTagAssetRemoved");
static_assert(offsetof(HWCharacter_Base_HandleOnSkinTagAssetRemoved, SkinTagAssetToRemove) == 0x000000, "Member 'HWCharacter_Base_HandleOnSkinTagAssetRemoved::SkinTagAssetToRemove' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_AbilityBuffering
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_AbilityBuffering final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_AbilityBuffering) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_AbilityBuffering");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_AbilityBuffering) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_AbilityBuffering");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_AbilityBuffering, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_AbilityBuffering::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_AbilityBuffering, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_AbilityBuffering::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_FreezeSkeleton
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_FreezeSkeleton final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_FreezeSkeleton) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_FreezeSkeleton");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_FreezeSkeleton) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_FreezeSkeleton");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_FreezeSkeleton, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_FreezeSkeleton::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_FreezeSkeleton, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_FreezeSkeleton::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_IgnoreControlRotation
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_IgnoreControlRotation final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_IgnoreControlRotation) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_IgnoreControlRotation");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_IgnoreControlRotation) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_IgnoreControlRotation");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_IgnoreControlRotation, Tag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_IgnoreControlRotation::Tag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_IgnoreControlRotation, Count) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_IgnoreControlRotation::Count' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_IgnoreLookInput
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_IgnoreLookInput final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_IgnoreLookInput) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_IgnoreLookInput");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_IgnoreLookInput) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_IgnoreLookInput");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_IgnoreLookInput, Tag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_IgnoreLookInput::Tag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_IgnoreLookInput, Count) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_IgnoreLookInput::Count' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_IgnoreMoveInput
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_IgnoreMoveInput final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_IgnoreMoveInput) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_IgnoreMoveInput");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_IgnoreMoveInput) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_IgnoreMoveInput");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_IgnoreMoveInput, Tag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_IgnoreMoveInput::Tag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_IgnoreMoveInput, Count) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_IgnoreMoveInput::Count' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_Intoxicate
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_Intoxicate final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_Intoxicate) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_Intoxicate");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_Intoxicate) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_Intoxicate");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_Intoxicate, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_Intoxicate::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_Intoxicate, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_Intoxicate::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_IsInFountain
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_IsInFountain final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_IsInFountain) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_IsInFountain");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_IsInFountain) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_IsInFountain");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_IsInFountain, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_IsInFountain::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_IsInFountain, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_IsInFountain::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_Knockback
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_Knockback final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_Knockback) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_Knockback");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_Knockback) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_Knockback");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_Knockback, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_Knockback::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_Knockback, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_Knockback::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_Mesmerize
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_Mesmerize final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_Mesmerize) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_Mesmerize");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_Mesmerize) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_Mesmerize");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_Mesmerize, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_Mesmerize::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_Mesmerize, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_Mesmerize::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_NoSpectatingAllowed
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_NoSpectatingAllowed final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_NoSpectatingAllowed) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_NoSpectatingAllowed");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_NoSpectatingAllowed) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_NoSpectatingAllowed");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_NoSpectatingAllowed, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_NoSpectatingAllowed::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_NoSpectatingAllowed, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_NoSpectatingAllowed::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_Rooted
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_Rooted final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_Rooted) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_Rooted");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_Rooted) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_Rooted");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_Rooted, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_Rooted::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_Rooted, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_Rooted::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_Stun
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_Stun final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_Stun) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_Stun");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_Stun) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_Stun");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_Stun, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_Stun::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_Stun, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_Stun::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_TargetLock
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_TargetLock final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_TargetLock) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_TargetLock");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_TargetLock) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_TargetLock");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_TargetLock, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_TargetLock::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_TargetLock, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_TargetLock::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HandleTagUpdated_TypeGod
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_HandleTagUpdated_TypeGod final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HandleTagUpdated_TypeGod) == 0x000004, "Wrong alignment on HWCharacter_Base_HandleTagUpdated_TypeGod");
static_assert(sizeof(HWCharacter_Base_HandleTagUpdated_TypeGod) == 0x00000C, "Wrong size on HWCharacter_Base_HandleTagUpdated_TypeGod");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_TypeGod, CallbackTag) == 0x000000, "Member 'HWCharacter_Base_HandleTagUpdated_TypeGod::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HandleTagUpdated_TypeGod, NewCount) == 0x000008, "Member 'HWCharacter_Base_HandleTagUpdated_TypeGod::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.MeshFadeTimelineUpdate
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Base_MeshFadeTimelineUpdate final
{
public:
	float                                         FadeScalar;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_MeshFadeTimelineUpdate) == 0x000004, "Wrong alignment on HWCharacter_Base_MeshFadeTimelineUpdate");
static_assert(sizeof(HWCharacter_Base_MeshFadeTimelineUpdate) == 0x000004, "Wrong size on HWCharacter_Base_MeshFadeTimelineUpdate");
static_assert(offsetof(HWCharacter_Base_MeshFadeTimelineUpdate, FadeScalar) == 0x000000, "Member 'HWCharacter_Base_MeshFadeTimelineUpdate::FadeScalar' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.Multicast_SetEnableCollision
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_Multicast_SetEnableCollision final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_Multicast_SetEnableCollision) == 0x000001, "Wrong alignment on HWCharacter_Base_Multicast_SetEnableCollision");
static_assert(sizeof(HWCharacter_Base_Multicast_SetEnableCollision) == 0x000001, "Wrong size on HWCharacter_Base_Multicast_SetEnableCollision");
static_assert(offsetof(HWCharacter_Base_Multicast_SetEnableCollision, bEnable) == 0x000000, "Member 'HWCharacter_Base_Multicast_SetEnableCollision::bEnable' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.OnBroadcastHitReaction
// 0x0020 (0x0020 - 0x0000)
struct HWCharacter_Base_OnBroadcastHitReaction final
{
public:
	struct FVector                                DamageDirection;                                   // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMagnitude;                                   // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_Base_OnBroadcastHitReaction) == 0x000008, "Wrong alignment on HWCharacter_Base_OnBroadcastHitReaction");
static_assert(sizeof(HWCharacter_Base_OnBroadcastHitReaction) == 0x000020, "Wrong size on HWCharacter_Base_OnBroadcastHitReaction");
static_assert(offsetof(HWCharacter_Base_OnBroadcastHitReaction, DamageDirection) == 0x000000, "Member 'HWCharacter_Base_OnBroadcastHitReaction::DamageDirection' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_OnBroadcastHitReaction, DamageMagnitude) == 0x000018, "Member 'HWCharacter_Base_OnBroadcastHitReaction::DamageMagnitude' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.OnHighlightedStatusChanged
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_OnHighlightedStatusChanged final
{
public:
	bool                                          bIsHighlighted;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_OnHighlightedStatusChanged) == 0x000001, "Wrong alignment on HWCharacter_Base_OnHighlightedStatusChanged");
static_assert(sizeof(HWCharacter_Base_OnHighlightedStatusChanged) == 0x000001, "Wrong size on HWCharacter_Base_OnHighlightedStatusChanged");
static_assert(offsetof(HWCharacter_Base_OnHighlightedStatusChanged, bIsHighlighted) == 0x000000, "Member 'HWCharacter_Base_OnHighlightedStatusChanged::bIsHighlighted' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.OnRep_AbilitySystemActor
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_OnRep_AbilitySystemActor final
{
public:
	class AHWCharacterAbilitySystemActor*         PreviousAbilitySystemActor;                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_OnRep_AbilitySystemActor) == 0x000008, "Wrong alignment on HWCharacter_Base_OnRep_AbilitySystemActor");
static_assert(sizeof(HWCharacter_Base_OnRep_AbilitySystemActor) == 0x000008, "Wrong size on HWCharacter_Base_OnRep_AbilitySystemActor");
static_assert(offsetof(HWCharacter_Base_OnRep_AbilitySystemActor, PreviousAbilitySystemActor) == 0x000000, "Member 'HWCharacter_Base_OnRep_AbilitySystemActor::PreviousAbilitySystemActor' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.OnTeamUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_OnTeamUpdated final
{
public:
	class AHWCharacterAbilitySystemActor*         OwningAbilitySystemActor;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamState*                           InTeamState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_OnTeamUpdated) == 0x000008, "Wrong alignment on HWCharacter_Base_OnTeamUpdated");
static_assert(sizeof(HWCharacter_Base_OnTeamUpdated) == 0x000010, "Wrong size on HWCharacter_Base_OnTeamUpdated");
static_assert(offsetof(HWCharacter_Base_OnTeamUpdated, OwningAbilitySystemActor) == 0x000000, "Member 'HWCharacter_Base_OnTeamUpdated::OwningAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_OnTeamUpdated, InTeamState) == 0x000008, "Member 'HWCharacter_Base_OnTeamUpdated::InTeamState' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.OverrideDeathMontage
// 0x0038 (0x0038 - 0x0000)
struct HWCharacter_Base_OverrideDeathMontage final
{
public:
	struct FAssetRequestKey                       MontageKey;                                        // 0x0000(0x001C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       ReturnValue;                                       // 0x001C(0x001C)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_OverrideDeathMontage) == 0x000004, "Wrong alignment on HWCharacter_Base_OverrideDeathMontage");
static_assert(sizeof(HWCharacter_Base_OverrideDeathMontage) == 0x000038, "Wrong size on HWCharacter_Base_OverrideDeathMontage");
static_assert(offsetof(HWCharacter_Base_OverrideDeathMontage, MontageKey) == 0x000000, "Member 'HWCharacter_Base_OverrideDeathMontage::MontageKey' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_OverrideDeathMontage, ReturnValue) == 0x00001C, "Member 'HWCharacter_Base_OverrideDeathMontage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.PopCollisionState
// 0x0040 (0x0040 - 0x0000)
struct HWCharacter_Base_PopCollisionState final
{
public:
	struct FHWCollisionState                      CollisionStateData;                                // 0x0000(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_Base_PopCollisionState) == 0x000004, "Wrong alignment on HWCharacter_Base_PopCollisionState");
static_assert(sizeof(HWCharacter_Base_PopCollisionState) == 0x000040, "Wrong size on HWCharacter_Base_PopCollisionState");
static_assert(offsetof(HWCharacter_Base_PopCollisionState, CollisionStateData) == 0x000000, "Member 'HWCharacter_Base_PopCollisionState::CollisionStateData' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_PopCollisionState, ReturnValue) == 0x00003C, "Member 'HWCharacter_Base_PopCollisionState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.PushCollisionState
// 0x003C (0x003C - 0x0000)
struct HWCharacter_Base_PushCollisionState final
{
public:
	struct FHWCollisionState                      CollisionStateData;                                // 0x0000(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_PushCollisionState) == 0x000004, "Wrong alignment on HWCharacter_Base_PushCollisionState");
static_assert(sizeof(HWCharacter_Base_PushCollisionState) == 0x00003C, "Wrong size on HWCharacter_Base_PushCollisionState");
static_assert(offsetof(HWCharacter_Base_PushCollisionState, CollisionStateData) == 0x000000, "Member 'HWCharacter_Base_PushCollisionState::CollisionStateData' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.RemoveBlendable
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_RemoveBlendable final
{
public:
	TScriptInterface<class IBlendableInterface>   InBlendableObject;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_RemoveBlendable) == 0x000008, "Wrong alignment on HWCharacter_Base_RemoveBlendable");
static_assert(sizeof(HWCharacter_Base_RemoveBlendable) == 0x000010, "Wrong size on HWCharacter_Base_RemoveBlendable");
static_assert(offsetof(HWCharacter_Base_RemoveBlendable, InBlendableObject) == 0x000000, "Member 'HWCharacter_Base_RemoveBlendable::InBlendableObject' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.RemoveMinimapModifier
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_RemoveMinimapModifier final
{
public:
	EHWMinimapModifier                            Modifier;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_RemoveMinimapModifier) == 0x000001, "Wrong alignment on HWCharacter_Base_RemoveMinimapModifier");
static_assert(sizeof(HWCharacter_Base_RemoveMinimapModifier) == 0x000001, "Wrong size on HWCharacter_Base_RemoveMinimapModifier");
static_assert(offsetof(HWCharacter_Base_RemoveMinimapModifier, Modifier) == 0x000000, "Member 'HWCharacter_Base_RemoveMinimapModifier::Modifier' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.RemoveSpecialFXCurve
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_RemoveSpecialFXCurve final
{
public:
	class FName                                   InFXID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_RemoveSpecialFXCurve) == 0x000004, "Wrong alignment on HWCharacter_Base_RemoveSpecialFXCurve");
static_assert(sizeof(HWCharacter_Base_RemoveSpecialFXCurve) == 0x000008, "Wrong size on HWCharacter_Base_RemoveSpecialFXCurve");
static_assert(offsetof(HWCharacter_Base_RemoveSpecialFXCurve, InFXID) == 0x000000, "Member 'HWCharacter_Base_RemoveSpecialFXCurve::InFXID' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.ResetMeshFadeValueAfterMeshSwap
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_ResetMeshFadeValueAfterMeshSwap final
{
public:
	bool                                          bMeshSwapped;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_ResetMeshFadeValueAfterMeshSwap) == 0x000001, "Wrong alignment on HWCharacter_Base_ResetMeshFadeValueAfterMeshSwap");
static_assert(sizeof(HWCharacter_Base_ResetMeshFadeValueAfterMeshSwap) == 0x000001, "Wrong size on HWCharacter_Base_ResetMeshFadeValueAfterMeshSwap");
static_assert(offsetof(HWCharacter_Base_ResetMeshFadeValueAfterMeshSwap, bMeshSwapped) == 0x000000, "Member 'HWCharacter_Base_ResetMeshFadeValueAfterMeshSwap::bMeshSwapped' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.ResetSpecialFXTime
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_ResetSpecialFXTime final
{
public:
	class FName                                   InFXID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_ResetSpecialFXTime) == 0x000004, "Wrong alignment on HWCharacter_Base_ResetSpecialFXTime");
static_assert(sizeof(HWCharacter_Base_ResetSpecialFXTime) == 0x000008, "Wrong size on HWCharacter_Base_ResetSpecialFXTime");
static_assert(offsetof(HWCharacter_Base_ResetSpecialFXTime, InFXID) == 0x000000, "Member 'HWCharacter_Base_ResetSpecialFXTime::InFXID' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.ReverseSpecialFX
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_ReverseSpecialFX final
{
public:
	class FName                                   InFXID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_ReverseSpecialFX) == 0x000004, "Wrong alignment on HWCharacter_Base_ReverseSpecialFX");
static_assert(sizeof(HWCharacter_Base_ReverseSpecialFX) == 0x000008, "Wrong size on HWCharacter_Base_ReverseSpecialFX");
static_assert(offsetof(HWCharacter_Base_ReverseSpecialFX, InFXID) == 0x000000, "Member 'HWCharacter_Base_ReverseSpecialFX::InFXID' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.SetCameraLock
// 0x0030 (0x0030 - 0x0000)
struct HWCharacter_Base_SetCameraLock final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LockOrigin;                                        // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         YawAngleThreshold;                                 // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAngleThreshold;                               // 0x0024(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurrentCharacterRotationAsOriginRotation;      // 0x0028(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_Base_SetCameraLock) == 0x000008, "Wrong alignment on HWCharacter_Base_SetCameraLock");
static_assert(sizeof(HWCharacter_Base_SetCameraLock) == 0x000030, "Wrong size on HWCharacter_Base_SetCameraLock");
static_assert(offsetof(HWCharacter_Base_SetCameraLock, bEnable) == 0x000000, "Member 'HWCharacter_Base_SetCameraLock::bEnable' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_SetCameraLock, LockOrigin) == 0x000008, "Member 'HWCharacter_Base_SetCameraLock::LockOrigin' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_SetCameraLock, YawAngleThreshold) == 0x000020, "Member 'HWCharacter_Base_SetCameraLock::YawAngleThreshold' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_SetCameraLock, PitchAngleThreshold) == 0x000024, "Member 'HWCharacter_Base_SetCameraLock::PitchAngleThreshold' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_SetCameraLock, bUseCurrentCharacterRotationAsOriginRotation) == 0x000028, "Member 'HWCharacter_Base_SetCameraLock::bUseCurrentCharacterRotationAsOriginRotation' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.SetCameraPitchLimits
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_SetCameraPitchLimits final
{
public:
	double                                        PitchMin;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        PitchMax;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_SetCameraPitchLimits) == 0x000008, "Wrong alignment on HWCharacter_Base_SetCameraPitchLimits");
static_assert(sizeof(HWCharacter_Base_SetCameraPitchLimits) == 0x000010, "Wrong size on HWCharacter_Base_SetCameraPitchLimits");
static_assert(offsetof(HWCharacter_Base_SetCameraPitchLimits, PitchMin) == 0x000000, "Member 'HWCharacter_Base_SetCameraPitchLimits::PitchMin' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_SetCameraPitchLimits, PitchMax) == 0x000008, "Member 'HWCharacter_Base_SetCameraPitchLimits::PitchMax' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.SetCameraPitchLimitsWithLerp
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_Base_SetCameraPitchLimitsWithLerp final
{
public:
	double                                        PitchMin;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        PitchMax;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpTime;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_Base_SetCameraPitchLimitsWithLerp) == 0x000008, "Wrong alignment on HWCharacter_Base_SetCameraPitchLimitsWithLerp");
static_assert(sizeof(HWCharacter_Base_SetCameraPitchLimitsWithLerp) == 0x000018, "Wrong size on HWCharacter_Base_SetCameraPitchLimitsWithLerp");
static_assert(offsetof(HWCharacter_Base_SetCameraPitchLimitsWithLerp, PitchMin) == 0x000000, "Member 'HWCharacter_Base_SetCameraPitchLimitsWithLerp::PitchMin' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_SetCameraPitchLimitsWithLerp, PitchMax) == 0x000008, "Member 'HWCharacter_Base_SetCameraPitchLimitsWithLerp::PitchMax' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_SetCameraPitchLimitsWithLerp, LerpTime) == 0x000010, "Member 'HWCharacter_Base_SetCameraPitchLimitsWithLerp::LerpTime' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.SetFactoryOwner
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_SetFactoryOwner final
{
public:
	class AHWBotFactory*                          factory;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_SetFactoryOwner) == 0x000008, "Wrong alignment on HWCharacter_Base_SetFactoryOwner");
static_assert(sizeof(HWCharacter_Base_SetFactoryOwner) == 0x000008, "Wrong size on HWCharacter_Base_SetFactoryOwner");
static_assert(offsetof(HWCharacter_Base_SetFactoryOwner, factory) == 0x000000, "Member 'HWCharacter_Base_SetFactoryOwner::factory' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.SetLocalTeamColor
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_SetLocalTeamColor final
{
public:
	class AHWCharacterAbilitySystemActor*         OwningAbilitySystemActor;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamState*                           InTeamState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_SetLocalTeamColor) == 0x000008, "Wrong alignment on HWCharacter_Base_SetLocalTeamColor");
static_assert(sizeof(HWCharacter_Base_SetLocalTeamColor) == 0x000010, "Wrong size on HWCharacter_Base_SetLocalTeamColor");
static_assert(offsetof(HWCharacter_Base_SetLocalTeamColor, OwningAbilitySystemActor) == 0x000000, "Member 'HWCharacter_Base_SetLocalTeamColor::OwningAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_SetLocalTeamColor, InTeamState) == 0x000008, "Member 'HWCharacter_Base_SetLocalTeamColor::InTeamState' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.SetToBaseCollisionState
// 0x0002 (0x0002 - 0x0000)
struct HWCharacter_Base_SetToBaseCollisionState final
{
public:
	bool                                          bReturnToWalking;                                  // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckDeath;                                       // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_SetToBaseCollisionState) == 0x000001, "Wrong alignment on HWCharacter_Base_SetToBaseCollisionState");
static_assert(sizeof(HWCharacter_Base_SetToBaseCollisionState) == 0x000002, "Wrong size on HWCharacter_Base_SetToBaseCollisionState");
static_assert(offsetof(HWCharacter_Base_SetToBaseCollisionState, bReturnToWalking) == 0x000000, "Member 'HWCharacter_Base_SetToBaseCollisionState::bReturnToWalking' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_SetToBaseCollisionState, bCheckDeath) == 0x000001, "Member 'HWCharacter_Base_SetToBaseCollisionState::bCheckDeath' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.ShouldPreventCustomMovementFromInstigator
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_ShouldPreventCustomMovementFromInstigator final
{
public:
	const class AHWCharacter_Base*                MovementInstigator;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyEffectsAndCosts;                             // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_Base_ShouldPreventCustomMovementFromInstigator) == 0x000008, "Wrong alignment on HWCharacter_Base_ShouldPreventCustomMovementFromInstigator");
static_assert(sizeof(HWCharacter_Base_ShouldPreventCustomMovementFromInstigator) == 0x000010, "Wrong size on HWCharacter_Base_ShouldPreventCustomMovementFromInstigator");
static_assert(offsetof(HWCharacter_Base_ShouldPreventCustomMovementFromInstigator, MovementInstigator) == 0x000000, "Member 'HWCharacter_Base_ShouldPreventCustomMovementFromInstigator::MovementInstigator' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_ShouldPreventCustomMovementFromInstigator, bApplyEffectsAndCosts) == 0x000008, "Member 'HWCharacter_Base_ShouldPreventCustomMovementFromInstigator::bApplyEffectsAndCosts' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_ShouldPreventCustomMovementFromInstigator, ReturnValue) == 0x000009, "Member 'HWCharacter_Base_ShouldPreventCustomMovementFromInstigator::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.StartHWSpecialEffect
// 0x0080 (0x0080 - 0x0000)
struct HWCharacter_Base_StartHWSpecialEffect final
{
public:
	struct FHWSpecialEffect                       Effect;                                            // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestart;                                          // 0x0074(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWFXCurveComponent*                    ReturnValue;                                       // 0x0078(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_StartHWSpecialEffect) == 0x000008, "Wrong alignment on HWCharacter_Base_StartHWSpecialEffect");
static_assert(sizeof(HWCharacter_Base_StartHWSpecialEffect) == 0x000080, "Wrong size on HWCharacter_Base_StartHWSpecialEffect");
static_assert(offsetof(HWCharacter_Base_StartHWSpecialEffect, Effect) == 0x000000, "Member 'HWCharacter_Base_StartHWSpecialEffect::Effect' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_StartHWSpecialEffect, PlayRate) == 0x000070, "Member 'HWCharacter_Base_StartHWSpecialEffect::PlayRate' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_StartHWSpecialEffect, bRestart) == 0x000074, "Member 'HWCharacter_Base_StartHWSpecialEffect::bRestart' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_StartHWSpecialEffect, ReturnValue) == 0x000078, "Member 'HWCharacter_Base_StartHWSpecialEffect::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.StopSpecialFX
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_StopSpecialFX final
{
public:
	class FName                                   InFXID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_StopSpecialFX) == 0x000004, "Wrong alignment on HWCharacter_Base_StopSpecialFX");
static_assert(sizeof(HWCharacter_Base_StopSpecialFX) == 0x000008, "Wrong size on HWCharacter_Base_StopSpecialFX");
static_assert(offsetof(HWCharacter_Base_StopSpecialFX, InFXID) == 0x000000, "Member 'HWCharacter_Base_StopSpecialFX::InFXID' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.SwapSkinTags
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_SwapSkinTags final
{
public:
	struct FGameplayTag                           NewSkinTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OldSkinTag;                                        // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_SwapSkinTags) == 0x000004, "Wrong alignment on HWCharacter_Base_SwapSkinTags");
static_assert(sizeof(HWCharacter_Base_SwapSkinTags) == 0x000010, "Wrong size on HWCharacter_Base_SwapSkinTags");
static_assert(offsetof(HWCharacter_Base_SwapSkinTags, NewSkinTag) == 0x000000, "Member 'HWCharacter_Base_SwapSkinTags::NewSkinTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_SwapSkinTags, OldSkinTag) == 0x000008, "Member 'HWCharacter_Base_SwapSkinTags::OldSkinTag' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.TeleportToLocation
// 0x0108 (0x0108 - 0x0000)
struct HWCharacter_Base_TeleportToLocation final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             SweepHitResult;                                    // 0x0018(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bPreserveZHeight;                                  // 0x0100(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0101(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_Base_TeleportToLocation) == 0x000008, "Wrong alignment on HWCharacter_Base_TeleportToLocation");
static_assert(sizeof(HWCharacter_Base_TeleportToLocation) == 0x000108, "Wrong size on HWCharacter_Base_TeleportToLocation");
static_assert(offsetof(HWCharacter_Base_TeleportToLocation, TargetLocation) == 0x000000, "Member 'HWCharacter_Base_TeleportToLocation::TargetLocation' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_TeleportToLocation, SweepHitResult) == 0x000018, "Member 'HWCharacter_Base_TeleportToLocation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_TeleportToLocation, bPreserveZHeight) == 0x000100, "Member 'HWCharacter_Base_TeleportToLocation::bPreserveZHeight' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_TeleportToLocation, bSweep) == 0x000101, "Member 'HWCharacter_Base_TeleportToLocation::bSweep' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.TeleportToStartSpot
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_TeleportToStartSpot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_TeleportToStartSpot) == 0x000001, "Wrong alignment on HWCharacter_Base_TeleportToStartSpot");
static_assert(sizeof(HWCharacter_Base_TeleportToStartSpot) == 0x000001, "Wrong size on HWCharacter_Base_TeleportToStartSpot");
static_assert(offsetof(HWCharacter_Base_TeleportToStartSpot, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_TeleportToStartSpot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.TeleportToTransform
// 0x0150 (0x0150 - 0x0000)
struct HWCharacter_Base_TeleportToTransform final
{
public:
	struct FTransform                             TargetTransform;                                   // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             SweepHitResult;                                    // 0x0060(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bPreserveZHeight;                                  // 0x0148(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0149(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_Base_TeleportToTransform) == 0x000010, "Wrong alignment on HWCharacter_Base_TeleportToTransform");
static_assert(sizeof(HWCharacter_Base_TeleportToTransform) == 0x000150, "Wrong size on HWCharacter_Base_TeleportToTransform");
static_assert(offsetof(HWCharacter_Base_TeleportToTransform, TargetTransform) == 0x000000, "Member 'HWCharacter_Base_TeleportToTransform::TargetTransform' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_TeleportToTransform, SweepHitResult) == 0x000060, "Member 'HWCharacter_Base_TeleportToTransform::SweepHitResult' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_TeleportToTransform, bPreserveZHeight) == 0x000148, "Member 'HWCharacter_Base_TeleportToTransform::bPreserveZHeight' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_TeleportToTransform, bSweep) == 0x000149, "Member 'HWCharacter_Base_TeleportToTransform::bSweep' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.TestCheat
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_TestCheat final
{
public:
	bool                                          bSetActive;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         testInt;                                           // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_TestCheat) == 0x000004, "Wrong alignment on HWCharacter_Base_TestCheat");
static_assert(sizeof(HWCharacter_Base_TestCheat) == 0x000008, "Wrong size on HWCharacter_Base_TestCheat");
static_assert(offsetof(HWCharacter_Base_TestCheat, bSetActive) == 0x000000, "Member 'HWCharacter_Base_TestCheat::bSetActive' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_TestCheat, testInt) == 0x000004, "Member 'HWCharacter_Base_TestCheat::testInt' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.CanBeHardDisplaced
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_CanBeHardDisplaced final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_CanBeHardDisplaced) == 0x000001, "Wrong alignment on HWCharacter_Base_CanBeHardDisplaced");
static_assert(sizeof(HWCharacter_Base_CanBeHardDisplaced) == 0x000001, "Wrong size on HWCharacter_Base_CanBeHardDisplaced");
static_assert(offsetof(HWCharacter_Base_CanBeHardDisplaced, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_CanBeHardDisplaced::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.CanBePulled
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_CanBePulled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_CanBePulled) == 0x000001, "Wrong alignment on HWCharacter_Base_CanBePulled");
static_assert(sizeof(HWCharacter_Base_CanBePulled) == 0x000001, "Wrong size on HWCharacter_Base_CanBePulled");
static_assert(offsetof(HWCharacter_Base_CanBePulled, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_CanBePulled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.DidRespawnThisTick
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_DidRespawnThisTick final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_DidRespawnThisTick) == 0x000001, "Wrong alignment on HWCharacter_Base_DidRespawnThisTick");
static_assert(sizeof(HWCharacter_Base_DidRespawnThisTick) == 0x000001, "Wrong size on HWCharacter_Base_DidRespawnThisTick");
static_assert(offsetof(HWCharacter_Base_DidRespawnThisTick, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_DidRespawnThisTick::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GenerateBaseCollisionState
// 0x003C (0x003C - 0x0000)
struct HWCharacter_Base_GenerateBaseCollisionState final
{
public:
	struct FHWCollisionState                      ReturnValue;                                       // 0x0000(0x003C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GenerateBaseCollisionState) == 0x000004, "Wrong alignment on HWCharacter_Base_GenerateBaseCollisionState");
static_assert(sizeof(HWCharacter_Base_GenerateBaseCollisionState) == 0x00003C, "Wrong size on HWCharacter_Base_GenerateBaseCollisionState");
static_assert(offsetof(HWCharacter_Base_GenerateBaseCollisionState, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GenerateBaseCollisionState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetAbilitySystemComponent final
{
public:
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetAbilitySystemComponent) == 0x000008, "Wrong alignment on HWCharacter_Base_GetAbilitySystemComponent");
static_assert(sizeof(HWCharacter_Base_GetAbilitySystemComponent) == 0x000008, "Wrong size on HWCharacter_Base_GetAbilitySystemComponent");
static_assert(offsetof(HWCharacter_Base_GetAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetApparelComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetApparelComponent final
{
public:
	class UHWApparelComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetApparelComponent) == 0x000008, "Wrong alignment on HWCharacter_Base_GetApparelComponent");
static_assert(sizeof(HWCharacter_Base_GetApparelComponent) == 0x000008, "Wrong size on HWCharacter_Base_GetApparelComponent");
static_assert(offsetof(HWCharacter_Base_GetApparelComponent, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetApparelComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetApparelSkinObjectByName
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_GetApparelSkinObjectByName final
{
public:
	class FName                                   InSkinObjectName;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMultiSkinObject*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetApparelSkinObjectByName) == 0x000008, "Wrong alignment on HWCharacter_Base_GetApparelSkinObjectByName");
static_assert(sizeof(HWCharacter_Base_GetApparelSkinObjectByName) == 0x000010, "Wrong size on HWCharacter_Base_GetApparelSkinObjectByName");
static_assert(offsetof(HWCharacter_Base_GetApparelSkinObjectByName, InSkinObjectName) == 0x000000, "Member 'HWCharacter_Base_GetApparelSkinObjectByName::InSkinObjectName' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetApparelSkinObjectByName, ReturnValue) == 0x000008, "Member 'HWCharacter_Base_GetApparelSkinObjectByName::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetCapsuleHalfHeight
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetCapsuleHalfHeight final
{
public:
	bool                                          bScaled;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetCapsuleHalfHeight) == 0x000004, "Wrong alignment on HWCharacter_Base_GetCapsuleHalfHeight");
static_assert(sizeof(HWCharacter_Base_GetCapsuleHalfHeight) == 0x000008, "Wrong size on HWCharacter_Base_GetCapsuleHalfHeight");
static_assert(offsetof(HWCharacter_Base_GetCapsuleHalfHeight, bScaled) == 0x000000, "Member 'HWCharacter_Base_GetCapsuleHalfHeight::bScaled' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetCapsuleHalfHeight, ReturnValue) == 0x000004, "Member 'HWCharacter_Base_GetCapsuleHalfHeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetCapsuleRadius
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetCapsuleRadius final
{
public:
	bool                                          bScaled;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetCapsuleRadius) == 0x000004, "Wrong alignment on HWCharacter_Base_GetCapsuleRadius");
static_assert(sizeof(HWCharacter_Base_GetCapsuleRadius) == 0x000008, "Wrong size on HWCharacter_Base_GetCapsuleRadius");
static_assert(offsetof(HWCharacter_Base_GetCapsuleRadius, bScaled) == 0x000000, "Member 'HWCharacter_Base_GetCapsuleRadius::bScaled' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetCapsuleRadius, ReturnValue) == 0x000004, "Member 'HWCharacter_Base_GetCapsuleRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetCharacterAbilitySystemActor
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetCharacterAbilitySystemActor final
{
public:
	class AHWCharacterAbilitySystemActor*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetCharacterAbilitySystemActor) == 0x000008, "Wrong alignment on HWCharacter_Base_GetCharacterAbilitySystemActor");
static_assert(sizeof(HWCharacter_Base_GetCharacterAbilitySystemActor) == 0x000008, "Wrong size on HWCharacter_Base_GetCharacterAbilitySystemActor");
static_assert(offsetof(HWCharacter_Base_GetCharacterAbilitySystemActor, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetCharacterAbilitySystemActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetCharacterLevel
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Base_GetCharacterLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetCharacterLevel) == 0x000004, "Wrong alignment on HWCharacter_Base_GetCharacterLevel");
static_assert(sizeof(HWCharacter_Base_GetCharacterLevel) == 0x000004, "Wrong size on HWCharacter_Base_GetCharacterLevel");
static_assert(offsetof(HWCharacter_Base_GetCharacterLevel, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetCharacterLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetCharacterMeshApparelSkinObject
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetCharacterMeshApparelSkinObject final
{
public:
	class UMultiSkinObject*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetCharacterMeshApparelSkinObject) == 0x000008, "Wrong alignment on HWCharacter_Base_GetCharacterMeshApparelSkinObject");
static_assert(sizeof(HWCharacter_Base_GetCharacterMeshApparelSkinObject) == 0x000008, "Wrong size on HWCharacter_Base_GetCharacterMeshApparelSkinObject");
static_assert(offsetof(HWCharacter_Base_GetCharacterMeshApparelSkinObject, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetCharacterMeshApparelSkinObject::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetCurrentSkin
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetCurrentSkin final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetCurrentSkin) == 0x000008, "Wrong alignment on HWCharacter_Base_GetCurrentSkin");
static_assert(sizeof(HWCharacter_Base_GetCurrentSkin) == 0x000008, "Wrong size on HWCharacter_Base_GetCurrentSkin");
static_assert(offsetof(HWCharacter_Base_GetCurrentSkin, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetCurrentSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetCurrentTargetActor
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetCurrentTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetCurrentTargetActor) == 0x000008, "Wrong alignment on HWCharacter_Base_GetCurrentTargetActor");
static_assert(sizeof(HWCharacter_Base_GetCurrentTargetActor) == 0x000008, "Wrong size on HWCharacter_Base_GetCurrentTargetActor");
static_assert(offsetof(HWCharacter_Base_GetCurrentTargetActor, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetCurrentTargetActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetDamageCountFromSource
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_GetDamageCountFromSource final
{
public:
	const class AHWCharacter_Base*                Source;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeRange;                                      // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetDamageCountFromSource) == 0x000008, "Wrong alignment on HWCharacter_Base_GetDamageCountFromSource");
static_assert(sizeof(HWCharacter_Base_GetDamageCountFromSource) == 0x000010, "Wrong size on HWCharacter_Base_GetDamageCountFromSource");
static_assert(offsetof(HWCharacter_Base_GetDamageCountFromSource, Source) == 0x000000, "Member 'HWCharacter_Base_GetDamageCountFromSource::Source' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetDamageCountFromSource, MaxTimeRange) == 0x000008, "Member 'HWCharacter_Base_GetDamageCountFromSource::MaxTimeRange' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetDamageCountFromSource, ReturnValue) == 0x00000C, "Member 'HWCharacter_Base_GetDamageCountFromSource::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetDamageSourceCountInTimeframe
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_GetDamageSourceCountInTimeframe final
{
public:
	float                                         Timeframe;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGodsOnly;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetDamageSourceCountInTimeframe) == 0x000004, "Wrong alignment on HWCharacter_Base_GetDamageSourceCountInTimeframe");
static_assert(sizeof(HWCharacter_Base_GetDamageSourceCountInTimeframe) == 0x00000C, "Wrong size on HWCharacter_Base_GetDamageSourceCountInTimeframe");
static_assert(offsetof(HWCharacter_Base_GetDamageSourceCountInTimeframe, Timeframe) == 0x000000, "Member 'HWCharacter_Base_GetDamageSourceCountInTimeframe::Timeframe' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetDamageSourceCountInTimeframe, bGodsOnly) == 0x000004, "Member 'HWCharacter_Base_GetDamageSourceCountInTimeframe::bGodsOnly' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetDamageSourceCountInTimeframe, ReturnValue) == 0x000008, "Member 'HWCharacter_Base_GetDamageSourceCountInTimeframe::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetDisplayInfoComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetDisplayInfoComponent final
{
public:
	class UHWDisplayInfoComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetDisplayInfoComponent) == 0x000008, "Wrong alignment on HWCharacter_Base_GetDisplayInfoComponent");
static_assert(sizeof(HWCharacter_Base_GetDisplayInfoComponent) == 0x000008, "Wrong size on HWCharacter_Base_GetDisplayInfoComponent");
static_assert(offsetof(HWCharacter_Base_GetDisplayInfoComponent, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetDisplayInfoComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetFactoryOwner
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetFactoryOwner final
{
public:
	class AHWBotFactory*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetFactoryOwner) == 0x000008, "Wrong alignment on HWCharacter_Base_GetFactoryOwner");
static_assert(sizeof(HWCharacter_Base_GetFactoryOwner) == 0x000008, "Wrong size on HWCharacter_Base_GetFactoryOwner");
static_assert(offsetof(HWCharacter_Base_GetFactoryOwner, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetFactoryOwner::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetFamiliarHandle
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Base_GetFamiliarHandle final
{
public:
	struct FHWActiveFamiliarHandle                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetFamiliarHandle) == 0x000004, "Wrong alignment on HWCharacter_Base_GetFamiliarHandle");
static_assert(sizeof(HWCharacter_Base_GetFamiliarHandle) == 0x00000C, "Wrong size on HWCharacter_Base_GetFamiliarHandle");
static_assert(offsetof(HWCharacter_Base_GetFamiliarHandle, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetFamiliarHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetFXCurveComponentByFXID
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Base_GetFXCurveComponentByFXID final
{
public:
	class FName                                   InFXID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWFXCurveComponent*                    ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetFXCurveComponentByFXID) == 0x000008, "Wrong alignment on HWCharacter_Base_GetFXCurveComponentByFXID");
static_assert(sizeof(HWCharacter_Base_GetFXCurveComponentByFXID) == 0x000010, "Wrong size on HWCharacter_Base_GetFXCurveComponentByFXID");
static_assert(offsetof(HWCharacter_Base_GetFXCurveComponentByFXID, InFXID) == 0x000000, "Member 'HWCharacter_Base_GetFXCurveComponentByFXID::InFXID' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetFXCurveComponentByFXID, ReturnValue) == 0x000008, "Member 'HWCharacter_Base_GetFXCurveComponentByFXID::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetGold
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Base_GetGold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetGold) == 0x000004, "Wrong alignment on HWCharacter_Base_GetGold");
static_assert(sizeof(HWCharacter_Base_GetGold) == 0x000004, "Wrong size on HWCharacter_Base_GetGold");
static_assert(offsetof(HWCharacter_Base_GetGold, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetGold::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetHealth
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Base_GetHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetHealth) == 0x000004, "Wrong alignment on HWCharacter_Base_GetHealth");
static_assert(sizeof(HWCharacter_Base_GetHealth) == 0x000004, "Wrong size on HWCharacter_Base_GetHealth");
static_assert(offsetof(HWCharacter_Base_GetHealth, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetHealth::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetHealthPercentage
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Base_GetHealthPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetHealthPercentage) == 0x000004, "Wrong alignment on HWCharacter_Base_GetHealthPercentage");
static_assert(sizeof(HWCharacter_Base_GetHealthPercentage) == 0x000004, "Wrong size on HWCharacter_Base_GetHealthPercentage");
static_assert(offsetof(HWCharacter_Base_GetHealthPercentage, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetHealthPercentage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetHWAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetHWAbilitySystemComponent final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetHWAbilitySystemComponent) == 0x000008, "Wrong alignment on HWCharacter_Base_GetHWAbilitySystemComponent");
static_assert(sizeof(HWCharacter_Base_GetHWAbilitySystemComponent) == 0x000008, "Wrong size on HWCharacter_Base_GetHWAbilitySystemComponent");
static_assert(offsetof(HWCharacter_Base_GetHWAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetHWAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetHWPlayerState
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetHWPlayerState final
{
public:
	class AHWPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetHWPlayerState) == 0x000008, "Wrong alignment on HWCharacter_Base_GetHWPlayerState");
static_assert(sizeof(HWCharacter_Base_GetHWPlayerState) == 0x000008, "Wrong size on HWCharacter_Base_GetHWPlayerState");
static_assert(offsetof(HWCharacter_Base_GetHWPlayerState, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetHWPlayerState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetInhandProjectileSpeedModifierPercent
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Base_GetInhandProjectileSpeedModifierPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetInhandProjectileSpeedModifierPercent) == 0x000004, "Wrong alignment on HWCharacter_Base_GetInhandProjectileSpeedModifierPercent");
static_assert(sizeof(HWCharacter_Base_GetInhandProjectileSpeedModifierPercent) == 0x000004, "Wrong size on HWCharacter_Base_GetInhandProjectileSpeedModifierPercent");
static_assert(offsetof(HWCharacter_Base_GetInhandProjectileSpeedModifierPercent, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetInhandProjectileSpeedModifierPercent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetInventoryManager
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetInventoryManager final
{
public:
	class UHWInventoryManagerComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetInventoryManager) == 0x000008, "Wrong alignment on HWCharacter_Base_GetInventoryManager");
static_assert(sizeof(HWCharacter_Base_GetInventoryManager) == 0x000008, "Wrong size on HWCharacter_Base_GetInventoryManager");
static_assert(offsetof(HWCharacter_Base_GetInventoryManager, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetInventoryManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetLastValidGroundLocation
// 0x0020 (0x0020 - 0x0000)
struct HWCharacter_Base_GetLastValidGroundLocation final
{
public:
	struct FGameplayTag                           PlaneOfExistence;                                  // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetLastValidGroundLocation) == 0x000008, "Wrong alignment on HWCharacter_Base_GetLastValidGroundLocation");
static_assert(sizeof(HWCharacter_Base_GetLastValidGroundLocation) == 0x000020, "Wrong size on HWCharacter_Base_GetLastValidGroundLocation");
static_assert(offsetof(HWCharacter_Base_GetLastValidGroundLocation, PlaneOfExistence) == 0x000000, "Member 'HWCharacter_Base_GetLastValidGroundLocation::PlaneOfExistence' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetLastValidGroundLocation, ReturnValue) == 0x000008, "Member 'HWCharacter_Base_GetLastValidGroundLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetMana
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Base_GetMana final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetMana) == 0x000004, "Wrong alignment on HWCharacter_Base_GetMana");
static_assert(sizeof(HWCharacter_Base_GetMana) == 0x000004, "Wrong size on HWCharacter_Base_GetMana");
static_assert(offsetof(HWCharacter_Base_GetMana, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetMana::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetManaPercentage
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Base_GetManaPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetManaPercentage) == 0x000004, "Wrong alignment on HWCharacter_Base_GetManaPercentage");
static_assert(sizeof(HWCharacter_Base_GetManaPercentage) == 0x000004, "Wrong size on HWCharacter_Base_GetManaPercentage");
static_assert(offsetof(HWCharacter_Base_GetManaPercentage, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetManaPercentage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetMaxCameraPitch
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetMaxCameraPitch final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetMaxCameraPitch) == 0x000008, "Wrong alignment on HWCharacter_Base_GetMaxCameraPitch");
static_assert(sizeof(HWCharacter_Base_GetMaxCameraPitch) == 0x000008, "Wrong size on HWCharacter_Base_GetMaxCameraPitch");
static_assert(offsetof(HWCharacter_Base_GetMaxCameraPitch, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetMaxCameraPitch::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetMaxHealth
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Base_GetMaxHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetMaxHealth) == 0x000004, "Wrong alignment on HWCharacter_Base_GetMaxHealth");
static_assert(sizeof(HWCharacter_Base_GetMaxHealth) == 0x000004, "Wrong size on HWCharacter_Base_GetMaxHealth");
static_assert(offsetof(HWCharacter_Base_GetMaxHealth, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetMaxHealth::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetMaxMana
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Base_GetMaxMana final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetMaxMana) == 0x000004, "Wrong alignment on HWCharacter_Base_GetMaxMana");
static_assert(sizeof(HWCharacter_Base_GetMaxMana) == 0x000004, "Wrong size on HWCharacter_Base_GetMaxMana");
static_assert(offsetof(HWCharacter_Base_GetMaxMana, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetMaxMana::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetMinCameraPitch
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetMinCameraPitch final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetMinCameraPitch) == 0x000008, "Wrong alignment on HWCharacter_Base_GetMinCameraPitch");
static_assert(sizeof(HWCharacter_Base_GetMinCameraPitch) == 0x000008, "Wrong size on HWCharacter_Base_GetMinCameraPitch");
static_assert(offsetof(HWCharacter_Base_GetMinCameraPitch, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetMinCameraPitch::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetMinimapType
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_GetMinimapType final
{
public:
	EHWMinimapType                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetMinimapType) == 0x000001, "Wrong alignment on HWCharacter_Base_GetMinimapType");
static_assert(sizeof(HWCharacter_Base_GetMinimapType) == 0x000001, "Wrong size on HWCharacter_Base_GetMinimapType");
static_assert(offsetof(HWCharacter_Base_GetMinimapType, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetMinimapType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetMostRecentDamageSourceInTimeframe
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_Base_GetMostRecentDamageSourceInTimeframe final
{
public:
	float                                         Timeframe;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGodsOnly;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetMostRecentDamageSourceInTimeframe) == 0x000008, "Wrong alignment on HWCharacter_Base_GetMostRecentDamageSourceInTimeframe");
static_assert(sizeof(HWCharacter_Base_GetMostRecentDamageSourceInTimeframe) == 0x000018, "Wrong size on HWCharacter_Base_GetMostRecentDamageSourceInTimeframe");
static_assert(offsetof(HWCharacter_Base_GetMostRecentDamageSourceInTimeframe, Timeframe) == 0x000000, "Member 'HWCharacter_Base_GetMostRecentDamageSourceInTimeframe::Timeframe' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetMostRecentDamageSourceInTimeframe, Range) == 0x000004, "Member 'HWCharacter_Base_GetMostRecentDamageSourceInTimeframe::Range' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetMostRecentDamageSourceInTimeframe, bGodsOnly) == 0x000008, "Member 'HWCharacter_Base_GetMostRecentDamageSourceInTimeframe::bGodsOnly' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_GetMostRecentDamageSourceInTimeframe, ReturnValue) == 0x000010, "Member 'HWCharacter_Base_GetMostRecentDamageSourceInTimeframe::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.GetShieldManagerComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_GetShieldManagerComponent final
{
public:
	class UHWShieldManagerComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_GetShieldManagerComponent) == 0x000008, "Wrong alignment on HWCharacter_Base_GetShieldManagerComponent");
static_assert(sizeof(HWCharacter_Base_GetShieldManagerComponent) == 0x000008, "Wrong size on HWCharacter_Base_GetShieldManagerComponent");
static_assert(offsetof(HWCharacter_Base_GetShieldManagerComponent, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_GetShieldManagerComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HasApparelBeenAppliedAtLeastOnce
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_HasApparelBeenAppliedAtLeastOnce final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HasApparelBeenAppliedAtLeastOnce) == 0x000001, "Wrong alignment on HWCharacter_Base_HasApparelBeenAppliedAtLeastOnce");
static_assert(sizeof(HWCharacter_Base_HasApparelBeenAppliedAtLeastOnce) == 0x000001, "Wrong size on HWCharacter_Base_HasApparelBeenAppliedAtLeastOnce");
static_assert(offsetof(HWCharacter_Base_HasApparelBeenAppliedAtLeastOnce, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_HasApparelBeenAppliedAtLeastOnce::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HasBeenDamagedInTimeframe
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Base_HasBeenDamagedInTimeframe final
{
public:
	float                                         Timeframe;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGodsOnly;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_Base_HasBeenDamagedInTimeframe) == 0x000004, "Wrong alignment on HWCharacter_Base_HasBeenDamagedInTimeframe");
static_assert(sizeof(HWCharacter_Base_HasBeenDamagedInTimeframe) == 0x000008, "Wrong size on HWCharacter_Base_HasBeenDamagedInTimeframe");
static_assert(offsetof(HWCharacter_Base_HasBeenDamagedInTimeframe, Timeframe) == 0x000000, "Member 'HWCharacter_Base_HasBeenDamagedInTimeframe::Timeframe' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HasBeenDamagedInTimeframe, bGodsOnly) == 0x000004, "Member 'HWCharacter_Base_HasBeenDamagedInTimeframe::bGodsOnly' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HasBeenDamagedInTimeframe, ReturnValue) == 0x000005, "Member 'HWCharacter_Base_HasBeenDamagedInTimeframe::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HasMinimapModifier
// 0x0002 (0x0002 - 0x0000)
struct HWCharacter_Base_HasMinimapModifier final
{
public:
	EHWMinimapModifier                            Modifier;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HasMinimapModifier) == 0x000001, "Wrong alignment on HWCharacter_Base_HasMinimapModifier");
static_assert(sizeof(HWCharacter_Base_HasMinimapModifier) == 0x000002, "Wrong size on HWCharacter_Base_HasMinimapModifier");
static_assert(offsetof(HWCharacter_Base_HasMinimapModifier, Modifier) == 0x000000, "Member 'HWCharacter_Base_HasMinimapModifier::Modifier' has a wrong offset!");
static_assert(offsetof(HWCharacter_Base_HasMinimapModifier, ReturnValue) == 0x000001, "Member 'HWCharacter_Base_HasMinimapModifier::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.HasValidGroundLocation
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_HasValidGroundLocation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_HasValidGroundLocation) == 0x000001, "Wrong alignment on HWCharacter_Base_HasValidGroundLocation");
static_assert(sizeof(HWCharacter_Base_HasValidGroundLocation) == 0x000001, "Wrong size on HWCharacter_Base_HasValidGroundLocation");
static_assert(offsetof(HWCharacter_Base_HasValidGroundLocation, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_HasValidGroundLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsAGod
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsAGod final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsAGod) == 0x000001, "Wrong alignment on HWCharacter_Base_IsAGod");
static_assert(sizeof(HWCharacter_Base_IsAGod) == 0x000001, "Wrong size on HWCharacter_Base_IsAGod");
static_assert(offsetof(HWCharacter_Base_IsAGod, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsAGod::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsAJungleBoss
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsAJungleBoss final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsAJungleBoss) == 0x000001, "Wrong alignment on HWCharacter_Base_IsAJungleBoss");
static_assert(sizeof(HWCharacter_Base_IsAJungleBoss) == 0x000001, "Wrong size on HWCharacter_Base_IsAJungleBoss");
static_assert(offsetof(HWCharacter_Base_IsAJungleBoss, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsAJungleBoss::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsAJungleMonster
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsAJungleMonster final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsAJungleMonster) == 0x000001, "Wrong alignment on HWCharacter_Base_IsAJungleMonster");
static_assert(sizeof(HWCharacter_Base_IsAJungleMonster) == 0x000001, "Wrong size on HWCharacter_Base_IsAJungleMonster");
static_assert(offsetof(HWCharacter_Base_IsAJungleMonster, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsAJungleMonster::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsAMinion
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsAMinion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsAMinion) == 0x000001, "Wrong alignment on HWCharacter_Base_IsAMinion");
static_assert(sizeof(HWCharacter_Base_IsAMinion) == 0x000001, "Wrong size on HWCharacter_Base_IsAMinion");
static_assert(offsetof(HWCharacter_Base_IsAMinion, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsAMinion::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsAStructure
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsAStructure final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsAStructure) == 0x000001, "Wrong alignment on HWCharacter_Base_IsAStructure");
static_assert(sizeof(HWCharacter_Base_IsAStructure) == 0x000001, "Wrong size on HWCharacter_Base_IsAStructure");
static_assert(offsetof(HWCharacter_Base_IsAStructure, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsAStructure::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsATitan
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsATitan final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsATitan) == 0x000001, "Wrong alignment on HWCharacter_Base_IsATitan");
static_assert(sizeof(HWCharacter_Base_IsATitan) == 0x000001, "Wrong size on HWCharacter_Base_IsATitan");
static_assert(offsetof(HWCharacter_Base_IsATitan, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsATitan::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsCloneFamiliar
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsCloneFamiliar final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsCloneFamiliar) == 0x000001, "Wrong alignment on HWCharacter_Base_IsCloneFamiliar");
static_assert(sizeof(HWCharacter_Base_IsCloneFamiliar) == 0x000001, "Wrong size on HWCharacter_Base_IsCloneFamiliar");
static_assert(offsetof(HWCharacter_Base_IsCloneFamiliar, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsCloneFamiliar::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsFamiliar
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsFamiliar final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsFamiliar) == 0x000001, "Wrong alignment on HWCharacter_Base_IsFamiliar");
static_assert(sizeof(HWCharacter_Base_IsFamiliar) == 0x000001, "Wrong size on HWCharacter_Base_IsFamiliar");
static_assert(offsetof(HWCharacter_Base_IsFamiliar, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsFamiliar::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsGodDecoy
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsGodDecoy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsGodDecoy) == 0x000001, "Wrong alignment on HWCharacter_Base_IsGodDecoy");
static_assert(sizeof(HWCharacter_Base_IsGodDecoy) == 0x000001, "Wrong size on HWCharacter_Base_IsGodDecoy");
static_assert(offsetof(HWCharacter_Base_IsGodDecoy, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsGodDecoy::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsHardRooted
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsHardRooted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsHardRooted) == 0x000001, "Wrong alignment on HWCharacter_Base_IsHardRooted");
static_assert(sizeof(HWCharacter_Base_IsHardRooted) == 0x000001, "Wrong size on HWCharacter_Base_IsHardRooted");
static_assert(offsetof(HWCharacter_Base_IsHardRooted, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsHardRooted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsImmobilized
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsImmobilized final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsImmobilized) == 0x000001, "Wrong alignment on HWCharacter_Base_IsImmobilized");
static_assert(sizeof(HWCharacter_Base_IsImmobilized) == 0x000001, "Wrong size on HWCharacter_Base_IsImmobilized");
static_assert(offsetof(HWCharacter_Base_IsImmobilized, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsImmobilized::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsMesmerized
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsMesmerized final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsMesmerized) == 0x000001, "Wrong alignment on HWCharacter_Base_IsMesmerized");
static_assert(sizeof(HWCharacter_Base_IsMesmerized) == 0x000001, "Wrong size on HWCharacter_Base_IsMesmerized");
static_assert(offsetof(HWCharacter_Base_IsMesmerized, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsMesmerized::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsRespawning
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsRespawning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsRespawning) == 0x000001, "Wrong alignment on HWCharacter_Base_IsRespawning");
static_assert(sizeof(HWCharacter_Base_IsRespawning) == 0x000001, "Wrong size on HWCharacter_Base_IsRespawning");
static_assert(offsetof(HWCharacter_Base_IsRespawning, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsRespawning::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsSkinningReady
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsSkinningReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsSkinningReady) == 0x000001, "Wrong alignment on HWCharacter_Base_IsSkinningReady");
static_assert(sizeof(HWCharacter_Base_IsSkinningReady) == 0x000001, "Wrong size on HWCharacter_Base_IsSkinningReady");
static_assert(offsetof(HWCharacter_Base_IsSkinningReady, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsSkinningReady::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Base.IsStunned
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Base_IsStunned final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Base_IsStunned) == 0x000001, "Wrong alignment on HWCharacter_Base_IsStunned");
static_assert(sizeof(HWCharacter_Base_IsStunned) == 0x000001, "Wrong size on HWCharacter_Base_IsStunned");
static_assert(offsetof(HWCharacter_Base_IsStunned, ReturnValue) == 0x000000, "Member 'HWCharacter_Base_IsStunned::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_PlayableCharacter.HandleTagUpdated_DisableCameraCollision
// 0x000C (0x000C - 0x0000)
struct HWCharacter_PlayableCharacter_HandleTagUpdated_DisableCameraCollision final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_PlayableCharacter_HandleTagUpdated_DisableCameraCollision) == 0x000004, "Wrong alignment on HWCharacter_PlayableCharacter_HandleTagUpdated_DisableCameraCollision");
static_assert(sizeof(HWCharacter_PlayableCharacter_HandleTagUpdated_DisableCameraCollision) == 0x00000C, "Wrong size on HWCharacter_PlayableCharacter_HandleTagUpdated_DisableCameraCollision");
static_assert(offsetof(HWCharacter_PlayableCharacter_HandleTagUpdated_DisableCameraCollision, Tag) == 0x000000, "Member 'HWCharacter_PlayableCharacter_HandleTagUpdated_DisableCameraCollision::Tag' has a wrong offset!");
static_assert(offsetof(HWCharacter_PlayableCharacter_HandleTagUpdated_DisableCameraCollision, Count) == 0x000008, "Member 'HWCharacter_PlayableCharacter_HandleTagUpdated_DisableCameraCollision::Count' has a wrong offset!");

// Function Hemingway.HWCharacter_PlayableCharacter.Input_JumpPressed
// 0x0020 (0x0020 - 0x0000)
struct HWCharacter_PlayableCharacter_Input_JumpPressed final
{
public:
	struct FInputActionValue                      InputActionValue;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_PlayableCharacter_Input_JumpPressed) == 0x000008, "Wrong alignment on HWCharacter_PlayableCharacter_Input_JumpPressed");
static_assert(sizeof(HWCharacter_PlayableCharacter_Input_JumpPressed) == 0x000020, "Wrong size on HWCharacter_PlayableCharacter_Input_JumpPressed");
static_assert(offsetof(HWCharacter_PlayableCharacter_Input_JumpPressed, InputActionValue) == 0x000000, "Member 'HWCharacter_PlayableCharacter_Input_JumpPressed::InputActionValue' has a wrong offset!");

// Function Hemingway.HWCharacter_PlayableCharacter.Input_JumpReleased
// 0x0020 (0x0020 - 0x0000)
struct HWCharacter_PlayableCharacter_Input_JumpReleased final
{
public:
	struct FInputActionValue                      InputActionValue;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_PlayableCharacter_Input_JumpReleased) == 0x000008, "Wrong alignment on HWCharacter_PlayableCharacter_Input_JumpReleased");
static_assert(sizeof(HWCharacter_PlayableCharacter_Input_JumpReleased) == 0x000020, "Wrong size on HWCharacter_PlayableCharacter_Input_JumpReleased");
static_assert(offsetof(HWCharacter_PlayableCharacter_Input_JumpReleased, InputActionValue) == 0x000000, "Member 'HWCharacter_PlayableCharacter_Input_JumpReleased::InputActionValue' has a wrong offset!");

// Function Hemingway.HWCharacter_PlayableCharacter.Input_Look
// 0x0020 (0x0020 - 0x0000)
struct HWCharacter_PlayableCharacter_Input_Look final
{
public:
	struct FInputActionValue                      InputActionValue;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_PlayableCharacter_Input_Look) == 0x000008, "Wrong alignment on HWCharacter_PlayableCharacter_Input_Look");
static_assert(sizeof(HWCharacter_PlayableCharacter_Input_Look) == 0x000020, "Wrong size on HWCharacter_PlayableCharacter_Input_Look");
static_assert(offsetof(HWCharacter_PlayableCharacter_Input_Look, InputActionValue) == 0x000000, "Member 'HWCharacter_PlayableCharacter_Input_Look::InputActionValue' has a wrong offset!");

// Function Hemingway.HWCharacter_PlayableCharacter.Input_Move
// 0x0020 (0x0020 - 0x0000)
struct HWCharacter_PlayableCharacter_Input_Move final
{
public:
	struct FInputActionValue                      InputActionValue;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_PlayableCharacter_Input_Move) == 0x000008, "Wrong alignment on HWCharacter_PlayableCharacter_Input_Move");
static_assert(sizeof(HWCharacter_PlayableCharacter_Input_Move) == 0x000020, "Wrong size on HWCharacter_PlayableCharacter_Input_Move");
static_assert(offsetof(HWCharacter_PlayableCharacter_Input_Move, InputActionValue) == 0x000000, "Member 'HWCharacter_PlayableCharacter_Input_Move::InputActionValue' has a wrong offset!");

// Function Hemingway.HWCharacter_PlayableCharacter.GetEffectiveKillAssistRange
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_PlayableCharacter_GetEffectiveKillAssistRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_PlayableCharacter_GetEffectiveKillAssistRange) == 0x000004, "Wrong alignment on HWCharacter_PlayableCharacter_GetEffectiveKillAssistRange");
static_assert(sizeof(HWCharacter_PlayableCharacter_GetEffectiveKillAssistRange) == 0x000004, "Wrong size on HWCharacter_PlayableCharacter_GetEffectiveKillAssistRange");
static_assert(offsetof(HWCharacter_PlayableCharacter_GetEffectiveKillAssistRange, ReturnValue) == 0x000000, "Member 'HWCharacter_PlayableCharacter_GetEffectiveKillAssistRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_PlayableCharacter.GetGodKillAssistEligibilityDuration
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_PlayableCharacter_GetGodKillAssistEligibilityDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_PlayableCharacter_GetGodKillAssistEligibilityDuration) == 0x000004, "Wrong alignment on HWCharacter_PlayableCharacter_GetGodKillAssistEligibilityDuration");
static_assert(sizeof(HWCharacter_PlayableCharacter_GetGodKillAssistEligibilityDuration) == 0x000004, "Wrong size on HWCharacter_PlayableCharacter_GetGodKillAssistEligibilityDuration");
static_assert(offsetof(HWCharacter_PlayableCharacter_GetGodKillAssistEligibilityDuration, ReturnValue) == 0x000000, "Member 'HWCharacter_PlayableCharacter_GetGodKillAssistEligibilityDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_PlayableCharacter.GetNPCKillAssistEligibilityDuration
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_PlayableCharacter_GetNPCKillAssistEligibilityDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_PlayableCharacter_GetNPCKillAssistEligibilityDuration) == 0x000004, "Wrong alignment on HWCharacter_PlayableCharacter_GetNPCKillAssistEligibilityDuration");
static_assert(sizeof(HWCharacter_PlayableCharacter_GetNPCKillAssistEligibilityDuration) == 0x000004, "Wrong size on HWCharacter_PlayableCharacter_GetNPCKillAssistEligibilityDuration");
static_assert(offsetof(HWCharacter_PlayableCharacter_GetNPCKillAssistEligibilityDuration, ReturnValue) == 0x000000, "Member 'HWCharacter_PlayableCharacter_GetNPCKillAssistEligibilityDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_PlayableCharacter.GetSpringArmComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_PlayableCharacter_GetSpringArmComponent final
{
public:
	class UHWSpringArmComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_PlayableCharacter_GetSpringArmComponent) == 0x000008, "Wrong alignment on HWCharacter_PlayableCharacter_GetSpringArmComponent");
static_assert(sizeof(HWCharacter_PlayableCharacter_GetSpringArmComponent) == 0x000008, "Wrong size on HWCharacter_PlayableCharacter_GetSpringArmComponent");
static_assert(offsetof(HWCharacter_PlayableCharacter_GetSpringArmComponent, ReturnValue) == 0x000000, "Member 'HWCharacter_PlayableCharacter_GetSpringArmComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_PlayableCharacter.GetStartingCameraZ
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_PlayableCharacter_GetStartingCameraZ final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_PlayableCharacter_GetStartingCameraZ) == 0x000004, "Wrong alignment on HWCharacter_PlayableCharacter_GetStartingCameraZ");
static_assert(sizeof(HWCharacter_PlayableCharacter_GetStartingCameraZ) == 0x000004, "Wrong size on HWCharacter_PlayableCharacter_GetStartingCameraZ");
static_assert(offsetof(HWCharacter_PlayableCharacter_GetStartingCameraZ, ReturnValue) == 0x000000, "Member 'HWCharacter_PlayableCharacter_GetStartingCameraZ::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Smite_God.ActivateCharacterDamagedFeedbackMaterialOverlay
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Smite_God_ActivateCharacterDamagedFeedbackMaterialOverlay final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaterialIntensity;                                 // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Smite_God_ActivateCharacterDamagedFeedbackMaterialOverlay) == 0x000004, "Wrong alignment on HWCharacter_Smite_God_ActivateCharacterDamagedFeedbackMaterialOverlay");
static_assert(sizeof(HWCharacter_Smite_God_ActivateCharacterDamagedFeedbackMaterialOverlay) == 0x000008, "Wrong size on HWCharacter_Smite_God_ActivateCharacterDamagedFeedbackMaterialOverlay");
static_assert(offsetof(HWCharacter_Smite_God_ActivateCharacterDamagedFeedbackMaterialOverlay, Duration) == 0x000000, "Member 'HWCharacter_Smite_God_ActivateCharacterDamagedFeedbackMaterialOverlay::Duration' has a wrong offset!");
static_assert(offsetof(HWCharacter_Smite_God_ActivateCharacterDamagedFeedbackMaterialOverlay, MaterialIntensity) == 0x000004, "Member 'HWCharacter_Smite_God_ActivateCharacterDamagedFeedbackMaterialOverlay::MaterialIntensity' has a wrong offset!");

// Function Hemingway.HWCharacter_Smite_God.DamageFeedbackTimelineUpdate
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Smite_God_DamageFeedbackTimelineUpdate final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Smite_God_DamageFeedbackTimelineUpdate) == 0x000004, "Wrong alignment on HWCharacter_Smite_God_DamageFeedbackTimelineUpdate");
static_assert(sizeof(HWCharacter_Smite_God_DamageFeedbackTimelineUpdate) == 0x000004, "Wrong size on HWCharacter_Smite_God_DamageFeedbackTimelineUpdate");
static_assert(offsetof(HWCharacter_Smite_God_DamageFeedbackTimelineUpdate, Value) == 0x000000, "Member 'HWCharacter_Smite_God_DamageFeedbackTimelineUpdate::Value' has a wrong offset!");

// Function Hemingway.HWCharacter_Smite_God.HandleTagUpdated_InCombat
// 0x000C (0x000C - 0x0000)
struct HWCharacter_Smite_God_HandleTagUpdated_InCombat final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Smite_God_HandleTagUpdated_InCombat) == 0x000004, "Wrong alignment on HWCharacter_Smite_God_HandleTagUpdated_InCombat");
static_assert(sizeof(HWCharacter_Smite_God_HandleTagUpdated_InCombat) == 0x00000C, "Wrong size on HWCharacter_Smite_God_HandleTagUpdated_InCombat");
static_assert(offsetof(HWCharacter_Smite_God_HandleTagUpdated_InCombat, CallbackTag) == 0x000000, "Member 'HWCharacter_Smite_God_HandleTagUpdated_InCombat::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_Smite_God_HandleTagUpdated_InCombat, NewCount) == 0x000008, "Member 'HWCharacter_Smite_God_HandleTagUpdated_InCombat::NewCount' has a wrong offset!");

// Function Hemingway.HWCharacter_Smite_God.TriggerLocalVoiceEvent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Smite_God_TriggerLocalVoiceEvent final
{
public:
	struct FGameplayTag                           VoiceEvent;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Smite_God_TriggerLocalVoiceEvent) == 0x000004, "Wrong alignment on HWCharacter_Smite_God_TriggerLocalVoiceEvent");
static_assert(sizeof(HWCharacter_Smite_God_TriggerLocalVoiceEvent) == 0x000008, "Wrong size on HWCharacter_Smite_God_TriggerLocalVoiceEvent");
static_assert(offsetof(HWCharacter_Smite_God_TriggerLocalVoiceEvent, VoiceEvent) == 0x000000, "Member 'HWCharacter_Smite_God_TriggerLocalVoiceEvent::VoiceEvent' has a wrong offset!");

// Function Hemingway.HWCharacter_Smite_God.TriggerVoiceEvent
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Smite_God_TriggerVoiceEvent final
{
public:
	struct FGameplayTag                           VoiceEvent;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AudienceOverride;                                  // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Smite_God_TriggerVoiceEvent) == 0x000004, "Wrong alignment on HWCharacter_Smite_God_TriggerVoiceEvent");
static_assert(sizeof(HWCharacter_Smite_God_TriggerVoiceEvent) == 0x000010, "Wrong size on HWCharacter_Smite_God_TriggerVoiceEvent");
static_assert(offsetof(HWCharacter_Smite_God_TriggerVoiceEvent, VoiceEvent) == 0x000000, "Member 'HWCharacter_Smite_God_TriggerVoiceEvent::VoiceEvent' has a wrong offset!");
static_assert(offsetof(HWCharacter_Smite_God_TriggerVoiceEvent, AudienceOverride) == 0x000008, "Member 'HWCharacter_Smite_God_TriggerVoiceEvent::AudienceOverride' has a wrong offset!");

// Function Hemingway.HWCharacter_Smite_God.GetVoiceComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Smite_God_GetVoiceComponent final
{
public:
	class UHWVoiceComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Smite_God_GetVoiceComponent) == 0x000008, "Wrong alignment on HWCharacter_Smite_God_GetVoiceComponent");
static_assert(sizeof(HWCharacter_Smite_God_GetVoiceComponent) == 0x000008, "Wrong size on HWCharacter_Smite_God_GetVoiceComponent");
static_assert(offsetof(HWCharacter_Smite_God_GetVoiceComponent, ReturnValue) == 0x000000, "Member 'HWCharacter_Smite_God_GetVoiceComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.AddDynamicDisplayCurrency
// 0x0028 (0x0028 - 0x0000)
struct HWStoreSubsystem_AddDynamicDisplayCurrency final
{
public:
	TSoftObjectPtr<class URHCurrency>             CURRENCY;                                          // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_AddDynamicDisplayCurrency) == 0x000008, "Wrong alignment on HWStoreSubsystem_AddDynamicDisplayCurrency");
static_assert(sizeof(HWStoreSubsystem_AddDynamicDisplayCurrency) == 0x000028, "Wrong size on HWStoreSubsystem_AddDynamicDisplayCurrency");
static_assert(offsetof(HWStoreSubsystem_AddDynamicDisplayCurrency, CURRENCY) == 0x000000, "Member 'HWStoreSubsystem_AddDynamicDisplayCurrency::CURRENCY' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetPriceForDisplay
// 0x0020 (0x0020 - 0x0000)
struct HWStoreSubsystem_GetPriceForDisplay final
{
public:
	class URHStoreItem*                           StoreItem;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class URHStoreItemPrice* ItemPrice, const struct FGameplayTag& PriceGroupTag)> Callback; // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetPriceForDisplay) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetPriceForDisplay");
static_assert(sizeof(HWStoreSubsystem_GetPriceForDisplay) == 0x000020, "Wrong size on HWStoreSubsystem_GetPriceForDisplay");
static_assert(offsetof(HWStoreSubsystem_GetPriceForDisplay, StoreItem) == 0x000000, "Member 'HWStoreSubsystem_GetPriceForDisplay::StoreItem' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetPriceForDisplay, PlayerInfo) == 0x000008, "Member 'HWStoreSubsystem_GetPriceForDisplay::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetPriceForDisplay, Callback) == 0x000010, "Member 'HWStoreSubsystem_GetPriceForDisplay::Callback' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetVIPStoreItem
// 0x0008 (0x0008 - 0x0000)
struct HWStoreSubsystem_GetVIPStoreItem final
{
public:
	class URHStoreItem*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetVIPStoreItem) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetVIPStoreItem");
static_assert(sizeof(HWStoreSubsystem_GetVIPStoreItem) == 0x000008, "Wrong size on HWStoreSubsystem_GetVIPStoreItem");
static_assert(offsetof(HWStoreSubsystem_GetVIPStoreItem, ReturnValue) == 0x000000, "Member 'HWStoreSubsystem_GetVIPStoreItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.RemoveDynamicDisplayCurrency
// 0x0028 (0x0028 - 0x0000)
struct HWStoreSubsystem_RemoveDynamicDisplayCurrency final
{
public:
	TSoftObjectPtr<class URHCurrency>             CURRENCY;                                          // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_RemoveDynamicDisplayCurrency) == 0x000008, "Wrong alignment on HWStoreSubsystem_RemoveDynamicDisplayCurrency");
static_assert(sizeof(HWStoreSubsystem_RemoveDynamicDisplayCurrency) == 0x000028, "Wrong size on HWStoreSubsystem_RemoveDynamicDisplayCurrency");
static_assert(offsetof(HWStoreSubsystem_RemoveDynamicDisplayCurrency, CURRENCY) == 0x000000, "Member 'HWStoreSubsystem_RemoveDynamicDisplayCurrency::CURRENCY' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.CurrencyIdToType
// 0x0018 (0x0018 - 0x0000)
struct HWStoreSubsystem_CurrencyIdToType final
{
public:
	struct FRH_ItemId                             CurrencyId;                                        // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWCurrencyType                               ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWStoreSubsystem_CurrencyIdToType) == 0x000004, "Wrong alignment on HWStoreSubsystem_CurrencyIdToType");
static_assert(sizeof(HWStoreSubsystem_CurrencyIdToType) == 0x000018, "Wrong size on HWStoreSubsystem_CurrencyIdToType");
static_assert(offsetof(HWStoreSubsystem_CurrencyIdToType, CurrencyId) == 0x000000, "Member 'HWStoreSubsystem_CurrencyIdToType::CurrencyId' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_CurrencyIdToType, ReturnValue) == 0x000014, "Member 'HWStoreSubsystem_CurrencyIdToType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.CurrencyTypeToId
// 0x0018 (0x0018 - 0x0000)
struct HWStoreSubsystem_CurrencyTypeToId final
{
public:
	EHWCurrencyType                               CurrencyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_ItemId                             ReturnValue;                                       // 0x0004(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_CurrencyTypeToId) == 0x000004, "Wrong alignment on HWStoreSubsystem_CurrencyTypeToId");
static_assert(sizeof(HWStoreSubsystem_CurrencyTypeToId) == 0x000018, "Wrong size on HWStoreSubsystem_CurrencyTypeToId");
static_assert(offsetof(HWStoreSubsystem_CurrencyTypeToId, CurrencyType) == 0x000000, "Member 'HWStoreSubsystem_CurrencyTypeToId::CurrencyType' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_CurrencyTypeToId, ReturnValue) == 0x000004, "Member 'HWStoreSubsystem_CurrencyTypeToId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetArePurchasesWithCurrencyEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWStoreSubsystem_GetArePurchasesWithCurrencyEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetArePurchasesWithCurrencyEnabled) == 0x000001, "Wrong alignment on HWStoreSubsystem_GetArePurchasesWithCurrencyEnabled");
static_assert(sizeof(HWStoreSubsystem_GetArePurchasesWithCurrencyEnabled) == 0x000001, "Wrong size on HWStoreSubsystem_GetArePurchasesWithCurrencyEnabled");
static_assert(offsetof(HWStoreSubsystem_GetArePurchasesWithCurrencyEnabled, ReturnValue) == 0x000000, "Member 'HWStoreSubsystem_GetArePurchasesWithCurrencyEnabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetCachedPlayerVIPOwnershipExpiration
// 0x0010 (0x0010 - 0x0000)
struct HWStoreSubsystem_GetCachedPlayerVIPOwnershipExpiration final
{
public:
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetCachedPlayerVIPOwnershipExpiration) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetCachedPlayerVIPOwnershipExpiration");
static_assert(sizeof(HWStoreSubsystem_GetCachedPlayerVIPOwnershipExpiration) == 0x000010, "Wrong size on HWStoreSubsystem_GetCachedPlayerVIPOwnershipExpiration");
static_assert(offsetof(HWStoreSubsystem_GetCachedPlayerVIPOwnershipExpiration, PlayerInfo) == 0x000000, "Member 'HWStoreSubsystem_GetCachedPlayerVIPOwnershipExpiration::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetCachedPlayerVIPOwnershipExpiration, ReturnValue) == 0x000008, "Member 'HWStoreSubsystem_GetCachedPlayerVIPOwnershipExpiration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetCachedPlayerVIPOwnershipLevel
// 0x0010 (0x0010 - 0x0000)
struct HWStoreSubsystem_GetCachedPlayerVIPOwnershipLevel final
{
public:
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWVIPOwnershipLevel                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWStoreSubsystem_GetCachedPlayerVIPOwnershipLevel) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetCachedPlayerVIPOwnershipLevel");
static_assert(sizeof(HWStoreSubsystem_GetCachedPlayerVIPOwnershipLevel) == 0x000010, "Wrong size on HWStoreSubsystem_GetCachedPlayerVIPOwnershipLevel");
static_assert(offsetof(HWStoreSubsystem_GetCachedPlayerVIPOwnershipLevel, PlayerInfo) == 0x000000, "Member 'HWStoreSubsystem_GetCachedPlayerVIPOwnershipLevel::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetCachedPlayerVIPOwnershipLevel, ReturnValue) == 0x000008, "Member 'HWStoreSubsystem_GetCachedPlayerVIPOwnershipLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetCurrencyById
// 0x0020 (0x0020 - 0x0000)
struct HWStoreSubsystem_GetCurrencyById final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URHCurrency*                            ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetCurrencyById) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetCurrencyById");
static_assert(sizeof(HWStoreSubsystem_GetCurrencyById) == 0x000020, "Wrong size on HWStoreSubsystem_GetCurrencyById");
static_assert(offsetof(HWStoreSubsystem_GetCurrencyById, ItemId) == 0x000000, "Member 'HWStoreSubsystem_GetCurrencyById::ItemId' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetCurrencyById, ReturnValue) == 0x000018, "Member 'HWStoreSubsystem_GetCurrencyById::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetCurrencyByType
// 0x0010 (0x0010 - 0x0000)
struct HWStoreSubsystem_GetCurrencyByType final
{
public:
	EHWCurrencyType                               CurrencyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URHCurrency*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetCurrencyByType) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetCurrencyByType");
static_assert(sizeof(HWStoreSubsystem_GetCurrencyByType) == 0x000010, "Wrong size on HWStoreSubsystem_GetCurrencyByType");
static_assert(offsetof(HWStoreSubsystem_GetCurrencyByType, CurrencyType) == 0x000000, "Member 'HWStoreSubsystem_GetCurrencyByType::CurrencyType' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetCurrencyByType, ReturnValue) == 0x000008, "Member 'HWStoreSubsystem_GetCurrencyByType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetDynamicDisplayCurrencies
// 0x0010 (0x0010 - 0x0000)
struct HWStoreSubsystem_GetDynamicDisplayCurrencies final
{
public:
	TArray<TSoftObjectPtr<class URHCurrency>>     ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetDynamicDisplayCurrencies) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetDynamicDisplayCurrencies");
static_assert(sizeof(HWStoreSubsystem_GetDynamicDisplayCurrencies) == 0x000010, "Wrong size on HWStoreSubsystem_GetDynamicDisplayCurrencies");
static_assert(offsetof(HWStoreSubsystem_GetDynamicDisplayCurrencies, ReturnValue) == 0x000000, "Member 'HWStoreSubsystem_GetDynamicDisplayCurrencies::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetGenericCollectionItemById
// 0x0048 (0x0048 - 0x0000)
struct HWStoreSubsystem_GetGenericCollectionItemById final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWGenericCollectionMappedData         OutMappedData;                                     // 0x0014(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWCollectionItem>       ReturnValue;                                       // 0x0020(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetGenericCollectionItemById) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetGenericCollectionItemById");
static_assert(sizeof(HWStoreSubsystem_GetGenericCollectionItemById) == 0x000048, "Wrong size on HWStoreSubsystem_GetGenericCollectionItemById");
static_assert(offsetof(HWStoreSubsystem_GetGenericCollectionItemById, ItemId) == 0x000000, "Member 'HWStoreSubsystem_GetGenericCollectionItemById::ItemId' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetGenericCollectionItemById, OutMappedData) == 0x000014, "Member 'HWStoreSubsystem_GetGenericCollectionItemById::OutMappedData' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetGenericCollectionItemById, ReturnValue) == 0x000020, "Member 'HWStoreSubsystem_GetGenericCollectionItemById::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetLegacyCurrencyItem
// 0x0008 (0x0008 - 0x0000)
struct HWStoreSubsystem_GetLegacyCurrencyItem final
{
public:
	class URHCurrency*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetLegacyCurrencyItem) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetLegacyCurrencyItem");
static_assert(sizeof(HWStoreSubsystem_GetLegacyCurrencyItem) == 0x000008, "Wrong size on HWStoreSubsystem_GetLegacyCurrencyItem");
static_assert(offsetof(HWStoreSubsystem_GetLegacyCurrencyItem, ReturnValue) == 0x000000, "Member 'HWStoreSubsystem_GetLegacyCurrencyItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetPlayerFoundersOwnershipLevel
// 0x0010 (0x0010 - 0x0000)
struct HWStoreSubsystem_GetPlayerFoundersOwnershipLevel final
{
public:
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWFoundersOwnershipLevel                     ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWStoreSubsystem_GetPlayerFoundersOwnershipLevel) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetPlayerFoundersOwnershipLevel");
static_assert(sizeof(HWStoreSubsystem_GetPlayerFoundersOwnershipLevel) == 0x000010, "Wrong size on HWStoreSubsystem_GetPlayerFoundersOwnershipLevel");
static_assert(offsetof(HWStoreSubsystem_GetPlayerFoundersOwnershipLevel, PlayerInfo) == 0x000000, "Member 'HWStoreSubsystem_GetPlayerFoundersOwnershipLevel::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetPlayerFoundersOwnershipLevel, ReturnValue) == 0x000008, "Member 'HWStoreSubsystem_GetPlayerFoundersOwnershipLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetPrismBundleUpsell
// 0x0028 (0x0028 - 0x0000)
struct HWStoreSubsystem_GetPrismBundleUpsell final
{
public:
	struct FRH_ItemId                             BaseSkinId;                                        // 0x0000(0x0014)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             ReturnValue;                                       // 0x0014(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetPrismBundleUpsell) == 0x000004, "Wrong alignment on HWStoreSubsystem_GetPrismBundleUpsell");
static_assert(sizeof(HWStoreSubsystem_GetPrismBundleUpsell) == 0x000028, "Wrong size on HWStoreSubsystem_GetPrismBundleUpsell");
static_assert(offsetof(HWStoreSubsystem_GetPrismBundleUpsell, BaseSkinId) == 0x000000, "Member 'HWStoreSubsystem_GetPrismBundleUpsell::BaseSkinId' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetPrismBundleUpsell, ReturnValue) == 0x000014, "Member 'HWStoreSubsystem_GetPrismBundleUpsell::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetPurchaseRequestDataForItem
// 0x0010 (0x0010 - 0x0000)
struct HWStoreSubsystem_GetPurchaseRequestDataForItem final
{
public:
	const class UHWInventoryItem*                 Item;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URHStorePurchaseRequest*                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetPurchaseRequestDataForItem) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetPurchaseRequestDataForItem");
static_assert(sizeof(HWStoreSubsystem_GetPurchaseRequestDataForItem) == 0x000010, "Wrong size on HWStoreSubsystem_GetPurchaseRequestDataForItem");
static_assert(offsetof(HWStoreSubsystem_GetPurchaseRequestDataForItem, Item) == 0x000000, "Member 'HWStoreSubsystem_GetPurchaseRequestDataForItem::Item' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetPurchaseRequestDataForItem, ReturnValue) == 0x000008, "Member 'HWStoreSubsystem_GetPurchaseRequestDataForItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetSoftCurrencyById
// 0x0040 (0x0040 - 0x0000)
struct HWStoreSubsystem_GetSoftCurrencyById final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class URHCurrency>             ReturnValue;                                       // 0x0018(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetSoftCurrencyById) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetSoftCurrencyById");
static_assert(sizeof(HWStoreSubsystem_GetSoftCurrencyById) == 0x000040, "Wrong size on HWStoreSubsystem_GetSoftCurrencyById");
static_assert(offsetof(HWStoreSubsystem_GetSoftCurrencyById, ItemId) == 0x000000, "Member 'HWStoreSubsystem_GetSoftCurrencyById::ItemId' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetSoftCurrencyById, ReturnValue) == 0x000018, "Member 'HWStoreSubsystem_GetSoftCurrencyById::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.GetStoreItemBySKU
// 0x0018 (0x0018 - 0x0000)
struct HWStoreSubsystem_GetStoreItemBySKU final
{
public:
	class FString                                 Sku;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URHStoreItem*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_GetStoreItemBySKU) == 0x000008, "Wrong alignment on HWStoreSubsystem_GetStoreItemBySKU");
static_assert(sizeof(HWStoreSubsystem_GetStoreItemBySKU) == 0x000018, "Wrong size on HWStoreSubsystem_GetStoreItemBySKU");
static_assert(offsetof(HWStoreSubsystem_GetStoreItemBySKU, Sku) == 0x000000, "Member 'HWStoreSubsystem_GetStoreItemBySKU::Sku' has a wrong offset!");
static_assert(offsetof(HWStoreSubsystem_GetStoreItemBySKU, ReturnValue) == 0x000010, "Member 'HWStoreSubsystem_GetStoreItemBySKU::ReturnValue' has a wrong offset!");

// Function Hemingway.HWStoreSubsystem.IsReadyForQueries
// 0x0001 (0x0001 - 0x0000)
struct HWStoreSubsystem_IsReadyForQueries final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWStoreSubsystem_IsReadyForQueries) == 0x000001, "Wrong alignment on HWStoreSubsystem_IsReadyForQueries");
static_assert(sizeof(HWStoreSubsystem_IsReadyForQueries) == 0x000001, "Wrong size on HWStoreSubsystem_IsReadyForQueries");
static_assert(offsetof(HWStoreSubsystem_IsReadyForQueries, ReturnValue) == 0x000000, "Member 'HWStoreSubsystem_IsReadyForQueries::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_Custom.BP_CalcHighlightingTargetList
// 0x0070 (0x0070 - 0x0000)
struct HWAbilityAttackSettings_Custom_BP_CalcHighlightingTargetList final
{
public:
	struct FHWAttackTargetingInfo                 TargetingInfo;                                     // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetListDataHandle;                              // 0x0048(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_Custom_BP_CalcHighlightingTargetList) == 0x000008, "Wrong alignment on HWAbilityAttackSettings_Custom_BP_CalcHighlightingTargetList");
static_assert(sizeof(HWAbilityAttackSettings_Custom_BP_CalcHighlightingTargetList) == 0x000070, "Wrong size on HWAbilityAttackSettings_Custom_BP_CalcHighlightingTargetList");
static_assert(offsetof(HWAbilityAttackSettings_Custom_BP_CalcHighlightingTargetList, TargetingInfo) == 0x000000, "Member 'HWAbilityAttackSettings_Custom_BP_CalcHighlightingTargetList::TargetingInfo' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_Custom_BP_CalcHighlightingTargetList, TargetListDataHandle) == 0x000048, "Member 'HWAbilityAttackSettings_Custom_BP_CalcHighlightingTargetList::TargetListDataHandle' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy.OnBeginOverlap
// 0x0108 (0x0108 - 0x0000)
struct HWAbilityCollisionProxy_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityCollisionProxy_OnBeginOverlap) == 0x000008, "Wrong alignment on HWAbilityCollisionProxy_OnBeginOverlap");
static_assert(sizeof(HWAbilityCollisionProxy_OnBeginOverlap) == 0x000108, "Wrong size on HWAbilityCollisionProxy_OnBeginOverlap");
static_assert(offsetof(HWAbilityCollisionProxy_OnBeginOverlap, OverlappedComp) == 0x000000, "Member 'HWAbilityCollisionProxy_OnBeginOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_OnBeginOverlap, Other) == 0x000008, "Member 'HWAbilityCollisionProxy_OnBeginOverlap::Other' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_OnBeginOverlap, OtherComp) == 0x000010, "Member 'HWAbilityCollisionProxy_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'HWAbilityCollisionProxy_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'HWAbilityCollisionProxy_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_OnBeginOverlap, SweepResult) == 0x000020, "Member 'HWAbilityCollisionProxy_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct HWAbilityCollisionProxy_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityCollisionProxy_OnEndOverlap) == 0x000008, "Wrong alignment on HWAbilityCollisionProxy_OnEndOverlap");
static_assert(sizeof(HWAbilityCollisionProxy_OnEndOverlap) == 0x000020, "Wrong size on HWAbilityCollisionProxy_OnEndOverlap");
static_assert(offsetof(HWAbilityCollisionProxy_OnEndOverlap, OverlappedComp) == 0x000000, "Member 'HWAbilityCollisionProxy_OnEndOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_OnEndOverlap, Other) == 0x000008, "Member 'HWAbilityCollisionProxy_OnEndOverlap::Other' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_OnEndOverlap, OtherComp) == 0x000010, "Member 'HWAbilityCollisionProxy_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'HWAbilityCollisionProxy_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy.RemoveActorFromProxyTouchList
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityCollisionProxy_RemoveActorFromProxyTouchList final
{
public:
	const class AActor*                           TargetActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityCollisionProxy_RemoveActorFromProxyTouchList) == 0x000008, "Wrong alignment on HWAbilityCollisionProxy_RemoveActorFromProxyTouchList");
static_assert(sizeof(HWAbilityCollisionProxy_RemoveActorFromProxyTouchList) == 0x000008, "Wrong size on HWAbilityCollisionProxy_RemoveActorFromProxyTouchList");
static_assert(offsetof(HWAbilityCollisionProxy_RemoveActorFromProxyTouchList, TargetActor) == 0x000000, "Member 'HWAbilityCollisionProxy_RemoveActorFromProxyTouchList::TargetActor' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy.ShouldUseBaseCollisionFollow
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityCollisionProxy_ShouldUseBaseCollisionFollow final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityCollisionProxy_ShouldUseBaseCollisionFollow) == 0x000001, "Wrong alignment on HWAbilityCollisionProxy_ShouldUseBaseCollisionFollow");
static_assert(sizeof(HWAbilityCollisionProxy_ShouldUseBaseCollisionFollow) == 0x000001, "Wrong size on HWAbilityCollisionProxy_ShouldUseBaseCollisionFollow");
static_assert(offsetof(HWAbilityCollisionProxy_ShouldUseBaseCollisionFollow, ReturnValue) == 0x000000, "Member 'HWAbilityCollisionProxy_ShouldUseBaseCollisionFollow::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy_PushPull.CalcCharacterVelocityAdjustmentFactorPercent
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityCollisionProxy_PushPull_CalcCharacterVelocityAdjustmentFactorPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityCollisionProxy_PushPull_CalcCharacterVelocityAdjustmentFactorPercent) == 0x000004, "Wrong alignment on HWAbilityCollisionProxy_PushPull_CalcCharacterVelocityAdjustmentFactorPercent");
static_assert(sizeof(HWAbilityCollisionProxy_PushPull_CalcCharacterVelocityAdjustmentFactorPercent) == 0x000004, "Wrong size on HWAbilityCollisionProxy_PushPull_CalcCharacterVelocityAdjustmentFactorPercent");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_CalcCharacterVelocityAdjustmentFactorPercent, ReturnValue) == 0x000000, "Member 'HWAbilityCollisionProxy_PushPull_CalcCharacterVelocityAdjustmentFactorPercent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy_PushPull.CalcMovementForceSpeed
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityCollisionProxy_PushPull_CalcMovementForceSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityCollisionProxy_PushPull_CalcMovementForceSpeed) == 0x000004, "Wrong alignment on HWAbilityCollisionProxy_PushPull_CalcMovementForceSpeed");
static_assert(sizeof(HWAbilityCollisionProxy_PushPull_CalcMovementForceSpeed) == 0x000004, "Wrong size on HWAbilityCollisionProxy_PushPull_CalcMovementForceSpeed");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_CalcMovementForceSpeed, ReturnValue) == 0x000000, "Member 'HWAbilityCollisionProxy_PushPull_CalcMovementForceSpeed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy_PushPull.CanPushOrPullOverlappingActors
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityCollisionProxy_PushPull_CanPushOrPullOverlappingActors final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityCollisionProxy_PushPull_CanPushOrPullOverlappingActors) == 0x000001, "Wrong alignment on HWAbilityCollisionProxy_PushPull_CanPushOrPullOverlappingActors");
static_assert(sizeof(HWAbilityCollisionProxy_PushPull_CanPushOrPullOverlappingActors) == 0x000001, "Wrong size on HWAbilityCollisionProxy_PushPull_CanPushOrPullOverlappingActors");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_CanPushOrPullOverlappingActors, ReturnValue) == 0x000000, "Member 'HWAbilityCollisionProxy_PushPull_CanPushOrPullOverlappingActors::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy_PushPull.GetPullLocation
// 0x0018 (0x0018 - 0x0000)
struct HWAbilityCollisionProxy_PushPull_GetPullLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityCollisionProxy_PushPull_GetPullLocation) == 0x000008, "Wrong alignment on HWAbilityCollisionProxy_PushPull_GetPullLocation");
static_assert(sizeof(HWAbilityCollisionProxy_PushPull_GetPullLocation) == 0x000018, "Wrong size on HWAbilityCollisionProxy_PushPull_GetPullLocation");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_GetPullLocation, ReturnValue) == 0x000000, "Member 'HWAbilityCollisionProxy_PushPull_GetPullLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy_PushPull.GetPushDirection
// 0x0020 (0x0020 - 0x0000)
struct HWAbilityCollisionProxy_PushPull_GetPushDirection final
{
public:
	const class AActor*                           OverlappedActor;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityCollisionProxy_PushPull_GetPushDirection) == 0x000008, "Wrong alignment on HWAbilityCollisionProxy_PushPull_GetPushDirection");
static_assert(sizeof(HWAbilityCollisionProxy_PushPull_GetPushDirection) == 0x000020, "Wrong size on HWAbilityCollisionProxy_PushPull_GetPushDirection");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_GetPushDirection, OverlappedActor) == 0x000000, "Member 'HWAbilityCollisionProxy_PushPull_GetPushDirection::OverlappedActor' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_GetPushDirection, ReturnValue) == 0x000008, "Member 'HWAbilityCollisionProxy_PushPull_GetPushDirection::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy_PushPull.IsUsingAdjustmentFactorCurve
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityCollisionProxy_PushPull_IsUsingAdjustmentFactorCurve final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityCollisionProxy_PushPull_IsUsingAdjustmentFactorCurve) == 0x000001, "Wrong alignment on HWAbilityCollisionProxy_PushPull_IsUsingAdjustmentFactorCurve");
static_assert(sizeof(HWAbilityCollisionProxy_PushPull_IsUsingAdjustmentFactorCurve) == 0x000001, "Wrong size on HWAbilityCollisionProxy_PushPull_IsUsingAdjustmentFactorCurve");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_IsUsingAdjustmentFactorCurve, ReturnValue) == 0x000000, "Member 'HWAbilityCollisionProxy_PushPull_IsUsingAdjustmentFactorCurve::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy_PushPull.IsUsingSpeedCurve
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityCollisionProxy_PushPull_IsUsingSpeedCurve final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityCollisionProxy_PushPull_IsUsingSpeedCurve) == 0x000001, "Wrong alignment on HWAbilityCollisionProxy_PushPull_IsUsingSpeedCurve");
static_assert(sizeof(HWAbilityCollisionProxy_PushPull_IsUsingSpeedCurve) == 0x000001, "Wrong size on HWAbilityCollisionProxy_PushPull_IsUsingSpeedCurve");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_IsUsingSpeedCurve, ReturnValue) == 0x000000, "Member 'HWAbilityCollisionProxy_PushPull_IsUsingSpeedCurve::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy_PushPull.ShouldPushOrPullActor
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityCollisionProxy_PushPull_ShouldPushOrPullActor final
{
public:
	const class AActor*                           Other;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityCollisionProxy_PushPull_ShouldPushOrPullActor) == 0x000008, "Wrong alignment on HWAbilityCollisionProxy_PushPull_ShouldPushOrPullActor");
static_assert(sizeof(HWAbilityCollisionProxy_PushPull_ShouldPushOrPullActor) == 0x000010, "Wrong size on HWAbilityCollisionProxy_PushPull_ShouldPushOrPullActor");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_ShouldPushOrPullActor, Other) == 0x000000, "Member 'HWAbilityCollisionProxy_PushPull_ShouldPushOrPullActor::Other' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_ShouldPushOrPullActor, ReturnValue) == 0x000008, "Member 'HWAbilityCollisionProxy_PushPull_ShouldPushOrPullActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityCollisionProxy_PushPull.ShouldTrackOverlappedActor
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityCollisionProxy_PushPull_ShouldTrackOverlappedActor final
{
public:
	const class AActor*                           Other;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityCollisionProxy_PushPull_ShouldTrackOverlappedActor) == 0x000008, "Wrong alignment on HWAbilityCollisionProxy_PushPull_ShouldTrackOverlappedActor");
static_assert(sizeof(HWAbilityCollisionProxy_PushPull_ShouldTrackOverlappedActor) == 0x000010, "Wrong size on HWAbilityCollisionProxy_PushPull_ShouldTrackOverlappedActor");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_ShouldTrackOverlappedActor, Other) == 0x000000, "Member 'HWAbilityCollisionProxy_PushPull_ShouldTrackOverlappedActor::Other' has a wrong offset!");
static_assert(offsetof(HWAbilityCollisionProxy_PushPull_ShouldTrackOverlappedActor, ReturnValue) == 0x000008, "Member 'HWAbilityCollisionProxy_PushPull_ShouldTrackOverlappedActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Blueprintable.ActivateBlueprintAbilityTask
// 0x0020 (0x0020 - 0x0000)
struct HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWAbilityTask_Blueprintable> TaskClass;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_Blueprintable*           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask) == 0x000008, "Wrong alignment on HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask");
static_assert(sizeof(HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask) == 0x000020, "Wrong size on HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask");
static_assert(offsetof(HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask, OwningAbility) == 0x000000, "Member 'HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask, TaskClass) == 0x000010, "Member 'HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask::TaskClass' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask, ReturnValue) == 0x000018, "Member 'HWAbilityTask_Blueprintable_ActivateBlueprintAbilityTask::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Blueprintable.BP_OnDeactivated
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityTask_Blueprintable_BP_OnDeactivated final
{
public:
	bool                                          bWasDeactivatedDueToAbilityEnding;                 // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Blueprintable_BP_OnDeactivated) == 0x000001, "Wrong alignment on HWAbilityTask_Blueprintable_BP_OnDeactivated");
static_assert(sizeof(HWAbilityTask_Blueprintable_BP_OnDeactivated) == 0x000001, "Wrong size on HWAbilityTask_Blueprintable_BP_OnDeactivated");
static_assert(offsetof(HWAbilityTask_Blueprintable_BP_OnDeactivated, bWasDeactivatedDueToAbilityEnding) == 0x000000, "Member 'HWAbilityTask_Blueprintable_BP_OnDeactivated::bWasDeactivatedDueToAbilityEnding' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Blueprintable.BP_TickTask
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityTask_Blueprintable_BP_TickTask final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Blueprintable_BP_TickTask) == 0x000004, "Wrong alignment on HWAbilityTask_Blueprintable_BP_TickTask");
static_assert(sizeof(HWAbilityTask_Blueprintable_BP_TickTask) == 0x000004, "Wrong size on HWAbilityTask_Blueprintable_BP_TickTask");
static_assert(offsetof(HWAbilityTask_Blueprintable_BP_TickTask, DeltaTime) == 0x000000, "Member 'HWAbilityTask_Blueprintable_BP_TickTask::DeltaTime' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Blueprintable.BP_IsForRemoteClient
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityTask_Blueprintable_BP_IsForRemoteClient final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Blueprintable_BP_IsForRemoteClient) == 0x000001, "Wrong alignment on HWAbilityTask_Blueprintable_BP_IsForRemoteClient");
static_assert(sizeof(HWAbilityTask_Blueprintable_BP_IsForRemoteClient) == 0x000001, "Wrong size on HWAbilityTask_Blueprintable_BP_IsForRemoteClient");
static_assert(offsetof(HWAbilityTask_Blueprintable_BP_IsForRemoteClient, ReturnValue) == 0x000000, "Member 'HWAbilityTask_Blueprintable_BP_IsForRemoteClient::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Blueprintable.BP_IsLocallyControlled
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityTask_Blueprintable_BP_IsLocallyControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Blueprintable_BP_IsLocallyControlled) == 0x000001, "Wrong alignment on HWAbilityTask_Blueprintable_BP_IsLocallyControlled");
static_assert(sizeof(HWAbilityTask_Blueprintable_BP_IsLocallyControlled) == 0x000001, "Wrong size on HWAbilityTask_Blueprintable_BP_IsLocallyControlled");
static_assert(offsetof(HWAbilityTask_Blueprintable_BP_IsLocallyControlled, ReturnValue) == 0x000000, "Member 'HWAbilityTask_Blueprintable_BP_IsLocallyControlled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Blueprintable.BP_IsPredictingClient
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityTask_Blueprintable_BP_IsPredictingClient final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Blueprintable_BP_IsPredictingClient) == 0x000001, "Wrong alignment on HWAbilityTask_Blueprintable_BP_IsPredictingClient");
static_assert(sizeof(HWAbilityTask_Blueprintable_BP_IsPredictingClient) == 0x000001, "Wrong size on HWAbilityTask_Blueprintable_BP_IsPredictingClient");
static_assert(offsetof(HWAbilityTask_Blueprintable_BP_IsPredictingClient, ReturnValue) == 0x000000, "Member 'HWAbilityTask_Blueprintable_BP_IsPredictingClient::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Blueprintable.GetOwningHWAbility
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_Blueprintable_GetOwningHWAbility final
{
public:
	class UHWGameplayAbility*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Blueprintable_GetOwningHWAbility) == 0x000008, "Wrong alignment on HWAbilityTask_Blueprintable_GetOwningHWAbility");
static_assert(sizeof(HWAbilityTask_Blueprintable_GetOwningHWAbility) == 0x000008, "Wrong size on HWAbilityTask_Blueprintable_GetOwningHWAbility");
static_assert(offsetof(HWAbilityTask_Blueprintable_GetOwningHWAbility, ReturnValue) == 0x000000, "Member 'HWAbilityTask_Blueprintable_GetOwningHWAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Blueprintable.GetOwningHWAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_Blueprintable_GetOwningHWAbilitySystemComponent final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Blueprintable_GetOwningHWAbilitySystemComponent) == 0x000008, "Wrong alignment on HWAbilityTask_Blueprintable_GetOwningHWAbilitySystemComponent");
static_assert(sizeof(HWAbilityTask_Blueprintable_GetOwningHWAbilitySystemComponent) == 0x000008, "Wrong size on HWAbilityTask_Blueprintable_GetOwningHWAbilitySystemComponent");
static_assert(offsetof(HWAbilityTask_Blueprintable_GetOwningHWAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWAbilityTask_Blueprintable_GetOwningHWAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Hercules.ToggleBoulderMeshVisibility
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Hercules_ToggleBoulderMeshVisibility final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Hercules_ToggleBoulderMeshVisibility) == 0x000001, "Wrong alignment on HWCharacter_Hercules_ToggleBoulderMeshVisibility");
static_assert(sizeof(HWCharacter_Hercules_ToggleBoulderMeshVisibility) == 0x000001, "Wrong size on HWCharacter_Hercules_ToggleBoulderMeshVisibility");
static_assert(offsetof(HWCharacter_Hercules_ToggleBoulderMeshVisibility, bVisible) == 0x000000, "Member 'HWCharacter_Hercules_ToggleBoulderMeshVisibility::bVisible' has a wrong offset!");

// Function Hemingway.HWCharacter_Hercules.GetBoulderMeshScale
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_Hercules_GetBoulderMeshScale final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Hercules_GetBoulderMeshScale) == 0x000008, "Wrong alignment on HWCharacter_Hercules_GetBoulderMeshScale");
static_assert(sizeof(HWCharacter_Hercules_GetBoulderMeshScale) == 0x000018, "Wrong size on HWCharacter_Hercules_GetBoulderMeshScale");
static_assert(offsetof(HWCharacter_Hercules_GetBoulderMeshScale, ReturnValue) == 0x000000, "Member 'HWCharacter_Hercules_GetBoulderMeshScale::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Hercules.GetBoulderSocketName
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_Hercules_GetBoulderSocketName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Hercules_GetBoulderSocketName) == 0x000004, "Wrong alignment on HWCharacter_Hercules_GetBoulderSocketName");
static_assert(sizeof(HWCharacter_Hercules_GetBoulderSocketName) == 0x000008, "Wrong size on HWCharacter_Hercules_GetBoulderSocketName");
static_assert(offsetof(HWCharacter_Hercules_GetBoulderSocketName, ReturnValue) == 0x000000, "Member 'HWCharacter_Hercules_GetBoulderSocketName::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayLevitate.PerformGameplayLevitateOnTarget
// 0x0030 (0x0030 - 0x0000)
struct HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWGameplayLevitate>        Levitation;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      LevitationSource_0;                                // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      LevitationTarget;                                  // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_GameplayLevitate*        ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget");
static_assert(sizeof(HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget) == 0x000030, "Wrong size on HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget, OwningAbility) == 0x000000, "Member 'HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget, Levitation) == 0x000010, "Member 'HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget::Levitation' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget, LevitationSource_0) == 0x000018, "Member 'HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget::LevitationSource_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget, LevitationTarget) == 0x000020, "Member 'HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget::LevitationTarget' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget, ReturnValue) == 0x000028, "Member 'HWAbilityTask_GameplayLevitate_PerformGameplayLevitateOnTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayLevitate.OnAscentEnded
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_GameplayLevitate_OnAscentEnded final
{
public:
	class UHWGameplayLevitate*                    LevitationInstance;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayLevitate_OnAscentEnded) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayLevitate_OnAscentEnded");
static_assert(sizeof(HWAbilityTask_GameplayLevitate_OnAscentEnded) == 0x000008, "Wrong size on HWAbilityTask_GameplayLevitate_OnAscentEnded");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_OnAscentEnded, LevitationInstance) == 0x000000, "Member 'HWAbilityTask_GameplayLevitate_OnAscentEnded::LevitationInstance' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayLevitate.OnAscentStarted
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_GameplayLevitate_OnAscentStarted final
{
public:
	class UHWGameplayLevitate*                    LevitationInstance;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayLevitate_OnAscentStarted) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayLevitate_OnAscentStarted");
static_assert(sizeof(HWAbilityTask_GameplayLevitate_OnAscentStarted) == 0x000008, "Wrong size on HWAbilityTask_GameplayLevitate_OnAscentStarted");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_OnAscentStarted, LevitationInstance) == 0x000000, "Member 'HWAbilityTask_GameplayLevitate_OnAscentStarted::LevitationInstance' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayLevitate.OnDescentEnded
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_GameplayLevitate_OnDescentEnded final
{
public:
	class UHWGameplayLevitate*                    LevitationInstance;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayLevitate_OnDescentEnded) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayLevitate_OnDescentEnded");
static_assert(sizeof(HWAbilityTask_GameplayLevitate_OnDescentEnded) == 0x000008, "Wrong size on HWAbilityTask_GameplayLevitate_OnDescentEnded");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_OnDescentEnded, LevitationInstance) == 0x000000, "Member 'HWAbilityTask_GameplayLevitate_OnDescentEnded::LevitationInstance' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayLevitate.OnDescentStarted
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_GameplayLevitate_OnDescentStarted final
{
public:
	class UHWGameplayLevitate*                    LevitationInstance;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayLevitate_OnDescentStarted) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayLevitate_OnDescentStarted");
static_assert(sizeof(HWAbilityTask_GameplayLevitate_OnDescentStarted) == 0x000008, "Wrong size on HWAbilityTask_GameplayLevitate_OnDescentStarted");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_OnDescentStarted, LevitationInstance) == 0x000000, "Member 'HWAbilityTask_GameplayLevitate_OnDescentStarted::LevitationInstance' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayLevitate.OnHoverEnded
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_GameplayLevitate_OnHoverEnded final
{
public:
	class UHWGameplayLevitate*                    LevitationInstance;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayLevitate_OnHoverEnded) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayLevitate_OnHoverEnded");
static_assert(sizeof(HWAbilityTask_GameplayLevitate_OnHoverEnded) == 0x000008, "Wrong size on HWAbilityTask_GameplayLevitate_OnHoverEnded");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_OnHoverEnded, LevitationInstance) == 0x000000, "Member 'HWAbilityTask_GameplayLevitate_OnHoverEnded::LevitationInstance' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayLevitate.OnHoverStarted
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_GameplayLevitate_OnHoverStarted final
{
public:
	class UHWGameplayLevitate*                    LevitationInstance;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayLevitate_OnHoverStarted) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayLevitate_OnHoverStarted");
static_assert(sizeof(HWAbilityTask_GameplayLevitate_OnHoverStarted) == 0x000008, "Wrong size on HWAbilityTask_GameplayLevitate_OnHoverStarted");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_OnHoverStarted, LevitationInstance) == 0x000000, "Member 'HWAbilityTask_GameplayLevitate_OnHoverStarted::LevitationInstance' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayLevitate.OnLevitateCleansed
// 0x0028 (0x0028 - 0x0000)
struct HWAbilityTask_GameplayLevitate_OnLevitateCleansed final
{
public:
	struct FGameplayEffectRemovalInfo             GameplayEffectRemovalInfo;                         // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayLevitate_OnLevitateCleansed) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayLevitate_OnLevitateCleansed");
static_assert(sizeof(HWAbilityTask_GameplayLevitate_OnLevitateCleansed) == 0x000028, "Wrong size on HWAbilityTask_GameplayLevitate_OnLevitateCleansed");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_OnLevitateCleansed, GameplayEffectRemovalInfo) == 0x000000, "Member 'HWAbilityTask_GameplayLevitate_OnLevitateCleansed::GameplayEffectRemovalInfo' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayLevitate.OnLevitationEnded
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_GameplayLevitate_OnLevitationEnded final
{
public:
	class UHWGameplayLevitate*                    Levitation;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndLevitationReason                        EndLevitationReason;                               // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_GameplayLevitate_OnLevitationEnded) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayLevitate_OnLevitationEnded");
static_assert(sizeof(HWAbilityTask_GameplayLevitate_OnLevitationEnded) == 0x000010, "Wrong size on HWAbilityTask_GameplayLevitate_OnLevitationEnded");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_OnLevitationEnded, Levitation) == 0x000000, "Member 'HWAbilityTask_GameplayLevitate_OnLevitationEnded::Levitation' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_OnLevitationEnded, EndLevitationReason) == 0x000008, "Member 'HWAbilityTask_GameplayLevitate_OnLevitationEnded::EndLevitationReason' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayLevitate.OnLevitationStarted
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_GameplayLevitate_OnLevitationStarted final
{
public:
	class UHWGameplayLevitate*                    LevitationInstance;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayLevitate_OnLevitationStarted) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayLevitate_OnLevitationStarted");
static_assert(sizeof(HWAbilityTask_GameplayLevitate_OnLevitationStarted) == 0x000008, "Wrong size on HWAbilityTask_GameplayLevitate_OnLevitationStarted");
static_assert(offsetof(HWAbilityTask_GameplayLevitate_OnLevitationStarted, LevitationInstance) == 0x000000, "Member 'HWAbilityTask_GameplayLevitate_OnLevitationStarted::LevitationInstance' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitCastStyleInput.WaitForAblityCastInput
// 0x0020 (0x0020 - 0x0000)
struct HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityCastStyle                             CastStyle;                                         // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventAbilityInputFromConfirming;                // 0x0011(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitCastStyleInput*      ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput) == 0x000008, "Wrong alignment on HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput");
static_assert(sizeof(HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput) == 0x000020, "Wrong size on HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput");
static_assert(offsetof(HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput, CastStyle) == 0x000010, "Member 'HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput::CastStyle' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput, bPreventAbilityInputFromConfirming) == 0x000011, "Member 'HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput::bPreventAbilityInputFromConfirming' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput, ReturnValue) == 0x000018, "Member 'HWAbilityTask_WaitCastStyleInput_WaitForAblityCastInput::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitCastStyleInput.OnAbilityInputPressed
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityTask_WaitCastStyleInput_OnAbilityInputPressed final
{
public:
	float                                         TimeWaited;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitCastStyleInput_OnAbilityInputPressed) == 0x000004, "Wrong alignment on HWAbilityTask_WaitCastStyleInput_OnAbilityInputPressed");
static_assert(sizeof(HWAbilityTask_WaitCastStyleInput_OnAbilityInputPressed) == 0x000004, "Wrong size on HWAbilityTask_WaitCastStyleInput_OnAbilityInputPressed");
static_assert(offsetof(HWAbilityTask_WaitCastStyleInput_OnAbilityInputPressed, TimeWaited) == 0x000000, "Member 'HWAbilityTask_WaitCastStyleInput_OnAbilityInputPressed::TimeWaited' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitCastStyleInput.OnAbilityInputReleased
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityTask_WaitCastStyleInput_OnAbilityInputReleased final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitCastStyleInput_OnAbilityInputReleased) == 0x000004, "Wrong alignment on HWAbilityTask_WaitCastStyleInput_OnAbilityInputReleased");
static_assert(sizeof(HWAbilityTask_WaitCastStyleInput_OnAbilityInputReleased) == 0x000004, "Wrong size on HWAbilityTask_WaitCastStyleInput_OnAbilityInputReleased");
static_assert(offsetof(HWAbilityTask_WaitCastStyleInput_OnAbilityInputReleased, TimeHeld) == 0x000000, "Member 'HWAbilityTask_WaitCastStyleInput_OnAbilityInputReleased::TimeHeld' has a wrong offset!");

// Function Hemingway.HWActorComponent.HasAuthority
// 0x0001 (0x0001 - 0x0000)
struct HWActorComponent_HasAuthority final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWActorComponent_HasAuthority) == 0x000001, "Wrong alignment on HWActorComponent_HasAuthority");
static_assert(sizeof(HWActorComponent_HasAuthority) == 0x000001, "Wrong size on HWActorComponent_HasAuthority");
static_assert(offsetof(HWActorComponent_HasAuthority, ReturnValue) == 0x000000, "Member 'HWActorComponent_HasAuthority::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployableDestructionComponent.OnComponentOverlaps
// 0x0108 (0x0108 - 0x0000)
struct HWDeployableDestructionComponent_OnComponentOverlaps final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployableDestructionComponent_OnComponentOverlaps) == 0x000008, "Wrong alignment on HWDeployableDestructionComponent_OnComponentOverlaps");
static_assert(sizeof(HWDeployableDestructionComponent_OnComponentOverlaps) == 0x000108, "Wrong size on HWDeployableDestructionComponent_OnComponentOverlaps");
static_assert(offsetof(HWDeployableDestructionComponent_OnComponentOverlaps, OverlappedComp) == 0x000000, "Member 'HWDeployableDestructionComponent_OnComponentOverlaps::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWDeployableDestructionComponent_OnComponentOverlaps, Other) == 0x000008, "Member 'HWDeployableDestructionComponent_OnComponentOverlaps::Other' has a wrong offset!");
static_assert(offsetof(HWDeployableDestructionComponent_OnComponentOverlaps, OtherComp) == 0x000010, "Member 'HWDeployableDestructionComponent_OnComponentOverlaps::OtherComp' has a wrong offset!");
static_assert(offsetof(HWDeployableDestructionComponent_OnComponentOverlaps, OtherBodyIndex) == 0x000018, "Member 'HWDeployableDestructionComponent_OnComponentOverlaps::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HWDeployableDestructionComponent_OnComponentOverlaps, bFromSweep) == 0x00001C, "Member 'HWDeployableDestructionComponent_OnComponentOverlaps::bFromSweep' has a wrong offset!");
static_assert(offsetof(HWDeployableDestructionComponent_OnComponentOverlaps, SweepResult) == 0x000020, "Member 'HWDeployableDestructionComponent_OnComponentOverlaps::SweepResult' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitForTargeterValidationChange.WaitForTargetDataValidationChange
// 0x0028 (0x0028 - 0x0000)
struct HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackID;                                          // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bListenOnce;                                       // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitForTargeterValidationChange* ReturnValue;                               // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange) == 0x000008, "Wrong alignment on HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange");
static_assert(sizeof(HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange) == 0x000028, "Wrong size on HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange");
static_assert(offsetof(HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange, AttackID) == 0x000010, "Member 'HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange::AttackID' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange, bListenOnce) == 0x000018, "Member 'HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange::bListenOnce' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange, ReturnValue) == 0x000020, "Member 'HWAbilityTask_WaitForTargeterValidationChange_WaitForTargetDataValidationChange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitForTargeterValidationChange.OnTargeterValidationChanged
// 0x0018 (0x0018 - 0x0000)
struct HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged final
{
public:
	class AHWTargeter*                            Targeter;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InAttackId;                                        // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged) == 0x000008, "Wrong alignment on HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged");
static_assert(sizeof(HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged) == 0x000018, "Wrong size on HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged");
static_assert(offsetof(HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged, Targeter) == 0x000000, "Member 'HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged::Targeter' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged, InAttackId) == 0x000008, "Member 'HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged::InAttackId' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged, bValid) == 0x000010, "Member 'HWAbilityTask_WaitForTargeterValidationChange_OnTargeterValidationChanged::bValid' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.AddBlockedAbilityTags
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_AddBlockedAbilityTags final
{
public:
	struct FGameplayTagContainer                  InTags;                                            // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OwningAbilitySystem;                               // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_AddBlockedAbilityTags) == 0x000008, "Wrong alignment on HWGameplayAbility_AddBlockedAbilityTags");
static_assert(sizeof(HWGameplayAbility_AddBlockedAbilityTags) == 0x000028, "Wrong size on HWGameplayAbility_AddBlockedAbilityTags");
static_assert(offsetof(HWGameplayAbility_AddBlockedAbilityTags, InTags) == 0x000000, "Member 'HWGameplayAbility_AddBlockedAbilityTags::InTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_AddBlockedAbilityTags, OwningAbilitySystem) == 0x000020, "Member 'HWGameplayAbility_AddBlockedAbilityTags::OwningAbilitySystem' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.AddDynamicGameplayTagsToAvatar
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_AddDynamicGameplayTagsToAvatar final
{
public:
	struct FGameplayTagContainer                  InTags;                                            // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OwningAbilitySystem;                               // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_AddDynamicGameplayTagsToAvatar) == 0x000008, "Wrong alignment on HWGameplayAbility_AddDynamicGameplayTagsToAvatar");
static_assert(sizeof(HWGameplayAbility_AddDynamicGameplayTagsToAvatar) == 0x000028, "Wrong size on HWGameplayAbility_AddDynamicGameplayTagsToAvatar");
static_assert(offsetof(HWGameplayAbility_AddDynamicGameplayTagsToAvatar, InTags) == 0x000000, "Member 'HWGameplayAbility_AddDynamicGameplayTagsToAvatar::InTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_AddDynamicGameplayTagsToAvatar, OwningAbilitySystem) == 0x000020, "Member 'HWGameplayAbility_AddDynamicGameplayTagsToAvatar::OwningAbilitySystem' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.ApplyGameplayEffectGroupsToSelf
// 0x0038 (0x0038 - 0x0000)
struct HWGameplayAbility_ApplyGameplayEffectGroupsToSelf final
{
public:
	struct FGameplayTagContainer                  EffectGroupTags;                                   // 0x0000(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CurrentAttackId;                                   // 0x0020(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    OutActiveEffectHandles;                            // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_ApplyGameplayEffectGroupsToSelf) == 0x000008, "Wrong alignment on HWGameplayAbility_ApplyGameplayEffectGroupsToSelf");
static_assert(sizeof(HWGameplayAbility_ApplyGameplayEffectGroupsToSelf) == 0x000038, "Wrong size on HWGameplayAbility_ApplyGameplayEffectGroupsToSelf");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupsToSelf, EffectGroupTags) == 0x000000, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupsToSelf::EffectGroupTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupsToSelf, CurrentAttackId) == 0x000020, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupsToSelf::CurrentAttackId' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupsToSelf, OutActiveEffectHandles) == 0x000028, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupsToSelf::OutActiveEffectHandles' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.ApplyGameplayEffectGroupsToTarget
// 0x0060 (0x0060 - 0x0000)
struct HWGameplayAbility_ApplyGameplayEffectGroupsToTarget final
{
public:
	struct FGameplayTagContainer                  EffectGroupTags;                                   // 0x0000(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CurrentAttackId;                                   // 0x0020(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0028(0x0028)(Parm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    OutActiveEffectHandles;                            // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_ApplyGameplayEffectGroupsToTarget) == 0x000008, "Wrong alignment on HWGameplayAbility_ApplyGameplayEffectGroupsToTarget");
static_assert(sizeof(HWGameplayAbility_ApplyGameplayEffectGroupsToTarget) == 0x000060, "Wrong size on HWGameplayAbility_ApplyGameplayEffectGroupsToTarget");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupsToTarget, EffectGroupTags) == 0x000000, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupsToTarget::EffectGroupTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupsToTarget, CurrentAttackId) == 0x000020, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupsToTarget::CurrentAttackId' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupsToTarget, TargetDataHandle) == 0x000028, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupsToTarget::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupsToTarget, OutActiveEffectHandles) == 0x000050, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupsToTarget::OutActiveEffectHandles' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.ApplyGameplayEffectGroupToSelf
// 0x0020 (0x0020 - 0x0000)
struct HWGameplayAbility_ApplyGameplayEffectGroupToSelf final
{
public:
	struct FGameplayTag                           EffectGroupTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CurrentAttackId;                                   // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    OutActiveEffectHandles;                            // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_ApplyGameplayEffectGroupToSelf) == 0x000008, "Wrong alignment on HWGameplayAbility_ApplyGameplayEffectGroupToSelf");
static_assert(sizeof(HWGameplayAbility_ApplyGameplayEffectGroupToSelf) == 0x000020, "Wrong size on HWGameplayAbility_ApplyGameplayEffectGroupToSelf");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupToSelf, EffectGroupTag) == 0x000000, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupToSelf::EffectGroupTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupToSelf, CurrentAttackId) == 0x000008, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupToSelf::CurrentAttackId' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupToSelf, OutActiveEffectHandles) == 0x000010, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupToSelf::OutActiveEffectHandles' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.ApplyGameplayEffectGroupToTarget
// 0x0048 (0x0048 - 0x0000)
struct HWGameplayAbility_ApplyGameplayEffectGroupToTarget final
{
public:
	struct FGameplayTag                           EffectGroupTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CurrentAttackId;                                   // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0010(0x0028)(Parm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    OutActiveEffectHandles;                            // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_ApplyGameplayEffectGroupToTarget) == 0x000008, "Wrong alignment on HWGameplayAbility_ApplyGameplayEffectGroupToTarget");
static_assert(sizeof(HWGameplayAbility_ApplyGameplayEffectGroupToTarget) == 0x000048, "Wrong size on HWGameplayAbility_ApplyGameplayEffectGroupToTarget");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupToTarget, EffectGroupTag) == 0x000000, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupToTarget::EffectGroupTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupToTarget, CurrentAttackId) == 0x000008, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupToTarget::CurrentAttackId' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupToTarget, TargetDataHandle) == 0x000010, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupToTarget::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_ApplyGameplayEffectGroupToTarget, OutActiveEffectHandles) == 0x000038, "Member 'HWGameplayAbility_ApplyGameplayEffectGroupToTarget::OutActiveEffectHandles' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.BP_PostAbilityActivationLogic
// 0x00B0 (0x00B0 - 0x0000)
struct HWGameplayAbility_BP_PostAbilityActivationLogic final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_BP_PostAbilityActivationLogic) == 0x000008, "Wrong alignment on HWGameplayAbility_BP_PostAbilityActivationLogic");
static_assert(sizeof(HWGameplayAbility_BP_PostAbilityActivationLogic) == 0x0000B0, "Wrong size on HWGameplayAbility_BP_PostAbilityActivationLogic");
static_assert(offsetof(HWGameplayAbility_BP_PostAbilityActivationLogic, EventData) == 0x000000, "Member 'HWGameplayAbility_BP_PostAbilityActivationLogic::EventData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.HandleMontagePhaseBehavior
// 0x00C0 (0x00C0 - 0x0000)
struct HWGameplayAbility_HandleMontagePhaseBehavior final
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0008(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EMontagePhaseNotifyEvent                      PhaseEventType;                                    // 0x00B8(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x00BC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_HandleMontagePhaseBehavior) == 0x000008, "Wrong alignment on HWGameplayAbility_HandleMontagePhaseBehavior");
static_assert(sizeof(HWGameplayAbility_HandleMontagePhaseBehavior) == 0x0000C0, "Wrong size on HWGameplayAbility_HandleMontagePhaseBehavior");
static_assert(offsetof(HWGameplayAbility_HandleMontagePhaseBehavior, PhaseTag) == 0x000000, "Member 'HWGameplayAbility_HandleMontagePhaseBehavior::PhaseTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_HandleMontagePhaseBehavior, Payload) == 0x000008, "Member 'HWGameplayAbility_HandleMontagePhaseBehavior::Payload' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_HandleMontagePhaseBehavior, PhaseEventType) == 0x0000B8, "Member 'HWGameplayAbility_HandleMontagePhaseBehavior::PhaseEventType' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_HandleMontagePhaseBehavior, Duration) == 0x0000BC, "Member 'HWGameplayAbility_HandleMontagePhaseBehavior::Duration' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.ProcessAbilitySwappedPersistentState
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_ProcessAbilitySwappedPersistentState final
{
public:
	class FString                                 PreviousState;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_ProcessAbilitySwappedPersistentState) == 0x000008, "Wrong alignment on HWGameplayAbility_ProcessAbilitySwappedPersistentState");
static_assert(sizeof(HWGameplayAbility_ProcessAbilitySwappedPersistentState) == 0x000010, "Wrong size on HWGameplayAbility_ProcessAbilitySwappedPersistentState");
static_assert(offsetof(HWGameplayAbility_ProcessAbilitySwappedPersistentState, PreviousState) == 0x000000, "Member 'HWGameplayAbility_ProcessAbilitySwappedPersistentState::PreviousState' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.RemoveBlockedAbilityTags
// 0x0030 (0x0030 - 0x0000)
struct HWGameplayAbility_RemoveBlockedAbilityTags final
{
public:
	struct FGameplayTagContainer                  InTags;                                            // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         CountToRemove;                                     // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySystemComponent*              OwningAbilitySystem;                               // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_RemoveBlockedAbilityTags) == 0x000008, "Wrong alignment on HWGameplayAbility_RemoveBlockedAbilityTags");
static_assert(sizeof(HWGameplayAbility_RemoveBlockedAbilityTags) == 0x000030, "Wrong size on HWGameplayAbility_RemoveBlockedAbilityTags");
static_assert(offsetof(HWGameplayAbility_RemoveBlockedAbilityTags, InTags) == 0x000000, "Member 'HWGameplayAbility_RemoveBlockedAbilityTags::InTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveBlockedAbilityTags, CountToRemove) == 0x000020, "Member 'HWGameplayAbility_RemoveBlockedAbilityTags::CountToRemove' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveBlockedAbilityTags, OwningAbilitySystem) == 0x000028, "Member 'HWGameplayAbility_RemoveBlockedAbilityTags::OwningAbilitySystem' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.RemoveDynamicGameplayTagsFromAvatar
// 0x0030 (0x0030 - 0x0000)
struct HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar final
{
public:
	struct FGameplayTagContainer                  InTags;                                            // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         CountToRemove;                                     // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySystemComponent*              OwningAbilitySystem;                               // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar) == 0x000008, "Wrong alignment on HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar");
static_assert(sizeof(HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar) == 0x000030, "Wrong size on HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar");
static_assert(offsetof(HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar, InTags) == 0x000000, "Member 'HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar::InTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar, CountToRemove) == 0x000020, "Member 'HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar::CountToRemove' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar, OwningAbilitySystem) == 0x000028, "Member 'HWGameplayAbility_RemoveDynamicGameplayTagsFromAvatar::OwningAbilitySystem' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.RemoveGameplayEffectGroupFromSelf
// 0x0014 (0x0014 - 0x0000)
struct HWGameplayAbility_RemoveGameplayEffectGroupFromSelf final
{
public:
	struct FGameplayTag                           EffectGroupTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackID;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_RemoveGameplayEffectGroupFromSelf) == 0x000004, "Wrong alignment on HWGameplayAbility_RemoveGameplayEffectGroupFromSelf");
static_assert(sizeof(HWGameplayAbility_RemoveGameplayEffectGroupFromSelf) == 0x000014, "Wrong size on HWGameplayAbility_RemoveGameplayEffectGroupFromSelf");
static_assert(offsetof(HWGameplayAbility_RemoveGameplayEffectGroupFromSelf, EffectGroupTag) == 0x000000, "Member 'HWGameplayAbility_RemoveGameplayEffectGroupFromSelf::EffectGroupTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveGameplayEffectGroupFromSelf, AttackID) == 0x000008, "Member 'HWGameplayAbility_RemoveGameplayEffectGroupFromSelf::AttackID' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveGameplayEffectGroupFromSelf, ReturnValue) == 0x000010, "Member 'HWGameplayAbility_RemoveGameplayEffectGroupFromSelf::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.RemoveGameplayEffectGroupsFromSelf
// 0x0030 (0x0030 - 0x0000)
struct HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf final
{
public:
	struct FGameplayTagContainer                  EffectGroupTags;                                   // 0x0000(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackID;                                          // 0x0020(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf) == 0x000008, "Wrong alignment on HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf");
static_assert(sizeof(HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf) == 0x000030, "Wrong size on HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf");
static_assert(offsetof(HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf, EffectGroupTags) == 0x000000, "Member 'HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf::EffectGroupTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf, AttackID) == 0x000020, "Member 'HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf::AttackID' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf, ReturnValue) == 0x000028, "Member 'HWGameplayAbility_RemoveGameplayEffectGroupsFromSelf::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.RemoveGameplayEffectGroupsFromTarget
// 0x0058 (0x0058 - 0x0000)
struct HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget final
{
public:
	struct FGameplayTagContainer                  EffectGroupTags;                                   // 0x0000(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0020(0x0028)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackID;                                          // 0x0048(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget) == 0x000008, "Wrong alignment on HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget");
static_assert(sizeof(HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget) == 0x000058, "Wrong size on HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget");
static_assert(offsetof(HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget, EffectGroupTags) == 0x000000, "Member 'HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget::EffectGroupTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget, TargetDataHandle) == 0x000020, "Member 'HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget, AttackID) == 0x000048, "Member 'HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget::AttackID' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget, ReturnValue) == 0x000050, "Member 'HWGameplayAbility_RemoveGameplayEffectGroupsFromTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.BP_CheckCost
// 0x0078 (0x0078 - 0x0000)
struct HWGameplayAbility_BP_CheckCost final
{
public:
	struct FGameplayAbilitySpecHandle             Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OptionalRelevantTags;                              // 0x0050(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bCanConsumeCosts;                                  // 0x0070(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0071(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_BP_CheckCost) == 0x000008, "Wrong alignment on HWGameplayAbility_BP_CheckCost");
static_assert(sizeof(HWGameplayAbility_BP_CheckCost) == 0x000078, "Wrong size on HWGameplayAbility_BP_CheckCost");
static_assert(offsetof(HWGameplayAbility_BP_CheckCost, Handle) == 0x000000, "Member 'HWGameplayAbility_BP_CheckCost::Handle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_BP_CheckCost, ActorInfo) == 0x000008, "Member 'HWGameplayAbility_BP_CheckCost::ActorInfo' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_BP_CheckCost, OptionalRelevantTags) == 0x000050, "Member 'HWGameplayAbility_BP_CheckCost::OptionalRelevantTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_BP_CheckCost, bCanConsumeCosts) == 0x000070, "Member 'HWGameplayAbility_BP_CheckCost::bCanConsumeCosts' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_BP_CheckCost, ReturnValue) == 0x000071, "Member 'HWGameplayAbility_BP_CheckCost::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.BP_GetCooldownTags
// 0x0020 (0x0020 - 0x0000)
struct HWGameplayAbility_BP_GetCooldownTags final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_BP_GetCooldownTags) == 0x000008, "Wrong alignment on HWGameplayAbility_BP_GetCooldownTags");
static_assert(sizeof(HWGameplayAbility_BP_GetCooldownTags) == 0x000020, "Wrong size on HWGameplayAbility_BP_GetCooldownTags");
static_assert(offsetof(HWGameplayAbility_BP_GetCooldownTags, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_BP_GetCooldownTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.BP_GetCooldownTimeRemainingAndDuration
// 0x0050 (0x0050 - 0x0000)
struct HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration final
{
public:
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         OutTimeRemaining;                                  // 0x0048(0x0004)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutDuration;                                       // 0x004C(0x0004)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration) == 0x000008, "Wrong alignment on HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration");
static_assert(sizeof(HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration) == 0x000050, "Wrong size on HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration");
static_assert(offsetof(HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration, ActorInfo) == 0x000000, "Member 'HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration::ActorInfo' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration, OutTimeRemaining) == 0x000048, "Member 'HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration::OutTimeRemaining' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration, OutDuration) == 0x00004C, "Member 'HWGameplayAbility_BP_GetCooldownTimeRemainingAndDuration::OutDuration' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.BP_IsActive
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_BP_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_BP_IsActive) == 0x000001, "Wrong alignment on HWGameplayAbility_BP_IsActive");
static_assert(sizeof(HWGameplayAbility_BP_IsActive) == 0x000001, "Wrong size on HWGameplayAbility_BP_IsActive");
static_assert(offsetof(HWGameplayAbility_BP_IsActive, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_BP_IsActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.BP_IsForRemoteClient
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_BP_IsForRemoteClient final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_BP_IsForRemoteClient) == 0x000001, "Wrong alignment on HWGameplayAbility_BP_IsForRemoteClient");
static_assert(sizeof(HWGameplayAbility_BP_IsForRemoteClient) == 0x000001, "Wrong size on HWGameplayAbility_BP_IsForRemoteClient");
static_assert(offsetof(HWGameplayAbility_BP_IsForRemoteClient, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_BP_IsForRemoteClient::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.BP_IsPredictingClient
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_BP_IsPredictingClient final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_BP_IsPredictingClient) == 0x000001, "Wrong alignment on HWGameplayAbility_BP_IsPredictingClient");
static_assert(sizeof(HWGameplayAbility_BP_IsPredictingClient) == 0x000001, "Wrong size on HWGameplayAbility_BP_IsPredictingClient");
static_assert(offsetof(HWGameplayAbility_BP_IsPredictingClient, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_BP_IsPredictingClient::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.BP_MakeEffectContext
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_BP_MakeEffectContext final
{
public:
	struct FGameplayEffectContextHandle           ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_BP_MakeEffectContext) == 0x000008, "Wrong alignment on HWGameplayAbility_BP_MakeEffectContext");
static_assert(sizeof(HWGameplayAbility_BP_MakeEffectContext) == 0x000018, "Wrong size on HWGameplayAbility_BP_MakeEffectContext");
static_assert(offsetof(HWGameplayAbility_BP_MakeEffectContext, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_BP_MakeEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.BP_MakeEffectContext_FromGrantedEffect
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_BP_MakeEffectContext_FromGrantedEffect final
{
public:
	struct FGameplayEffectContextHandle           ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_BP_MakeEffectContext_FromGrantedEffect) == 0x000008, "Wrong alignment on HWGameplayAbility_BP_MakeEffectContext_FromGrantedEffect");
static_assert(sizeof(HWGameplayAbility_BP_MakeEffectContext_FromGrantedEffect) == 0x000018, "Wrong size on HWGameplayAbility_BP_MakeEffectContext_FromGrantedEffect");
static_assert(offsetof(HWGameplayAbility_BP_MakeEffectContext_FromGrantedEffect, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_BP_MakeEffectContext_FromGrantedEffect::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.CanAbilityBeUseAtLevel
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_CanAbilityBeUseAtLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_CanAbilityBeUseAtLevel) == 0x000004, "Wrong alignment on HWGameplayAbility_CanAbilityBeUseAtLevel");
static_assert(sizeof(HWGameplayAbility_CanAbilityBeUseAtLevel) == 0x000008, "Wrong size on HWGameplayAbility_CanAbilityBeUseAtLevel");
static_assert(offsetof(HWGameplayAbility_CanAbilityBeUseAtLevel, Level) == 0x000000, "Member 'HWGameplayAbility_CanAbilityBeUseAtLevel::Level' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_CanAbilityBeUseAtLevel, ReturnValue) == 0x000004, "Member 'HWGameplayAbility_CanAbilityBeUseAtLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.CanAbilityLevelUp
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_CanAbilityLevelUp final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySystemComponent*              OwningASC;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_CanAbilityLevelUp) == 0x000008, "Wrong alignment on HWGameplayAbility_CanAbilityLevelUp");
static_assert(sizeof(HWGameplayAbility_CanAbilityLevelUp) == 0x000018, "Wrong size on HWGameplayAbility_CanAbilityLevelUp");
static_assert(offsetof(HWGameplayAbility_CanAbilityLevelUp, AbilityHandle) == 0x000000, "Member 'HWGameplayAbility_CanAbilityLevelUp::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_CanAbilityLevelUp, OwningASC) == 0x000008, "Member 'HWGameplayAbility_CanAbilityLevelUp::OwningASC' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_CanAbilityLevelUp, ReturnValue) == 0x000010, "Member 'HWGameplayAbility_CanAbilityLevelUp::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.CanConfirmTargeting
// 0x0030 (0x0030 - 0x0000)
struct HWGameplayAbility_CanConfirmTargeting final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetingData;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTargetingExpiring;                                // 0x0028(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0029(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_CanConfirmTargeting) == 0x000008, "Wrong alignment on HWGameplayAbility_CanConfirmTargeting");
static_assert(sizeof(HWGameplayAbility_CanConfirmTargeting) == 0x000030, "Wrong size on HWGameplayAbility_CanConfirmTargeting");
static_assert(offsetof(HWGameplayAbility_CanConfirmTargeting, TargetingData) == 0x000000, "Member 'HWGameplayAbility_CanConfirmTargeting::TargetingData' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_CanConfirmTargeting, bTargetingExpiring) == 0x000028, "Member 'HWGameplayAbility_CanConfirmTargeting::bTargetingExpiring' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_CanConfirmTargeting, ReturnValue) == 0x000029, "Member 'HWGameplayAbility_CanConfirmTargeting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.CanHighlightTargets
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_CanHighlightTargets final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_CanHighlightTargets) == 0x000001, "Wrong alignment on HWGameplayAbility_CanHighlightTargets");
static_assert(sizeof(HWGameplayAbility_CanHighlightTargets) == 0x000001, "Wrong size on HWGameplayAbility_CanHighlightTargets");
static_assert(offsetof(HWGameplayAbility_CanHighlightTargets, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_CanHighlightTargets::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.CanSetAbilityLevelTo
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_CanSetAbilityLevelTo final
{
public:
	int32                                         DesiredLevel;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0004(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OwningASC;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_CanSetAbilityLevelTo) == 0x000008, "Wrong alignment on HWGameplayAbility_CanSetAbilityLevelTo");
static_assert(sizeof(HWGameplayAbility_CanSetAbilityLevelTo) == 0x000018, "Wrong size on HWGameplayAbility_CanSetAbilityLevelTo");
static_assert(offsetof(HWGameplayAbility_CanSetAbilityLevelTo, DesiredLevel) == 0x000000, "Member 'HWGameplayAbility_CanSetAbilityLevelTo::DesiredLevel' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_CanSetAbilityLevelTo, AbilityHandle) == 0x000004, "Member 'HWGameplayAbility_CanSetAbilityLevelTo::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_CanSetAbilityLevelTo, OwningASC) == 0x000008, "Member 'HWGameplayAbility_CanSetAbilityLevelTo::OwningASC' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_CanSetAbilityLevelTo, ReturnValue) == 0x000010, "Member 'HWGameplayAbility_CanSetAbilityLevelTo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetAbilityHandleFromAvatarBySlot
// 0x0014 (0x0014 - 0x0000)
struct HWGameplayAbility_GetAbilityHandleFromAvatarBySlot final
{
public:
	struct FHWInventorySlot                       Slot;                                              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             outHandle;                                         // 0x000C(0x0004)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_GetAbilityHandleFromAvatarBySlot) == 0x000004, "Wrong alignment on HWGameplayAbility_GetAbilityHandleFromAvatarBySlot");
static_assert(sizeof(HWGameplayAbility_GetAbilityHandleFromAvatarBySlot) == 0x000014, "Wrong size on HWGameplayAbility_GetAbilityHandleFromAvatarBySlot");
static_assert(offsetof(HWGameplayAbility_GetAbilityHandleFromAvatarBySlot, Slot) == 0x000000, "Member 'HWGameplayAbility_GetAbilityHandleFromAvatarBySlot::Slot' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_GetAbilityHandleFromAvatarBySlot, outHandle) == 0x00000C, "Member 'HWGameplayAbility_GetAbilityHandleFromAvatarBySlot::outHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_GetAbilityHandleFromAvatarBySlot, ReturnValue) == 0x000010, "Member 'HWGameplayAbility_GetAbilityHandleFromAvatarBySlot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetAbilityId
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_GetAbilityId final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetAbilityId) == 0x000004, "Wrong alignment on HWGameplayAbility_GetAbilityId");
static_assert(sizeof(HWGameplayAbility_GetAbilityId) == 0x000008, "Wrong size on HWGameplayAbility_GetAbilityId");
static_assert(offsetof(HWGameplayAbility_GetAbilityId, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetAbilityId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetAbilityLevelAsFloat
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayAbility_GetAbilityLevelAsFloat final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetAbilityLevelAsFloat) == 0x000004, "Wrong alignment on HWGameplayAbility_GetAbilityLevelAsFloat");
static_assert(sizeof(HWGameplayAbility_GetAbilityLevelAsFloat) == 0x000004, "Wrong size on HWGameplayAbility_GetAbilityLevelAsFloat");
static_assert(offsetof(HWGameplayAbility_GetAbilityLevelAsFloat, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetAbilityLevelAsFloat::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetAbilityLevelFromAvatarBySlot
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_GetAbilityLevelFromAvatarBySlot final
{
public:
	struct FHWInventorySlot                       Slot;                                              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetAbilityLevelFromAvatarBySlot) == 0x000004, "Wrong alignment on HWGameplayAbility_GetAbilityLevelFromAvatarBySlot");
static_assert(sizeof(HWGameplayAbility_GetAbilityLevelFromAvatarBySlot) == 0x000010, "Wrong size on HWGameplayAbility_GetAbilityLevelFromAvatarBySlot");
static_assert(offsetof(HWGameplayAbility_GetAbilityLevelFromAvatarBySlot, Slot) == 0x000000, "Member 'HWGameplayAbility_GetAbilityLevelFromAvatarBySlot::Slot' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_GetAbilityLevelFromAvatarBySlot, ReturnValue) == 0x00000C, "Member 'HWGameplayAbility_GetAbilityLevelFromAvatarBySlot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetAbilitySwappedPersistentState
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_GetAbilitySwappedPersistentState final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetAbilitySwappedPersistentState) == 0x000008, "Wrong alignment on HWGameplayAbility_GetAbilitySwappedPersistentState");
static_assert(sizeof(HWGameplayAbility_GetAbilitySwappedPersistentState) == 0x000010, "Wrong size on HWGameplayAbility_GetAbilitySwappedPersistentState");
static_assert(offsetof(HWGameplayAbility_GetAbilitySwappedPersistentState, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetAbilitySwappedPersistentState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetAllActivationBlockedTags
// 0x0070 (0x0070 - 0x0000)
struct HWGameplayAbility_GetAllActivationBlockedTags final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0050(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetAllActivationBlockedTags) == 0x000008, "Wrong alignment on HWGameplayAbility_GetAllActivationBlockedTags");
static_assert(sizeof(HWGameplayAbility_GetAllActivationBlockedTags) == 0x000070, "Wrong size on HWGameplayAbility_GetAllActivationBlockedTags");
static_assert(offsetof(HWGameplayAbility_GetAllActivationBlockedTags, AbilityHandle) == 0x000000, "Member 'HWGameplayAbility_GetAllActivationBlockedTags::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_GetAllActivationBlockedTags, ActorInfo) == 0x000008, "Member 'HWGameplayAbility_GetAllActivationBlockedTags::ActorInfo' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_GetAllActivationBlockedTags, ReturnValue) == 0x000050, "Member 'HWGameplayAbility_GetAllActivationBlockedTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetAllCancelTags
// 0x0070 (0x0070 - 0x0000)
struct HWGameplayAbility_GetAllCancelTags final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActorInfo              ActorInfo;                                         // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0050(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetAllCancelTags) == 0x000008, "Wrong alignment on HWGameplayAbility_GetAllCancelTags");
static_assert(sizeof(HWGameplayAbility_GetAllCancelTags) == 0x000070, "Wrong size on HWGameplayAbility_GetAllCancelTags");
static_assert(offsetof(HWGameplayAbility_GetAllCancelTags, AbilityHandle) == 0x000000, "Member 'HWGameplayAbility_GetAllCancelTags::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_GetAllCancelTags, ActorInfo) == 0x000008, "Member 'HWGameplayAbility_GetAllCancelTags::ActorInfo' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_GetAllCancelTags, ReturnValue) == 0x000050, "Member 'HWGameplayAbility_GetAllCancelTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetCachedAITarget
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_GetCachedAITarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetCachedAITarget) == 0x000008, "Wrong alignment on HWGameplayAbility_GetCachedAITarget");
static_assert(sizeof(HWGameplayAbility_GetCachedAITarget) == 0x000008, "Wrong size on HWGameplayAbility_GetCachedAITarget");
static_assert(offsetof(HWGameplayAbility_GetCachedAITarget, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetCachedAITarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetCharacterAvatarFromActorInfo
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_GetCharacterAvatarFromActorInfo final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetCharacterAvatarFromActorInfo) == 0x000008, "Wrong alignment on HWGameplayAbility_GetCharacterAvatarFromActorInfo");
static_assert(sizeof(HWGameplayAbility_GetCharacterAvatarFromActorInfo) == 0x000008, "Wrong size on HWGameplayAbility_GetCharacterAvatarFromActorInfo");
static_assert(offsetof(HWGameplayAbility_GetCharacterAvatarFromActorInfo, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetCharacterAvatarFromActorInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetCurrentFiringInstanceId
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_GetCurrentFiringInstanceId final
{
public:
	struct FHWAbilityFiringInstanceId             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetCurrentFiringInstanceId) == 0x000004, "Wrong alignment on HWGameplayAbility_GetCurrentFiringInstanceId");
static_assert(sizeof(HWGameplayAbility_GetCurrentFiringInstanceId) == 0x000008, "Wrong size on HWGameplayAbility_GetCurrentFiringInstanceId");
static_assert(offsetof(HWGameplayAbility_GetCurrentFiringInstanceId, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetCurrentFiringInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetCurrentLevelConfig
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_GetCurrentLevelConfig final
{
public:
	const class UHWAbilityLevelConfig*            ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetCurrentLevelConfig) == 0x000008, "Wrong alignment on HWGameplayAbility_GetCurrentLevelConfig");
static_assert(sizeof(HWGameplayAbility_GetCurrentLevelConfig) == 0x000008, "Wrong size on HWGameplayAbility_GetCurrentLevelConfig");
static_assert(offsetof(HWGameplayAbility_GetCurrentLevelConfig, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetCurrentLevelConfig::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetEquipmentComponentByClass
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_GetEquipmentComponentByClass final
{
public:
	TSubclassOf<class UHWEquipmentComponent>      ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ID;                                                // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWEquipmentComponent*                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetEquipmentComponentByClass) == 0x000008, "Wrong alignment on HWGameplayAbility_GetEquipmentComponentByClass");
static_assert(sizeof(HWGameplayAbility_GetEquipmentComponentByClass) == 0x000018, "Wrong size on HWGameplayAbility_GetEquipmentComponentByClass");
static_assert(offsetof(HWGameplayAbility_GetEquipmentComponentByClass, ComponentClass) == 0x000000, "Member 'HWGameplayAbility_GetEquipmentComponentByClass::ComponentClass' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_GetEquipmentComponentByClass, ID) == 0x000008, "Member 'HWGameplayAbility_GetEquipmentComponentByClass::ID' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_GetEquipmentComponentByClass, ReturnValue) == 0x000010, "Member 'HWGameplayAbility_GetEquipmentComponentByClass::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetEquipmentInstance
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_GetEquipmentInstance final
{
public:
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetEquipmentInstance) == 0x000008, "Wrong alignment on HWGameplayAbility_GetEquipmentInstance");
static_assert(sizeof(HWGameplayAbility_GetEquipmentInstance) == 0x000008, "Wrong size on HWGameplayAbility_GetEquipmentInstance");
static_assert(offsetof(HWGameplayAbility_GetEquipmentInstance, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetEquipmentInstance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetEquipmentItem
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_GetEquipmentItem final
{
public:
	const class UHWEquipmentItem*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetEquipmentItem) == 0x000008, "Wrong alignment on HWGameplayAbility_GetEquipmentItem");
static_assert(sizeof(HWGameplayAbility_GetEquipmentItem) == 0x000008, "Wrong size on HWGameplayAbility_GetEquipmentItem");
static_assert(offsetof(HWGameplayAbility_GetEquipmentItem, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetEquipmentItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetGrantedByActiveGameplayEffectHandle
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_GetGrantedByActiveGameplayEffectHandle final
{
public:
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetGrantedByActiveGameplayEffectHandle) == 0x000004, "Wrong alignment on HWGameplayAbility_GetGrantedByActiveGameplayEffectHandle");
static_assert(sizeof(HWGameplayAbility_GetGrantedByActiveGameplayEffectHandle) == 0x000008, "Wrong size on HWGameplayAbility_GetGrantedByActiveGameplayEffectHandle");
static_assert(offsetof(HWGameplayAbility_GetGrantedByActiveGameplayEffectHandle, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetGrantedByActiveGameplayEffectHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetHWAbilitySystemComponentFromActorInfo
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_GetHWAbilitySystemComponentFromActorInfo final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetHWAbilitySystemComponentFromActorInfo) == 0x000008, "Wrong alignment on HWGameplayAbility_GetHWAbilitySystemComponentFromActorInfo");
static_assert(sizeof(HWGameplayAbility_GetHWAbilitySystemComponentFromActorInfo) == 0x000008, "Wrong size on HWGameplayAbility_GetHWAbilitySystemComponentFromActorInfo");
static_assert(offsetof(HWGameplayAbility_GetHWAbilitySystemComponentFromActorInfo, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetHWAbilitySystemComponentFromActorInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetInventoryManagerFromActorInfo
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_GetInventoryManagerFromActorInfo final
{
public:
	class UHWInventoryManagerComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetInventoryManagerFromActorInfo) == 0x000008, "Wrong alignment on HWGameplayAbility_GetInventoryManagerFromActorInfo");
static_assert(sizeof(HWGameplayAbility_GetInventoryManagerFromActorInfo) == 0x000008, "Wrong size on HWGameplayAbility_GetInventoryManagerFromActorInfo");
static_assert(offsetof(HWGameplayAbility_GetInventoryManagerFromActorInfo, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetInventoryManagerFromActorInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetLevelConfig
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_GetLevelConfig final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWAbilityLevelConfig*            ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetLevelConfig) == 0x000008, "Wrong alignment on HWGameplayAbility_GetLevelConfig");
static_assert(sizeof(HWGameplayAbility_GetLevelConfig) == 0x000010, "Wrong size on HWGameplayAbility_GetLevelConfig");
static_assert(offsetof(HWGameplayAbility_GetLevelConfig, Level) == 0x000000, "Member 'HWGameplayAbility_GetLevelConfig::Level' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_GetLevelConfig, ReturnValue) == 0x000008, "Member 'HWGameplayAbility_GetLevelConfig::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetMaxLevel
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayAbility_GetMaxLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetMaxLevel) == 0x000004, "Wrong alignment on HWGameplayAbility_GetMaxLevel");
static_assert(sizeof(HWGameplayAbility_GetMaxLevel) == 0x000004, "Wrong size on HWGameplayAbility_GetMaxLevel");
static_assert(offsetof(HWGameplayAbility_GetMaxLevel, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetMaxLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.GetTargetsHitArray
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_GetTargetsHitArray final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_GetTargetsHitArray) == 0x000008, "Wrong alignment on HWGameplayAbility_GetTargetsHitArray");
static_assert(sizeof(HWGameplayAbility_GetTargetsHitArray) == 0x000010, "Wrong size on HWGameplayAbility_GetTargetsHitArray");
static_assert(offsetof(HWGameplayAbility_GetTargetsHitArray, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_GetTargetsHitArray::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.IsAbilityEnding
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_IsAbilityEnding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_IsAbilityEnding) == 0x000001, "Wrong alignment on HWGameplayAbility_IsAbilityEnding");
static_assert(sizeof(HWGameplayAbility_IsAbilityEnding) == 0x000001, "Wrong size on HWGameplayAbility_IsAbilityEnding");
static_assert(offsetof(HWGameplayAbility_IsAbilityEnding, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_IsAbilityEnding::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.IsAChannelingAbility
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_IsAChannelingAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_IsAChannelingAbility) == 0x000001, "Wrong alignment on HWGameplayAbility_IsAChannelingAbility");
static_assert(sizeof(HWGameplayAbility_IsAChannelingAbility) == 0x000001, "Wrong size on HWGameplayAbility_IsAChannelingAbility");
static_assert(offsetof(HWGameplayAbility_IsAChannelingAbility, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_IsAChannelingAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.IsAvatarAIControlled
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_IsAvatarAIControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_IsAvatarAIControlled) == 0x000001, "Wrong alignment on HWGameplayAbility_IsAvatarAIControlled");
static_assert(sizeof(HWGameplayAbility_IsAvatarAIControlled) == 0x000001, "Wrong size on HWGameplayAbility_IsAvatarAIControlled");
static_assert(offsetof(HWGameplayAbility_IsAvatarAIControlled, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_IsAvatarAIControlled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.IsChanneling
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_IsChanneling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_IsChanneling) == 0x000001, "Wrong alignment on HWGameplayAbility_IsChanneling");
static_assert(sizeof(HWGameplayAbility_IsChanneling) == 0x000001, "Wrong size on HWGameplayAbility_IsChanneling");
static_assert(offsetof(HWGameplayAbility_IsChanneling, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_IsChanneling::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.IsOwnerNetAuthority
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_IsOwnerNetAuthority final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_IsOwnerNetAuthority) == 0x000001, "Wrong alignment on HWGameplayAbility_IsOwnerNetAuthority");
static_assert(sizeof(HWGameplayAbility_IsOwnerNetAuthority) == 0x000001, "Wrong size on HWGameplayAbility_IsOwnerNetAuthority");
static_assert(offsetof(HWGameplayAbility_IsOwnerNetAuthority, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_IsOwnerNetAuthority::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.IsPlayingMontage
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_IsPlayingMontage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_IsPlayingMontage) == 0x000001, "Wrong alignment on HWGameplayAbility_IsPlayingMontage");
static_assert(sizeof(HWGameplayAbility_IsPlayingMontage) == 0x000001, "Wrong size on HWGameplayAbility_IsPlayingMontage");
static_assert(offsetof(HWGameplayAbility_IsPlayingMontage, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_IsPlayingMontage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.IsPredictingOrStandaloneClient
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_IsPredictingOrStandaloneClient final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_IsPredictingOrStandaloneClient) == 0x000001, "Wrong alignment on HWGameplayAbility_IsPredictingOrStandaloneClient");
static_assert(sizeof(HWGameplayAbility_IsPredictingOrStandaloneClient) == 0x000001, "Wrong size on HWGameplayAbility_IsPredictingOrStandaloneClient");
static_assert(offsetof(HWGameplayAbility_IsPredictingOrStandaloneClient, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_IsPredictingOrStandaloneClient::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.IsRunningOnDedicatedServer
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_IsRunningOnDedicatedServer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_IsRunningOnDedicatedServer) == 0x000001, "Wrong alignment on HWGameplayAbility_IsRunningOnDedicatedServer");
static_assert(sizeof(HWGameplayAbility_IsRunningOnDedicatedServer) == 0x000001, "Wrong size on HWGameplayAbility_IsRunningOnDedicatedServer");
static_assert(offsetof(HWGameplayAbility_IsRunningOnDedicatedServer, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_IsRunningOnDedicatedServer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.IsRunningOnStandalone
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_IsRunningOnStandalone final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_IsRunningOnStandalone) == 0x000001, "Wrong alignment on HWGameplayAbility_IsRunningOnStandalone");
static_assert(sizeof(HWGameplayAbility_IsRunningOnStandalone) == 0x000001, "Wrong size on HWGameplayAbility_IsRunningOnStandalone");
static_assert(offsetof(HWGameplayAbility_IsRunningOnStandalone, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_IsRunningOnStandalone::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.ShouldCancelAbilityOnLevelUp
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_ShouldCancelAbilityOnLevelUp final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_ShouldCancelAbilityOnLevelUp) == 0x000001, "Wrong alignment on HWGameplayAbility_ShouldCancelAbilityOnLevelUp");
static_assert(sizeof(HWGameplayAbility_ShouldCancelAbilityOnLevelUp) == 0x000001, "Wrong size on HWGameplayAbility_ShouldCancelAbilityOnLevelUp");
static_assert(offsetof(HWGameplayAbility_ShouldCancelAbilityOnLevelUp, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_ShouldCancelAbilityOnLevelUp::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility.ShouldIncrementFiringInstanceId
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_ShouldIncrementFiringInstanceId final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_ShouldIncrementFiringInstanceId) == 0x000001, "Wrong alignment on HWGameplayAbility_ShouldIncrementFiringInstanceId");
static_assert(sizeof(HWGameplayAbility_ShouldIncrementFiringInstanceId) == 0x000001, "Wrong size on HWGameplayAbility_ShouldIncrementFiringInstanceId");
static_assert(offsetof(HWGameplayAbility_ShouldIncrementFiringInstanceId, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_ShouldIncrementFiringInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.BP_OnBlackboardTargetChange
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_NPC_BP_OnBlackboardTargetChange final
{
public:
	const class UBlackboardComponent*             Blackboard;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_BP_OnBlackboardTargetChange) == 0x000008, "Wrong alignment on HWCharacter_NPC_BP_OnBlackboardTargetChange");
static_assert(sizeof(HWCharacter_NPC_BP_OnBlackboardTargetChange) == 0x000008, "Wrong size on HWCharacter_NPC_BP_OnBlackboardTargetChange");
static_assert(offsetof(HWCharacter_NPC_BP_OnBlackboardTargetChange, Blackboard) == 0x000000, "Member 'HWCharacter_NPC_BP_OnBlackboardTargetChange::Blackboard' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.EnterHibernation
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_NPC_EnterHibernation final
{
public:
	float                                         tickRate;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_EnterHibernation) == 0x000004, "Wrong alignment on HWCharacter_NPC_EnterHibernation");
static_assert(sizeof(HWCharacter_NPC_EnterHibernation) == 0x000004, "Wrong size on HWCharacter_NPC_EnterHibernation");
static_assert(offsetof(HWCharacter_NPC_EnterHibernation, tickRate) == 0x000000, "Member 'HWCharacter_NPC_EnterHibernation::tickRate' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.ProcessPotentialTargetList
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_NPC_ProcessPotentialTargetList final
{
public:
	TArray<class AHWCharacter_Base*>              PotentialTargetList;                               // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_ProcessPotentialTargetList) == 0x000008, "Wrong alignment on HWCharacter_NPC_ProcessPotentialTargetList");
static_assert(sizeof(HWCharacter_NPC_ProcessPotentialTargetList) == 0x000010, "Wrong size on HWCharacter_NPC_ProcessPotentialTargetList");
static_assert(offsetof(HWCharacter_NPC_ProcessPotentialTargetList, PotentialTargetList) == 0x000000, "Member 'HWCharacter_NPC_ProcessPotentialTargetList::PotentialTargetList' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.SetCanCatchUpToSquad
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NPC_SetCanCatchUpToSquad final
{
public:
	bool                                          bCanCatchUp;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_SetCanCatchUpToSquad) == 0x000001, "Wrong alignment on HWCharacter_NPC_SetCanCatchUpToSquad");
static_assert(sizeof(HWCharacter_NPC_SetCanCatchUpToSquad) == 0x000001, "Wrong size on HWCharacter_NPC_SetCanCatchUpToSquad");
static_assert(offsetof(HWCharacter_NPC_SetCanCatchUpToSquad, bCanCatchUp) == 0x000000, "Member 'HWCharacter_NPC_SetCanCatchUpToSquad::bCanCatchUp' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.SetIsBehindSquad
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NPC_SetIsBehindSquad final
{
public:
	bool                                          bIsBehind;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_SetIsBehindSquad) == 0x000001, "Wrong alignment on HWCharacter_NPC_SetIsBehindSquad");
static_assert(sizeof(HWCharacter_NPC_SetIsBehindSquad) == 0x000001, "Wrong size on HWCharacter_NPC_SetIsBehindSquad");
static_assert(offsetof(HWCharacter_NPC_SetIsBehindSquad, bIsBehind) == 0x000000, "Member 'HWCharacter_NPC_SetIsBehindSquad::bIsBehind' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.SetSpreadLocation
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_NPC_SetSpreadLocation final
{
public:
	struct FVector                                InSpreadLocation;                                  // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_SetSpreadLocation) == 0x000008, "Wrong alignment on HWCharacter_NPC_SetSpreadLocation");
static_assert(sizeof(HWCharacter_NPC_SetSpreadLocation) == 0x000018, "Wrong size on HWCharacter_NPC_SetSpreadLocation");
static_assert(offsetof(HWCharacter_NPC_SetSpreadLocation, InSpreadLocation) == 0x000000, "Member 'HWCharacter_NPC_SetSpreadLocation::InSpreadLocation' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.ToggleAntiSquadmateIntersection
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NPC_ToggleAntiSquadmateIntersection final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_ToggleAntiSquadmateIntersection) == 0x000001, "Wrong alignment on HWCharacter_NPC_ToggleAntiSquadmateIntersection");
static_assert(sizeof(HWCharacter_NPC_ToggleAntiSquadmateIntersection) == 0x000001, "Wrong size on HWCharacter_NPC_ToggleAntiSquadmateIntersection");
static_assert(offsetof(HWCharacter_NPC_ToggleAntiSquadmateIntersection, bOn) == 0x000000, "Member 'HWCharacter_NPC_ToggleAntiSquadmateIntersection::bOn' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.CanCatchUpToSquad
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NPC_CanCatchUpToSquad final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_CanCatchUpToSquad) == 0x000001, "Wrong alignment on HWCharacter_NPC_CanCatchUpToSquad");
static_assert(sizeof(HWCharacter_NPC_CanCatchUpToSquad) == 0x000001, "Wrong size on HWCharacter_NPC_CanCatchUpToSquad");
static_assert(offsetof(HWCharacter_NPC_CanCatchUpToSquad, ReturnValue) == 0x000000, "Member 'HWCharacter_NPC_CanCatchUpToSquad::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.CanPerformSquadTactics
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NPC_CanPerformSquadTactics final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_CanPerformSquadTactics) == 0x000001, "Wrong alignment on HWCharacter_NPC_CanPerformSquadTactics");
static_assert(sizeof(HWCharacter_NPC_CanPerformSquadTactics) == 0x000001, "Wrong size on HWCharacter_NPC_CanPerformSquadTactics");
static_assert(offsetof(HWCharacter_NPC_CanPerformSquadTactics, ReturnValue) == 0x000000, "Member 'HWCharacter_NPC_CanPerformSquadTactics::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.CanSpreadOut
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NPC_CanSpreadOut final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_CanSpreadOut) == 0x000001, "Wrong alignment on HWCharacter_NPC_CanSpreadOut");
static_assert(sizeof(HWCharacter_NPC_CanSpreadOut) == 0x000001, "Wrong size on HWCharacter_NPC_CanSpreadOut");
static_assert(offsetof(HWCharacter_NPC_CanSpreadOut, ReturnValue) == 0x000000, "Member 'HWCharacter_NPC_CanSpreadOut::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.GetSpreadLocation
// 0x0018 (0x0018 - 0x0000)
struct HWCharacter_NPC_GetSpreadLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_GetSpreadLocation) == 0x000008, "Wrong alignment on HWCharacter_NPC_GetSpreadLocation");
static_assert(sizeof(HWCharacter_NPC_GetSpreadLocation) == 0x000018, "Wrong size on HWCharacter_NPC_GetSpreadLocation");
static_assert(offsetof(HWCharacter_NPC_GetSpreadLocation, ReturnValue) == 0x000000, "Member 'HWCharacter_NPC_GetSpreadLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.HasSpreadLocation
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NPC_HasSpreadLocation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_HasSpreadLocation) == 0x000001, "Wrong alignment on HWCharacter_NPC_HasSpreadLocation");
static_assert(sizeof(HWCharacter_NPC_HasSpreadLocation) == 0x000001, "Wrong size on HWCharacter_NPC_HasSpreadLocation");
static_assert(offsetof(HWCharacter_NPC_HasSpreadLocation, ReturnValue) == 0x000000, "Member 'HWCharacter_NPC_HasSpreadLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.IsBehindSquad
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NPC_IsBehindSquad final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_IsBehindSquad) == 0x000001, "Wrong alignment on HWCharacter_NPC_IsBehindSquad");
static_assert(sizeof(HWCharacter_NPC_IsBehindSquad) == 0x000001, "Wrong size on HWCharacter_NPC_IsBehindSquad");
static_assert(offsetof(HWCharacter_NPC_IsBehindSquad, ReturnValue) == 0x000000, "Member 'HWCharacter_NPC_IsBehindSquad::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.IsHibernating
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NPC_IsHibernating final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_IsHibernating) == 0x000001, "Wrong alignment on HWCharacter_NPC_IsHibernating");
static_assert(sizeof(HWCharacter_NPC_IsHibernating) == 0x000001, "Wrong size on HWCharacter_NPC_IsHibernating");
static_assert(offsetof(HWCharacter_NPC_IsHibernating, ReturnValue) == 0x000000, "Member 'HWCharacter_NPC_IsHibernating::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_NPC.IsSpawnCached
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NPC_IsSpawnCached final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NPC_IsSpawnCached) == 0x000001, "Wrong alignment on HWCharacter_NPC_IsSpawnCached");
static_assert(sizeof(HWCharacter_NPC_IsSpawnCached) == 0x000001, "Wrong size on HWCharacter_NPC_IsSpawnCached");
static_assert(offsetof(HWCharacter_NPC_IsSpawnCached, ReturnValue) == 0x000000, "Member 'HWCharacter_NPC_IsSpawnCached::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.AbilityPhaseEnumToTag
// 0x000C (0x000C - 0x0000)
struct HWGameplayAbility_Enhanced_AbilityPhaseEnumToTag final
{
public:
	EAbilityFlowPhase                             Phase;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_AbilityPhaseEnumToTag) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_AbilityPhaseEnumToTag");
static_assert(sizeof(HWGameplayAbility_Enhanced_AbilityPhaseEnumToTag) == 0x00000C, "Wrong size on HWGameplayAbility_Enhanced_AbilityPhaseEnumToTag");
static_assert(offsetof(HWGameplayAbility_Enhanced_AbilityPhaseEnumToTag, Phase) == 0x000000, "Member 'HWGameplayAbility_Enhanced_AbilityPhaseEnumToTag::Phase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_AbilityPhaseEnumToTag, ReturnValue) == 0x000004, "Member 'HWGameplayAbility_Enhanced_AbilityPhaseEnumToTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.AbilityPhaseTagToEnum
// 0x000C (0x000C - 0x0000)
struct HWGameplayAbility_Enhanced_AbilityPhaseTagToEnum final
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityFlowPhase                             ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_Enhanced_AbilityPhaseTagToEnum) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_AbilityPhaseTagToEnum");
static_assert(sizeof(HWGameplayAbility_Enhanced_AbilityPhaseTagToEnum) == 0x00000C, "Wrong size on HWGameplayAbility_Enhanced_AbilityPhaseTagToEnum");
static_assert(offsetof(HWGameplayAbility_Enhanced_AbilityPhaseTagToEnum, PhaseTag) == 0x000000, "Member 'HWGameplayAbility_Enhanced_AbilityPhaseTagToEnum::PhaseTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_AbilityPhaseTagToEnum, ReturnValue) == 0x000008, "Member 'HWGameplayAbility_Enhanced_AbilityPhaseTagToEnum::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.AttemptAbilityAttackHit
// 0x00D0 (0x00D0 - 0x0000)
struct HWGameplayAbility_Enhanced_AttemptAbilityAttackHit final
{
public:
	class UHWAbilityTask_FireAttack*              AttackTask;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityAttackInstance               Attack;                                            // 0x0008(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0088(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  HitTags;                                           // 0x00B0(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_AttemptAbilityAttackHit) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_AttemptAbilityAttackHit");
static_assert(sizeof(HWGameplayAbility_Enhanced_AttemptAbilityAttackHit) == 0x0000D0, "Wrong size on HWGameplayAbility_Enhanced_AttemptAbilityAttackHit");
static_assert(offsetof(HWGameplayAbility_Enhanced_AttemptAbilityAttackHit, AttackTask) == 0x000000, "Member 'HWGameplayAbility_Enhanced_AttemptAbilityAttackHit::AttackTask' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_AttemptAbilityAttackHit, Attack) == 0x000008, "Member 'HWGameplayAbility_Enhanced_AttemptAbilityAttackHit::Attack' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_AttemptAbilityAttackHit, TargetData) == 0x000088, "Member 'HWGameplayAbility_Enhanced_AttemptAbilityAttackHit::TargetData' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_AttemptAbilityAttackHit, HitTags) == 0x0000B0, "Member 'HWGameplayAbility_Enhanced_AttemptAbilityAttackHit::HitTags' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.BP_AdjustTargetActorSettings
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_BP_AdjustTargetActorSettings final
{
public:
	class AHWTargeter*                            Targeter;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_BP_AdjustTargetActorSettings) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_BP_AdjustTargetActorSettings");
static_assert(sizeof(HWGameplayAbility_Enhanced_BP_AdjustTargetActorSettings) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_BP_AdjustTargetActorSettings");
static_assert(offsetof(HWGameplayAbility_Enhanced_BP_AdjustTargetActorSettings, Targeter) == 0x000000, "Member 'HWGameplayAbility_Enhanced_BP_AdjustTargetActorSettings::Targeter' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.BP_OnTargetingCancelled
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_Enhanced_BP_OnTargetingCancelled final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetingData;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_BP_OnTargetingCancelled) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_BP_OnTargetingCancelled");
static_assert(sizeof(HWGameplayAbility_Enhanced_BP_OnTargetingCancelled) == 0x000028, "Wrong size on HWGameplayAbility_Enhanced_BP_OnTargetingCancelled");
static_assert(offsetof(HWGameplayAbility_Enhanced_BP_OnTargetingCancelled, TargetingData) == 0x000000, "Member 'HWGameplayAbility_Enhanced_BP_OnTargetingCancelled::TargetingData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.BP_OnTargetingConfirmed
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_Enhanced_BP_OnTargetingConfirmed final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetingData;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_BP_OnTargetingConfirmed) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_BP_OnTargetingConfirmed");
static_assert(sizeof(HWGameplayAbility_Enhanced_BP_OnTargetingConfirmed) == 0x000028, "Wrong size on HWGameplayAbility_Enhanced_BP_OnTargetingConfirmed");
static_assert(offsetof(HWGameplayAbility_Enhanced_BP_OnTargetingConfirmed, TargetingData) == 0x000000, "Member 'HWGameplayAbility_Enhanced_BP_OnTargetingConfirmed::TargetingData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.CalcHomingTargetForProjectileAttack
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_Enhanced_CalcHomingTargetForProjectileAttack final
{
public:
	struct FGameplayTag                           AttackID;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_CalcHomingTargetForProjectileAttack) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_CalcHomingTargetForProjectileAttack");
static_assert(sizeof(HWGameplayAbility_Enhanced_CalcHomingTargetForProjectileAttack) == 0x000010, "Wrong size on HWGameplayAbility_Enhanced_CalcHomingTargetForProjectileAttack");
static_assert(offsetof(HWGameplayAbility_Enhanced_CalcHomingTargetForProjectileAttack, AttackID) == 0x000000, "Member 'HWGameplayAbility_Enhanced_CalcHomingTargetForProjectileAttack::AttackID' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_CalcHomingTargetForProjectileAttack, ReturnValue) == 0x000008, "Member 'HWGameplayAbility_Enhanced_CalcHomingTargetForProjectileAttack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.ConfirmTargeting
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_ConfirmTargeting final
{
public:
	bool                                          bEndTargetingTask;                                 // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_ConfirmTargeting) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_ConfirmTargeting");
static_assert(sizeof(HWGameplayAbility_Enhanced_ConfirmTargeting) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_ConfirmTargeting");
static_assert(offsetof(HWGameplayAbility_Enhanced_ConfirmTargeting, bEndTargetingTask) == 0x000000, "Member 'HWGameplayAbility_Enhanced_ConfirmTargeting::bEndTargetingTask' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.CurrentFiringDataUpdated
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_Enhanced_CurrentFiringDataUpdated final
{
public:
	struct FGameplayAbilityTargetDataHandle       NewFiringTargetData;                               // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_CurrentFiringDataUpdated) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_CurrentFiringDataUpdated");
static_assert(sizeof(HWGameplayAbility_Enhanced_CurrentFiringDataUpdated) == 0x000028, "Wrong size on HWGameplayAbility_Enhanced_CurrentFiringDataUpdated");
static_assert(offsetof(HWGameplayAbility_Enhanced_CurrentFiringDataUpdated, NewFiringTargetData) == 0x000000, "Member 'HWGameplayAbility_Enhanced_CurrentFiringDataUpdated::NewFiringTargetData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.EndTargeting
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_EndTargeting final
{
public:
	bool                                          bWasCancelled;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_EndTargeting) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_EndTargeting");
static_assert(sizeof(HWGameplayAbility_Enhanced_EndTargeting) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_EndTargeting");
static_assert(offsetof(HWGameplayAbility_Enhanced_EndTargeting, bWasCancelled) == 0x000000, "Member 'HWGameplayAbility_Enhanced_EndTargeting::bWasCancelled' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.FamiliarSpawnParamsOverrideCharacter
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideCharacter final
{
public:
	const class UHWCharacterItem*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideCharacter) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideCharacter");
static_assert(sizeof(HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideCharacter) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideCharacter");
static_assert(offsetof(HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideCharacter, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.FamiliarSpawnParamsOverrideController
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideController final
{
public:
	const class AController*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideController) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideController");
static_assert(sizeof(HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideController) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideController");
static_assert(offsetof(HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideController, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideController::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.FamiliarSpawnParamsOverrideSkin
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideSkin final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideSkin) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideSkin");
static_assert(sizeof(HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideSkin) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideSkin");
static_assert(offsetof(HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideSkin, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_FamiliarSpawnParamsOverrideSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.FireCustomAttack
// 0x00E0 (0x00E0 - 0x0000)
struct HWGameplayAbility_Enhanced_FireCustomAttack final
{
public:
	class UHWAbilityTask_FireAttack*              AttackTask;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityAttackInstance               Attack;                                            // 0x0008(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings_Custom*  AttackSettings;                                    // 0x0088(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       AimData;                                           // 0x0090(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetList;                                        // 0x00B8(0x0028)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_FireCustomAttack) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_FireCustomAttack");
static_assert(sizeof(HWGameplayAbility_Enhanced_FireCustomAttack) == 0x0000E0, "Wrong size on HWGameplayAbility_Enhanced_FireCustomAttack");
static_assert(offsetof(HWGameplayAbility_Enhanced_FireCustomAttack, AttackTask) == 0x000000, "Member 'HWGameplayAbility_Enhanced_FireCustomAttack::AttackTask' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_FireCustomAttack, Attack) == 0x000008, "Member 'HWGameplayAbility_Enhanced_FireCustomAttack::Attack' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_FireCustomAttack, AttackSettings) == 0x000088, "Member 'HWGameplayAbility_Enhanced_FireCustomAttack::AttackSettings' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_FireCustomAttack, AimData) == 0x000090, "Member 'HWGameplayAbility_Enhanced_FireCustomAttack::AimData' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_FireCustomAttack, TargetList) == 0x0000B8, "Member 'HWGameplayAbility_Enhanced_FireCustomAttack::TargetList' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.ManagePendingAttackTargets
// 0x0020 (0x0020 - 0x0000)
struct HWGameplayAbility_Enhanced_ManagePendingAttackTargets final
{
public:
	struct FHWHitResultsReference                 HitArray;                                          // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHWHitResultsReference                 OutHitArray;                                       // 0x0010(0x0010)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_ManagePendingAttackTargets) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_ManagePendingAttackTargets");
static_assert(sizeof(HWGameplayAbility_Enhanced_ManagePendingAttackTargets) == 0x000020, "Wrong size on HWGameplayAbility_Enhanced_ManagePendingAttackTargets");
static_assert(offsetof(HWGameplayAbility_Enhanced_ManagePendingAttackTargets, HitArray) == 0x000000, "Member 'HWGameplayAbility_Enhanced_ManagePendingAttackTargets::HitArray' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_ManagePendingAttackTargets, OutHitArray) == 0x000010, "Member 'HWGameplayAbility_Enhanced_ManagePendingAttackTargets::OutHitArray' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.ModifyTargetingHighlightListForAttack
// 0x0070 (0x0070 - 0x0000)
struct HWGameplayAbility_Enhanced_ModifyTargetingHighlightListForAttack final
{
public:
	struct FHWAttackTargetingInfo                 TargetingInfo;                                     // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetListDataHandle;                              // 0x0048(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_ModifyTargetingHighlightListForAttack) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_ModifyTargetingHighlightListForAttack");
static_assert(sizeof(HWGameplayAbility_Enhanced_ModifyTargetingHighlightListForAttack) == 0x000070, "Wrong size on HWGameplayAbility_Enhanced_ModifyTargetingHighlightListForAttack");
static_assert(offsetof(HWGameplayAbility_Enhanced_ModifyTargetingHighlightListForAttack, TargetingInfo) == 0x000000, "Member 'HWGameplayAbility_Enhanced_ModifyTargetingHighlightListForAttack::TargetingInfo' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_ModifyTargetingHighlightListForAttack, TargetListDataHandle) == 0x000048, "Member 'HWGameplayAbility_Enhanced_ModifyTargetingHighlightListForAttack::TargetListDataHandle' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnAbilityAttackProgressedEvent
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_OnAbilityAttackProgressedEvent final
{
public:
	int32                                         AttackID;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackEventID;                                     // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnAbilityAttackProgressedEvent) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_OnAbilityAttackProgressedEvent");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnAbilityAttackProgressedEvent) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_OnAbilityAttackProgressedEvent");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAbilityAttackProgressedEvent, AttackID) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnAbilityAttackProgressedEvent::AttackID' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAbilityAttackProgressedEvent, AttackEventID) == 0x000004, "Member 'HWGameplayAbility_Enhanced_OnAbilityAttackProgressedEvent::AttackEventID' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnAbilityPhaseChangeStarted
// 0x0002 (0x0002 - 0x0000)
struct HWGameplayAbility_Enhanced_OnAbilityPhaseChangeStarted final
{
public:
	EAbilityFlowPhase                             PrevPhase;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityFlowPhase                             NextPhase;                                         // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnAbilityPhaseChangeStarted) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_OnAbilityPhaseChangeStarted");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnAbilityPhaseChangeStarted) == 0x000002, "Wrong size on HWGameplayAbility_Enhanced_OnAbilityPhaseChangeStarted");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAbilityPhaseChangeStarted, PrevPhase) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnAbilityPhaseChangeStarted::PrevPhase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAbilityPhaseChangeStarted, NextPhase) == 0x000001, "Member 'HWGameplayAbility_Enhanced_OnAbilityPhaseChangeStarted::NextPhase' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnAttackEnded
// 0x0088 (0x0088 - 0x0000)
struct HWGameplayAbility_Enhanced_OnAttackEnded final
{
public:
	class UHWAbilityTask_FireAttack*              AttackTask;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityAttackInstance               Attack;                                            // 0x0008(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnAttackEnded) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnAttackEnded");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnAttackEnded) == 0x000088, "Wrong size on HWGameplayAbility_Enhanced_OnAttackEnded");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAttackEnded, AttackTask) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnAttackEnded::AttackTask' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAttackEnded, Attack) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnAttackEnded::Attack' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnAttackFired
// 0x00B0 (0x00B0 - 0x0000)
struct HWGameplayAbility_Enhanced_OnAttackFired final
{
public:
	class UHWAbilityTask_FireAttack*              AttackTask;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityAttackInstance               Attack;                                            // 0x0008(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetListHandle;                                  // 0x0088(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnAttackFired) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnAttackFired");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnAttackFired) == 0x0000B0, "Wrong size on HWGameplayAbility_Enhanced_OnAttackFired");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAttackFired, AttackTask) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnAttackFired::AttackTask' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAttackFired, Attack) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnAttackFired::Attack' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAttackFired, TargetListHandle) == 0x000088, "Member 'HWGameplayAbility_Enhanced_OnAttackFired::TargetListHandle' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnAttackStarted
// 0x0088 (0x0088 - 0x0000)
struct HWGameplayAbility_Enhanced_OnAttackStarted final
{
public:
	class UHWAbilityTask_FireAttack*              AttackTask;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityAttackInstance               Attack;                                            // 0x0008(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnAttackStarted) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnAttackStarted");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnAttackStarted) == 0x000088, "Wrong size on HWGameplayAbility_Enhanced_OnAttackStarted");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAttackStarted, AttackTask) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnAttackStarted::AttackTask' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnAttackStarted, Attack) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnAttackStarted::Attack' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnCastStyleCancelled
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_OnCastStyleCancelled final
{
public:
	float                                         TimeElapsed;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputReleased;                                    // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnCastStyleCancelled) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_OnCastStyleCancelled");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnCastStyleCancelled) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_OnCastStyleCancelled");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnCastStyleCancelled, TimeElapsed) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnCastStyleCancelled::TimeElapsed' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnCastStyleCancelled, bInputReleased) == 0x000004, "Member 'HWGameplayAbility_Enhanced_OnCastStyleCancelled::bInputReleased' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnCastStyleConfirmed
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_OnCastStyleConfirmed final
{
public:
	float                                         TimeElapsed;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputReleased;                                    // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnCastStyleConfirmed) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_OnCastStyleConfirmed");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnCastStyleConfirmed) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_OnCastStyleConfirmed");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnCastStyleConfirmed, TimeElapsed) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnCastStyleConfirmed::TimeElapsed' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnCastStyleConfirmed, bInputReleased) == 0x000004, "Member 'HWGameplayAbility_Enhanced_OnCastStyleConfirmed::bInputReleased' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnDeployableBeginSpawning
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_Enhanced_OnDeployableBeginSpawning final
{
public:
	class AHWDeployable*                          SpawnedDeployable;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings_Deployable* DeployableAttackSettings;                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnDeployableBeginSpawning) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnDeployableBeginSpawning");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnDeployableBeginSpawning) == 0x000010, "Wrong size on HWGameplayAbility_Enhanced_OnDeployableBeginSpawning");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnDeployableBeginSpawning, SpawnedDeployable) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnDeployableBeginSpawning::SpawnedDeployable' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnDeployableBeginSpawning, DeployableAttackSettings) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnDeployableBeginSpawning::DeployableAttackSettings' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnDeployableSpawned
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_Enhanced_OnDeployableSpawned final
{
public:
	class AHWDeployable*                          SpawnedDeployable;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings_Deployable* DeployableAttackSettings;                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnDeployableSpawned) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnDeployableSpawned");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnDeployableSpawned) == 0x000010, "Wrong size on HWGameplayAbility_Enhanced_OnDeployableSpawned");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnDeployableSpawned, SpawnedDeployable) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnDeployableSpawned::SpawnedDeployable' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnDeployableSpawned, DeployableAttackSettings) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnDeployableSpawned::DeployableAttackSettings' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnFamiliarSpawned
// 0x0020 (0x0020 - 0x0000)
struct HWGameplayAbility_Enhanced_OnFamiliarSpawned final
{
public:
	struct FHWActiveFamiliarHandle                FamiliarHandle;                                    // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWFamiliarManagerComponent*            FamiliarManager;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings_SpawnFamiliar* FamiliarAttackSettings;                      // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnFamiliarSpawned) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnFamiliarSpawned");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnFamiliarSpawned) == 0x000020, "Wrong size on HWGameplayAbility_Enhanced_OnFamiliarSpawned");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFamiliarSpawned, FamiliarHandle) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnFamiliarSpawned::FamiliarHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFamiliarSpawned, FamiliarManager) == 0x000010, "Member 'HWGameplayAbility_Enhanced_OnFamiliarSpawned::FamiliarManager' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFamiliarSpawned, FamiliarAttackSettings) == 0x000018, "Member 'HWGameplayAbility_Enhanced_OnFamiliarSpawned::FamiliarAttackSettings' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnFiringMontageEnded
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_Enhanced_OnFiringMontageEnded final
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseDuration;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_PhasedMontage*           MontageTask;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnFiringMontageEnded) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnFiringMontageEnded");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnFiringMontageEnded) == 0x000018, "Wrong size on HWGameplayAbility_Enhanced_OnFiringMontageEnded");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFiringMontageEnded, PhaseTag) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnFiringMontageEnded::PhaseTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFiringMontageEnded, PhaseDuration) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnFiringMontageEnded::PhaseDuration' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFiringMontageEnded, MontageTask) == 0x000010, "Member 'HWGameplayAbility_Enhanced_OnFiringMontageEnded::MontageTask' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnFiringMontagePhaseEnded
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded final
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseDuration;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_PhasedMontage*           MontageTask;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded) == 0x000018, "Wrong size on HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded, PhaseTag) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded::PhaseTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded, PhaseDuration) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded::PhaseDuration' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded, MontageTask) == 0x000010, "Member 'HWGameplayAbility_Enhanced_OnFiringMontagePhaseEnded::MontageTask' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnFiringMontagePhaseStarted
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted final
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseDuration;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_PhasedMontage*           MontageTask;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted) == 0x000018, "Wrong size on HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted, PhaseTag) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted::PhaseTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted, PhaseDuration) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted::PhaseDuration' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted, MontageTask) == 0x000010, "Member 'HWGameplayAbility_Enhanced_OnFiringMontagePhaseStarted::MontageTask' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnProjectileBeginSpawning
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_Enhanced_OnProjectileBeginSpawning final
{
public:
	class AHWProjectile*                          SpawnedProjectile;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings_Projectile* ProjectileAttackSettings;                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnProjectileBeginSpawning) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnProjectileBeginSpawning");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnProjectileBeginSpawning) == 0x000010, "Wrong size on HWGameplayAbility_Enhanced_OnProjectileBeginSpawning");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnProjectileBeginSpawning, SpawnedProjectile) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnProjectileBeginSpawning::SpawnedProjectile' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnProjectileBeginSpawning, ProjectileAttackSettings) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnProjectileBeginSpawning::ProjectileAttackSettings' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnProjectileSpawned
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_Enhanced_OnProjectileSpawned final
{
public:
	class AHWProjectile*                          SpawnedProjectile;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings_Projectile* ProjectileAttackSettings;                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnProjectileSpawned) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnProjectileSpawned");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnProjectileSpawned) == 0x000010, "Wrong size on HWGameplayAbility_Enhanced_OnProjectileSpawned");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnProjectileSpawned, SpawnedProjectile) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnProjectileSpawned::SpawnedProjectile' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnProjectileSpawned, ProjectileAttackSettings) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnProjectileSpawned::ProjectileAttackSettings' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnSpawnedProjectileHitTarget
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_Enhanced_OnSpawnedProjectileHitTarget final
{
public:
	class AHWProjectile*                          SpawnedProjectile;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HitTarget;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnSpawnedProjectileHitTarget) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnSpawnedProjectileHitTarget");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnSpawnedProjectileHitTarget) == 0x000010, "Wrong size on HWGameplayAbility_Enhanced_OnSpawnedProjectileHitTarget");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnSpawnedProjectileHitTarget, SpawnedProjectile) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnSpawnedProjectileHitTarget::SpawnedProjectile' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnSpawnedProjectileHitTarget, HitTarget) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnSpawnedProjectileHitTarget::HitTarget' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnTargeterValidationChanged
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_OnTargeterValidationChanged final
{
public:
	bool                                          bValid;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnTargeterValidationChanged) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_OnTargeterValidationChanged");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnTargeterValidationChanged) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_OnTargeterValidationChanged");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargeterValidationChanged, bValid) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnTargeterValidationChanged::bValid' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnTargetingCancelled
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_Enhanced_OnTargetingCancelled final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetingData;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnTargetingCancelled) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnTargetingCancelled");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnTargetingCancelled) == 0x000028, "Wrong size on HWGameplayAbility_Enhanced_OnTargetingCancelled");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingCancelled, TargetingData) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnTargetingCancelled::TargetingData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnTargetingConfirmed
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_Enhanced_OnTargetingConfirmed final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetingData;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnTargetingConfirmed) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnTargetingConfirmed");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnTargetingConfirmed) == 0x000028, "Wrong size on HWGameplayAbility_Enhanced_OnTargetingConfirmed");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingConfirmed, TargetingData) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnTargetingConfirmed::TargetingData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnTargetingMontageEnded
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_Enhanced_OnTargetingMontageEnded final
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseDuration;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_PhasedMontage*           MontageTask;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnTargetingMontageEnded) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnTargetingMontageEnded");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnTargetingMontageEnded) == 0x000018, "Wrong size on HWGameplayAbility_Enhanced_OnTargetingMontageEnded");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingMontageEnded, PhaseTag) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnTargetingMontageEnded::PhaseTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingMontageEnded, PhaseDuration) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnTargetingMontageEnded::PhaseDuration' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingMontageEnded, MontageTask) == 0x000010, "Member 'HWGameplayAbility_Enhanced_OnTargetingMontageEnded::MontageTask' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnTargetingMontagePhaseEnded
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded final
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseDuration;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_PhasedMontage*           MontageTask;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded) == 0x000018, "Wrong size on HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded, PhaseTag) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded::PhaseTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded, PhaseDuration) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded::PhaseDuration' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded, MontageTask) == 0x000010, "Member 'HWGameplayAbility_Enhanced_OnTargetingMontagePhaseEnded::MontageTask' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OnTargetingMontagePhaseStarted
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted final
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseDuration;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_PhasedMontage*           MontageTask;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted");
static_assert(sizeof(HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted) == 0x000018, "Wrong size on HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted, PhaseTag) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted::PhaseTag' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted, PhaseDuration) == 0x000008, "Member 'HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted::PhaseDuration' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted, MontageTask) == 0x000010, "Member 'HWGameplayAbility_Enhanced_OnTargetingMontagePhaseStarted::MontageTask' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.OverrideAbilityPhaseTransition
// 0x0003 (0x0003 - 0x0000)
struct HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition final
{
public:
	EAbilityFlowPhase                             PrevPhase;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityFlowPhase                             NextPhase;                                         // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition");
static_assert(sizeof(HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition) == 0x000003, "Wrong size on HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition");
static_assert(offsetof(HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition, PrevPhase) == 0x000000, "Member 'HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition::PrevPhase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition, NextPhase) == 0x000001, "Member 'HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition::NextPhase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition, ReturnValue) == 0x000002, "Member 'HWGameplayAbility_Enhanced_OverrideAbilityPhaseTransition::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.PlayFiringMontage
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_PlayFiringMontage final
{
public:
	bool                                          bRestartActiveFiringMontage;                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_PlayFiringMontage) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_PlayFiringMontage");
static_assert(sizeof(HWGameplayAbility_Enhanced_PlayFiringMontage) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_PlayFiringMontage");
static_assert(offsetof(HWGameplayAbility_Enhanced_PlayFiringMontage, bRestartActiveFiringMontage) == 0x000000, "Member 'HWGameplayAbility_Enhanced_PlayFiringMontage::bRestartActiveFiringMontage' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.PlayTargetingMontage
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_PlayTargetingMontage final
{
public:
	bool                                          bRestartActiveTargetingMontage;                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_PlayTargetingMontage) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_PlayTargetingMontage");
static_assert(sizeof(HWGameplayAbility_Enhanced_PlayTargetingMontage) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_PlayTargetingMontage");
static_assert(offsetof(HWGameplayAbility_Enhanced_PlayTargetingMontage, bRestartActiveTargetingMontage) == 0x000000, "Member 'HWGameplayAbility_Enhanced_PlayTargetingMontage::bRestartActiveTargetingMontage' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.RemoveAbilityAttackHit
// 0x0050 (0x0050 - 0x0000)
struct HWGameplayAbility_Enhanced_RemoveAbilityAttackHit final
{
public:
	class UHWAbilityTask_FireAttack*              AttackTask;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  HitTags;                                           // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0028(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_RemoveAbilityAttackHit) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_RemoveAbilityAttackHit");
static_assert(sizeof(HWGameplayAbility_Enhanced_RemoveAbilityAttackHit) == 0x000050, "Wrong size on HWGameplayAbility_Enhanced_RemoveAbilityAttackHit");
static_assert(offsetof(HWGameplayAbility_Enhanced_RemoveAbilityAttackHit, AttackTask) == 0x000000, "Member 'HWGameplayAbility_Enhanced_RemoveAbilityAttackHit::AttackTask' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_RemoveAbilityAttackHit, HitTags) == 0x000008, "Member 'HWGameplayAbility_Enhanced_RemoveAbilityAttackHit::HitTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_RemoveAbilityAttackHit, TargetData) == 0x000028, "Member 'HWGameplayAbility_Enhanced_RemoveAbilityAttackHit::TargetData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.SetAttacksToTargetDuringTargetingPhase
// 0x0020 (0x0020 - 0x0000)
struct HWGameplayAbility_Enhanced_SetAttacksToTargetDuringTargetingPhase final
{
public:
	struct FGameplayTagContainer                  TargetAttacks;                                     // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_SetAttacksToTargetDuringTargetingPhase) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_SetAttacksToTargetDuringTargetingPhase");
static_assert(sizeof(HWGameplayAbility_Enhanced_SetAttacksToTargetDuringTargetingPhase) == 0x000020, "Wrong size on HWGameplayAbility_Enhanced_SetAttacksToTargetDuringTargetingPhase");
static_assert(offsetof(HWGameplayAbility_Enhanced_SetAttacksToTargetDuringTargetingPhase, TargetAttacks) == 0x000000, "Member 'HWGameplayAbility_Enhanced_SetAttacksToTargetDuringTargetingPhase::TargetAttacks' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.SetProjectileSpawnCustomData
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_SetProjectileSpawnCustomData final
{
public:
	class UHWAbilityTask_SpawnProjectile*         SpawnTask;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_SetProjectileSpawnCustomData) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_SetProjectileSpawnCustomData");
static_assert(sizeof(HWGameplayAbility_Enhanced_SetProjectileSpawnCustomData) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_SetProjectileSpawnCustomData");
static_assert(offsetof(HWGameplayAbility_Enhanced_SetProjectileSpawnCustomData, SpawnTask) == 0x000000, "Member 'HWGameplayAbility_Enhanced_SetProjectileSpawnCustomData::SpawnTask' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.SetShouldUseLevelConfigForPhaseTiming
// 0x0002 (0x0002 - 0x0000)
struct HWGameplayAbility_Enhanced_SetShouldUseLevelConfigForPhaseTiming final
{
public:
	EAbilityFlowPhase                             Phase;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseLevelConfig;                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_SetShouldUseLevelConfigForPhaseTiming) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_SetShouldUseLevelConfigForPhaseTiming");
static_assert(sizeof(HWGameplayAbility_Enhanced_SetShouldUseLevelConfigForPhaseTiming) == 0x000002, "Wrong size on HWGameplayAbility_Enhanced_SetShouldUseLevelConfigForPhaseTiming");
static_assert(offsetof(HWGameplayAbility_Enhanced_SetShouldUseLevelConfigForPhaseTiming, Phase) == 0x000000, "Member 'HWGameplayAbility_Enhanced_SetShouldUseLevelConfigForPhaseTiming::Phase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_SetShouldUseLevelConfigForPhaseTiming, bShouldUseLevelConfig) == 0x000001, "Member 'HWGameplayAbility_Enhanced_SetShouldUseLevelConfigForPhaseTiming::bShouldUseLevelConfig' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.ShouldAllowCancellationWhileFiring
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_ShouldAllowCancellationWhileFiring final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_ShouldAllowCancellationWhileFiring) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_ShouldAllowCancellationWhileFiring");
static_assert(sizeof(HWGameplayAbility_Enhanced_ShouldAllowCancellationWhileFiring) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_ShouldAllowCancellationWhileFiring");
static_assert(offsetof(HWGameplayAbility_Enhanced_ShouldAllowCancellationWhileFiring, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_ShouldAllowCancellationWhileFiring::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.StopFiringAbility
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_StopFiringAbility final
{
public:
	bool                                          bIsCanceling;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_StopFiringAbility) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_StopFiringAbility");
static_assert(sizeof(HWGameplayAbility_Enhanced_StopFiringAbility) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_StopFiringAbility");
static_assert(offsetof(HWGameplayAbility_Enhanced_StopFiringAbility, bIsCanceling) == 0x000000, "Member 'HWGameplayAbility_Enhanced_StopFiringAbility::bIsCanceling' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.StopTargetingMontage
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_StopTargetingMontage final
{
public:
	bool                                          bWasCancelled;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_StopTargetingMontage) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_StopTargetingMontage");
static_assert(sizeof(HWGameplayAbility_Enhanced_StopTargetingMontage) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_StopTargetingMontage");
static_assert(offsetof(HWGameplayAbility_Enhanced_StopTargetingMontage, bWasCancelled) == 0x000000, "Member 'HWGameplayAbility_Enhanced_StopTargetingMontage::bWasCancelled' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.ToggleIgnoreControlRotationSimulated
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_ToggleIgnoreControlRotationSimulated final
{
public:
	bool                                          bShouldIgnoreControlRotation;                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_ToggleIgnoreControlRotationSimulated) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_ToggleIgnoreControlRotationSimulated");
static_assert(sizeof(HWGameplayAbility_Enhanced_ToggleIgnoreControlRotationSimulated) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_ToggleIgnoreControlRotationSimulated");
static_assert(offsetof(HWGameplayAbility_Enhanced_ToggleIgnoreControlRotationSimulated, bShouldIgnoreControlRotation) == 0x000000, "Member 'HWGameplayAbility_Enhanced_ToggleIgnoreControlRotationSimulated::bShouldIgnoreControlRotation' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.ToggleIgnoreMovementInputSimulated
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_ToggleIgnoreMovementInputSimulated final
{
public:
	bool                                          bShouldIgnoreMovementInput;                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_ToggleIgnoreMovementInputSimulated) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_ToggleIgnoreMovementInputSimulated");
static_assert(sizeof(HWGameplayAbility_Enhanced_ToggleIgnoreMovementInputSimulated) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_ToggleIgnoreMovementInputSimulated");
static_assert(offsetof(HWGameplayAbility_Enhanced_ToggleIgnoreMovementInputSimulated, bShouldIgnoreMovementInput) == 0x000000, "Member 'HWGameplayAbility_Enhanced_ToggleIgnoreMovementInputSimulated::bShouldIgnoreMovementInput' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.TransitionToAbilityPhase
// 0x000C (0x000C - 0x0000)
struct HWGameplayAbility_Enhanced_TransitionToAbilityPhase final
{
public:
	EAbilityFlowPhase                             PhaseToEnter;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimingError;                                       // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceToClients;                                   // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_Enhanced_TransitionToAbilityPhase) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_TransitionToAbilityPhase");
static_assert(sizeof(HWGameplayAbility_Enhanced_TransitionToAbilityPhase) == 0x00000C, "Wrong size on HWGameplayAbility_Enhanced_TransitionToAbilityPhase");
static_assert(offsetof(HWGameplayAbility_Enhanced_TransitionToAbilityPhase, PhaseToEnter) == 0x000000, "Member 'HWGameplayAbility_Enhanced_TransitionToAbilityPhase::PhaseToEnter' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_TransitionToAbilityPhase, TimingError) == 0x000004, "Member 'HWGameplayAbility_Enhanced_TransitionToAbilityPhase::TimingError' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_TransitionToAbilityPhase, bForceToClients) == 0x000008, "Member 'HWGameplayAbility_Enhanced_TransitionToAbilityPhase::bForceToClients' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_TransitionToAbilityPhase, ReturnValue) == 0x000009, "Member 'HWGameplayAbility_Enhanced_TransitionToAbilityPhase::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.UpdateFiringAimDataForAttack
// 0x0030 (0x0030 - 0x0000)
struct HWGameplayAbility_Enhanced_UpdateFiringAimDataForAttack final
{
public:
	struct FGameplayTag                           AttackID;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_UpdateFiringAimDataForAttack) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_UpdateFiringAimDataForAttack");
static_assert(sizeof(HWGameplayAbility_Enhanced_UpdateFiringAimDataForAttack) == 0x000030, "Wrong size on HWGameplayAbility_Enhanced_UpdateFiringAimDataForAttack");
static_assert(offsetof(HWGameplayAbility_Enhanced_UpdateFiringAimDataForAttack, AttackID) == 0x000000, "Member 'HWGameplayAbility_Enhanced_UpdateFiringAimDataForAttack::AttackID' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_UpdateFiringAimDataForAttack, ReturnValue) == 0x000008, "Member 'HWGameplayAbility_Enhanced_UpdateFiringAimDataForAttack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.ValidatedAttemptAbilityAttackHit
// 0x00D0 (0x00D0 - 0x0000)
struct HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit final
{
public:
	class UHWAbilityTask_FireAttack*              AttackTask;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityAttackInstance               Attack;                                            // 0x0008(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0088(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  HitTags;                                           // 0x00B0(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit");
static_assert(sizeof(HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit) == 0x0000D0, "Wrong size on HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit");
static_assert(offsetof(HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit, AttackTask) == 0x000000, "Member 'HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit::AttackTask' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit, Attack) == 0x000008, "Member 'HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit::Attack' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit, TargetData) == 0x000088, "Member 'HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit::TargetData' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit, HitTags) == 0x0000B0, "Member 'HWGameplayAbility_Enhanced_ValidatedAttemptAbilityAttackHit::HitTags' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.WantsToOverrideFamiliarSpawnParams
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_WantsToOverrideFamiliarSpawnParams final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_WantsToOverrideFamiliarSpawnParams) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_WantsToOverrideFamiliarSpawnParams");
static_assert(sizeof(HWGameplayAbility_Enhanced_WantsToOverrideFamiliarSpawnParams) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_WantsToOverrideFamiliarSpawnParams");
static_assert(offsetof(HWGameplayAbility_Enhanced_WantsToOverrideFamiliarSpawnParams, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_WantsToOverrideFamiliarSpawnParams::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.CanBeCancelledByAnotherFiringAbility
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_CanBeCancelledByAnotherFiringAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_CanBeCancelledByAnotherFiringAbility) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_CanBeCancelledByAnotherFiringAbility");
static_assert(sizeof(HWGameplayAbility_Enhanced_CanBeCancelledByAnotherFiringAbility) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_CanBeCancelledByAnotherFiringAbility");
static_assert(offsetof(HWGameplayAbility_Enhanced_CanBeCancelledByAnotherFiringAbility, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_CanBeCancelledByAnotherFiringAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.CanCancelWhileFiring
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_CanCancelWhileFiring final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_CanCancelWhileFiring) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_CanCancelWhileFiring");
static_assert(sizeof(HWGameplayAbility_Enhanced_CanCancelWhileFiring) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_CanCancelWhileFiring");
static_assert(offsetof(HWGameplayAbility_Enhanced_CanCancelWhileFiring, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_CanCancelWhileFiring::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.CanRestartFiring
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_CanRestartFiring final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_CanRestartFiring) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_CanRestartFiring");
static_assert(sizeof(HWGameplayAbility_Enhanced_CanRestartFiring) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_CanRestartFiring");
static_assert(offsetof(HWGameplayAbility_Enhanced_CanRestartFiring, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_CanRestartFiring::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.CanTransitionToPhase
// 0x0002 (0x0002 - 0x0000)
struct HWGameplayAbility_Enhanced_CanTransitionToPhase final
{
public:
	EAbilityFlowPhase                             DesiredPhase;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_CanTransitionToPhase) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_CanTransitionToPhase");
static_assert(sizeof(HWGameplayAbility_Enhanced_CanTransitionToPhase) == 0x000002, "Wrong size on HWGameplayAbility_Enhanced_CanTransitionToPhase");
static_assert(offsetof(HWGameplayAbility_Enhanced_CanTransitionToPhase, DesiredPhase) == 0x000000, "Member 'HWGameplayAbility_Enhanced_CanTransitionToPhase::DesiredPhase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_CanTransitionToPhase, ReturnValue) == 0x000001, "Member 'HWGameplayAbility_Enhanced_CanTransitionToPhase::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetAbilityPhase
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_GetAbilityPhase final
{
public:
	EAbilityFlowPhase                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetAbilityPhase) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_GetAbilityPhase");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetAbilityPhase) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_GetAbilityPhase");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetAbilityPhase, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetAbilityPhase::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetAbilityPhaseDuration
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_GetAbilityPhaseDuration final
{
public:
	EAbilityFlowPhase                             CurrentAbilityPhase;                               // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetAbilityPhaseDuration) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_GetAbilityPhaseDuration");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetAbilityPhaseDuration) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_GetAbilityPhaseDuration");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetAbilityPhaseDuration, CurrentAbilityPhase) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetAbilityPhaseDuration::CurrentAbilityPhase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetAbilityPhaseDuration, ReturnValue) == 0x000004, "Member 'HWGameplayAbility_Enhanced_GetAbilityPhaseDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetAbilityPhaseDurationScale
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_GetAbilityPhaseDurationScale final
{
public:
	EAbilityFlowPhase                             CurrentAbilityPhase;                               // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetAbilityPhaseDurationScale) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_GetAbilityPhaseDurationScale");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetAbilityPhaseDurationScale) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_GetAbilityPhaseDurationScale");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetAbilityPhaseDurationScale, CurrentAbilityPhase) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetAbilityPhaseDurationScale::CurrentAbilityPhase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetAbilityPhaseDurationScale, ReturnValue) == 0x000004, "Member 'HWGameplayAbility_Enhanced_GetAbilityPhaseDurationScale::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetActiveAttackTaskById
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_Enhanced_GetActiveAttackTaskById final
{
public:
	struct FGameplayTag                           AttackIdToGet;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_FireAttack*              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetActiveAttackTaskById) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_GetActiveAttackTaskById");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetActiveAttackTaskById) == 0x000010, "Wrong size on HWGameplayAbility_Enhanced_GetActiveAttackTaskById");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetActiveAttackTaskById, AttackIdToGet) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetActiveAttackTaskById::AttackIdToGet' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetActiveAttackTaskById, ReturnValue) == 0x000008, "Member 'HWGameplayAbility_Enhanced_GetActiveAttackTaskById::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetCachedFiringAbilityPhaseDuration
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_GetCachedFiringAbilityPhaseDuration final
{
public:
	EAbilityFlowPhase                             Phase;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetCachedFiringAbilityPhaseDuration) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_GetCachedFiringAbilityPhaseDuration");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetCachedFiringAbilityPhaseDuration) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_GetCachedFiringAbilityPhaseDuration");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetCachedFiringAbilityPhaseDuration, Phase) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetCachedFiringAbilityPhaseDuration::Phase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetCachedFiringAbilityPhaseDuration, ReturnValue) == 0x000004, "Member 'HWGameplayAbility_Enhanced_GetCachedFiringAbilityPhaseDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetCastStyle
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_GetCastStyle final
{
public:
	EAbilityCastStyle                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetCastStyle) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_GetCastStyle");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetCastStyle) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_GetCastStyle");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetCastStyle, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetCastStyle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetCurrentFiringTargetData
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_Enhanced_GetCurrentFiringTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetCurrentFiringTargetData) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_GetCurrentFiringTargetData");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetCurrentFiringTargetData) == 0x000028, "Wrong size on HWGameplayAbility_Enhanced_GetCurrentFiringTargetData");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetCurrentFiringTargetData, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetCurrentFiringTargetData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetFiringMontageInfo
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_Enhanced_GetFiringMontageInfo final
{
public:
	struct FHWMontageInfo                         ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetFiringMontageInfo) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_GetFiringMontageInfo");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetFiringMontageInfo) == 0x000018, "Wrong size on HWGameplayAbility_Enhanced_GetFiringMontageInfo");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetFiringMontageInfo, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetFiringMontageInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetFiringMontagePlayRate
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayAbility_Enhanced_GetFiringMontagePlayRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetFiringMontagePlayRate) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_GetFiringMontagePlayRate");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetFiringMontagePlayRate) == 0x000004, "Wrong size on HWGameplayAbility_Enhanced_GetFiringMontagePlayRate");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetFiringMontagePlayRate, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetFiringMontagePlayRate::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetFiringMontageStartingSection
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_GetFiringMontageStartingSection final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetFiringMontageStartingSection) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_GetFiringMontageStartingSection");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetFiringMontageStartingSection) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_GetFiringMontageStartingSection");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetFiringMontageStartingSection, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetFiringMontageStartingSection::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetFiringMontageTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_GetFiringMontageTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetFiringMontageTag) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_GetFiringMontageTag");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetFiringMontageTag) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_GetFiringMontageTag");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetFiringMontageTag, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetFiringMontageTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetOverrideCastStyle
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayAbility_Enhanced_GetOverrideCastStyle final
{
public:
	const class AActor*                           Avatar;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityCastStyle                             ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetOverrideCastStyle) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_GetOverrideCastStyle");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetOverrideCastStyle) == 0x000010, "Wrong size on HWGameplayAbility_Enhanced_GetOverrideCastStyle");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetOverrideCastStyle, Avatar) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetOverrideCastStyle::Avatar' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetOverrideCastStyle, ReturnValue) == 0x000008, "Member 'HWGameplayAbility_Enhanced_GetOverrideCastStyle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetTargetingMontageInfo
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayAbility_Enhanced_GetTargetingMontageInfo final
{
public:
	struct FHWMontageInfo                         ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetTargetingMontageInfo) == 0x000008, "Wrong alignment on HWGameplayAbility_Enhanced_GetTargetingMontageInfo");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetTargetingMontageInfo) == 0x000018, "Wrong size on HWGameplayAbility_Enhanced_GetTargetingMontageInfo");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetTargetingMontageInfo, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetTargetingMontageInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetTargetingMontagePlayRate
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayAbility_Enhanced_GetTargetingMontagePlayRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetTargetingMontagePlayRate) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_GetTargetingMontagePlayRate");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetTargetingMontagePlayRate) == 0x000004, "Wrong size on HWGameplayAbility_Enhanced_GetTargetingMontagePlayRate");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetTargetingMontagePlayRate, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetTargetingMontagePlayRate::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetTargetingMontageStartingSection
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_GetTargetingMontageStartingSection final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetTargetingMontageStartingSection) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_GetTargetingMontageStartingSection");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetTargetingMontageStartingSection) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_GetTargetingMontageStartingSection");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetTargetingMontageStartingSection, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetTargetingMontageStartingSection::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetTargetingMontageTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_Enhanced_GetTargetingMontageTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetTargetingMontageTag) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_GetTargetingMontageTag");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetTargetingMontageTag) == 0x000008, "Wrong size on HWGameplayAbility_Enhanced_GetTargetingMontageTag");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetTargetingMontageTag, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetTargetingMontageTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.GetTargetingTimeElapsed
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayAbility_Enhanced_GetTargetingTimeElapsed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_GetTargetingTimeElapsed) == 0x000004, "Wrong alignment on HWGameplayAbility_Enhanced_GetTargetingTimeElapsed");
static_assert(sizeof(HWGameplayAbility_Enhanced_GetTargetingTimeElapsed) == 0x000004, "Wrong size on HWGameplayAbility_Enhanced_GetTargetingTimeElapsed");
static_assert(offsetof(HWGameplayAbility_Enhanced_GetTargetingTimeElapsed, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_GetTargetingTimeElapsed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.IsCastStyleSupported
// 0x0003 (0x0003 - 0x0000)
struct HWGameplayAbility_Enhanced_IsCastStyleSupported final
{
public:
	EAbilityCastStyle                             CastStyleToCheck;                                  // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingGamepad;                                   // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_IsCastStyleSupported) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_IsCastStyleSupported");
static_assert(sizeof(HWGameplayAbility_Enhanced_IsCastStyleSupported) == 0x000003, "Wrong size on HWGameplayAbility_Enhanced_IsCastStyleSupported");
static_assert(offsetof(HWGameplayAbility_Enhanced_IsCastStyleSupported, CastStyleToCheck) == 0x000000, "Member 'HWGameplayAbility_Enhanced_IsCastStyleSupported::CastStyleToCheck' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_IsCastStyleSupported, bIsUsingGamepad) == 0x000001, "Member 'HWGameplayAbility_Enhanced_IsCastStyleSupported::bIsUsingGamepad' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_IsCastStyleSupported, ReturnValue) == 0x000002, "Member 'HWGameplayAbility_Enhanced_IsCastStyleSupported::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.IsContinousFireAbility
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_IsContinousFireAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_IsContinousFireAbility) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_IsContinousFireAbility");
static_assert(sizeof(HWGameplayAbility_Enhanced_IsContinousFireAbility) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_IsContinousFireAbility");
static_assert(offsetof(HWGameplayAbility_Enhanced_IsContinousFireAbility, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_IsContinousFireAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.IsFiring
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_IsFiring final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_IsFiring) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_IsFiring");
static_assert(sizeof(HWGameplayAbility_Enhanced_IsFiring) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_IsFiring");
static_assert(offsetof(HWGameplayAbility_Enhanced_IsFiring, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_IsFiring::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.IsInAbilityPhase
// 0x0002 (0x0002 - 0x0000)
struct HWGameplayAbility_Enhanced_IsInAbilityPhase final
{
public:
	EAbilityFlowPhase                             Phase;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_IsInAbilityPhase) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_IsInAbilityPhase");
static_assert(sizeof(HWGameplayAbility_Enhanced_IsInAbilityPhase) == 0x000002, "Wrong size on HWGameplayAbility_Enhanced_IsInAbilityPhase");
static_assert(offsetof(HWGameplayAbility_Enhanced_IsInAbilityPhase, Phase) == 0x000000, "Member 'HWGameplayAbility_Enhanced_IsInAbilityPhase::Phase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_IsInAbilityPhase, ReturnValue) == 0x000001, "Member 'HWGameplayAbility_Enhanced_IsInAbilityPhase::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.IsInBuildUp
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_IsInBuildUp final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_IsInBuildUp) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_IsInBuildUp");
static_assert(sizeof(HWGameplayAbility_Enhanced_IsInBuildUp) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_IsInBuildUp");
static_assert(offsetof(HWGameplayAbility_Enhanced_IsInBuildUp, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_IsInBuildUp::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.IsInstantFireAbility
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Enhanced_IsInstantFireAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_IsInstantFireAbility) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_IsInstantFireAbility");
static_assert(sizeof(HWGameplayAbility_Enhanced_IsInstantFireAbility) == 0x000001, "Wrong size on HWGameplayAbility_Enhanced_IsInstantFireAbility");
static_assert(offsetof(HWGameplayAbility_Enhanced_IsInstantFireAbility, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_Enhanced_IsInstantFireAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Enhanced.ShouldUseLevelConfigForPhaseTiming
// 0x0002 (0x0002 - 0x0000)
struct HWGameplayAbility_Enhanced_ShouldUseLevelConfigForPhaseTiming final
{
public:
	EAbilityFlowPhase                             Phase;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Enhanced_ShouldUseLevelConfigForPhaseTiming) == 0x000001, "Wrong alignment on HWGameplayAbility_Enhanced_ShouldUseLevelConfigForPhaseTiming");
static_assert(sizeof(HWGameplayAbility_Enhanced_ShouldUseLevelConfigForPhaseTiming) == 0x000002, "Wrong size on HWGameplayAbility_Enhanced_ShouldUseLevelConfigForPhaseTiming");
static_assert(offsetof(HWGameplayAbility_Enhanced_ShouldUseLevelConfigForPhaseTiming, Phase) == 0x000000, "Member 'HWGameplayAbility_Enhanced_ShouldUseLevelConfigForPhaseTiming::Phase' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Enhanced_ShouldUseLevelConfigForPhaseTiming, ReturnValue) == 0x000001, "Member 'HWGameplayAbility_Enhanced_ShouldUseLevelConfigForPhaseTiming::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Agni_A04.ShouldAllowTransitionBackToTargetingPhase
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Agni_A04_ShouldAllowTransitionBackToTargetingPhase final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Agni_A04_ShouldAllowTransitionBackToTargetingPhase) == 0x000001, "Wrong alignment on HWAbility_Agni_A04_ShouldAllowTransitionBackToTargetingPhase");
static_assert(sizeof(HWAbility_Agni_A04_ShouldAllowTransitionBackToTargetingPhase) == 0x000001, "Wrong size on HWAbility_Agni_A04_ShouldAllowTransitionBackToTargetingPhase");
static_assert(offsetof(HWAbility_Agni_A04_ShouldAllowTransitionBackToTargetingPhase, ReturnValue) == 0x000000, "Member 'HWAbility_Agni_A04_ShouldAllowTransitionBackToTargetingPhase::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_CerberusSoul.SetSoulOwner
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_CerberusSoul_SetSoulOwner final
{
public:
	class AHWCharacter_Base*                      NewOwner;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_CerberusSoul_SetSoulOwner) == 0x000008, "Wrong alignment on HWCharacter_CerberusSoul_SetSoulOwner");
static_assert(sizeof(HWCharacter_CerberusSoul_SetSoulOwner) == 0x000008, "Wrong size on HWCharacter_CerberusSoul_SetSoulOwner");
static_assert(offsetof(HWCharacter_CerberusSoul_SetSoulOwner, NewOwner) == 0x000000, "Member 'HWCharacter_CerberusSoul_SetSoulOwner::NewOwner' has a wrong offset!");

// Function Hemingway.HWCharacter_CerberusSoul.GetSoulOwner
// 0x0008 (0x0008 - 0x0000)
struct HWCharacter_CerberusSoul_GetSoulOwner final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_CerberusSoul_GetSoulOwner) == 0x000008, "Wrong alignment on HWCharacter_CerberusSoul_GetSoulOwner");
static_assert(sizeof(HWCharacter_CerberusSoul_GetSoulOwner) == 0x000008, "Wrong size on HWCharacter_CerberusSoul_GetSoulOwner");
static_assert(offsetof(HWCharacter_CerberusSoul_GetSoulOwner, ReturnValue) == 0x000000, "Member 'HWCharacter_CerberusSoul_GetSoulOwner::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Aladdin_A03.ClampWallRunAngle
// 0x0038 (0x0038 - 0x0000)
struct HWAbility_Aladdin_A03_ClampWallRunAngle final
{
public:
	float                                         InitialImpactAngle;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHeight;                                     // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAladdinWallRunPathClampInfo         ClampSettings;                                     // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Aladdin_A03_ClampWallRunAngle) == 0x000008, "Wrong alignment on HWAbility_Aladdin_A03_ClampWallRunAngle");
static_assert(sizeof(HWAbility_Aladdin_A03_ClampWallRunAngle) == 0x000038, "Wrong size on HWAbility_Aladdin_A03_ClampWallRunAngle");
static_assert(offsetof(HWAbility_Aladdin_A03_ClampWallRunAngle, InitialImpactAngle) == 0x000000, "Member 'HWAbility_Aladdin_A03_ClampWallRunAngle::InitialImpactAngle' has a wrong offset!");
static_assert(offsetof(HWAbility_Aladdin_A03_ClampWallRunAngle, CurrentHeight) == 0x000004, "Member 'HWAbility_Aladdin_A03_ClampWallRunAngle::CurrentHeight' has a wrong offset!");
static_assert(offsetof(HWAbility_Aladdin_A03_ClampWallRunAngle, ClampSettings) == 0x000008, "Member 'HWAbility_Aladdin_A03_ClampWallRunAngle::ClampSettings' has a wrong offset!");
static_assert(offsetof(HWAbility_Aladdin_A03_ClampWallRunAngle, ReturnValue) == 0x000030, "Member 'HWAbility_Aladdin_A03_ClampWallRunAngle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Aladdin_A03.GenerateWallRunPath
// 0x0240 (0x0240 - 0x0000)
struct HWAbility_Aladdin_A03_GenerateWallRunPath final
{
public:
	class AHWCharacter_Base*                      Aladdin;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             InitialWallHit;                                    // 0x0008(0x00E8)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHWAladdinWallRunPathClampInfo         ClampSettings;                                     // 0x00F0(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0118(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugPersistTime;                                  // 0x011C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWWallRunPathInfo                     ReturnValue;                                       // 0x0120(0x0120)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Aladdin_A03_GenerateWallRunPath) == 0x000008, "Wrong alignment on HWAbility_Aladdin_A03_GenerateWallRunPath");
static_assert(sizeof(HWAbility_Aladdin_A03_GenerateWallRunPath) == 0x000240, "Wrong size on HWAbility_Aladdin_A03_GenerateWallRunPath");
static_assert(offsetof(HWAbility_Aladdin_A03_GenerateWallRunPath, Aladdin) == 0x000000, "Member 'HWAbility_Aladdin_A03_GenerateWallRunPath::Aladdin' has a wrong offset!");
static_assert(offsetof(HWAbility_Aladdin_A03_GenerateWallRunPath, InitialWallHit) == 0x000008, "Member 'HWAbility_Aladdin_A03_GenerateWallRunPath::InitialWallHit' has a wrong offset!");
static_assert(offsetof(HWAbility_Aladdin_A03_GenerateWallRunPath, ClampSettings) == 0x0000F0, "Member 'HWAbility_Aladdin_A03_GenerateWallRunPath::ClampSettings' has a wrong offset!");
static_assert(offsetof(HWAbility_Aladdin_A03_GenerateWallRunPath, bDrawDebug) == 0x000118, "Member 'HWAbility_Aladdin_A03_GenerateWallRunPath::bDrawDebug' has a wrong offset!");
static_assert(offsetof(HWAbility_Aladdin_A03_GenerateWallRunPath, DebugPersistTime) == 0x00011C, "Member 'HWAbility_Aladdin_A03_GenerateWallRunPath::DebugPersistTime' has a wrong offset!");
static_assert(offsetof(HWAbility_Aladdin_A03_GenerateWallRunPath, ReturnValue) == 0x000120, "Member 'HWAbility_Aladdin_A03_GenerateWallRunPath::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Aladdin_A03.SetWallRunPathInfo
// 0x0120 (0x0120 - 0x0000)
struct HWAbility_Aladdin_A03_SetWallRunPathInfo final
{
public:
	struct FHWWallRunPathInfo                     PathInfo;                                          // 0x0000(0x0120)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Aladdin_A03_SetWallRunPathInfo) == 0x000008, "Wrong alignment on HWAbility_Aladdin_A03_SetWallRunPathInfo");
static_assert(sizeof(HWAbility_Aladdin_A03_SetWallRunPathInfo) == 0x000120, "Wrong size on HWAbility_Aladdin_A03_SetWallRunPathInfo");
static_assert(offsetof(HWAbility_Aladdin_A03_SetWallRunPathInfo, PathInfo) == 0x000000, "Member 'HWAbility_Aladdin_A03_SetWallRunPathInfo::PathInfo' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Core.OnRep_Health
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Core_OnRep_Health final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Core_OnRep_Health) == 0x000008, "Wrong alignment on HWAttributeSet_Core_OnRep_Health");
static_assert(sizeof(HWAttributeSet_Core_OnRep_Health) == 0x000010, "Wrong size on HWAttributeSet_Core_OnRep_Health");
static_assert(offsetof(HWAttributeSet_Core_OnRep_Health, OldValue) == 0x000000, "Member 'HWAttributeSet_Core_OnRep_Health::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Core.OnRep_HealthPerTime
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Core_OnRep_HealthPerTime final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Core_OnRep_HealthPerTime) == 0x000008, "Wrong alignment on HWAttributeSet_Core_OnRep_HealthPerTime");
static_assert(sizeof(HWAttributeSet_Core_OnRep_HealthPerTime) == 0x000010, "Wrong size on HWAttributeSet_Core_OnRep_HealthPerTime");
static_assert(offsetof(HWAttributeSet_Core_OnRep_HealthPerTime, OldValue) == 0x000000, "Member 'HWAttributeSet_Core_OnRep_HealthPerTime::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Core.OnRep_HealthPerTimeBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Core_OnRep_HealthPerTimeBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Core_OnRep_HealthPerTimeBase) == 0x000008, "Wrong alignment on HWAttributeSet_Core_OnRep_HealthPerTimeBase");
static_assert(sizeof(HWAttributeSet_Core_OnRep_HealthPerTimeBase) == 0x000010, "Wrong size on HWAttributeSet_Core_OnRep_HealthPerTimeBase");
static_assert(offsetof(HWAttributeSet_Core_OnRep_HealthPerTimeBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Core_OnRep_HealthPerTimeBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Core.OnRep_HealthPerTimeItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Core_OnRep_HealthPerTimeItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Core_OnRep_HealthPerTimeItem) == 0x000008, "Wrong alignment on HWAttributeSet_Core_OnRep_HealthPerTimeItem");
static_assert(sizeof(HWAttributeSet_Core_OnRep_HealthPerTimeItem) == 0x000010, "Wrong size on HWAttributeSet_Core_OnRep_HealthPerTimeItem");
static_assert(offsetof(HWAttributeSet_Core_OnRep_HealthPerTimeItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Core_OnRep_HealthPerTimeItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Core.OnRep_MaxHealth
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Core_OnRep_MaxHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Core_OnRep_MaxHealth) == 0x000008, "Wrong alignment on HWAttributeSet_Core_OnRep_MaxHealth");
static_assert(sizeof(HWAttributeSet_Core_OnRep_MaxHealth) == 0x000010, "Wrong size on HWAttributeSet_Core_OnRep_MaxHealth");
static_assert(offsetof(HWAttributeSet_Core_OnRep_MaxHealth, OldValue) == 0x000000, "Member 'HWAttributeSet_Core_OnRep_MaxHealth::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Core.OnRep_MaxHealthBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Core_OnRep_MaxHealthBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Core_OnRep_MaxHealthBase) == 0x000008, "Wrong alignment on HWAttributeSet_Core_OnRep_MaxHealthBase");
static_assert(sizeof(HWAttributeSet_Core_OnRep_MaxHealthBase) == 0x000010, "Wrong size on HWAttributeSet_Core_OnRep_MaxHealthBase");
static_assert(offsetof(HWAttributeSet_Core_OnRep_MaxHealthBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Core_OnRep_MaxHealthBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Core.OnRep_MaxHealthItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Core_OnRep_MaxHealthItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Core_OnRep_MaxHealthItem) == 0x000008, "Wrong alignment on HWAttributeSet_Core_OnRep_MaxHealthItem");
static_assert(sizeof(HWAttributeSet_Core_OnRep_MaxHealthItem) == 0x000010, "Wrong size on HWAttributeSet_Core_OnRep_MaxHealthItem");
static_assert(offsetof(HWAttributeSet_Core_OnRep_MaxHealthItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Core_OnRep_MaxHealthItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Core.IsDebugImmuneFromDamage
// 0x0001 (0x0001 - 0x0000)
struct HWAttributeSet_Core_IsDebugImmuneFromDamage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Core_IsDebugImmuneFromDamage) == 0x000001, "Wrong alignment on HWAttributeSet_Core_IsDebugImmuneFromDamage");
static_assert(sizeof(HWAttributeSet_Core_IsDebugImmuneFromDamage) == 0x000001, "Wrong size on HWAttributeSet_Core_IsDebugImmuneFromDamage");
static_assert(offsetof(HWAttributeSet_Core_IsDebugImmuneFromDamage, ReturnValue) == 0x000000, "Member 'HWAttributeSet_Core_IsDebugImmuneFromDamage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_AbilityCostReductionPercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_AbilityCostReductionPercentBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_AbilityCostReductionPercentItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_AbilityCostReductionPercentItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_AttackSpeed
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_AttackSpeed final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_AttackSpeed) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_AttackSpeed");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_AttackSpeed) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_AttackSpeed");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_AttackSpeed, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_AttackSpeed::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_BaseAttackSpeed
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_BaseAttackSpeed final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_BaseAttackSpeed) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_BaseAttackSpeed");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_BaseAttackSpeed) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_BaseAttackSpeed");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_BaseAttackSpeed, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_BaseAttackSpeed::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CooldownRate
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CooldownRate final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CooldownRate) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CooldownRate");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CooldownRate) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CooldownRate");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CooldownRate, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CooldownRate::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CooldownRateBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CooldownRateBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CooldownRateBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CooldownRateBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CooldownRateBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CooldownRateBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CooldownRateBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CooldownRateBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CooldownRateItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CooldownRateItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CooldownRateItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CooldownRateItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CooldownRateItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CooldownRateItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CooldownRateItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CooldownRateItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CritChancePercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CritChancePercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CritChancePercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CritChancePercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CritChancePercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CritChancePercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CritChancePercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CritChancePercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CritChancePercentBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CritChancePercentBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CritChancePercentBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CritChancePercentBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CritChancePercentBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CritChancePercentBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CritChancePercentBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CritChancePercentBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CritChancePercentItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CritChancePercentItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CritChancePercentItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CritChancePercentItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CritChancePercentItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CritChancePercentItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CritChancePercentItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CritChancePercentItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CrowdControlReductionFlat
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlat final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlat) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlat");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlat) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlat");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlat, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlat::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CrowdControlReductionFlatBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CrowdControlReductionFlatItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CrowdControlReductionFlatItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CrowdControlReductionPercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CrowdControlReductionPercentBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CrowdControlReductionPercentFromDR
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentFromDR final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentFromDR) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentFromDR");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentFromDR) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentFromDR");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentFromDR, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentFromDR::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_CrowdControlReductionPercentItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_CrowdControlReductionPercentItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageDealtFlatModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageDealtFlatModifierBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageDealtFlatModifierItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageDealtFlatModifierItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageDealtPercentModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageDealtPercentModifierBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageDealtPercentModifierItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageDealtPercentModifierItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageTakenFlatModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageTakenFlatModifierBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageTakenFlatModifierItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageTakenFlatModifierItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageTakenPercentModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageTakenPercentModifierBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_DamageTakenPercentModifierItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_DamageTakenPercentModifierItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_Gold
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_Gold final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_Gold) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_Gold");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_Gold) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_Gold");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_Gold, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_Gold::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_GoldPerTime
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_GoldPerTime final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_GoldPerTime) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_GoldPerTime");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_GoldPerTime) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_GoldPerTime");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_GoldPerTime, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_GoldPerTime::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_GroundSpeedBackpedalPercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_GroundSpeedBackpedalPercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_GroundSpeedBackpedalPercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_GroundSpeedBackpedalPercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_GroundSpeedBackpedalPercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_GroundSpeedBackpedalPercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_GroundSpeedBackpedalPercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_GroundSpeedBackpedalPercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_GroundSpeedForwardPercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_GroundSpeedForwardPercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_GroundSpeedForwardPercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_GroundSpeedForwardPercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_GroundSpeedForwardPercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_GroundSpeedForwardPercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_GroundSpeedForwardPercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_GroundSpeedForwardPercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_GroundSpeedStrafePercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_GroundSpeedStrafePercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_GroundSpeedStrafePercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_GroundSpeedStrafePercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_GroundSpeedStrafePercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_GroundSpeedStrafePercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_GroundSpeedStrafePercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_GroundSpeedStrafePercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_HealingDealtPercentModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_HealingDealtPercentModifierBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_HealingDealtPercentModifierItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_HealingDealtPercentModifierItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_HealingTakenPercentModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_HealingTakenPercentModifierBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_HealingTakenPercentModifierItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_HealingTakenPercentModifierItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_InhandMoveSpeedPenaltyPercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_InhandMoveSpeedPenaltyPercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_InhandMoveSpeedPenaltyPercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_InhandMoveSpeedPenaltyPercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_InhandMoveSpeedPenaltyPercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_InhandMoveSpeedPenaltyPercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_InhandMoveSpeedPenaltyPercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_InhandMoveSpeedPenaltyPercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_InhandPower
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_InhandPower final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_InhandPower) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_InhandPower");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_InhandPower) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_InhandPower");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_InhandPower, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_InhandPower::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_InhandPowerBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_InhandPowerBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_InhandPowerBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_InhandPowerBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_InhandPowerBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_InhandPowerBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_InhandPowerBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_InhandPowerBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_InhandPowerItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_InhandPowerItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_InhandPowerItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_InhandPowerItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_InhandPowerItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_InhandPowerItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_InhandPowerItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_InhandPowerItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_InhandProjectileSpeedModifierPercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_InhandProjectileSpeedModifierPercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_InhandProjectileSpeedModifierPercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_InhandProjectileSpeedModifierPercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_InhandProjectileSpeedModifierPercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_InhandProjectileSpeedModifierPercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_InhandProjectileSpeedModifierPercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_InhandProjectileSpeedModifierPercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_IntoxicatedAccelerationForce
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_IntoxicatedAccelerationForce final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_IntoxicatedAccelerationForce) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_IntoxicatedAccelerationForce");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_IntoxicatedAccelerationForce) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_IntoxicatedAccelerationForce");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_IntoxicatedAccelerationForce, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_IntoxicatedAccelerationForce::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_IntoxicatedInterval
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_IntoxicatedInterval final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_IntoxicatedInterval) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_IntoxicatedInterval");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_IntoxicatedInterval) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_IntoxicatedInterval");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_IntoxicatedInterval, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_IntoxicatedInterval::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_IntoxicatedMaxPitchRotation
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxPitchRotation final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxPitchRotation) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxPitchRotation");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxPitchRotation) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxPitchRotation");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxPitchRotation, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxPitchRotation::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_IntoxicatedMaxStrafeDuration
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxStrafeDuration final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxStrafeDuration) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxStrafeDuration");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxStrafeDuration) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxStrafeDuration");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxStrafeDuration, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxStrafeDuration::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_IntoxicatedMaxYawRotation
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxYawRotation final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxYawRotation) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxYawRotation");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxYawRotation) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxYawRotation");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxYawRotation, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_IntoxicatedMaxYawRotation::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_IntoxicatedMinStrafeDuration
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_IntoxicatedMinStrafeDuration final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMinStrafeDuration) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_IntoxicatedMinStrafeDuration");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMinStrafeDuration) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_IntoxicatedMinStrafeDuration");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_IntoxicatedMinStrafeDuration, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_IntoxicatedMinStrafeDuration::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_IntoxicatedOrder
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_IntoxicatedOrder final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_IntoxicatedOrder) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_IntoxicatedOrder");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_IntoxicatedOrder) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_IntoxicatedOrder");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_IntoxicatedOrder, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_IntoxicatedOrder::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_Level
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_Level final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_Level) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_Level");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_Level) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_Level");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_Level, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_Level::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_LifeStealPercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_LifeStealPercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_LifeStealPercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_LifeStealPercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_LifeStealPercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_LifeStealPercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_LifeStealPercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_LifeStealPercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_LifeStealPercentBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_LifeStealPercentBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_LifeStealPercentBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_LifeStealPercentBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_LifeStealPercentBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_LifeStealPercentBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_LifeStealPercentBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_LifeStealPercentBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_LifeStealPercentItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_LifeStealPercentItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_LifeStealPercentItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_LifeStealPercentItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_LifeStealPercentItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_LifeStealPercentItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_LifeStealPercentItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_LifeStealPercentItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalPenetrationFlat
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlat final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlat) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlat");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlat) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlat");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlat, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlat::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalPenetrationFlatBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalPenetrationFlatItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalPenetrationFlatItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalPenetrationPercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalPenetrationPercentBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalPenetrationPercentItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalPenetrationPercentItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalPower
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalPower final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalPower) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalPower");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalPower) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalPower");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalPower, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalPower::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalPowerBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalPowerBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalPowerBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalPowerBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalPowerBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalPowerBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalPowerBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalPowerBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalPowerItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalPowerItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalPowerItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalPowerItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalPowerItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalPowerItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalPowerItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalPowerItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalProtection
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalProtection final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalProtection) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalProtection");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalProtection) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalProtection");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalProtection, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalProtection::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalProtectionBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalProtectionBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalProtectionBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalProtectionBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalProtectionBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalProtectionBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalProtectionBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalProtectionBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MagicalProtectionItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MagicalProtectionItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MagicalProtectionItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MagicalProtectionItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MagicalProtectionItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MagicalProtectionItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MagicalProtectionItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MagicalProtectionItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_Mana
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_Mana final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_Mana) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_Mana");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_Mana) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_Mana");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_Mana, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_Mana::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_ManaPerTime
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_ManaPerTime final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_ManaPerTime) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_ManaPerTime");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_ManaPerTime) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_ManaPerTime");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_ManaPerTime, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_ManaPerTime::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_ManaPerTimeBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_ManaPerTimeBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_ManaPerTimeBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_ManaPerTimeBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_ManaPerTimeBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_ManaPerTimeBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_ManaPerTimeBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_ManaPerTimeBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_ManaPerTimeItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_ManaPerTimeItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_ManaPerTimeItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_ManaPerTimeItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_ManaPerTimeItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_ManaPerTimeItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_ManaPerTimeItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_ManaPerTimeItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MaxMana
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MaxMana final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MaxMana) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MaxMana");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MaxMana) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MaxMana");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MaxMana, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MaxMana::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MaxManaBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MaxManaBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MaxManaBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MaxManaBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MaxManaBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MaxManaBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MaxManaBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MaxManaBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_MaxManaItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_MaxManaItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_MaxManaItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_MaxManaItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_MaxManaItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_MaxManaItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_MaxManaItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_MaxManaItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalPenetrationFlat
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlat final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlat) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlat");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlat) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlat");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlat, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlat::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalPenetrationFlatBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalPenetrationFlatItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationFlatItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalPenetrationPercent
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercent final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercent) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercent");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercent) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercent");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercent, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercent::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalPenetrationPercentBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalPenetrationPercentItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalPenetrationPercentItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalPower
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalPower final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalPower) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalPower");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalPower) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalPower");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalPower, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalPower::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalPowerBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalPowerBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalPowerBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalPowerBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalPowerBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalPowerBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalPowerBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalPowerBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalPowerItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalPowerItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalPowerItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalPowerItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalPowerItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalPowerItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalPowerItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalPowerItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalProtection
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalProtection final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalProtection) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalProtection");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalProtection) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalProtection");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalProtection, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalProtection::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalProtectionBase
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalProtectionBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalProtectionBase) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalProtectionBase");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalProtectionBase) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalProtectionBase");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalProtectionBase, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalProtectionBase::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_PhysicalProtectionItem
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_PhysicalProtectionItem final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_PhysicalProtectionItem) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_PhysicalProtectionItem");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_PhysicalProtectionItem) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_PhysicalProtectionItem");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_PhysicalProtectionItem, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_PhysicalProtectionItem::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_RevealRangeFlatModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_RevealRangeFlatModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_RevealRangeFlatModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_RevealRangeFlatModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_RevealRangeFlatModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_RevealRangeFlatModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_RevealRangeFlatModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_RevealRangeFlatModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_RevealRangePercentModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_RevealRangePercentModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_RevealRangePercentModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_RevealRangePercentModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_RevealRangePercentModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_RevealRangePercentModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_RevealRangePercentModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_RevealRangePercentModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_SkillPoint
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_SkillPoint final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_SkillPoint) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_SkillPoint");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_SkillPoint) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_SkillPoint");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_SkillPoint, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_SkillPoint::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_VisionRangeFlatModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_VisionRangeFlatModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_VisionRangeFlatModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_VisionRangeFlatModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_VisionRangeFlatModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_VisionRangeFlatModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_VisionRangeFlatModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_VisionRangeFlatModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_VisionRangePercentModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_VisionRangePercentModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_VisionRangePercentModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_VisionRangePercentModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_VisionRangePercentModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_VisionRangePercentModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_VisionRangePercentModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_VisionRangePercentModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_XP
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_XP final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_XP) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_XP");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_XP) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_XP");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_XP, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_XP::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_XPFlatModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_XPFlatModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_XPFlatModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_XPFlatModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_XPFlatModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_XPFlatModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_XPFlatModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_XPFlatModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_XPPercentModifier
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_XPPercentModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_XPPercentModifier) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_XPPercentModifier");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_XPPercentModifier) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_XPPercentModifier");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_XPPercentModifier, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_XPPercentModifier::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Character_Base.OnRep_XPPerTime
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Character_Base_OnRep_XPPerTime final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Character_Base_OnRep_XPPerTime) == 0x000008, "Wrong alignment on HWAttributeSet_Character_Base_OnRep_XPPerTime");
static_assert(sizeof(HWAttributeSet_Character_Base_OnRep_XPPerTime) == 0x000010, "Wrong size on HWAttributeSet_Character_Base_OnRep_XPPerTime");
static_assert(offsetof(HWAttributeSet_Character_Base_OnRep_XPPerTime, OldValue) == 0x000000, "Member 'HWAttributeSet_Character_Base_OnRep_XPPerTime::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_God.OnRep_Hysteria
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_God_OnRep_Hysteria final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_God_OnRep_Hysteria) == 0x000008, "Wrong alignment on HWAttributeSet_God_OnRep_Hysteria");
static_assert(sizeof(HWAttributeSet_God_OnRep_Hysteria) == 0x000010, "Wrong size on HWAttributeSet_God_OnRep_Hysteria");
static_assert(offsetof(HWAttributeSet_God_OnRep_Hysteria, OldValue) == 0x000000, "Member 'HWAttributeSet_God_OnRep_Hysteria::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Poseidon.OnRep_Tide
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Poseidon_OnRep_Tide final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Poseidon_OnRep_Tide) == 0x000008, "Wrong alignment on HWAttributeSet_Poseidon_OnRep_Tide");
static_assert(sizeof(HWAttributeSet_Poseidon_OnRep_Tide) == 0x000010, "Wrong size on HWAttributeSet_Poseidon_OnRep_Tide");
static_assert(offsetof(HWAttributeSet_Poseidon_OnRep_Tide, OldValue) == 0x000000, "Member 'HWAttributeSet_Poseidon_OnRep_Tide::OldValue' has a wrong offset!");

// Function Hemingway.HWAbility_Amaterasu_A02.HandleOnPawnControllerChanged
// 0x0018 (0x0018 - 0x0000)
struct HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OldController;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            NewController;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged) == 0x000008, "Wrong alignment on HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged");
static_assert(sizeof(HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged) == 0x000018, "Wrong size on HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged");
static_assert(offsetof(HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged, Pawn) == 0x000000, "Member 'HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged::Pawn' has a wrong offset!");
static_assert(offsetof(HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged, OldController) == 0x000008, "Member 'HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged::OldController' has a wrong offset!");
static_assert(offsetof(HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged, NewController) == 0x000010, "Member 'HWAbility_Amaterasu_A02_HandleOnPawnControllerChanged::NewController' has a wrong offset!");

// Function Hemingway.HWAbility_Amaterasu_A02.HandleTagUpdated_AmaA02RefireEnabled
// 0x000C (0x000C - 0x0000)
struct HWAbility_Amaterasu_A02_HandleTagUpdated_AmaA02RefireEnabled final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Amaterasu_A02_HandleTagUpdated_AmaA02RefireEnabled) == 0x000004, "Wrong alignment on HWAbility_Amaterasu_A02_HandleTagUpdated_AmaA02RefireEnabled");
static_assert(sizeof(HWAbility_Amaterasu_A02_HandleTagUpdated_AmaA02RefireEnabled) == 0x00000C, "Wrong size on HWAbility_Amaterasu_A02_HandleTagUpdated_AmaA02RefireEnabled");
static_assert(offsetof(HWAbility_Amaterasu_A02_HandleTagUpdated_AmaA02RefireEnabled, CallbackTag) == 0x000000, "Member 'HWAbility_Amaterasu_A02_HandleTagUpdated_AmaA02RefireEnabled::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWAbility_Amaterasu_A02_HandleTagUpdated_AmaA02RefireEnabled, NewCount) == 0x000008, "Member 'HWAbility_Amaterasu_A02_HandleTagUpdated_AmaA02RefireEnabled::NewCount' has a wrong offset!");

// Function Hemingway.HWAbility_Amaterasu_A02.OnAdjustBaseDamageToTarget
// 0x00C0 (0x00C0 - 0x0000)
struct HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget final
{
public:
	struct FGameplayTagContainer                  EffectTags;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FDamageCalcInfo                        DamageCalcInfo;                                    // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              BroadcastingAbilitySystemComponent;                // 0x00B0(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWAdjustAttributeEventType                   AdjustAttributeEventType;                          // 0x00B8(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDamageValue;                                   // 0x00BC(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget) == 0x000008, "Wrong alignment on HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget");
static_assert(sizeof(HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget) == 0x0000C0, "Wrong size on HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget");
static_assert(offsetof(HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget, EffectTags) == 0x000000, "Member 'HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget::EffectTags' has a wrong offset!");
static_assert(offsetof(HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget, DamageCalcInfo) == 0x000020, "Member 'HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget::DamageCalcInfo' has a wrong offset!");
static_assert(offsetof(HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget, BroadcastingAbilitySystemComponent) == 0x0000B0, "Member 'HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget::BroadcastingAbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget, AdjustAttributeEventType) == 0x0000B8, "Member 'HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget::AdjustAttributeEventType' has a wrong offset!");
static_assert(offsetof(HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget, BaseDamageValue) == 0x0000BC, "Member 'HWAbility_Amaterasu_A02_OnAdjustBaseDamageToTarget::BaseDamageValue' has a wrong offset!");

// Function Hemingway.HWAbility_Amaterasu_A02.SetPlayFiringMontage
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Amaterasu_A02_SetPlayFiringMontage final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Amaterasu_A02_SetPlayFiringMontage) == 0x000001, "Wrong alignment on HWAbility_Amaterasu_A02_SetPlayFiringMontage");
static_assert(sizeof(HWAbility_Amaterasu_A02_SetPlayFiringMontage) == 0x000001, "Wrong size on HWAbility_Amaterasu_A02_SetPlayFiringMontage");
static_assert(offsetof(HWAbility_Amaterasu_A02_SetPlayFiringMontage, bValue) == 0x000000, "Member 'HWAbility_Amaterasu_A02_SetPlayFiringMontage::bValue' has a wrong offset!");

// Function Hemingway.HWAbility_Amaterasu_A02.StoreDamage
// 0x0070 (0x0070 - 0x0000)
struct HWAbility_Amaterasu_A02_StoreDamage final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Amaterasu_A02_StoreDamage) == 0x000008, "Wrong alignment on HWAbility_Amaterasu_A02_StoreDamage");
static_assert(sizeof(HWAbility_Amaterasu_A02_StoreDamage) == 0x000070, "Wrong size on HWAbility_Amaterasu_A02_StoreDamage");
static_assert(offsetof(HWAbility_Amaterasu_A02_StoreDamage, DamageEventData) == 0x000000, "Member 'HWAbility_Amaterasu_A02_StoreDamage::DamageEventData' has a wrong offset!");

// Function Hemingway.HWAbility_Amaterasu_A02.StoreDealtDamage
// 0x0070 (0x0070 - 0x0000)
struct HWAbility_Amaterasu_A02_StoreDealtDamage final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Amaterasu_A02_StoreDealtDamage) == 0x000008, "Wrong alignment on HWAbility_Amaterasu_A02_StoreDealtDamage");
static_assert(sizeof(HWAbility_Amaterasu_A02_StoreDealtDamage) == 0x000070, "Wrong size on HWAbility_Amaterasu_A02_StoreDealtDamage");
static_assert(offsetof(HWAbility_Amaterasu_A02_StoreDealtDamage, DamageEventData) == 0x000000, "Member 'HWAbility_Amaterasu_A02_StoreDealtDamage::DamageEventData' has a wrong offset!");

// Function Hemingway.HWChatManager.SendPlayerChatEntry
// 0x0060 (0x0060 - 0x0000)
struct HWChatManager_SendPlayerChatEntry final
{
public:
	struct FHWChatEntry                           ChatEntry;                                         // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWChatManager_SendPlayerChatEntry) == 0x000008, "Wrong alignment on HWChatManager_SendPlayerChatEntry");
static_assert(sizeof(HWChatManager_SendPlayerChatEntry) == 0x000060, "Wrong size on HWChatManager_SendPlayerChatEntry");
static_assert(offsetof(HWChatManager_SendPlayerChatEntry, ChatEntry) == 0x000000, "Member 'HWChatManager_SendPlayerChatEntry::ChatEntry' has a wrong offset!");

// Function Hemingway.HWChatManager.IsPlayerChatEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWChatManager_IsPlayerChatEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWChatManager_IsPlayerChatEnabled) == 0x000001, "Wrong alignment on HWChatManager_IsPlayerChatEnabled");
static_assert(sizeof(HWChatManager_IsPlayerChatEnabled) == 0x000001, "Wrong size on HWChatManager_IsPlayerChatEnabled");
static_assert(offsetof(HWChatManager_IsPlayerChatEnabled, ReturnValue) == 0x000000, "Member 'HWChatManager_IsPlayerChatEnabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWChatManager.MulticastSendChatEntry
// 0x0060 (0x0060 - 0x0000)
struct HWChatManager_MulticastSendChatEntry final
{
public:
	struct FHWChatEntry                           ChatEntry;                                         // 0x0000(0x0060)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWChatManager_MulticastSendChatEntry) == 0x000008, "Wrong alignment on HWChatManager_MulticastSendChatEntry");
static_assert(sizeof(HWChatManager_MulticastSendChatEntry) == 0x000060, "Wrong size on HWChatManager_MulticastSendChatEntry");
static_assert(offsetof(HWChatManager_MulticastSendChatEntry, ChatEntry) == 0x000000, "Member 'HWChatManager_MulticastSendChatEntry::ChatEntry' has a wrong offset!");

// Function Hemingway.HWChatManager.SendChatEntry
// 0x0060 (0x0060 - 0x0000)
struct HWChatManager_SendChatEntry final
{
public:
	struct FHWChatEntry                           ChatEntry;                                         // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWChatManager_SendChatEntry) == 0x000008, "Wrong alignment on HWChatManager_SendChatEntry");
static_assert(sizeof(HWChatManager_SendChatEntry) == 0x000060, "Wrong size on HWChatManager_SendChatEntry");
static_assert(offsetof(HWChatManager_SendChatEntry, ChatEntry) == 0x000000, "Member 'HWChatManager_SendChatEntry::ChatEntry' has a wrong offset!");

// Function Hemingway.HWChatManager.SendSystemMessageEntry
// 0x0028 (0x0028 - 0x0000)
struct HWChatManager_SendSystemMessageEntry final
{
public:
	struct FGameplayTag                           MessageTag;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         ExclusiveToTeam;                                   // 0x0008(0x0001)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ExclusiveToPlayer;                                 // 0x000C(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UObject*                          MessageContext;                                    // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWChatManager_SendSystemMessageEntry) == 0x000008, "Wrong alignment on HWChatManager_SendSystemMessageEntry");
static_assert(sizeof(HWChatManager_SendSystemMessageEntry) == 0x000028, "Wrong size on HWChatManager_SendSystemMessageEntry");
static_assert(offsetof(HWChatManager_SendSystemMessageEntry, MessageTag) == 0x000000, "Member 'HWChatManager_SendSystemMessageEntry::MessageTag' has a wrong offset!");
static_assert(offsetof(HWChatManager_SendSystemMessageEntry, ExclusiveToTeam) == 0x000008, "Member 'HWChatManager_SendSystemMessageEntry::ExclusiveToTeam' has a wrong offset!");
static_assert(offsetof(HWChatManager_SendSystemMessageEntry, ExclusiveToPlayer) == 0x00000C, "Member 'HWChatManager_SendSystemMessageEntry::ExclusiveToPlayer' has a wrong offset!");
static_assert(offsetof(HWChatManager_SendSystemMessageEntry, MessageContext) == 0x000020, "Member 'HWChatManager_SendSystemMessageEntry::MessageContext' has a wrong offset!");

// Function Hemingway.HWDeployable.HandleTagUpdated_InstigatorDied
// 0x000C (0x000C - 0x0000)
struct HWDeployable_HandleTagUpdated_InstigatorDied final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_HandleTagUpdated_InstigatorDied) == 0x000004, "Wrong alignment on HWDeployable_HandleTagUpdated_InstigatorDied");
static_assert(sizeof(HWDeployable_HandleTagUpdated_InstigatorDied) == 0x00000C, "Wrong size on HWDeployable_HandleTagUpdated_InstigatorDied");
static_assert(offsetof(HWDeployable_HandleTagUpdated_InstigatorDied, CallbackTag) == 0x000000, "Member 'HWDeployable_HandleTagUpdated_InstigatorDied::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWDeployable_HandleTagUpdated_InstigatorDied, NewCount) == 0x000008, "Member 'HWDeployable_HandleTagUpdated_InstigatorDied::NewCount' has a wrong offset!");

// Function Hemingway.HWDeployable.HandleTagUpdated_OwnerDied
// 0x000C (0x000C - 0x0000)
struct HWDeployable_HandleTagUpdated_OwnerDied final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_HandleTagUpdated_OwnerDied) == 0x000004, "Wrong alignment on HWDeployable_HandleTagUpdated_OwnerDied");
static_assert(sizeof(HWDeployable_HandleTagUpdated_OwnerDied) == 0x00000C, "Wrong size on HWDeployable_HandleTagUpdated_OwnerDied");
static_assert(offsetof(HWDeployable_HandleTagUpdated_OwnerDied, CallbackTag) == 0x000000, "Member 'HWDeployable_HandleTagUpdated_OwnerDied::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWDeployable_HandleTagUpdated_OwnerDied, NewCount) == 0x000008, "Member 'HWDeployable_HandleTagUpdated_OwnerDied::NewCount' has a wrong offset!");

// Function Hemingway.HWDeployable.OnRep_CurrentVisualPhase
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_OnRep_CurrentVisualPhase final
{
public:
	EAbilityFlowPhase                             OldPhase;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_OnRep_CurrentVisualPhase) == 0x000001, "Wrong alignment on HWDeployable_OnRep_CurrentVisualPhase");
static_assert(sizeof(HWDeployable_OnRep_CurrentVisualPhase) == 0x000001, "Wrong size on HWDeployable_OnRep_CurrentVisualPhase");
static_assert(offsetof(HWDeployable_OnRep_CurrentVisualPhase, OldPhase) == 0x000000, "Member 'HWDeployable_OnRep_CurrentVisualPhase::OldPhase' has a wrong offset!");

// Function Hemingway.HWDeployable.OnRep_RepositionData
// 0x0038 (0x0038 - 0x0000)
struct HWDeployable_OnRep_RepositionData final
{
public:
	struct FHWDeployableRepositionData            OldRepositionData;                                 // 0x0000(0x0038)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_OnRep_RepositionData) == 0x000008, "Wrong alignment on HWDeployable_OnRep_RepositionData");
static_assert(sizeof(HWDeployable_OnRep_RepositionData) == 0x000038, "Wrong size on HWDeployable_OnRep_RepositionData");
static_assert(offsetof(HWDeployable_OnRep_RepositionData, OldRepositionData) == 0x000000, "Member 'HWDeployable_OnRep_RepositionData::OldRepositionData' has a wrong offset!");

// Function Hemingway.HWDeployable.SetDeployableLevel
// 0x0004 (0x0004 - 0x0000)
struct HWDeployable_SetDeployableLevel final
{
public:
	float                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_SetDeployableLevel) == 0x000004, "Wrong alignment on HWDeployable_SetDeployableLevel");
static_assert(sizeof(HWDeployable_SetDeployableLevel) == 0x000004, "Wrong size on HWDeployable_SetDeployableLevel");
static_assert(offsetof(HWDeployable_SetDeployableLevel, Level) == 0x000000, "Member 'HWDeployable_SetDeployableLevel::Level' has a wrong offset!");

// Function Hemingway.HWDeployable.SetDeployablePhase
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_SetDeployablePhase final
{
public:
	EAbilityFlowPhase                             Phase;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_SetDeployablePhase) == 0x000001, "Wrong alignment on HWDeployable_SetDeployablePhase");
static_assert(sizeof(HWDeployable_SetDeployablePhase) == 0x000001, "Wrong size on HWDeployable_SetDeployablePhase");
static_assert(offsetof(HWDeployable_SetDeployablePhase, Phase) == 0x000000, "Member 'HWDeployable_SetDeployablePhase::Phase' has a wrong offset!");

// Function Hemingway.HWDeployable.StartDestroy
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_StartDestroy final
{
public:
	bool                                          bSkipTimeAfterDeath;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_StartDestroy) == 0x000001, "Wrong alignment on HWDeployable_StartDestroy");
static_assert(sizeof(HWDeployable_StartDestroy) == 0x000001, "Wrong size on HWDeployable_StartDestroy");
static_assert(offsetof(HWDeployable_StartDestroy, bSkipTimeAfterDeath) == 0x000000, "Member 'HWDeployable_StartDestroy::bSkipTimeAfterDeath' has a wrong offset!");

// Function Hemingway.HWDeployable.CalcHighlightingTargetList
// 0x0070 (0x0070 - 0x0000)
struct HWDeployable_CalcHighlightingTargetList final
{
public:
	struct FHWAttackTargetingInfo                 TargetingInfo;                                     // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetListDataHandle;                              // 0x0048(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_CalcHighlightingTargetList) == 0x000008, "Wrong alignment on HWDeployable_CalcHighlightingTargetList");
static_assert(sizeof(HWDeployable_CalcHighlightingTargetList) == 0x000070, "Wrong size on HWDeployable_CalcHighlightingTargetList");
static_assert(offsetof(HWDeployable_CalcHighlightingTargetList, TargetingInfo) == 0x000000, "Member 'HWDeployable_CalcHighlightingTargetList::TargetingInfo' has a wrong offset!");
static_assert(offsetof(HWDeployable_CalcHighlightingTargetList, TargetListDataHandle) == 0x000048, "Member 'HWDeployable_CalcHighlightingTargetList::TargetListDataHandle' has a wrong offset!");

// Function Hemingway.HWDeployable.GetAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_GetAbilitySystemComponent final
{
public:
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_GetAbilitySystemComponent) == 0x000008, "Wrong alignment on HWDeployable_GetAbilitySystemComponent");
static_assert(sizeof(HWDeployable_GetAbilitySystemComponent) == 0x000008, "Wrong size on HWDeployable_GetAbilitySystemComponent");
static_assert(offsetof(HWDeployable_GetAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWDeployable_GetAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable.GetApparelComponent
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_GetApparelComponent final
{
public:
	class UHWApparelComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_GetApparelComponent) == 0x000008, "Wrong alignment on HWDeployable_GetApparelComponent");
static_assert(sizeof(HWDeployable_GetApparelComponent) == 0x000008, "Wrong size on HWDeployable_GetApparelComponent");
static_assert(offsetof(HWDeployable_GetApparelComponent, ReturnValue) == 0x000000, "Member 'HWDeployable_GetApparelComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable.GetCurrentSkin
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_GetCurrentSkin final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_GetCurrentSkin) == 0x000008, "Wrong alignment on HWDeployable_GetCurrentSkin");
static_assert(sizeof(HWDeployable_GetCurrentSkin) == 0x000008, "Wrong size on HWDeployable_GetCurrentSkin");
static_assert(offsetof(HWDeployable_GetCurrentSkin, ReturnValue) == 0x000000, "Member 'HWDeployable_GetCurrentSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable.GetDeployableLevel
// 0x0004 (0x0004 - 0x0000)
struct HWDeployable_GetDeployableLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_GetDeployableLevel) == 0x000004, "Wrong alignment on HWDeployable_GetDeployableLevel");
static_assert(sizeof(HWDeployable_GetDeployableLevel) == 0x000004, "Wrong size on HWDeployable_GetDeployableLevel");
static_assert(offsetof(HWDeployable_GetDeployableLevel, ReturnValue) == 0x000000, "Member 'HWDeployable_GetDeployableLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable.GetDeployableType
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_GetDeployableType final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_GetDeployableType) == 0x000004, "Wrong alignment on HWDeployable_GetDeployableType");
static_assert(sizeof(HWDeployable_GetDeployableType) == 0x000008, "Wrong size on HWDeployable_GetDeployableType");
static_assert(offsetof(HWDeployable_GetDeployableType, ReturnValue) == 0x000000, "Member 'HWDeployable_GetDeployableType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable.GetFiringInstanceId
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_GetFiringInstanceId final
{
public:
	struct FHWAbilityFiringInstanceId             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_GetFiringInstanceId) == 0x000004, "Wrong alignment on HWDeployable_GetFiringInstanceId");
static_assert(sizeof(HWDeployable_GetFiringInstanceId) == 0x000008, "Wrong size on HWDeployable_GetFiringInstanceId");
static_assert(offsetof(HWDeployable_GetFiringInstanceId, ReturnValue) == 0x000000, "Member 'HWDeployable_GetFiringInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable.GetHWAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_GetHWAbilitySystemComponent final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_GetHWAbilitySystemComponent) == 0x000008, "Wrong alignment on HWDeployable_GetHWAbilitySystemComponent");
static_assert(sizeof(HWDeployable_GetHWAbilitySystemComponent) == 0x000008, "Wrong size on HWDeployable_GetHWAbilitySystemComponent");
static_assert(offsetof(HWDeployable_GetHWAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWDeployable_GetHWAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable.IsSkinningReady
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_IsSkinningReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_IsSkinningReady) == 0x000001, "Wrong alignment on HWDeployable_IsSkinningReady");
static_assert(sizeof(HWDeployable_IsSkinningReady) == 0x000001, "Wrong size on HWDeployable_IsSkinningReady");
static_assert(offsetof(HWDeployable_IsSkinningReady, ReturnValue) == 0x000000, "Member 'HWDeployable_IsSkinningReady::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Passive.OnInternalCooldownRemoved
// 0x0028 (0x0028 - 0x0000)
struct HWAbility_Passive_OnInternalCooldownRemoved final
{
public:
	struct FGameplayEffectRemovalInfo             GameplayEffectRemovalInfo;                         // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Passive_OnInternalCooldownRemoved) == 0x000008, "Wrong alignment on HWAbility_Passive_OnInternalCooldownRemoved");
static_assert(sizeof(HWAbility_Passive_OnInternalCooldownRemoved) == 0x000028, "Wrong size on HWAbility_Passive_OnInternalCooldownRemoved");
static_assert(offsetof(HWAbility_Passive_OnInternalCooldownRemoved, GameplayEffectRemovalInfo) == 0x000000, "Member 'HWAbility_Passive_OnInternalCooldownRemoved::GameplayEffectRemovalInfo' has a wrong offset!");

// Function Hemingway.HWAbility_Passive.IsInternalCooldownActive
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Passive_IsInternalCooldownActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Passive_IsInternalCooldownActive) == 0x000001, "Wrong alignment on HWAbility_Passive_IsInternalCooldownActive");
static_assert(sizeof(HWAbility_Passive_IsInternalCooldownActive) == 0x000001, "Wrong size on HWAbility_Passive_IsInternalCooldownActive");
static_assert(offsetof(HWAbility_Passive_IsInternalCooldownActive, ReturnValue) == 0x000000, "Member 'HWAbility_Passive_IsInternalCooldownActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Buff.ApplyBuffToTarget
// 0x0010 (0x0010 - 0x0000)
struct HWDeployable_Buff_ApplyBuffToTarget final
{
public:
	class AHWCharacter_Base*                      Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDeployable_Buff_ApplyBuffToTarget) == 0x000008, "Wrong alignment on HWDeployable_Buff_ApplyBuffToTarget");
static_assert(sizeof(HWDeployable_Buff_ApplyBuffToTarget) == 0x000010, "Wrong size on HWDeployable_Buff_ApplyBuffToTarget");
static_assert(offsetof(HWDeployable_Buff_ApplyBuffToTarget, Target) == 0x000000, "Member 'HWDeployable_Buff_ApplyBuffToTarget::Target' has a wrong offset!");
static_assert(offsetof(HWDeployable_Buff_ApplyBuffToTarget, ReturnValue) == 0x000008, "Member 'HWDeployable_Buff_ApplyBuffToTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Buff.CanApplyBuffToTarget
// 0x0010 (0x0010 - 0x0000)
struct HWDeployable_Buff_CanApplyBuffToTarget final
{
public:
	const class AHWCharacter_Base*                Target;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDeployable_Buff_CanApplyBuffToTarget) == 0x000008, "Wrong alignment on HWDeployable_Buff_CanApplyBuffToTarget");
static_assert(sizeof(HWDeployable_Buff_CanApplyBuffToTarget) == 0x000010, "Wrong size on HWDeployable_Buff_CanApplyBuffToTarget");
static_assert(offsetof(HWDeployable_Buff_CanApplyBuffToTarget, Target) == 0x000000, "Member 'HWDeployable_Buff_CanApplyBuffToTarget::Target' has a wrong offset!");
static_assert(offsetof(HWDeployable_Buff_CanApplyBuffToTarget, ReturnValue) == 0x000008, "Member 'HWDeployable_Buff_CanApplyBuffToTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Cabrakan_EmpoweredA01_Listener.ConfigureCustomEnhancedA01Context
// 0x0018 (0x0018 - 0x0000)
struct HWAbility_Cabrakan_EmpoweredA01_Listener_ConfigureCustomEnhancedA01Context final
{
public:
	struct FGameplayEffectContextHandle           ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Cabrakan_EmpoweredA01_Listener_ConfigureCustomEnhancedA01Context) == 0x000008, "Wrong alignment on HWAbility_Cabrakan_EmpoweredA01_Listener_ConfigureCustomEnhancedA01Context");
static_assert(sizeof(HWAbility_Cabrakan_EmpoweredA01_Listener_ConfigureCustomEnhancedA01Context) == 0x000018, "Wrong size on HWAbility_Cabrakan_EmpoweredA01_Listener_ConfigureCustomEnhancedA01Context");
static_assert(offsetof(HWAbility_Cabrakan_EmpoweredA01_Listener_ConfigureCustomEnhancedA01Context, ReturnValue) == 0x000000, "Member 'HWAbility_Cabrakan_EmpoweredA01_Listener_ConfigureCustomEnhancedA01Context::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Leap.OnLeapEnded
// 0x0018 (0x0018 - 0x0000)
struct HWAbility_Leap_OnLeapEnded final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Leap_OnLeapEnded) == 0x000008, "Wrong alignment on HWAbility_Leap_OnLeapEnded");
static_assert(sizeof(HWAbility_Leap_OnLeapEnded) == 0x000018, "Wrong size on HWAbility_Leap_OnLeapEnded");
static_assert(offsetof(HWAbility_Leap_OnLeapEnded, TweenInstance) == 0x000000, "Member 'HWAbility_Leap_OnLeapEnded::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbility_Leap_OnLeapEnded, TweenTarget) == 0x000008, "Member 'HWAbility_Leap_OnLeapEnded::TweenTarget' has a wrong offset!");
static_assert(offsetof(HWAbility_Leap_OnLeapEnded, EndTweenReason) == 0x000010, "Member 'HWAbility_Leap_OnLeapEnded::EndTweenReason' has a wrong offset!");

// Function Hemingway.HWAbility_Leap.OnLeapStarted
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Leap_OnLeapStarted final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Leap_OnLeapStarted) == 0x000008, "Wrong alignment on HWAbility_Leap_OnLeapStarted");
static_assert(sizeof(HWAbility_Leap_OnLeapStarted) == 0x000010, "Wrong size on HWAbility_Leap_OnLeapStarted");
static_assert(offsetof(HWAbility_Leap_OnLeapStarted, TweenInstance) == 0x000000, "Member 'HWAbility_Leap_OnLeapStarted::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbility_Leap_OnLeapStarted, TweenTarget) == 0x000008, "Member 'HWAbility_Leap_OnLeapStarted::TweenTarget' has a wrong offset!");

// Function Hemingway.HWAbility_Thanatos_Passive.GetExecuteThresholdByAbilityLevel
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Thanatos_Passive_GetExecuteThresholdByAbilityLevel final
{
public:
	int32                                         AbilityLevel;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Thanatos_Passive_GetExecuteThresholdByAbilityLevel) == 0x000004, "Wrong alignment on HWAbility_Thanatos_Passive_GetExecuteThresholdByAbilityLevel");
static_assert(sizeof(HWAbility_Thanatos_Passive_GetExecuteThresholdByAbilityLevel) == 0x000008, "Wrong size on HWAbility_Thanatos_Passive_GetExecuteThresholdByAbilityLevel");
static_assert(offsetof(HWAbility_Thanatos_Passive_GetExecuteThresholdByAbilityLevel, AbilityLevel) == 0x000000, "Member 'HWAbility_Thanatos_Passive_GetExecuteThresholdByAbilityLevel::AbilityLevel' has a wrong offset!");
static_assert(offsetof(HWAbility_Thanatos_Passive_GetExecuteThresholdByAbilityLevel, ReturnValue) == 0x000004, "Member 'HWAbility_Thanatos_Passive_GetExecuteThresholdByAbilityLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeserterSubsystem.GetDeserterList
// 0x0010 (0x0010 - 0x0000)
struct HWDeserterSubsystem_GetDeserterList final
{
public:
	TArray<struct FGuid>                          DeserterList;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeserterSubsystem_GetDeserterList) == 0x000008, "Wrong alignment on HWDeserterSubsystem_GetDeserterList");
static_assert(sizeof(HWDeserterSubsystem_GetDeserterList) == 0x000010, "Wrong size on HWDeserterSubsystem_GetDeserterList");
static_assert(offsetof(HWDeserterSubsystem_GetDeserterList, DeserterList) == 0x000000, "Member 'HWDeserterSubsystem_GetDeserterList::DeserterList' has a wrong offset!");

// Function Hemingway.HWDeserterSubsystem.GetPrimaryDeserter
// 0x0010 (0x0010 - 0x0000)
struct HWDeserterSubsystem_GetPrimaryDeserter final
{
public:
	struct FGuid                                  DeserterId;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeserterSubsystem_GetPrimaryDeserter) == 0x000004, "Wrong alignment on HWDeserterSubsystem_GetPrimaryDeserter");
static_assert(sizeof(HWDeserterSubsystem_GetPrimaryDeserter) == 0x000010, "Wrong size on HWDeserterSubsystem_GetPrimaryDeserter");
static_assert(offsetof(HWDeserterSubsystem_GetPrimaryDeserter, DeserterId) == 0x000000, "Member 'HWDeserterSubsystem_GetPrimaryDeserter::DeserterId' has a wrong offset!");

// Function Hemingway.HWDeserterSubsystem.GetPrimaryDeserterThreshold
// 0x0004 (0x0004 - 0x0000)
struct HWDeserterSubsystem_GetPrimaryDeserterThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeserterSubsystem_GetPrimaryDeserterThreshold) == 0x000004, "Wrong alignment on HWDeserterSubsystem_GetPrimaryDeserterThreshold");
static_assert(sizeof(HWDeserterSubsystem_GetPrimaryDeserterThreshold) == 0x000004, "Wrong size on HWDeserterSubsystem_GetPrimaryDeserterThreshold");
static_assert(offsetof(HWDeserterSubsystem_GetPrimaryDeserterThreshold, ReturnValue) == 0x000000, "Member 'HWDeserterSubsystem_GetPrimaryDeserterThreshold::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeserterSubsystem.HasMatchBeenDeserted
// 0x0001 (0x0001 - 0x0000)
struct HWDeserterSubsystem_HasMatchBeenDeserted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeserterSubsystem_HasMatchBeenDeserted) == 0x000001, "Wrong alignment on HWDeserterSubsystem_HasMatchBeenDeserted");
static_assert(sizeof(HWDeserterSubsystem_HasMatchBeenDeserted) == 0x000001, "Wrong size on HWDeserterSubsystem_HasMatchBeenDeserted");
static_assert(offsetof(HWDeserterSubsystem_HasMatchBeenDeserted, ReturnValue) == 0x000000, "Member 'HWDeserterSubsystem_HasMatchBeenDeserted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeserterSubsystem.IsSingleDeserterSystemEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWDeserterSubsystem_IsSingleDeserterSystemEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeserterSubsystem_IsSingleDeserterSystemEnabled) == 0x000001, "Wrong alignment on HWDeserterSubsystem_IsSingleDeserterSystemEnabled");
static_assert(sizeof(HWDeserterSubsystem_IsSingleDeserterSystemEnabled) == 0x000001, "Wrong size on HWDeserterSubsystem_IsSingleDeserterSystemEnabled");
static_assert(offsetof(HWDeserterSubsystem_IsSingleDeserterSystemEnabled, ReturnValue) == 0x000000, "Member 'HWDeserterSubsystem_IsSingleDeserterSystemEnabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeserterSubsystem.MarkAsPrimaryDeserter
// 0x0010 (0x0010 - 0x0000)
struct HWDeserterSubsystem_MarkAsPrimaryDeserter final
{
public:
	struct FGuid                                  PlayerUuid;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeserterSubsystem_MarkAsPrimaryDeserter) == 0x000004, "Wrong alignment on HWDeserterSubsystem_MarkAsPrimaryDeserter");
static_assert(sizeof(HWDeserterSubsystem_MarkAsPrimaryDeserter) == 0x000010, "Wrong size on HWDeserterSubsystem_MarkAsPrimaryDeserter");
static_assert(offsetof(HWDeserterSubsystem_MarkAsPrimaryDeserter, PlayerUuid) == 0x000000, "Member 'HWDeserterSubsystem_MarkAsPrimaryDeserter::PlayerUuid' has a wrong offset!");

// Function Hemingway.HWDeserterSubsystem.GetHasAppliedAnyDeserters
// 0x0001 (0x0001 - 0x0000)
struct HWDeserterSubsystem_GetHasAppliedAnyDeserters final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeserterSubsystem_GetHasAppliedAnyDeserters) == 0x000001, "Wrong alignment on HWDeserterSubsystem_GetHasAppliedAnyDeserters");
static_assert(sizeof(HWDeserterSubsystem_GetHasAppliedAnyDeserters) == 0x000001, "Wrong size on HWDeserterSubsystem_GetHasAppliedAnyDeserters");
static_assert(offsetof(HWDeserterSubsystem_GetHasAppliedAnyDeserters, ReturnValue) == 0x000000, "Member 'HWDeserterSubsystem_GetHasAppliedAnyDeserters::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Danzaburou_A04.GetRocketHomingTarget
// 0x0030 (0x0030 - 0x0000)
struct HWAbility_Danzaburou_A04_GetRocketHomingTarget final
{
public:
	struct FGameplayAbilityTargetDataHandle       AimData;                                           // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Danzaburou_A04_GetRocketHomingTarget) == 0x000008, "Wrong alignment on HWAbility_Danzaburou_A04_GetRocketHomingTarget");
static_assert(sizeof(HWAbility_Danzaburou_A04_GetRocketHomingTarget) == 0x000030, "Wrong size on HWAbility_Danzaburou_A04_GetRocketHomingTarget");
static_assert(offsetof(HWAbility_Danzaburou_A04_GetRocketHomingTarget, AimData) == 0x000000, "Member 'HWAbility_Danzaburou_A04_GetRocketHomingTarget::AimData' has a wrong offset!");
static_assert(offsetof(HWAbility_Danzaburou_A04_GetRocketHomingTarget, ReturnValue) == 0x000028, "Member 'HWAbility_Danzaburou_A04_GetRocketHomingTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDraftRules.ConvertToDraftPlayerIdHandle
// 0x0030 (0x0030 - 0x0000)
struct HWDraftRules_ConvertToDraftPlayerIdHandle final
{
public:
	struct FHWPersistentPlayerId                  InPlayerId;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDraftPlayerIdHandle                   ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDraftRules_ConvertToDraftPlayerIdHandle) == 0x000008, "Wrong alignment on HWDraftRules_ConvertToDraftPlayerIdHandle");
static_assert(sizeof(HWDraftRules_ConvertToDraftPlayerIdHandle) == 0x000030, "Wrong size on HWDraftRules_ConvertToDraftPlayerIdHandle");
static_assert(offsetof(HWDraftRules_ConvertToDraftPlayerIdHandle, InPlayerId) == 0x000000, "Member 'HWDraftRules_ConvertToDraftPlayerIdHandle::InPlayerId' has a wrong offset!");
static_assert(offsetof(HWDraftRules_ConvertToDraftPlayerIdHandle, ReturnValue) == 0x000020, "Member 'HWDraftRules_ConvertToDraftPlayerIdHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDraftRules.ConvertToHWPlayerId
// 0x0030 (0x0030 - 0x0000)
struct HWDraftRules_ConvertToHWPlayerId final
{
public:
	struct FDraftPlayerIdHandle                   InDraftPlayerId;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWPersistentPlayerId                  ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDraftRules_ConvertToHWPlayerId) == 0x000008, "Wrong alignment on HWDraftRules_ConvertToHWPlayerId");
static_assert(sizeof(HWDraftRules_ConvertToHWPlayerId) == 0x000030, "Wrong size on HWDraftRules_ConvertToHWPlayerId");
static_assert(offsetof(HWDraftRules_ConvertToHWPlayerId, InDraftPlayerId) == 0x000000, "Member 'HWDraftRules_ConvertToHWPlayerId::InDraftPlayerId' has a wrong offset!");
static_assert(offsetof(HWDraftRules_ConvertToHWPlayerId, ReturnValue) == 0x000010, "Member 'HWDraftRules_ConvertToHWPlayerId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDraftRules.IsValidRandomBotChoice
// 0x0068 (0x0068 - 0x0000)
struct HWDraftRules_IsValidRandomBotChoice final
{
public:
	struct FDraftChoice                           InDraftChoice;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDraftTask                             InDraftTask;                                       // 0x0010(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class ADraftAuthority*                        InDraftAuthority;                                  // 0x0058(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDraftRules_IsValidRandomBotChoice) == 0x000008, "Wrong alignment on HWDraftRules_IsValidRandomBotChoice");
static_assert(sizeof(HWDraftRules_IsValidRandomBotChoice) == 0x000068, "Wrong size on HWDraftRules_IsValidRandomBotChoice");
static_assert(offsetof(HWDraftRules_IsValidRandomBotChoice, InDraftChoice) == 0x000000, "Member 'HWDraftRules_IsValidRandomBotChoice::InDraftChoice' has a wrong offset!");
static_assert(offsetof(HWDraftRules_IsValidRandomBotChoice, InDraftTask) == 0x000010, "Member 'HWDraftRules_IsValidRandomBotChoice::InDraftTask' has a wrong offset!");
static_assert(offsetof(HWDraftRules_IsValidRandomBotChoice, InDraftAuthority) == 0x000058, "Member 'HWDraftRules_IsValidRandomBotChoice::InDraftAuthority' has a wrong offset!");
static_assert(offsetof(HWDraftRules_IsValidRandomBotChoice, ReturnValue) == 0x000060, "Member 'HWDraftRules_IsValidRandomBotChoice::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDraftRules.IsValidRandomPlayerChoice
// 0x0068 (0x0068 - 0x0000)
struct HWDraftRules_IsValidRandomPlayerChoice final
{
public:
	struct FDraftChoice                           InDraftChoice;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDraftTask                             InDraftTask;                                       // 0x0010(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class ADraftAuthority*                        InDraftAuthority;                                  // 0x0058(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDraftRules_IsValidRandomPlayerChoice) == 0x000008, "Wrong alignment on HWDraftRules_IsValidRandomPlayerChoice");
static_assert(sizeof(HWDraftRules_IsValidRandomPlayerChoice) == 0x000068, "Wrong size on HWDraftRules_IsValidRandomPlayerChoice");
static_assert(offsetof(HWDraftRules_IsValidRandomPlayerChoice, InDraftChoice) == 0x000000, "Member 'HWDraftRules_IsValidRandomPlayerChoice::InDraftChoice' has a wrong offset!");
static_assert(offsetof(HWDraftRules_IsValidRandomPlayerChoice, InDraftTask) == 0x000010, "Member 'HWDraftRules_IsValidRandomPlayerChoice::InDraftTask' has a wrong offset!");
static_assert(offsetof(HWDraftRules_IsValidRandomPlayerChoice, InDraftAuthority) == 0x000058, "Member 'HWDraftRules_IsValidRandomPlayerChoice::InDraftAuthority' has a wrong offset!");
static_assert(offsetof(HWDraftRules_IsValidRandomPlayerChoice, ReturnValue) == 0x000060, "Member 'HWDraftRules_IsValidRandomPlayerChoice::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDraftRules.HandleGodLoadoutReceived
// 0x0098 (0x0098 - 0x0000)
struct HWDraftRules_HandleGodLoadoutReceived final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_PlayerSettingsDataWrapper          SettingsWrapper;                                   // 0x0008(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADraftAuthority>         InDraftAuthority;                                  // 0x0068(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0070(0x0020)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 CharacterItem;                                     // 0x0090(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDraftRules_HandleGodLoadoutReceived) == 0x000008, "Wrong alignment on HWDraftRules_HandleGodLoadoutReceived");
static_assert(sizeof(HWDraftRules_HandleGodLoadoutReceived) == 0x000098, "Wrong size on HWDraftRules_HandleGodLoadoutReceived");
static_assert(offsetof(HWDraftRules_HandleGodLoadoutReceived, bSuccess) == 0x000000, "Member 'HWDraftRules_HandleGodLoadoutReceived::bSuccess' has a wrong offset!");
static_assert(offsetof(HWDraftRules_HandleGodLoadoutReceived, SettingsWrapper) == 0x000008, "Member 'HWDraftRules_HandleGodLoadoutReceived::SettingsWrapper' has a wrong offset!");
static_assert(offsetof(HWDraftRules_HandleGodLoadoutReceived, InDraftAuthority) == 0x000068, "Member 'HWDraftRules_HandleGodLoadoutReceived::InDraftAuthority' has a wrong offset!");
static_assert(offsetof(HWDraftRules_HandleGodLoadoutReceived, PlayerId) == 0x000070, "Member 'HWDraftRules_HandleGodLoadoutReceived::PlayerId' has a wrong offset!");
static_assert(offsetof(HWDraftRules_HandleGodLoadoutReceived, CharacterItem) == 0x000090, "Member 'HWDraftRules_HandleGodLoadoutReceived::CharacterItem' has a wrong offset!");

// Function Hemingway.HWDraftRules.HandlePlayerLoadoutReceived
// 0x0090 (0x0090 - 0x0000)
struct HWDraftRules_HandlePlayerLoadoutReceived final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_PlayerSettingsDataWrapper          SettingsWrapper;                                   // 0x0008(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADraftAuthority>         InDraftAuthority;                                  // 0x0068(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0070(0x0020)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDraftRules_HandlePlayerLoadoutReceived) == 0x000008, "Wrong alignment on HWDraftRules_HandlePlayerLoadoutReceived");
static_assert(sizeof(HWDraftRules_HandlePlayerLoadoutReceived) == 0x000090, "Wrong size on HWDraftRules_HandlePlayerLoadoutReceived");
static_assert(offsetof(HWDraftRules_HandlePlayerLoadoutReceived, bSuccess) == 0x000000, "Member 'HWDraftRules_HandlePlayerLoadoutReceived::bSuccess' has a wrong offset!");
static_assert(offsetof(HWDraftRules_HandlePlayerLoadoutReceived, SettingsWrapper) == 0x000008, "Member 'HWDraftRules_HandlePlayerLoadoutReceived::SettingsWrapper' has a wrong offset!");
static_assert(offsetof(HWDraftRules_HandlePlayerLoadoutReceived, InDraftAuthority) == 0x000068, "Member 'HWDraftRules_HandlePlayerLoadoutReceived::InDraftAuthority' has a wrong offset!");
static_assert(offsetof(HWDraftRules_HandlePlayerLoadoutReceived, PlayerId) == 0x000070, "Member 'HWDraftRules_HandlePlayerLoadoutReceived::PlayerId' has a wrong offset!");

// Function Hemingway.HWAbility_Levitate.HandleEarlyEndTrigger
// 0x00B0 (0x00B0 - 0x0000)
struct HWAbility_Levitate_HandleEarlyEndTrigger final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Levitate_HandleEarlyEndTrigger) == 0x000008, "Wrong alignment on HWAbility_Levitate_HandleEarlyEndTrigger");
static_assert(sizeof(HWAbility_Levitate_HandleEarlyEndTrigger) == 0x0000B0, "Wrong size on HWAbility_Levitate_HandleEarlyEndTrigger");
static_assert(offsetof(HWAbility_Levitate_HandleEarlyEndTrigger, Payload) == 0x000000, "Member 'HWAbility_Levitate_HandleEarlyEndTrigger::Payload' has a wrong offset!");

// Function Hemingway.HWAbility_Levitate.OnLevitationEnded
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Levitate_OnLevitationEnded final
{
public:
	EHWEndLevitationReason                        EndLevitationReason;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Levitate_OnLevitationEnded) == 0x000001, "Wrong alignment on HWAbility_Levitate_OnLevitationEnded");
static_assert(sizeof(HWAbility_Levitate_OnLevitationEnded) == 0x000001, "Wrong size on HWAbility_Levitate_OnLevitationEnded");
static_assert(offsetof(HWAbility_Levitate_OnLevitationEnded, EndLevitationReason) == 0x000000, "Member 'HWAbility_Levitate_OnLevitationEnded::EndLevitationReason' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.AdjustLocationToGround
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_Core_AdjustLocationToGround final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_AdjustLocationToGround) == 0x000008, "Wrong alignment on HWLibrary_Core_AdjustLocationToGround");
static_assert(sizeof(HWLibrary_Core_AdjustLocationToGround) == 0x000038, "Wrong size on HWLibrary_Core_AdjustLocationToGround");
static_assert(offsetof(HWLibrary_Core_AdjustLocationToGround, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_AdjustLocationToGround::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_AdjustLocationToGround, Location) == 0x000008, "Member 'HWLibrary_Core_AdjustLocationToGround::Location' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_AdjustLocationToGround, ReturnValue) == 0x000020, "Member 'HWLibrary_Core_AdjustLocationToGround::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.BP_TraceBookmark
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_BP_TraceBookmark final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_BP_TraceBookmark) == 0x000008, "Wrong alignment on HWLibrary_Core_BP_TraceBookmark");
static_assert(sizeof(HWLibrary_Core_BP_TraceBookmark) == 0x000010, "Wrong size on HWLibrary_Core_BP_TraceBookmark");
static_assert(offsetof(HWLibrary_Core_BP_TraceBookmark, Message) == 0x000000, "Member 'HWLibrary_Core_BP_TraceBookmark::Message' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.ClearAndInvalidateTimerHandleWithWorldContext
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_ClearAndInvalidateTimerHandleWithWorldContext final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_ClearAndInvalidateTimerHandleWithWorldContext) == 0x000008, "Wrong alignment on HWLibrary_Core_ClearAndInvalidateTimerHandleWithWorldContext");
static_assert(sizeof(HWLibrary_Core_ClearAndInvalidateTimerHandleWithWorldContext) == 0x000010, "Wrong size on HWLibrary_Core_ClearAndInvalidateTimerHandleWithWorldContext");
static_assert(offsetof(HWLibrary_Core_ClearAndInvalidateTimerHandleWithWorldContext, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_ClearAndInvalidateTimerHandleWithWorldContext::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ClearAndInvalidateTimerHandleWithWorldContext, Handle) == 0x000008, "Member 'HWLibrary_Core_ClearAndInvalidateTimerHandleWithWorldContext::Handle' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.CloneHWTargetDataFilter
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_Core_CloneHWTargetDataFilter final
{
public:
	struct FGameplayTargetDataFilterHandle        FilterHandle;                                      // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 NewAvatar;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_CloneHWTargetDataFilter) == 0x000008, "Wrong alignment on HWLibrary_Core_CloneHWTargetDataFilter");
static_assert(sizeof(HWLibrary_Core_CloneHWTargetDataFilter) == 0x000028, "Wrong size on HWLibrary_Core_CloneHWTargetDataFilter");
static_assert(offsetof(HWLibrary_Core_CloneHWTargetDataFilter, FilterHandle) == 0x000000, "Member 'HWLibrary_Core_CloneHWTargetDataFilter::FilterHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_CloneHWTargetDataFilter, NewAvatar) == 0x000010, "Member 'HWLibrary_Core_CloneHWTargetDataFilter::NewAvatar' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_CloneHWTargetDataFilter, ReturnValue) == 0x000018, "Member 'HWLibrary_Core_CloneHWTargetDataFilter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.ConstrainCameraLocation
// 0x0060 (0x0060 - 0x0000)
struct HWLibrary_Core_ConstrainCameraLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLocation;                                    // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FocusLocation;                                     // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ProbeChannel;                                      // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProbeSize;                                         // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_ConstrainCameraLocation) == 0x000008, "Wrong alignment on HWLibrary_Core_ConstrainCameraLocation");
static_assert(sizeof(HWLibrary_Core_ConstrainCameraLocation) == 0x000060, "Wrong size on HWLibrary_Core_ConstrainCameraLocation");
static_assert(offsetof(HWLibrary_Core_ConstrainCameraLocation, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_ConstrainCameraLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConstrainCameraLocation, SourceActor) == 0x000008, "Member 'HWLibrary_Core_ConstrainCameraLocation::SourceActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConstrainCameraLocation, CameraLocation) == 0x000010, "Member 'HWLibrary_Core_ConstrainCameraLocation::CameraLocation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConstrainCameraLocation, FocusLocation) == 0x000028, "Member 'HWLibrary_Core_ConstrainCameraLocation::FocusLocation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConstrainCameraLocation, ProbeChannel) == 0x000040, "Member 'HWLibrary_Core_ConstrainCameraLocation::ProbeChannel' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConstrainCameraLocation, ProbeSize) == 0x000044, "Member 'HWLibrary_Core_ConstrainCameraLocation::ProbeSize' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConstrainCameraLocation, ReturnValue) == 0x000048, "Member 'HWLibrary_Core_ConstrainCameraLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.ConvertSocketWorldToParentSpace
// 0x0070 (0x0070 - 0x0000)
struct HWLibrary_Core_ConvertSocketWorldToParentSpace final
{
public:
	struct FVector                                ParentLocation;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ParentRotation;                                    // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	const class USkeletalMeshComponent*           Mesh;                                              // 0x0030(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0038(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutOffset;                                         // 0x0040(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutRotation;                                       // 0x0058(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_ConvertSocketWorldToParentSpace) == 0x000008, "Wrong alignment on HWLibrary_Core_ConvertSocketWorldToParentSpace");
static_assert(sizeof(HWLibrary_Core_ConvertSocketWorldToParentSpace) == 0x000070, "Wrong size on HWLibrary_Core_ConvertSocketWorldToParentSpace");
static_assert(offsetof(HWLibrary_Core_ConvertSocketWorldToParentSpace, ParentLocation) == 0x000000, "Member 'HWLibrary_Core_ConvertSocketWorldToParentSpace::ParentLocation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConvertSocketWorldToParentSpace, ParentRotation) == 0x000018, "Member 'HWLibrary_Core_ConvertSocketWorldToParentSpace::ParentRotation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConvertSocketWorldToParentSpace, Mesh) == 0x000030, "Member 'HWLibrary_Core_ConvertSocketWorldToParentSpace::Mesh' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConvertSocketWorldToParentSpace, SocketName) == 0x000038, "Member 'HWLibrary_Core_ConvertSocketWorldToParentSpace::SocketName' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConvertSocketWorldToParentSpace, OutOffset) == 0x000040, "Member 'HWLibrary_Core_ConvertSocketWorldToParentSpace::OutOffset' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ConvertSocketWorldToParentSpace, OutRotation) == 0x000058, "Member 'HWLibrary_Core_ConvertSocketWorldToParentSpace::OutRotation' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.CumulativeDistributionFunction
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_CumulativeDistributionFunction final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mu;                                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sigma;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_CumulativeDistributionFunction) == 0x000004, "Wrong alignment on HWLibrary_Core_CumulativeDistributionFunction");
static_assert(sizeof(HWLibrary_Core_CumulativeDistributionFunction) == 0x000010, "Wrong size on HWLibrary_Core_CumulativeDistributionFunction");
static_assert(offsetof(HWLibrary_Core_CumulativeDistributionFunction, X) == 0x000000, "Member 'HWLibrary_Core_CumulativeDistributionFunction::X' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_CumulativeDistributionFunction, Mu) == 0x000004, "Member 'HWLibrary_Core_CumulativeDistributionFunction::Mu' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_CumulativeDistributionFunction, Sigma) == 0x000008, "Member 'HWLibrary_Core_CumulativeDistributionFunction::Sigma' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_CumulativeDistributionFunction, ReturnValue) == 0x00000C, "Member 'HWLibrary_Core_CumulativeDistributionFunction::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.DoesActorHaveLineOfSightOfLocation
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_Core_DoesActorHaveLineOfSightOfLocation final
{
public:
	const class AActor*                           TargetActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0020(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_DoesActorHaveLineOfSightOfLocation) == 0x000008, "Wrong alignment on HWLibrary_Core_DoesActorHaveLineOfSightOfLocation");
static_assert(sizeof(HWLibrary_Core_DoesActorHaveLineOfSightOfLocation) == 0x000038, "Wrong size on HWLibrary_Core_DoesActorHaveLineOfSightOfLocation");
static_assert(offsetof(HWLibrary_Core_DoesActorHaveLineOfSightOfLocation, TargetActor) == 0x000000, "Member 'HWLibrary_Core_DoesActorHaveLineOfSightOfLocation::TargetActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_DoesActorHaveLineOfSightOfLocation, EndLocation) == 0x000008, "Member 'HWLibrary_Core_DoesActorHaveLineOfSightOfLocation::EndLocation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_DoesActorHaveLineOfSightOfLocation, IgnoreActors) == 0x000020, "Member 'HWLibrary_Core_DoesActorHaveLineOfSightOfLocation::IgnoreActors' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_DoesActorHaveLineOfSightOfLocation, ReturnValue) == 0x000030, "Member 'HWLibrary_Core_DoesActorHaveLineOfSightOfLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.EqualEqual_FGenericTeamId
// 0x0003 (0x0003 - 0x0000)
struct HWLibrary_Core_EqualEqual_FGenericTeamId final
{
public:
	struct FGenericTeamId                         A;                                                 // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         B;                                                 // 0x0001(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_EqualEqual_FGenericTeamId) == 0x000001, "Wrong alignment on HWLibrary_Core_EqualEqual_FGenericTeamId");
static_assert(sizeof(HWLibrary_Core_EqualEqual_FGenericTeamId) == 0x000003, "Wrong size on HWLibrary_Core_EqualEqual_FGenericTeamId");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FGenericTeamId, A) == 0x000000, "Member 'HWLibrary_Core_EqualEqual_FGenericTeamId::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FGenericTeamId, B) == 0x000001, "Member 'HWLibrary_Core_EqualEqual_FGenericTeamId::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FGenericTeamId, ReturnValue) == 0x000002, "Member 'HWLibrary_Core_EqualEqual_FGenericTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.EqualEqual_FHWAbilityFiringInstanceId
// 0x0014 (0x0014 - 0x0000)
struct HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId final
{
public:
	struct FHWAbilityFiringInstanceId             A;                                                 // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             B;                                                 // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId) == 0x000004, "Wrong alignment on HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId");
static_assert(sizeof(HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId) == 0x000014, "Wrong size on HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId, A) == 0x000000, "Member 'HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId, B) == 0x000008, "Member 'HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId, ReturnValue) == 0x000010, "Member 'HWLibrary_Core_EqualEqual_FHWAbilityFiringInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.EqualEqual_FHWActiveFamiliarHandle
// 0x001C (0x001C - 0x0000)
struct HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle final
{
public:
	struct FHWActiveFamiliarHandle                A;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWActiveFamiliarHandle                B;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle) == 0x000004, "Wrong alignment on HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle");
static_assert(sizeof(HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle) == 0x00001C, "Wrong size on HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle, A) == 0x000000, "Member 'HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle, B) == 0x00000C, "Member 'HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle, ReturnValue) == 0x000018, "Member 'HWLibrary_Core_EqualEqual_FHWActiveFamiliarHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.EqualEqual_FHWActiveFamiliarInfo
// 0x00A8 (0x00A8 - 0x0000)
struct HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo final
{
public:
	struct FHWActiveFamiliarInfo                  A;                                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWActiveFamiliarInfo                  B;                                                 // 0x0050(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo) == 0x000008, "Wrong alignment on HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo");
static_assert(sizeof(HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo) == 0x0000A8, "Wrong size on HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo, A) == 0x000000, "Member 'HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo, B) == 0x000050, "Member 'HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo, ReturnValue) == 0x0000A0, "Member 'HWLibrary_Core_EqualEqual_FHWActiveFamiliarInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.EqualEqual_FHWPersistentPlayerId
// 0x0044 (0x0044 - 0x0000)
struct HWLibrary_Core_EqualEqual_FHWPersistentPlayerId final
{
public:
	struct FHWPersistentPlayerId                  A;                                                 // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWPersistentPlayerId                  B;                                                 // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_EqualEqual_FHWPersistentPlayerId) == 0x000004, "Wrong alignment on HWLibrary_Core_EqualEqual_FHWPersistentPlayerId");
static_assert(sizeof(HWLibrary_Core_EqualEqual_FHWPersistentPlayerId) == 0x000044, "Wrong size on HWLibrary_Core_EqualEqual_FHWPersistentPlayerId");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWPersistentPlayerId, A) == 0x000000, "Member 'HWLibrary_Core_EqualEqual_FHWPersistentPlayerId::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWPersistentPlayerId, B) == 0x000020, "Member 'HWLibrary_Core_EqualEqual_FHWPersistentPlayerId::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_EqualEqual_FHWPersistentPlayerId, ReturnValue) == 0x000040, "Member 'HWLibrary_Core_EqualEqual_FHWPersistentPlayerId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.ErrorFunction
// 0x0008 (0x0008 - 0x0000)
struct HWLibrary_Core_ErrorFunction final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_ErrorFunction) == 0x000004, "Wrong alignment on HWLibrary_Core_ErrorFunction");
static_assert(sizeof(HWLibrary_Core_ErrorFunction) == 0x000008, "Wrong size on HWLibrary_Core_ErrorFunction");
static_assert(offsetof(HWLibrary_Core_ErrorFunction, X) == 0x000000, "Member 'HWLibrary_Core_ErrorFunction::X' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ErrorFunction, ReturnValue) == 0x000004, "Member 'HWLibrary_Core_ErrorFunction::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.FindEdgeOfWorldGeometryCheck
// 0x0088 (0x0088 - 0x0000)
struct HWLibrary_Core_FindEdgeOfWorldGeometryCheck final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceOrigin;                                       // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceDirection;                                    // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0038(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Extent;                                            // 0x0040(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0058(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           SourceActor;                                       // 0x0060(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutEdgeLocation;                                   // 0x0068(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldFindSpotClosestFromTraceOrigin;             // 0x0080(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebug;                                        // 0x0081(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0082(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83[0x5];                                       // 0x0083(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck) == 0x000008, "Wrong alignment on HWLibrary_Core_FindEdgeOfWorldGeometryCheck");
static_assert(sizeof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck) == 0x000088, "Wrong size on HWLibrary_Core_FindEdgeOfWorldGeometryCheck");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, TraceOrigin) == 0x000008, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::TraceOrigin' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, TraceDirection) == 0x000020, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::TraceDirection' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, Range) == 0x000038, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::Range' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, Extent) == 0x000040, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::Extent' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, ProfileName) == 0x000058, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::ProfileName' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, SourceActor) == 0x000060, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::SourceActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, OutEdgeLocation) == 0x000068, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::OutEdgeLocation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, bShouldFindSpotClosestFromTraceOrigin) == 0x000080, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::bShouldFindSpotClosestFromTraceOrigin' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, bShowDebug) == 0x000081, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::bShowDebug' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindEdgeOfWorldGeometryCheck, ReturnValue) == 0x000082, "Member 'HWLibrary_Core_FindEdgeOfWorldGeometryCheck::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.FindNearestValidGroundLocation
// 0x0068 (0x0068 - 0x0000)
struct HWLibrary_Core_FindNearestValidGroundLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0038(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckInsideCollision;                             // 0x003C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	const class AActor*                           ActorToCheck;                                      // 0x0040(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           ActorToIgnoreCollision;                            // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0050(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_FindNearestValidGroundLocation) == 0x000008, "Wrong alignment on HWLibrary_Core_FindNearestValidGroundLocation");
static_assert(sizeof(HWLibrary_Core_FindNearestValidGroundLocation) == 0x000068, "Wrong size on HWLibrary_Core_FindNearestValidGroundLocation");
static_assert(offsetof(HWLibrary_Core_FindNearestValidGroundLocation, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_FindNearestValidGroundLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindNearestValidGroundLocation, StartLocation) == 0x000008, "Member 'HWLibrary_Core_FindNearestValidGroundLocation::StartLocation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindNearestValidGroundLocation, EndLocation) == 0x000020, "Member 'HWLibrary_Core_FindNearestValidGroundLocation::EndLocation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindNearestValidGroundLocation, MinDistance) == 0x000038, "Member 'HWLibrary_Core_FindNearestValidGroundLocation::MinDistance' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindNearestValidGroundLocation, bCheckInsideCollision) == 0x00003C, "Member 'HWLibrary_Core_FindNearestValidGroundLocation::bCheckInsideCollision' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindNearestValidGroundLocation, ActorToCheck) == 0x000040, "Member 'HWLibrary_Core_FindNearestValidGroundLocation::ActorToCheck' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindNearestValidGroundLocation, ActorToIgnoreCollision) == 0x000048, "Member 'HWLibrary_Core_FindNearestValidGroundLocation::ActorToIgnoreCollision' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindNearestValidGroundLocation, ReturnValue) == 0x000050, "Member 'HWLibrary_Core_FindNearestValidGroundLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.FindWorldImpact
// 0x0150 (0x0150 - 0x0000)
struct HWLibrary_Core_FindWorldImpact final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTrace;                                        // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTrace;                                          // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CollisionExtents;                                  // 0x0038(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           TraceActor;                                        // 0x0050(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             OutWorldImpact;                                    // 0x0058(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   CollisionProfileOverride;                          // 0x0140(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamOverride;                                      // 0x0148(0x0001)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0149(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_FindWorldImpact) == 0x000008, "Wrong alignment on HWLibrary_Core_FindWorldImpact");
static_assert(sizeof(HWLibrary_Core_FindWorldImpact) == 0x000150, "Wrong size on HWLibrary_Core_FindWorldImpact");
static_assert(offsetof(HWLibrary_Core_FindWorldImpact, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_FindWorldImpact::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindWorldImpact, StartTrace) == 0x000008, "Member 'HWLibrary_Core_FindWorldImpact::StartTrace' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindWorldImpact, EndTrace) == 0x000020, "Member 'HWLibrary_Core_FindWorldImpact::EndTrace' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindWorldImpact, CollisionExtents) == 0x000038, "Member 'HWLibrary_Core_FindWorldImpact::CollisionExtents' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindWorldImpact, TraceActor) == 0x000050, "Member 'HWLibrary_Core_FindWorldImpact::TraceActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindWorldImpact, OutWorldImpact) == 0x000058, "Member 'HWLibrary_Core_FindWorldImpact::OutWorldImpact' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindWorldImpact, CollisionProfileOverride) == 0x000140, "Member 'HWLibrary_Core_FindWorldImpact::CollisionProfileOverride' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindWorldImpact, TeamOverride) == 0x000148, "Member 'HWLibrary_Core_FindWorldImpact::TeamOverride' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_FindWorldImpact, ReturnValue) == 0x000149, "Member 'HWLibrary_Core_FindWorldImpact::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetAbilitySpecFromAbilityFiringInstanceId
// 0x000C (0x000C - 0x0000)
struct HWLibrary_Core_GetAbilitySpecFromAbilityFiringInstanceId final
{
public:
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetAbilitySpecFromAbilityFiringInstanceId) == 0x000004, "Wrong alignment on HWLibrary_Core_GetAbilitySpecFromAbilityFiringInstanceId");
static_assert(sizeof(HWLibrary_Core_GetAbilitySpecFromAbilityFiringInstanceId) == 0x00000C, "Wrong size on HWLibrary_Core_GetAbilitySpecFromAbilityFiringInstanceId");
static_assert(offsetof(HWLibrary_Core_GetAbilitySpecFromAbilityFiringInstanceId, FiringInstanceId) == 0x000000, "Member 'HWLibrary_Core_GetAbilitySpecFromAbilityFiringInstanceId::FiringInstanceId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetAbilitySpecFromAbilityFiringInstanceId, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetAbilitySpecFromAbilityFiringInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetActorAttitudeTowardsLocalPlayer
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InActor;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer) == 0x000008, "Wrong alignment on HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer");
static_assert(sizeof(HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer) == 0x000018, "Wrong size on HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer");
static_assert(offsetof(HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer, InActor) == 0x000008, "Member 'HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer::InActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer, ReturnValue) == 0x000010, "Member 'HWLibrary_Core_GetActorAttitudeTowardsLocalPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetActorGameTeam
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetActorGameTeam final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           InActor;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWSmiteTeamId                                ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetActorGameTeam) == 0x000008, "Wrong alignment on HWLibrary_Core_GetActorGameTeam");
static_assert(sizeof(HWLibrary_Core_GetActorGameTeam) == 0x000018, "Wrong size on HWLibrary_Core_GetActorGameTeam");
static_assert(offsetof(HWLibrary_Core_GetActorGameTeam, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetActorGameTeam::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetActorGameTeam, InActor) == 0x000008, "Member 'HWLibrary_Core_GetActorGameTeam::InActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetActorGameTeam, ReturnValue) == 0x000010, "Member 'HWLibrary_Core_GetActorGameTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetAngleBetweenTwoVectors
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_Core_GetAngleBetweenTwoVectors final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetAngleBetweenTwoVectors) == 0x000008, "Wrong alignment on HWLibrary_Core_GetAngleBetweenTwoVectors");
static_assert(sizeof(HWLibrary_Core_GetAngleBetweenTwoVectors) == 0x000038, "Wrong size on HWLibrary_Core_GetAngleBetweenTwoVectors");
static_assert(offsetof(HWLibrary_Core_GetAngleBetweenTwoVectors, A) == 0x000000, "Member 'HWLibrary_Core_GetAngleBetweenTwoVectors::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetAngleBetweenTwoVectors, B) == 0x000018, "Member 'HWLibrary_Core_GetAngleBetweenTwoVectors::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetAngleBetweenTwoVectors, ReturnValue) == 0x000030, "Member 'HWLibrary_Core_GetAngleBetweenTwoVectors::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetAnnouncerCueFromAnnouncerPack
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAnnouncerPackItem*             AnnouncerPack;                                     // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       AssetKey;                                          // 0x0010(0x001C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              ReturnValue;                                       // 0x0030(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack) == 0x000008, "Wrong alignment on HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack");
static_assert(sizeof(HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack) == 0x000058, "Wrong size on HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack");
static_assert(offsetof(HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack, AnnouncerPack) == 0x000008, "Member 'HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack::AnnouncerPack' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack, AssetKey) == 0x000010, "Member 'HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack::AssetKey' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack, ReturnValue) == 0x000030, "Member 'HWLibrary_Core_GetAnnouncerCueFromAnnouncerPack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetAnnouncerCueFromLocalPlayerAnnouncerPack
// 0x0050 (0x0050 - 0x0000)
struct HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       AssetKey;                                          // 0x0008(0x001C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              ReturnValue;                                       // 0x0028(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack) == 0x000008, "Wrong alignment on HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack");
static_assert(sizeof(HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack) == 0x000050, "Wrong size on HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack");
static_assert(offsetof(HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack, AssetKey) == 0x000008, "Member 'HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack::AssetKey' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack, ReturnValue) == 0x000028, "Member 'HWLibrary_Core_GetAnnouncerCueFromLocalPlayerAnnouncerPack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetBooleanAppSetting
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetBooleanAppSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SettingTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutSettingValue;                                  // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetBooleanAppSetting) == 0x000008, "Wrong alignment on HWLibrary_Core_GetBooleanAppSetting");
static_assert(sizeof(HWLibrary_Core_GetBooleanAppSetting) == 0x000018, "Wrong size on HWLibrary_Core_GetBooleanAppSetting");
static_assert(offsetof(HWLibrary_Core_GetBooleanAppSetting, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetBooleanAppSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetBooleanAppSetting, SettingTag) == 0x000008, "Member 'HWLibrary_Core_GetBooleanAppSetting::SettingTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetBooleanAppSetting, bOutSettingValue) == 0x000010, "Member 'HWLibrary_Core_GetBooleanAppSetting::bOutSettingValue' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetBooleanAppSetting, ReturnValue) == 0x000011, "Member 'HWLibrary_Core_GetBooleanAppSetting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetBooleanGameUserSetting
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetBooleanGameUserSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SettingName;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutSettingValue;                                  // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetBooleanGameUserSetting) == 0x000008, "Wrong alignment on HWLibrary_Core_GetBooleanGameUserSetting");
static_assert(sizeof(HWLibrary_Core_GetBooleanGameUserSetting) == 0x000018, "Wrong size on HWLibrary_Core_GetBooleanGameUserSetting");
static_assert(offsetof(HWLibrary_Core_GetBooleanGameUserSetting, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetBooleanGameUserSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetBooleanGameUserSetting, SettingName) == 0x000008, "Member 'HWLibrary_Core_GetBooleanGameUserSetting::SettingName' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetBooleanGameUserSetting, bOutSettingValue) == 0x000010, "Member 'HWLibrary_Core_GetBooleanGameUserSetting::bOutSettingValue' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetBooleanGameUserSetting, ReturnValue) == 0x000011, "Member 'HWLibrary_Core_GetBooleanGameUserSetting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetBotGameplayTagForRole
// 0x000C (0x000C - 0x0000)
struct HWLibrary_Core_GetBotGameplayTagForRole final
{
public:
	ECharacterRole                                Role;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetBotGameplayTagForRole) == 0x000004, "Wrong alignment on HWLibrary_Core_GetBotGameplayTagForRole");
static_assert(sizeof(HWLibrary_Core_GetBotGameplayTagForRole) == 0x00000C, "Wrong size on HWLibrary_Core_GetBotGameplayTagForRole");
static_assert(offsetof(HWLibrary_Core_GetBotGameplayTagForRole, Role) == 0x000000, "Member 'HWLibrary_Core_GetBotGameplayTagForRole::Role' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetBotGameplayTagForRole, ReturnValue) == 0x000004, "Member 'HWLibrary_Core_GetBotGameplayTagForRole::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetCachedGodMasteryLevelInfoForPlayer
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 GodItem;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWLevelInfo                           OutLevelInfo;                                      // 0x0018(0x0014)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer) == 0x000008, "Wrong alignment on HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer");
static_assert(sizeof(HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer) == 0x000030, "Wrong size on HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer");
static_assert(offsetof(HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer, GodItem) == 0x000008, "Member 'HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer::GodItem' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer, PlayerInfo) == 0x000010, "Member 'HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer, OutLevelInfo) == 0x000018, "Member 'HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer::OutLevelInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer, ReturnValue) == 0x00002C, "Member 'HWLibrary_Core_GetCachedGodMasteryLevelInfoForPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetCapturedTargetTagsFromEffectSpecHandle
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_Core_GetCapturedTargetTagsFromEffectSpecHandle final
{
public:
	struct FGameplayEffectSpecHandle              EffectSpecHandle;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetCapturedTargetTagsFromEffectSpecHandle) == 0x000008, "Wrong alignment on HWLibrary_Core_GetCapturedTargetTagsFromEffectSpecHandle");
static_assert(sizeof(HWLibrary_Core_GetCapturedTargetTagsFromEffectSpecHandle) == 0x000030, "Wrong size on HWLibrary_Core_GetCapturedTargetTagsFromEffectSpecHandle");
static_assert(offsetof(HWLibrary_Core_GetCapturedTargetTagsFromEffectSpecHandle, EffectSpecHandle) == 0x000000, "Member 'HWLibrary_Core_GetCapturedTargetTagsFromEffectSpecHandle::EffectSpecHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetCapturedTargetTagsFromEffectSpecHandle, ReturnValue) == 0x000010, "Member 'HWLibrary_Core_GetCapturedTargetTagsFromEffectSpecHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetCollectionTagFromType
// 0x000C (0x000C - 0x0000)
struct HWLibrary_Core_GetCollectionTagFromType final
{
public:
	EHWCollectionItemType                         CollectionType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetCollectionTagFromType) == 0x000004, "Wrong alignment on HWLibrary_Core_GetCollectionTagFromType");
static_assert(sizeof(HWLibrary_Core_GetCollectionTagFromType) == 0x00000C, "Wrong size on HWLibrary_Core_GetCollectionTagFromType");
static_assert(offsetof(HWLibrary_Core_GetCollectionTagFromType, CollectionType) == 0x000000, "Member 'HWLibrary_Core_GetCollectionTagFromType::CollectionType' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetCollectionTagFromType, ReturnValue) == 0x000004, "Member 'HWLibrary_Core_GetCollectionTagFromType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetConsoleType
// 0x0001 (0x0001 - 0x0000)
struct HWLibrary_Core_GetConsoleType final
{
public:
	EHWConsoleType                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetConsoleType) == 0x000001, "Wrong alignment on HWLibrary_Core_GetConsoleType");
static_assert(sizeof(HWLibrary_Core_GetConsoleType) == 0x000001, "Wrong size on HWLibrary_Core_GetConsoleType");
static_assert(offsetof(HWLibrary_Core_GetConsoleType, ReturnValue) == 0x000000, "Member 'HWLibrary_Core_GetConsoleType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetDraftLobbyTeamIndexForPlayer
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer final
{
public:
	const class ADraftReplicatedActor*            InDraftActor;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWPlayerState*                   PlayerState;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer) == 0x000008, "Wrong alignment on HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer");
static_assert(sizeof(HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer) == 0x000018, "Wrong size on HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer");
static_assert(offsetof(HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer, InDraftActor) == 0x000000, "Member 'HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer::InDraftActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer, PlayerState) == 0x000008, "Member 'HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer::PlayerState' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer, ReturnValue) == 0x000010, "Member 'HWLibrary_Core_GetDraftLobbyTeamIndexForPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetFirstMatchingTag
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_Core_GetFirstMatchingTag final
{
public:
	struct FGameplayTagContainer                  Container;                                         // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagToMatch;                                        // 0x0020(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExactMatch;                                       // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x002C(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetFirstMatchingTag) == 0x000008, "Wrong alignment on HWLibrary_Core_GetFirstMatchingTag");
static_assert(sizeof(HWLibrary_Core_GetFirstMatchingTag) == 0x000038, "Wrong size on HWLibrary_Core_GetFirstMatchingTag");
static_assert(offsetof(HWLibrary_Core_GetFirstMatchingTag, Container) == 0x000000, "Member 'HWLibrary_Core_GetFirstMatchingTag::Container' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetFirstMatchingTag, TagToMatch) == 0x000020, "Member 'HWLibrary_Core_GetFirstMatchingTag::TagToMatch' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetFirstMatchingTag, bExactMatch) == 0x000028, "Member 'HWLibrary_Core_GetFirstMatchingTag::bExactMatch' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetFirstMatchingTag, ReturnValue) == 0x00002C, "Member 'HWLibrary_Core_GetFirstMatchingTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetFloatGameUserSetting
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetFloatGameUserSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SettingName;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bOutSettingValue;                                  // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetFloatGameUserSetting) == 0x000008, "Wrong alignment on HWLibrary_Core_GetFloatGameUserSetting");
static_assert(sizeof(HWLibrary_Core_GetFloatGameUserSetting) == 0x000018, "Wrong size on HWLibrary_Core_GetFloatGameUserSetting");
static_assert(offsetof(HWLibrary_Core_GetFloatGameUserSetting, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetFloatGameUserSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetFloatGameUserSetting, SettingName) == 0x000008, "Member 'HWLibrary_Core_GetFloatGameUserSetting::SettingName' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetFloatGameUserSetting, bOutSettingValue) == 0x000010, "Member 'HWLibrary_Core_GetFloatGameUserSetting::bOutSettingValue' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetFloatGameUserSetting, ReturnValue) == 0x000014, "Member 'HWLibrary_Core_GetFloatGameUserSetting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetGameModeInfo
// 0x0108 (0x0108 - 0x0000)
struct HWLibrary_Core_GetGameModeInfo final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWGameModeInfo                        GameModeInfo;                                      // 0x0008(0x00F8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultGameModeInfoTag;                        // 0x0100(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0101(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetGameModeInfo) == 0x000008, "Wrong alignment on HWLibrary_Core_GetGameModeInfo");
static_assert(sizeof(HWLibrary_Core_GetGameModeInfo) == 0x000108, "Wrong size on HWLibrary_Core_GetGameModeInfo");
static_assert(offsetof(HWLibrary_Core_GetGameModeInfo, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetGameModeInfo::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGameModeInfo, GameModeInfo) == 0x000008, "Member 'HWLibrary_Core_GetGameModeInfo::GameModeInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGameModeInfo, bUseDefaultGameModeInfoTag) == 0x000100, "Member 'HWLibrary_Core_GetGameModeInfo::bUseDefaultGameModeInfoTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGameModeInfo, ReturnValue) == 0x000101, "Member 'HWLibrary_Core_GetGameModeInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetGameplayEffectContext
// 0x02C0 (0x02C0 - 0x0000)
struct HWLibrary_Core_GetGameplayEffectContext final
{
public:
	struct FGameplayEffectSpec                    GameplayEffectSpec;                                // 0x0000(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           ReturnValue;                                       // 0x02A8(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetGameplayEffectContext) == 0x000008, "Wrong alignment on HWLibrary_Core_GetGameplayEffectContext");
static_assert(sizeof(HWLibrary_Core_GetGameplayEffectContext) == 0x0002C0, "Wrong size on HWLibrary_Core_GetGameplayEffectContext");
static_assert(offsetof(HWLibrary_Core_GetGameplayEffectContext, GameplayEffectSpec) == 0x000000, "Member 'HWLibrary_Core_GetGameplayEffectContext::GameplayEffectSpec' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGameplayEffectContext, ReturnValue) == 0x0002A8, "Member 'HWLibrary_Core_GetGameplayEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetGameplayTagForRole
// 0x000C (0x000C - 0x0000)
struct HWLibrary_Core_GetGameplayTagForRole final
{
public:
	ECharacterRole                                Role;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetGameplayTagForRole) == 0x000004, "Wrong alignment on HWLibrary_Core_GetGameplayTagForRole");
static_assert(sizeof(HWLibrary_Core_GetGameplayTagForRole) == 0x00000C, "Wrong size on HWLibrary_Core_GetGameplayTagForRole");
static_assert(offsetof(HWLibrary_Core_GetGameplayTagForRole, Role) == 0x000000, "Member 'HWLibrary_Core_GetGameplayTagForRole::Role' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGameplayTagForRole, ReturnValue) == 0x000004, "Member 'HWLibrary_Core_GetGameplayTagForRole::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetGameTeamFromGenericTeamId
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetGameTeamFromGenericTeamId final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         InTeamId;                                          // 0x0008(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWSmiteTeamId                                ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetGameTeamFromGenericTeamId) == 0x000008, "Wrong alignment on HWLibrary_Core_GetGameTeamFromGenericTeamId");
static_assert(sizeof(HWLibrary_Core_GetGameTeamFromGenericTeamId) == 0x000010, "Wrong size on HWLibrary_Core_GetGameTeamFromGenericTeamId");
static_assert(offsetof(HWLibrary_Core_GetGameTeamFromGenericTeamId, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetGameTeamFromGenericTeamId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGameTeamFromGenericTeamId, InTeamId) == 0x000008, "Member 'HWLibrary_Core_GetGameTeamFromGenericTeamId::InTeamId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGameTeamFromGenericTeamId, ReturnValue) == 0x000009, "Member 'HWLibrary_Core_GetGameTeamFromGenericTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetGameTeamFromRHTeamId
// 0x0008 (0x0008 - 0x0000)
struct HWLibrary_Core_GetGameTeamFromRHTeamId final
{
public:
	int32                                         RHTeamId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWSmiteTeamId                                ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetGameTeamFromRHTeamId) == 0x000004, "Wrong alignment on HWLibrary_Core_GetGameTeamFromRHTeamId");
static_assert(sizeof(HWLibrary_Core_GetGameTeamFromRHTeamId) == 0x000008, "Wrong size on HWLibrary_Core_GetGameTeamFromRHTeamId");
static_assert(offsetof(HWLibrary_Core_GetGameTeamFromRHTeamId, RHTeamId) == 0x000000, "Member 'HWLibrary_Core_GetGameTeamFromRHTeamId::RHTeamId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGameTeamFromRHTeamId, ReturnValue) == 0x000004, "Member 'HWLibrary_Core_GetGameTeamFromRHTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetGenericTeamId
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetGenericTeamId final
{
public:
	const class AActor*                           TeamMemberActor;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetGenericTeamId) == 0x000008, "Wrong alignment on HWLibrary_Core_GetGenericTeamId");
static_assert(sizeof(HWLibrary_Core_GetGenericTeamId) == 0x000010, "Wrong size on HWLibrary_Core_GetGenericTeamId");
static_assert(offsetof(HWLibrary_Core_GetGenericTeamId, TeamMemberActor) == 0x000000, "Member 'HWLibrary_Core_GetGenericTeamId::TeamMemberActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGenericTeamId, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetGenericTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetGodMasteryLevelForPlayer
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_Core_GetGodMasteryLevelForPlayer final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 GodItem;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class UHWCharacterItem* Character, const class URH_PlayerInfo* InPlayerInfo, int32 Level, float LevelProgressPercent)> Delegate; // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetGodMasteryLevelForPlayer) == 0x000008, "Wrong alignment on HWLibrary_Core_GetGodMasteryLevelForPlayer");
static_assert(sizeof(HWLibrary_Core_GetGodMasteryLevelForPlayer) == 0x000028, "Wrong size on HWLibrary_Core_GetGodMasteryLevelForPlayer");
static_assert(offsetof(HWLibrary_Core_GetGodMasteryLevelForPlayer, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetGodMasteryLevelForPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGodMasteryLevelForPlayer, GodItem) == 0x000008, "Member 'HWLibrary_Core_GetGodMasteryLevelForPlayer::GodItem' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGodMasteryLevelForPlayer, PlayerInfo) == 0x000010, "Member 'HWLibrary_Core_GetGodMasteryLevelForPlayer::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGodMasteryLevelForPlayer, Delegate) == 0x000018, "Member 'HWLibrary_Core_GetGodMasteryLevelForPlayer::Delegate' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetGodSubsystem
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetGodSubsystem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWGodSubsystem*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetGodSubsystem) == 0x000008, "Wrong alignment on HWLibrary_Core_GetGodSubsystem");
static_assert(sizeof(HWLibrary_Core_GetGodSubsystem) == 0x000010, "Wrong size on HWLibrary_Core_GetGodSubsystem");
static_assert(offsetof(HWLibrary_Core_GetGodSubsystem, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetGodSubsystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetGodSubsystem, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetGodSubsystem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetHWGameInstance
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetHWGameInstance final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWGameInstance*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetHWGameInstance) == 0x000008, "Wrong alignment on HWLibrary_Core_GetHWGameInstance");
static_assert(sizeof(HWLibrary_Core_GetHWGameInstance) == 0x000010, "Wrong size on HWLibrary_Core_GetHWGameInstance");
static_assert(offsetof(HWLibrary_Core_GetHWGameInstance, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetHWGameInstance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetHWGameInstance, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetHWGameInstance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetHWGameMode
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetHWGameMode final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWGameMode*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetHWGameMode) == 0x000008, "Wrong alignment on HWLibrary_Core_GetHWGameMode");
static_assert(sizeof(HWLibrary_Core_GetHWGameMode) == 0x000010, "Wrong size on HWLibrary_Core_GetHWGameMode");
static_assert(offsetof(HWLibrary_Core_GetHWGameMode, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetHWGameMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetHWGameMode, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetHWGameMode::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetHWGameState
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetHWGameState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWGameState*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetHWGameState) == 0x000008, "Wrong alignment on HWLibrary_Core_GetHWGameState");
static_assert(sizeof(HWLibrary_Core_GetHWGameState) == 0x000010, "Wrong size on HWLibrary_Core_GetHWGameState");
static_assert(offsetof(HWLibrary_Core_GetHWGameState, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetHWGameState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetHWGameState, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetHWGameState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetHWGameStateWithManualWorldContext
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetHWGameStateWithManualWorldContext final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWGameState*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetHWGameStateWithManualWorldContext) == 0x000008, "Wrong alignment on HWLibrary_Core_GetHWGameStateWithManualWorldContext");
static_assert(sizeof(HWLibrary_Core_GetHWGameStateWithManualWorldContext) == 0x000010, "Wrong size on HWLibrary_Core_GetHWGameStateWithManualWorldContext");
static_assert(offsetof(HWLibrary_Core_GetHWGameStateWithManualWorldContext, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetHWGameStateWithManualWorldContext::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetHWGameStateWithManualWorldContext, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetHWGameStateWithManualWorldContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetHWTagManager
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetHWTagManager final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWTagManager*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetHWTagManager) == 0x000008, "Wrong alignment on HWLibrary_Core_GetHWTagManager");
static_assert(sizeof(HWLibrary_Core_GetHWTagManager) == 0x000010, "Wrong size on HWLibrary_Core_GetHWTagManager");
static_assert(offsetof(HWLibrary_Core_GetHWTagManager, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetHWTagManager::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetHWTagManager, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetHWTagManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetIntegerAppSetting
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetIntegerAppSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SettingTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutSettingValue;                                   // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetIntegerAppSetting) == 0x000008, "Wrong alignment on HWLibrary_Core_GetIntegerAppSetting");
static_assert(sizeof(HWLibrary_Core_GetIntegerAppSetting) == 0x000018, "Wrong size on HWLibrary_Core_GetIntegerAppSetting");
static_assert(offsetof(HWLibrary_Core_GetIntegerAppSetting, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetIntegerAppSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetIntegerAppSetting, SettingTag) == 0x000008, "Member 'HWLibrary_Core_GetIntegerAppSetting::SettingTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetIntegerAppSetting, OutSettingValue) == 0x000010, "Member 'HWLibrary_Core_GetIntegerAppSetting::OutSettingValue' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetIntegerAppSetting, ReturnValue) == 0x000014, "Member 'HWLibrary_Core_GetIntegerAppSetting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetIntegerGameUserSetting
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetIntegerGameUserSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SettingName;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutSettingValue;                                   // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetIntegerGameUserSetting) == 0x000008, "Wrong alignment on HWLibrary_Core_GetIntegerGameUserSetting");
static_assert(sizeof(HWLibrary_Core_GetIntegerGameUserSetting) == 0x000018, "Wrong size on HWLibrary_Core_GetIntegerGameUserSetting");
static_assert(offsetof(HWLibrary_Core_GetIntegerGameUserSetting, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetIntegerGameUserSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetIntegerGameUserSetting, SettingName) == 0x000008, "Member 'HWLibrary_Core_GetIntegerGameUserSetting::SettingName' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetIntegerGameUserSetting, OutSettingValue) == 0x000010, "Member 'HWLibrary_Core_GetIntegerGameUserSetting::OutSettingValue' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetIntegerGameUserSetting, ReturnValue) == 0x000014, "Member 'HWLibrary_Core_GetIntegerGameUserSetting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetLocalPlayerController
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetLocalPlayerController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetLocalPlayerController) == 0x000008, "Wrong alignment on HWLibrary_Core_GetLocalPlayerController");
static_assert(sizeof(HWLibrary_Core_GetLocalPlayerController) == 0x000018, "Wrong size on HWLibrary_Core_GetLocalPlayerController");
static_assert(offsetof(HWLibrary_Core_GetLocalPlayerController, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetLocalPlayerController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetLocalPlayerController, PlayerIndex) == 0x000008, "Member 'HWLibrary_Core_GetLocalPlayerController::PlayerIndex' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetLocalPlayerController, ReturnValue) == 0x000010, "Member 'HWLibrary_Core_GetLocalPlayerController::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetMusicCueFromLocalPlayerMusicPack
// 0x0050 (0x0050 - 0x0000)
struct HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       AssetKey;                                          // 0x0008(0x001C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMetaSoundSource>        ReturnValue;                                       // 0x0028(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack) == 0x000008, "Wrong alignment on HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack");
static_assert(sizeof(HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack) == 0x000050, "Wrong size on HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack");
static_assert(offsetof(HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack, AssetKey) == 0x000008, "Member 'HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack::AssetKey' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack, ReturnValue) == 0x000028, "Member 'HWLibrary_Core_GetMusicCueFromLocalPlayerMusicPack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetMusicCueFromMusicPack
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_Core_GetMusicCueFromMusicPack final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWMusicPackItem*                 MusicPack;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       AssetKey;                                          // 0x0010(0x001C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMetaSoundSource>        ReturnValue;                                       // 0x0030(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetMusicCueFromMusicPack) == 0x000008, "Wrong alignment on HWLibrary_Core_GetMusicCueFromMusicPack");
static_assert(sizeof(HWLibrary_Core_GetMusicCueFromMusicPack) == 0x000058, "Wrong size on HWLibrary_Core_GetMusicCueFromMusicPack");
static_assert(offsetof(HWLibrary_Core_GetMusicCueFromMusicPack, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetMusicCueFromMusicPack::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetMusicCueFromMusicPack, MusicPack) == 0x000008, "Member 'HWLibrary_Core_GetMusicCueFromMusicPack::MusicPack' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetMusicCueFromMusicPack, AssetKey) == 0x000010, "Member 'HWLibrary_Core_GetMusicCueFromMusicPack::AssetKey' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetMusicCueFromMusicPack, ReturnValue) == 0x000030, "Member 'HWLibrary_Core_GetMusicCueFromMusicPack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetNPCType
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetNPCType final
{
public:
	const class AHWCharacter_NPC*                 NPCCharacter;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetNPCType) == 0x000008, "Wrong alignment on HWLibrary_Core_GetNPCType");
static_assert(sizeof(HWLibrary_Core_GetNPCType) == 0x000018, "Wrong size on HWLibrary_Core_GetNPCType");
static_assert(offsetof(HWLibrary_Core_GetNPCType, NPCCharacter) == 0x000000, "Member 'HWLibrary_Core_GetNPCType::NPCCharacter' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetNPCType, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetNPCType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetObjectFirstMatchingTag
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetObjectFirstMatchingTag final
{
public:
	const class UObject*                          ObjectToCheck;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetObjectFirstMatchingTag) == 0x000008, "Wrong alignment on HWLibrary_Core_GetObjectFirstMatchingTag");
static_assert(sizeof(HWLibrary_Core_GetObjectFirstMatchingTag) == 0x000018, "Wrong size on HWLibrary_Core_GetObjectFirstMatchingTag");
static_assert(offsetof(HWLibrary_Core_GetObjectFirstMatchingTag, ObjectToCheck) == 0x000000, "Member 'HWLibrary_Core_GetObjectFirstMatchingTag::ObjectToCheck' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetObjectFirstMatchingTag, Tag) == 0x000008, "Member 'HWLibrary_Core_GetObjectFirstMatchingTag::Tag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetObjectFirstMatchingTag, ReturnValue) == 0x000010, "Member 'HWLibrary_Core_GetObjectFirstMatchingTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetPlayerCohort
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetPlayerCohort final
{
public:
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCohorts;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetPlayerCohort) == 0x000008, "Wrong alignment on HWLibrary_Core_GetPlayerCohort");
static_assert(sizeof(HWLibrary_Core_GetPlayerCohort) == 0x000010, "Wrong size on HWLibrary_Core_GetPlayerCohort");
static_assert(offsetof(HWLibrary_Core_GetPlayerCohort, PlayerInfo) == 0x000000, "Member 'HWLibrary_Core_GetPlayerCohort::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetPlayerCohort, NumCohorts) == 0x000008, "Member 'HWLibrary_Core_GetPlayerCohort::NumCohorts' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetPlayerCohort, ReturnValue) == 0x00000C, "Member 'HWLibrary_Core_GetPlayerCohort::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetPlayerFacingGameVersion
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetPlayerFacingGameVersion final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetPlayerFacingGameVersion) == 0x000008, "Wrong alignment on HWLibrary_Core_GetPlayerFacingGameVersion");
static_assert(sizeof(HWLibrary_Core_GetPlayerFacingGameVersion) == 0x000018, "Wrong size on HWLibrary_Core_GetPlayerFacingGameVersion");
static_assert(offsetof(HWLibrary_Core_GetPlayerFacingGameVersion, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetPlayerFacingGameVersion::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetPlayerFacingGameVersion, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetPlayerFacingGameVersion::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetPlayerNameFromDraftTask
// 0x0068 (0x0068 - 0x0000)
struct HWLibrary_Core_GetPlayerNameFromDraftTask final
{
public:
	const class ADraftReplicatedActor*            InDraftActor;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDraftTask                             DraftTask;                                         // 0x0008(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 OutName;                                           // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetPlayerNameFromDraftTask) == 0x000008, "Wrong alignment on HWLibrary_Core_GetPlayerNameFromDraftTask");
static_assert(sizeof(HWLibrary_Core_GetPlayerNameFromDraftTask) == 0x000068, "Wrong size on HWLibrary_Core_GetPlayerNameFromDraftTask");
static_assert(offsetof(HWLibrary_Core_GetPlayerNameFromDraftTask, InDraftActor) == 0x000000, "Member 'HWLibrary_Core_GetPlayerNameFromDraftTask::InDraftActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetPlayerNameFromDraftTask, DraftTask) == 0x000008, "Member 'HWLibrary_Core_GetPlayerNameFromDraftTask::DraftTask' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetPlayerNameFromDraftTask, OutName) == 0x000050, "Member 'HWLibrary_Core_GetPlayerNameFromDraftTask::OutName' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetPlayerNameFromDraftTask, ReturnValue) == 0x000060, "Member 'HWLibrary_Core_GetPlayerNameFromDraftTask::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetReflexAvailable
// 0x0001 (0x0001 - 0x0000)
struct HWLibrary_Core_GetReflexAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetReflexAvailable) == 0x000001, "Wrong alignment on HWLibrary_Core_GetReflexAvailable");
static_assert(sizeof(HWLibrary_Core_GetReflexAvailable) == 0x000001, "Wrong size on HWLibrary_Core_GetReflexAvailable");
static_assert(offsetof(HWLibrary_Core_GetReflexAvailable, ReturnValue) == 0x000000, "Member 'HWLibrary_Core_GetReflexAvailable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetRewardsForQuestTier
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_Core_GetRewardsForQuestTier final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWQuest*                         Quest;                                             // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 CharacterItem;                                     // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuestTier;                                         // 0x0018(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRH_ItemId>                     ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetRewardsForQuestTier) == 0x000008, "Wrong alignment on HWLibrary_Core_GetRewardsForQuestTier");
static_assert(sizeof(HWLibrary_Core_GetRewardsForQuestTier) == 0x000030, "Wrong size on HWLibrary_Core_GetRewardsForQuestTier");
static_assert(offsetof(HWLibrary_Core_GetRewardsForQuestTier, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetRewardsForQuestTier::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetRewardsForQuestTier, Quest) == 0x000008, "Member 'HWLibrary_Core_GetRewardsForQuestTier::Quest' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetRewardsForQuestTier, CharacterItem) == 0x000010, "Member 'HWLibrary_Core_GetRewardsForQuestTier::CharacterItem' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetRewardsForQuestTier, QuestTier) == 0x000018, "Member 'HWLibrary_Core_GetRewardsForQuestTier::QuestTier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetRewardsForQuestTier, ReturnValue) == 0x000020, "Member 'HWLibrary_Core_GetRewardsForQuestTier::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetRHTeamIdFromGameTeamId
// 0x0008 (0x0008 - 0x0000)
struct HWLibrary_Core_GetRHTeamIdFromGameTeamId final
{
public:
	int32                                         GameTeamId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetRHTeamIdFromGameTeamId) == 0x000004, "Wrong alignment on HWLibrary_Core_GetRHTeamIdFromGameTeamId");
static_assert(sizeof(HWLibrary_Core_GetRHTeamIdFromGameTeamId) == 0x000008, "Wrong size on HWLibrary_Core_GetRHTeamIdFromGameTeamId");
static_assert(offsetof(HWLibrary_Core_GetRHTeamIdFromGameTeamId, GameTeamId) == 0x000000, "Member 'HWLibrary_Core_GetRHTeamIdFromGameTeamId::GameTeamId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetRHTeamIdFromGameTeamId, ReturnValue) == 0x000004, "Member 'HWLibrary_Core_GetRHTeamIdFromGameTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetRoleForGameplayTag
// 0x000C (0x000C - 0x0000)
struct HWLibrary_Core_GetRoleForGameplayTag final
{
public:
	struct FGameplayTag                           RoleTag;                                           // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterRole                                ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetRoleForGameplayTag) == 0x000004, "Wrong alignment on HWLibrary_Core_GetRoleForGameplayTag");
static_assert(sizeof(HWLibrary_Core_GetRoleForGameplayTag) == 0x00000C, "Wrong size on HWLibrary_Core_GetRoleForGameplayTag");
static_assert(offsetof(HWLibrary_Core_GetRoleForGameplayTag, RoleTag) == 0x000000, "Member 'HWLibrary_Core_GetRoleForGameplayTag::RoleTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetRoleForGameplayTag, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetRoleForGameplayTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetSimpleTagName
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetSimpleTagName final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetSimpleTagName) == 0x000004, "Wrong alignment on HWLibrary_Core_GetSimpleTagName");
static_assert(sizeof(HWLibrary_Core_GetSimpleTagName) == 0x000010, "Wrong size on HWLibrary_Core_GetSimpleTagName");
static_assert(offsetof(HWLibrary_Core_GetSimpleTagName, Tag) == 0x000000, "Member 'HWLibrary_Core_GetSimpleTagName::Tag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetSimpleTagName, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetSimpleTagName::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetSoftInventoryItemFromItemId
// 0x0040 (0x0040 - 0x0000)
struct HWLibrary_Core_GetSoftInventoryItemFromItemId final
{
public:
	struct FRH_ItemId                             InItemId;                                          // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWInventoryItem>        ReturnValue;                                       // 0x0018(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetSoftInventoryItemFromItemId) == 0x000008, "Wrong alignment on HWLibrary_Core_GetSoftInventoryItemFromItemId");
static_assert(sizeof(HWLibrary_Core_GetSoftInventoryItemFromItemId) == 0x000040, "Wrong size on HWLibrary_Core_GetSoftInventoryItemFromItemId");
static_assert(offsetof(HWLibrary_Core_GetSoftInventoryItemFromItemId, InItemId) == 0x000000, "Member 'HWLibrary_Core_GetSoftInventoryItemFromItemId::InItemId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetSoftInventoryItemFromItemId, ReturnValue) == 0x000018, "Member 'HWLibrary_Core_GetSoftInventoryItemFromItemId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetSoftInventoryItemFromLootId
// 0x0040 (0x0040 - 0x0000)
struct HWLibrary_Core_GetSoftInventoryItemFromLootId final
{
public:
	struct FRH_LootId                             InLootId;                                          // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWInventoryItem>        ReturnValue;                                       // 0x0018(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetSoftInventoryItemFromLootId) == 0x000008, "Wrong alignment on HWLibrary_Core_GetSoftInventoryItemFromLootId");
static_assert(sizeof(HWLibrary_Core_GetSoftInventoryItemFromLootId) == 0x000040, "Wrong size on HWLibrary_Core_GetSoftInventoryItemFromLootId");
static_assert(offsetof(HWLibrary_Core_GetSoftInventoryItemFromLootId, InLootId) == 0x000000, "Member 'HWLibrary_Core_GetSoftInventoryItemFromLootId::InLootId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetSoftInventoryItemFromLootId, ReturnValue) == 0x000018, "Member 'HWLibrary_Core_GetSoftInventoryItemFromLootId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetStringAppSetting
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_Core_GetStringAppSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SettingTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutSettingValue;                                   // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetStringAppSetting) == 0x000008, "Wrong alignment on HWLibrary_Core_GetStringAppSetting");
static_assert(sizeof(HWLibrary_Core_GetStringAppSetting) == 0x000028, "Wrong size on HWLibrary_Core_GetStringAppSetting");
static_assert(offsetof(HWLibrary_Core_GetStringAppSetting, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetStringAppSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetStringAppSetting, SettingTag) == 0x000008, "Member 'HWLibrary_Core_GetStringAppSetting::SettingTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetStringAppSetting, OutSettingValue) == 0x000010, "Member 'HWLibrary_Core_GetStringAppSetting::OutSettingValue' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetStringAppSetting, ReturnValue) == 0x000020, "Member 'HWLibrary_Core_GetStringAppSetting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetStringArrayAppSetting
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_Core_GetStringArrayAppSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SettingTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         OutSettingValues;                                  // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Delimiter;                                         // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetStringArrayAppSetting) == 0x000008, "Wrong alignment on HWLibrary_Core_GetStringArrayAppSetting");
static_assert(sizeof(HWLibrary_Core_GetStringArrayAppSetting) == 0x000038, "Wrong size on HWLibrary_Core_GetStringArrayAppSetting");
static_assert(offsetof(HWLibrary_Core_GetStringArrayAppSetting, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetStringArrayAppSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetStringArrayAppSetting, SettingTag) == 0x000008, "Member 'HWLibrary_Core_GetStringArrayAppSetting::SettingTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetStringArrayAppSetting, OutSettingValues) == 0x000010, "Member 'HWLibrary_Core_GetStringArrayAppSetting::OutSettingValues' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetStringArrayAppSetting, Delimiter) == 0x000020, "Member 'HWLibrary_Core_GetStringArrayAppSetting::Delimiter' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetStringArrayAppSetting, ReturnValue) == 0x000030, "Member 'HWLibrary_Core_GetStringArrayAppSetting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetStringFromFiringInstance
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetStringFromFiringInstance final
{
public:
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetStringFromFiringInstance) == 0x000008, "Wrong alignment on HWLibrary_Core_GetStringFromFiringInstance");
static_assert(sizeof(HWLibrary_Core_GetStringFromFiringInstance) == 0x000018, "Wrong size on HWLibrary_Core_GetStringFromFiringInstance");
static_assert(offsetof(HWLibrary_Core_GetStringFromFiringInstance, FiringInstanceId) == 0x000000, "Member 'HWLibrary_Core_GetStringFromFiringInstance::FiringInstanceId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetStringFromFiringInstance, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetStringFromFiringInstance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetTeamAttitudeTowards
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetTeamAttitudeTowards final
{
public:
	const class AActor*                           TeamMemberActor;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           OtherActor;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetTeamAttitudeTowards) == 0x000008, "Wrong alignment on HWLibrary_Core_GetTeamAttitudeTowards");
static_assert(sizeof(HWLibrary_Core_GetTeamAttitudeTowards) == 0x000018, "Wrong size on HWLibrary_Core_GetTeamAttitudeTowards");
static_assert(offsetof(HWLibrary_Core_GetTeamAttitudeTowards, TeamMemberActor) == 0x000000, "Member 'HWLibrary_Core_GetTeamAttitudeTowards::TeamMemberActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetTeamAttitudeTowards, OtherActor) == 0x000008, "Member 'HWLibrary_Core_GetTeamAttitudeTowards::OtherActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetTeamAttitudeTowards, ReturnValue) == 0x000010, "Member 'HWLibrary_Core_GetTeamAttitudeTowards::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetTeamState
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_Core_GetTeamState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x0008(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWTeamState*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_GetTeamState) == 0x000008, "Wrong alignment on HWLibrary_Core_GetTeamState");
static_assert(sizeof(HWLibrary_Core_GetTeamState) == 0x000018, "Wrong size on HWLibrary_Core_GetTeamState");
static_assert(offsetof(HWLibrary_Core_GetTeamState, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetTeamState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetTeamState, TeamId) == 0x000008, "Member 'HWLibrary_Core_GetTeamState::TeamId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetTeamState, ReturnValue) == 0x000010, "Member 'HWLibrary_Core_GetTeamState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.GetWorldTimeStamp
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_GetWorldTimeStamp final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_GetWorldTimeStamp) == 0x000008, "Wrong alignment on HWLibrary_Core_GetWorldTimeStamp");
static_assert(sizeof(HWLibrary_Core_GetWorldTimeStamp) == 0x000010, "Wrong size on HWLibrary_Core_GetWorldTimeStamp");
static_assert(offsetof(HWLibrary_Core_GetWorldTimeStamp, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_GetWorldTimeStamp::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_GetWorldTimeStamp, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_GetWorldTimeStamp::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.HW_PlaySoftSound2D
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_Core_HW_PlaySoftSound2D final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SoftSound;                                         // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0040(0x0008)(Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           OwningActor;                                       // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUISound;                                        // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_HW_PlaySoftSound2D) == 0x000008, "Wrong alignment on HWLibrary_Core_HW_PlaySoftSound2D");
static_assert(sizeof(HWLibrary_Core_HW_PlaySoftSound2D) == 0x000058, "Wrong size on HWLibrary_Core_HW_PlaySoftSound2D");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoftSound2D, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_HW_PlaySoftSound2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoftSound2D, SoftSound) == 0x000008, "Member 'HWLibrary_Core_HW_PlaySoftSound2D::SoftSound' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoftSound2D, VolumeMultiplier) == 0x000030, "Member 'HWLibrary_Core_HW_PlaySoftSound2D::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoftSound2D, PitchMultiplier) == 0x000034, "Member 'HWLibrary_Core_HW_PlaySoftSound2D::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoftSound2D, StartTime) == 0x000038, "Member 'HWLibrary_Core_HW_PlaySoftSound2D::StartTime' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoftSound2D, ConcurrencySettings) == 0x000040, "Member 'HWLibrary_Core_HW_PlaySoftSound2D::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoftSound2D, OwningActor) == 0x000048, "Member 'HWLibrary_Core_HW_PlaySoftSound2D::OwningActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoftSound2D, bIsUISound) == 0x000050, "Member 'HWLibrary_Core_HW_PlaySoftSound2D::bIsUISound' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.HW_PlaySound2D
// 0x0050 (0x0050 - 0x0000)
struct HWLibrary_Core_HW_PlaySound2D final
{
public:
	const class AActor*                           SkinningInstigatorActor;                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       SkinningKey;                                       // 0x0010(0x001C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           OwningActor;                                       // 0x0040(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUISound;                                        // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_HW_PlaySound2D) == 0x000008, "Wrong alignment on HWLibrary_Core_HW_PlaySound2D");
static_assert(sizeof(HWLibrary_Core_HW_PlaySound2D) == 0x000050, "Wrong size on HWLibrary_Core_HW_PlaySound2D");
static_assert(offsetof(HWLibrary_Core_HW_PlaySound2D, SkinningInstigatorActor) == 0x000000, "Member 'HWLibrary_Core_HW_PlaySound2D::SkinningInstigatorActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySound2D, Sound) == 0x000008, "Member 'HWLibrary_Core_HW_PlaySound2D::Sound' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySound2D, SkinningKey) == 0x000010, "Member 'HWLibrary_Core_HW_PlaySound2D::SkinningKey' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySound2D, VolumeMultiplier) == 0x00002C, "Member 'HWLibrary_Core_HW_PlaySound2D::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySound2D, PitchMultiplier) == 0x000030, "Member 'HWLibrary_Core_HW_PlaySound2D::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySound2D, StartTime) == 0x000034, "Member 'HWLibrary_Core_HW_PlaySound2D::StartTime' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySound2D, ConcurrencySettings) == 0x000038, "Member 'HWLibrary_Core_HW_PlaySound2D::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySound2D, OwningActor) == 0x000040, "Member 'HWLibrary_Core_HW_PlaySound2D::OwningActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySound2D, bIsUISound) == 0x000048, "Member 'HWLibrary_Core_HW_PlaySound2D::bIsUISound' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.HW_PlaySoundAtLocation
// 0x0090 (0x0090 - 0x0000)
struct HWLibrary_Core_HW_PlaySoundAtLocation final
{
public:
	const class AActor*                           SkinningInstigatorActor;                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       SkinningKey;                                       // 0x0010(0x001C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0048(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0070(0x0008)(Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0078(0x0008)(Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           OwningActor;                                       // 0x0080(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInitialActiveSoundParams*        InitialParams;                                     // 0x0088(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_HW_PlaySoundAtLocation) == 0x000008, "Wrong alignment on HWLibrary_Core_HW_PlaySoundAtLocation");
static_assert(sizeof(HWLibrary_Core_HW_PlaySoundAtLocation) == 0x000090, "Wrong size on HWLibrary_Core_HW_PlaySoundAtLocation");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, SkinningInstigatorActor) == 0x000000, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::SkinningInstigatorActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, Sound) == 0x000008, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::Sound' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, SkinningKey) == 0x000010, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::SkinningKey' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, Location) == 0x000030, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::Location' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, Rotation) == 0x000048, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, VolumeMultiplier) == 0x000060, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, PitchMultiplier) == 0x000064, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, StartTime) == 0x000068, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::StartTime' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, AttenuationSettings) == 0x000070, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, ConcurrencySettings) == 0x000078, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, OwningActor) == 0x000080, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::OwningActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_PlaySoundAtLocation, InitialParams) == 0x000088, "Member 'HWLibrary_Core_HW_PlaySoundAtLocation::InitialParams' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.HW_SetUnfocusedVolumeMultiplier
// 0x0004 (0x0004 - 0x0000)
struct HWLibrary_Core_HW_SetUnfocusedVolumeMultiplier final
{
public:
	float                                         InVolumeMultiplier;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_HW_SetUnfocusedVolumeMultiplier) == 0x000004, "Wrong alignment on HWLibrary_Core_HW_SetUnfocusedVolumeMultiplier");
static_assert(sizeof(HWLibrary_Core_HW_SetUnfocusedVolumeMultiplier) == 0x000004, "Wrong size on HWLibrary_Core_HW_SetUnfocusedVolumeMultiplier");
static_assert(offsetof(HWLibrary_Core_HW_SetUnfocusedVolumeMultiplier, InVolumeMultiplier) == 0x000000, "Member 'HWLibrary_Core_HW_SetUnfocusedVolumeMultiplier::InVolumeMultiplier' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.HW_SpawnNiagaraSystemAtLocation
// 0x0088 (0x0088 - 0x0000)
struct HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation final
{
public:
	const class AActor*                           SkinningInstigatorActor;                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         SystemTemplate;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       SkinningKey;                                       // 0x0010(0x001C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0048(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0060(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0078(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoActivate;                                     // 0x0079(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENCPoolMethod                                 PoolingMethod;                                     // 0x007A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreCullCheck;                                     // 0x007B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0080(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation) == 0x000008, "Wrong alignment on HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation");
static_assert(sizeof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation) == 0x000088, "Wrong size on HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, SkinningInstigatorActor) == 0x000000, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::SkinningInstigatorActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, SystemTemplate) == 0x000008, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::SystemTemplate' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, SkinningKey) == 0x000010, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::SkinningKey' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, Location) == 0x000030, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::Location' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, Rotation) == 0x000048, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, Scale) == 0x000060, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::Scale' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, bAutoDestroy) == 0x000078, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, bAutoActivate) == 0x000079, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::bAutoActivate' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, PoolingMethod) == 0x00007A, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::PoolingMethod' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, bPreCullCheck) == 0x00007B, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::bPreCullCheck' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation, ReturnValue) == 0x000080, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAtLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.HW_SpawnNiagaraSystemAttached
// 0x0080 (0x0080 - 0x0000)
struct HWLibrary_Core_HW_SpawnNiagaraSystemAttached final
{
public:
	const class AActor*                           SkinningInstigatorActor;                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         SystemTemplate;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       SkinningKey;                                       // 0x0010(0x001C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachToComponent;                                 // 0x0030(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0040(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0058(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoActivate;                                     // 0x0072(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENCPoolMethod                                 PoolingMethod;                                     // 0x0073(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreCullCheck;                                     // 0x0074(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0078(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached) == 0x000008, "Wrong alignment on HWLibrary_Core_HW_SpawnNiagaraSystemAttached");
static_assert(sizeof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached) == 0x000080, "Wrong size on HWLibrary_Core_HW_SpawnNiagaraSystemAttached");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, SkinningInstigatorActor) == 0x000000, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::SkinningInstigatorActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, SystemTemplate) == 0x000008, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::SystemTemplate' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, SkinningKey) == 0x000010, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::SkinningKey' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, AttachToComponent) == 0x000030, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, AttachPointName) == 0x000038, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, Location) == 0x000040, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::Location' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, Rotation) == 0x000058, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::Rotation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, LocationType) == 0x000070, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::LocationType' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, bAutoDestroy) == 0x000071, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, bAutoActivate) == 0x000072, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::bAutoActivate' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, PoolingMethod) == 0x000073, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::PoolingMethod' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, bPreCullCheck) == 0x000074, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::bPreCullCheck' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnNiagaraSystemAttached, ReturnValue) == 0x000078, "Member 'HWLibrary_Core_HW_SpawnNiagaraSystemAttached::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.HW_SpawnSoundAtLocation
// 0x0090 (0x0090 - 0x0000)
struct HWLibrary_Core_HW_SpawnSoundAtLocation final
{
public:
	const class AActor*                           SkinningInstigatorActor;                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       SkinningKey;                                       // 0x0010(0x001C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0048(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0070(0x0008)(Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0078(0x0008)(Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0088(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_HW_SpawnSoundAtLocation) == 0x000008, "Wrong alignment on HWLibrary_Core_HW_SpawnSoundAtLocation");
static_assert(sizeof(HWLibrary_Core_HW_SpawnSoundAtLocation) == 0x000090, "Wrong size on HWLibrary_Core_HW_SpawnSoundAtLocation");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, SkinningInstigatorActor) == 0x000000, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::SkinningInstigatorActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, Sound) == 0x000008, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::Sound' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, SkinningKey) == 0x000010, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::SkinningKey' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, Location) == 0x000030, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::Location' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, Rotation) == 0x000048, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, VolumeMultiplier) == 0x000060, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, PitchMultiplier) == 0x000064, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, StartTime) == 0x000068, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::StartTime' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, AttenuationSettings) == 0x000070, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, ConcurrencySettings) == 0x000078, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, bAutoDestroy) == 0x000080, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAtLocation, ReturnValue) == 0x000088, "Member 'HWLibrary_Core_HW_SpawnSoundAtLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.HW_SpawnSoundAttached
// 0x00A0 (0x00A0 - 0x0000)
struct HWLibrary_Core_HW_SpawnSoundAttached final
{
public:
	const class AActor*                           SkinningInstigatorActor;                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       SkinningKey;                                       // 0x0010(0x001C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachToComponent;                                 // 0x0030(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0040(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0058(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeMultiplier;                                  // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0080(0x0008)(Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0088(0x0008)(Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0098(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_HW_SpawnSoundAttached) == 0x000008, "Wrong alignment on HWLibrary_Core_HW_SpawnSoundAttached");
static_assert(sizeof(HWLibrary_Core_HW_SpawnSoundAttached) == 0x0000A0, "Wrong size on HWLibrary_Core_HW_SpawnSoundAttached");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, SkinningInstigatorActor) == 0x000000, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::SkinningInstigatorActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, Sound) == 0x000008, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::Sound' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, SkinningKey) == 0x000010, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::SkinningKey' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, AttachToComponent) == 0x000030, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, AttachPointName) == 0x000038, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, Location) == 0x000040, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::Location' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, Rotation) == 0x000058, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::Rotation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, LocationType) == 0x000070, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::LocationType' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, bStopWhenAttachedToDestroyed) == 0x000071, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, VolumeMultiplier) == 0x000074, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, PitchMultiplier) == 0x000078, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, StartTime) == 0x00007C, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::StartTime' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, AttenuationSettings) == 0x000080, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, ConcurrencySettings) == 0x000088, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, bAutoDestroy) == 0x000090, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_HW_SpawnSoundAttached, ReturnValue) == 0x000098, "Member 'HWLibrary_Core_HW_SpawnSoundAttached::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.IsBot_FHWPersistentPlayerId
// 0x0024 (0x0024 - 0x0000)
struct HWLibrary_Core_IsBot_FHWPersistentPlayerId final
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_IsBot_FHWPersistentPlayerId) == 0x000004, "Wrong alignment on HWLibrary_Core_IsBot_FHWPersistentPlayerId");
static_assert(sizeof(HWLibrary_Core_IsBot_FHWPersistentPlayerId) == 0x000024, "Wrong size on HWLibrary_Core_IsBot_FHWPersistentPlayerId");
static_assert(offsetof(HWLibrary_Core_IsBot_FHWPersistentPlayerId, PlayerId) == 0x000000, "Member 'HWLibrary_Core_IsBot_FHWPersistentPlayerId::PlayerId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_IsBot_FHWPersistentPlayerId, ReturnValue) == 0x000020, "Member 'HWLibrary_Core_IsBot_FHWPersistentPlayerId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.IsDLSSAvailable
// 0x0001 (0x0001 - 0x0000)
struct HWLibrary_Core_IsDLSSAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_IsDLSSAvailable) == 0x000001, "Wrong alignment on HWLibrary_Core_IsDLSSAvailable");
static_assert(sizeof(HWLibrary_Core_IsDLSSAvailable) == 0x000001, "Wrong size on HWLibrary_Core_IsDLSSAvailable");
static_assert(offsetof(HWLibrary_Core_IsDLSSAvailable, ReturnValue) == 0x000000, "Member 'HWLibrary_Core_IsDLSSAvailable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.IsDLSSFrameGenAvailable
// 0x0001 (0x0001 - 0x0000)
struct HWLibrary_Core_IsDLSSFrameGenAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_IsDLSSFrameGenAvailable) == 0x000001, "Wrong alignment on HWLibrary_Core_IsDLSSFrameGenAvailable");
static_assert(sizeof(HWLibrary_Core_IsDLSSFrameGenAvailable) == 0x000001, "Wrong size on HWLibrary_Core_IsDLSSFrameGenAvailable");
static_assert(offsetof(HWLibrary_Core_IsDLSSFrameGenAvailable, ReturnValue) == 0x000000, "Member 'HWLibrary_Core_IsDLSSFrameGenAvailable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.IsGameplayTagRequirementMet
// 0x0098 (0x0098 - 0x0000)
struct HWLibrary_Core_IsGameplayTagRequirementMet final
{
public:
	const class UObject*                          ObjectToCheck;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0008(0x0088)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_IsGameplayTagRequirementMet) == 0x000008, "Wrong alignment on HWLibrary_Core_IsGameplayTagRequirementMet");
static_assert(sizeof(HWLibrary_Core_IsGameplayTagRequirementMet) == 0x000098, "Wrong size on HWLibrary_Core_IsGameplayTagRequirementMet");
static_assert(offsetof(HWLibrary_Core_IsGameplayTagRequirementMet, ObjectToCheck) == 0x000000, "Member 'HWLibrary_Core_IsGameplayTagRequirementMet::ObjectToCheck' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_IsGameplayTagRequirementMet, TagRequirements) == 0x000008, "Member 'HWLibrary_Core_IsGameplayTagRequirementMet::TagRequirements' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_IsGameplayTagRequirementMet, ReturnValue) == 0x000090, "Member 'HWLibrary_Core_IsGameplayTagRequirementMet::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.IsGameplayTagRequirementMetForTags
// 0x00B0 (0x00B0 - 0x0000)
struct HWLibrary_Core_IsGameplayTagRequirementMetForTags final
{
public:
	struct FGameplayTagContainer                  TagsToCheck;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0020(0x0088)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_IsGameplayTagRequirementMetForTags) == 0x000008, "Wrong alignment on HWLibrary_Core_IsGameplayTagRequirementMetForTags");
static_assert(sizeof(HWLibrary_Core_IsGameplayTagRequirementMetForTags) == 0x0000B0, "Wrong size on HWLibrary_Core_IsGameplayTagRequirementMetForTags");
static_assert(offsetof(HWLibrary_Core_IsGameplayTagRequirementMetForTags, TagsToCheck) == 0x000000, "Member 'HWLibrary_Core_IsGameplayTagRequirementMetForTags::TagsToCheck' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_IsGameplayTagRequirementMetForTags, TagRequirements) == 0x000020, "Member 'HWLibrary_Core_IsGameplayTagRequirementMetForTags::TagRequirements' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_IsGameplayTagRequirementMetForTags, ReturnValue) == 0x0000A8, "Member 'HWLibrary_Core_IsGameplayTagRequirementMetForTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.IsHuman_FHWPersistentPlayerId
// 0x0024 (0x0024 - 0x0000)
struct HWLibrary_Core_IsHuman_FHWPersistentPlayerId final
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_IsHuman_FHWPersistentPlayerId) == 0x000004, "Wrong alignment on HWLibrary_Core_IsHuman_FHWPersistentPlayerId");
static_assert(sizeof(HWLibrary_Core_IsHuman_FHWPersistentPlayerId) == 0x000024, "Wrong size on HWLibrary_Core_IsHuman_FHWPersistentPlayerId");
static_assert(offsetof(HWLibrary_Core_IsHuman_FHWPersistentPlayerId, PlayerId) == 0x000000, "Member 'HWLibrary_Core_IsHuman_FHWPersistentPlayerId::PlayerId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_IsHuman_FHWPersistentPlayerId, ReturnValue) == 0x000020, "Member 'HWLibrary_Core_IsHuman_FHWPersistentPlayerId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.IsValid_FHWPersistentPlayerId
// 0x0024 (0x0024 - 0x0000)
struct HWLibrary_Core_IsValid_FHWPersistentPlayerId final
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_IsValid_FHWPersistentPlayerId) == 0x000004, "Wrong alignment on HWLibrary_Core_IsValid_FHWPersistentPlayerId");
static_assert(sizeof(HWLibrary_Core_IsValid_FHWPersistentPlayerId) == 0x000024, "Wrong size on HWLibrary_Core_IsValid_FHWPersistentPlayerId");
static_assert(offsetof(HWLibrary_Core_IsValid_FHWPersistentPlayerId, PlayerId) == 0x000000, "Member 'HWLibrary_Core_IsValid_FHWPersistentPlayerId::PlayerId' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_IsValid_FHWPersistentPlayerId, ReturnValue) == 0x000020, "Member 'HWLibrary_Core_IsValid_FHWPersistentPlayerId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.IsValidWorldHit
// 0x00F8 (0x00F8 - 0x0000)
struct HWLibrary_Core_IsValidWorldHit final
{
public:
	struct FHitResult                             HitToCheck;                                        // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	const class AActor*                           TraceActor;                                        // 0x00E8(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamOverride;                                      // 0x00F0(0x0001)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F1(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_IsValidWorldHit) == 0x000008, "Wrong alignment on HWLibrary_Core_IsValidWorldHit");
static_assert(sizeof(HWLibrary_Core_IsValidWorldHit) == 0x0000F8, "Wrong size on HWLibrary_Core_IsValidWorldHit");
static_assert(offsetof(HWLibrary_Core_IsValidWorldHit, HitToCheck) == 0x000000, "Member 'HWLibrary_Core_IsValidWorldHit::HitToCheck' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_IsValidWorldHit, TraceActor) == 0x0000E8, "Member 'HWLibrary_Core_IsValidWorldHit::TraceActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_IsValidWorldHit, TeamOverride) == 0x0000F0, "Member 'HWLibrary_Core_IsValidWorldHit::TeamOverride' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_IsValidWorldHit, ReturnValue) == 0x0000F1, "Member 'HWLibrary_Core_IsValidWorldHit::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.MakeAssetRequestKeyUsingKeyword
// 0x0024 (0x0024 - 0x0000)
struct HWLibrary_Core_MakeAssetRequestKeyUsingKeyword final
{
public:
	class FName                                   Keyword;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAssetRequestKey                       ReturnValue;                                       // 0x0008(0x001C)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_MakeAssetRequestKeyUsingKeyword) == 0x000004, "Wrong alignment on HWLibrary_Core_MakeAssetRequestKeyUsingKeyword");
static_assert(sizeof(HWLibrary_Core_MakeAssetRequestKeyUsingKeyword) == 0x000024, "Wrong size on HWLibrary_Core_MakeAssetRequestKeyUsingKeyword");
static_assert(offsetof(HWLibrary_Core_MakeAssetRequestKeyUsingKeyword, Keyword) == 0x000000, "Member 'HWLibrary_Core_MakeAssetRequestKeyUsingKeyword::Keyword' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_MakeAssetRequestKeyUsingKeyword, ReturnValue) == 0x000008, "Member 'HWLibrary_Core_MakeAssetRequestKeyUsingKeyword::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.MakeHWTargetDataFilterHandle
// 0x01E8 (0x01E8 - 0x0000)
struct HWLibrary_Core_MakeHWTargetDataFilterHandle final
{
public:
	struct FHWGameplayTargetDataFilter            Filter;                                            // 0x0000(0x01D0)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 Avatar;                                            // 0x01D0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        ReturnValue;                                       // 0x01D8(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_MakeHWTargetDataFilterHandle) == 0x000008, "Wrong alignment on HWLibrary_Core_MakeHWTargetDataFilterHandle");
static_assert(sizeof(HWLibrary_Core_MakeHWTargetDataFilterHandle) == 0x0001E8, "Wrong size on HWLibrary_Core_MakeHWTargetDataFilterHandle");
static_assert(offsetof(HWLibrary_Core_MakeHWTargetDataFilterHandle, Filter) == 0x000000, "Member 'HWLibrary_Core_MakeHWTargetDataFilterHandle::Filter' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_MakeHWTargetDataFilterHandle, Avatar) == 0x0001D0, "Member 'HWLibrary_Core_MakeHWTargetDataFilterHandle::Avatar' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_MakeHWTargetDataFilterHandle, ReturnValue) == 0x0001D8, "Member 'HWLibrary_Core_MakeHWTargetDataFilterHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.NotEqual_FGenericTeamId
// 0x0003 (0x0003 - 0x0000)
struct HWLibrary_Core_NotEqual_FGenericTeamId final
{
public:
	struct FGenericTeamId                         A;                                                 // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         B;                                                 // 0x0001(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_NotEqual_FGenericTeamId) == 0x000001, "Wrong alignment on HWLibrary_Core_NotEqual_FGenericTeamId");
static_assert(sizeof(HWLibrary_Core_NotEqual_FGenericTeamId) == 0x000003, "Wrong size on HWLibrary_Core_NotEqual_FGenericTeamId");
static_assert(offsetof(HWLibrary_Core_NotEqual_FGenericTeamId, A) == 0x000000, "Member 'HWLibrary_Core_NotEqual_FGenericTeamId::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_NotEqual_FGenericTeamId, B) == 0x000001, "Member 'HWLibrary_Core_NotEqual_FGenericTeamId::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_NotEqual_FGenericTeamId, ReturnValue) == 0x000002, "Member 'HWLibrary_Core_NotEqual_FGenericTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.NotEqual_FHWAbilityFiringInstanceId
// 0x0014 (0x0014 - 0x0000)
struct HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId final
{
public:
	struct FHWAbilityFiringInstanceId             A;                                                 // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             B;                                                 // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId) == 0x000004, "Wrong alignment on HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId");
static_assert(sizeof(HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId) == 0x000014, "Wrong size on HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId, A) == 0x000000, "Member 'HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId, B) == 0x000008, "Member 'HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId, ReturnValue) == 0x000010, "Member 'HWLibrary_Core_NotEqual_FHWAbilityFiringInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.NotEqual_FHWActiveFamiliarHandle
// 0x001C (0x001C - 0x0000)
struct HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle final
{
public:
	struct FHWActiveFamiliarHandle                A;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWActiveFamiliarHandle                B;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle) == 0x000004, "Wrong alignment on HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle");
static_assert(sizeof(HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle) == 0x00001C, "Wrong size on HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle, A) == 0x000000, "Member 'HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle, B) == 0x00000C, "Member 'HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle, ReturnValue) == 0x000018, "Member 'HWLibrary_Core_NotEqual_FHWActiveFamiliarHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.NotEqual_FHWActiveFamiliarInfo
// 0x00A8 (0x00A8 - 0x0000)
struct HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo final
{
public:
	struct FHWActiveFamiliarInfo                  A;                                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWActiveFamiliarInfo                  B;                                                 // 0x0050(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo) == 0x000008, "Wrong alignment on HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo");
static_assert(sizeof(HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo) == 0x0000A8, "Wrong size on HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo, A) == 0x000000, "Member 'HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo, B) == 0x000050, "Member 'HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo, ReturnValue) == 0x0000A0, "Member 'HWLibrary_Core_NotEqual_FHWActiveFamiliarInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.NotEqual_FHWPersistentPlayerId
// 0x0044 (0x0044 - 0x0000)
struct HWLibrary_Core_NotEqual_FHWPersistentPlayerId final
{
public:
	struct FHWPersistentPlayerId                  A;                                                 // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWPersistentPlayerId                  B;                                                 // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_NotEqual_FHWPersistentPlayerId) == 0x000004, "Wrong alignment on HWLibrary_Core_NotEqual_FHWPersistentPlayerId");
static_assert(sizeof(HWLibrary_Core_NotEqual_FHWPersistentPlayerId) == 0x000044, "Wrong size on HWLibrary_Core_NotEqual_FHWPersistentPlayerId");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWPersistentPlayerId, A) == 0x000000, "Member 'HWLibrary_Core_NotEqual_FHWPersistentPlayerId::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWPersistentPlayerId, B) == 0x000020, "Member 'HWLibrary_Core_NotEqual_FHWPersistentPlayerId::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_NotEqual_FHWPersistentPlayerId, ReturnValue) == 0x000040, "Member 'HWLibrary_Core_NotEqual_FHWPersistentPlayerId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.ParseMatchData
// 0x02D0 (0x02D0 - 0x0000)
struct HWLibrary_Core_ParseMatchData final
{
public:
	struct FRHAPI_MatchPlayerWithMatch            PlayerMatchData;                                   // 0x0000(0x0258)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWPlayerMatchData                     OutPlayerMatchData;                                // 0x0258(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_ParseMatchData) == 0x000008, "Wrong alignment on HWLibrary_Core_ParseMatchData");
static_assert(sizeof(HWLibrary_Core_ParseMatchData) == 0x0002D0, "Wrong size on HWLibrary_Core_ParseMatchData");
static_assert(offsetof(HWLibrary_Core_ParseMatchData, PlayerMatchData) == 0x000000, "Member 'HWLibrary_Core_ParseMatchData::PlayerMatchData' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ParseMatchData, OutPlayerMatchData) == 0x000258, "Member 'HWLibrary_Core_ParseMatchData::OutPlayerMatchData' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.ParsePlayerData
// 0x01A0 (0x01A0 - 0x0000)
struct HWLibrary_Core_ParsePlayerData final
{
public:
	struct FRHAPI_MatchPlayerResponse             PlayerMatchData;                                   // 0x0000(0x0120)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTimespan                              Duration;                                          // 0x0120(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWPlayerMatchData                     OutMatchData;                                      // 0x0128(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_ParsePlayerData) == 0x000008, "Wrong alignment on HWLibrary_Core_ParsePlayerData");
static_assert(sizeof(HWLibrary_Core_ParsePlayerData) == 0x0001A0, "Wrong size on HWLibrary_Core_ParsePlayerData");
static_assert(offsetof(HWLibrary_Core_ParsePlayerData, PlayerMatchData) == 0x000000, "Member 'HWLibrary_Core_ParsePlayerData::PlayerMatchData' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ParsePlayerData, Duration) == 0x000120, "Member 'HWLibrary_Core_ParsePlayerData::Duration' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ParsePlayerData, OutMatchData) == 0x000128, "Member 'HWLibrary_Core_ParsePlayerData::OutMatchData' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.ParsePlayerDataFromFullMatch
// 0x01F0 (0x01F0 - 0x0000)
struct HWLibrary_Core_ParsePlayerDataFromFullMatch final
{
public:
	struct FRHAPI_MatchWithPlayers                MatchData;                                         // 0x0000(0x0168)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGuid                                  RHPlayerUuid;                                      // 0x0168(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWPlayerMatchData                     OutPlayerMatchData;                                // 0x0178(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_ParsePlayerDataFromFullMatch) == 0x000008, "Wrong alignment on HWLibrary_Core_ParsePlayerDataFromFullMatch");
static_assert(sizeof(HWLibrary_Core_ParsePlayerDataFromFullMatch) == 0x0001F0, "Wrong size on HWLibrary_Core_ParsePlayerDataFromFullMatch");
static_assert(offsetof(HWLibrary_Core_ParsePlayerDataFromFullMatch, MatchData) == 0x000000, "Member 'HWLibrary_Core_ParsePlayerDataFromFullMatch::MatchData' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ParsePlayerDataFromFullMatch, RHPlayerUuid) == 0x000168, "Member 'HWLibrary_Core_ParsePlayerDataFromFullMatch::RHPlayerUuid' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ParsePlayerDataFromFullMatch, OutPlayerMatchData) == 0x000178, "Member 'HWLibrary_Core_ParsePlayerDataFromFullMatch::OutPlayerMatchData' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.RegisterToBooleanAppSettingUpdates
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_Core_RegisterToBooleanAppSettingUpdates final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SettingTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGameplayTag& AppSettingTag, bool bValue)> Callback;                 // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireInitialState;                                 // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValueIfNotFound;                                  // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_RegisterToBooleanAppSettingUpdates) == 0x000008, "Wrong alignment on HWLibrary_Core_RegisterToBooleanAppSettingUpdates");
static_assert(sizeof(HWLibrary_Core_RegisterToBooleanAppSettingUpdates) == 0x000028, "Wrong size on HWLibrary_Core_RegisterToBooleanAppSettingUpdates");
static_assert(offsetof(HWLibrary_Core_RegisterToBooleanAppSettingUpdates, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_RegisterToBooleanAppSettingUpdates::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToBooleanAppSettingUpdates, SettingTag) == 0x000008, "Member 'HWLibrary_Core_RegisterToBooleanAppSettingUpdates::SettingTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToBooleanAppSettingUpdates, Callback) == 0x000010, "Member 'HWLibrary_Core_RegisterToBooleanAppSettingUpdates::Callback' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToBooleanAppSettingUpdates, bFireInitialState) == 0x000020, "Member 'HWLibrary_Core_RegisterToBooleanAppSettingUpdates::bFireInitialState' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToBooleanAppSettingUpdates, bValueIfNotFound) == 0x000021, "Member 'HWLibrary_Core_RegisterToBooleanAppSettingUpdates::bValueIfNotFound' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.RegisterToIntegerAppSettingUpdates
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_Core_RegisterToIntegerAppSettingUpdates final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SettingTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGameplayTag& AppSettingTag, int32 Value)> Callback;                 // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireInitialState;                                 // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ValueIfNotFound;                                   // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_RegisterToIntegerAppSettingUpdates) == 0x000008, "Wrong alignment on HWLibrary_Core_RegisterToIntegerAppSettingUpdates");
static_assert(sizeof(HWLibrary_Core_RegisterToIntegerAppSettingUpdates) == 0x000028, "Wrong size on HWLibrary_Core_RegisterToIntegerAppSettingUpdates");
static_assert(offsetof(HWLibrary_Core_RegisterToIntegerAppSettingUpdates, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_RegisterToIntegerAppSettingUpdates::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToIntegerAppSettingUpdates, SettingTag) == 0x000008, "Member 'HWLibrary_Core_RegisterToIntegerAppSettingUpdates::SettingTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToIntegerAppSettingUpdates, Callback) == 0x000010, "Member 'HWLibrary_Core_RegisterToIntegerAppSettingUpdates::Callback' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToIntegerAppSettingUpdates, bFireInitialState) == 0x000020, "Member 'HWLibrary_Core_RegisterToIntegerAppSettingUpdates::bFireInitialState' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToIntegerAppSettingUpdates, ValueIfNotFound) == 0x000024, "Member 'HWLibrary_Core_RegisterToIntegerAppSettingUpdates::ValueIfNotFound' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.RegisterToStringAppSettingUpdates
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_Core_RegisterToStringAppSettingUpdates final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SettingTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGameplayTag& AppSettingTag, const class FString& Value)> Callback;  // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireInitialState;                                 // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_RegisterToStringAppSettingUpdates) == 0x000008, "Wrong alignment on HWLibrary_Core_RegisterToStringAppSettingUpdates");
static_assert(sizeof(HWLibrary_Core_RegisterToStringAppSettingUpdates) == 0x000028, "Wrong size on HWLibrary_Core_RegisterToStringAppSettingUpdates");
static_assert(offsetof(HWLibrary_Core_RegisterToStringAppSettingUpdates, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_RegisterToStringAppSettingUpdates::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToStringAppSettingUpdates, SettingTag) == 0x000008, "Member 'HWLibrary_Core_RegisterToStringAppSettingUpdates::SettingTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToStringAppSettingUpdates, Callback) == 0x000010, "Member 'HWLibrary_Core_RegisterToStringAppSettingUpdates::Callback' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToStringAppSettingUpdates, bFireInitialState) == 0x000020, "Member 'HWLibrary_Core_RegisterToStringAppSettingUpdates::bFireInitialState' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.RegisterToStringArrayAppSettingUpdates
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_Core_RegisterToStringArrayAppSettingUpdates final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SettingTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGameplayTag& AppSettingTag, const TArray<class FString>& Values)> Callback; // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireInitialState;                                 // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Delimiter;                                         // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_RegisterToStringArrayAppSettingUpdates) == 0x000008, "Wrong alignment on HWLibrary_Core_RegisterToStringArrayAppSettingUpdates");
static_assert(sizeof(HWLibrary_Core_RegisterToStringArrayAppSettingUpdates) == 0x000038, "Wrong size on HWLibrary_Core_RegisterToStringArrayAppSettingUpdates");
static_assert(offsetof(HWLibrary_Core_RegisterToStringArrayAppSettingUpdates, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_RegisterToStringArrayAppSettingUpdates::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToStringArrayAppSettingUpdates, SettingTag) == 0x000008, "Member 'HWLibrary_Core_RegisterToStringArrayAppSettingUpdates::SettingTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToStringArrayAppSettingUpdates, Callback) == 0x000010, "Member 'HWLibrary_Core_RegisterToStringArrayAppSettingUpdates::Callback' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToStringArrayAppSettingUpdates, bFireInitialState) == 0x000020, "Member 'HWLibrary_Core_RegisterToStringArrayAppSettingUpdates::bFireInitialState' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_RegisterToStringArrayAppSettingUpdates, Delimiter) == 0x000028, "Member 'HWLibrary_Core_RegisterToStringArrayAppSettingUpdates::Delimiter' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.ReturnToMainLobby
// 0x0008 (0x0008 - 0x0000)
struct HWLibrary_Core_ReturnToMainLobby final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_ReturnToMainLobby) == 0x000008, "Wrong alignment on HWLibrary_Core_ReturnToMainLobby");
static_assert(sizeof(HWLibrary_Core_ReturnToMainLobby) == 0x000008, "Wrong size on HWLibrary_Core_ReturnToMainLobby");
static_assert(offsetof(HWLibrary_Core_ReturnToMainLobby, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_ReturnToMainLobby::WorldContextObject' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.SetGenericTeamId
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_Core_SetGenericTeamId final
{
public:
	class AActor*                                 TeamMemberActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x0008(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_SetGenericTeamId) == 0x000008, "Wrong alignment on HWLibrary_Core_SetGenericTeamId");
static_assert(sizeof(HWLibrary_Core_SetGenericTeamId) == 0x000010, "Wrong size on HWLibrary_Core_SetGenericTeamId");
static_assert(offsetof(HWLibrary_Core_SetGenericTeamId, TeamMemberActor) == 0x000000, "Member 'HWLibrary_Core_SetGenericTeamId::TeamMemberActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_SetGenericTeamId, TeamId) == 0x000008, "Member 'HWLibrary_Core_SetGenericTeamId::TeamId' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.SetReflexMode
// 0x0001 (0x0001 - 0x0000)
struct HWLibrary_Core_SetReflexMode final
{
public:
	EHWNvidiaReflexMode                           Mode;                                              // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_SetReflexMode) == 0x000001, "Wrong alignment on HWLibrary_Core_SetReflexMode");
static_assert(sizeof(HWLibrary_Core_SetReflexMode) == 0x000001, "Wrong size on HWLibrary_Core_SetReflexMode");
static_assert(offsetof(HWLibrary_Core_SetReflexMode, Mode) == 0x000000, "Member 'HWLibrary_Core_SetReflexMode::Mode' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.SortActiveDraftPlayers
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_Core_SortActiveDraftPlayers final
{
public:
	TArray<struct FDraftTask>                     DraftTasks;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWPersistentPlayerId                  LHS;                                               // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWPersistentPlayerId                  RHS;                                               // 0x0030(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_SortActiveDraftPlayers) == 0x000008, "Wrong alignment on HWLibrary_Core_SortActiveDraftPlayers");
static_assert(sizeof(HWLibrary_Core_SortActiveDraftPlayers) == 0x000058, "Wrong size on HWLibrary_Core_SortActiveDraftPlayers");
static_assert(offsetof(HWLibrary_Core_SortActiveDraftPlayers, DraftTasks) == 0x000000, "Member 'HWLibrary_Core_SortActiveDraftPlayers::DraftTasks' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_SortActiveDraftPlayers, LHS) == 0x000010, "Member 'HWLibrary_Core_SortActiveDraftPlayers::LHS' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_SortActiveDraftPlayers, RHS) == 0x000030, "Member 'HWLibrary_Core_SortActiveDraftPlayers::RHS' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_SortActiveDraftPlayers, ReturnValue) == 0x000050, "Member 'HWLibrary_Core_SortActiveDraftPlayers::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.UnregisterToAppSettingUpdates
// 0x0008 (0x0008 - 0x0000)
struct HWLibrary_Core_UnregisterToAppSettingUpdates final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Core_UnregisterToAppSettingUpdates) == 0x000008, "Wrong alignment on HWLibrary_Core_UnregisterToAppSettingUpdates");
static_assert(sizeof(HWLibrary_Core_UnregisterToAppSettingUpdates) == 0x000008, "Wrong size on HWLibrary_Core_UnregisterToAppSettingUpdates");
static_assert(offsetof(HWLibrary_Core_UnregisterToAppSettingUpdates, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_UnregisterToAppSettingUpdates::WorldContextObject' has a wrong offset!");

// Function Hemingway.HWLibrary_Core.ValidateGroundLocation
// 0x0060 (0x0060 - 0x0000)
struct HWLibrary_Core_ValidateGroundLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CollisionExtents;                                  // 0x0038(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           SourceActor;                                       // 0x0050(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCapsule;                                        // 0x0058(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0059(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_Core_ValidateGroundLocation) == 0x000008, "Wrong alignment on HWLibrary_Core_ValidateGroundLocation");
static_assert(sizeof(HWLibrary_Core_ValidateGroundLocation) == 0x000060, "Wrong size on HWLibrary_Core_ValidateGroundLocation");
static_assert(offsetof(HWLibrary_Core_ValidateGroundLocation, WorldContextObject) == 0x000000, "Member 'HWLibrary_Core_ValidateGroundLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ValidateGroundLocation, Origin) == 0x000008, "Member 'HWLibrary_Core_ValidateGroundLocation::Origin' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ValidateGroundLocation, Orientation) == 0x000020, "Member 'HWLibrary_Core_ValidateGroundLocation::Orientation' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ValidateGroundLocation, CollisionExtents) == 0x000038, "Member 'HWLibrary_Core_ValidateGroundLocation::CollisionExtents' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ValidateGroundLocation, SourceActor) == 0x000050, "Member 'HWLibrary_Core_ValidateGroundLocation::SourceActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ValidateGroundLocation, bIsCapsule) == 0x000058, "Member 'HWLibrary_Core_ValidateGroundLocation::bIsCapsule' has a wrong offset!");
static_assert(offsetof(HWLibrary_Core_ValidateGroundLocation, ReturnValue) == 0x000059, "Member 'HWLibrary_Core_ValidateGroundLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_EscalatingDamageOnTarget.OnAdjustDamageToTarget
// 0x00C0 (0x00C0 - 0x0000)
struct HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget final
{
public:
	struct FGameplayTagContainer                  EffectTags;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FDamageCalcInfo                        DamageCalcInfo;                                    // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              BroadcastingAbilitySystemComponent;                // 0x00B0(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWAdjustAttributeEventType                   AdjustAttributeEventType;                          // 0x00B8(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDamage;                                        // 0x00BC(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget) == 0x000008, "Wrong alignment on HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget");
static_assert(sizeof(HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget) == 0x0000C0, "Wrong size on HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget");
static_assert(offsetof(HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget, EffectTags) == 0x000000, "Member 'HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget::EffectTags' has a wrong offset!");
static_assert(offsetof(HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget, DamageCalcInfo) == 0x000020, "Member 'HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget::DamageCalcInfo' has a wrong offset!");
static_assert(offsetof(HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget, BroadcastingAbilitySystemComponent) == 0x0000B0, "Member 'HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget::BroadcastingAbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget, AdjustAttributeEventType) == 0x0000B8, "Member 'HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget::AdjustAttributeEventType' has a wrong offset!");
static_assert(offsetof(HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget, BaseDamage) == 0x0000BC, "Member 'HWAbility_EscalatingDamageOnTarget_OnAdjustDamageToTarget::BaseDamage' has a wrong offset!");

// Function Hemingway.HWAbility_Inhand.BP_OnInhandResetTimerCompleted
// 0x0028 (0x0028 - 0x0000)
struct HWAbility_Inhand_BP_OnInhandResetTimerCompleted final
{
public:
	struct FGameplayEffectRemovalInfo             RemovalInfo;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Inhand_BP_OnInhandResetTimerCompleted) == 0x000008, "Wrong alignment on HWAbility_Inhand_BP_OnInhandResetTimerCompleted");
static_assert(sizeof(HWAbility_Inhand_BP_OnInhandResetTimerCompleted) == 0x000028, "Wrong size on HWAbility_Inhand_BP_OnInhandResetTimerCompleted");
static_assert(offsetof(HWAbility_Inhand_BP_OnInhandResetTimerCompleted, RemovalInfo) == 0x000000, "Member 'HWAbility_Inhand_BP_OnInhandResetTimerCompleted::RemovalInfo' has a wrong offset!");

// Function Hemingway.HWAbility_Inhand.OnAttackChainTimerTagUpdated
// 0x000C (0x000C - 0x0000)
struct HWAbility_Inhand_OnAttackChainTimerTagUpdated final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Inhand_OnAttackChainTimerTagUpdated) == 0x000004, "Wrong alignment on HWAbility_Inhand_OnAttackChainTimerTagUpdated");
static_assert(sizeof(HWAbility_Inhand_OnAttackChainTimerTagUpdated) == 0x00000C, "Wrong size on HWAbility_Inhand_OnAttackChainTimerTagUpdated");
static_assert(offsetof(HWAbility_Inhand_OnAttackChainTimerTagUpdated, CallbackTag) == 0x000000, "Member 'HWAbility_Inhand_OnAttackChainTimerTagUpdated::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWAbility_Inhand_OnAttackChainTimerTagUpdated, NewCount) == 0x000008, "Member 'HWAbility_Inhand_OnAttackChainTimerTagUpdated::NewCount' has a wrong offset!");

// Function Hemingway.HWAbility_Inhand.OnInhandResetTimerCompleted
// 0x0028 (0x0028 - 0x0000)
struct HWAbility_Inhand_OnInhandResetTimerCompleted final
{
public:
	struct FGameplayEffectRemovalInfo             RemovalInfo;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Inhand_OnInhandResetTimerCompleted) == 0x000008, "Wrong alignment on HWAbility_Inhand_OnInhandResetTimerCompleted");
static_assert(sizeof(HWAbility_Inhand_OnInhandResetTimerCompleted) == 0x000028, "Wrong size on HWAbility_Inhand_OnInhandResetTimerCompleted");
static_assert(offsetof(HWAbility_Inhand_OnInhandResetTimerCompleted, RemovalInfo) == 0x000000, "Member 'HWAbility_Inhand_OnInhandResetTimerCompleted::RemovalInfo' has a wrong offset!");

// Function Hemingway.HWAbility_Inhand.UpdateTargetingForInhandAttackChain
// 0x0004 (0x0004 - 0x0000)
struct HWAbility_Inhand_UpdateTargetingForInhandAttackChain final
{
public:
	int32                                         nChainIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Inhand_UpdateTargetingForInhandAttackChain) == 0x000004, "Wrong alignment on HWAbility_Inhand_UpdateTargetingForInhandAttackChain");
static_assert(sizeof(HWAbility_Inhand_UpdateTargetingForInhandAttackChain) == 0x000004, "Wrong size on HWAbility_Inhand_UpdateTargetingForInhandAttackChain");
static_assert(offsetof(HWAbility_Inhand_UpdateTargetingForInhandAttackChain, nChainIndex) == 0x000000, "Member 'HWAbility_Inhand_UpdateTargetingForInhandAttackChain::nChainIndex' has a wrong offset!");

// Function Hemingway.HWAbility_Inhand.GetCurrentInhandAttackChainIndex
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Inhand_GetCurrentInhandAttackChainIndex final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Inhand_GetCurrentInhandAttackChainIndex) == 0x000001, "Wrong alignment on HWAbility_Inhand_GetCurrentInhandAttackChainIndex");
static_assert(sizeof(HWAbility_Inhand_GetCurrentInhandAttackChainIndex) == 0x000001, "Wrong size on HWAbility_Inhand_GetCurrentInhandAttackChainIndex");
static_assert(offsetof(HWAbility_Inhand_GetCurrentInhandAttackChainIndex, ReturnValue) == 0x000000, "Member 'HWAbility_Inhand_GetCurrentInhandAttackChainIndex::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Inhand.GetCurrentInhandAttackChainTag
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Inhand_GetCurrentInhandAttackChainTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Inhand_GetCurrentInhandAttackChainTag) == 0x000004, "Wrong alignment on HWAbility_Inhand_GetCurrentInhandAttackChainTag");
static_assert(sizeof(HWAbility_Inhand_GetCurrentInhandAttackChainTag) == 0x000008, "Wrong size on HWAbility_Inhand_GetCurrentInhandAttackChainTag");
static_assert(offsetof(HWAbility_Inhand_GetCurrentInhandAttackChainTag, ReturnValue) == 0x000000, "Member 'HWAbility_Inhand_GetCurrentInhandAttackChainTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Inhand.GetMaxInhandAttackChainIndex
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Inhand_GetMaxInhandAttackChainIndex final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Inhand_GetMaxInhandAttackChainIndex) == 0x000001, "Wrong alignment on HWAbility_Inhand_GetMaxInhandAttackChainIndex");
static_assert(sizeof(HWAbility_Inhand_GetMaxInhandAttackChainIndex) == 0x000001, "Wrong size on HWAbility_Inhand_GetMaxInhandAttackChainIndex");
static_assert(offsetof(HWAbility_Inhand_GetMaxInhandAttackChainIndex, ReturnValue) == 0x000000, "Member 'HWAbility_Inhand_GetMaxInhandAttackChainIndex::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Inhand.IsAttackChainActive
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Inhand_IsAttackChainActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Inhand_IsAttackChainActive) == 0x000001, "Wrong alignment on HWAbility_Inhand_IsAttackChainActive");
static_assert(sizeof(HWAbility_Inhand_IsAttackChainActive) == 0x000001, "Wrong size on HWAbility_Inhand_IsAttackChainActive");
static_assert(offsetof(HWAbility_Inhand_IsAttackChainActive, ReturnValue) == 0x000000, "Member 'HWAbility_Inhand_IsAttackChainActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Inhand.ShouldIncrementInhandChainAttack
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Inhand_ShouldIncrementInhandChainAttack final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Inhand_ShouldIncrementInhandChainAttack) == 0x000001, "Wrong alignment on HWAbility_Inhand_ShouldIncrementInhandChainAttack");
static_assert(sizeof(HWAbility_Inhand_ShouldIncrementInhandChainAttack) == 0x000001, "Wrong size on HWAbility_Inhand_ShouldIncrementInhandChainAttack");
static_assert(offsetof(HWAbility_Inhand_ShouldIncrementInhandChainAttack, ReturnValue) == 0x000000, "Member 'HWAbility_Inhand_ShouldIncrementInhandChainAttack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Wall.OnBeginOverlapWithWall
// 0x0108 (0x0108 - 0x0000)
struct HWDeployable_Wall_OnBeginOverlapWithWall final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromSweep;                                         // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Wall_OnBeginOverlapWithWall) == 0x000008, "Wrong alignment on HWDeployable_Wall_OnBeginOverlapWithWall");
static_assert(sizeof(HWDeployable_Wall_OnBeginOverlapWithWall) == 0x000108, "Wrong size on HWDeployable_Wall_OnBeginOverlapWithWall");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWall, OverlappedComp) == 0x000000, "Member 'HWDeployable_Wall_OnBeginOverlapWithWall::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWall, OtherActor) == 0x000008, "Member 'HWDeployable_Wall_OnBeginOverlapWithWall::OtherActor' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWall, OtherComp) == 0x000010, "Member 'HWDeployable_Wall_OnBeginOverlapWithWall::OtherComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWall, OtherBodyIndex) == 0x000018, "Member 'HWDeployable_Wall_OnBeginOverlapWithWall::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWall, FromSweep) == 0x00001C, "Member 'HWDeployable_Wall_OnBeginOverlapWithWall::FromSweep' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWall, SweepResult) == 0x000020, "Member 'HWDeployable_Wall_OnBeginOverlapWithWall::SweepResult' has a wrong offset!");

// Function Hemingway.HWDeployable_Wall.OnBeginOverlapWithWallPushoutCollision
// 0x0108 (0x0108 - 0x0000)
struct HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromSweep;                                         // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision) == 0x000008, "Wrong alignment on HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision");
static_assert(sizeof(HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision) == 0x000108, "Wrong size on HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision, OverlappedComp) == 0x000000, "Member 'HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision, OtherActor) == 0x000008, "Member 'HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision::OtherActor' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision, OtherComp) == 0x000010, "Member 'HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision::OtherComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision, OtherBodyIndex) == 0x000018, "Member 'HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision, FromSweep) == 0x00001C, "Member 'HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision::FromSweep' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision, SweepResult) == 0x000020, "Member 'HWDeployable_Wall_OnBeginOverlapWithWallPushoutCollision::SweepResult' has a wrong offset!");

// Function Hemingway.HWDeployable_Wall.OnEndOverlapWithWall
// 0x0020 (0x0020 - 0x0000)
struct HWDeployable_Wall_OnEndOverlapWithWall final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDeployable_Wall_OnEndOverlapWithWall) == 0x000008, "Wrong alignment on HWDeployable_Wall_OnEndOverlapWithWall");
static_assert(sizeof(HWDeployable_Wall_OnEndOverlapWithWall) == 0x000020, "Wrong size on HWDeployable_Wall_OnEndOverlapWithWall");
static_assert(offsetof(HWDeployable_Wall_OnEndOverlapWithWall, OverlappedComp) == 0x000000, "Member 'HWDeployable_Wall_OnEndOverlapWithWall::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnEndOverlapWithWall, Other) == 0x000008, "Member 'HWDeployable_Wall_OnEndOverlapWithWall::Other' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnEndOverlapWithWall, OtherComp) == 0x000010, "Member 'HWDeployable_Wall_OnEndOverlapWithWall::OtherComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnEndOverlapWithWall, OtherBodyIndex) == 0x000018, "Member 'HWDeployable_Wall_OnEndOverlapWithWall::OtherBodyIndex' has a wrong offset!");

// Function Hemingway.HWDeployable_Wall.OnEndOverlapWithWallPushoutCollision
// 0x0020 (0x0020 - 0x0000)
struct HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision) == 0x000008, "Wrong alignment on HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision");
static_assert(sizeof(HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision) == 0x000020, "Wrong size on HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision");
static_assert(offsetof(HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision, OverlappedComp) == 0x000000, "Member 'HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision, Other) == 0x000008, "Member 'HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision::Other' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision, OtherComp) == 0x000010, "Member 'HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision::OtherComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision, OtherBodyIndex) == 0x000018, "Member 'HWDeployable_Wall_OnEndOverlapWithWallPushoutCollision::OtherBodyIndex' has a wrong offset!");

// Function Hemingway.HWDeployable_Wall.CanPushOverlappingActors
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Wall_CanPushOverlappingActors final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Wall_CanPushOverlappingActors) == 0x000001, "Wrong alignment on HWDeployable_Wall_CanPushOverlappingActors");
static_assert(sizeof(HWDeployable_Wall_CanPushOverlappingActors) == 0x000001, "Wrong size on HWDeployable_Wall_CanPushOverlappingActors");
static_assert(offsetof(HWDeployable_Wall_CanPushOverlappingActors, ReturnValue) == 0x000000, "Member 'HWDeployable_Wall_CanPushOverlappingActors::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Wall.ShouldPushActor
// 0x0010 (0x0010 - 0x0000)
struct HWDeployable_Wall_ShouldPushActor final
{
public:
	const class AActor*                           Other;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDeployable_Wall_ShouldPushActor) == 0x000008, "Wrong alignment on HWDeployable_Wall_ShouldPushActor");
static_assert(sizeof(HWDeployable_Wall_ShouldPushActor) == 0x000010, "Wrong size on HWDeployable_Wall_ShouldPushActor");
static_assert(offsetof(HWDeployable_Wall_ShouldPushActor, Other) == 0x000000, "Member 'HWDeployable_Wall_ShouldPushActor::Other' has a wrong offset!");
static_assert(offsetof(HWDeployable_Wall_ShouldPushActor, ReturnValue) == 0x000008, "Member 'HWDeployable_Wall_ShouldPushActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Pele_Inhand.OnConeAttackTagUpdated
// 0x000C (0x000C - 0x0000)
struct HWAbility_Pele_Inhand_OnConeAttackTagUpdated final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Pele_Inhand_OnConeAttackTagUpdated) == 0x000004, "Wrong alignment on HWAbility_Pele_Inhand_OnConeAttackTagUpdated");
static_assert(sizeof(HWAbility_Pele_Inhand_OnConeAttackTagUpdated) == 0x00000C, "Wrong size on HWAbility_Pele_Inhand_OnConeAttackTagUpdated");
static_assert(offsetof(HWAbility_Pele_Inhand_OnConeAttackTagUpdated, CallbackTag) == 0x000000, "Member 'HWAbility_Pele_Inhand_OnConeAttackTagUpdated::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWAbility_Pele_Inhand_OnConeAttackTagUpdated, NewCount) == 0x000008, "Member 'HWAbility_Pele_Inhand_OnConeAttackTagUpdated::NewCount' has a wrong offset!");

// Function Hemingway.HWLocalPlayerLoadoutSubsystem.GetEquippedBadgesForGod
// 0x0018 (0x0018 - 0x0000)
struct HWLocalPlayerLoadoutSubsystem_GetEquippedBadgesForGod final
{
public:
	const class UHWCharacterItem*                 GodItem;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHWCollectionItem*>              OutBadgeItems;                                     // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerLoadoutSubsystem_GetEquippedBadgesForGod) == 0x000008, "Wrong alignment on HWLocalPlayerLoadoutSubsystem_GetEquippedBadgesForGod");
static_assert(sizeof(HWLocalPlayerLoadoutSubsystem_GetEquippedBadgesForGod) == 0x000018, "Wrong size on HWLocalPlayerLoadoutSubsystem_GetEquippedBadgesForGod");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetEquippedBadgesForGod, GodItem) == 0x000000, "Member 'HWLocalPlayerLoadoutSubsystem_GetEquippedBadgesForGod::GodItem' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetEquippedBadgesForGod, OutBadgeItems) == 0x000008, "Member 'HWLocalPlayerLoadoutSubsystem_GetEquippedBadgesForGod::OutBadgeItems' has a wrong offset!");

// Function Hemingway.HWLocalPlayerLoadoutSubsystem.GetEquippedSkinForGod
// 0x0010 (0x0010 - 0x0000)
struct HWLocalPlayerLoadoutSubsystem_GetEquippedSkinForGod final
{
public:
	const class UHWCharacterItem*                 GodItem;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWSkinItem*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerLoadoutSubsystem_GetEquippedSkinForGod) == 0x000008, "Wrong alignment on HWLocalPlayerLoadoutSubsystem_GetEquippedSkinForGod");
static_assert(sizeof(HWLocalPlayerLoadoutSubsystem_GetEquippedSkinForGod) == 0x000010, "Wrong size on HWLocalPlayerLoadoutSubsystem_GetEquippedSkinForGod");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetEquippedSkinForGod, GodItem) == 0x000000, "Member 'HWLocalPlayerLoadoutSubsystem_GetEquippedSkinForGod::GodItem' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetEquippedSkinForGod, ReturnValue) == 0x000008, "Member 'HWLocalPlayerLoadoutSubsystem_GetEquippedSkinForGod::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLocalPlayerLoadoutSubsystem.GetEquippedTrackersForGod
// 0x0018 (0x0018 - 0x0000)
struct HWLocalPlayerLoadoutSubsystem_GetEquippedTrackersForGod final
{
public:
	const class UHWCharacterItem*                 GodItem;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHWCollectionItem*>              OutTrackerItems;                                   // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerLoadoutSubsystem_GetEquippedTrackersForGod) == 0x000008, "Wrong alignment on HWLocalPlayerLoadoutSubsystem_GetEquippedTrackersForGod");
static_assert(sizeof(HWLocalPlayerLoadoutSubsystem_GetEquippedTrackersForGod) == 0x000018, "Wrong size on HWLocalPlayerLoadoutSubsystem_GetEquippedTrackersForGod");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetEquippedTrackersForGod, GodItem) == 0x000000, "Member 'HWLocalPlayerLoadoutSubsystem_GetEquippedTrackersForGod::GodItem' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetEquippedTrackersForGod, OutTrackerItems) == 0x000008, "Member 'HWLocalPlayerLoadoutSubsystem_GetEquippedTrackersForGod::OutTrackerItems' has a wrong offset!");

// Function Hemingway.HWLocalPlayerLoadoutSubsystem.GetGodLoadout
// 0x0138 (0x0138 - 0x0000)
struct HWLocalPlayerLoadoutSubsystem_GetGodLoadout final
{
public:
	const class UHWCharacterItem*                 GodItem;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWGodLoadout                          OutLoadout;                                        // 0x0008(0x0128)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          bCreateIfMissing;                                  // 0x0130(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0131(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLocalPlayerLoadoutSubsystem_GetGodLoadout) == 0x000008, "Wrong alignment on HWLocalPlayerLoadoutSubsystem_GetGodLoadout");
static_assert(sizeof(HWLocalPlayerLoadoutSubsystem_GetGodLoadout) == 0x000138, "Wrong size on HWLocalPlayerLoadoutSubsystem_GetGodLoadout");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetGodLoadout, GodItem) == 0x000000, "Member 'HWLocalPlayerLoadoutSubsystem_GetGodLoadout::GodItem' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetGodLoadout, OutLoadout) == 0x000008, "Member 'HWLocalPlayerLoadoutSubsystem_GetGodLoadout::OutLoadout' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetGodLoadout, bCreateIfMissing) == 0x000130, "Member 'HWLocalPlayerLoadoutSubsystem_GetGodLoadout::bCreateIfMissing' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetGodLoadout, ReturnValue) == 0x000131, "Member 'HWLocalPlayerLoadoutSubsystem_GetGodLoadout::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLocalPlayerLoadoutSubsystem.GetPlayerLoadoutItem
// 0x0010 (0x0010 - 0x0000)
struct HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem final
{
public:
	EHWCollectionItemType                         ItemType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWCollectionItem*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem) == 0x000008, "Wrong alignment on HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem");
static_assert(sizeof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem) == 0x000010, "Wrong size on HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem, ItemType) == 0x000000, "Member 'HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem::ItemType' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem, SlotIndex) == 0x000004, "Member 'HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem::SlotIndex' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem, ReturnValue) == 0x000008, "Member 'HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLocalPlayerLoadoutSubsystem.GetPlayerLoadoutItemId
// 0x001C (0x001C - 0x0000)
struct HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId final
{
public:
	EHWCollectionItemType                         ItemType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             ReturnValue;                                       // 0x0008(0x0014)(ConstParm, Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId) == 0x000004, "Wrong alignment on HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId");
static_assert(sizeof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId) == 0x00001C, "Wrong size on HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId, ItemType) == 0x000000, "Member 'HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId::ItemType' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId, SlotIndex) == 0x000004, "Member 'HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId::SlotIndex' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId, ReturnValue) == 0x000008, "Member 'HWLocalPlayerLoadoutSubsystem_GetPlayerLoadoutItemId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLocalPlayerLoadoutSubsystem.AreLocalGodLoadoutsLoaded
// 0x0001 (0x0001 - 0x0000)
struct HWLocalPlayerLoadoutSubsystem_AreLocalGodLoadoutsLoaded final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerLoadoutSubsystem_AreLocalGodLoadoutsLoaded) == 0x000001, "Wrong alignment on HWLocalPlayerLoadoutSubsystem_AreLocalGodLoadoutsLoaded");
static_assert(sizeof(HWLocalPlayerLoadoutSubsystem_AreLocalGodLoadoutsLoaded) == 0x000001, "Wrong size on HWLocalPlayerLoadoutSubsystem_AreLocalGodLoadoutsLoaded");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_AreLocalGodLoadoutsLoaded, ReturnValue) == 0x000000, "Member 'HWLocalPlayerLoadoutSubsystem_AreLocalGodLoadoutsLoaded::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLocalPlayerLoadoutSubsystem.GetPlayerLoadout
// 0x00B8 (0x00B8 - 0x0000)
struct HWLocalPlayerLoadoutSubsystem_GetPlayerLoadout final
{
public:
	struct FHWPlayerLoadout                       ReturnValue;                                       // 0x0000(0x00B8)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadout) == 0x000008, "Wrong alignment on HWLocalPlayerLoadoutSubsystem_GetPlayerLoadout");
static_assert(sizeof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadout) == 0x0000B8, "Wrong size on HWLocalPlayerLoadoutSubsystem_GetPlayerLoadout");
static_assert(offsetof(HWLocalPlayerLoadoutSubsystem_GetPlayerLoadout, ReturnValue) == 0x000000, "Member 'HWLocalPlayerLoadoutSubsystem_GetPlayerLoadout::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Rama_Talent1_Listener.OnEquipmentSlotChanged
// 0x0020 (0x0020 - 0x0000)
struct HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged final
{
public:
	class UHWInventoryManagerComponent*           InventoryManager;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       Slot;                                              // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWInventoryChangeReason                      InventoryChangeReason;                             // 0x001C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged) == 0x000008, "Wrong alignment on HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged");
static_assert(sizeof(HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged) == 0x000020, "Wrong size on HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged");
static_assert(offsetof(HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged, InventoryManager) == 0x000000, "Member 'HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged::InventoryManager' has a wrong offset!");
static_assert(offsetof(HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged, EquipmentInstance) == 0x000008, "Member 'HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged, Slot) == 0x000010, "Member 'HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged::Slot' has a wrong offset!");
static_assert(offsetof(HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged, InventoryChangeReason) == 0x00001C, "Member 'HWAbility_Rama_Talent1_Listener_OnEquipmentSlotChanged::InventoryChangeReason' has a wrong offset!");

// Function Hemingway.HWAbility_Susano_A03_Refire.FindSafeTeleportSpot
// 0x0040 (0x0040 - 0x0000)
struct HWAbility_Susano_A03_Refire_FindSafeTeleportSpot final
{
public:
	const class AActor*                           TestActor;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaceLocation;                                     // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlaceRotation;                                     // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Susano_A03_Refire_FindSafeTeleportSpot) == 0x000008, "Wrong alignment on HWAbility_Susano_A03_Refire_FindSafeTeleportSpot");
static_assert(sizeof(HWAbility_Susano_A03_Refire_FindSafeTeleportSpot) == 0x000040, "Wrong size on HWAbility_Susano_A03_Refire_FindSafeTeleportSpot");
static_assert(offsetof(HWAbility_Susano_A03_Refire_FindSafeTeleportSpot, TestActor) == 0x000000, "Member 'HWAbility_Susano_A03_Refire_FindSafeTeleportSpot::TestActor' has a wrong offset!");
static_assert(offsetof(HWAbility_Susano_A03_Refire_FindSafeTeleportSpot, PlaceLocation) == 0x000008, "Member 'HWAbility_Susano_A03_Refire_FindSafeTeleportSpot::PlaceLocation' has a wrong offset!");
static_assert(offsetof(HWAbility_Susano_A03_Refire_FindSafeTeleportSpot, PlaceRotation) == 0x000020, "Member 'HWAbility_Susano_A03_Refire_FindSafeTeleportSpot::PlaceRotation' has a wrong offset!");
static_assert(offsetof(HWAbility_Susano_A03_Refire_FindSafeTeleportSpot, ReturnValue) == 0x000038, "Member 'HWAbility_Susano_A03_Refire_FindSafeTeleportSpot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings.IsMultipleSupported
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponentSettings_IsMultipleSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_IsMultipleSupported) == 0x000001, "Wrong alignment on HWEquipmentComponentSettings_IsMultipleSupported");
static_assert(sizeof(HWEquipmentComponentSettings_IsMultipleSupported) == 0x000001, "Wrong size on HWEquipmentComponentSettings_IsMultipleSupported");
static_assert(offsetof(HWEquipmentComponentSettings_IsMultipleSupported, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_IsMultipleSupported::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Susano_A04.OnAdjustDamageToTarget
// 0x00C0 (0x00C0 - 0x0000)
struct HWAbility_Susano_A04_OnAdjustDamageToTarget final
{
public:
	struct FGameplayTagContainer                  EffectTags;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FDamageCalcInfo                        DamageCalcInfo;                                    // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              BroadcastingAbilitySystemComponent;                // 0x00B0(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWAdjustAttributeEventType                   AdjustAttributeEventType;                          // 0x00B8(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDamageValue;                                   // 0x00BC(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Susano_A04_OnAdjustDamageToTarget) == 0x000008, "Wrong alignment on HWAbility_Susano_A04_OnAdjustDamageToTarget");
static_assert(sizeof(HWAbility_Susano_A04_OnAdjustDamageToTarget) == 0x0000C0, "Wrong size on HWAbility_Susano_A04_OnAdjustDamageToTarget");
static_assert(offsetof(HWAbility_Susano_A04_OnAdjustDamageToTarget, EffectTags) == 0x000000, "Member 'HWAbility_Susano_A04_OnAdjustDamageToTarget::EffectTags' has a wrong offset!");
static_assert(offsetof(HWAbility_Susano_A04_OnAdjustDamageToTarget, DamageCalcInfo) == 0x000020, "Member 'HWAbility_Susano_A04_OnAdjustDamageToTarget::DamageCalcInfo' has a wrong offset!");
static_assert(offsetof(HWAbility_Susano_A04_OnAdjustDamageToTarget, BroadcastingAbilitySystemComponent) == 0x0000B0, "Member 'HWAbility_Susano_A04_OnAdjustDamageToTarget::BroadcastingAbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(HWAbility_Susano_A04_OnAdjustDamageToTarget, AdjustAttributeEventType) == 0x0000B8, "Member 'HWAbility_Susano_A04_OnAdjustDamageToTarget::AdjustAttributeEventType' has a wrong offset!");
static_assert(offsetof(HWAbility_Susano_A04_OnAdjustDamageToTarget, BaseDamageValue) == 0x0000BC, "Member 'HWAbility_Susano_A04_OnAdjustDamageToTarget::BaseDamageValue' has a wrong offset!");

// Function Hemingway.HWAbility_Susano_A04.OnDeath
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Susano_A04_OnDeath final
{
public:
	class AHWCharacterAbilitySystemActor*         CharacterAbilitySystemActor;                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnTimerDuration;                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Susano_A04_OnDeath) == 0x000008, "Wrong alignment on HWAbility_Susano_A04_OnDeath");
static_assert(sizeof(HWAbility_Susano_A04_OnDeath) == 0x000010, "Wrong size on HWAbility_Susano_A04_OnDeath");
static_assert(offsetof(HWAbility_Susano_A04_OnDeath, CharacterAbilitySystemActor) == 0x000000, "Member 'HWAbility_Susano_A04_OnDeath::CharacterAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWAbility_Susano_A04_OnDeath, RespawnTimerDuration) == 0x000008, "Member 'HWAbility_Susano_A04_OnDeath::RespawnTimerDuration' has a wrong offset!");

// Function Hemingway.HWSettingsInfo_Generic.GetVersion
// 0x0004 (0x0004 - 0x0000)
struct HWSettingsInfo_Generic_GetVersion final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSettingsInfo_Generic_GetVersion) == 0x000004, "Wrong alignment on HWSettingsInfo_Generic_GetVersion");
static_assert(sizeof(HWSettingsInfo_Generic_GetVersion) == 0x000004, "Wrong size on HWSettingsInfo_Generic_GetVersion");
static_assert(offsetof(HWSettingsInfo_Generic_GetVersion, ReturnValue) == 0x000000, "Member 'HWSettingsInfo_Generic_GetVersion::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_VGS.HandleAbilityTaskReceived
// 0x00B0 (0x00B0 - 0x0000)
struct HWAbility_VGS_HandleAbilityTaskReceived final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_VGS_HandleAbilityTaskReceived) == 0x000008, "Wrong alignment on HWAbility_VGS_HandleAbilityTaskReceived");
static_assert(sizeof(HWAbility_VGS_HandleAbilityTaskReceived) == 0x0000B0, "Wrong size on HWAbility_VGS_HandleAbilityTaskReceived");
static_assert(offsetof(HWAbility_VGS_HandleAbilityTaskReceived, Payload) == 0x000000, "Member 'HWAbility_VGS_HandleAbilityTaskReceived::Payload' has a wrong offset!");

// Function Hemingway.HWAbility_VGS.HandleCancelTaskReceived
// 0x00B0 (0x00B0 - 0x0000)
struct HWAbility_VGS_HandleCancelTaskReceived final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_VGS_HandleCancelTaskReceived) == 0x000008, "Wrong alignment on HWAbility_VGS_HandleCancelTaskReceived");
static_assert(sizeof(HWAbility_VGS_HandleCancelTaskReceived) == 0x0000B0, "Wrong size on HWAbility_VGS_HandleCancelTaskReceived");
static_assert(offsetof(HWAbility_VGS_HandleCancelTaskReceived, Payload) == 0x000000, "Member 'HWAbility_VGS_HandleCancelTaskReceived::Payload' has a wrong offset!");

// Function Hemingway.HWBoosterSubsystem.ApplyBooster
// 0x001C (0x001C - 0x0000)
struct HWBoosterSubsystem_ApplyBooster final
{
public:
	struct FGuid                                  PlayerId;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BoosterTag;                                        // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x0018(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWBoosterSubsystem_ApplyBooster) == 0x000004, "Wrong alignment on HWBoosterSubsystem_ApplyBooster");
static_assert(sizeof(HWBoosterSubsystem_ApplyBooster) == 0x00001C, "Wrong size on HWBoosterSubsystem_ApplyBooster");
static_assert(offsetof(HWBoosterSubsystem_ApplyBooster, PlayerId) == 0x000000, "Member 'HWBoosterSubsystem_ApplyBooster::PlayerId' has a wrong offset!");
static_assert(offsetof(HWBoosterSubsystem_ApplyBooster, BoosterTag) == 0x000010, "Member 'HWBoosterSubsystem_ApplyBooster::BoosterTag' has a wrong offset!");
static_assert(offsetof(HWBoosterSubsystem_ApplyBooster, TeamId) == 0x000018, "Member 'HWBoosterSubsystem_ApplyBooster::TeamId' has a wrong offset!");

// Function Hemingway.HWBoosterSubsystem.UpdateAppliedTeamBoosters
// 0x0050 (0x0050 - 0x0000)
struct HWBoosterSubsystem_UpdateAppliedTeamBoosters final
{
public:
	TMap<struct FGenericTeamId, struct FHWTeamBoosters> InAppliedTeamBoosters;                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBoosterSubsystem_UpdateAppliedTeamBoosters) == 0x000008, "Wrong alignment on HWBoosterSubsystem_UpdateAppliedTeamBoosters");
static_assert(sizeof(HWBoosterSubsystem_UpdateAppliedTeamBoosters) == 0x000050, "Wrong size on HWBoosterSubsystem_UpdateAppliedTeamBoosters");
static_assert(offsetof(HWBoosterSubsystem_UpdateAppliedTeamBoosters, InAppliedTeamBoosters) == 0x000000, "Member 'HWBoosterSubsystem_UpdateAppliedTeamBoosters::InAppliedTeamBoosters' has a wrong offset!");

// Function Hemingway.HWBoosterSubsystem.UpdateGrantedSkins
// 0x0050 (0x0050 - 0x0000)
struct HWBoosterSubsystem_UpdateGrantedSkins final
{
public:
	TMap<struct FGenericTeamId, struct FHWTeamGrantedSkins> InGrantedSkinItems;                      // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBoosterSubsystem_UpdateGrantedSkins) == 0x000008, "Wrong alignment on HWBoosterSubsystem_UpdateGrantedSkins");
static_assert(sizeof(HWBoosterSubsystem_UpdateGrantedSkins) == 0x000050, "Wrong size on HWBoosterSubsystem_UpdateGrantedSkins");
static_assert(offsetof(HWBoosterSubsystem_UpdateGrantedSkins, InGrantedSkinItems) == 0x000000, "Member 'HWBoosterSubsystem_UpdateGrantedSkins::InGrantedSkinItems' has a wrong offset!");

// Function Hemingway.HWBoosterSubsystem.GetBoosterConfig
// 0x0040 (0x0040 - 0x0000)
struct HWBoosterSubsystem_GetBoosterConfig final
{
public:
	struct FGameplayTag                           BoosterTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWBoosterTableRow                     OutBoosterConfig;                                  // 0x0008(0x0030)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWBoosterSubsystem_GetBoosterConfig) == 0x000008, "Wrong alignment on HWBoosterSubsystem_GetBoosterConfig");
static_assert(sizeof(HWBoosterSubsystem_GetBoosterConfig) == 0x000040, "Wrong size on HWBoosterSubsystem_GetBoosterConfig");
static_assert(offsetof(HWBoosterSubsystem_GetBoosterConfig, BoosterTag) == 0x000000, "Member 'HWBoosterSubsystem_GetBoosterConfig::BoosterTag' has a wrong offset!");
static_assert(offsetof(HWBoosterSubsystem_GetBoosterConfig, OutBoosterConfig) == 0x000008, "Member 'HWBoosterSubsystem_GetBoosterConfig::OutBoosterConfig' has a wrong offset!");
static_assert(offsetof(HWBoosterSubsystem_GetBoosterConfig, ReturnValue) == 0x000038, "Member 'HWBoosterSubsystem_GetBoosterConfig::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBoosterSubsystem.IsSkinGrantedByBooster
// 0x0010 (0x0010 - 0x0000)
struct HWBoosterSubsystem_IsSkinGrantedByBooster final
{
public:
	const class UHWSkinItem*                      SkinItem;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x0008(0x0001)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWBoosterSubsystem_IsSkinGrantedByBooster) == 0x000008, "Wrong alignment on HWBoosterSubsystem_IsSkinGrantedByBooster");
static_assert(sizeof(HWBoosterSubsystem_IsSkinGrantedByBooster) == 0x000010, "Wrong size on HWBoosterSubsystem_IsSkinGrantedByBooster");
static_assert(offsetof(HWBoosterSubsystem_IsSkinGrantedByBooster, SkinItem) == 0x000000, "Member 'HWBoosterSubsystem_IsSkinGrantedByBooster::SkinItem' has a wrong offset!");
static_assert(offsetof(HWBoosterSubsystem_IsSkinGrantedByBooster, TeamId) == 0x000008, "Member 'HWBoosterSubsystem_IsSkinGrantedByBooster::TeamId' has a wrong offset!");
static_assert(offsetof(HWBoosterSubsystem_IsSkinGrantedByBooster, ReturnValue) == 0x000009, "Member 'HWBoosterSubsystem_IsSkinGrantedByBooster::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Yemoja_PSV.OnYemojaCooldownAdjusted
// 0x0558 (0x0558 - 0x0000)
struct HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted final
{
public:
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0000(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectBeingModified;                               // 0x02A8(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         InCooldownMultiplier;                              // 0x0550(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InCooldownFlatDelta;                               // 0x0554(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted) == 0x000008, "Wrong alignment on HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted");
static_assert(sizeof(HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted) == 0x000558, "Wrong size on HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted");
static_assert(offsetof(HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted, EffectSpec) == 0x000000, "Member 'HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted::EffectSpec' has a wrong offset!");
static_assert(offsetof(HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted, EffectBeingModified) == 0x0002A8, "Member 'HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted::EffectBeingModified' has a wrong offset!");
static_assert(offsetof(HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted, InCooldownMultiplier) == 0x000550, "Member 'HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted::InCooldownMultiplier' has a wrong offset!");
static_assert(offsetof(HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted, InCooldownFlatDelta) == 0x000554, "Member 'HWAbility_Yemoja_PSV_OnYemojaCooldownAdjusted::InCooldownFlatDelta' has a wrong offset!");

// Function Hemingway.HWInterface_Visibility.AbilityAddVisibilityData
// 0x0010 (0x0010 - 0x0000)
struct HWInterface_Visibility_AbilityAddVisibilityData final
{
public:
	class UVisibilityData*                        NewVisibilityData;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             AbilitySpecHandle;                                 // 0x0008(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInterface_Visibility_AbilityAddVisibilityData) == 0x000008, "Wrong alignment on HWInterface_Visibility_AbilityAddVisibilityData");
static_assert(sizeof(HWInterface_Visibility_AbilityAddVisibilityData) == 0x000010, "Wrong size on HWInterface_Visibility_AbilityAddVisibilityData");
static_assert(offsetof(HWInterface_Visibility_AbilityAddVisibilityData, NewVisibilityData) == 0x000000, "Member 'HWInterface_Visibility_AbilityAddVisibilityData::NewVisibilityData' has a wrong offset!");
static_assert(offsetof(HWInterface_Visibility_AbilityAddVisibilityData, AbilitySpecHandle) == 0x000008, "Member 'HWInterface_Visibility_AbilityAddVisibilityData::AbilitySpecHandle' has a wrong offset!");

// Function Hemingway.HWInterface_Visibility.AbilityRemoveVisibilityData
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_Visibility_AbilityRemoveVisibilityData final
{
public:
	class UVisibilityData*                        OldVisibilityData;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Visibility_AbilityRemoveVisibilityData) == 0x000008, "Wrong alignment on HWInterface_Visibility_AbilityRemoveVisibilityData");
static_assert(sizeof(HWInterface_Visibility_AbilityRemoveVisibilityData) == 0x000008, "Wrong size on HWInterface_Visibility_AbilityRemoveVisibilityData");
static_assert(offsetof(HWInterface_Visibility_AbilityRemoveVisibilityData, OldVisibilityData) == 0x000000, "Member 'HWInterface_Visibility_AbilityRemoveVisibilityData::OldVisibilityData' has a wrong offset!");

// Function Hemingway.HWInterface_Visibility.SetVisibility
// 0x0002 (0x0002 - 0x0000)
struct HWInterface_Visibility_SetVisibility final
{
public:
	bool                                          bNewVisible;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWVisibilityType                             VisibilityType;                                    // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Visibility_SetVisibility) == 0x000001, "Wrong alignment on HWInterface_Visibility_SetVisibility");
static_assert(sizeof(HWInterface_Visibility_SetVisibility) == 0x000002, "Wrong size on HWInterface_Visibility_SetVisibility");
static_assert(offsetof(HWInterface_Visibility_SetVisibility, bNewVisible) == 0x000000, "Member 'HWInterface_Visibility_SetVisibility::bNewVisible' has a wrong offset!");
static_assert(offsetof(HWInterface_Visibility_SetVisibility, VisibilityType) == 0x000001, "Member 'HWInterface_Visibility_SetVisibility::VisibilityType' has a wrong offset!");

// Function Hemingway.HWInterface_Visibility.GetLineOfSightOrigin
// 0x0020 (0x0020 - 0x0000)
struct HWInterface_Visibility_GetLineOfSightOrigin final
{
public:
	struct FVector                                OutOrigin;                                         // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCameraLocation;                                // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInterface_Visibility_GetLineOfSightOrigin) == 0x000008, "Wrong alignment on HWInterface_Visibility_GetLineOfSightOrigin");
static_assert(sizeof(HWInterface_Visibility_GetLineOfSightOrigin) == 0x000020, "Wrong size on HWInterface_Visibility_GetLineOfSightOrigin");
static_assert(offsetof(HWInterface_Visibility_GetLineOfSightOrigin, OutOrigin) == 0x000000, "Member 'HWInterface_Visibility_GetLineOfSightOrigin::OutOrigin' has a wrong offset!");
static_assert(offsetof(HWInterface_Visibility_GetLineOfSightOrigin, bUseCameraLocation) == 0x000018, "Member 'HWInterface_Visibility_GetLineOfSightOrigin::bUseCameraLocation' has a wrong offset!");

// Function Hemingway.HWInterface_Visibility.GetVisibilityComponent
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_Visibility_GetVisibilityComponent final
{
public:
	class UHWVisibilityComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Visibility_GetVisibilityComponent) == 0x000008, "Wrong alignment on HWInterface_Visibility_GetVisibilityComponent");
static_assert(sizeof(HWInterface_Visibility_GetVisibilityComponent) == 0x000008, "Wrong size on HWInterface_Visibility_GetVisibilityComponent");
static_assert(offsetof(HWInterface_Visibility_GetVisibilityComponent, ReturnValue) == 0x000000, "Member 'HWInterface_Visibility_GetVisibilityComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Visibility.IsValidForMinimap
// 0x0001 (0x0001 - 0x0000)
struct HWInterface_Visibility_IsValidForMinimap final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Visibility_IsValidForMinimap) == 0x000001, "Wrong alignment on HWInterface_Visibility_IsValidForMinimap");
static_assert(sizeof(HWInterface_Visibility_IsValidForMinimap) == 0x000001, "Wrong size on HWInterface_Visibility_IsValidForMinimap");
static_assert(offsetof(HWInterface_Visibility_IsValidForMinimap, ReturnValue) == 0x000000, "Member 'HWInterface_Visibility_IsValidForMinimap::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Visibility.VisGetAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_Visibility_VisGetAbilitySystemComponent final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Visibility_VisGetAbilitySystemComponent) == 0x000008, "Wrong alignment on HWInterface_Visibility_VisGetAbilitySystemComponent");
static_assert(sizeof(HWInterface_Visibility_VisGetAbilitySystemComponent) == 0x000008, "Wrong size on HWInterface_Visibility_VisGetAbilitySystemComponent");
static_assert(offsetof(HWInterface_Visibility_VisGetAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWInterface_Visibility_VisGetAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWVGSManager.AttemptPlayEmote
// 0x0180 (0x0180 - 0x0000)
struct HWVGSManager_AttemptPlayEmote final
{
public:
	struct FHWVGSActionRow                        Action;                                            // 0x0000(0x0170)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         PlayerState;                                       // 0x0170(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayOnRemoteClients;                        // 0x0178(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVGSManager_AttemptPlayEmote) == 0x000008, "Wrong alignment on HWVGSManager_AttemptPlayEmote");
static_assert(sizeof(HWVGSManager_AttemptPlayEmote) == 0x000180, "Wrong size on HWVGSManager_AttemptPlayEmote");
static_assert(offsetof(HWVGSManager_AttemptPlayEmote, Action) == 0x000000, "Member 'HWVGSManager_AttemptPlayEmote::Action' has a wrong offset!");
static_assert(offsetof(HWVGSManager_AttemptPlayEmote, PlayerState) == 0x000170, "Member 'HWVGSManager_AttemptPlayEmote::PlayerState' has a wrong offset!");
static_assert(offsetof(HWVGSManager_AttemptPlayEmote, bShouldPlayOnRemoteClients) == 0x000178, "Member 'HWVGSManager_AttemptPlayEmote::bShouldPlayOnRemoteClients' has a wrong offset!");

// Function Hemingway.HWVGSManager.GetItemQuantityForGC
// 0x0180 (0x0180 - 0x0000)
struct HWVGSManager_GetItemQuantityForGC final
{
public:
	struct FHWVGSActionRow                        Action;                                            // 0x0000(0x0170)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         PlayerState;                                       // 0x0170(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0178(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVGSManager_GetItemQuantityForGC) == 0x000008, "Wrong alignment on HWVGSManager_GetItemQuantityForGC");
static_assert(sizeof(HWVGSManager_GetItemQuantityForGC) == 0x000180, "Wrong size on HWVGSManager_GetItemQuantityForGC");
static_assert(offsetof(HWVGSManager_GetItemQuantityForGC, Action) == 0x000000, "Member 'HWVGSManager_GetItemQuantityForGC::Action' has a wrong offset!");
static_assert(offsetof(HWVGSManager_GetItemQuantityForGC, PlayerState) == 0x000170, "Member 'HWVGSManager_GetItemQuantityForGC::PlayerState' has a wrong offset!");
static_assert(offsetof(HWVGSManager_GetItemQuantityForGC, ReturnValue) == 0x000178, "Member 'HWVGSManager_GetItemQuantityForGC::ReturnValue' has a wrong offset!");

// Function Hemingway.HWVGSManager.GetQuestQuantityForGC
// 0x0180 (0x0180 - 0x0000)
struct HWVGSManager_GetQuestQuantityForGC final
{
public:
	struct FHWVGSActionRow                        Action;                                            // 0x0000(0x0170)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         PlayerState;                                       // 0x0170(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0178(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVGSManager_GetQuestQuantityForGC) == 0x000008, "Wrong alignment on HWVGSManager_GetQuestQuantityForGC");
static_assert(sizeof(HWVGSManager_GetQuestQuantityForGC) == 0x000180, "Wrong size on HWVGSManager_GetQuestQuantityForGC");
static_assert(offsetof(HWVGSManager_GetQuestQuantityForGC, Action) == 0x000000, "Member 'HWVGSManager_GetQuestQuantityForGC::Action' has a wrong offset!");
static_assert(offsetof(HWVGSManager_GetQuestQuantityForGC, PlayerState) == 0x000170, "Member 'HWVGSManager_GetQuestQuantityForGC::PlayerState' has a wrong offset!");
static_assert(offsetof(HWVGSManager_GetQuestQuantityForGC, ReturnValue) == 0x000178, "Member 'HWVGSManager_GetQuestQuantityForGC::ReturnValue' has a wrong offset!");

// Function Hemingway.HWVGSManager.HandlePostKeyHandled
// 0x0020 (0x0020 - 0x0000)
struct HWVGSManager_HandlePostKeyHandled final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputEvent;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVGSManager_HandlePostKeyHandled) == 0x000008, "Wrong alignment on HWVGSManager_HandlePostKeyHandled");
static_assert(sizeof(HWVGSManager_HandlePostKeyHandled) == 0x000020, "Wrong size on HWVGSManager_HandlePostKeyHandled");
static_assert(offsetof(HWVGSManager_HandlePostKeyHandled, Key) == 0x000000, "Member 'HWVGSManager_HandlePostKeyHandled::Key' has a wrong offset!");
static_assert(offsetof(HWVGSManager_HandlePostKeyHandled, InputEvent) == 0x000018, "Member 'HWVGSManager_HandlePostKeyHandled::InputEvent' has a wrong offset!");

// Function Hemingway.HWVGSManager.IsEmoteItemOwnershipRequired
// 0x0178 (0x0178 - 0x0000)
struct HWVGSManager_IsEmoteItemOwnershipRequired final
{
public:
	struct FHWVGSActionRow                        Action;                                            // 0x0000(0x0170)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0170(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVGSManager_IsEmoteItemOwnershipRequired) == 0x000008, "Wrong alignment on HWVGSManager_IsEmoteItemOwnershipRequired");
static_assert(sizeof(HWVGSManager_IsEmoteItemOwnershipRequired) == 0x000178, "Wrong size on HWVGSManager_IsEmoteItemOwnershipRequired");
static_assert(offsetof(HWVGSManager_IsEmoteItemOwnershipRequired, Action) == 0x000000, "Member 'HWVGSManager_IsEmoteItemOwnershipRequired::Action' has a wrong offset!");
static_assert(offsetof(HWVGSManager_IsEmoteItemOwnershipRequired, ReturnValue) == 0x000170, "Member 'HWVGSManager_IsEmoteItemOwnershipRequired::ReturnValue' has a wrong offset!");

// Function Hemingway.HWVGSManager.OnCollectionItemLoaded
// 0x01C0 (0x01C0 - 0x0000)
struct HWVGSManager_OnCollectionItemLoaded final
{
public:
	struct FHWVGSActionRow                        Action;                                            // 0x0000(0x0170)(Parm, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         PlayerState;                                       // 0x0170(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             ItemId;                                            // 0x0178(0x0014)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWCollectionItem>       CollectionItem;                                    // 0x0190(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayOnRemoteClients;                        // 0x01B8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVGSManager_OnCollectionItemLoaded) == 0x000008, "Wrong alignment on HWVGSManager_OnCollectionItemLoaded");
static_assert(sizeof(HWVGSManager_OnCollectionItemLoaded) == 0x0001C0, "Wrong size on HWVGSManager_OnCollectionItemLoaded");
static_assert(offsetof(HWVGSManager_OnCollectionItemLoaded, Action) == 0x000000, "Member 'HWVGSManager_OnCollectionItemLoaded::Action' has a wrong offset!");
static_assert(offsetof(HWVGSManager_OnCollectionItemLoaded, PlayerState) == 0x000170, "Member 'HWVGSManager_OnCollectionItemLoaded::PlayerState' has a wrong offset!");
static_assert(offsetof(HWVGSManager_OnCollectionItemLoaded, ItemId) == 0x000178, "Member 'HWVGSManager_OnCollectionItemLoaded::ItemId' has a wrong offset!");
static_assert(offsetof(HWVGSManager_OnCollectionItemLoaded, CollectionItem) == 0x000190, "Member 'HWVGSManager_OnCollectionItemLoaded::CollectionItem' has a wrong offset!");
static_assert(offsetof(HWVGSManager_OnCollectionItemLoaded, bShouldPlayOnRemoteClients) == 0x0001B8, "Member 'HWVGSManager_OnCollectionItemLoaded::bShouldPlayOnRemoteClients' has a wrong offset!");

// Function Hemingway.HWVGSManager.TriggerAction
// 0x0010 (0x0010 - 0x0000)
struct HWVGSManager_TriggerAction final
{
public:
	struct FGameplayTag                           ActionId;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Sender;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVGSManager_TriggerAction) == 0x000008, "Wrong alignment on HWVGSManager_TriggerAction");
static_assert(sizeof(HWVGSManager_TriggerAction) == 0x000010, "Wrong size on HWVGSManager_TriggerAction");
static_assert(offsetof(HWVGSManager_TriggerAction, ActionId) == 0x000000, "Member 'HWVGSManager_TriggerAction::ActionId' has a wrong offset!");
static_assert(offsetof(HWVGSManager_TriggerAction, Sender) == 0x000008, "Member 'HWVGSManager_TriggerAction::Sender' has a wrong offset!");

// Function Hemingway.HWVGSManager.MulticastSendVGS
// 0x0010 (0x0010 - 0x0000)
struct HWVGSManager_MulticastSendVGS final
{
public:
	class AActor*                                 Sender;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VgsEntry;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVGSManager_MulticastSendVGS) == 0x000008, "Wrong alignment on HWVGSManager_MulticastSendVGS");
static_assert(sizeof(HWVGSManager_MulticastSendVGS) == 0x000010, "Wrong size on HWVGSManager_MulticastSendVGS");
static_assert(offsetof(HWVGSManager_MulticastSendVGS, Sender) == 0x000000, "Member 'HWVGSManager_MulticastSendVGS::Sender' has a wrong offset!");
static_assert(offsetof(HWVGSManager_MulticastSendVGS, VgsEntry) == 0x000008, "Member 'HWVGSManager_MulticastSendVGS::VgsEntry' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_AbilitySwap.GetAbilitySwapBehavior
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponentSettings_AbilitySwap_GetAbilitySwapBehavior final
{
public:
	EHWAbilitySwapBehavior                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_AbilitySwap_GetAbilitySwapBehavior) == 0x000001, "Wrong alignment on HWEquipmentComponentSettings_AbilitySwap_GetAbilitySwapBehavior");
static_assert(sizeof(HWEquipmentComponentSettings_AbilitySwap_GetAbilitySwapBehavior) == 0x000001, "Wrong size on HWEquipmentComponentSettings_AbilitySwap_GetAbilitySwapBehavior");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetAbilitySwapBehavior, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetAbilitySwapBehavior::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_AbilitySwap.GetInputTagOverride
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponentSettings_AbilitySwap_GetInputTagOverride final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_AbilitySwap_GetInputTagOverride) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_AbilitySwap_GetInputTagOverride");
static_assert(sizeof(HWEquipmentComponentSettings_AbilitySwap_GetInputTagOverride) == 0x000008, "Wrong size on HWEquipmentComponentSettings_AbilitySwap_GetInputTagOverride");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetInputTagOverride, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetInputTagOverride::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_AbilitySwap.GetNumPhases
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponentSettings_AbilitySwap_GetNumPhases final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_AbilitySwap_GetNumPhases) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_AbilitySwap_GetNumPhases");
static_assert(sizeof(HWEquipmentComponentSettings_AbilitySwap_GetNumPhases) == 0x000004, "Wrong size on HWEquipmentComponentSettings_AbilitySwap_GetNumPhases");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetNumPhases, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetNumPhases::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_AbilitySwap.GetSwapAbilityAdditionalCooldownCost
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityAdditionalCooldownCost final
{
public:
	int32                                         PhaseIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityAdditionalCooldownCost) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityAdditionalCooldownCost");
static_assert(sizeof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityAdditionalCooldownCost) == 0x000008, "Wrong size on HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityAdditionalCooldownCost");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityAdditionalCooldownCost, PhaseIndex) == 0x000000, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityAdditionalCooldownCost::PhaseIndex' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityAdditionalCooldownCost, ReturnValue) == 0x000004, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityAdditionalCooldownCost::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_AbilitySwap.GetSwapAbilityDelay
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityDelay final
{
public:
	int32                                         PhaseIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityDelay) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityDelay");
static_assert(sizeof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityDelay) == 0x000008, "Wrong size on HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityDelay");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityDelay, PhaseIndex) == 0x000000, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityDelay::PhaseIndex' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityDelay, ReturnValue) == 0x000004, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityDelay::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_AbilitySwap.GetSwapAbilityWindowDuration
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityWindowDuration final
{
public:
	int32                                         PhaseIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityWindowDuration) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityWindowDuration");
static_assert(sizeof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityWindowDuration) == 0x000008, "Wrong size on HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityWindowDuration");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityWindowDuration, PhaseIndex) == 0x000000, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityWindowDuration::PhaseIndex' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityWindowDuration, ReturnValue) == 0x000004, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetSwapAbilityWindowDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_AbilitySwap.GetSwapEquipmentItem
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentComponentSettings_AbilitySwap_GetSwapEquipmentItem final
{
public:
	int32                                         PhaseIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWEquipmentItem*                 ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_AbilitySwap_GetSwapEquipmentItem) == 0x000008, "Wrong alignment on HWEquipmentComponentSettings_AbilitySwap_GetSwapEquipmentItem");
static_assert(sizeof(HWEquipmentComponentSettings_AbilitySwap_GetSwapEquipmentItem) == 0x000010, "Wrong size on HWEquipmentComponentSettings_AbilitySwap_GetSwapEquipmentItem");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetSwapEquipmentItem, PhaseIndex) == 0x000000, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetSwapEquipmentItem::PhaseIndex' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_GetSwapEquipmentItem, ReturnValue) == 0x000008, "Member 'HWEquipmentComponentSettings_AbilitySwap_GetSwapEquipmentItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_AbilitySwap.IsValidPhaseIndex
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponentSettings_AbilitySwap_IsValidPhaseIndex final
{
public:
	int32                                         PhaseIndex;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponentSettings_AbilitySwap_IsValidPhaseIndex) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_AbilitySwap_IsValidPhaseIndex");
static_assert(sizeof(HWEquipmentComponentSettings_AbilitySwap_IsValidPhaseIndex) == 0x000008, "Wrong size on HWEquipmentComponentSettings_AbilitySwap_IsValidPhaseIndex");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_IsValidPhaseIndex, PhaseIndex) == 0x000000, "Member 'HWEquipmentComponentSettings_AbilitySwap_IsValidPhaseIndex::PhaseIndex' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponentSettings_AbilitySwap_IsValidPhaseIndex, ReturnValue) == 0x000004, "Member 'HWEquipmentComponentSettings_AbilitySwap_IsValidPhaseIndex::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.ApplyObstacleAvoidanceToVectorField
// 0x0030 (0x0030 - 0x0000)
struct HWAIBlueprintLibrary_ApplyObstacleAvoidanceToVectorField final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWObstacleAvoidanceParams             avoidanceParams;                                   // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_ApplyObstacleAvoidanceToVectorField) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_ApplyObstacleAvoidanceToVectorField");
static_assert(sizeof(HWAIBlueprintLibrary_ApplyObstacleAvoidanceToVectorField) == 0x000030, "Wrong size on HWAIBlueprintLibrary_ApplyObstacleAvoidanceToVectorField");
static_assert(offsetof(HWAIBlueprintLibrary_ApplyObstacleAvoidanceToVectorField, WorldContextObject) == 0x000000, "Member 'HWAIBlueprintLibrary_ApplyObstacleAvoidanceToVectorField::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_ApplyObstacleAvoidanceToVectorField, avoidanceParams) == 0x000008, "Member 'HWAIBlueprintLibrary_ApplyObstacleAvoidanceToVectorField::avoidanceParams' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.AssignBotToNearestLane
// 0x0020 (0x0020 - 0x0000)
struct HWAIBlueprintLibrary_AssignBotToNearestLane final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Lanes;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ImmunityTag;                                       // 0x0018(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_AssignBotToNearestLane) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_AssignBotToNearestLane");
static_assert(sizeof(HWAIBlueprintLibrary_AssignBotToNearestLane) == 0x000020, "Wrong size on HWAIBlueprintLibrary_AssignBotToNearestLane");
static_assert(offsetof(HWAIBlueprintLibrary_AssignBotToNearestLane, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_AssignBotToNearestLane::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_AssignBotToNearestLane, Lanes) == 0x000008, "Member 'HWAIBlueprintLibrary_AssignBotToNearestLane::Lanes' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_AssignBotToNearestLane, ImmunityTag) == 0x000018, "Member 'HWAIBlueprintLibrary_AssignBotToNearestLane::ImmunityTag' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.CalculateAimPointWithPrediction
// 0x0050 (0x0050 - 0x0000)
struct HWAIBlueprintLibrary_CalculateAimPointWithPrediction final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWCharacter_Base*                TargetCharacter;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           abilityEquipPoint;                                 // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         abilitySlotIndex;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                outAimFromPoint;                                   // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                outAimToPoint;                                     // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_CalculateAimPointWithPrediction) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_CalculateAimPointWithPrediction");
static_assert(sizeof(HWAIBlueprintLibrary_CalculateAimPointWithPrediction) == 0x000050, "Wrong size on HWAIBlueprintLibrary_CalculateAimPointWithPrediction");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPrediction, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPrediction::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPrediction, TargetCharacter) == 0x000008, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPrediction::TargetCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPrediction, abilityEquipPoint) == 0x000010, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPrediction::abilityEquipPoint' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPrediction, abilitySlotIndex) == 0x000018, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPrediction::abilitySlotIndex' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPrediction, outAimFromPoint) == 0x000020, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPrediction::outAimFromPoint' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPrediction, outAimToPoint) == 0x000038, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPrediction::outAimToPoint' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.CalculateAimPointWithPredictionByLevelConfig
// 0x0048 (0x0048 - 0x0000)
struct HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWCharacter_Base*                TargetCharacter;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityLevelConfig*            levelConfig;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                outAimFromPoint;                                   // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                outAimToPoint;                                     // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig");
static_assert(sizeof(HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig) == 0x000048, "Wrong size on HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig, TargetCharacter) == 0x000008, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig::TargetCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig, levelConfig) == 0x000010, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig::levelConfig' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig, outAimFromPoint) == 0x000018, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig::outAimFromPoint' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig, outAimToPoint) == 0x000030, "Member 'HWAIBlueprintLibrary_CalculateAimPointWithPredictionByLevelConfig::outAimToPoint' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.CalculateBestLaneWaitLocation
// 0x0038 (0x0038 - 0x0000)
struct HWAIBlueprintLibrary_CalculateBestLaneWaitLocation final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Aggression;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ImmunityTag;                                       // 0x0018(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_CalculateBestLaneWaitLocation) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_CalculateBestLaneWaitLocation");
static_assert(sizeof(HWAIBlueprintLibrary_CalculateBestLaneWaitLocation) == 0x000038, "Wrong size on HWAIBlueprintLibrary_CalculateBestLaneWaitLocation");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateBestLaneWaitLocation, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_CalculateBestLaneWaitLocation::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateBestLaneWaitLocation, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_CalculateBestLaneWaitLocation::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateBestLaneWaitLocation, Direction) == 0x000010, "Member 'HWAIBlueprintLibrary_CalculateBestLaneWaitLocation::Direction' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateBestLaneWaitLocation, Aggression) == 0x000014, "Member 'HWAIBlueprintLibrary_CalculateBestLaneWaitLocation::Aggression' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateBestLaneWaitLocation, ImmunityTag) == 0x000018, "Member 'HWAIBlueprintLibrary_CalculateBestLaneWaitLocation::ImmunityTag' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateBestLaneWaitLocation, ReturnValue) == 0x000020, "Member 'HWAIBlueprintLibrary_CalculateBestLaneWaitLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.CalculateBestLaningLocation
// 0x0050 (0x0050 - 0x0000)
struct HWAIBlueprintLibrary_CalculateBestLaningLocation final
{
public:
	struct FHWLaneAggressionParams                inParams;                                          // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_CalculateBestLaningLocation) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_CalculateBestLaningLocation");
static_assert(sizeof(HWAIBlueprintLibrary_CalculateBestLaningLocation) == 0x000050, "Wrong size on HWAIBlueprintLibrary_CalculateBestLaningLocation");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateBestLaningLocation, inParams) == 0x000000, "Member 'HWAIBlueprintLibrary_CalculateBestLaningLocation::inParams' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateBestLaningLocation, ReturnValue) == 0x000038, "Member 'HWAIBlueprintLibrary_CalculateBestLaningLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.CalculateCombatAdvantage
// 0x0040 (0x0040 - 0x0000)
struct HWAIBlueprintLibrary_CalculateCombatAdvantage final
{
public:
	struct FHWCombatAdvantageParams               inParams;                                          // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EHWAdvantageTypes                             ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_CalculateCombatAdvantage) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_CalculateCombatAdvantage");
static_assert(sizeof(HWAIBlueprintLibrary_CalculateCombatAdvantage) == 0x000040, "Wrong size on HWAIBlueprintLibrary_CalculateCombatAdvantage");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateCombatAdvantage, inParams) == 0x000000, "Member 'HWAIBlueprintLibrary_CalculateCombatAdvantage::inParams' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_CalculateCombatAdvantage, ReturnValue) == 0x000038, "Member 'HWAIBlueprintLibrary_CalculateCombatAdvantage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.ClearNavigationAvoidanceGroupsToAvoidMask
// 0x0008 (0x0008 - 0x0000)
struct HWAIBlueprintLibrary_ClearNavigationAvoidanceGroupsToAvoidMask final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_ClearNavigationAvoidanceGroupsToAvoidMask) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_ClearNavigationAvoidanceGroupsToAvoidMask");
static_assert(sizeof(HWAIBlueprintLibrary_ClearNavigationAvoidanceGroupsToAvoidMask) == 0x000008, "Wrong size on HWAIBlueprintLibrary_ClearNavigationAvoidanceGroupsToAvoidMask");
static_assert(offsetof(HWAIBlueprintLibrary_ClearNavigationAvoidanceGroupsToAvoidMask, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_ClearNavigationAvoidanceGroupsToAvoidMask::Character' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.ComputeGodBackToBaseWeight
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_ComputeGodBackToBaseWeight final
{
public:
	const class AHWCharacter_Base*                Source;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         healthWeight;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         manaWeight;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_ComputeGodBackToBaseWeight) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_ComputeGodBackToBaseWeight");
static_assert(sizeof(HWAIBlueprintLibrary_ComputeGodBackToBaseWeight) == 0x000018, "Wrong size on HWAIBlueprintLibrary_ComputeGodBackToBaseWeight");
static_assert(offsetof(HWAIBlueprintLibrary_ComputeGodBackToBaseWeight, Source) == 0x000000, "Member 'HWAIBlueprintLibrary_ComputeGodBackToBaseWeight::Source' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_ComputeGodBackToBaseWeight, healthWeight) == 0x000008, "Member 'HWAIBlueprintLibrary_ComputeGodBackToBaseWeight::healthWeight' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_ComputeGodBackToBaseWeight, manaWeight) == 0x00000C, "Member 'HWAIBlueprintLibrary_ComputeGodBackToBaseWeight::manaWeight' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_ComputeGodBackToBaseWeight, ReturnValue) == 0x000010, "Member 'HWAIBlueprintLibrary_ComputeGodBackToBaseWeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.DoesCharacterMatchRole
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_DoesCharacterMatchRole final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterRole                                RoleToCheck;                                       // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_DoesCharacterMatchRole) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_DoesCharacterMatchRole");
static_assert(sizeof(HWAIBlueprintLibrary_DoesCharacterMatchRole) == 0x000010, "Wrong size on HWAIBlueprintLibrary_DoesCharacterMatchRole");
static_assert(offsetof(HWAIBlueprintLibrary_DoesCharacterMatchRole, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_DoesCharacterMatchRole::Character' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_DoesCharacterMatchRole, RoleToCheck) == 0x000008, "Member 'HWAIBlueprintLibrary_DoesCharacterMatchRole::RoleToCheck' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_DoesCharacterMatchRole, ReturnValue) == 0x000009, "Member 'HWAIBlueprintLibrary_DoesCharacterMatchRole::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.DoesFactoryHaveLivingBots
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_DoesFactoryHaveLivingBots final
{
public:
	class AHWBotFactory*                          factory;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_DoesFactoryHaveLivingBots) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_DoesFactoryHaveLivingBots");
static_assert(sizeof(HWAIBlueprintLibrary_DoesFactoryHaveLivingBots) == 0x000010, "Wrong size on HWAIBlueprintLibrary_DoesFactoryHaveLivingBots");
static_assert(offsetof(HWAIBlueprintLibrary_DoesFactoryHaveLivingBots, factory) == 0x000000, "Member 'HWAIBlueprintLibrary_DoesFactoryHaveLivingBots::factory' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_DoesFactoryHaveLivingBots, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_DoesFactoryHaveLivingBots::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.DoesLaneExist
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_DoesLaneExist final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_DoesLaneExist) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_DoesLaneExist");
static_assert(sizeof(HWAIBlueprintLibrary_DoesLaneExist) == 0x000018, "Wrong size on HWAIBlueprintLibrary_DoesLaneExist");
static_assert(offsetof(HWAIBlueprintLibrary_DoesLaneExist, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_DoesLaneExist::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_DoesLaneExist, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_DoesLaneExist::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_DoesLaneExist, ReturnValue) == 0x000010, "Member 'HWAIBlueprintLibrary_DoesLaneExist::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.FilterByTeam
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_FilterByTeam final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         matchTeam;                                         // 0x0010(0x0001)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_FilterByTeam) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_FilterByTeam");
static_assert(sizeof(HWAIBlueprintLibrary_FilterByTeam) == 0x000018, "Wrong size on HWAIBlueprintLibrary_FilterByTeam");
static_assert(offsetof(HWAIBlueprintLibrary_FilterByTeam, Actors) == 0x000000, "Member 'HWAIBlueprintLibrary_FilterByTeam::Actors' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_FilterByTeam, matchTeam) == 0x000010, "Member 'HWAIBlueprintLibrary_FilterByTeam::matchTeam' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.FindLaneWaypoint
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_FindLaneWaypoint final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWWaypoint*                            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_FindLaneWaypoint) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_FindLaneWaypoint");
static_assert(sizeof(HWAIBlueprintLibrary_FindLaneWaypoint) == 0x000018, "Wrong size on HWAIBlueprintLibrary_FindLaneWaypoint");
static_assert(offsetof(HWAIBlueprintLibrary_FindLaneWaypoint, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_FindLaneWaypoint::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_FindLaneWaypoint, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_FindLaneWaypoint::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_FindLaneWaypoint, ReturnValue) == 0x000010, "Member 'HWAIBlueprintLibrary_FindLaneWaypoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetAllFactoriesByLane
// 0x00A8 (0x00A8 - 0x0000)
struct HWAIBlueprintLibrary_GetAllFactoriesByLane final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0010(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AHWBotFactory*>                  outFactories;                                      // 0x0098(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetAllFactoriesByLane) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetAllFactoriesByLane");
static_assert(sizeof(HWAIBlueprintLibrary_GetAllFactoriesByLane) == 0x0000A8, "Wrong size on HWAIBlueprintLibrary_GetAllFactoriesByLane");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllFactoriesByLane, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetAllFactoriesByLane::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllFactoriesByLane, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_GetAllFactoriesByLane::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllFactoriesByLane, TagRequirements) == 0x000010, "Member 'HWAIBlueprintLibrary_GetAllFactoriesByLane::TagRequirements' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllFactoriesByLane, outFactories) == 0x000098, "Member 'HWAIBlueprintLibrary_GetAllFactoriesByLane::outFactories' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetAlliesWithinRange
// 0x0040 (0x0040 - 0x0000)
struct HWAIBlueprintLibrary_GetAlliesWithinRange final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AHWCharacter_Base*>              outTargets;                                        // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetAlliesWithinRange) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetAlliesWithinRange");
static_assert(sizeof(HWAIBlueprintLibrary_GetAlliesWithinRange) == 0x000040, "Wrong size on HWAIBlueprintLibrary_GetAlliesWithinRange");
static_assert(offsetof(HWAIBlueprintLibrary_GetAlliesWithinRange, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetAlliesWithinRange::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAlliesWithinRange, Radius) == 0x000008, "Member 'HWAIBlueprintLibrary_GetAlliesWithinRange::Radius' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAlliesWithinRange, tagsToIgnore) == 0x000010, "Member 'HWAIBlueprintLibrary_GetAlliesWithinRange::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAlliesWithinRange, outTargets) == 0x000030, "Member 'HWAIBlueprintLibrary_GetAlliesWithinRange::outTargets' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetAllyCountThatAreFocusedOnTarget
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWCharacter_Base*                TargetCharacter;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSource;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget");
static_assert(sizeof(HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget) == 0x000018, "Wrong size on HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget, TargetCharacter) == 0x000008, "Member 'HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget::TargetCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget, bIncludeSource) == 0x000010, "Member 'HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget::bIncludeSource' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget, ReturnValue) == 0x000014, "Member 'HWAIBlueprintLibrary_GetAllyCountThatAreFocusedOnTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetAllyCountWithinRange
// 0x0038 (0x0038 - 0x0000)
struct HWAIBlueprintLibrary_GetAllyCountWithinRange final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetAllyCountWithinRange) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetAllyCountWithinRange");
static_assert(sizeof(HWAIBlueprintLibrary_GetAllyCountWithinRange) == 0x000038, "Wrong size on HWAIBlueprintLibrary_GetAllyCountWithinRange");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllyCountWithinRange, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetAllyCountWithinRange::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllyCountWithinRange, Radius) == 0x000008, "Member 'HWAIBlueprintLibrary_GetAllyCountWithinRange::Radius' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllyCountWithinRange, tagsToIgnore) == 0x000010, "Member 'HWAIBlueprintLibrary_GetAllyCountWithinRange::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAllyCountWithinRange, ReturnValue) == 0x000030, "Member 'HWAIBlueprintLibrary_GetAllyCountWithinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetAverageTeamLevel
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetAverageTeamLevel final
{
public:
	const class AHWTeamState*                     Team;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetAverageTeamLevel) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetAverageTeamLevel");
static_assert(sizeof(HWAIBlueprintLibrary_GetAverageTeamLevel) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetAverageTeamLevel");
static_assert(offsetof(HWAIBlueprintLibrary_GetAverageTeamLevel, Team) == 0x000000, "Member 'HWAIBlueprintLibrary_GetAverageTeamLevel::Team' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetAverageTeamLevel, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetAverageTeamLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetBestJungleObjective
// 0x0020 (0x0020 - 0x0000)
struct HWAIBlueprintLibrary_GetBestJungleObjective final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHWBotFactory*>                  jungleFactories;                                   // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AHWBotFactory*                          ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetBestJungleObjective) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetBestJungleObjective");
static_assert(sizeof(HWAIBlueprintLibrary_GetBestJungleObjective) == 0x000020, "Wrong size on HWAIBlueprintLibrary_GetBestJungleObjective");
static_assert(offsetof(HWAIBlueprintLibrary_GetBestJungleObjective, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetBestJungleObjective::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetBestJungleObjective, jungleFactories) == 0x000008, "Member 'HWAIBlueprintLibrary_GetBestJungleObjective::jungleFactories' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetBestJungleObjective, ReturnValue) == 0x000018, "Member 'HWAIBlueprintLibrary_GetBestJungleObjective::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetCharactersInRadius
// 0x0048 (0x0048 - 0x0000)
struct HWAIBlueprintLibrary_GetCharactersInRadius final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ignoreActor;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         outCharacters;                                     // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetCharactersInRadius) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetCharactersInRadius");
static_assert(sizeof(HWAIBlueprintLibrary_GetCharactersInRadius) == 0x000048, "Wrong size on HWAIBlueprintLibrary_GetCharactersInRadius");
static_assert(offsetof(HWAIBlueprintLibrary_GetCharactersInRadius, WorldContextObject) == 0x000000, "Member 'HWAIBlueprintLibrary_GetCharactersInRadius::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetCharactersInRadius, Location) == 0x000008, "Member 'HWAIBlueprintLibrary_GetCharactersInRadius::Location' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetCharactersInRadius, Radius) == 0x000020, "Member 'HWAIBlueprintLibrary_GetCharactersInRadius::Radius' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetCharactersInRadius, ignoreActor) == 0x000028, "Member 'HWAIBlueprintLibrary_GetCharactersInRadius::ignoreActor' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetCharactersInRadius, outCharacters) == 0x000030, "Member 'HWAIBlueprintLibrary_GetCharactersInRadius::outCharacters' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetCharactersInRadius, ReturnValue) == 0x000040, "Member 'HWAIBlueprintLibrary_GetCharactersInRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetClosestAllyWithinRange
// 0x0038 (0x0038 - 0x0000)
struct HWAIBlueprintLibrary_GetClosestAllyWithinRange final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetClosestAllyWithinRange) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetClosestAllyWithinRange");
static_assert(sizeof(HWAIBlueprintLibrary_GetClosestAllyWithinRange) == 0x000038, "Wrong size on HWAIBlueprintLibrary_GetClosestAllyWithinRange");
static_assert(offsetof(HWAIBlueprintLibrary_GetClosestAllyWithinRange, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetClosestAllyWithinRange::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetClosestAllyWithinRange, Range) == 0x000008, "Member 'HWAIBlueprintLibrary_GetClosestAllyWithinRange::Range' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetClosestAllyWithinRange, tagsToIgnore) == 0x000010, "Member 'HWAIBlueprintLibrary_GetClosestAllyWithinRange::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetClosestAllyWithinRange, ReturnValue) == 0x000030, "Member 'HWAIBlueprintLibrary_GetClosestAllyWithinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetClosestTeamStructure
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_GetClosestTeamStructure final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpposing;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         outDistance;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetClosestTeamStructure) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetClosestTeamStructure");
static_assert(sizeof(HWAIBlueprintLibrary_GetClosestTeamStructure) == 0x000018, "Wrong size on HWAIBlueprintLibrary_GetClosestTeamStructure");
static_assert(offsetof(HWAIBlueprintLibrary_GetClosestTeamStructure, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetClosestTeamStructure::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetClosestTeamStructure, bOpposing) == 0x000008, "Member 'HWAIBlueprintLibrary_GetClosestTeamStructure::bOpposing' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetClosestTeamStructure, outDistance) == 0x00000C, "Member 'HWAIBlueprintLibrary_GetClosestTeamStructure::outDistance' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetClosestTeamStructure, ReturnValue) == 0x000010, "Member 'HWAIBlueprintLibrary_GetClosestTeamStructure::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetDefeatedLaneCount
// 0x0028 (0x0028 - 0x0000)
struct HWAIBlueprintLibrary_GetDefeatedLaneCount final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Lanes;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ImmunityTag;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetDefeatedLaneCount) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetDefeatedLaneCount");
static_assert(sizeof(HWAIBlueprintLibrary_GetDefeatedLaneCount) == 0x000028, "Wrong size on HWAIBlueprintLibrary_GetDefeatedLaneCount");
static_assert(offsetof(HWAIBlueprintLibrary_GetDefeatedLaneCount, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_GetDefeatedLaneCount::Character' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetDefeatedLaneCount, Lanes) == 0x000008, "Member 'HWAIBlueprintLibrary_GetDefeatedLaneCount::Lanes' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetDefeatedLaneCount, ImmunityTag) == 0x000018, "Member 'HWAIBlueprintLibrary_GetDefeatedLaneCount::ImmunityTag' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetDefeatedLaneCount, ReturnValue) == 0x000020, "Member 'HWAIBlueprintLibrary_GetDefeatedLaneCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetDistanceAlongLane
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_GetDistanceAlongLane final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetDistanceAlongLane) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetDistanceAlongLane");
static_assert(sizeof(HWAIBlueprintLibrary_GetDistanceAlongLane) == 0x000018, "Wrong size on HWAIBlueprintLibrary_GetDistanceAlongLane");
static_assert(offsetof(HWAIBlueprintLibrary_GetDistanceAlongLane, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetDistanceAlongLane::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetDistanceAlongLane, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_GetDistanceAlongLane::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetDistanceAlongLane, Direction) == 0x000010, "Member 'HWAIBlueprintLibrary_GetDistanceAlongLane::Direction' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetDistanceAlongLane, ReturnValue) == 0x000014, "Member 'HWAIBlueprintLibrary_GetDistanceAlongLane::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetDistancePercentageAlongLane
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_GetDistancePercentageAlongLane final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetDistancePercentageAlongLane) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetDistancePercentageAlongLane");
static_assert(sizeof(HWAIBlueprintLibrary_GetDistancePercentageAlongLane) == 0x000018, "Wrong size on HWAIBlueprintLibrary_GetDistancePercentageAlongLane");
static_assert(offsetof(HWAIBlueprintLibrary_GetDistancePercentageAlongLane, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetDistancePercentageAlongLane::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetDistancePercentageAlongLane, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_GetDistancePercentageAlongLane::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetDistancePercentageAlongLane, Direction) == 0x000010, "Member 'HWAIBlueprintLibrary_GetDistancePercentageAlongLane::Direction' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetDistancePercentageAlongLane, ReturnValue) == 0x000014, "Member 'HWAIBlueprintLibrary_GetDistancePercentageAlongLane::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetEnemiesWithinRange
// 0x0040 (0x0040 - 0x0000)
struct HWAIBlueprintLibrary_GetEnemiesWithinRange final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AHWCharacter_Base*>              outTargets;                                        // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetEnemiesWithinRange) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetEnemiesWithinRange");
static_assert(sizeof(HWAIBlueprintLibrary_GetEnemiesWithinRange) == 0x000040, "Wrong size on HWAIBlueprintLibrary_GetEnemiesWithinRange");
static_assert(offsetof(HWAIBlueprintLibrary_GetEnemiesWithinRange, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetEnemiesWithinRange::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetEnemiesWithinRange, Radius) == 0x000008, "Member 'HWAIBlueprintLibrary_GetEnemiesWithinRange::Radius' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetEnemiesWithinRange, tagsToIgnore) == 0x000010, "Member 'HWAIBlueprintLibrary_GetEnemiesWithinRange::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetEnemiesWithinRange, outTargets) == 0x000030, "Member 'HWAIBlueprintLibrary_GetEnemiesWithinRange::outTargets' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetEnemyCountWithinRange
// 0x0038 (0x0038 - 0x0000)
struct HWAIBlueprintLibrary_GetEnemyCountWithinRange final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetEnemyCountWithinRange) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetEnemyCountWithinRange");
static_assert(sizeof(HWAIBlueprintLibrary_GetEnemyCountWithinRange) == 0x000038, "Wrong size on HWAIBlueprintLibrary_GetEnemyCountWithinRange");
static_assert(offsetof(HWAIBlueprintLibrary_GetEnemyCountWithinRange, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetEnemyCountWithinRange::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetEnemyCountWithinRange, Radius) == 0x000008, "Member 'HWAIBlueprintLibrary_GetEnemyCountWithinRange::Radius' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetEnemyCountWithinRange, tagsToIgnore) == 0x000010, "Member 'HWAIBlueprintLibrary_GetEnemyCountWithinRange::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetEnemyCountWithinRange, ReturnValue) == 0x000030, "Member 'HWAIBlueprintLibrary_GetEnemyCountWithinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetFurthestLaneObjective
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_GetFurthestLaneObjective final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetFurthestLaneObjective) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetFurthestLaneObjective");
static_assert(sizeof(HWAIBlueprintLibrary_GetFurthestLaneObjective) == 0x000018, "Wrong size on HWAIBlueprintLibrary_GetFurthestLaneObjective");
static_assert(offsetof(HWAIBlueprintLibrary_GetFurthestLaneObjective, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetFurthestLaneObjective::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetFurthestLaneObjective, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_GetFurthestLaneObjective::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetFurthestLaneObjective, ReturnValue) == 0x000010, "Member 'HWAIBlueprintLibrary_GetFurthestLaneObjective::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetGodBotInhandRange
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetGodBotInhandRange final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetGodBotInhandRange) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetGodBotInhandRange");
static_assert(sizeof(HWAIBlueprintLibrary_GetGodBotInhandRange) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetGodBotInhandRange");
static_assert(offsetof(HWAIBlueprintLibrary_GetGodBotInhandRange, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetGodBotInhandRange::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetGodBotInhandRange, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetGodBotInhandRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetNearestLaneID
// 0x0028 (0x0028 - 0x0000)
struct HWAIBlueprintLibrary_GetNearestLaneID final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Lanes;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ImmunityTag;                                       // 0x0018(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetNearestLaneID) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetNearestLaneID");
static_assert(sizeof(HWAIBlueprintLibrary_GetNearestLaneID) == 0x000028, "Wrong size on HWAIBlueprintLibrary_GetNearestLaneID");
static_assert(offsetof(HWAIBlueprintLibrary_GetNearestLaneID, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetNearestLaneID::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetNearestLaneID, Lanes) == 0x000008, "Member 'HWAIBlueprintLibrary_GetNearestLaneID::Lanes' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetNearestLaneID, ImmunityTag) == 0x000018, "Member 'HWAIBlueprintLibrary_GetNearestLaneID::ImmunityTag' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetNearestLaneID, ReturnValue) == 0x000020, "Member 'HWAIBlueprintLibrary_GetNearestLaneID::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetNearestLaneObjectiveToEscapeTo
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetNearestLaneObjectiveToEscapeTo final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetNearestLaneObjectiveToEscapeTo) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetNearestLaneObjectiveToEscapeTo");
static_assert(sizeof(HWAIBlueprintLibrary_GetNearestLaneObjectiveToEscapeTo) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetNearestLaneObjectiveToEscapeTo");
static_assert(offsetof(HWAIBlueprintLibrary_GetNearestLaneObjectiveToEscapeTo, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetNearestLaneObjectiveToEscapeTo::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetNearestLaneObjectiveToEscapeTo, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetNearestLaneObjectiveToEscapeTo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetNextLaneObjectiveToAttack
// 0x0020 (0x0020 - 0x0000)
struct HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ImmunityTag;                                       // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack");
static_assert(sizeof(HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack) == 0x000020, "Wrong size on HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack");
static_assert(offsetof(HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack, ImmunityTag) == 0x000010, "Member 'HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack::ImmunityTag' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack, ReturnValue) == 0x000018, "Member 'HWAIBlueprintLibrary_GetNextLaneObjectiveToAttack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetNextLaneObjectiveToDefend
// 0x0020 (0x0020 - 0x0000)
struct HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ImmunityTag;                                       // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend");
static_assert(sizeof(HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend) == 0x000020, "Wrong size on HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend");
static_assert(offsetof(HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend, ImmunityTag) == 0x000010, "Member 'HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend::ImmunityTag' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend, ReturnValue) == 0x000018, "Member 'HWAIBlueprintLibrary_GetNextLaneObjectiveToDefend::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetOpposingTeamState
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetOpposingTeamState final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamState*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetOpposingTeamState) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetOpposingTeamState");
static_assert(sizeof(HWAIBlueprintLibrary_GetOpposingTeamState) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetOpposingTeamState");
static_assert(offsetof(HWAIBlueprintLibrary_GetOpposingTeamState, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetOpposingTeamState::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetOpposingTeamState, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetOpposingTeamState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetOpposingTeamStateByTeam
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetOpposingTeamStateByTeam final
{
public:
	const class AHWTeamState*                     Team;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamState*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetOpposingTeamStateByTeam) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetOpposingTeamStateByTeam");
static_assert(sizeof(HWAIBlueprintLibrary_GetOpposingTeamStateByTeam) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetOpposingTeamStateByTeam");
static_assert(offsetof(HWAIBlueprintLibrary_GetOpposingTeamStateByTeam, Team) == 0x000000, "Member 'HWAIBlueprintLibrary_GetOpposingTeamStateByTeam::Team' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetOpposingTeamStateByTeam, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetOpposingTeamStateByTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetRoleForCharacter
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetRoleForCharacter final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterRole                                ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetRoleForCharacter) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetRoleForCharacter");
static_assert(sizeof(HWAIBlueprintLibrary_GetRoleForCharacter) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetRoleForCharacter");
static_assert(offsetof(HWAIBlueprintLibrary_GetRoleForCharacter, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_GetRoleForCharacter::Character' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetRoleForCharacter, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetRoleForCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetStructureInhandRange
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetStructureInhandRange final
{
public:
	const class AHWCharacter_Base*                SourceStructure;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetStructureInhandRange) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetStructureInhandRange");
static_assert(sizeof(HWAIBlueprintLibrary_GetStructureInhandRange) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetStructureInhandRange");
static_assert(offsetof(HWAIBlueprintLibrary_GetStructureInhandRange, SourceStructure) == 0x000000, "Member 'HWAIBlueprintLibrary_GetStructureInhandRange::SourceStructure' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetStructureInhandRange, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetStructureInhandRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetTeamNumbersAdvantage
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetTeamNumbersAdvantage final
{
public:
	const class AHWTeamState*                     Team;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetTeamNumbersAdvantage) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetTeamNumbersAdvantage");
static_assert(sizeof(HWAIBlueprintLibrary_GetTeamNumbersAdvantage) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetTeamNumbersAdvantage");
static_assert(offsetof(HWAIBlueprintLibrary_GetTeamNumbersAdvantage, Team) == 0x000000, "Member 'HWAIBlueprintLibrary_GetTeamNumbersAdvantage::Team' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetTeamNumbersAdvantage, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetTeamNumbersAdvantage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetTeamPhoenixCount
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetTeamPhoenixCount final
{
public:
	const class AHWTeamState*                     TeamState;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetTeamPhoenixCount) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetTeamPhoenixCount");
static_assert(sizeof(HWAIBlueprintLibrary_GetTeamPhoenixCount) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetTeamPhoenixCount");
static_assert(offsetof(HWAIBlueprintLibrary_GetTeamPhoenixCount, TeamState) == 0x000000, "Member 'HWAIBlueprintLibrary_GetTeamPhoenixCount::TeamState' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetTeamPhoenixCount, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetTeamPhoenixCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetTeamPhoenixCountByCharacter
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetTeamPhoenixCountByCharacter final
{
public:
	const class AHWCharacter_Base*                TargetCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetTeamPhoenixCountByCharacter) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetTeamPhoenixCountByCharacter");
static_assert(sizeof(HWAIBlueprintLibrary_GetTeamPhoenixCountByCharacter) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetTeamPhoenixCountByCharacter");
static_assert(offsetof(HWAIBlueprintLibrary_GetTeamPhoenixCountByCharacter, TargetCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetTeamPhoenixCountByCharacter::TargetCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetTeamPhoenixCountByCharacter, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetTeamPhoenixCountByCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetTeamState
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_GetTeamState final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamState*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_GetTeamState) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetTeamState");
static_assert(sizeof(HWAIBlueprintLibrary_GetTeamState) == 0x000010, "Wrong size on HWAIBlueprintLibrary_GetTeamState");
static_assert(offsetof(HWAIBlueprintLibrary_GetTeamState, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_GetTeamState::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetTeamState, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_GetTeamState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.GetWorldGeoInRadius
// 0x0040 (0x0040 - 0x0000)
struct HWAIBlueprintLibrary_GetWorldGeoInRadius final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     outHitResults;                                     // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_GetWorldGeoInRadius) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_GetWorldGeoInRadius");
static_assert(sizeof(HWAIBlueprintLibrary_GetWorldGeoInRadius) == 0x000040, "Wrong size on HWAIBlueprintLibrary_GetWorldGeoInRadius");
static_assert(offsetof(HWAIBlueprintLibrary_GetWorldGeoInRadius, WorldContextObject) == 0x000000, "Member 'HWAIBlueprintLibrary_GetWorldGeoInRadius::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetWorldGeoInRadius, Location) == 0x000008, "Member 'HWAIBlueprintLibrary_GetWorldGeoInRadius::Location' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetWorldGeoInRadius, Radius) == 0x000020, "Member 'HWAIBlueprintLibrary_GetWorldGeoInRadius::Radius' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetWorldGeoInRadius, outHitResults) == 0x000028, "Member 'HWAIBlueprintLibrary_GetWorldGeoInRadius::outHitResults' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_GetWorldGeoInRadius, ReturnValue) == 0x000038, "Member 'HWAIBlueprintLibrary_GetWorldGeoInRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.HaveMinionsSpawnedForLane
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_HaveMinionsSpawnedForLane final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_HaveMinionsSpawnedForLane) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_HaveMinionsSpawnedForLane");
static_assert(sizeof(HWAIBlueprintLibrary_HaveMinionsSpawnedForLane) == 0x000018, "Wrong size on HWAIBlueprintLibrary_HaveMinionsSpawnedForLane");
static_assert(offsetof(HWAIBlueprintLibrary_HaveMinionsSpawnedForLane, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_HaveMinionsSpawnedForLane::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_HaveMinionsSpawnedForLane, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_HaveMinionsSpawnedForLane::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_HaveMinionsSpawnedForLane, ReturnValue) == 0x000010, "Member 'HWAIBlueprintLibrary_HaveMinionsSpawnedForLane::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsAbilityFiring
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_IsAbilityFiring final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EquipTag;                                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipSlot;                                         // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsAbilityFiring) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsAbilityFiring");
static_assert(sizeof(HWAIBlueprintLibrary_IsAbilityFiring) == 0x000018, "Wrong size on HWAIBlueprintLibrary_IsAbilityFiring");
static_assert(offsetof(HWAIBlueprintLibrary_IsAbilityFiring, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_IsAbilityFiring::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsAbilityFiring, EquipTag) == 0x000008, "Member 'HWAIBlueprintLibrary_IsAbilityFiring::EquipTag' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsAbilityFiring, EquipSlot) == 0x000010, "Member 'HWAIBlueprintLibrary_IsAbilityFiring::EquipSlot' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsAbilityFiring, ReturnValue) == 0x000014, "Member 'HWAIBlueprintLibrary_IsAbilityFiring::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsAnyGodInRange
// 0x0028 (0x0028 - 0x0000)
struct HWAIBlueprintLibrary_IsAnyGodInRange final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsAnyGodInRange) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsAnyGodInRange");
static_assert(sizeof(HWAIBlueprintLibrary_IsAnyGodInRange) == 0x000028, "Wrong size on HWAIBlueprintLibrary_IsAnyGodInRange");
static_assert(offsetof(HWAIBlueprintLibrary_IsAnyGodInRange, WorldContextObject) == 0x000000, "Member 'HWAIBlueprintLibrary_IsAnyGodInRange::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsAnyGodInRange, Location) == 0x000008, "Member 'HWAIBlueprintLibrary_IsAnyGodInRange::Location' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsAnyGodInRange, Range) == 0x000020, "Member 'HWAIBlueprintLibrary_IsAnyGodInRange::Range' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsAnyGodInRange, ReturnValue) == 0x000024, "Member 'HWAIBlueprintLibrary_IsAnyGodInRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsAnyOffhandFiring
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_IsAnyOffhandFiring final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChannelingOnly;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsAnyOffhandFiring) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsAnyOffhandFiring");
static_assert(sizeof(HWAIBlueprintLibrary_IsAnyOffhandFiring) == 0x000010, "Wrong size on HWAIBlueprintLibrary_IsAnyOffhandFiring");
static_assert(offsetof(HWAIBlueprintLibrary_IsAnyOffhandFiring, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_IsAnyOffhandFiring::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsAnyOffhandFiring, bChannelingOnly) == 0x000008, "Member 'HWAIBlueprintLibrary_IsAnyOffhandFiring::bChannelingOnly' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsAnyOffhandFiring, ReturnValue) == 0x000009, "Member 'HWAIBlueprintLibrary_IsAnyOffhandFiring::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsCharacterJungleRole
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_IsCharacterJungleRole final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsCharacterJungleRole) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsCharacterJungleRole");
static_assert(sizeof(HWAIBlueprintLibrary_IsCharacterJungleRole) == 0x000010, "Wrong size on HWAIBlueprintLibrary_IsCharacterJungleRole");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterJungleRole, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_IsCharacterJungleRole::Character' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterJungleRole, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_IsCharacterJungleRole::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsCharacterProtectedByTower
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_IsCharacterProtectedByTower final
{
public:
	const class AHWCharacter_Base*                TargetCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Buffer;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsCharacterProtectedByTower) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsCharacterProtectedByTower");
static_assert(sizeof(HWAIBlueprintLibrary_IsCharacterProtectedByTower) == 0x000010, "Wrong size on HWAIBlueprintLibrary_IsCharacterProtectedByTower");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterProtectedByTower, TargetCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_IsCharacterProtectedByTower::TargetCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterProtectedByTower, Buffer) == 0x000008, "Member 'HWAIBlueprintLibrary_IsCharacterProtectedByTower::Buffer' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterProtectedByTower, ReturnValue) == 0x00000C, "Member 'HWAIBlueprintLibrary_IsCharacterProtectedByTower::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsCharacterSoloRole
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_IsCharacterSoloRole final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsCharacterSoloRole) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsCharacterSoloRole");
static_assert(sizeof(HWAIBlueprintLibrary_IsCharacterSoloRole) == 0x000010, "Wrong size on HWAIBlueprintLibrary_IsCharacterSoloRole");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterSoloRole, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_IsCharacterSoloRole::Character' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterSoloRole, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_IsCharacterSoloRole::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsCharacterSupportRole
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_IsCharacterSupportRole final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsCharacterSupportRole) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsCharacterSupportRole");
static_assert(sizeof(HWAIBlueprintLibrary_IsCharacterSupportRole) == 0x000010, "Wrong size on HWAIBlueprintLibrary_IsCharacterSupportRole");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterSupportRole, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_IsCharacterSupportRole::Character' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterSupportRole, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_IsCharacterSupportRole::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsCharacterUntargetable
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_IsCharacterUntargetable final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsCharacterUntargetable) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsCharacterUntargetable");
static_assert(sizeof(HWAIBlueprintLibrary_IsCharacterUntargetable) == 0x000010, "Wrong size on HWAIBlueprintLibrary_IsCharacterUntargetable");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterUntargetable, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_IsCharacterUntargetable::Character' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterUntargetable, ReturnValue) == 0x000008, "Member 'HWAIBlueprintLibrary_IsCharacterUntargetable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsCharacterWithinAnyLaningArea
// 0x0028 (0x0028 - 0x0000)
struct HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Lanes;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceFromLane;                               // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea");
static_assert(sizeof(HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea) == 0x000028, "Wrong size on HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea::Character' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea, Lanes) == 0x000008, "Member 'HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea::Lanes' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea, Direction) == 0x000018, "Member 'HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea::Direction' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea, MaxDistanceFromLane) == 0x00001C, "Member 'HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea::MaxDistanceFromLane' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea, ReturnValue) == 0x000020, "Member 'HWAIBlueprintLibrary_IsCharacterWithinAnyLaningArea::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsCharacterWithinLaningArea
// 0x0020 (0x0020 - 0x0000)
struct HWAIBlueprintLibrary_IsCharacterWithinLaningArea final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaneId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceFromLane;                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsCharacterWithinLaningArea) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsCharacterWithinLaningArea");
static_assert(sizeof(HWAIBlueprintLibrary_IsCharacterWithinLaningArea) == 0x000020, "Wrong size on HWAIBlueprintLibrary_IsCharacterWithinLaningArea");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterWithinLaningArea, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_IsCharacterWithinLaningArea::Character' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterWithinLaningArea, LaneId) == 0x000008, "Member 'HWAIBlueprintLibrary_IsCharacterWithinLaningArea::LaneId' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterWithinLaningArea, Direction) == 0x000010, "Member 'HWAIBlueprintLibrary_IsCharacterWithinLaningArea::Direction' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterWithinLaningArea, MaxDistanceFromLane) == 0x000014, "Member 'HWAIBlueprintLibrary_IsCharacterWithinLaningArea::MaxDistanceFromLane' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsCharacterWithinLaningArea, ReturnValue) == 0x000018, "Member 'HWAIBlueprintLibrary_IsCharacterWithinLaningArea::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsGodBotAheadOfWave
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_IsGodBotAheadOfWave final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWWaypoint*                            LaneWaypoint;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AheadByAmount;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsGodBotAheadOfWave) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsGodBotAheadOfWave");
static_assert(sizeof(HWAIBlueprintLibrary_IsGodBotAheadOfWave) == 0x000018, "Wrong size on HWAIBlueprintLibrary_IsGodBotAheadOfWave");
static_assert(offsetof(HWAIBlueprintLibrary_IsGodBotAheadOfWave, SourceCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_IsGodBotAheadOfWave::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsGodBotAheadOfWave, LaneWaypoint) == 0x000008, "Member 'HWAIBlueprintLibrary_IsGodBotAheadOfWave::LaneWaypoint' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsGodBotAheadOfWave, AheadByAmount) == 0x000010, "Member 'HWAIBlueprintLibrary_IsGodBotAheadOfWave::AheadByAmount' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsGodBotAheadOfWave, ReturnValue) == 0x000014, "Member 'HWAIBlueprintLibrary_IsGodBotAheadOfWave::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsLocationInCharacterAttackRange
// 0x0028 (0x0028 - 0x0000)
struct HWAIBlueprintLibrary_IsLocationInCharacterAttackRange final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Buffer;                                            // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsLocationInCharacterAttackRange) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsLocationInCharacterAttackRange");
static_assert(sizeof(HWAIBlueprintLibrary_IsLocationInCharacterAttackRange) == 0x000028, "Wrong size on HWAIBlueprintLibrary_IsLocationInCharacterAttackRange");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationInCharacterAttackRange, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_IsLocationInCharacterAttackRange::Character' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationInCharacterAttackRange, Location) == 0x000008, "Member 'HWAIBlueprintLibrary_IsLocationInCharacterAttackRange::Location' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationInCharacterAttackRange, Buffer) == 0x000020, "Member 'HWAIBlueprintLibrary_IsLocationInCharacterAttackRange::Buffer' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationInCharacterAttackRange, ReturnValue) == 0x000024, "Member 'HWAIBlueprintLibrary_IsLocationInCharacterAttackRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsLocationProtectedByOpposingTower
// 0x0028 (0x0028 - 0x0000)
struct HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower final
{
public:
	const class AHWTeamState*                     AttackingTeam;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Buffer;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower");
static_assert(sizeof(HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower) == 0x000028, "Wrong size on HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower, AttackingTeam) == 0x000000, "Member 'HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower::AttackingTeam' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower, Location) == 0x000008, "Member 'HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower::Location' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower, Buffer) == 0x000020, "Member 'HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower::Buffer' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower, ReturnValue) == 0x000024, "Member 'HWAIBlueprintLibrary_IsLocationProtectedByOpposingTower::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsLocationProtectedByTower
// 0x0028 (0x0028 - 0x0000)
struct HWAIBlueprintLibrary_IsLocationProtectedByTower final
{
public:
	const class AHWTeamState*                     ProtectingTeam;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Buffer;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsLocationProtectedByTower) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsLocationProtectedByTower");
static_assert(sizeof(HWAIBlueprintLibrary_IsLocationProtectedByTower) == 0x000028, "Wrong size on HWAIBlueprintLibrary_IsLocationProtectedByTower");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationProtectedByTower, ProtectingTeam) == 0x000000, "Member 'HWAIBlueprintLibrary_IsLocationProtectedByTower::ProtectingTeam' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationProtectedByTower, Location) == 0x000008, "Member 'HWAIBlueprintLibrary_IsLocationProtectedByTower::Location' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationProtectedByTower, Buffer) == 0x000020, "Member 'HWAIBlueprintLibrary_IsLocationProtectedByTower::Buffer' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsLocationProtectedByTower, ReturnValue) == 0x000024, "Member 'HWAIBlueprintLibrary_IsLocationProtectedByTower::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.IsTargetProtectedByTower
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_IsTargetProtectedByTower final
{
public:
	const class AHWCharacter_Base*                AttackingCharacter;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWCharacter_Base*                TargetCharacter;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_IsTargetProtectedByTower) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_IsTargetProtectedByTower");
static_assert(sizeof(HWAIBlueprintLibrary_IsTargetProtectedByTower) == 0x000018, "Wrong size on HWAIBlueprintLibrary_IsTargetProtectedByTower");
static_assert(offsetof(HWAIBlueprintLibrary_IsTargetProtectedByTower, AttackingCharacter) == 0x000000, "Member 'HWAIBlueprintLibrary_IsTargetProtectedByTower::AttackingCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsTargetProtectedByTower, TargetCharacter) == 0x000008, "Member 'HWAIBlueprintLibrary_IsTargetProtectedByTower::TargetCharacter' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_IsTargetProtectedByTower, ReturnValue) == 0x000010, "Member 'HWAIBlueprintLibrary_IsTargetProtectedByTower::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.ManageCharacterLane
// 0x0038 (0x0038 - 0x0000)
struct HWAIBlueprintLibrary_ManageCharacterLane final
{
public:
	struct FHWManageCharacterLaneParams           LaneParams;                                        // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_ManageCharacterLane) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_ManageCharacterLane");
static_assert(sizeof(HWAIBlueprintLibrary_ManageCharacterLane) == 0x000038, "Wrong size on HWAIBlueprintLibrary_ManageCharacterLane");
static_assert(offsetof(HWAIBlueprintLibrary_ManageCharacterLane, LaneParams) == 0x000000, "Member 'HWAIBlueprintLibrary_ManageCharacterLane::LaneParams' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.PickRandomIndexFromWeightedSet
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_PickRandomIndexFromWeightedSet final
{
public:
	TArray<float>                                 Weights;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_PickRandomIndexFromWeightedSet) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_PickRandomIndexFromWeightedSet");
static_assert(sizeof(HWAIBlueprintLibrary_PickRandomIndexFromWeightedSet) == 0x000018, "Wrong size on HWAIBlueprintLibrary_PickRandomIndexFromWeightedSet");
static_assert(offsetof(HWAIBlueprintLibrary_PickRandomIndexFromWeightedSet, Weights) == 0x000000, "Member 'HWAIBlueprintLibrary_PickRandomIndexFromWeightedSet::Weights' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_PickRandomIndexFromWeightedSet, ReturnValue) == 0x000010, "Member 'HWAIBlueprintLibrary_PickRandomIndexFromWeightedSet::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.PostNPEProgressPointEvent
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_PostNPEProgressPointEvent final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProgressPoint;                                     // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_PostNPEProgressPointEvent) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_PostNPEProgressPointEvent");
static_assert(sizeof(HWAIBlueprintLibrary_PostNPEProgressPointEvent) == 0x000018, "Wrong size on HWAIBlueprintLibrary_PostNPEProgressPointEvent");
static_assert(offsetof(HWAIBlueprintLibrary_PostNPEProgressPointEvent, WorldContextObject) == 0x000000, "Member 'HWAIBlueprintLibrary_PostNPEProgressPointEvent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_PostNPEProgressPointEvent, ProgressPoint) == 0x000008, "Member 'HWAIBlueprintLibrary_PostNPEProgressPointEvent::ProgressPoint' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.PostNPEProgressPointEventWithTag
// 0x0010 (0x0010 - 0x0000)
struct HWAIBlueprintLibrary_PostNPEProgressPointEventWithTag final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ProgressPoint;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_PostNPEProgressPointEventWithTag) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_PostNPEProgressPointEventWithTag");
static_assert(sizeof(HWAIBlueprintLibrary_PostNPEProgressPointEventWithTag) == 0x000010, "Wrong size on HWAIBlueprintLibrary_PostNPEProgressPointEventWithTag");
static_assert(offsetof(HWAIBlueprintLibrary_PostNPEProgressPointEventWithTag, WorldContextObject) == 0x000000, "Member 'HWAIBlueprintLibrary_PostNPEProgressPointEventWithTag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_PostNPEProgressPointEventWithTag, ProgressPoint) == 0x000008, "Member 'HWAIBlueprintLibrary_PostNPEProgressPointEventWithTag::ProgressPoint' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.RemoveComponentFromNavigation
// 0x0008 (0x0008 - 0x0000)
struct HWAIBlueprintLibrary_RemoveComponentFromNavigation final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_RemoveComponentFromNavigation) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_RemoveComponentFromNavigation");
static_assert(sizeof(HWAIBlueprintLibrary_RemoveComponentFromNavigation) == 0x000008, "Wrong size on HWAIBlueprintLibrary_RemoveComponentFromNavigation");
static_assert(offsetof(HWAIBlueprintLibrary_RemoveComponentFromNavigation, Comp) == 0x000000, "Member 'HWAIBlueprintLibrary_RemoveComponentFromNavigation::Comp' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.RequestGameplayTagFromName
// 0x0014 (0x0014 - 0x0000)
struct HWAIBlueprintLibrary_RequestGameplayTagFromName final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           outTag;                                            // 0x0008(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_RequestGameplayTagFromName) == 0x000004, "Wrong alignment on HWAIBlueprintLibrary_RequestGameplayTagFromName");
static_assert(sizeof(HWAIBlueprintLibrary_RequestGameplayTagFromName) == 0x000014, "Wrong size on HWAIBlueprintLibrary_RequestGameplayTagFromName");
static_assert(offsetof(HWAIBlueprintLibrary_RequestGameplayTagFromName, InName) == 0x000000, "Member 'HWAIBlueprintLibrary_RequestGameplayTagFromName::InName' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_RequestGameplayTagFromName, outTag) == 0x000008, "Member 'HWAIBlueprintLibrary_RequestGameplayTagFromName::outTag' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_RequestGameplayTagFromName, ReturnValue) == 0x000010, "Member 'HWAIBlueprintLibrary_RequestGameplayTagFromName::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.SetNavigationAvoidanceGroupsToAvoidMask_AllGods
// 0x0008 (0x0008 - 0x0000)
struct HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGods final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGods) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGods");
static_assert(sizeof(HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGods) == 0x000008, "Wrong size on HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGods");
static_assert(offsetof(HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGods, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGods::Character' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.SetNavigationAvoidanceGroupsToAvoidMask_AllGodsEnemyMinions
// 0x0008 (0x0008 - 0x0000)
struct HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGodsEnemyMinions final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGodsEnemyMinions) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGodsEnemyMinions");
static_assert(sizeof(HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGodsEnemyMinions) == 0x000008, "Wrong size on HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGodsEnemyMinions");
static_assert(offsetof(HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGodsEnemyMinions, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllGodsEnemyMinions::Character' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.SetNavigationAvoidanceGroupsToAvoidMask_AllyGodsEnemyMinions
// 0x0008 (0x0008 - 0x0000)
struct HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllyGodsEnemyMinions final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllyGodsEnemyMinions) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllyGodsEnemyMinions");
static_assert(sizeof(HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllyGodsEnemyMinions) == 0x000008, "Wrong size on HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllyGodsEnemyMinions");
static_assert(offsetof(HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllyGodsEnemyMinions, Character) == 0x000000, "Member 'HWAIBlueprintLibrary_SetNavigationAvoidanceGroupsToAvoidMask_AllyGodsEnemyMinions::Character' has a wrong offset!");

// Function Hemingway.HWAIBlueprintLibrary.ShouldGodBackToBase
// 0x0018 (0x0018 - 0x0000)
struct HWAIBlueprintLibrary_ShouldGodBackToBase final
{
public:
	const class AHWCharacter_Base*                Source;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         healthThreshold;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         manaThreshold;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIBlueprintLibrary_ShouldGodBackToBase) == 0x000008, "Wrong alignment on HWAIBlueprintLibrary_ShouldGodBackToBase");
static_assert(sizeof(HWAIBlueprintLibrary_ShouldGodBackToBase) == 0x000018, "Wrong size on HWAIBlueprintLibrary_ShouldGodBackToBase");
static_assert(offsetof(HWAIBlueprintLibrary_ShouldGodBackToBase, Source) == 0x000000, "Member 'HWAIBlueprintLibrary_ShouldGodBackToBase::Source' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_ShouldGodBackToBase, healthThreshold) == 0x000008, "Member 'HWAIBlueprintLibrary_ShouldGodBackToBase::healthThreshold' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_ShouldGodBackToBase, manaThreshold) == 0x00000C, "Member 'HWAIBlueprintLibrary_ShouldGodBackToBase::manaThreshold' has a wrong offset!");
static_assert(offsetof(HWAIBlueprintLibrary_ShouldGodBackToBase, ReturnValue) == 0x000010, "Member 'HWAIBlueprintLibrary_ShouldGodBackToBase::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetLastDamageTakenWorldTime
// 0x0004 (0x0004 - 0x0000)
struct HWAIController_GetLastDamageTakenWorldTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetLastDamageTakenWorldTime) == 0x000004, "Wrong alignment on HWAIController_GetLastDamageTakenWorldTime");
static_assert(sizeof(HWAIController_GetLastDamageTakenWorldTime) == 0x000004, "Wrong size on HWAIController_GetLastDamageTakenWorldTime");
static_assert(offsetof(HWAIController_GetLastDamageTakenWorldTime, ReturnValue) == 0x000000, "Member 'HWAIController_GetLastDamageTakenWorldTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.InitializeBotComponents
// 0x00B8 (0x00B8 - 0x0000)
struct HWAIController_InitializeBotComponents final
{
public:
	const class AHWBotFactory*                    factory;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAIBotConfig                         botConfig;                                         // 0x0008(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_InitializeBotComponents) == 0x000008, "Wrong alignment on HWAIController_InitializeBotComponents");
static_assert(sizeof(HWAIController_InitializeBotComponents) == 0x0000B8, "Wrong size on HWAIController_InitializeBotComponents");
static_assert(offsetof(HWAIController_InitializeBotComponents, factory) == 0x000000, "Member 'HWAIController_InitializeBotComponents::factory' has a wrong offset!");
static_assert(offsetof(HWAIController_InitializeBotComponents, botConfig) == 0x000008, "Member 'HWAIController_InitializeBotComponents::botConfig' has a wrong offset!");

// Function Hemingway.HWAIController.InitializePerception
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_InitializePerception final
{
public:
	TSubclassOf<class UHWAIPerceptionComponent>   PerceptionComponentClass;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_InitializePerception) == 0x000008, "Wrong alignment on HWAIController_InitializePerception");
static_assert(sizeof(HWAIController_InitializePerception) == 0x000008, "Wrong size on HWAIController_InitializePerception");
static_assert(offsetof(HWAIController_InitializePerception, PerceptionComponentClass) == 0x000000, "Member 'HWAIController_InitializePerception::PerceptionComponentClass' has a wrong offset!");

// Function Hemingway.HWAIController.OnCharacterDamaged
// 0x0070 (0x0070 - 0x0000)
struct HWAIController_OnCharacterDamaged final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_OnCharacterDamaged) == 0x000008, "Wrong alignment on HWAIController_OnCharacterDamaged");
static_assert(sizeof(HWAIController_OnCharacterDamaged) == 0x000070, "Wrong size on HWAIController_OnCharacterDamaged");
static_assert(offsetof(HWAIController_OnCharacterDamaged, DamageEventData) == 0x000000, "Member 'HWAIController_OnCharacterDamaged::DamageEventData' has a wrong offset!");

// Function Hemingway.HWAIController.OnTargetPerceptionUpdated
// 0x0060 (0x0060 - 0x0000)
struct HWAIController_OnTargetPerceptionUpdated final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIStimulus                            Stimulus;                                          // 0x0008(0x0058)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_OnTargetPerceptionUpdated) == 0x000008, "Wrong alignment on HWAIController_OnTargetPerceptionUpdated");
static_assert(sizeof(HWAIController_OnTargetPerceptionUpdated) == 0x000060, "Wrong size on HWAIController_OnTargetPerceptionUpdated");
static_assert(offsetof(HWAIController_OnTargetPerceptionUpdated, Actor) == 0x000000, "Member 'HWAIController_OnTargetPerceptionUpdated::Actor' has a wrong offset!");
static_assert(offsetof(HWAIController_OnTargetPerceptionUpdated, Stimulus) == 0x000008, "Member 'HWAIController_OnTargetPerceptionUpdated::Stimulus' has a wrong offset!");

// Function Hemingway.HWAIController.SetCurrentThreatEvaluator
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_SetCurrentThreatEvaluator final
{
public:
	class UHWAIThreatEvaluator*                   inEvaluator;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_SetCurrentThreatEvaluator) == 0x000008, "Wrong alignment on HWAIController_SetCurrentThreatEvaluator");
static_assert(sizeof(HWAIController_SetCurrentThreatEvaluator) == 0x000008, "Wrong size on HWAIController_SetCurrentThreatEvaluator");
static_assert(offsetof(HWAIController_SetCurrentThreatEvaluator, inEvaluator) == 0x000000, "Member 'HWAIController_SetCurrentThreatEvaluator::inEvaluator' has a wrong offset!");

// Function Hemingway.HWAIController.ToggleFocusOnPlayActor
// 0x0001 (0x0001 - 0x0000)
struct HWAIController_ToggleFocusOnPlayActor final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_ToggleFocusOnPlayActor) == 0x000001, "Wrong alignment on HWAIController_ToggleFocusOnPlayActor");
static_assert(sizeof(HWAIController_ToggleFocusOnPlayActor) == 0x000001, "Wrong size on HWAIController_ToggleFocusOnPlayActor");
static_assert(offsetof(HWAIController_ToggleFocusOnPlayActor, bOn) == 0x000000, "Member 'HWAIController_ToggleFocusOnPlayActor::bOn' has a wrong offset!");

// Function Hemingway.HWAIController.ToggleLockCurrentThreat
// 0x0001 (0x0001 - 0x0000)
struct HWAIController_ToggleLockCurrentThreat final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_ToggleLockCurrentThreat) == 0x000001, "Wrong alignment on HWAIController_ToggleLockCurrentThreat");
static_assert(sizeof(HWAIController_ToggleLockCurrentThreat) == 0x000001, "Wrong size on HWAIController_ToggleLockCurrentThreat");
static_assert(offsetof(HWAIController_ToggleLockCurrentThreat, bOn) == 0x000000, "Member 'HWAIController_ToggleLockCurrentThreat::bOn' has a wrong offset!");

// Function Hemingway.HWAIController.AreThereCredibleThreatsWithinRange
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_AreThereCredibleThreatsWithinRange final
{
public:
	float                                         Range;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIController_AreThereCredibleThreatsWithinRange) == 0x000004, "Wrong alignment on HWAIController_AreThereCredibleThreatsWithinRange");
static_assert(sizeof(HWAIController_AreThereCredibleThreatsWithinRange) == 0x000008, "Wrong size on HWAIController_AreThereCredibleThreatsWithinRange");
static_assert(offsetof(HWAIController_AreThereCredibleThreatsWithinRange, Range) == 0x000000, "Member 'HWAIController_AreThereCredibleThreatsWithinRange::Range' has a wrong offset!");
static_assert(offsetof(HWAIController_AreThereCredibleThreatsWithinRange, ReturnValue) == 0x000004, "Member 'HWAIController_AreThereCredibleThreatsWithinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.CanSeeHostileTarget
// 0x0010 (0x0010 - 0x0000)
struct HWAIController_CanSeeHostileTarget final
{
public:
	const class AActor*                           InActor;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeMiniMap;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIController_CanSeeHostileTarget) == 0x000008, "Wrong alignment on HWAIController_CanSeeHostileTarget");
static_assert(sizeof(HWAIController_CanSeeHostileTarget) == 0x000010, "Wrong size on HWAIController_CanSeeHostileTarget");
static_assert(offsetof(HWAIController_CanSeeHostileTarget, InActor) == 0x000000, "Member 'HWAIController_CanSeeHostileTarget::InActor' has a wrong offset!");
static_assert(offsetof(HWAIController_CanSeeHostileTarget, bIncludeMiniMap) == 0x000008, "Member 'HWAIController_CanSeeHostileTarget::bIncludeMiniMap' has a wrong offset!");
static_assert(offsetof(HWAIController_CanSeeHostileTarget, ReturnValue) == 0x000009, "Member 'HWAIController_CanSeeHostileTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetAbilitySystemActor
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_GetAbilitySystemActor final
{
public:
	class AHWCharacterAbilitySystemActor*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetAbilitySystemActor) == 0x000008, "Wrong alignment on HWAIController_GetAbilitySystemActor");
static_assert(sizeof(HWAIController_GetAbilitySystemActor) == 0x000008, "Wrong size on HWAIController_GetAbilitySystemActor");
static_assert(offsetof(HWAIController_GetAbilitySystemActor, ReturnValue) == 0x000000, "Member 'HWAIController_GetAbilitySystemActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetAllThreats
// 0x0018 (0x0018 - 0x0000)
struct HWAIController_GetAllThreats final
{
public:
	bool                                          bIncludeCurrentThreat;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWCharacter_Base*>              outThreats;                                        // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetAllThreats) == 0x000008, "Wrong alignment on HWAIController_GetAllThreats");
static_assert(sizeof(HWAIController_GetAllThreats) == 0x000018, "Wrong size on HWAIController_GetAllThreats");
static_assert(offsetof(HWAIController_GetAllThreats, bIncludeCurrentThreat) == 0x000000, "Member 'HWAIController_GetAllThreats::bIncludeCurrentThreat' has a wrong offset!");
static_assert(offsetof(HWAIController_GetAllThreats, outThreats) == 0x000008, "Member 'HWAIController_GetAllThreats::outThreats' has a wrong offset!");

// Function Hemingway.HWAIController.GetAverageIncomingDamage
// 0x0004 (0x0004 - 0x0000)
struct HWAIController_GetAverageIncomingDamage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetAverageIncomingDamage) == 0x000004, "Wrong alignment on HWAIController_GetAverageIncomingDamage");
static_assert(sizeof(HWAIController_GetAverageIncomingDamage) == 0x000004, "Wrong size on HWAIController_GetAverageIncomingDamage");
static_assert(offsetof(HWAIController_GetAverageIncomingDamage, ReturnValue) == 0x000000, "Member 'HWAIController_GetAverageIncomingDamage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetAverageOutgoingDamage
// 0x0004 (0x0004 - 0x0000)
struct HWAIController_GetAverageOutgoingDamage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetAverageOutgoingDamage) == 0x000004, "Wrong alignment on HWAIController_GetAverageOutgoingDamage");
static_assert(sizeof(HWAIController_GetAverageOutgoingDamage) == 0x000004, "Wrong size on HWAIController_GetAverageOutgoingDamage");
static_assert(offsetof(HWAIController_GetAverageOutgoingDamage, ReturnValue) == 0x000000, "Member 'HWAIController_GetAverageOutgoingDamage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetAvgThreatLocation
// 0x0018 (0x0018 - 0x0000)
struct HWAIController_GetAvgThreatLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetAvgThreatLocation) == 0x000008, "Wrong alignment on HWAIController_GetAvgThreatLocation");
static_assert(sizeof(HWAIController_GetAvgThreatLocation) == 0x000018, "Wrong size on HWAIController_GetAvgThreatLocation");
static_assert(offsetof(HWAIController_GetAvgThreatLocation, ReturnValue) == 0x000000, "Member 'HWAIController_GetAvgThreatLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetBehaviorTreeComponent
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_GetBehaviorTreeComponent final
{
public:
	class UBehaviorTreeComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetBehaviorTreeComponent) == 0x000008, "Wrong alignment on HWAIController_GetBehaviorTreeComponent");
static_assert(sizeof(HWAIController_GetBehaviorTreeComponent) == 0x000008, "Wrong size on HWAIController_GetBehaviorTreeComponent");
static_assert(offsetof(HWAIController_GetBehaviorTreeComponent, ReturnValue) == 0x000000, "Member 'HWAIController_GetBehaviorTreeComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetCurrentThreat
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_GetCurrentThreat final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetCurrentThreat) == 0x000008, "Wrong alignment on HWAIController_GetCurrentThreat");
static_assert(sizeof(HWAIController_GetCurrentThreat) == 0x000008, "Wrong size on HWAIController_GetCurrentThreat");
static_assert(offsetof(HWAIController_GetCurrentThreat, ReturnValue) == 0x000000, "Member 'HWAIController_GetCurrentThreat::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetCurrentThreatLastKnownLocation
// 0x0018 (0x0018 - 0x0000)
struct HWAIController_GetCurrentThreatLastKnownLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetCurrentThreatLastKnownLocation) == 0x000008, "Wrong alignment on HWAIController_GetCurrentThreatLastKnownLocation");
static_assert(sizeof(HWAIController_GetCurrentThreatLastKnownLocation) == 0x000018, "Wrong size on HWAIController_GetCurrentThreatLastKnownLocation");
static_assert(offsetof(HWAIController_GetCurrentThreatLastKnownLocation, ReturnValue) == 0x000000, "Member 'HWAIController_GetCurrentThreatLastKnownLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetGankAbleThreatCount
// 0x000C (0x000C - 0x0000)
struct HWAIController_GetGankAbleThreatCount final
{
public:
	float                                         Range;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSight;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetGankAbleThreatCount) == 0x000004, "Wrong alignment on HWAIController_GetGankAbleThreatCount");
static_assert(sizeof(HWAIController_GetGankAbleThreatCount) == 0x00000C, "Wrong size on HWAIController_GetGankAbleThreatCount");
static_assert(offsetof(HWAIController_GetGankAbleThreatCount, Range) == 0x000000, "Member 'HWAIController_GetGankAbleThreatCount::Range' has a wrong offset!");
static_assert(offsetof(HWAIController_GetGankAbleThreatCount, bHasSight) == 0x000004, "Member 'HWAIController_GetGankAbleThreatCount::bHasSight' has a wrong offset!");
static_assert(offsetof(HWAIController_GetGankAbleThreatCount, ReturnValue) == 0x000008, "Member 'HWAIController_GetGankAbleThreatCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetGodThreatAvgHealthPct
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_GetGodThreatAvgHealthPct final
{
public:
	float                                         MaxDistance;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetGodThreatAvgHealthPct) == 0x000004, "Wrong alignment on HWAIController_GetGodThreatAvgHealthPct");
static_assert(sizeof(HWAIController_GetGodThreatAvgHealthPct) == 0x000008, "Wrong size on HWAIController_GetGodThreatAvgHealthPct");
static_assert(offsetof(HWAIController_GetGodThreatAvgHealthPct, MaxDistance) == 0x000000, "Member 'HWAIController_GetGodThreatAvgHealthPct::MaxDistance' has a wrong offset!");
static_assert(offsetof(HWAIController_GetGodThreatAvgHealthPct, ReturnValue) == 0x000004, "Member 'HWAIController_GetGodThreatAvgHealthPct::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetGodThreatCount
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_GetGodThreatCount final
{
public:
	float                                         MaxDistance;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetGodThreatCount) == 0x000004, "Wrong alignment on HWAIController_GetGodThreatCount");
static_assert(sizeof(HWAIController_GetGodThreatCount) == 0x000008, "Wrong size on HWAIController_GetGodThreatCount");
static_assert(offsetof(HWAIController_GetGodThreatCount, MaxDistance) == 0x000000, "Member 'HWAIController_GetGodThreatCount::MaxDistance' has a wrong offset!");
static_assert(offsetof(HWAIController_GetGodThreatCount, ReturnValue) == 0x000004, "Member 'HWAIController_GetGodThreatCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetGodThreatTotalHealthPct
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_GetGodThreatTotalHealthPct final
{
public:
	float                                         MaxDistance;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetGodThreatTotalHealthPct) == 0x000004, "Wrong alignment on HWAIController_GetGodThreatTotalHealthPct");
static_assert(sizeof(HWAIController_GetGodThreatTotalHealthPct) == 0x000008, "Wrong size on HWAIController_GetGodThreatTotalHealthPct");
static_assert(offsetof(HWAIController_GetGodThreatTotalHealthPct, MaxDistance) == 0x000000, "Member 'HWAIController_GetGodThreatTotalHealthPct::MaxDistance' has a wrong offset!");
static_assert(offsetof(HWAIController_GetGodThreatTotalHealthPct, ReturnValue) == 0x000004, "Member 'HWAIController_GetGodThreatTotalHealthPct::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetHostileThreatCount
// 0x0010 (0x0010 - 0x0000)
struct HWAIController_GetHostileThreatCount final
{
public:
	bool                                          bOnlyWithinAttackRange;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDamagedByTime;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGodOnly;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetHostileThreatCount) == 0x000004, "Wrong alignment on HWAIController_GetHostileThreatCount");
static_assert(sizeof(HWAIController_GetHostileThreatCount) == 0x000010, "Wrong size on HWAIController_GetHostileThreatCount");
static_assert(offsetof(HWAIController_GetHostileThreatCount, bOnlyWithinAttackRange) == 0x000000, "Member 'HWAIController_GetHostileThreatCount::bOnlyWithinAttackRange' has a wrong offset!");
static_assert(offsetof(HWAIController_GetHostileThreatCount, MaxDamagedByTime) == 0x000004, "Member 'HWAIController_GetHostileThreatCount::MaxDamagedByTime' has a wrong offset!");
static_assert(offsetof(HWAIController_GetHostileThreatCount, bGodOnly) == 0x000008, "Member 'HWAIController_GetHostileThreatCount::bGodOnly' has a wrong offset!");
static_assert(offsetof(HWAIController_GetHostileThreatCount, ReturnValue) == 0x00000C, "Member 'HWAIController_GetHostileThreatCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetIncomingDamagePerSecond
// 0x0004 (0x0004 - 0x0000)
struct HWAIController_GetIncomingDamagePerSecond final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetIncomingDamagePerSecond) == 0x000004, "Wrong alignment on HWAIController_GetIncomingDamagePerSecond");
static_assert(sizeof(HWAIController_GetIncomingDamagePerSecond) == 0x000004, "Wrong size on HWAIController_GetIncomingDamagePerSecond");
static_assert(offsetof(HWAIController_GetIncomingDamagePerSecond, ReturnValue) == 0x000000, "Member 'HWAIController_GetIncomingDamagePerSecond::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetLaneDirection
// 0x0001 (0x0001 - 0x0000)
struct HWAIController_GetLaneDirection final
{
public:
	EWaypointPathDirectionType                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetLaneDirection) == 0x000001, "Wrong alignment on HWAIController_GetLaneDirection");
static_assert(sizeof(HWAIController_GetLaneDirection) == 0x000001, "Wrong size on HWAIController_GetLaneDirection");
static_assert(offsetof(HWAIController_GetLaneDirection, ReturnValue) == 0x000000, "Member 'HWAIController_GetLaneDirection::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetLaneID
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_GetLaneID final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetLaneID) == 0x000004, "Wrong alignment on HWAIController_GetLaneID");
static_assert(sizeof(HWAIController_GetLaneID) == 0x000008, "Wrong size on HWAIController_GetLaneID");
static_assert(offsetof(HWAIController_GetLaneID, ReturnValue) == 0x000000, "Member 'HWAIController_GetLaneID::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetMinionThreatAggroCount
// 0x0004 (0x0004 - 0x0000)
struct HWAIController_GetMinionThreatAggroCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetMinionThreatAggroCount) == 0x000004, "Wrong alignment on HWAIController_GetMinionThreatAggroCount");
static_assert(sizeof(HWAIController_GetMinionThreatAggroCount) == 0x000004, "Wrong size on HWAIController_GetMinionThreatAggroCount");
static_assert(offsetof(HWAIController_GetMinionThreatAggroCount, ReturnValue) == 0x000000, "Member 'HWAIController_GetMinionThreatAggroCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetMinionThreatCount
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_GetMinionThreatCount final
{
public:
	float                                         MaxDistance;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetMinionThreatCount) == 0x000004, "Wrong alignment on HWAIController_GetMinionThreatCount");
static_assert(sizeof(HWAIController_GetMinionThreatCount) == 0x000008, "Wrong size on HWAIController_GetMinionThreatCount");
static_assert(offsetof(HWAIController_GetMinionThreatCount, MaxDistance) == 0x000000, "Member 'HWAIController_GetMinionThreatCount::MaxDistance' has a wrong offset!");
static_assert(offsetof(HWAIController_GetMinionThreatCount, ReturnValue) == 0x000004, "Member 'HWAIController_GetMinionThreatCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetNearestStructureThreat
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_GetNearestStructureThreat final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetNearestStructureThreat) == 0x000008, "Wrong alignment on HWAIController_GetNearestStructureThreat");
static_assert(sizeof(HWAIController_GetNearestStructureThreat) == 0x000008, "Wrong size on HWAIController_GetNearestStructureThreat");
static_assert(offsetof(HWAIController_GetNearestStructureThreat, ReturnValue) == 0x000000, "Member 'HWAIController_GetNearestStructureThreat::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetNearestThreat
// 0x0010 (0x0010 - 0x0000)
struct HWAIController_GetNearestThreat final
{
public:
	bool                                          bGodOnly;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetNearestThreat) == 0x000008, "Wrong alignment on HWAIController_GetNearestThreat");
static_assert(sizeof(HWAIController_GetNearestThreat) == 0x000010, "Wrong size on HWAIController_GetNearestThreat");
static_assert(offsetof(HWAIController_GetNearestThreat, bGodOnly) == 0x000000, "Member 'HWAIController_GetNearestThreat::bGodOnly' has a wrong offset!");
static_assert(offsetof(HWAIController_GetNearestThreat, ReturnValue) == 0x000008, "Member 'HWAIController_GetNearestThreat::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetOutgoingDamagePerSecond
// 0x0004 (0x0004 - 0x0000)
struct HWAIController_GetOutgoingDamagePerSecond final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetOutgoingDamagePerSecond) == 0x000004, "Wrong alignment on HWAIController_GetOutgoingDamagePerSecond");
static_assert(sizeof(HWAIController_GetOutgoingDamagePerSecond) == 0x000004, "Wrong size on HWAIController_GetOutgoingDamagePerSecond");
static_assert(offsetof(HWAIController_GetOutgoingDamagePerSecond, ReturnValue) == 0x000000, "Member 'HWAIController_GetOutgoingDamagePerSecond::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.GetTeamRole
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_GetTeamRole final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_GetTeamRole) == 0x000004, "Wrong alignment on HWAIController_GetTeamRole");
static_assert(sizeof(HWAIController_GetTeamRole) == 0x000008, "Wrong size on HWAIController_GetTeamRole");
static_assert(offsetof(HWAIController_GetTeamRole, ReturnValue) == 0x000000, "Member 'HWAIController_GetTeamRole::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.IsAHostileThreat
// 0x0010 (0x0010 - 0x0000)
struct HWAIController_IsAHostileThreat final
{
public:
	const class AHWCharacter_Base*                Threat;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDamagedByTime;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIController_IsAHostileThreat) == 0x000008, "Wrong alignment on HWAIController_IsAHostileThreat");
static_assert(sizeof(HWAIController_IsAHostileThreat) == 0x000010, "Wrong size on HWAIController_IsAHostileThreat");
static_assert(offsetof(HWAIController_IsAHostileThreat, Threat) == 0x000000, "Member 'HWAIController_IsAHostileThreat::Threat' has a wrong offset!");
static_assert(offsetof(HWAIController_IsAHostileThreat, MaxDamagedByTime) == 0x000008, "Member 'HWAIController_IsAHostileThreat::MaxDamagedByTime' has a wrong offset!");
static_assert(offsetof(HWAIController_IsAHostileThreat, ReturnValue) == 0x00000C, "Member 'HWAIController_IsAHostileThreat::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.IsCurrentThreatGankable
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_IsCurrentThreatGankable final
{
public:
	float                                         Range;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIController_IsCurrentThreatGankable) == 0x000004, "Wrong alignment on HWAIController_IsCurrentThreatGankable");
static_assert(sizeof(HWAIController_IsCurrentThreatGankable) == 0x000008, "Wrong size on HWAIController_IsCurrentThreatGankable");
static_assert(offsetof(HWAIController_IsCurrentThreatGankable, Range) == 0x000000, "Member 'HWAIController_IsCurrentThreatGankable::Range' has a wrong offset!");
static_assert(offsetof(HWAIController_IsCurrentThreatGankable, ReturnValue) == 0x000004, "Member 'HWAIController_IsCurrentThreatGankable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.IsCurrentThreatLocked
// 0x0001 (0x0001 - 0x0000)
struct HWAIController_IsCurrentThreatLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_IsCurrentThreatLocked) == 0x000001, "Wrong alignment on HWAIController_IsCurrentThreatLocked");
static_assert(sizeof(HWAIController_IsCurrentThreatLocked) == 0x000001, "Wrong size on HWAIController_IsCurrentThreatLocked");
static_assert(offsetof(HWAIController_IsCurrentThreatLocked, ReturnValue) == 0x000000, "Member 'HWAIController_IsCurrentThreatLocked::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.IsGoalSystemLocked
// 0x0001 (0x0001 - 0x0000)
struct HWAIController_IsGoalSystemLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_IsGoalSystemLocked) == 0x000001, "Wrong alignment on HWAIController_IsGoalSystemLocked");
static_assert(sizeof(HWAIController_IsGoalSystemLocked) == 0x000001, "Wrong size on HWAIController_IsGoalSystemLocked");
static_assert(offsetof(HWAIController_IsGoalSystemLocked, ReturnValue) == 0x000000, "Member 'HWAIController_IsGoalSystemLocked::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.IsGodThreatAvailable
// 0x0008 (0x0008 - 0x0000)
struct HWAIController_IsGodThreatAvailable final
{
public:
	float                                         MaxDistance;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIController_IsGodThreatAvailable) == 0x000004, "Wrong alignment on HWAIController_IsGodThreatAvailable");
static_assert(sizeof(HWAIController_IsGodThreatAvailable) == 0x000008, "Wrong size on HWAIController_IsGodThreatAvailable");
static_assert(offsetof(HWAIController_IsGodThreatAvailable, MaxDistance) == 0x000000, "Member 'HWAIController_IsGodThreatAvailable::MaxDistance' has a wrong offset!");
static_assert(offsetof(HWAIController_IsGodThreatAvailable, ReturnValue) == 0x000004, "Member 'HWAIController_IsGodThreatAvailable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.IsHostileThreatAvailable
// 0x000C (0x000C - 0x0000)
struct HWAIController_IsHostileThreatAvailable final
{
public:
	bool                                          bOnlyWithinAttackRange;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDamagedByTime;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGodOnly;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIController_IsHostileThreatAvailable) == 0x000004, "Wrong alignment on HWAIController_IsHostileThreatAvailable");
static_assert(sizeof(HWAIController_IsHostileThreatAvailable) == 0x00000C, "Wrong size on HWAIController_IsHostileThreatAvailable");
static_assert(offsetof(HWAIController_IsHostileThreatAvailable, bOnlyWithinAttackRange) == 0x000000, "Member 'HWAIController_IsHostileThreatAvailable::bOnlyWithinAttackRange' has a wrong offset!");
static_assert(offsetof(HWAIController_IsHostileThreatAvailable, MaxDamagedByTime) == 0x000004, "Member 'HWAIController_IsHostileThreatAvailable::MaxDamagedByTime' has a wrong offset!");
static_assert(offsetof(HWAIController_IsHostileThreatAvailable, bGodOnly) == 0x000008, "Member 'HWAIController_IsHostileThreatAvailable::bGodOnly' has a wrong offset!");
static_assert(offsetof(HWAIController_IsHostileThreatAvailable, ReturnValue) == 0x000009, "Member 'HWAIController_IsHostileThreatAvailable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.IsThreat
// 0x0010 (0x0010 - 0x0000)
struct HWAIController_IsThreat final
{
public:
	const class AActor*                           InActor;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutIndex;                                          // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIController_IsThreat) == 0x000008, "Wrong alignment on HWAIController_IsThreat");
static_assert(sizeof(HWAIController_IsThreat) == 0x000010, "Wrong size on HWAIController_IsThreat");
static_assert(offsetof(HWAIController_IsThreat, InActor) == 0x000000, "Member 'HWAIController_IsThreat::InActor' has a wrong offset!");
static_assert(offsetof(HWAIController_IsThreat, OutIndex) == 0x000008, "Member 'HWAIController_IsThreat::OutIndex' has a wrong offset!");
static_assert(offsetof(HWAIController_IsThreat, ReturnValue) == 0x00000C, "Member 'HWAIController_IsThreat::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.IsThreatGankable
// 0x0010 (0x0010 - 0x0000)
struct HWAIController_IsThreatGankable final
{
public:
	const class AHWCharacter_Base*                Threat;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIController_IsThreatGankable) == 0x000008, "Wrong alignment on HWAIController_IsThreatGankable");
static_assert(sizeof(HWAIController_IsThreatGankable) == 0x000010, "Wrong size on HWAIController_IsThreatGankable");
static_assert(offsetof(HWAIController_IsThreatGankable, Threat) == 0x000000, "Member 'HWAIController_IsThreatGankable::Threat' has a wrong offset!");
static_assert(offsetof(HWAIController_IsThreatGankable, Range) == 0x000008, "Member 'HWAIController_IsThreatGankable::Range' has a wrong offset!");
static_assert(offsetof(HWAIController_IsThreatGankable, ReturnValue) == 0x00000C, "Member 'HWAIController_IsThreatGankable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.PredictNextIncomingDamageAmount
// 0x0004 (0x0004 - 0x0000)
struct HWAIController_PredictNextIncomingDamageAmount final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_PredictNextIncomingDamageAmount) == 0x000004, "Wrong alignment on HWAIController_PredictNextIncomingDamageAmount");
static_assert(sizeof(HWAIController_PredictNextIncomingDamageAmount) == 0x000004, "Wrong size on HWAIController_PredictNextIncomingDamageAmount");
static_assert(offsetof(HWAIController_PredictNextIncomingDamageAmount, ReturnValue) == 0x000000, "Member 'HWAIController_PredictNextIncomingDamageAmount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIController.PredictNextOutgoingDamageAmount
// 0x0004 (0x0004 - 0x0000)
struct HWAIController_PredictNextOutgoingDamageAmount final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIController_PredictNextOutgoingDamageAmount) == 0x000004, "Wrong alignment on HWAIController_PredictNextOutgoingDamageAmount");
static_assert(sizeof(HWAIController_PredictNextOutgoingDamageAmount) == 0x000004, "Wrong size on HWAIController_PredictNextOutgoingDamageAmount");
static_assert(offsetof(HWAIController_PredictNextOutgoingDamageAmount, ReturnValue) == 0x000000, "Member 'HWAIController_PredictNextOutgoingDamageAmount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShopVendorVolume.OnOverlappedCharacterAbilitySystemChanged
// 0x0010 (0x0010 - 0x0000)
struct HWShopVendorVolume_OnOverlappedCharacterAbilitySystemChanged final
{
public:
	class UHWAbilitySystemComponent*              NewAbilitySystem;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OldAbilitySystem;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShopVendorVolume_OnOverlappedCharacterAbilitySystemChanged) == 0x000008, "Wrong alignment on HWShopVendorVolume_OnOverlappedCharacterAbilitySystemChanged");
static_assert(sizeof(HWShopVendorVolume_OnOverlappedCharacterAbilitySystemChanged) == 0x000010, "Wrong size on HWShopVendorVolume_OnOverlappedCharacterAbilitySystemChanged");
static_assert(offsetof(HWShopVendorVolume_OnOverlappedCharacterAbilitySystemChanged, NewAbilitySystem) == 0x000000, "Member 'HWShopVendorVolume_OnOverlappedCharacterAbilitySystemChanged::NewAbilitySystem' has a wrong offset!");
static_assert(offsetof(HWShopVendorVolume_OnOverlappedCharacterAbilitySystemChanged, OldAbilitySystem) == 0x000008, "Member 'HWShopVendorVolume_OnOverlappedCharacterAbilitySystemChanged::OldAbilitySystem' has a wrong offset!");

// Function Hemingway.HWShopVendorVolume.CanShopActivateFor
// 0x0010 (0x0010 - 0x0000)
struct HWShopVendorVolume_CanShopActivateFor final
{
public:
	class AHWCharacter_Base*                      NewTouchingCharacter;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWShopVendorVolume_CanShopActivateFor) == 0x000008, "Wrong alignment on HWShopVendorVolume_CanShopActivateFor");
static_assert(sizeof(HWShopVendorVolume_CanShopActivateFor) == 0x000010, "Wrong size on HWShopVendorVolume_CanShopActivateFor");
static_assert(offsetof(HWShopVendorVolume_CanShopActivateFor, NewTouchingCharacter) == 0x000000, "Member 'HWShopVendorVolume_CanShopActivateFor::NewTouchingCharacter' has a wrong offset!");
static_assert(offsetof(HWShopVendorVolume_CanShopActivateFor, ReturnValue) == 0x000008, "Member 'HWShopVendorVolume_CanShopActivateFor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIDifficultyConfig.GetMaxFocusFireOnPlayer
// 0x0008 (0x0008 - 0x0000)
struct HWAIDifficultyConfig_GetMaxFocusFireOnPlayer final
{
public:
	float                                         DifficultyScale;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIDifficultyConfig_GetMaxFocusFireOnPlayer) == 0x000004, "Wrong alignment on HWAIDifficultyConfig_GetMaxFocusFireOnPlayer");
static_assert(sizeof(HWAIDifficultyConfig_GetMaxFocusFireOnPlayer) == 0x000008, "Wrong size on HWAIDifficultyConfig_GetMaxFocusFireOnPlayer");
static_assert(offsetof(HWAIDifficultyConfig_GetMaxFocusFireOnPlayer, DifficultyScale) == 0x000000, "Member 'HWAIDifficultyConfig_GetMaxFocusFireOnPlayer::DifficultyScale' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_GetMaxFocusFireOnPlayer, ReturnValue) == 0x000004, "Member 'HWAIDifficultyConfig_GetMaxFocusFireOnPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIDifficultyConfig.GetMinPlayerLevelForAggression
// 0x0008 (0x0008 - 0x0000)
struct HWAIDifficultyConfig_GetMinPlayerLevelForAggression final
{
public:
	float                                         DifficultyScale;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIDifficultyConfig_GetMinPlayerLevelForAggression) == 0x000004, "Wrong alignment on HWAIDifficultyConfig_GetMinPlayerLevelForAggression");
static_assert(sizeof(HWAIDifficultyConfig_GetMinPlayerLevelForAggression) == 0x000008, "Wrong size on HWAIDifficultyConfig_GetMinPlayerLevelForAggression");
static_assert(offsetof(HWAIDifficultyConfig_GetMinPlayerLevelForAggression, DifficultyScale) == 0x000000, "Member 'HWAIDifficultyConfig_GetMinPlayerLevelForAggression::DifficultyScale' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_GetMinPlayerLevelForAggression, ReturnValue) == 0x000004, "Member 'HWAIDifficultyConfig_GetMinPlayerLevelForAggression::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIDifficultyConfig.GetPlayerThreatModifier
// 0x0008 (0x0008 - 0x0000)
struct HWAIDifficultyConfig_GetPlayerThreatModifier final
{
public:
	float                                         DifficultyScale;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIDifficultyConfig_GetPlayerThreatModifier) == 0x000004, "Wrong alignment on HWAIDifficultyConfig_GetPlayerThreatModifier");
static_assert(sizeof(HWAIDifficultyConfig_GetPlayerThreatModifier) == 0x000008, "Wrong size on HWAIDifficultyConfig_GetPlayerThreatModifier");
static_assert(offsetof(HWAIDifficultyConfig_GetPlayerThreatModifier, DifficultyScale) == 0x000000, "Member 'HWAIDifficultyConfig_GetPlayerThreatModifier::DifficultyScale' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_GetPlayerThreatModifier, ReturnValue) == 0x000004, "Member 'HWAIDifficultyConfig_GetPlayerThreatModifier::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIDifficultyConfig.GetPlayWeightPenalty
// 0x0010 (0x0010 - 0x0000)
struct HWAIDifficultyConfig_GetPlayWeightPenalty final
{
public:
	float                                         DifficultyScale;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlayTag;                                           // 0x0004(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIDifficultyConfig_GetPlayWeightPenalty) == 0x000004, "Wrong alignment on HWAIDifficultyConfig_GetPlayWeightPenalty");
static_assert(sizeof(HWAIDifficultyConfig_GetPlayWeightPenalty) == 0x000010, "Wrong size on HWAIDifficultyConfig_GetPlayWeightPenalty");
static_assert(offsetof(HWAIDifficultyConfig_GetPlayWeightPenalty, DifficultyScale) == 0x000000, "Member 'HWAIDifficultyConfig_GetPlayWeightPenalty::DifficultyScale' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_GetPlayWeightPenalty, PlayTag) == 0x000004, "Member 'HWAIDifficultyConfig_GetPlayWeightPenalty::PlayTag' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_GetPlayWeightPenalty, ReturnValue) == 0x00000C, "Member 'HWAIDifficultyConfig_GetPlayWeightPenalty::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIDifficultyConfig.IsPlayDisabled
// 0x0010 (0x0010 - 0x0000)
struct HWAIDifficultyConfig_IsPlayDisabled final
{
public:
	float                                         DifficultyScale;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlayTag;                                           // 0x0004(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIDifficultyConfig_IsPlayDisabled) == 0x000004, "Wrong alignment on HWAIDifficultyConfig_IsPlayDisabled");
static_assert(sizeof(HWAIDifficultyConfig_IsPlayDisabled) == 0x000010, "Wrong size on HWAIDifficultyConfig_IsPlayDisabled");
static_assert(offsetof(HWAIDifficultyConfig_IsPlayDisabled, DifficultyScale) == 0x000000, "Member 'HWAIDifficultyConfig_IsPlayDisabled::DifficultyScale' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_IsPlayDisabled, PlayTag) == 0x000004, "Member 'HWAIDifficultyConfig_IsPlayDisabled::PlayTag' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_IsPlayDisabled, ReturnValue) == 0x00000C, "Member 'HWAIDifficultyConfig_IsPlayDisabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIDifficultyConfig.ShouldAllowAbility
// 0x0030 (0x0030 - 0x0000)
struct HWAIDifficultyConfig_ShouldAllowAbility final
{
public:
	float                                         DifficultyScale;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIDifficultyConfig_ShouldAllowAbility) == 0x000008, "Wrong alignment on HWAIDifficultyConfig_ShouldAllowAbility");
static_assert(sizeof(HWAIDifficultyConfig_ShouldAllowAbility) == 0x000030, "Wrong size on HWAIDifficultyConfig_ShouldAllowAbility");
static_assert(offsetof(HWAIDifficultyConfig_ShouldAllowAbility, DifficultyScale) == 0x000000, "Member 'HWAIDifficultyConfig_ShouldAllowAbility::DifficultyScale' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_ShouldAllowAbility, Tags) == 0x000008, "Member 'HWAIDifficultyConfig_ShouldAllowAbility::Tags' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_ShouldAllowAbility, ReturnValue) == 0x000028, "Member 'HWAIDifficultyConfig_ShouldAllowAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIDifficultyConfig.ShouldAllowAbilityCombos
// 0x0008 (0x0008 - 0x0000)
struct HWAIDifficultyConfig_ShouldAllowAbilityCombos final
{
public:
	float                                         DifficultyScale;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIDifficultyConfig_ShouldAllowAbilityCombos) == 0x000004, "Wrong alignment on HWAIDifficultyConfig_ShouldAllowAbilityCombos");
static_assert(sizeof(HWAIDifficultyConfig_ShouldAllowAbilityCombos) == 0x000008, "Wrong size on HWAIDifficultyConfig_ShouldAllowAbilityCombos");
static_assert(offsetof(HWAIDifficultyConfig_ShouldAllowAbilityCombos, DifficultyScale) == 0x000000, "Member 'HWAIDifficultyConfig_ShouldAllowAbilityCombos::DifficultyScale' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_ShouldAllowAbilityCombos, ReturnValue) == 0x000004, "Member 'HWAIDifficultyConfig_ShouldAllowAbilityCombos::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIDifficultyConfig.ShouldAllowAggressiveAbilityUsage
// 0x000C (0x000C - 0x0000)
struct HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage final
{
public:
	float                                         DifficultyScale;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastAggressiveAbilityUsage;               // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage) == 0x000004, "Wrong alignment on HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage");
static_assert(sizeof(HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage) == 0x00000C, "Wrong size on HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage");
static_assert(offsetof(HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage, DifficultyScale) == 0x000000, "Member 'HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage::DifficultyScale' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage, TimeSinceLastAggressiveAbilityUsage) == 0x000004, "Member 'HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage::TimeSinceLastAggressiveAbilityUsage' has a wrong offset!");
static_assert(offsetof(HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage, ReturnValue) == 0x000008, "Member 'HWAIDifficultyConfig_ShouldAllowAggressiveAbilityUsage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIDifficultyConfig.ShouldAvoidDangerousDeployables
// 0x0001 (0x0001 - 0x0000)
struct HWAIDifficultyConfig_ShouldAvoidDangerousDeployables final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIDifficultyConfig_ShouldAvoidDangerousDeployables) == 0x000001, "Wrong alignment on HWAIDifficultyConfig_ShouldAvoidDangerousDeployables");
static_assert(sizeof(HWAIDifficultyConfig_ShouldAvoidDangerousDeployables) == 0x000001, "Wrong size on HWAIDifficultyConfig_ShouldAvoidDangerousDeployables");
static_assert(offsetof(HWAIDifficultyConfig_ShouldAvoidDangerousDeployables, ReturnValue) == 0x000000, "Member 'HWAIDifficultyConfig_ShouldAvoidDangerousDeployables::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_Mulan_Evolution.GetNonGodXpPercentReduction
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponentSettings_Mulan_Evolution_GetNonGodXpPercentReduction final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_Mulan_Evolution_GetNonGodXpPercentReduction) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_Mulan_Evolution_GetNonGodXpPercentReduction");
static_assert(sizeof(HWEquipmentComponentSettings_Mulan_Evolution_GetNonGodXpPercentReduction) == 0x000004, "Wrong size on HWEquipmentComponentSettings_Mulan_Evolution_GetNonGodXpPercentReduction");
static_assert(offsetof(HWEquipmentComponentSettings_Mulan_Evolution_GetNonGodXpPercentReduction, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_Mulan_Evolution_GetNonGodXpPercentReduction::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.CalculateWeight
// 0x0010 (0x0010 - 0x0000)
struct HWAIGoal_CalculateWeight final
{
public:
	class AHWAIController*                        InController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIGoal_CalculateWeight) == 0x000008, "Wrong alignment on HWAIGoal_CalculateWeight");
static_assert(sizeof(HWAIGoal_CalculateWeight) == 0x000010, "Wrong size on HWAIGoal_CalculateWeight");
static_assert(offsetof(HWAIGoal_CalculateWeight, InController) == 0x000000, "Member 'HWAIGoal_CalculateWeight::InController' has a wrong offset!");
static_assert(offsetof(HWAIGoal_CalculateWeight, ReturnValue) == 0x000008, "Member 'HWAIGoal_CalculateWeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.CheckPreconditionsBP
// 0x0010 (0x0010 - 0x0000)
struct HWAIGoal_CheckPreconditionsBP final
{
public:
	class AHWAIController*                        InController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIGoal_CheckPreconditionsBP) == 0x000008, "Wrong alignment on HWAIGoal_CheckPreconditionsBP");
static_assert(sizeof(HWAIGoal_CheckPreconditionsBP) == 0x000010, "Wrong size on HWAIGoal_CheckPreconditionsBP");
static_assert(offsetof(HWAIGoal_CheckPreconditionsBP, InController) == 0x000000, "Member 'HWAIGoal_CheckPreconditionsBP::InController' has a wrong offset!");
static_assert(offsetof(HWAIGoal_CheckPreconditionsBP, ReturnValue) == 0x000008, "Member 'HWAIGoal_CheckPreconditionsBP::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.ClearBlackboardVariable
// 0x0008 (0x0008 - 0x0000)
struct HWAIGoal_ClearBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_ClearBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_ClearBlackboardVariable");
static_assert(sizeof(HWAIGoal_ClearBlackboardVariable) == 0x000008, "Wrong size on HWAIGoal_ClearBlackboardVariable");
static_assert(offsetof(HWAIGoal_ClearBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_ClearBlackboardVariable::VarName' has a wrong offset!");

// Function Hemingway.HWAIGoal.CollectDebugText
// 0x0018 (0x0018 - 0x0000)
struct HWAIGoal_CollectDebugText final
{
public:
	class FString                                 outDebugText;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TabsCount;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIGoal_CollectDebugText) == 0x000008, "Wrong alignment on HWAIGoal_CollectDebugText");
static_assert(sizeof(HWAIGoal_CollectDebugText) == 0x000018, "Wrong size on HWAIGoal_CollectDebugText");
static_assert(offsetof(HWAIGoal_CollectDebugText, outDebugText) == 0x000000, "Member 'HWAIGoal_CollectDebugText::outDebugText' has a wrong offset!");
static_assert(offsetof(HWAIGoal_CollectDebugText, TabsCount) == 0x000010, "Member 'HWAIGoal_CollectDebugText::TabsCount' has a wrong offset!");

// Function Hemingway.HWAIGoal.EndGoal
// 0x0002 (0x0002 - 0x0000)
struct HWAIGoal_EndGoal final
{
public:
	EHWAIGoalStatus                               Status;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerCompletedDel;                              // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_EndGoal) == 0x000001, "Wrong alignment on HWAIGoal_EndGoal");
static_assert(sizeof(HWAIGoal_EndGoal) == 0x000002, "Wrong size on HWAIGoal_EndGoal");
static_assert(offsetof(HWAIGoal_EndGoal, Status) == 0x000000, "Member 'HWAIGoal_EndGoal::Status' has a wrong offset!");
static_assert(offsetof(HWAIGoal_EndGoal, bTriggerCompletedDel) == 0x000001, "Member 'HWAIGoal_EndGoal::bTriggerCompletedDel' has a wrong offset!");

// Function Hemingway.HWAIGoal.OnSubGoalCompleted
// 0x0001 (0x0001 - 0x0000)
struct HWAIGoal_OnSubGoalCompleted final
{
public:
	EHWAIGoalStatus                               Status;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_OnSubGoalCompleted) == 0x000001, "Wrong alignment on HWAIGoal_OnSubGoalCompleted");
static_assert(sizeof(HWAIGoal_OnSubGoalCompleted) == 0x000001, "Wrong size on HWAIGoal_OnSubGoalCompleted");
static_assert(offsetof(HWAIGoal_OnSubGoalCompleted, Status) == 0x000000, "Member 'HWAIGoal_OnSubGoalCompleted::Status' has a wrong offset!");

// Function Hemingway.HWAIGoal.SetActorBlackboardVariable
// 0x0010 (0x0010 - 0x0000)
struct HWAIGoal_SetActorBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InValue;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_SetActorBlackboardVariable) == 0x000008, "Wrong alignment on HWAIGoal_SetActorBlackboardVariable");
static_assert(sizeof(HWAIGoal_SetActorBlackboardVariable) == 0x000010, "Wrong size on HWAIGoal_SetActorBlackboardVariable");
static_assert(offsetof(HWAIGoal_SetActorBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_SetActorBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_SetActorBlackboardVariable, InValue) == 0x000008, "Member 'HWAIGoal_SetActorBlackboardVariable::InValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.SetBoolBlackboardVariable
// 0x000C (0x000C - 0x0000)
struct HWAIGoal_SetBoolBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InValue;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIGoal_SetBoolBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_SetBoolBlackboardVariable");
static_assert(sizeof(HWAIGoal_SetBoolBlackboardVariable) == 0x00000C, "Wrong size on HWAIGoal_SetBoolBlackboardVariable");
static_assert(offsetof(HWAIGoal_SetBoolBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_SetBoolBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_SetBoolBlackboardVariable, InValue) == 0x000008, "Member 'HWAIGoal_SetBoolBlackboardVariable::InValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.SetEnumBlackboardVariable
// 0x000C (0x000C - 0x0000)
struct HWAIGoal_SetEnumBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InValue;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIGoal_SetEnumBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_SetEnumBlackboardVariable");
static_assert(sizeof(HWAIGoal_SetEnumBlackboardVariable) == 0x00000C, "Wrong size on HWAIGoal_SetEnumBlackboardVariable");
static_assert(offsetof(HWAIGoal_SetEnumBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_SetEnumBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_SetEnumBlackboardVariable, InValue) == 0x000008, "Member 'HWAIGoal_SetEnumBlackboardVariable::InValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.SetFloatBlackboardVariable
// 0x000C (0x000C - 0x0000)
struct HWAIGoal_SetFloatBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_SetFloatBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_SetFloatBlackboardVariable");
static_assert(sizeof(HWAIGoal_SetFloatBlackboardVariable) == 0x00000C, "Wrong size on HWAIGoal_SetFloatBlackboardVariable");
static_assert(offsetof(HWAIGoal_SetFloatBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_SetFloatBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_SetFloatBlackboardVariable, InValue) == 0x000008, "Member 'HWAIGoal_SetFloatBlackboardVariable::InValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.SetIntBlackboardVariable
// 0x000C (0x000C - 0x0000)
struct HWAIGoal_SetIntBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InValue;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_SetIntBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_SetIntBlackboardVariable");
static_assert(sizeof(HWAIGoal_SetIntBlackboardVariable) == 0x00000C, "Wrong size on HWAIGoal_SetIntBlackboardVariable");
static_assert(offsetof(HWAIGoal_SetIntBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_SetIntBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_SetIntBlackboardVariable, InValue) == 0x000008, "Member 'HWAIGoal_SetIntBlackboardVariable::InValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.SetNameBlackboardVariable
// 0x0010 (0x0010 - 0x0000)
struct HWAIGoal_SetNameBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InValue;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_SetNameBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_SetNameBlackboardVariable");
static_assert(sizeof(HWAIGoal_SetNameBlackboardVariable) == 0x000010, "Wrong size on HWAIGoal_SetNameBlackboardVariable");
static_assert(offsetof(HWAIGoal_SetNameBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_SetNameBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_SetNameBlackboardVariable, InValue) == 0x000008, "Member 'HWAIGoal_SetNameBlackboardVariable::InValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.SetVectorBlackboardVariable
// 0x0020 (0x0020 - 0x0000)
struct HWAIGoal_SetVectorBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InValue;                                           // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_SetVectorBlackboardVariable) == 0x000008, "Wrong alignment on HWAIGoal_SetVectorBlackboardVariable");
static_assert(sizeof(HWAIGoal_SetVectorBlackboardVariable) == 0x000020, "Wrong size on HWAIGoal_SetVectorBlackboardVariable");
static_assert(offsetof(HWAIGoal_SetVectorBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_SetVectorBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_SetVectorBlackboardVariable, InValue) == 0x000008, "Member 'HWAIGoal_SetVectorBlackboardVariable::InValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.SpawnDebugDisplayActor
// 0x0010 (0x0010 - 0x0000)
struct HWAIGoal_SpawnDebugDisplayActor final
{
public:
	class UClass*                                 debugActorClass;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_SpawnDebugDisplayActor) == 0x000008, "Wrong alignment on HWAIGoal_SpawnDebugDisplayActor");
static_assert(sizeof(HWAIGoal_SpawnDebugDisplayActor) == 0x000010, "Wrong size on HWAIGoal_SpawnDebugDisplayActor");
static_assert(offsetof(HWAIGoal_SpawnDebugDisplayActor, debugActorClass) == 0x000000, "Member 'HWAIGoal_SpawnDebugDisplayActor::debugActorClass' has a wrong offset!");
static_assert(offsetof(HWAIGoal_SpawnDebugDisplayActor, ReturnValue) == 0x000008, "Member 'HWAIGoal_SpawnDebugDisplayActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.ToggleDebugDisplay
// 0x0001 (0x0001 - 0x0000)
struct HWAIGoal_ToggleDebugDisplay final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_ToggleDebugDisplay) == 0x000001, "Wrong alignment on HWAIGoal_ToggleDebugDisplay");
static_assert(sizeof(HWAIGoal_ToggleDebugDisplay) == 0x000001, "Wrong size on HWAIGoal_ToggleDebugDisplay");
static_assert(offsetof(HWAIGoal_ToggleDebugDisplay, bOn) == 0x000000, "Member 'HWAIGoal_ToggleDebugDisplay::bOn' has a wrong offset!");

// Function Hemingway.HWAIGoal.CalculateMaxETAForPlayParticipants
// 0x0010 (0x0010 - 0x0000)
struct HWAIGoal_CalculateMaxETAForPlayParticipants final
{
public:
	const class AHWAIController*                  InController;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrivalDistance;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_CalculateMaxETAForPlayParticipants) == 0x000008, "Wrong alignment on HWAIGoal_CalculateMaxETAForPlayParticipants");
static_assert(sizeof(HWAIGoal_CalculateMaxETAForPlayParticipants) == 0x000010, "Wrong size on HWAIGoal_CalculateMaxETAForPlayParticipants");
static_assert(offsetof(HWAIGoal_CalculateMaxETAForPlayParticipants, InController) == 0x000000, "Member 'HWAIGoal_CalculateMaxETAForPlayParticipants::InController' has a wrong offset!");
static_assert(offsetof(HWAIGoal_CalculateMaxETAForPlayParticipants, ArrivalDistance) == 0x000008, "Member 'HWAIGoal_CalculateMaxETAForPlayParticipants::ArrivalDistance' has a wrong offset!");
static_assert(offsetof(HWAIGoal_CalculateMaxETAForPlayParticipants, ReturnValue) == 0x00000C, "Member 'HWAIGoal_CalculateMaxETAForPlayParticipants::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetActorBlackboardVariable
// 0x0010 (0x0010 - 0x0000)
struct HWAIGoal_GetActorBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetActorBlackboardVariable) == 0x000008, "Wrong alignment on HWAIGoal_GetActorBlackboardVariable");
static_assert(sizeof(HWAIGoal_GetActorBlackboardVariable) == 0x000010, "Wrong size on HWAIGoal_GetActorBlackboardVariable");
static_assert(offsetof(HWAIGoal_GetActorBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_GetActorBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_GetActorBlackboardVariable, ReturnValue) == 0x000008, "Member 'HWAIGoal_GetActorBlackboardVariable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetBoolBlackboardVariable
// 0x000C (0x000C - 0x0000)
struct HWAIGoal_GetBoolBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIGoal_GetBoolBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_GetBoolBlackboardVariable");
static_assert(sizeof(HWAIGoal_GetBoolBlackboardVariable) == 0x00000C, "Wrong size on HWAIGoal_GetBoolBlackboardVariable");
static_assert(offsetof(HWAIGoal_GetBoolBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_GetBoolBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_GetBoolBlackboardVariable, ReturnValue) == 0x000008, "Member 'HWAIGoal_GetBoolBlackboardVariable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetCharacter
// 0x0008 (0x0008 - 0x0000)
struct HWAIGoal_GetCharacter final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetCharacter) == 0x000008, "Wrong alignment on HWAIGoal_GetCharacter");
static_assert(sizeof(HWAIGoal_GetCharacter) == 0x000008, "Wrong size on HWAIGoal_GetCharacter");
static_assert(offsetof(HWAIGoal_GetCharacter, ReturnValue) == 0x000000, "Member 'HWAIGoal_GetCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetCurrentFrameTime
// 0x0004 (0x0004 - 0x0000)
struct HWAIGoal_GetCurrentFrameTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetCurrentFrameTime) == 0x000004, "Wrong alignment on HWAIGoal_GetCurrentFrameTime");
static_assert(sizeof(HWAIGoal_GetCurrentFrameTime) == 0x000004, "Wrong size on HWAIGoal_GetCurrentFrameTime");
static_assert(offsetof(HWAIGoal_GetCurrentFrameTime, ReturnValue) == 0x000000, "Member 'HWAIGoal_GetCurrentFrameTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetCurrentPlayStateTag
// 0x0010 (0x0010 - 0x0000)
struct HWAIGoal_GetCurrentPlayStateTag final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetCurrentPlayStateTag) == 0x000008, "Wrong alignment on HWAIGoal_GetCurrentPlayStateTag");
static_assert(sizeof(HWAIGoal_GetCurrentPlayStateTag) == 0x000010, "Wrong size on HWAIGoal_GetCurrentPlayStateTag");
static_assert(offsetof(HWAIGoal_GetCurrentPlayStateTag, SourceCharacter) == 0x000000, "Member 'HWAIGoal_GetCurrentPlayStateTag::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIGoal_GetCurrentPlayStateTag, ReturnValue) == 0x000008, "Member 'HWAIGoal_GetCurrentPlayStateTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetEnumBlackboardVariable
// 0x000C (0x000C - 0x0000)
struct HWAIGoal_GetEnumBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIGoal_GetEnumBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_GetEnumBlackboardVariable");
static_assert(sizeof(HWAIGoal_GetEnumBlackboardVariable) == 0x00000C, "Wrong size on HWAIGoal_GetEnumBlackboardVariable");
static_assert(offsetof(HWAIGoal_GetEnumBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_GetEnumBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_GetEnumBlackboardVariable, ReturnValue) == 0x000008, "Member 'HWAIGoal_GetEnumBlackboardVariable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetFloatBlackboardVariable
// 0x000C (0x000C - 0x0000)
struct HWAIGoal_GetFloatBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetFloatBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_GetFloatBlackboardVariable");
static_assert(sizeof(HWAIGoal_GetFloatBlackboardVariable) == 0x00000C, "Wrong size on HWAIGoal_GetFloatBlackboardVariable");
static_assert(offsetof(HWAIGoal_GetFloatBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_GetFloatBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_GetFloatBlackboardVariable, ReturnValue) == 0x000008, "Member 'HWAIGoal_GetFloatBlackboardVariable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetGameMode
// 0x0008 (0x0008 - 0x0000)
struct HWAIGoal_GetGameMode final
{
public:
	class AHWGameMode*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetGameMode) == 0x000008, "Wrong alignment on HWAIGoal_GetGameMode");
static_assert(sizeof(HWAIGoal_GetGameMode) == 0x000008, "Wrong size on HWAIGoal_GetGameMode");
static_assert(offsetof(HWAIGoal_GetGameMode, ReturnValue) == 0x000000, "Member 'HWAIGoal_GetGameMode::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetGameState
// 0x0008 (0x0008 - 0x0000)
struct HWAIGoal_GetGameState final
{
public:
	class AHWGameState*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetGameState) == 0x000008, "Wrong alignment on HWAIGoal_GetGameState");
static_assert(sizeof(HWAIGoal_GetGameState) == 0x000008, "Wrong size on HWAIGoal_GetGameState");
static_assert(offsetof(HWAIGoal_GetGameState, ReturnValue) == 0x000000, "Member 'HWAIGoal_GetGameState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetIntBlackboardVariable
// 0x000C (0x000C - 0x0000)
struct HWAIGoal_GetIntBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetIntBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_GetIntBlackboardVariable");
static_assert(sizeof(HWAIGoal_GetIntBlackboardVariable) == 0x00000C, "Wrong size on HWAIGoal_GetIntBlackboardVariable");
static_assert(offsetof(HWAIGoal_GetIntBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_GetIntBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_GetIntBlackboardVariable, ReturnValue) == 0x000008, "Member 'HWAIGoal_GetIntBlackboardVariable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetNameBlackboardVariable
// 0x0010 (0x0010 - 0x0000)
struct HWAIGoal_GetNameBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetNameBlackboardVariable) == 0x000004, "Wrong alignment on HWAIGoal_GetNameBlackboardVariable");
static_assert(sizeof(HWAIGoal_GetNameBlackboardVariable) == 0x000010, "Wrong size on HWAIGoal_GetNameBlackboardVariable");
static_assert(offsetof(HWAIGoal_GetNameBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_GetNameBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_GetNameBlackboardVariable, ReturnValue) == 0x000008, "Member 'HWAIGoal_GetNameBlackboardVariable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetPlayerState
// 0x0008 (0x0008 - 0x0000)
struct HWAIGoal_GetPlayerState final
{
public:
	class AHWPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetPlayerState) == 0x000008, "Wrong alignment on HWAIGoal_GetPlayerState");
static_assert(sizeof(HWAIGoal_GetPlayerState) == 0x000008, "Wrong size on HWAIGoal_GetPlayerState");
static_assert(offsetof(HWAIGoal_GetPlayerState, ReturnValue) == 0x000000, "Member 'HWAIGoal_GetPlayerState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetPlayParticipants
// 0x0010 (0x0010 - 0x0000)
struct HWAIGoal_GetPlayParticipants final
{
public:
	TArray<class AHWCharacter_Base*>              OutParticipants;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetPlayParticipants) == 0x000008, "Wrong alignment on HWAIGoal_GetPlayParticipants");
static_assert(sizeof(HWAIGoal_GetPlayParticipants) == 0x000010, "Wrong size on HWAIGoal_GetPlayParticipants");
static_assert(offsetof(HWAIGoal_GetPlayParticipants, OutParticipants) == 0x000000, "Member 'HWAIGoal_GetPlayParticipants::OutParticipants' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetTimeInGoal
// 0x0004 (0x0004 - 0x0000)
struct HWAIGoal_GetTimeInGoal final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetTimeInGoal) == 0x000004, "Wrong alignment on HWAIGoal_GetTimeInGoal");
static_assert(sizeof(HWAIGoal_GetTimeInGoal) == 0x000004, "Wrong size on HWAIGoal_GetTimeInGoal");
static_assert(offsetof(HWAIGoal_GetTimeInGoal, ReturnValue) == 0x000000, "Member 'HWAIGoal_GetTimeInGoal::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetTimeInPlay
// 0x0004 (0x0004 - 0x0000)
struct HWAIGoal_GetTimeInPlay final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetTimeInPlay) == 0x000004, "Wrong alignment on HWAIGoal_GetTimeInPlay");
static_assert(sizeof(HWAIGoal_GetTimeInPlay) == 0x000004, "Wrong size on HWAIGoal_GetTimeInPlay");
static_assert(offsetof(HWAIGoal_GetTimeInPlay, ReturnValue) == 0x000000, "Member 'HWAIGoal_GetTimeInPlay::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.GetVectorBlackboardVariable
// 0x0020 (0x0020 - 0x0000)
struct HWAIGoal_GetVectorBlackboardVariable final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_GetVectorBlackboardVariable) == 0x000008, "Wrong alignment on HWAIGoal_GetVectorBlackboardVariable");
static_assert(sizeof(HWAIGoal_GetVectorBlackboardVariable) == 0x000020, "Wrong size on HWAIGoal_GetVectorBlackboardVariable");
static_assert(offsetof(HWAIGoal_GetVectorBlackboardVariable, VarName) == 0x000000, "Member 'HWAIGoal_GetVectorBlackboardVariable::VarName' has a wrong offset!");
static_assert(offsetof(HWAIGoal_GetVectorBlackboardVariable, ReturnValue) == 0x000008, "Member 'HWAIGoal_GetVectorBlackboardVariable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.IsCloseEnoughToPlayActor
// 0x0018 (0x0018 - 0x0000)
struct HWAIGoal_IsCloseEnoughToPlayActor final
{
public:
	const class AHWAIController*                  InController;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWCharacter_Base*                Character;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrivalDistance;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIGoal_IsCloseEnoughToPlayActor) == 0x000008, "Wrong alignment on HWAIGoal_IsCloseEnoughToPlayActor");
static_assert(sizeof(HWAIGoal_IsCloseEnoughToPlayActor) == 0x000018, "Wrong size on HWAIGoal_IsCloseEnoughToPlayActor");
static_assert(offsetof(HWAIGoal_IsCloseEnoughToPlayActor, InController) == 0x000000, "Member 'HWAIGoal_IsCloseEnoughToPlayActor::InController' has a wrong offset!");
static_assert(offsetof(HWAIGoal_IsCloseEnoughToPlayActor, Character) == 0x000008, "Member 'HWAIGoal_IsCloseEnoughToPlayActor::Character' has a wrong offset!");
static_assert(offsetof(HWAIGoal_IsCloseEnoughToPlayActor, ArrivalDistance) == 0x000010, "Member 'HWAIGoal_IsCloseEnoughToPlayActor::ArrivalDistance' has a wrong offset!");
static_assert(offsetof(HWAIGoal_IsCloseEnoughToPlayActor, ReturnValue) == 0x000014, "Member 'HWAIGoal_IsCloseEnoughToPlayActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.IsCurrentPlayStateEqualTo
// 0x0018 (0x0018 - 0x0000)
struct HWAIGoal_IsCurrentPlayStateEqualTo final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIGoal_IsCurrentPlayStateEqualTo) == 0x000008, "Wrong alignment on HWAIGoal_IsCurrentPlayStateEqualTo");
static_assert(sizeof(HWAIGoal_IsCurrentPlayStateEqualTo) == 0x000018, "Wrong size on HWAIGoal_IsCurrentPlayStateEqualTo");
static_assert(offsetof(HWAIGoal_IsCurrentPlayStateEqualTo, SourceCharacter) == 0x000000, "Member 'HWAIGoal_IsCurrentPlayStateEqualTo::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWAIGoal_IsCurrentPlayStateEqualTo, Tag) == 0x000008, "Member 'HWAIGoal_IsCurrentPlayStateEqualTo::Tag' has a wrong offset!");
static_assert(offsetof(HWAIGoal_IsCurrentPlayStateEqualTo, ReturnValue) == 0x000010, "Member 'HWAIGoal_IsCurrentPlayStateEqualTo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIGoal.IsInProgress
// 0x0001 (0x0001 - 0x0000)
struct HWAIGoal_IsInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIGoal_IsInProgress) == 0x000001, "Wrong alignment on HWAIGoal_IsInProgress");
static_assert(sizeof(HWAIGoal_IsInProgress) == 0x000001, "Wrong size on HWAIGoal_IsInProgress");
static_assert(offsetof(HWAIGoal_IsInProgress, ReturnValue) == 0x000000, "Member 'HWAIGoal_IsInProgress::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAILearningRecorder.GetAgentSamples
// 0x0010 (0x0010 - 0x0000)
struct HWAILearningRecorder_GetAgentSamples final
{
public:
	TArray<struct FHWAILearningAgentData>         OutAllSamples;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAILearningRecorder_GetAgentSamples) == 0x000008, "Wrong alignment on HWAILearningRecorder_GetAgentSamples");
static_assert(sizeof(HWAILearningRecorder_GetAgentSamples) == 0x000010, "Wrong size on HWAILearningRecorder_GetAgentSamples");
static_assert(offsetof(HWAILearningRecorder_GetAgentSamples, OutAllSamples) == 0x000000, "Member 'HWAILearningRecorder_GetAgentSamples::OutAllSamples' has a wrong offset!");

// Function Hemingway.HWAILearningRecorder.GetSamples
// 0x0010 (0x0010 - 0x0000)
struct HWAILearningRecorder_GetSamples final
{
public:
	TArray<struct FHWAILearningSampleData>        OutAllSamples;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAILearningRecorder_GetSamples) == 0x000008, "Wrong alignment on HWAILearningRecorder_GetSamples");
static_assert(sizeof(HWAILearningRecorder_GetSamples) == 0x000010, "Wrong size on HWAILearningRecorder_GetSamples");
static_assert(offsetof(HWAILearningRecorder_GetSamples, OutAllSamples) == 0x000000, "Member 'HWAILearningRecorder_GetSamples::OutAllSamples' has a wrong offset!");

// Function Hemingway.HWAILearningRecorderBlueprintLibrary.LoadAILearningRecordingFromJson
// 0x0020 (0x0020 - 0x0000)
struct HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromJson final
{
public:
	class FString                                 LearningDataFileName;                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWAILearningAgentData>         OutAllSamples;                                     // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromJson) == 0x000008, "Wrong alignment on HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromJson");
static_assert(sizeof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromJson) == 0x000020, "Wrong size on HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromJson");
static_assert(offsetof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromJson, LearningDataFileName) == 0x000000, "Member 'HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromJson::LearningDataFileName' has a wrong offset!");
static_assert(offsetof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromJson, OutAllSamples) == 0x000010, "Member 'HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromJson::OutAllSamples' has a wrong offset!");

// Function Hemingway.HWAILearningRecorderBlueprintLibrary.LoadAILearningRecordingFromSlot
// 0x0028 (0x0028 - 0x0000)
struct HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot final
{
public:
	class FString                                 SaveSlotName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWAILearningAgentData>         OutAllSamples;                                     // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot) == 0x000008, "Wrong alignment on HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot");
static_assert(sizeof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot) == 0x000028, "Wrong size on HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot");
static_assert(offsetof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot, SaveSlotName) == 0x000000, "Member 'HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot::SaveSlotName' has a wrong offset!");
static_assert(offsetof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot, UserIndex) == 0x000010, "Member 'HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot::UserIndex' has a wrong offset!");
static_assert(offsetof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot, OutAllSamples) == 0x000018, "Member 'HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlot::OutAllSamples' has a wrong offset!");

// Function Hemingway.HWAILearningRecorderBlueprintLibrary.LoadAILearningRecordingFromSlotWithTimeStamps
// 0x0028 (0x0028 - 0x0000)
struct HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps final
{
public:
	class FString                                 SaveSlotName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWAILearningSampleData>        OutAllSamples;                                     // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps) == 0x000008, "Wrong alignment on HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps");
static_assert(sizeof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps) == 0x000028, "Wrong size on HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps");
static_assert(offsetof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps, SaveSlotName) == 0x000000, "Member 'HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps::SaveSlotName' has a wrong offset!");
static_assert(offsetof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps, UserIndex) == 0x000010, "Member 'HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps::UserIndex' has a wrong offset!");
static_assert(offsetof(HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps, OutAllSamples) == 0x000018, "Member 'HWAILearningRecorderBlueprintLibrary_LoadAILearningRecordingFromSlotWithTimeStamps::OutAllSamples' has a wrong offset!");

// Function Hemingway.HWEventHandlerBase.OnEventEnd
// 0x0048 (0x0048 - 0x0000)
struct HWEventHandlerBase_OnEventEnd final
{
public:
	struct FHWEventConfig                         EventConfig;                                       // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEventHandlerBase_OnEventEnd) == 0x000008, "Wrong alignment on HWEventHandlerBase_OnEventEnd");
static_assert(sizeof(HWEventHandlerBase_OnEventEnd) == 0x000048, "Wrong size on HWEventHandlerBase_OnEventEnd");
static_assert(offsetof(HWEventHandlerBase_OnEventEnd, EventConfig) == 0x000000, "Member 'HWEventHandlerBase_OnEventEnd::EventConfig' has a wrong offset!");

// Function Hemingway.HWEventHandlerBase.OnEventStart
// 0x00D0 (0x00D0 - 0x0000)
struct HWEventHandlerBase_OnEventStart final
{
public:
	struct FHWEventConfig                         EventConfig;                                       // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWEventContext                        EventContext;                                      // 0x0048(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEventHandlerBase_OnEventStart) == 0x000008, "Wrong alignment on HWEventHandlerBase_OnEventStart");
static_assert(sizeof(HWEventHandlerBase_OnEventStart) == 0x0000D0, "Wrong size on HWEventHandlerBase_OnEventStart");
static_assert(offsetof(HWEventHandlerBase_OnEventStart, EventConfig) == 0x000000, "Member 'HWEventHandlerBase_OnEventStart::EventConfig' has a wrong offset!");
static_assert(offsetof(HWEventHandlerBase_OnEventStart, EventContext) == 0x000048, "Member 'HWEventHandlerBase_OnEventStart::EventContext' has a wrong offset!");

// Function Hemingway.HWEventHandlerBase.ShouldOverrideDuration
// 0x00D8 (0x00D8 - 0x0000)
struct HWEventHandlerBase_ShouldOverrideDuration final
{
public:
	struct FHWEventConfig                         EventConfig;                                       // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWEventContext                        EventContext;                                      // 0x0048(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         OutDuration;                                       // 0x00D0(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00D4(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEventHandlerBase_ShouldOverrideDuration) == 0x000008, "Wrong alignment on HWEventHandlerBase_ShouldOverrideDuration");
static_assert(sizeof(HWEventHandlerBase_ShouldOverrideDuration) == 0x0000D8, "Wrong size on HWEventHandlerBase_ShouldOverrideDuration");
static_assert(offsetof(HWEventHandlerBase_ShouldOverrideDuration, EventConfig) == 0x000000, "Member 'HWEventHandlerBase_ShouldOverrideDuration::EventConfig' has a wrong offset!");
static_assert(offsetof(HWEventHandlerBase_ShouldOverrideDuration, EventContext) == 0x000048, "Member 'HWEventHandlerBase_ShouldOverrideDuration::EventContext' has a wrong offset!");
static_assert(offsetof(HWEventHandlerBase_ShouldOverrideDuration, OutDuration) == 0x0000D0, "Member 'HWEventHandlerBase_ShouldOverrideDuration::OutDuration' has a wrong offset!");
static_assert(offsetof(HWEventHandlerBase_ShouldOverrideDuration, ReturnValue) == 0x0000D4, "Member 'HWEventHandlerBase_ShouldOverrideDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPerceptionComponent.GetIdTag
// 0x0008 (0x0008 - 0x0000)
struct HWAIPerceptionComponent_GetIdTag final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPerceptionComponent_GetIdTag) == 0x000004, "Wrong alignment on HWAIPerceptionComponent_GetIdTag");
static_assert(sizeof(HWAIPerceptionComponent_GetIdTag) == 0x000008, "Wrong size on HWAIPerceptionComponent_GetIdTag");
static_assert(offsetof(HWAIPerceptionComponent_GetIdTag, ReturnValue) == 0x000000, "Member 'HWAIPerceptionComponent_GetIdTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Actor.BP_OnGameplayEventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct HWGameplayCueNotify_Actor_BP_OnGameplayEventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0008(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Actor_BP_OnGameplayEventReceived) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Actor_BP_OnGameplayEventReceived");
static_assert(sizeof(HWGameplayCueNotify_Actor_BP_OnGameplayEventReceived) == 0x0000B8, "Wrong size on HWGameplayCueNotify_Actor_BP_OnGameplayEventReceived");
static_assert(offsetof(HWGameplayCueNotify_Actor_BP_OnGameplayEventReceived, EventTag) == 0x000000, "Member 'HWGameplayCueNotify_Actor_BP_OnGameplayEventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(HWGameplayCueNotify_Actor_BP_OnGameplayEventReceived, Payload) == 0x000008, "Member 'HWGameplayCueNotify_Actor_BP_OnGameplayEventReceived::Payload' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Actor.HandleLocalOwnerVisibilityComponentUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityComponentUpdated final
{
public:
	class UHWVisibilityComponent*                 VisibilityComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityComponentUpdated) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityComponentUpdated");
static_assert(sizeof(HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityComponentUpdated) == 0x000008, "Wrong size on HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityComponentUpdated");
static_assert(offsetof(HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityComponentUpdated, VisibilityComponent) == 0x000000, "Member 'HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityComponentUpdated::VisibilityComponent' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Actor.HandleLocalOwnerVisibilityUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityUpdated final
{
public:
	class UHWVisibilityComponent*                 VisibilityComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityUpdated) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityUpdated");
static_assert(sizeof(HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityUpdated) == 0x000008, "Wrong size on HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityUpdated");
static_assert(offsetof(HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityUpdated, VisibilityComponent) == 0x000000, "Member 'HWGameplayCueNotify_Actor_HandleLocalOwnerVisibilityUpdated::VisibilityComponent' has a wrong offset!");

// Function Hemingway.HWGameplayEffect.BP_GetStackLimitCount
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayEffect_BP_GetStackLimitCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_BP_GetStackLimitCount) == 0x000004, "Wrong alignment on HWGameplayEffect_BP_GetStackLimitCount");
static_assert(sizeof(HWGameplayEffect_BP_GetStackLimitCount) == 0x000004, "Wrong size on HWGameplayEffect_BP_GetStackLimitCount");
static_assert(offsetof(HWGameplayEffect_BP_GetStackLimitCount, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_BP_GetStackLimitCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect.GetApplicationPolicy
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_GetApplicationPolicy final
{
public:
	EHWEffectApplicationPolicy                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_GetApplicationPolicy) == 0x000001, "Wrong alignment on HWGameplayEffect_GetApplicationPolicy");
static_assert(sizeof(HWGameplayEffect_GetApplicationPolicy) == 0x000001, "Wrong size on HWGameplayEffect_GetApplicationPolicy");
static_assert(offsetof(HWGameplayEffect_GetApplicationPolicy, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_GetApplicationPolicy::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect.GetApplicationStrength
// 0x02B0 (0x02B0 - 0x0000)
struct HWGameplayEffect_GetApplicationStrength final
{
public:
	struct FGameplayEffectSpec                    RelevantSpec;                                      // 0x0000(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x02A8(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayEffect_GetApplicationStrength) == 0x000008, "Wrong alignment on HWGameplayEffect_GetApplicationStrength");
static_assert(sizeof(HWGameplayEffect_GetApplicationStrength) == 0x0002B0, "Wrong size on HWGameplayEffect_GetApplicationStrength");
static_assert(offsetof(HWGameplayEffect_GetApplicationStrength, RelevantSpec) == 0x000000, "Member 'HWGameplayEffect_GetApplicationStrength::RelevantSpec' has a wrong offset!");
static_assert(offsetof(HWGameplayEffect_GetApplicationStrength, ReturnValue) == 0x0002A8, "Member 'HWGameplayEffect_GetApplicationStrength::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect.GetApplicationTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayEffect_GetApplicationTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_GetApplicationTag) == 0x000004, "Wrong alignment on HWGameplayEffect_GetApplicationTag");
static_assert(sizeof(HWGameplayEffect_GetApplicationTag) == 0x000008, "Wrong size on HWGameplayEffect_GetApplicationTag");
static_assert(offsetof(HWGameplayEffect_GetApplicationTag, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_GetApplicationTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect.GetKeywordTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayEffect_GetKeywordTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_GetKeywordTag) == 0x000004, "Wrong alignment on HWGameplayEffect_GetKeywordTag");
static_assert(sizeof(HWGameplayEffect_GetKeywordTag) == 0x000008, "Wrong size on HWGameplayEffect_GetKeywordTag");
static_assert(offsetof(HWGameplayEffect_GetKeywordTag, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_GetKeywordTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect.ShouldOnlyInhibitSameInstigatorEffects
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_ShouldOnlyInhibitSameInstigatorEffects final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_ShouldOnlyInhibitSameInstigatorEffects) == 0x000001, "Wrong alignment on HWGameplayEffect_ShouldOnlyInhibitSameInstigatorEffects");
static_assert(sizeof(HWGameplayEffect_ShouldOnlyInhibitSameInstigatorEffects) == 0x000001, "Wrong size on HWGameplayEffect_ShouldOnlyInhibitSameInstigatorEffects");
static_assert(offsetof(HWGameplayEffect_ShouldOnlyInhibitSameInstigatorEffects, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_ShouldOnlyInhibitSameInstigatorEffects::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPlayLogic.GetAssociatedActor
// 0x0008 (0x0008 - 0x0000)
struct HWAIPlayLogic_GetAssociatedActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayLogic_GetAssociatedActor) == 0x000008, "Wrong alignment on HWAIPlayLogic_GetAssociatedActor");
static_assert(sizeof(HWAIPlayLogic_GetAssociatedActor) == 0x000008, "Wrong size on HWAIPlayLogic_GetAssociatedActor");
static_assert(offsetof(HWAIPlayLogic_GetAssociatedActor, ReturnValue) == 0x000000, "Member 'HWAIPlayLogic_GetAssociatedActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPlayLogic.GetCurrentPlayState
// 0x0008 (0x0008 - 0x0000)
struct HWAIPlayLogic_GetCurrentPlayState final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayLogic_GetCurrentPlayState) == 0x000004, "Wrong alignment on HWAIPlayLogic_GetCurrentPlayState");
static_assert(sizeof(HWAIPlayLogic_GetCurrentPlayState) == 0x000008, "Wrong size on HWAIPlayLogic_GetCurrentPlayState");
static_assert(offsetof(HWAIPlayLogic_GetCurrentPlayState, ReturnValue) == 0x000000, "Member 'HWAIPlayLogic_GetCurrentPlayState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPlayLogic.GetHandle
// 0x0010 (0x0010 - 0x0000)
struct HWAIPlayLogic_GetHandle final
{
public:
	struct FDataTableRowHandle                    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayLogic_GetHandle) == 0x000008, "Wrong alignment on HWAIPlayLogic_GetHandle");
static_assert(sizeof(HWAIPlayLogic_GetHandle) == 0x000010, "Wrong size on HWAIPlayLogic_GetHandle");
static_assert(offsetof(HWAIPlayLogic_GetHandle, ReturnValue) == 0x000000, "Member 'HWAIPlayLogic_GetHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPlayLogic.GetMinExecutionTime
// 0x0004 (0x0004 - 0x0000)
struct HWAIPlayLogic_GetMinExecutionTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayLogic_GetMinExecutionTime) == 0x000004, "Wrong alignment on HWAIPlayLogic_GetMinExecutionTime");
static_assert(sizeof(HWAIPlayLogic_GetMinExecutionTime) == 0x000004, "Wrong size on HWAIPlayLogic_GetMinExecutionTime");
static_assert(offsetof(HWAIPlayLogic_GetMinExecutionTime, ReturnValue) == 0x000000, "Member 'HWAIPlayLogic_GetMinExecutionTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPlayLogic.GetParticipants
// 0x0010 (0x0010 - 0x0000)
struct HWAIPlayLogic_GetParticipants final
{
public:
	TArray<class AHWCharacter_Base*>              OutParticipants;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayLogic_GetParticipants) == 0x000008, "Wrong alignment on HWAIPlayLogic_GetParticipants");
static_assert(sizeof(HWAIPlayLogic_GetParticipants) == 0x000010, "Wrong size on HWAIPlayLogic_GetParticipants");
static_assert(offsetof(HWAIPlayLogic_GetParticipants, OutParticipants) == 0x000000, "Member 'HWAIPlayLogic_GetParticipants::OutParticipants' has a wrong offset!");

// Function Hemingway.HWAIPlayLogic.GetPlayTime
// 0x0004 (0x0004 - 0x0000)
struct HWAIPlayLogic_GetPlayTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayLogic_GetPlayTime) == 0x000004, "Wrong alignment on HWAIPlayLogic_GetPlayTime");
static_assert(sizeof(HWAIPlayLogic_GetPlayTime) == 0x000004, "Wrong size on HWAIPlayLogic_GetPlayTime");
static_assert(offsetof(HWAIPlayLogic_GetPlayTime, ReturnValue) == 0x000000, "Member 'HWAIPlayLogic_GetPlayTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPlayLogic.HasParticipantsActive
// 0x0001 (0x0001 - 0x0000)
struct HWAIPlayLogic_HasParticipantsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayLogic_HasParticipantsActive) == 0x000001, "Wrong alignment on HWAIPlayLogic_HasParticipantsActive");
static_assert(sizeof(HWAIPlayLogic_HasParticipantsActive) == 0x000001, "Wrong size on HWAIPlayLogic_HasParticipantsActive");
static_assert(offsetof(HWAIPlayLogic_HasParticipantsActive, ReturnValue) == 0x000000, "Member 'HWAIPlayLogic_HasParticipantsActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.AddNPEBoostsToPlayer
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_AddNPEBoostsToPlayer final
{
public:
	class AHWPlayerController*                    TrackedPlayerController;                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_AddNPEBoostsToPlayer) == 0x000008, "Wrong alignment on HWGameMode_AddNPEBoostsToPlayer");
static_assert(sizeof(HWGameMode_AddNPEBoostsToPlayer) == 0x000008, "Wrong size on HWGameMode_AddNPEBoostsToPlayer");
static_assert(offsetof(HWGameMode_AddNPEBoostsToPlayer, TrackedPlayerController) == 0x000000, "Member 'HWGameMode_AddNPEBoostsToPlayer::TrackedPlayerController' has a wrong offset!");

// Function Hemingway.HWGameMode.AddPhaseRulesToNewTeamMember
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_AddPhaseRulesToNewTeamMember final
{
public:
	class AHWPlayerState*                         NewMember;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_AddPhaseRulesToNewTeamMember) == 0x000008, "Wrong alignment on HWGameMode_AddPhaseRulesToNewTeamMember");
static_assert(sizeof(HWGameMode_AddPhaseRulesToNewTeamMember) == 0x000008, "Wrong size on HWGameMode_AddPhaseRulesToNewTeamMember");
static_assert(offsetof(HWGameMode_AddPhaseRulesToNewTeamMember, NewMember) == 0x000000, "Member 'HWGameMode_AddPhaseRulesToNewTeamMember::NewMember' has a wrong offset!");

// Function Hemingway.HWGameMode.ApplyGameModeModifiersToPlayer
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_ApplyGameModeModifiersToPlayer final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_ApplyGameModeModifiersToPlayer) == 0x000008, "Wrong alignment on HWGameMode_ApplyGameModeModifiersToPlayer");
static_assert(sizeof(HWGameMode_ApplyGameModeModifiersToPlayer) == 0x000008, "Wrong size on HWGameMode_ApplyGameModeModifiersToPlayer");
static_assert(offsetof(HWGameMode_ApplyGameModeModifiersToPlayer, PlayerState) == 0x000000, "Member 'HWGameMode_ApplyGameModeModifiersToPlayer::PlayerState' has a wrong offset!");

// Function Hemingway.HWGameMode.CombatLogRewards
// 0x0020 (0x0020 - 0x0000)
struct HWGameMode_CombatLogRewards final
{
public:
	class AHWCharacter_Base*                      RewardSource;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      RewardTarget;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EventType;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Quantity;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RewardType;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameMode_CombatLogRewards) == 0x000008, "Wrong alignment on HWGameMode_CombatLogRewards");
static_assert(sizeof(HWGameMode_CombatLogRewards) == 0x000020, "Wrong size on HWGameMode_CombatLogRewards");
static_assert(offsetof(HWGameMode_CombatLogRewards, RewardSource) == 0x000000, "Member 'HWGameMode_CombatLogRewards::RewardSource' has a wrong offset!");
static_assert(offsetof(HWGameMode_CombatLogRewards, RewardTarget) == 0x000008, "Member 'HWGameMode_CombatLogRewards::RewardTarget' has a wrong offset!");
static_assert(offsetof(HWGameMode_CombatLogRewards, EventType) == 0x000010, "Member 'HWGameMode_CombatLogRewards::EventType' has a wrong offset!");
static_assert(offsetof(HWGameMode_CombatLogRewards, Quantity) == 0x000014, "Member 'HWGameMode_CombatLogRewards::Quantity' has a wrong offset!");
static_assert(offsetof(HWGameMode_CombatLogRewards, RewardType) == 0x000018, "Member 'HWGameMode_CombatLogRewards::RewardType' has a wrong offset!");

// Function Hemingway.HWGameMode.DeactivatePhaseRulesFromOldTeamMember
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_DeactivatePhaseRulesFromOldTeamMember final
{
public:
	class AHWPlayerState*                         OldMember;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_DeactivatePhaseRulesFromOldTeamMember) == 0x000008, "Wrong alignment on HWGameMode_DeactivatePhaseRulesFromOldTeamMember");
static_assert(sizeof(HWGameMode_DeactivatePhaseRulesFromOldTeamMember) == 0x000008, "Wrong size on HWGameMode_DeactivatePhaseRulesFromOldTeamMember");
static_assert(offsetof(HWGameMode_DeactivatePhaseRulesFromOldTeamMember, OldMember) == 0x000000, "Member 'HWGameMode_DeactivatePhaseRulesFromOldTeamMember::OldMember' has a wrong offset!");

// Function Hemingway.HWGameMode.DoesPlayerMeetNPEBoostCriteria
// 0x0010 (0x0010 - 0x0000)
struct HWGameMode_DoesPlayerMeetNPEBoostCriteria final
{
public:
	class AHWPlayerController*                    TrackedPlayerController;                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameMode_DoesPlayerMeetNPEBoostCriteria) == 0x000008, "Wrong alignment on HWGameMode_DoesPlayerMeetNPEBoostCriteria");
static_assert(sizeof(HWGameMode_DoesPlayerMeetNPEBoostCriteria) == 0x000010, "Wrong size on HWGameMode_DoesPlayerMeetNPEBoostCriteria");
static_assert(offsetof(HWGameMode_DoesPlayerMeetNPEBoostCriteria, TrackedPlayerController) == 0x000000, "Member 'HWGameMode_DoesPlayerMeetNPEBoostCriteria::TrackedPlayerController' has a wrong offset!");
static_assert(offsetof(HWGameMode_DoesPlayerMeetNPEBoostCriteria, ReturnValue) == 0x000008, "Member 'HWGameMode_DoesPlayerMeetNPEBoostCriteria::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.EndMatchOnSurrender
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_EndMatchOnSurrender final
{
public:
	const class AHWTeamState*                     TeamState;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_EndMatchOnSurrender) == 0x000008, "Wrong alignment on HWGameMode_EndMatchOnSurrender");
static_assert(sizeof(HWGameMode_EndMatchOnSurrender) == 0x000008, "Wrong size on HWGameMode_EndMatchOnSurrender");
static_assert(offsetof(HWGameMode_EndMatchOnSurrender, TeamState) == 0x000000, "Member 'HWGameMode_EndMatchOnSurrender::TeamState' has a wrong offset!");

// Function Hemingway.HWGameMode.GetRespawnDelayTime
// 0x0010 (0x0010 - 0x0000)
struct HWGameMode_GetRespawnDelayTime final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameMode_GetRespawnDelayTime) == 0x000008, "Wrong alignment on HWGameMode_GetRespawnDelayTime");
static_assert(sizeof(HWGameMode_GetRespawnDelayTime) == 0x000010, "Wrong size on HWGameMode_GetRespawnDelayTime");
static_assert(offsetof(HWGameMode_GetRespawnDelayTime, PlayerState) == 0x000000, "Member 'HWGameMode_GetRespawnDelayTime::PlayerState' has a wrong offset!");
static_assert(offsetof(HWGameMode_GetRespawnDelayTime, ReturnValue) == 0x000008, "Member 'HWGameMode_GetRespawnDelayTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GoToMatchPhase
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_GoToMatchPhase final
{
public:
	struct FGameplayTag                           NextPhaseTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GoToMatchPhase) == 0x000004, "Wrong alignment on HWGameMode_GoToMatchPhase");
static_assert(sizeof(HWGameMode_GoToMatchPhase) == 0x000008, "Wrong size on HWGameMode_GoToMatchPhase");
static_assert(offsetof(HWGameMode_GoToMatchPhase, NextPhaseTag) == 0x000000, "Member 'HWGameMode_GoToMatchPhase::NextPhaseTag' has a wrong offset!");

// Function Hemingway.HWGameMode.HandleKillCreditDeath
// 0x0020 (0x0020 - 0x0000)
struct HWGameMode_HandleKillCreditDeath final
{
public:
	class AHWCharacter_Base*                      KilledCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWAssistCandidate>             AssistingTeamMembers;                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_HandleKillCreditDeath) == 0x000008, "Wrong alignment on HWGameMode_HandleKillCreditDeath");
static_assert(sizeof(HWGameMode_HandleKillCreditDeath) == 0x000020, "Wrong size on HWGameMode_HandleKillCreditDeath");
static_assert(offsetof(HWGameMode_HandleKillCreditDeath, KilledCharacter) == 0x000000, "Member 'HWGameMode_HandleKillCreditDeath::KilledCharacter' has a wrong offset!");
static_assert(offsetof(HWGameMode_HandleKillCreditDeath, Killer) == 0x000008, "Member 'HWGameMode_HandleKillCreditDeath::Killer' has a wrong offset!");
static_assert(offsetof(HWGameMode_HandleKillCreditDeath, AssistingTeamMembers) == 0x000010, "Member 'HWGameMode_HandleKillCreditDeath::AssistingTeamMembers' has a wrong offset!");

// Function Hemingway.HWGameMode.IsMatchmadeQueue
// 0x0001 (0x0001 - 0x0000)
struct HWGameMode_IsMatchmadeQueue final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_IsMatchmadeQueue) == 0x000001, "Wrong alignment on HWGameMode_IsMatchmadeQueue");
static_assert(sizeof(HWGameMode_IsMatchmadeQueue) == 0x000001, "Wrong size on HWGameMode_IsMatchmadeQueue");
static_assert(offsetof(HWGameMode_IsMatchmadeQueue, ReturnValue) == 0x000000, "Member 'HWGameMode_IsMatchmadeQueue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.IsShopUnrestrictedForStartup
// 0x0001 (0x0001 - 0x0000)
struct HWGameMode_IsShopUnrestrictedForStartup final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_IsShopUnrestrictedForStartup) == 0x000001, "Wrong alignment on HWGameMode_IsShopUnrestrictedForStartup");
static_assert(sizeof(HWGameMode_IsShopUnrestrictedForStartup) == 0x000001, "Wrong size on HWGameMode_IsShopUnrestrictedForStartup");
static_assert(offsetof(HWGameMode_IsShopUnrestrictedForStartup, ReturnValue) == 0x000000, "Member 'HWGameMode_IsShopUnrestrictedForStartup::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.LockPhaseRulesDuringTransferFor
// 0x0020 (0x0020 - 0x0000)
struct HWGameMode_LockPhaseRulesDuringTransferFor final
{
public:
	struct FHWPersistentPlayerId                  TransferringPlayerId;                              // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_LockPhaseRulesDuringTransferFor) == 0x000004, "Wrong alignment on HWGameMode_LockPhaseRulesDuringTransferFor");
static_assert(sizeof(HWGameMode_LockPhaseRulesDuringTransferFor) == 0x000020, "Wrong size on HWGameMode_LockPhaseRulesDuringTransferFor");
static_assert(offsetof(HWGameMode_LockPhaseRulesDuringTransferFor, TransferringPlayerId) == 0x000000, "Member 'HWGameMode_LockPhaseRulesDuringTransferFor::TransferringPlayerId' has a wrong offset!");

// Function Hemingway.HWGameMode.ModeSupportsQuests
// 0x0001 (0x0001 - 0x0000)
struct HWGameMode_ModeSupportsQuests final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_ModeSupportsQuests) == 0x000001, "Wrong alignment on HWGameMode_ModeSupportsQuests");
static_assert(sizeof(HWGameMode_ModeSupportsQuests) == 0x000001, "Wrong size on HWGameMode_ModeSupportsQuests");
static_assert(offsetof(HWGameMode_ModeSupportsQuests, ReturnValue) == 0x000000, "Member 'HWGameMode_ModeSupportsQuests::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.PendingLoginDisconnected
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_PendingLoginDisconnected final
{
public:
	class URH_IpConnection*                       Connection;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_PendingLoginDisconnected) == 0x000008, "Wrong alignment on HWGameMode_PendingLoginDisconnected");
static_assert(sizeof(HWGameMode_PendingLoginDisconnected) == 0x000008, "Wrong size on HWGameMode_PendingLoginDisconnected");
static_assert(offsetof(HWGameMode_PendingLoginDisconnected, Connection) == 0x000000, "Member 'HWGameMode_PendingLoginDisconnected::Connection' has a wrong offset!");

// Function Hemingway.HWGameMode.RemoveGameModeModifiersFromPlayer
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_RemoveGameModeModifiersFromPlayer final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_RemoveGameModeModifiersFromPlayer) == 0x000008, "Wrong alignment on HWGameMode_RemoveGameModeModifiersFromPlayer");
static_assert(sizeof(HWGameMode_RemoveGameModeModifiersFromPlayer) == 0x000008, "Wrong size on HWGameMode_RemoveGameModeModifiersFromPlayer");
static_assert(offsetof(HWGameMode_RemoveGameModeModifiersFromPlayer, PlayerState) == 0x000000, "Member 'HWGameMode_RemoveGameModeModifiersFromPlayer::PlayerState' has a wrong offset!");

// Function Hemingway.HWGameMode.RestartPlayerWithCharacter
// 0x0028 (0x0028 - 0x0000)
struct HWGameMode_RestartPlayerWithCharacter final
{
public:
	class AController*                            ControllerToRestart;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 CharacterToGive;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWSkinItem*                      SkinToGive;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 StartSpot;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullyResetCharacter;                              // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameMode_RestartPlayerWithCharacter) == 0x000008, "Wrong alignment on HWGameMode_RestartPlayerWithCharacter");
static_assert(sizeof(HWGameMode_RestartPlayerWithCharacter) == 0x000028, "Wrong size on HWGameMode_RestartPlayerWithCharacter");
static_assert(offsetof(HWGameMode_RestartPlayerWithCharacter, ControllerToRestart) == 0x000000, "Member 'HWGameMode_RestartPlayerWithCharacter::ControllerToRestart' has a wrong offset!");
static_assert(offsetof(HWGameMode_RestartPlayerWithCharacter, CharacterToGive) == 0x000008, "Member 'HWGameMode_RestartPlayerWithCharacter::CharacterToGive' has a wrong offset!");
static_assert(offsetof(HWGameMode_RestartPlayerWithCharacter, SkinToGive) == 0x000010, "Member 'HWGameMode_RestartPlayerWithCharacter::SkinToGive' has a wrong offset!");
static_assert(offsetof(HWGameMode_RestartPlayerWithCharacter, StartSpot) == 0x000018, "Member 'HWGameMode_RestartPlayerWithCharacter::StartSpot' has a wrong offset!");
static_assert(offsetof(HWGameMode_RestartPlayerWithCharacter, bFullyResetCharacter) == 0x000020, "Member 'HWGameMode_RestartPlayerWithCharacter::bFullyResetCharacter' has a wrong offset!");

// Function Hemingway.HWGameMode.SendMatchCompositionToPlayer
// 0x00A8 (0x00A8 - 0x0000)
struct HWGameMode_SendMatchCompositionToPlayer final
{
public:
	class UNetConnection*                         Connection;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInstanceInfo_PlayerDataList         PlayerDataList;                                    // 0x0008(0x00A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_SendMatchCompositionToPlayer) == 0x000008, "Wrong alignment on HWGameMode_SendMatchCompositionToPlayer");
static_assert(sizeof(HWGameMode_SendMatchCompositionToPlayer) == 0x0000A8, "Wrong size on HWGameMode_SendMatchCompositionToPlayer");
static_assert(offsetof(HWGameMode_SendMatchCompositionToPlayer, Connection) == 0x000000, "Member 'HWGameMode_SendMatchCompositionToPlayer::Connection' has a wrong offset!");
static_assert(offsetof(HWGameMode_SendMatchCompositionToPlayer, PlayerDataList) == 0x000008, "Member 'HWGameMode_SendMatchCompositionToPlayer::PlayerDataList' has a wrong offset!");

// Function Hemingway.HWGameMode.SetCurrentMatchPhaseDuration
// 0x0004 (0x0004 - 0x0000)
struct HWGameMode_SetCurrentMatchPhaseDuration final
{
public:
	float                                         NewPhaseDuration;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_SetCurrentMatchPhaseDuration) == 0x000004, "Wrong alignment on HWGameMode_SetCurrentMatchPhaseDuration");
static_assert(sizeof(HWGameMode_SetCurrentMatchPhaseDuration) == 0x000004, "Wrong size on HWGameMode_SetCurrentMatchPhaseDuration");
static_assert(offsetof(HWGameMode_SetCurrentMatchPhaseDuration, NewPhaseDuration) == 0x000000, "Member 'HWGameMode_SetCurrentMatchPhaseDuration::NewPhaseDuration' has a wrong offset!");

// Function Hemingway.HWGameMode.SetGameModeFinishedWaitingOnLoadScreens
// 0x0001 (0x0001 - 0x0000)
struct HWGameMode_SetGameModeFinishedWaitingOnLoadScreens final
{
public:
	bool                                          bFinishedWaiting;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_SetGameModeFinishedWaitingOnLoadScreens) == 0x000001, "Wrong alignment on HWGameMode_SetGameModeFinishedWaitingOnLoadScreens");
static_assert(sizeof(HWGameMode_SetGameModeFinishedWaitingOnLoadScreens) == 0x000001, "Wrong size on HWGameMode_SetGameModeFinishedWaitingOnLoadScreens");
static_assert(offsetof(HWGameMode_SetGameModeFinishedWaitingOnLoadScreens, bFinishedWaiting) == 0x000000, "Member 'HWGameMode_SetGameModeFinishedWaitingOnLoadScreens::bFinishedWaiting' has a wrong offset!");

// Function Hemingway.HWGameMode.UnlockPhaseRulesAfterTransferFor
// 0x0020 (0x0020 - 0x0000)
struct HWGameMode_UnlockPhaseRulesAfterTransferFor final
{
public:
	struct FHWPersistentPlayerId                  TransferringPlayerId;                              // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_UnlockPhaseRulesAfterTransferFor) == 0x000004, "Wrong alignment on HWGameMode_UnlockPhaseRulesAfterTransferFor");
static_assert(sizeof(HWGameMode_UnlockPhaseRulesAfterTransferFor) == 0x000020, "Wrong size on HWGameMode_UnlockPhaseRulesAfterTransferFor");
static_assert(offsetof(HWGameMode_UnlockPhaseRulesAfterTransferFor, TransferringPlayerId) == 0x000000, "Member 'HWGameMode_UnlockPhaseRulesAfterTransferFor::TransferringPlayerId' has a wrong offset!");

// Function Hemingway.HWGameMode.WantsToInitializePlayerBehaviorTracking
// 0x0001 (0x0001 - 0x0000)
struct HWGameMode_WantsToInitializePlayerBehaviorTracking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_WantsToInitializePlayerBehaviorTracking) == 0x000001, "Wrong alignment on HWGameMode_WantsToInitializePlayerBehaviorTracking");
static_assert(sizeof(HWGameMode_WantsToInitializePlayerBehaviorTracking) == 0x000001, "Wrong size on HWGameMode_WantsToInitializePlayerBehaviorTracking");
static_assert(offsetof(HWGameMode_WantsToInitializePlayerBehaviorTracking, ReturnValue) == 0x000000, "Member 'HWGameMode_WantsToInitializePlayerBehaviorTracking::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.ApplyNpcAssistGoldFormula
// 0x000C (0x000C - 0x0000)
struct HWGameMode_ApplyNpcAssistGoldFormula final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContributorCount;                                  // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_ApplyNpcAssistGoldFormula) == 0x000004, "Wrong alignment on HWGameMode_ApplyNpcAssistGoldFormula");
static_assert(sizeof(HWGameMode_ApplyNpcAssistGoldFormula) == 0x00000C, "Wrong size on HWGameMode_ApplyNpcAssistGoldFormula");
static_assert(offsetof(HWGameMode_ApplyNpcAssistGoldFormula, BaseValue) == 0x000000, "Member 'HWGameMode_ApplyNpcAssistGoldFormula::BaseValue' has a wrong offset!");
static_assert(offsetof(HWGameMode_ApplyNpcAssistGoldFormula, ContributorCount) == 0x000004, "Member 'HWGameMode_ApplyNpcAssistGoldFormula::ContributorCount' has a wrong offset!");
static_assert(offsetof(HWGameMode_ApplyNpcAssistGoldFormula, ReturnValue) == 0x000008, "Member 'HWGameMode_ApplyNpcAssistGoldFormula::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.ApplyNpcAssistXpFormula
// 0x000C (0x000C - 0x0000)
struct HWGameMode_ApplyNpcAssistXpFormula final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContributorCount;                                  // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_ApplyNpcAssistXpFormula) == 0x000004, "Wrong alignment on HWGameMode_ApplyNpcAssistXpFormula");
static_assert(sizeof(HWGameMode_ApplyNpcAssistXpFormula) == 0x00000C, "Wrong size on HWGameMode_ApplyNpcAssistXpFormula");
static_assert(offsetof(HWGameMode_ApplyNpcAssistXpFormula, BaseValue) == 0x000000, "Member 'HWGameMode_ApplyNpcAssistXpFormula::BaseValue' has a wrong offset!");
static_assert(offsetof(HWGameMode_ApplyNpcAssistXpFormula, ContributorCount) == 0x000004, "Member 'HWGameMode_ApplyNpcAssistXpFormula::ContributorCount' has a wrong offset!");
static_assert(offsetof(HWGameMode_ApplyNpcAssistXpFormula, ReturnValue) == 0x000008, "Member 'HWGameMode_ApplyNpcAssistXpFormula::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.ApplyNpcKillGoldFormula
// 0x000C (0x000C - 0x0000)
struct HWGameMode_ApplyNpcKillGoldFormula final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContributorCount;                                  // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_ApplyNpcKillGoldFormula) == 0x000004, "Wrong alignment on HWGameMode_ApplyNpcKillGoldFormula");
static_assert(sizeof(HWGameMode_ApplyNpcKillGoldFormula) == 0x00000C, "Wrong size on HWGameMode_ApplyNpcKillGoldFormula");
static_assert(offsetof(HWGameMode_ApplyNpcKillGoldFormula, BaseValue) == 0x000000, "Member 'HWGameMode_ApplyNpcKillGoldFormula::BaseValue' has a wrong offset!");
static_assert(offsetof(HWGameMode_ApplyNpcKillGoldFormula, ContributorCount) == 0x000004, "Member 'HWGameMode_ApplyNpcKillGoldFormula::ContributorCount' has a wrong offset!");
static_assert(offsetof(HWGameMode_ApplyNpcKillGoldFormula, ReturnValue) == 0x000008, "Member 'HWGameMode_ApplyNpcKillGoldFormula::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.ApplyNpcKillXpFormula
// 0x000C (0x000C - 0x0000)
struct HWGameMode_ApplyNpcKillXpFormula final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContributorCount;                                  // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_ApplyNpcKillXpFormula) == 0x000004, "Wrong alignment on HWGameMode_ApplyNpcKillXpFormula");
static_assert(sizeof(HWGameMode_ApplyNpcKillXpFormula) == 0x00000C, "Wrong size on HWGameMode_ApplyNpcKillXpFormula");
static_assert(offsetof(HWGameMode_ApplyNpcKillXpFormula, BaseValue) == 0x000000, "Member 'HWGameMode_ApplyNpcKillXpFormula::BaseValue' has a wrong offset!");
static_assert(offsetof(HWGameMode_ApplyNpcKillXpFormula, ContributorCount) == 0x000004, "Member 'HWGameMode_ApplyNpcKillXpFormula::ContributorCount' has a wrong offset!");
static_assert(offsetof(HWGameMode_ApplyNpcKillXpFormula, ReturnValue) == 0x000008, "Member 'HWGameMode_ApplyNpcKillXpFormula::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.CalcPlayerAssistGoldReward
// 0x0018 (0x0018 - 0x0000)
struct HWGameMode_CalcPlayerAssistGoldReward final
{
public:
	class AHWCharacter_PlayableCharacter*         VictimPlayer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      AssistingPlayer;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssisterCount;                                     // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_CalcPlayerAssistGoldReward) == 0x000008, "Wrong alignment on HWGameMode_CalcPlayerAssistGoldReward");
static_assert(sizeof(HWGameMode_CalcPlayerAssistGoldReward) == 0x000018, "Wrong size on HWGameMode_CalcPlayerAssistGoldReward");
static_assert(offsetof(HWGameMode_CalcPlayerAssistGoldReward, VictimPlayer) == 0x000000, "Member 'HWGameMode_CalcPlayerAssistGoldReward::VictimPlayer' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerAssistGoldReward, AssistingPlayer) == 0x000008, "Member 'HWGameMode_CalcPlayerAssistGoldReward::AssistingPlayer' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerAssistGoldReward, AssisterCount) == 0x000010, "Member 'HWGameMode_CalcPlayerAssistGoldReward::AssisterCount' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerAssistGoldReward, ReturnValue) == 0x000014, "Member 'HWGameMode_CalcPlayerAssistGoldReward::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.CalcPlayerAssistXpReward
// 0x0018 (0x0018 - 0x0000)
struct HWGameMode_CalcPlayerAssistXpReward final
{
public:
	class AHWCharacter_PlayableCharacter*         VictimPlayer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      AssistingPlayer;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssisterCount;                                     // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_CalcPlayerAssistXpReward) == 0x000008, "Wrong alignment on HWGameMode_CalcPlayerAssistXpReward");
static_assert(sizeof(HWGameMode_CalcPlayerAssistXpReward) == 0x000018, "Wrong size on HWGameMode_CalcPlayerAssistXpReward");
static_assert(offsetof(HWGameMode_CalcPlayerAssistXpReward, VictimPlayer) == 0x000000, "Member 'HWGameMode_CalcPlayerAssistXpReward::VictimPlayer' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerAssistXpReward, AssistingPlayer) == 0x000008, "Member 'HWGameMode_CalcPlayerAssistXpReward::AssistingPlayer' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerAssistXpReward, AssisterCount) == 0x000010, "Member 'HWGameMode_CalcPlayerAssistXpReward::AssisterCount' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerAssistXpReward, ReturnValue) == 0x000014, "Member 'HWGameMode_CalcPlayerAssistXpReward::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.CalcPlayerKillGoldReward
// 0x0018 (0x0018 - 0x0000)
struct HWGameMode_CalcPlayerKillGoldReward final
{
public:
	class AHWCharacter_PlayableCharacter*         VictimPlayer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      KillerPlayer;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyFirstBloodBonus;                             // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_CalcPlayerKillGoldReward) == 0x000008, "Wrong alignment on HWGameMode_CalcPlayerKillGoldReward");
static_assert(sizeof(HWGameMode_CalcPlayerKillGoldReward) == 0x000018, "Wrong size on HWGameMode_CalcPlayerKillGoldReward");
static_assert(offsetof(HWGameMode_CalcPlayerKillGoldReward, VictimPlayer) == 0x000000, "Member 'HWGameMode_CalcPlayerKillGoldReward::VictimPlayer' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerKillGoldReward, KillerPlayer) == 0x000008, "Member 'HWGameMode_CalcPlayerKillGoldReward::KillerPlayer' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerKillGoldReward, bApplyFirstBloodBonus) == 0x000010, "Member 'HWGameMode_CalcPlayerKillGoldReward::bApplyFirstBloodBonus' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerKillGoldReward, ReturnValue) == 0x000014, "Member 'HWGameMode_CalcPlayerKillGoldReward::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.CalcPlayerKillXpReward
// 0x0018 (0x0018 - 0x0000)
struct HWGameMode_CalcPlayerKillXpReward final
{
public:
	class AHWCharacter_PlayableCharacter*         VictimPlayer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      KillerPlayer;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameMode_CalcPlayerKillXpReward) == 0x000008, "Wrong alignment on HWGameMode_CalcPlayerKillXpReward");
static_assert(sizeof(HWGameMode_CalcPlayerKillXpReward) == 0x000018, "Wrong size on HWGameMode_CalcPlayerKillXpReward");
static_assert(offsetof(HWGameMode_CalcPlayerKillXpReward, VictimPlayer) == 0x000000, "Member 'HWGameMode_CalcPlayerKillXpReward::VictimPlayer' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerKillXpReward, KillerPlayer) == 0x000008, "Member 'HWGameMode_CalcPlayerKillXpReward::KillerPlayer' has a wrong offset!");
static_assert(offsetof(HWGameMode_CalcPlayerKillXpReward, ReturnValue) == 0x000010, "Member 'HWGameMode_CalcPlayerKillXpReward::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.CurrentlyTrackingPlayerBehaviors
// 0x0001 (0x0001 - 0x0000)
struct HWGameMode_CurrentlyTrackingPlayerBehaviors final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_CurrentlyTrackingPlayerBehaviors) == 0x000001, "Wrong alignment on HWGameMode_CurrentlyTrackingPlayerBehaviors");
static_assert(sizeof(HWGameMode_CurrentlyTrackingPlayerBehaviors) == 0x000001, "Wrong size on HWGameMode_CurrentlyTrackingPlayerBehaviors");
static_assert(offsetof(HWGameMode_CurrentlyTrackingPlayerBehaviors, ReturnValue) == 0x000000, "Member 'HWGameMode_CurrentlyTrackingPlayerBehaviors::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.DoesNPCAwardLastHitGold
// 0x0010 (0x0010 - 0x0000)
struct HWGameMode_DoesNPCAwardLastHitGold final
{
public:
	const class UHWAbilitySystemComponent*        KilledNPCASC;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameMode_DoesNPCAwardLastHitGold) == 0x000008, "Wrong alignment on HWGameMode_DoesNPCAwardLastHitGold");
static_assert(sizeof(HWGameMode_DoesNPCAwardLastHitGold) == 0x000010, "Wrong size on HWGameMode_DoesNPCAwardLastHitGold");
static_assert(offsetof(HWGameMode_DoesNPCAwardLastHitGold, KilledNPCASC) == 0x000000, "Member 'HWGameMode_DoesNPCAwardLastHitGold::KilledNPCASC' has a wrong offset!");
static_assert(offsetof(HWGameMode_DoesNPCAwardLastHitGold, ReturnValue) == 0x000008, "Member 'HWGameMode_DoesNPCAwardLastHitGold::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetChaosPlayCaller
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_GetChaosPlayCaller final
{
public:
	class UHWAIPlayCaller*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetChaosPlayCaller) == 0x000008, "Wrong alignment on HWGameMode_GetChaosPlayCaller");
static_assert(sizeof(HWGameMode_GetChaosPlayCaller) == 0x000008, "Wrong size on HWGameMode_GetChaosPlayCaller");
static_assert(offsetof(HWGameMode_GetChaosPlayCaller, ReturnValue) == 0x000000, "Member 'HWGameMode_GetChaosPlayCaller::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetChaosTeamId
// 0x0001 (0x0001 - 0x0000)
struct HWGameMode_GetChaosTeamId final
{
public:
	struct FGenericTeamId                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetChaosTeamId) == 0x000001, "Wrong alignment on HWGameMode_GetChaosTeamId");
static_assert(sizeof(HWGameMode_GetChaosTeamId) == 0x000001, "Wrong size on HWGameMode_GetChaosTeamId");
static_assert(offsetof(HWGameMode_GetChaosTeamId, ReturnValue) == 0x000000, "Member 'HWGameMode_GetChaosTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetCurrentMatchPhaseTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_GetCurrentMatchPhaseTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetCurrentMatchPhaseTag) == 0x000004, "Wrong alignment on HWGameMode_GetCurrentMatchPhaseTag");
static_assert(sizeof(HWGameMode_GetCurrentMatchPhaseTag) == 0x000008, "Wrong size on HWGameMode_GetCurrentMatchPhaseTag");
static_assert(offsetof(HWGameMode_GetCurrentMatchPhaseTag, ReturnValue) == 0x000000, "Member 'HWGameMode_GetCurrentMatchPhaseTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetGameModeTypeTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_GetGameModeTypeTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetGameModeTypeTag) == 0x000004, "Wrong alignment on HWGameMode_GetGameModeTypeTag");
static_assert(sizeof(HWGameMode_GetGameModeTypeTag) == 0x000008, "Wrong size on HWGameMode_GetGameModeTypeTag");
static_assert(offsetof(HWGameMode_GetGameModeTypeTag, ReturnValue) == 0x000000, "Member 'HWGameMode_GetGameModeTypeTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetGodBotDifficultyConfig
// 0x0010 (0x0010 - 0x0000)
struct HWGameMode_GetGodBotDifficultyConfig final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAIDifficultyConfig*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetGodBotDifficultyConfig) == 0x000008, "Wrong alignment on HWGameMode_GetGodBotDifficultyConfig");
static_assert(sizeof(HWGameMode_GetGodBotDifficultyConfig) == 0x000010, "Wrong size on HWGameMode_GetGodBotDifficultyConfig");
static_assert(offsetof(HWGameMode_GetGodBotDifficultyConfig, Team) == 0x000000, "Member 'HWGameMode_GetGodBotDifficultyConfig::Team' has a wrong offset!");
static_assert(offsetof(HWGameMode_GetGodBotDifficultyConfig, ReturnValue) == 0x000008, "Member 'HWGameMode_GetGodBotDifficultyConfig::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetGodBotDifficultyConfigForOpposingTeam
// 0x0010 (0x0010 - 0x0000)
struct HWGameMode_GetGodBotDifficultyConfigForOpposingTeam final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAIDifficultyConfig*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetGodBotDifficultyConfigForOpposingTeam) == 0x000008, "Wrong alignment on HWGameMode_GetGodBotDifficultyConfigForOpposingTeam");
static_assert(sizeof(HWGameMode_GetGodBotDifficultyConfigForOpposingTeam) == 0x000010, "Wrong size on HWGameMode_GetGodBotDifficultyConfigForOpposingTeam");
static_assert(offsetof(HWGameMode_GetGodBotDifficultyConfigForOpposingTeam, Team) == 0x000000, "Member 'HWGameMode_GetGodBotDifficultyConfigForOpposingTeam::Team' has a wrong offset!");
static_assert(offsetof(HWGameMode_GetGodBotDifficultyConfigForOpposingTeam, ReturnValue) == 0x000008, "Member 'HWGameMode_GetGodBotDifficultyConfigForOpposingTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetNeutralTeamId
// 0x0001 (0x0001 - 0x0000)
struct HWGameMode_GetNeutralTeamId final
{
public:
	struct FGenericTeamId                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetNeutralTeamId) == 0x000001, "Wrong alignment on HWGameMode_GetNeutralTeamId");
static_assert(sizeof(HWGameMode_GetNeutralTeamId) == 0x000001, "Wrong size on HWGameMode_GetNeutralTeamId");
static_assert(offsetof(HWGameMode_GetNeutralTeamId, ReturnValue) == 0x000000, "Member 'HWGameMode_GetNeutralTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetNpcLastHitGoldMultiplier
// 0x0004 (0x0004 - 0x0000)
struct HWGameMode_GetNpcLastHitGoldMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetNpcLastHitGoldMultiplier) == 0x000004, "Wrong alignment on HWGameMode_GetNpcLastHitGoldMultiplier");
static_assert(sizeof(HWGameMode_GetNpcLastHitGoldMultiplier) == 0x000004, "Wrong size on HWGameMode_GetNpcLastHitGoldMultiplier");
static_assert(offsetof(HWGameMode_GetNpcLastHitGoldMultiplier, ReturnValue) == 0x000000, "Member 'HWGameMode_GetNpcLastHitGoldMultiplier::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetOpposingTeamIds
// 0x0020 (0x0020 - 0x0000)
struct HWGameMode_GetOpposingTeamIds final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGenericTeamId>                 OpposingTeamIds;                                   // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameMode_GetOpposingTeamIds) == 0x000008, "Wrong alignment on HWGameMode_GetOpposingTeamIds");
static_assert(sizeof(HWGameMode_GetOpposingTeamIds) == 0x000020, "Wrong size on HWGameMode_GetOpposingTeamIds");
static_assert(offsetof(HWGameMode_GetOpposingTeamIds, TeamId) == 0x000000, "Member 'HWGameMode_GetOpposingTeamIds::TeamId' has a wrong offset!");
static_assert(offsetof(HWGameMode_GetOpposingTeamIds, OpposingTeamIds) == 0x000008, "Member 'HWGameMode_GetOpposingTeamIds::OpposingTeamIds' has a wrong offset!");
static_assert(offsetof(HWGameMode_GetOpposingTeamIds, ReturnValue) == 0x000018, "Member 'HWGameMode_GetOpposingTeamIds::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetOrderPlayCaller
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_GetOrderPlayCaller final
{
public:
	class UHWAIPlayCaller*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetOrderPlayCaller) == 0x000008, "Wrong alignment on HWGameMode_GetOrderPlayCaller");
static_assert(sizeof(HWGameMode_GetOrderPlayCaller) == 0x000008, "Wrong size on HWGameMode_GetOrderPlayCaller");
static_assert(offsetof(HWGameMode_GetOrderPlayCaller, ReturnValue) == 0x000000, "Member 'HWGameMode_GetOrderPlayCaller::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetOrderTeamId
// 0x0001 (0x0001 - 0x0000)
struct HWGameMode_GetOrderTeamId final
{
public:
	struct FGenericTeamId                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetOrderTeamId) == 0x000001, "Wrong alignment on HWGameMode_GetOrderTeamId");
static_assert(sizeof(HWGameMode_GetOrderTeamId) == 0x000001, "Wrong size on HWGameMode_GetOrderTeamId");
static_assert(offsetof(HWGameMode_GetOrderTeamId, ReturnValue) == 0x000000, "Member 'HWGameMode_GetOrderTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetPlayCaller
// 0x0010 (0x0010 - 0x0000)
struct HWGameMode_GetPlayCaller final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAIPlayCaller*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetPlayCaller) == 0x000008, "Wrong alignment on HWGameMode_GetPlayCaller");
static_assert(sizeof(HWGameMode_GetPlayCaller) == 0x000010, "Wrong size on HWGameMode_GetPlayCaller");
static_assert(offsetof(HWGameMode_GetPlayCaller, TeamId) == 0x000000, "Member 'HWGameMode_GetPlayCaller::TeamId' has a wrong offset!");
static_assert(offsetof(HWGameMode_GetPlayCaller, ReturnValue) == 0x000008, "Member 'HWGameMode_GetPlayCaller::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetPlayerModifiersAbilitySet
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_GetPlayerModifiersAbilitySet final
{
public:
	const class UHWAbilitySet*                    ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetPlayerModifiersAbilitySet) == 0x000008, "Wrong alignment on HWGameMode_GetPlayerModifiersAbilitySet");
static_assert(sizeof(HWGameMode_GetPlayerModifiersAbilitySet) == 0x000008, "Wrong size on HWGameMode_GetPlayerModifiersAbilitySet");
static_assert(offsetof(HWGameMode_GetPlayerModifiersAbilitySet, ReturnValue) == 0x000000, "Member 'HWGameMode_GetPlayerModifiersAbilitySet::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.GetTransitionInfoTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_GetTransitionInfoTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_GetTransitionInfoTag) == 0x000004, "Wrong alignment on HWGameMode_GetTransitionInfoTag");
static_assert(sizeof(HWGameMode_GetTransitionInfoTag) == 0x000008, "Wrong size on HWGameMode_GetTransitionInfoTag");
static_assert(offsetof(HWGameMode_GetTransitionInfoTag, ReturnValue) == 0x000000, "Member 'HWGameMode_GetTransitionInfoTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.IsANPCTeam
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_IsANPCTeam final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameMode_IsANPCTeam) == 0x000004, "Wrong alignment on HWGameMode_IsANPCTeam");
static_assert(sizeof(HWGameMode_IsANPCTeam) == 0x000008, "Wrong size on HWGameMode_IsANPCTeam");
static_assert(offsetof(HWGameMode_IsANPCTeam, TeamId) == 0x000000, "Member 'HWGameMode_IsANPCTeam::TeamId' has a wrong offset!");
static_assert(offsetof(HWGameMode_IsANPCTeam, ReturnValue) == 0x000004, "Member 'HWGameMode_IsANPCTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.IsAPlayerTeam
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_IsAPlayerTeam final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameMode_IsAPlayerTeam) == 0x000004, "Wrong alignment on HWGameMode_IsAPlayerTeam");
static_assert(sizeof(HWGameMode_IsAPlayerTeam) == 0x000008, "Wrong size on HWGameMode_IsAPlayerTeam");
static_assert(offsetof(HWGameMode_IsAPlayerTeam, TeamId) == 0x000000, "Member 'HWGameMode_IsAPlayerTeam::TeamId' has a wrong offset!");
static_assert(offsetof(HWGameMode_IsAPlayerTeam, ReturnValue) == 0x000004, "Member 'HWGameMode_IsAPlayerTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode.IsASpectatorTeam
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_IsASpectatorTeam final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameMode_IsASpectatorTeam) == 0x000004, "Wrong alignment on HWGameMode_IsASpectatorTeam");
static_assert(sizeof(HWGameMode_IsASpectatorTeam) == 0x000008, "Wrong size on HWGameMode_IsASpectatorTeam");
static_assert(offsetof(HWGameMode_IsASpectatorTeam, TeamId) == 0x000000, "Member 'HWGameMode_IsASpectatorTeam::TeamId' has a wrong offset!");
static_assert(offsetof(HWGameMode_IsASpectatorTeam, ReturnValue) == 0x000004, "Member 'HWGameMode_IsASpectatorTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_Stacks.GetEffectToGrantPerStack
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponentSettings_Stacks_GetEffectToGrantPerStack final
{
public:
	struct FHWEquipmentInfo_EffectInfo            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_Stacks_GetEffectToGrantPerStack) == 0x000008, "Wrong alignment on HWEquipmentComponentSettings_Stacks_GetEffectToGrantPerStack");
static_assert(sizeof(HWEquipmentComponentSettings_Stacks_GetEffectToGrantPerStack) == 0x000008, "Wrong size on HWEquipmentComponentSettings_Stacks_GetEffectToGrantPerStack");
static_assert(offsetof(HWEquipmentComponentSettings_Stacks_GetEffectToGrantPerStack, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_Stacks_GetEffectToGrantPerStack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_Stacks.GetInitialStackCount
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponentSettings_Stacks_GetInitialStackCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_Stacks_GetInitialStackCount) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_Stacks_GetInitialStackCount");
static_assert(sizeof(HWEquipmentComponentSettings_Stacks_GetInitialStackCount) == 0x000004, "Wrong size on HWEquipmentComponentSettings_Stacks_GetInitialStackCount");
static_assert(offsetof(HWEquipmentComponentSettings_Stacks_GetInitialStackCount, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_Stacks_GetInitialStackCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_Stacks.GetMaxStackCount
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponentSettings_Stacks_GetMaxStackCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_Stacks_GetMaxStackCount) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_Stacks_GetMaxStackCount");
static_assert(sizeof(HWEquipmentComponentSettings_Stacks_GetMaxStackCount) == 0x000004, "Wrong size on HWEquipmentComponentSettings_Stacks_GetMaxStackCount");
static_assert(offsetof(HWEquipmentComponentSettings_Stacks_GetMaxStackCount, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_Stacks_GetMaxStackCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGEModiferMagnitudeCalc_Base.GetCharacterInfoFromInstigator
// 0x0020 (0x0020 - 0x0000)
struct HWGEModiferMagnitudeCalc_Base_GetCharacterInfoFromInstigator final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UHWCharacterInfo*                 ReturnValue;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGEModiferMagnitudeCalc_Base_GetCharacterInfoFromInstigator) == 0x000008, "Wrong alignment on HWGEModiferMagnitudeCalc_Base_GetCharacterInfoFromInstigator");
static_assert(sizeof(HWGEModiferMagnitudeCalc_Base_GetCharacterInfoFromInstigator) == 0x000020, "Wrong size on HWGEModiferMagnitudeCalc_Base_GetCharacterInfoFromInstigator");
static_assert(offsetof(HWGEModiferMagnitudeCalc_Base_GetCharacterInfoFromInstigator, EffectContextHandle) == 0x000000, "Member 'HWGEModiferMagnitudeCalc_Base_GetCharacterInfoFromInstigator::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWGEModiferMagnitudeCalc_Base_GetCharacterInfoFromInstigator, ReturnValue) == 0x000018, "Member 'HWGEModiferMagnitudeCalc_Base_GetCharacterInfoFromInstigator::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGEModiferMagnitudeCalc_Base.GetCharacterItemFromInstigator
// 0x0020 (0x0020 - 0x0000)
struct HWGEModiferMagnitudeCalc_Base_GetCharacterItemFromInstigator final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 ReturnValue;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGEModiferMagnitudeCalc_Base_GetCharacterItemFromInstigator) == 0x000008, "Wrong alignment on HWGEModiferMagnitudeCalc_Base_GetCharacterItemFromInstigator");
static_assert(sizeof(HWGEModiferMagnitudeCalc_Base_GetCharacterItemFromInstigator) == 0x000020, "Wrong size on HWGEModiferMagnitudeCalc_Base_GetCharacterItemFromInstigator");
static_assert(offsetof(HWGEModiferMagnitudeCalc_Base_GetCharacterItemFromInstigator, EffectContextHandle) == 0x000000, "Member 'HWGEModiferMagnitudeCalc_Base_GetCharacterItemFromInstigator::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWGEModiferMagnitudeCalc_Base_GetCharacterItemFromInstigator, ReturnValue) == 0x000018, "Member 'HWGEModiferMagnitudeCalc_Base_GetCharacterItemFromInstigator::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPlayCaller.BailOnCurrentPlay
// 0x0008 (0x0008 - 0x0000)
struct HWAIPlayCaller_BailOnCurrentPlay final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayCaller_BailOnCurrentPlay) == 0x000008, "Wrong alignment on HWAIPlayCaller_BailOnCurrentPlay");
static_assert(sizeof(HWAIPlayCaller_BailOnCurrentPlay) == 0x000008, "Wrong size on HWAIPlayCaller_BailOnCurrentPlay");
static_assert(offsetof(HWAIPlayCaller_BailOnCurrentPlay, Character) == 0x000000, "Member 'HWAIPlayCaller_BailOnCurrentPlay::Character' has a wrong offset!");

// Function Hemingway.HWAIPlayCaller.DebugForcePlay
// 0x0008 (0x0008 - 0x0000)
struct HWAIPlayCaller_DebugForcePlay final
{
public:
	class FName                                   PlayRowName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayCaller_DebugForcePlay) == 0x000004, "Wrong alignment on HWAIPlayCaller_DebugForcePlay");
static_assert(sizeof(HWAIPlayCaller_DebugForcePlay) == 0x000008, "Wrong size on HWAIPlayCaller_DebugForcePlay");
static_assert(offsetof(HWAIPlayCaller_DebugForcePlay, PlayRowName) == 0x000000, "Member 'HWAIPlayCaller_DebugForcePlay::PlayRowName' has a wrong offset!");

// Function Hemingway.HWAIPlayCaller.RegisterPlays
// 0x0020 (0x0020 - 0x0000)
struct HWAIPlayCaller_RegisterPlays final
{
public:
	class AActor*                                 AssociatedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            plays;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIPlayCaller_RegisterPlays) == 0x000008, "Wrong alignment on HWAIPlayCaller_RegisterPlays");
static_assert(sizeof(HWAIPlayCaller_RegisterPlays) == 0x000020, "Wrong size on HWAIPlayCaller_RegisterPlays");
static_assert(offsetof(HWAIPlayCaller_RegisterPlays, AssociatedActor) == 0x000000, "Member 'HWAIPlayCaller_RegisterPlays::AssociatedActor' has a wrong offset!");
static_assert(offsetof(HWAIPlayCaller_RegisterPlays, plays) == 0x000008, "Member 'HWAIPlayCaller_RegisterPlays::plays' has a wrong offset!");
static_assert(offsetof(HWAIPlayCaller_RegisterPlays, bForceUpdate) == 0x000018, "Member 'HWAIPlayCaller_RegisterPlays::bForceUpdate' has a wrong offset!");

// Function Hemingway.HWAIPlayCaller.StartPlayCalling
// 0x0008 (0x0008 - 0x0000)
struct HWAIPlayCaller_StartPlayCalling final
{
public:
	class AHWTeamState*                           inTeam;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayCaller_StartPlayCalling) == 0x000008, "Wrong alignment on HWAIPlayCaller_StartPlayCalling");
static_assert(sizeof(HWAIPlayCaller_StartPlayCalling) == 0x000008, "Wrong size on HWAIPlayCaller_StartPlayCalling");
static_assert(offsetof(HWAIPlayCaller_StartPlayCalling, inTeam) == 0x000000, "Member 'HWAIPlayCaller_StartPlayCalling::inTeam' has a wrong offset!");

// Function Hemingway.HWAIPlayCaller.UnregisterPlays
// 0x0008 (0x0008 - 0x0000)
struct HWAIPlayCaller_UnregisterPlays final
{
public:
	class AActor*                                 AssociatedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayCaller_UnregisterPlays) == 0x000008, "Wrong alignment on HWAIPlayCaller_UnregisterPlays");
static_assert(sizeof(HWAIPlayCaller_UnregisterPlays) == 0x000008, "Wrong size on HWAIPlayCaller_UnregisterPlays");
static_assert(offsetof(HWAIPlayCaller_UnregisterPlays, AssociatedActor) == 0x000000, "Member 'HWAIPlayCaller_UnregisterPlays::AssociatedActor' has a wrong offset!");

// Function Hemingway.HWAIPlayCaller.GetActivePlayCurrentStateTag
// 0x0010 (0x0010 - 0x0000)
struct HWAIPlayCaller_GetActivePlayCurrentStateTag final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayCaller_GetActivePlayCurrentStateTag) == 0x000008, "Wrong alignment on HWAIPlayCaller_GetActivePlayCurrentStateTag");
static_assert(sizeof(HWAIPlayCaller_GetActivePlayCurrentStateTag) == 0x000010, "Wrong size on HWAIPlayCaller_GetActivePlayCurrentStateTag");
static_assert(offsetof(HWAIPlayCaller_GetActivePlayCurrentStateTag, Character) == 0x000000, "Member 'HWAIPlayCaller_GetActivePlayCurrentStateTag::Character' has a wrong offset!");
static_assert(offsetof(HWAIPlayCaller_GetActivePlayCurrentStateTag, ReturnValue) == 0x000008, "Member 'HWAIPlayCaller_GetActivePlayCurrentStateTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPlayCaller.GetPlayParticipants
// 0x0018 (0x0018 - 0x0000)
struct HWAIPlayCaller_GetPlayParticipants final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHWCharacter_Base*>              OutParticipants;                                   // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIPlayCaller_GetPlayParticipants) == 0x000008, "Wrong alignment on HWAIPlayCaller_GetPlayParticipants");
static_assert(sizeof(HWAIPlayCaller_GetPlayParticipants) == 0x000018, "Wrong size on HWAIPlayCaller_GetPlayParticipants");
static_assert(offsetof(HWAIPlayCaller_GetPlayParticipants, Character) == 0x000000, "Member 'HWAIPlayCaller_GetPlayParticipants::Character' has a wrong offset!");
static_assert(offsetof(HWAIPlayCaller_GetPlayParticipants, OutParticipants) == 0x000008, "Member 'HWAIPlayCaller_GetPlayParticipants::OutParticipants' has a wrong offset!");

// Function Hemingway.HWAIPlayCaller.GetTimeInPlay
// 0x0010 (0x0010 - 0x0000)
struct HWAIPlayCaller_GetTimeInPlay final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIPlayCaller_GetTimeInPlay) == 0x000008, "Wrong alignment on HWAIPlayCaller_GetTimeInPlay");
static_assert(sizeof(HWAIPlayCaller_GetTimeInPlay) == 0x000010, "Wrong size on HWAIPlayCaller_GetTimeInPlay");
static_assert(offsetof(HWAIPlayCaller_GetTimeInPlay, Character) == 0x000000, "Member 'HWAIPlayCaller_GetTimeInPlay::Character' has a wrong offset!");
static_assert(offsetof(HWAIPlayCaller_GetTimeInPlay, ReturnValue) == 0x000008, "Member 'HWAIPlayCaller_GetTimeInPlay::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPlayCaller.IsCharacterInActivePlay
// 0x0010 (0x0010 - 0x0000)
struct HWAIPlayCaller_IsCharacterInActivePlay final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIPlayCaller_IsCharacterInActivePlay) == 0x000008, "Wrong alignment on HWAIPlayCaller_IsCharacterInActivePlay");
static_assert(sizeof(HWAIPlayCaller_IsCharacterInActivePlay) == 0x000010, "Wrong size on HWAIPlayCaller_IsCharacterInActivePlay");
static_assert(offsetof(HWAIPlayCaller_IsCharacterInActivePlay, Character) == 0x000000, "Member 'HWAIPlayCaller_IsCharacterInActivePlay::Character' has a wrong offset!");
static_assert(offsetof(HWAIPlayCaller_IsCharacterInActivePlay, ReturnValue) == 0x000008, "Member 'HWAIPlayCaller_IsCharacterInActivePlay::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIPlayCaller.IsCharacterInActiveSpecificPlay
// 0x0020 (0x0020 - 0x0000)
struct HWAIPlayCaller_IsCharacterInActiveSpecificPlay final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    PlayId;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIPlayCaller_IsCharacterInActiveSpecificPlay) == 0x000008, "Wrong alignment on HWAIPlayCaller_IsCharacterInActiveSpecificPlay");
static_assert(sizeof(HWAIPlayCaller_IsCharacterInActiveSpecificPlay) == 0x000020, "Wrong size on HWAIPlayCaller_IsCharacterInActiveSpecificPlay");
static_assert(offsetof(HWAIPlayCaller_IsCharacterInActiveSpecificPlay, Character) == 0x000000, "Member 'HWAIPlayCaller_IsCharacterInActiveSpecificPlay::Character' has a wrong offset!");
static_assert(offsetof(HWAIPlayCaller_IsCharacterInActiveSpecificPlay, PlayId) == 0x000008, "Member 'HWAIPlayCaller_IsCharacterInActiveSpecificPlay::PlayId' has a wrong offset!");
static_assert(offsetof(HWAIPlayCaller_IsCharacterInActiveSpecificPlay, ReturnValue) == 0x000018, "Member 'HWAIPlayCaller_IsCharacterInActiveSpecificPlay::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGEMMC_Cooldown.BP_AdjustCooldown
// 0x02C0 (0x02C0 - 0x0000)
struct HWGEMMC_Cooldown_BP_AdjustCooldown final
{
public:
	struct FGameplayEffectSpec                    Spec;                                              // 0x0000(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         InCooldownBase;                                    // 0x02A8(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InCooldownMultiplier;                              // 0x02AC(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InCooldownFlatDelta;                               // 0x02B0(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutCooldownMultiplier;                             // 0x02B4(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutCooldownFlatDelta;                              // 0x02B8(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGEMMC_Cooldown_BP_AdjustCooldown) == 0x000008, "Wrong alignment on HWGEMMC_Cooldown_BP_AdjustCooldown");
static_assert(sizeof(HWGEMMC_Cooldown_BP_AdjustCooldown) == 0x0002C0, "Wrong size on HWGEMMC_Cooldown_BP_AdjustCooldown");
static_assert(offsetof(HWGEMMC_Cooldown_BP_AdjustCooldown, Spec) == 0x000000, "Member 'HWGEMMC_Cooldown_BP_AdjustCooldown::Spec' has a wrong offset!");
static_assert(offsetof(HWGEMMC_Cooldown_BP_AdjustCooldown, InCooldownBase) == 0x0002A8, "Member 'HWGEMMC_Cooldown_BP_AdjustCooldown::InCooldownBase' has a wrong offset!");
static_assert(offsetof(HWGEMMC_Cooldown_BP_AdjustCooldown, InCooldownMultiplier) == 0x0002AC, "Member 'HWGEMMC_Cooldown_BP_AdjustCooldown::InCooldownMultiplier' has a wrong offset!");
static_assert(offsetof(HWGEMMC_Cooldown_BP_AdjustCooldown, InCooldownFlatDelta) == 0x0002B0, "Member 'HWGEMMC_Cooldown_BP_AdjustCooldown::InCooldownFlatDelta' has a wrong offset!");
static_assert(offsetof(HWGEMMC_Cooldown_BP_AdjustCooldown, OutCooldownMultiplier) == 0x0002B4, "Member 'HWGEMMC_Cooldown_BP_AdjustCooldown::OutCooldownMultiplier' has a wrong offset!");
static_assert(offsetof(HWGEMMC_Cooldown_BP_AdjustCooldown, OutCooldownFlatDelta) == 0x0002B8, "Member 'HWGEMMC_Cooldown_BP_AdjustCooldown::OutCooldownFlatDelta' has a wrong offset!");

// Function Hemingway.HWPlayCallSuggestionManager.CreatePlayCallSuggestionVFX
// 0x0068 (0x0068 - 0x0000)
struct HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX final
{
public:
	struct FVector                                P0;                                                // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                P1;                                                // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Tangent0;                                          // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Tangent1;                                          // 0x0048(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartSegment;                                     // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndSegment;                                       // 0x0061(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX) == 0x000008, "Wrong alignment on HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX");
static_assert(sizeof(HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX) == 0x000068, "Wrong size on HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX");
static_assert(offsetof(HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX, P0) == 0x000000, "Member 'HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX::P0' has a wrong offset!");
static_assert(offsetof(HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX, P1) == 0x000018, "Member 'HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX::P1' has a wrong offset!");
static_assert(offsetof(HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX, Tangent0) == 0x000030, "Member 'HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX::Tangent0' has a wrong offset!");
static_assert(offsetof(HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX, Tangent1) == 0x000048, "Member 'HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX::Tangent1' has a wrong offset!");
static_assert(offsetof(HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX, bStartSegment) == 0x000060, "Member 'HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX::bStartSegment' has a wrong offset!");
static_assert(offsetof(HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX, bEndSegment) == 0x000061, "Member 'HWPlayCallSuggestionManager_CreatePlayCallSuggestionVFX::bEndSegment' has a wrong offset!");

// Function Hemingway.HWAIReasonerComponent.GetLandmarkTargets
// 0x0038 (0x0038 - 0x0000)
struct HWAIReasonerComponent_GetLandmarkTargets final
{
public:
	struct FGameplayTagContainer                  TargetTags;                                        // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
	TArray<class AHWCharacter_Base*>              OutResults;                                        // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIReasonerComponent_GetLandmarkTargets) == 0x000008, "Wrong alignment on HWAIReasonerComponent_GetLandmarkTargets");
static_assert(sizeof(HWAIReasonerComponent_GetLandmarkTargets) == 0x000038, "Wrong size on HWAIReasonerComponent_GetLandmarkTargets");
static_assert(offsetof(HWAIReasonerComponent_GetLandmarkTargets, TargetTags) == 0x000000, "Member 'HWAIReasonerComponent_GetLandmarkTargets::TargetTags' has a wrong offset!");
static_assert(offsetof(HWAIReasonerComponent_GetLandmarkTargets, OutResults) == 0x000020, "Member 'HWAIReasonerComponent_GetLandmarkTargets::OutResults' has a wrong offset!");
static_assert(offsetof(HWAIReasonerComponent_GetLandmarkTargets, ReturnValue) == 0x000030, "Member 'HWAIReasonerComponent_GetLandmarkTargets::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIReasonerComponent.GetLaneByIndex
// 0x0010 (0x0010 - 0x0000)
struct HWAIReasonerComponent_GetLaneByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetIndex;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIReasonerComponent_GetLaneByIndex) == 0x000004, "Wrong alignment on HWAIReasonerComponent_GetLaneByIndex");
static_assert(sizeof(HWAIReasonerComponent_GetLaneByIndex) == 0x000010, "Wrong size on HWAIReasonerComponent_GetLaneByIndex");
static_assert(offsetof(HWAIReasonerComponent_GetLaneByIndex, Index_0) == 0x000000, "Member 'HWAIReasonerComponent_GetLaneByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(HWAIReasonerComponent_GetLaneByIndex, bSetIndex) == 0x000004, "Member 'HWAIReasonerComponent_GetLaneByIndex::bSetIndex' has a wrong offset!");
static_assert(offsetof(HWAIReasonerComponent_GetLaneByIndex, ReturnValue) == 0x000008, "Member 'HWAIReasonerComponent_GetLaneByIndex::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIReasonerComponent.InitilizeBotProperties
// 0x0008 (0x0008 - 0x0000)
struct HWAIReasonerComponent_InitilizeBotProperties final
{
public:
	const class UHWBotPropertiesDefinition*       Properties;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIReasonerComponent_InitilizeBotProperties) == 0x000008, "Wrong alignment on HWAIReasonerComponent_InitilizeBotProperties");
static_assert(sizeof(HWAIReasonerComponent_InitilizeBotProperties) == 0x000008, "Wrong size on HWAIReasonerComponent_InitilizeBotProperties");
static_assert(offsetof(HWAIReasonerComponent_InitilizeBotProperties, Properties) == 0x000000, "Member 'HWAIReasonerComponent_InitilizeBotProperties::Properties' has a wrong offset!");

// Function Hemingway.HWAIReasonerComponent.SelectNextLaneID
// 0x000C (0x000C - 0x0000)
struct HWAIReasonerComponent_SelectNextLaneID final
{
public:
	ELaneSelectType                               SelectType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIReasonerComponent_SelectNextLaneID) == 0x000004, "Wrong alignment on HWAIReasonerComponent_SelectNextLaneID");
static_assert(sizeof(HWAIReasonerComponent_SelectNextLaneID) == 0x00000C, "Wrong size on HWAIReasonerComponent_SelectNextLaneID");
static_assert(offsetof(HWAIReasonerComponent_SelectNextLaneID, SelectType) == 0x000000, "Member 'HWAIReasonerComponent_SelectNextLaneID::SelectType' has a wrong offset!");
static_assert(offsetof(HWAIReasonerComponent_SelectNextLaneID, ReturnValue) == 0x000004, "Member 'HWAIReasonerComponent_SelectNextLaneID::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIReasonerComponent.SetBaseActiveActions
// 0x0010 (0x0010 - 0x0000)
struct HWAIReasonerComponent_SetBaseActiveActions final
{
public:
	TArray<TSubclassOf<class UHWAIReasonerOption>> NewOptions;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIReasonerComponent_SetBaseActiveActions) == 0x000008, "Wrong alignment on HWAIReasonerComponent_SetBaseActiveActions");
static_assert(sizeof(HWAIReasonerComponent_SetBaseActiveActions) == 0x000010, "Wrong size on HWAIReasonerComponent_SetBaseActiveActions");
static_assert(offsetof(HWAIReasonerComponent_SetBaseActiveActions, NewOptions) == 0x000000, "Member 'HWAIReasonerComponent_SetBaseActiveActions::NewOptions' has a wrong offset!");

// Function Hemingway.HWAIReasonerOption.CalculateWeight
// 0x0010 (0x0010 - 0x0000)
struct HWAIReasonerOption_CalculateWeight final
{
public:
	class AHWAIController*                        AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIReasonerOption_CalculateWeight) == 0x000008, "Wrong alignment on HWAIReasonerOption_CalculateWeight");
static_assert(sizeof(HWAIReasonerOption_CalculateWeight) == 0x000010, "Wrong size on HWAIReasonerOption_CalculateWeight");
static_assert(offsetof(HWAIReasonerOption_CalculateWeight, AIController) == 0x000000, "Member 'HWAIReasonerOption_CalculateWeight::AIController' has a wrong offset!");
static_assert(offsetof(HWAIReasonerOption_CalculateWeight, ReturnValue) == 0x000008, "Member 'HWAIReasonerOption_CalculateWeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIReasonerOption.CanActivate
// 0x0010 (0x0010 - 0x0000)
struct HWAIReasonerOption_CanActivate final
{
public:
	class AHWAIController*                        AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAIReasonerOption_CanActivate) == 0x000008, "Wrong alignment on HWAIReasonerOption_CanActivate");
static_assert(sizeof(HWAIReasonerOption_CanActivate) == 0x000010, "Wrong size on HWAIReasonerOption_CanActivate");
static_assert(offsetof(HWAIReasonerOption_CanActivate, AIController) == 0x000000, "Member 'HWAIReasonerOption_CanActivate::AIController' has a wrong offset!");
static_assert(offsetof(HWAIReasonerOption_CanActivate, ReturnValue) == 0x000008, "Member 'HWAIReasonerOption_CanActivate::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIReasonerOption.GetGameState
// 0x0010 (0x0010 - 0x0000)
struct HWAIReasonerOption_GetGameState final
{
public:
	class AHWAIController*                        AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameStateBase*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIReasonerOption_GetGameState) == 0x000008, "Wrong alignment on HWAIReasonerOption_GetGameState");
static_assert(sizeof(HWAIReasonerOption_GetGameState) == 0x000010, "Wrong size on HWAIReasonerOption_GetGameState");
static_assert(offsetof(HWAIReasonerOption_GetGameState, AIController) == 0x000000, "Member 'HWAIReasonerOption_GetGameState::AIController' has a wrong offset!");
static_assert(offsetof(HWAIReasonerOption_GetGameState, ReturnValue) == 0x000008, "Member 'HWAIReasonerOption_GetGameState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIReasonerOption.GetWorldFromController
// 0x0010 (0x0010 - 0x0000)
struct HWAIReasonerOption_GetWorldFromController final
{
public:
	class AHWAIController*                        AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIReasonerOption_GetWorldFromController) == 0x000008, "Wrong alignment on HWAIReasonerOption_GetWorldFromController");
static_assert(sizeof(HWAIReasonerOption_GetWorldFromController) == 0x000010, "Wrong size on HWAIReasonerOption_GetWorldFromController");
static_assert(offsetof(HWAIReasonerOption_GetWorldFromController, AIController) == 0x000000, "Member 'HWAIReasonerOption_GetWorldFromController::AIController' has a wrong offset!");
static_assert(offsetof(HWAIReasonerOption_GetWorldFromController, ReturnValue) == 0x000008, "Member 'HWAIReasonerOption_GetWorldFromController::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAIReasonerOption.StartAction
// 0x0008 (0x0008 - 0x0000)
struct HWAIReasonerOption_StartAction final
{
public:
	class AHWAIController*                        AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIReasonerOption_StartAction) == 0x000008, "Wrong alignment on HWAIReasonerOption_StartAction");
static_assert(sizeof(HWAIReasonerOption_StartAction) == 0x000008, "Wrong size on HWAIReasonerOption_StartAction");
static_assert(offsetof(HWAIReasonerOption_StartAction, AIController) == 0x000000, "Member 'HWAIReasonerOption_StartAction::AIController' has a wrong offset!");

// Function Hemingway.HWAIReasonerOption.StopAction
// 0x0008 (0x0008 - 0x0000)
struct HWAIReasonerOption_StopAction final
{
public:
	class AHWAIController*                        AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIReasonerOption_StopAction) == 0x000008, "Wrong alignment on HWAIReasonerOption_StopAction");
static_assert(sizeof(HWAIReasonerOption_StopAction) == 0x000008, "Wrong size on HWAIReasonerOption_StopAction");
static_assert(offsetof(HWAIReasonerOption_StopAction, AIController) == 0x000000, "Member 'HWAIReasonerOption_StopAction::AIController' has a wrong offset!");

// Function Hemingway.HWAIReasonerOption.TickAction
// 0x0010 (0x0010 - 0x0000)
struct HWAIReasonerOption_TickAction final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWAIController*                        AIController;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAIReasonerOption_TickAction) == 0x000008, "Wrong alignment on HWAIReasonerOption_TickAction");
static_assert(sizeof(HWAIReasonerOption_TickAction) == 0x000010, "Wrong size on HWAIReasonerOption_TickAction");
static_assert(offsetof(HWAIReasonerOption_TickAction, DeltaTime) == 0x000000, "Member 'HWAIReasonerOption_TickAction::DeltaTime' has a wrong offset!");
static_assert(offsetof(HWAIReasonerOption_TickAction, AIController) == 0x000008, "Member 'HWAIReasonerOption_TickAction::AIController' has a wrong offset!");

// Function Hemingway.HWAISquadManager.AddSquadMember
// 0x0008 (0x0008 - 0x0000)
struct HWAISquadManager_AddSquadMember final
{
public:
	class AHWCharacter_NPC*                       Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_AddSquadMember) == 0x000008, "Wrong alignment on HWAISquadManager_AddSquadMember");
static_assert(sizeof(HWAISquadManager_AddSquadMember) == 0x000008, "Wrong size on HWAISquadManager_AddSquadMember");
static_assert(offsetof(HWAISquadManager_AddSquadMember, Character) == 0x000000, "Member 'HWAISquadManager_AddSquadMember::Character' has a wrong offset!");

// Function Hemingway.HWAISquadManager.GetSquadMemberRelativeLocationAlongRoute
// 0x0020 (0x0020 - 0x0000)
struct HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute) == 0x000008, "Wrong alignment on HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute");
static_assert(sizeof(HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute) == 0x000020, "Wrong size on HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute");
static_assert(offsetof(HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute, Index_0) == 0x000000, "Member 'HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute::Index_0' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute, Direction) == 0x000004, "Member 'HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute::Direction' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute, ReturnValue) == 0x000008, "Member 'HWAISquadManager_GetSquadMemberRelativeLocationAlongRoute::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.OnSquadMemberAdded
// 0x0008 (0x0008 - 0x0000)
struct HWAISquadManager_OnSquadMemberAdded final
{
public:
	class AHWCharacter_NPC*                       Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_OnSquadMemberAdded) == 0x000008, "Wrong alignment on HWAISquadManager_OnSquadMemberAdded");
static_assert(sizeof(HWAISquadManager_OnSquadMemberAdded) == 0x000008, "Wrong size on HWAISquadManager_OnSquadMemberAdded");
static_assert(offsetof(HWAISquadManager_OnSquadMemberAdded, Character) == 0x000000, "Member 'HWAISquadManager_OnSquadMemberAdded::Character' has a wrong offset!");

// Function Hemingway.HWAISquadManager.RemoveSquadMember
// 0x0008 (0x0008 - 0x0000)
struct HWAISquadManager_RemoveSquadMember final
{
public:
	class AHWCharacter_NPC*                       Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_RemoveSquadMember) == 0x000008, "Wrong alignment on HWAISquadManager_RemoveSquadMember");
static_assert(sizeof(HWAISquadManager_RemoveSquadMember) == 0x000008, "Wrong size on HWAISquadManager_RemoveSquadMember");
static_assert(offsetof(HWAISquadManager_RemoveSquadMember, Character) == 0x000000, "Member 'HWAISquadManager_RemoveSquadMember::Character' has a wrong offset!");

// Function Hemingway.HWAISquadManager.AreAllMembersWithinRange
// 0x0020 (0x0020 - 0x0000)
struct HWAISquadManager_AreAllMembersWithinRange final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAISquadManager_AreAllMembersWithinRange) == 0x000008, "Wrong alignment on HWAISquadManager_AreAllMembersWithinRange");
static_assert(sizeof(HWAISquadManager_AreAllMembersWithinRange) == 0x000020, "Wrong size on HWAISquadManager_AreAllMembersWithinRange");
static_assert(offsetof(HWAISquadManager_AreAllMembersWithinRange, Center) == 0x000000, "Member 'HWAISquadManager_AreAllMembersWithinRange::Center' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_AreAllMembersWithinRange, Range) == 0x000018, "Member 'HWAISquadManager_AreAllMembersWithinRange::Range' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_AreAllMembersWithinRange, ReturnValue) == 0x00001C, "Member 'HWAISquadManager_AreAllMembersWithinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.CanMemberPerformSquadTactics
// 0x0010 (0x0010 - 0x0000)
struct HWAISquadManager_CanMemberPerformSquadTactics final
{
public:
	const class AHWCharacter_NPC*                 member;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAISquadManager_CanMemberPerformSquadTactics) == 0x000008, "Wrong alignment on HWAISquadManager_CanMemberPerformSquadTactics");
static_assert(sizeof(HWAISquadManager_CanMemberPerformSquadTactics) == 0x000010, "Wrong size on HWAISquadManager_CanMemberPerformSquadTactics");
static_assert(offsetof(HWAISquadManager_CanMemberPerformSquadTactics, member) == 0x000000, "Member 'HWAISquadManager_CanMemberPerformSquadTactics::member' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_CanMemberPerformSquadTactics, ReturnValue) == 0x000008, "Member 'HWAISquadManager_CanMemberPerformSquadTactics::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.DoesSquadHaveTag
// 0x0028 (0x0028 - 0x0000)
struct HWAISquadManager_DoesSquadHaveTag final
{
public:
	struct FGameplayTagContainer                  TagsToCheck;                                       // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
	bool                                          bCheckAll;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAISquadManager_DoesSquadHaveTag) == 0x000008, "Wrong alignment on HWAISquadManager_DoesSquadHaveTag");
static_assert(sizeof(HWAISquadManager_DoesSquadHaveTag) == 0x000028, "Wrong size on HWAISquadManager_DoesSquadHaveTag");
static_assert(offsetof(HWAISquadManager_DoesSquadHaveTag, TagsToCheck) == 0x000000, "Member 'HWAISquadManager_DoesSquadHaveTag::TagsToCheck' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_DoesSquadHaveTag, bCheckAll) == 0x000020, "Member 'HWAISquadManager_DoesSquadHaveTag::bCheckAll' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_DoesSquadHaveTag, ReturnValue) == 0x000021, "Member 'HWAISquadManager_DoesSquadHaveTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.DoesSquadMemberHaveTag
// 0x0030 (0x0030 - 0x0000)
struct HWAISquadManager_DoesSquadMemberHaveTag final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagsToCheck;                                       // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	bool                                          bCheckAll;                                         // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0029(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAISquadManager_DoesSquadMemberHaveTag) == 0x000008, "Wrong alignment on HWAISquadManager_DoesSquadMemberHaveTag");
static_assert(sizeof(HWAISquadManager_DoesSquadMemberHaveTag) == 0x000030, "Wrong size on HWAISquadManager_DoesSquadMemberHaveTag");
static_assert(offsetof(HWAISquadManager_DoesSquadMemberHaveTag, Index_0) == 0x000000, "Member 'HWAISquadManager_DoesSquadMemberHaveTag::Index_0' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_DoesSquadMemberHaveTag, TagsToCheck) == 0x000008, "Member 'HWAISquadManager_DoesSquadMemberHaveTag::TagsToCheck' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_DoesSquadMemberHaveTag, bCheckAll) == 0x000028, "Member 'HWAISquadManager_DoesSquadMemberHaveTag::bCheckAll' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_DoesSquadMemberHaveTag, ReturnValue) == 0x000029, "Member 'HWAISquadManager_DoesSquadMemberHaveTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.GetBotFactory
// 0x0008 (0x0008 - 0x0000)
struct HWAISquadManager_GetBotFactory final
{
public:
	class AHWBotFactory*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_GetBotFactory) == 0x000008, "Wrong alignment on HWAISquadManager_GetBotFactory");
static_assert(sizeof(HWAISquadManager_GetBotFactory) == 0x000008, "Wrong size on HWAISquadManager_GetBotFactory");
static_assert(offsetof(HWAISquadManager_GetBotFactory, ReturnValue) == 0x000000, "Member 'HWAISquadManager_GetBotFactory::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.GetMembers
// 0x0010 (0x0010 - 0x0000)
struct HWAISquadManager_GetMembers final
{
public:
	TArray<class AHWCharacter_NPC*>               outMembers;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_GetMembers) == 0x000008, "Wrong alignment on HWAISquadManager_GetMembers");
static_assert(sizeof(HWAISquadManager_GetMembers) == 0x000010, "Wrong size on HWAISquadManager_GetMembers");
static_assert(offsetof(HWAISquadManager_GetMembers, outMembers) == 0x000000, "Member 'HWAISquadManager_GetMembers::outMembers' has a wrong offset!");

// Function Hemingway.HWAISquadManager.GetMembersAsActors
// 0x0010 (0x0010 - 0x0000)
struct HWAISquadManager_GetMembersAsActors final
{
public:
	TArray<class AActor*>                         outMembers;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_GetMembersAsActors) == 0x000008, "Wrong alignment on HWAISquadManager_GetMembersAsActors");
static_assert(sizeof(HWAISquadManager_GetMembersAsActors) == 0x000010, "Wrong size on HWAISquadManager_GetMembersAsActors");
static_assert(offsetof(HWAISquadManager_GetMembersAsActors, outMembers) == 0x000000, "Member 'HWAISquadManager_GetMembersAsActors::outMembers' has a wrong offset!");

// Function Hemingway.HWAISquadManager.GetMembersAvgLocation
// 0x0018 (0x0018 - 0x0000)
struct HWAISquadManager_GetMembersAvgLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_GetMembersAvgLocation) == 0x000008, "Wrong alignment on HWAISquadManager_GetMembersAvgLocation");
static_assert(sizeof(HWAISquadManager_GetMembersAvgLocation) == 0x000018, "Wrong size on HWAISquadManager_GetMembersAvgLocation");
static_assert(offsetof(HWAISquadManager_GetMembersAvgLocation, ReturnValue) == 0x000000, "Member 'HWAISquadManager_GetMembersAvgLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.GetSquadLeader
// 0x0008 (0x0008 - 0x0000)
struct HWAISquadManager_GetSquadLeader final
{
public:
	class AHWCharacter_NPC*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_GetSquadLeader) == 0x000008, "Wrong alignment on HWAISquadManager_GetSquadLeader");
static_assert(sizeof(HWAISquadManager_GetSquadLeader) == 0x000008, "Wrong size on HWAISquadManager_GetSquadLeader");
static_assert(offsetof(HWAISquadManager_GetSquadLeader, ReturnValue) == 0x000000, "Member 'HWAISquadManager_GetSquadLeader::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.GetSquadMemberByIndex
// 0x0010 (0x0010 - 0x0000)
struct HWAISquadManager_GetSquadMemberByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWCharacter_NPC*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_GetSquadMemberByIndex) == 0x000008, "Wrong alignment on HWAISquadManager_GetSquadMemberByIndex");
static_assert(sizeof(HWAISquadManager_GetSquadMemberByIndex) == 0x000010, "Wrong size on HWAISquadManager_GetSquadMemberByIndex");
static_assert(offsetof(HWAISquadManager_GetSquadMemberByIndex, Index_0) == 0x000000, "Member 'HWAISquadManager_GetSquadMemberByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_GetSquadMemberByIndex, ReturnValue) == 0x000008, "Member 'HWAISquadManager_GetSquadMemberByIndex::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.GetSquadMemberCombatFormationRelativeLocation
// 0x0020 (0x0020 - 0x0000)
struct HWAISquadManager_GetSquadMemberCombatFormationRelativeLocation final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_GetSquadMemberCombatFormationRelativeLocation) == 0x000008, "Wrong alignment on HWAISquadManager_GetSquadMemberCombatFormationRelativeLocation");
static_assert(sizeof(HWAISquadManager_GetSquadMemberCombatFormationRelativeLocation) == 0x000020, "Wrong size on HWAISquadManager_GetSquadMemberCombatFormationRelativeLocation");
static_assert(offsetof(HWAISquadManager_GetSquadMemberCombatFormationRelativeLocation, Index_0) == 0x000000, "Member 'HWAISquadManager_GetSquadMemberCombatFormationRelativeLocation::Index_0' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_GetSquadMemberCombatFormationRelativeLocation, ReturnValue) == 0x000008, "Member 'HWAISquadManager_GetSquadMemberCombatFormationRelativeLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.GetSquadMemberRelativeLocation
// 0x0020 (0x0020 - 0x0000)
struct HWAISquadManager_GetSquadMemberRelativeLocation final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_GetSquadMemberRelativeLocation) == 0x000008, "Wrong alignment on HWAISquadManager_GetSquadMemberRelativeLocation");
static_assert(sizeof(HWAISquadManager_GetSquadMemberRelativeLocation) == 0x000020, "Wrong size on HWAISquadManager_GetSquadMemberRelativeLocation");
static_assert(offsetof(HWAISquadManager_GetSquadMemberRelativeLocation, Index_0) == 0x000000, "Member 'HWAISquadManager_GetSquadMemberRelativeLocation::Index_0' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_GetSquadMemberRelativeLocation, ReturnValue) == 0x000008, "Member 'HWAISquadManager_GetSquadMemberRelativeLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.GetSquadTeamNum
// 0x0004 (0x0004 - 0x0000)
struct HWAISquadManager_GetSquadTeamNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_GetSquadTeamNum) == 0x000004, "Wrong alignment on HWAISquadManager_GetSquadTeamNum");
static_assert(sizeof(HWAISquadManager_GetSquadTeamNum) == 0x000004, "Wrong size on HWAISquadManager_GetSquadTeamNum");
static_assert(offsetof(HWAISquadManager_GetSquadTeamNum, ReturnValue) == 0x000000, "Member 'HWAISquadManager_GetSquadTeamNum::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.IsMember
// 0x0010 (0x0010 - 0x0000)
struct HWAISquadManager_IsMember final
{
public:
	const class AHWCharacter_NPC*                 Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAISquadManager_IsMember) == 0x000008, "Wrong alignment on HWAISquadManager_IsMember");
static_assert(sizeof(HWAISquadManager_IsMember) == 0x000010, "Wrong size on HWAISquadManager_IsMember");
static_assert(offsetof(HWAISquadManager_IsMember, Character) == 0x000000, "Member 'HWAISquadManager_IsMember::Character' has a wrong offset!");
static_assert(offsetof(HWAISquadManager_IsMember, ReturnValue) == 0x000008, "Member 'HWAISquadManager_IsMember::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.IsMerged
// 0x0001 (0x0001 - 0x0000)
struct HWAISquadManager_IsMerged final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_IsMerged) == 0x000001, "Wrong alignment on HWAISquadManager_IsMerged");
static_assert(sizeof(HWAISquadManager_IsMerged) == 0x000001, "Wrong size on HWAISquadManager_IsMerged");
static_assert(offsetof(HWAISquadManager_IsMerged, ReturnValue) == 0x000000, "Member 'HWAISquadManager_IsMerged::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAISquadManager.IsSquadInCombat
// 0x0001 (0x0001 - 0x0000)
struct HWAISquadManager_IsSquadInCombat final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAISquadManager_IsSquadInCombat) == 0x000001, "Wrong alignment on HWAISquadManager_IsSquadInCombat");
static_assert(sizeof(HWAISquadManager_IsSquadInCombat) == 0x000001, "Wrong size on HWAISquadManager_IsSquadInCombat");
static_assert(offsetof(HWAISquadManager_IsSquadInCombat, ReturnValue) == 0x000000, "Member 'HWAISquadManager_IsSquadInCombat::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.ApplyDynamicSubLevel
// 0x0018 (0x0018 - 0x0000)
struct HWGameState_ApplyDynamicSubLevel final
{
public:
	class UWorld*                                 SubLevel;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWDynamicSubLevelHandle               ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_ApplyDynamicSubLevel) == 0x000008, "Wrong alignment on HWGameState_ApplyDynamicSubLevel");
static_assert(sizeof(HWGameState_ApplyDynamicSubLevel) == 0x000018, "Wrong size on HWGameState_ApplyDynamicSubLevel");
static_assert(offsetof(HWGameState_ApplyDynamicSubLevel, SubLevel) == 0x000000, "Member 'HWGameState_ApplyDynamicSubLevel::SubLevel' has a wrong offset!");
static_assert(offsetof(HWGameState_ApplyDynamicSubLevel, ReturnValue) == 0x000008, "Member 'HWGameState_ApplyDynamicSubLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.ApplyDynamicSubLevelBySoftObjectPtr
// 0x0038 (0x0038 - 0x0000)
struct HWGameState_ApplyDynamicSubLevelBySoftObjectPtr final
{
public:
	TSoftObjectPtr<class UWorld>                  SubLevel;                                          // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWDynamicSubLevelHandle               ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_ApplyDynamicSubLevelBySoftObjectPtr) == 0x000008, "Wrong alignment on HWGameState_ApplyDynamicSubLevelBySoftObjectPtr");
static_assert(sizeof(HWGameState_ApplyDynamicSubLevelBySoftObjectPtr) == 0x000038, "Wrong size on HWGameState_ApplyDynamicSubLevelBySoftObjectPtr");
static_assert(offsetof(HWGameState_ApplyDynamicSubLevelBySoftObjectPtr, SubLevel) == 0x000000, "Member 'HWGameState_ApplyDynamicSubLevelBySoftObjectPtr::SubLevel' has a wrong offset!");
static_assert(offsetof(HWGameState_ApplyDynamicSubLevelBySoftObjectPtr, ReturnValue) == 0x000028, "Member 'HWGameState_ApplyDynamicSubLevelBySoftObjectPtr::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GamePhaseEnding
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GamePhaseEnding final
{
public:
	struct FGameplayTag                           EndingPhase;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GamePhaseEnding) == 0x000004, "Wrong alignment on HWGameState_GamePhaseEnding");
static_assert(sizeof(HWGameState_GamePhaseEnding) == 0x000008, "Wrong size on HWGameState_GamePhaseEnding");
static_assert(offsetof(HWGameState_GamePhaseEnding, EndingPhase) == 0x000000, "Member 'HWGameState_GamePhaseEnding::EndingPhase' has a wrong offset!");

// Function Hemingway.HWGameState.GamePhaseStarting
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GamePhaseStarting final
{
public:
	struct FGameplayTag                           NewPhase;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GamePhaseStarting) == 0x000004, "Wrong alignment on HWGameState_GamePhaseStarting");
static_assert(sizeof(HWGameState_GamePhaseStarting) == 0x000008, "Wrong size on HWGameState_GamePhaseStarting");
static_assert(offsetof(HWGameState_GamePhaseStarting, NewPhase) == 0x000000, "Member 'HWGameState_GamePhaseStarting::NewPhase' has a wrong offset!");

// Function Hemingway.HWGameState.GenerateNextClientOnlyProjectileInstanceId
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_GenerateNextClientOnlyProjectileInstanceId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GenerateNextClientOnlyProjectileInstanceId) == 0x000004, "Wrong alignment on HWGameState_GenerateNextClientOnlyProjectileInstanceId");
static_assert(sizeof(HWGameState_GenerateNextClientOnlyProjectileInstanceId) == 0x000004, "Wrong size on HWGameState_GenerateNextClientOnlyProjectileInstanceId");
static_assert(offsetof(HWGameState_GenerateNextClientOnlyProjectileInstanceId, ReturnValue) == 0x000000, "Member 'HWGameState_GenerateNextClientOnlyProjectileInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GenerateNextProjectileInstanceId
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_GenerateNextProjectileInstanceId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GenerateNextProjectileInstanceId) == 0x000004, "Wrong alignment on HWGameState_GenerateNextProjectileInstanceId");
static_assert(sizeof(HWGameState_GenerateNextProjectileInstanceId) == 0x000004, "Wrong size on HWGameState_GenerateNextProjectileInstanceId");
static_assert(offsetof(HWGameState_GenerateNextProjectileInstanceId, ReturnValue) == 0x000000, "Member 'HWGameState_GenerateNextProjectileInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetTeamCount
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_GetTeamCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetTeamCount) == 0x000004, "Wrong alignment on HWGameState_GetTeamCount");
static_assert(sizeof(HWGameState_GetTeamCount) == 0x000004, "Wrong size on HWGameState_GetTeamCount");
static_assert(offsetof(HWGameState_GetTeamCount, ReturnValue) == 0x000000, "Member 'HWGameState_GetTeamCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetWaypointSet
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetWaypointSet final
{
public:
	class AHWWaypointSet*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetWaypointSet) == 0x000008, "Wrong alignment on HWGameState_GetWaypointSet");
static_assert(sizeof(HWGameState_GetWaypointSet) == 0x000008, "Wrong size on HWGameState_GetWaypointSet");
static_assert(offsetof(HWGameState_GetWaypointSet, ReturnValue) == 0x000000, "Member 'HWGameState_GetWaypointSet::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.HandleTeamKillsUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_HandleTeamKillsUpdated final
{
public:
	class AHWTeamState*                           TeamState;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewTeamKills;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameState_HandleTeamKillsUpdated) == 0x000008, "Wrong alignment on HWGameState_HandleTeamKillsUpdated");
static_assert(sizeof(HWGameState_HandleTeamKillsUpdated) == 0x000010, "Wrong size on HWGameState_HandleTeamKillsUpdated");
static_assert(offsetof(HWGameState_HandleTeamKillsUpdated, TeamState) == 0x000000, "Member 'HWGameState_HandleTeamKillsUpdated::TeamState' has a wrong offset!");
static_assert(offsetof(HWGameState_HandleTeamKillsUpdated, NewTeamKills) == 0x000008, "Member 'HWGameState_HandleTeamKillsUpdated::NewTeamKills' has a wrong offset!");

// Function Hemingway.HWGameState.HandleTeamStatsTrackerReplicated
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_HandleTeamStatsTrackerReplicated final
{
public:
	class AHWTeamState*                           TeamState;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamStatsTracker*                    TeamStatsTracker;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_HandleTeamStatsTrackerReplicated) == 0x000008, "Wrong alignment on HWGameState_HandleTeamStatsTrackerReplicated");
static_assert(sizeof(HWGameState_HandleTeamStatsTrackerReplicated) == 0x000010, "Wrong size on HWGameState_HandleTeamStatsTrackerReplicated");
static_assert(offsetof(HWGameState_HandleTeamStatsTrackerReplicated, TeamState) == 0x000000, "Member 'HWGameState_HandleTeamStatsTrackerReplicated::TeamState' has a wrong offset!");
static_assert(offsetof(HWGameState_HandleTeamStatsTrackerReplicated, TeamStatsTracker) == 0x000008, "Member 'HWGameState_HandleTeamStatsTrackerReplicated::TeamStatsTracker' has a wrong offset!");

// Function Hemingway.HWGameState.MarkAllPlayersConnected
// 0x0001 (0x0001 - 0x0000)
struct HWGameState_MarkAllPlayersConnected final
{
public:
	bool                                          bAreAllConnected;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_MarkAllPlayersConnected) == 0x000001, "Wrong alignment on HWGameState_MarkAllPlayersConnected");
static_assert(sizeof(HWGameState_MarkAllPlayersConnected) == 0x000001, "Wrong size on HWGameState_MarkAllPlayersConnected");
static_assert(offsetof(HWGameState_MarkAllPlayersConnected, bAreAllConnected) == 0x000000, "Member 'HWGameState_MarkAllPlayersConnected::bAreAllConnected' has a wrong offset!");

// Function Hemingway.HWGameState.MulticastNotifyGameFeedEvent
// 0x0028 (0x0028 - 0x0000)
struct HWGameState_MulticastNotifyGameFeedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           EventInstigator;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           Affected;                                          // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        Info;                                              // 0x0018(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_MulticastNotifyGameFeedEvent) == 0x000008, "Wrong alignment on HWGameState_MulticastNotifyGameFeedEvent");
static_assert(sizeof(HWGameState_MulticastNotifyGameFeedEvent) == 0x000028, "Wrong size on HWGameState_MulticastNotifyGameFeedEvent");
static_assert(offsetof(HWGameState_MulticastNotifyGameFeedEvent, EventTag) == 0x000000, "Member 'HWGameState_MulticastNotifyGameFeedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(HWGameState_MulticastNotifyGameFeedEvent, EventInstigator) == 0x000008, "Member 'HWGameState_MulticastNotifyGameFeedEvent::EventInstigator' has a wrong offset!");
static_assert(offsetof(HWGameState_MulticastNotifyGameFeedEvent, Affected) == 0x000010, "Member 'HWGameState_MulticastNotifyGameFeedEvent::Affected' has a wrong offset!");
static_assert(offsetof(HWGameState_MulticastNotifyGameFeedEvent, Info) == 0x000018, "Member 'HWGameState_MulticastNotifyGameFeedEvent::Info' has a wrong offset!");

// Function Hemingway.HWGameState.MulticastPlayerDraftChoiceUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_MulticastPlayerDraftChoiceUpdated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 Choice;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_MulticastPlayerDraftChoiceUpdated) == 0x000008, "Wrong alignment on HWGameState_MulticastPlayerDraftChoiceUpdated");
static_assert(sizeof(HWGameState_MulticastPlayerDraftChoiceUpdated) == 0x000010, "Wrong size on HWGameState_MulticastPlayerDraftChoiceUpdated");
static_assert(offsetof(HWGameState_MulticastPlayerDraftChoiceUpdated, PlayerState) == 0x000000, "Member 'HWGameState_MulticastPlayerDraftChoiceUpdated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWGameState_MulticastPlayerDraftChoiceUpdated, Choice) == 0x000008, "Member 'HWGameState_MulticastPlayerDraftChoiceUpdated::Choice' has a wrong offset!");

// Function Hemingway.HWGameState.MulticastSendGameplayEventToActor
// 0x00C0 (0x00C0 - 0x0000)
struct HWGameState_MulticastSendGameplayEventToActor final
{
public:
	class AActor*                                 EventReciever;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_MulticastSendGameplayEventToActor) == 0x000008, "Wrong alignment on HWGameState_MulticastSendGameplayEventToActor");
static_assert(sizeof(HWGameState_MulticastSendGameplayEventToActor) == 0x0000C0, "Wrong size on HWGameState_MulticastSendGameplayEventToActor");
static_assert(offsetof(HWGameState_MulticastSendGameplayEventToActor, EventReciever) == 0x000000, "Member 'HWGameState_MulticastSendGameplayEventToActor::EventReciever' has a wrong offset!");
static_assert(offsetof(HWGameState_MulticastSendGameplayEventToActor, EventTag) == 0x000008, "Member 'HWGameState_MulticastSendGameplayEventToActor::EventTag' has a wrong offset!");
static_assert(offsetof(HWGameState_MulticastSendGameplayEventToActor, Payload) == 0x000010, "Member 'HWGameState_MulticastSendGameplayEventToActor::Payload' has a wrong offset!");

// Function Hemingway.HWGameState.MulticastUpdatePauseState
// 0x0018 (0x0018 - 0x0000)
struct HWGameState_MulticastUpdatePauseState final
{
public:
	bool                                          bInIsPaused;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWTeamState*                           InPausingTeam;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              InPauseStartTime;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_MulticastUpdatePauseState) == 0x000008, "Wrong alignment on HWGameState_MulticastUpdatePauseState");
static_assert(sizeof(HWGameState_MulticastUpdatePauseState) == 0x000018, "Wrong size on HWGameState_MulticastUpdatePauseState");
static_assert(offsetof(HWGameState_MulticastUpdatePauseState, bInIsPaused) == 0x000000, "Member 'HWGameState_MulticastUpdatePauseState::bInIsPaused' has a wrong offset!");
static_assert(offsetof(HWGameState_MulticastUpdatePauseState, InPausingTeam) == 0x000008, "Member 'HWGameState_MulticastUpdatePauseState::InPausingTeam' has a wrong offset!");
static_assert(offsetof(HWGameState_MulticastUpdatePauseState, InPauseStartTime) == 0x000010, "Member 'HWGameState_MulticastUpdatePauseState::InPauseStartTime' has a wrong offset!");

// Function Hemingway.HWGameState.MulticastUpdateUnpauseDelay
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_MulticastUpdateUnpauseDelay final
{
public:
	int32                                         UnpauseDelayRemaining;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_MulticastUpdateUnpauseDelay) == 0x000004, "Wrong alignment on HWGameState_MulticastUpdateUnpauseDelay");
static_assert(sizeof(HWGameState_MulticastUpdateUnpauseDelay) == 0x000004, "Wrong size on HWGameState_MulticastUpdateUnpauseDelay");
static_assert(offsetof(HWGameState_MulticastUpdateUnpauseDelay, UnpauseDelayRemaining) == 0x000000, "Member 'HWGameState_MulticastUpdateUnpauseDelay::UnpauseDelayRemaining' has a wrong offset!");

// Function Hemingway.HWGameState.OwningClientSendGameplayEventToActor
// 0x00C0 (0x00C0 - 0x0000)
struct HWGameState_OwningClientSendGameplayEventToActor final
{
public:
	class AActor*                                 EventReciever;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_OwningClientSendGameplayEventToActor) == 0x000008, "Wrong alignment on HWGameState_OwningClientSendGameplayEventToActor");
static_assert(sizeof(HWGameState_OwningClientSendGameplayEventToActor) == 0x0000C0, "Wrong size on HWGameState_OwningClientSendGameplayEventToActor");
static_assert(offsetof(HWGameState_OwningClientSendGameplayEventToActor, EventReciever) == 0x000000, "Member 'HWGameState_OwningClientSendGameplayEventToActor::EventReciever' has a wrong offset!");
static_assert(offsetof(HWGameState_OwningClientSendGameplayEventToActor, EventTag) == 0x000008, "Member 'HWGameState_OwningClientSendGameplayEventToActor::EventTag' has a wrong offset!");
static_assert(offsetof(HWGameState_OwningClientSendGameplayEventToActor, Payload) == 0x000010, "Member 'HWGameState_OwningClientSendGameplayEventToActor::Payload' has a wrong offset!");

// Function Hemingway.HWGameState.RemoveDynamicSubLevel
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_RemoveDynamicSubLevel final
{
public:
	struct FHWDynamicSubLevelHandle               LevelHandle;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_RemoveDynamicSubLevel) == 0x000008, "Wrong alignment on HWGameState_RemoveDynamicSubLevel");
static_assert(sizeof(HWGameState_RemoveDynamicSubLevel) == 0x000010, "Wrong size on HWGameState_RemoveDynamicSubLevel");
static_assert(offsetof(HWGameState_RemoveDynamicSubLevel, LevelHandle) == 0x000000, "Member 'HWGameState_RemoveDynamicSubLevel::LevelHandle' has a wrong offset!");

// Function Hemingway.HWGameState.ServerSendGameplayEventToActor
// 0x00C0 (0x00C0 - 0x0000)
struct HWGameState_ServerSendGameplayEventToActor final
{
public:
	class AActor*                                 EventReciever;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_ServerSendGameplayEventToActor) == 0x000008, "Wrong alignment on HWGameState_ServerSendGameplayEventToActor");
static_assert(sizeof(HWGameState_ServerSendGameplayEventToActor) == 0x0000C0, "Wrong size on HWGameState_ServerSendGameplayEventToActor");
static_assert(offsetof(HWGameState_ServerSendGameplayEventToActor, EventReciever) == 0x000000, "Member 'HWGameState_ServerSendGameplayEventToActor::EventReciever' has a wrong offset!");
static_assert(offsetof(HWGameState_ServerSendGameplayEventToActor, EventTag) == 0x000008, "Member 'HWGameState_ServerSendGameplayEventToActor::EventTag' has a wrong offset!");
static_assert(offsetof(HWGameState_ServerSendGameplayEventToActor, Payload) == 0x000010, "Member 'HWGameState_ServerSendGameplayEventToActor::Payload' has a wrong offset!");

// Function Hemingway.HWGameState.SetAbilitiesCanBeCanceledPreFire
// 0x0001 (0x0001 - 0x0000)
struct HWGameState_SetAbilitiesCanBeCanceledPreFire final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_SetAbilitiesCanBeCanceledPreFire) == 0x000001, "Wrong alignment on HWGameState_SetAbilitiesCanBeCanceledPreFire");
static_assert(sizeof(HWGameState_SetAbilitiesCanBeCanceledPreFire) == 0x000001, "Wrong size on HWGameState_SetAbilitiesCanBeCanceledPreFire");
static_assert(offsetof(HWGameState_SetAbilitiesCanBeCanceledPreFire, bOn) == 0x000000, "Member 'HWGameState_SetAbilitiesCanBeCanceledPreFire::bOn' has a wrong offset!");

// Function Hemingway.HWGameState.SetDynamicSubLevelInvisible
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_SetDynamicSubLevelInvisible final
{
public:
	struct FHWDynamicSubLevelHandle               LevelHandle;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_SetDynamicSubLevelInvisible) == 0x000008, "Wrong alignment on HWGameState_SetDynamicSubLevelInvisible");
static_assert(sizeof(HWGameState_SetDynamicSubLevelInvisible) == 0x000010, "Wrong size on HWGameState_SetDynamicSubLevelInvisible");
static_assert(offsetof(HWGameState_SetDynamicSubLevelInvisible, LevelHandle) == 0x000000, "Member 'HWGameState_SetDynamicSubLevelInvisible::LevelHandle' has a wrong offset!");

// Function Hemingway.HWGameState.SetDynamicSubLevelVisible
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_SetDynamicSubLevelVisible final
{
public:
	struct FHWDynamicSubLevelHandle               LevelHandle;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_SetDynamicSubLevelVisible) == 0x000008, "Wrong alignment on HWGameState_SetDynamicSubLevelVisible");
static_assert(sizeof(HWGameState_SetDynamicSubLevelVisible) == 0x000010, "Wrong size on HWGameState_SetDynamicSubLevelVisible");
static_assert(offsetof(HWGameState_SetDynamicSubLevelVisible, LevelHandle) == 0x000000, "Member 'HWGameState_SetDynamicSubLevelVisible::LevelHandle' has a wrong offset!");

// Function Hemingway.HWGameState.SetPauseState
// 0x0018 (0x0018 - 0x0000)
struct HWGameState_SetPauseState final
{
public:
	bool                                          bInIsPaused;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWTeamState*                           InPausingTeam;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              InPauseStartTime;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_SetPauseState) == 0x000008, "Wrong alignment on HWGameState_SetPauseState");
static_assert(sizeof(HWGameState_SetPauseState) == 0x000018, "Wrong size on HWGameState_SetPauseState");
static_assert(offsetof(HWGameState_SetPauseState, bInIsPaused) == 0x000000, "Member 'HWGameState_SetPauseState::bInIsPaused' has a wrong offset!");
static_assert(offsetof(HWGameState_SetPauseState, InPausingTeam) == 0x000008, "Member 'HWGameState_SetPauseState::InPausingTeam' has a wrong offset!");
static_assert(offsetof(HWGameState_SetPauseState, InPauseStartTime) == 0x000010, "Member 'HWGameState_SetPauseState::InPauseStartTime' has a wrong offset!");

// Function Hemingway.HWGameState.TeamCaresAboutObservingOthersInMinimap
// 0x0002 (0x0002 - 0x0000)
struct HWGameState_TeamCaresAboutObservingOthersInMinimap final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_TeamCaresAboutObservingOthersInMinimap) == 0x000001, "Wrong alignment on HWGameState_TeamCaresAboutObservingOthersInMinimap");
static_assert(sizeof(HWGameState_TeamCaresAboutObservingOthersInMinimap) == 0x000002, "Wrong size on HWGameState_TeamCaresAboutObservingOthersInMinimap");
static_assert(offsetof(HWGameState_TeamCaresAboutObservingOthersInMinimap, TeamId) == 0x000000, "Member 'HWGameState_TeamCaresAboutObservingOthersInMinimap::TeamId' has a wrong offset!");
static_assert(offsetof(HWGameState_TeamCaresAboutObservingOthersInMinimap, ReturnValue) == 0x000001, "Member 'HWGameState_TeamCaresAboutObservingOthersInMinimap::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.CanAbilitiesBeCanceledPreFire
// 0x0001 (0x0001 - 0x0000)
struct HWGameState_CanAbilitiesBeCanceledPreFire final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_CanAbilitiesBeCanceledPreFire) == 0x000001, "Wrong alignment on HWGameState_CanAbilitiesBeCanceledPreFire");
static_assert(sizeof(HWGameState_CanAbilitiesBeCanceledPreFire) == 0x000001, "Wrong size on HWGameState_CanAbilitiesBeCanceledPreFire");
static_assert(offsetof(HWGameState_CanAbilitiesBeCanceledPreFire, ReturnValue) == 0x000000, "Member 'HWGameState_CanAbilitiesBeCanceledPreFire::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.CanEarlySurrender
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_CanEarlySurrender final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameState_CanEarlySurrender) == 0x000004, "Wrong alignment on HWGameState_CanEarlySurrender");
static_assert(sizeof(HWGameState_CanEarlySurrender) == 0x000008, "Wrong size on HWGameState_CanEarlySurrender");
static_assert(offsetof(HWGameState_CanEarlySurrender, TeamId) == 0x000000, "Member 'HWGameState_CanEarlySurrender::TeamId' has a wrong offset!");
static_assert(offsetof(HWGameState_CanEarlySurrender, ReturnValue) == 0x000004, "Member 'HWGameState_CanEarlySurrender::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetAladdinArenaManager
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetAladdinArenaManager final
{
public:
	class AHWAladdinArenaManager*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetAladdinArenaManager) == 0x000008, "Wrong alignment on HWGameState_GetAladdinArenaManager");
static_assert(sizeof(HWGameState_GetAladdinArenaManager) == 0x000008, "Wrong size on HWGameState_GetAladdinArenaManager");
static_assert(offsetof(HWGameState_GetAladdinArenaManager, ReturnValue) == 0x000000, "Member 'HWGameState_GetAladdinArenaManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetAllBotFactories
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_GetAllBotFactories final
{
public:
	TArray<class AHWBotFactory*>                  outBotFactories;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetAllBotFactories) == 0x000008, "Wrong alignment on HWGameState_GetAllBotFactories");
static_assert(sizeof(HWGameState_GetAllBotFactories) == 0x000010, "Wrong size on HWGameState_GetAllBotFactories");
static_assert(offsetof(HWGameState_GetAllBotFactories, outBotFactories) == 0x000000, "Member 'HWGameState_GetAllBotFactories::outBotFactories' has a wrong offset!");

// Function Hemingway.HWGameState.GetAllBotFactoriesWithAssetTags
// 0x0098 (0x0098 - 0x0000)
struct HWGameState_GetAllBotFactoriesWithAssetTags final
{
public:
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AHWBotFactory*>                  outFactories;                                      // 0x0088(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetAllBotFactoriesWithAssetTags) == 0x000008, "Wrong alignment on HWGameState_GetAllBotFactoriesWithAssetTags");
static_assert(sizeof(HWGameState_GetAllBotFactoriesWithAssetTags) == 0x000098, "Wrong size on HWGameState_GetAllBotFactoriesWithAssetTags");
static_assert(offsetof(HWGameState_GetAllBotFactoriesWithAssetTags, TagRequirements) == 0x000000, "Member 'HWGameState_GetAllBotFactoriesWithAssetTags::TagRequirements' has a wrong offset!");
static_assert(offsetof(HWGameState_GetAllBotFactoriesWithAssetTags, outFactories) == 0x000088, "Member 'HWGameState_GetAllBotFactoriesWithAssetTags::outFactories' has a wrong offset!");

// Function Hemingway.HWGameState.GetAudioManagerComponent
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetAudioManagerComponent final
{
public:
	class UHWGameAudioManagerComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetAudioManagerComponent) == 0x000008, "Wrong alignment on HWGameState_GetAudioManagerComponent");
static_assert(sizeof(HWGameState_GetAudioManagerComponent) == 0x000008, "Wrong size on HWGameState_GetAudioManagerComponent");
static_assert(offsetof(HWGameState_GetAudioManagerComponent, ReturnValue) == 0x000000, "Member 'HWGameState_GetAudioManagerComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetChatManager
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetChatManager final
{
public:
	class AHWChatManager*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetChatManager) == 0x000008, "Wrong alignment on HWGameState_GetChatManager");
static_assert(sizeof(HWGameState_GetChatManager) == 0x000008, "Wrong size on HWGameState_GetChatManager");
static_assert(offsetof(HWGameState_GetChatManager, ReturnValue) == 0x000000, "Member 'HWGameState_GetChatManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetCurrentGamePhaseTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetCurrentGamePhaseTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetCurrentGamePhaseTag) == 0x000004, "Wrong alignment on HWGameState_GetCurrentGamePhaseTag");
static_assert(sizeof(HWGameState_GetCurrentGamePhaseTag) == 0x000008, "Wrong size on HWGameState_GetCurrentGamePhaseTag");
static_assert(offsetof(HWGameState_GetCurrentGamePhaseTag, ReturnValue) == 0x000000, "Member 'HWGameState_GetCurrentGamePhaseTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetCurrentPhaseConfig
// 0x0058 (0x0058 - 0x0000)
struct HWGameState_GetCurrentPhaseConfig final
{
public:
	struct FHWGamePhaseConfig                     ReturnValue;                                       // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetCurrentPhaseConfig) == 0x000008, "Wrong alignment on HWGameState_GetCurrentPhaseConfig");
static_assert(sizeof(HWGameState_GetCurrentPhaseConfig) == 0x000058, "Wrong size on HWGameState_GetCurrentPhaseConfig");
static_assert(offsetof(HWGameState_GetCurrentPhaseConfig, ReturnValue) == 0x000000, "Member 'HWGameState_GetCurrentPhaseConfig::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetCurrentPhaseDuration
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_GetCurrentPhaseDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetCurrentPhaseDuration) == 0x000004, "Wrong alignment on HWGameState_GetCurrentPhaseDuration");
static_assert(sizeof(HWGameState_GetCurrentPhaseDuration) == 0x000004, "Wrong size on HWGameState_GetCurrentPhaseDuration");
static_assert(offsetof(HWGameState_GetCurrentPhaseDuration, ReturnValue) == 0x000000, "Member 'HWGameState_GetCurrentPhaseDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetCurrentPhaseElapsedTime
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_GetCurrentPhaseElapsedTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetCurrentPhaseElapsedTime) == 0x000004, "Wrong alignment on HWGameState_GetCurrentPhaseElapsedTime");
static_assert(sizeof(HWGameState_GetCurrentPhaseElapsedTime) == 0x000004, "Wrong size on HWGameState_GetCurrentPhaseElapsedTime");
static_assert(offsetof(HWGameState_GetCurrentPhaseElapsedTime, ReturnValue) == 0x000000, "Member 'HWGameState_GetCurrentPhaseElapsedTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetCurrentPhaseRemainingTime
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_GetCurrentPhaseRemainingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetCurrentPhaseRemainingTime) == 0x000004, "Wrong alignment on HWGameState_GetCurrentPhaseRemainingTime");
static_assert(sizeof(HWGameState_GetCurrentPhaseRemainingTime) == 0x000004, "Wrong size on HWGameState_GetCurrentPhaseRemainingTime");
static_assert(offsetof(HWGameState_GetCurrentPhaseRemainingTime, ReturnValue) == 0x000000, "Member 'HWGameState_GetCurrentPhaseRemainingTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetCurrentPhaseStartTime
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_GetCurrentPhaseStartTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetCurrentPhaseStartTime) == 0x000004, "Wrong alignment on HWGameState_GetCurrentPhaseStartTime");
static_assert(sizeof(HWGameState_GetCurrentPhaseStartTime) == 0x000004, "Wrong size on HWGameState_GetCurrentPhaseStartTime");
static_assert(offsetof(HWGameState_GetCurrentPhaseStartTime, ReturnValue) == 0x000000, "Member 'HWGameState_GetCurrentPhaseStartTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetDisplayInfoManager
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetDisplayInfoManager final
{
public:
	class UHWDisplayInfoManager*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetDisplayInfoManager) == 0x000008, "Wrong alignment on HWGameState_GetDisplayInfoManager");
static_assert(sizeof(HWGameState_GetDisplayInfoManager) == 0x000008, "Wrong size on HWGameState_GetDisplayInfoManager");
static_assert(offsetof(HWGameState_GetDisplayInfoManager, ReturnValue) == 0x000000, "Member 'HWGameState_GetDisplayInfoManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetEventManager
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetEventManager final
{
public:
	class AHWEventManager*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetEventManager) == 0x000008, "Wrong alignment on HWGameState_GetEventManager");
static_assert(sizeof(HWGameState_GetEventManager) == 0x000008, "Wrong size on HWGameState_GetEventManager");
static_assert(offsetof(HWGameState_GetEventManager, ReturnValue) == 0x000000, "Member 'HWGameState_GetEventManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetGameStatsTracker
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetGameStatsTracker final
{
public:
	class AHWGameStatsTracker*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetGameStatsTracker) == 0x000008, "Wrong alignment on HWGameState_GetGameStatsTracker");
static_assert(sizeof(HWGameState_GetGameStatsTracker) == 0x000008, "Wrong size on HWGameState_GetGameStatsTracker");
static_assert(offsetof(HWGameState_GetGameStatsTracker, ReturnValue) == 0x000000, "Member 'HWGameState_GetGameStatsTracker::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetHaveAllPlayersInitiallyConnected
// 0x0001 (0x0001 - 0x0000)
struct HWGameState_GetHaveAllPlayersInitiallyConnected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetHaveAllPlayersInitiallyConnected) == 0x000001, "Wrong alignment on HWGameState_GetHaveAllPlayersInitiallyConnected");
static_assert(sizeof(HWGameState_GetHaveAllPlayersInitiallyConnected) == 0x000001, "Wrong size on HWGameState_GetHaveAllPlayersInitiallyConnected");
static_assert(offsetof(HWGameState_GetHaveAllPlayersInitiallyConnected, ReturnValue) == 0x000000, "Member 'HWGameState_GetHaveAllPlayersInitiallyConnected::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetLocalPlayerTeamPlacementOrder
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_GetLocalPlayerTeamPlacementOrder final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetLocalPlayerTeamPlacementOrder) == 0x000004, "Wrong alignment on HWGameState_GetLocalPlayerTeamPlacementOrder");
static_assert(sizeof(HWGameState_GetLocalPlayerTeamPlacementOrder) == 0x000004, "Wrong size on HWGameState_GetLocalPlayerTeamPlacementOrder");
static_assert(offsetof(HWGameState_GetLocalPlayerTeamPlacementOrder, ReturnValue) == 0x000000, "Member 'HWGameState_GetLocalPlayerTeamPlacementOrder::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetMatchActivePhaseTime
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_GetMatchActivePhaseTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetMatchActivePhaseTime) == 0x000004, "Wrong alignment on HWGameState_GetMatchActivePhaseTime");
static_assert(sizeof(HWGameState_GetMatchActivePhaseTime) == 0x000004, "Wrong size on HWGameState_GetMatchActivePhaseTime");
static_assert(offsetof(HWGameState_GetMatchActivePhaseTime, ReturnValue) == 0x000000, "Member 'HWGameState_GetMatchActivePhaseTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetOpposingTeams
// 0x0020 (0x0020 - 0x0000)
struct HWGameState_GetOpposingTeams final
{
public:
	struct FGenericTeamId                         FriendlyTeamId;                                    // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeNeutralTeam;                               // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWTeamState*>                   OutOpposingTeams;                                  // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameState_GetOpposingTeams) == 0x000008, "Wrong alignment on HWGameState_GetOpposingTeams");
static_assert(sizeof(HWGameState_GetOpposingTeams) == 0x000020, "Wrong size on HWGameState_GetOpposingTeams");
static_assert(offsetof(HWGameState_GetOpposingTeams, FriendlyTeamId) == 0x000000, "Member 'HWGameState_GetOpposingTeams::FriendlyTeamId' has a wrong offset!");
static_assert(offsetof(HWGameState_GetOpposingTeams, bIncludeNeutralTeam) == 0x000001, "Member 'HWGameState_GetOpposingTeams::bIncludeNeutralTeam' has a wrong offset!");
static_assert(offsetof(HWGameState_GetOpposingTeams, OutOpposingTeams) == 0x000008, "Member 'HWGameState_GetOpposingTeams::OutOpposingTeams' has a wrong offset!");
static_assert(offsetof(HWGameState_GetOpposingTeams, ReturnValue) == 0x000018, "Member 'HWGameState_GetOpposingTeams::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetPingManager
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetPingManager final
{
public:
	class AHWPingManager*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetPingManager) == 0x000008, "Wrong alignment on HWGameState_GetPingManager");
static_assert(sizeof(HWGameState_GetPingManager) == 0x000008, "Wrong size on HWGameState_GetPingManager");
static_assert(offsetof(HWGameState_GetPingManager, ReturnValue) == 0x000000, "Member 'HWGameState_GetPingManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetPlayer
// 0x0028 (0x0028 - 0x0000)
struct HWGameState_GetPlayer final
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetPlayer) == 0x000008, "Wrong alignment on HWGameState_GetPlayer");
static_assert(sizeof(HWGameState_GetPlayer) == 0x000028, "Wrong size on HWGameState_GetPlayer");
static_assert(offsetof(HWGameState_GetPlayer, PlayerId) == 0x000000, "Member 'HWGameState_GetPlayer::PlayerId' has a wrong offset!");
static_assert(offsetof(HWGameState_GetPlayer, ReturnValue) == 0x000020, "Member 'HWGameState_GetPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetSimulatedProjectile
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_GetSimulatedProjectile final
{
public:
	int32                                         ProjectileId;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWProjectile*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetSimulatedProjectile) == 0x000008, "Wrong alignment on HWGameState_GetSimulatedProjectile");
static_assert(sizeof(HWGameState_GetSimulatedProjectile) == 0x000010, "Wrong size on HWGameState_GetSimulatedProjectile");
static_assert(offsetof(HWGameState_GetSimulatedProjectile, ProjectileId) == 0x000000, "Member 'HWGameState_GetSimulatedProjectile::ProjectileId' has a wrong offset!");
static_assert(offsetof(HWGameState_GetSimulatedProjectile, ReturnValue) == 0x000008, "Member 'HWGameState_GetSimulatedProjectile::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetTeam
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_GetTeam final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWTeamState*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetTeam) == 0x000008, "Wrong alignment on HWGameState_GetTeam");
static_assert(sizeof(HWGameState_GetTeam) == 0x000010, "Wrong size on HWGameState_GetTeam");
static_assert(offsetof(HWGameState_GetTeam, TeamId) == 0x000000, "Member 'HWGameState_GetTeam::TeamId' has a wrong offset!");
static_assert(offsetof(HWGameState_GetTeam, ReturnValue) == 0x000008, "Member 'HWGameState_GetTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetTeamPlacementOrder
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_GetTeamPlacementOrder final
{
public:
	const class APlayerController*                PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameState_GetTeamPlacementOrder) == 0x000008, "Wrong alignment on HWGameState_GetTeamPlacementOrder");
static_assert(sizeof(HWGameState_GetTeamPlacementOrder) == 0x000010, "Wrong size on HWGameState_GetTeamPlacementOrder");
static_assert(offsetof(HWGameState_GetTeamPlacementOrder, PlayerController) == 0x000000, "Member 'HWGameState_GetTeamPlacementOrder::PlayerController' has a wrong offset!");
static_assert(offsetof(HWGameState_GetTeamPlacementOrder, ReturnValue) == 0x000008, "Member 'HWGameState_GetTeamPlacementOrder::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetTeamPlacementOrderWithTeamId
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetTeamPlacementOrderWithTeamId final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetTeamPlacementOrderWithTeamId) == 0x000004, "Wrong alignment on HWGameState_GetTeamPlacementOrderWithTeamId");
static_assert(sizeof(HWGameState_GetTeamPlacementOrderWithTeamId) == 0x000008, "Wrong size on HWGameState_GetTeamPlacementOrderWithTeamId");
static_assert(offsetof(HWGameState_GetTeamPlacementOrderWithTeamId, TeamId) == 0x000000, "Member 'HWGameState_GetTeamPlacementOrderWithTeamId::TeamId' has a wrong offset!");
static_assert(offsetof(HWGameState_GetTeamPlacementOrderWithTeamId, ReturnValue) == 0x000004, "Member 'HWGameState_GetTeamPlacementOrderWithTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetTeams
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_GetTeams final
{
public:
	TArray<class AHWTeamState*>                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetTeams) == 0x000008, "Wrong alignment on HWGameState_GetTeams");
static_assert(sizeof(HWGameState_GetTeams) == 0x000010, "Wrong size on HWGameState_GetTeams");
static_assert(offsetof(HWGameState_GetTeams, ReturnValue) == 0x000000, "Member 'HWGameState_GetTeams::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetTransitionInfoTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetTransitionInfoTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetTransitionInfoTag) == 0x000004, "Wrong alignment on HWGameState_GetTransitionInfoTag");
static_assert(sizeof(HWGameState_GetTransitionInfoTag) == 0x000008, "Wrong size on HWGameState_GetTransitionInfoTag");
static_assert(offsetof(HWGameState_GetTransitionInfoTag, ReturnValue) == 0x000000, "Member 'HWGameState_GetTransitionInfoTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.GetVGSManager
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_GetVGSManager final
{
public:
	class AHWVGSManager*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_GetVGSManager) == 0x000008, "Wrong alignment on HWGameState_GetVGSManager");
static_assert(sizeof(HWGameState_GetVGSManager) == 0x000008, "Wrong size on HWGameState_GetVGSManager");
static_assert(offsetof(HWGameState_GetVGSManager, ReturnValue) == 0x000000, "Member 'HWGameState_GetVGSManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.IsDyanmicSubLevelVisible
// 0x0018 (0x0018 - 0x0000)
struct HWGameState_IsDyanmicSubLevelVisible final
{
public:
	struct FHWDynamicSubLevelHandle               LevelHandle;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameState_IsDyanmicSubLevelVisible) == 0x000008, "Wrong alignment on HWGameState_IsDyanmicSubLevelVisible");
static_assert(sizeof(HWGameState_IsDyanmicSubLevelVisible) == 0x000018, "Wrong size on HWGameState_IsDyanmicSubLevelVisible");
static_assert(offsetof(HWGameState_IsDyanmicSubLevelVisible, LevelHandle) == 0x000000, "Member 'HWGameState_IsDyanmicSubLevelVisible::LevelHandle' has a wrong offset!");
static_assert(offsetof(HWGameState_IsDyanmicSubLevelVisible, ReturnValue) == 0x000010, "Member 'HWGameState_IsDyanmicSubLevelVisible::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.IsDynamicSubLevelLoaded
// 0x0018 (0x0018 - 0x0000)
struct HWGameState_IsDynamicSubLevelLoaded final
{
public:
	struct FHWDynamicSubLevelHandle               LevelHandle;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameState_IsDynamicSubLevelLoaded) == 0x000008, "Wrong alignment on HWGameState_IsDynamicSubLevelLoaded");
static_assert(sizeof(HWGameState_IsDynamicSubLevelLoaded) == 0x000018, "Wrong size on HWGameState_IsDynamicSubLevelLoaded");
static_assert(offsetof(HWGameState_IsDynamicSubLevelLoaded, LevelHandle) == 0x000000, "Member 'HWGameState_IsDynamicSubLevelLoaded::LevelHandle' has a wrong offset!");
static_assert(offsetof(HWGameState_IsDynamicSubLevelLoaded, ReturnValue) == 0x000010, "Member 'HWGameState_IsDynamicSubLevelLoaded::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.IsMatchDeserted
// 0x0001 (0x0001 - 0x0000)
struct HWGameState_IsMatchDeserted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_IsMatchDeserted) == 0x000001, "Wrong alignment on HWGameState_IsMatchDeserted");
static_assert(sizeof(HWGameState_IsMatchDeserted) == 0x000001, "Wrong size on HWGameState_IsMatchDeserted");
static_assert(offsetof(HWGameState_IsMatchDeserted, ReturnValue) == 0x000000, "Member 'HWGameState_IsMatchDeserted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState.IsTutorialAnnouncementsEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWGameState_IsTutorialAnnouncementsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_IsTutorialAnnouncementsEnabled) == 0x000001, "Wrong alignment on HWGameState_IsTutorialAnnouncementsEnabled");
static_assert(sizeof(HWGameState_IsTutorialAnnouncementsEnabled) == 0x000001, "Wrong size on HWGameState_IsTutorialAnnouncementsEnabled");
static_assert(offsetof(HWGameState_IsTutorialAnnouncementsEnabled, ReturnValue) == 0x000000, "Member 'HWGameState_IsTutorialAnnouncementsEnabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState_DraftLobby.CharacterSwapRequestTimedOut
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_DraftLobby_CharacterSwapRequestTimedOut final
{
public:
	struct FPGame_ReplicatedTimerId               InTimerId;                                         // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TradeId;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_DraftLobby_CharacterSwapRequestTimedOut) == 0x000004, "Wrong alignment on HWGameState_DraftLobby_CharacterSwapRequestTimedOut");
static_assert(sizeof(HWGameState_DraftLobby_CharacterSwapRequestTimedOut) == 0x000008, "Wrong size on HWGameState_DraftLobby_CharacterSwapRequestTimedOut");
static_assert(offsetof(HWGameState_DraftLobby_CharacterSwapRequestTimedOut, InTimerId) == 0x000000, "Member 'HWGameState_DraftLobby_CharacterSwapRequestTimedOut::InTimerId' has a wrong offset!");
static_assert(offsetof(HWGameState_DraftLobby_CharacterSwapRequestTimedOut, TradeId) == 0x000004, "Member 'HWGameState_DraftLobby_CharacterSwapRequestTimedOut::TradeId' has a wrong offset!");

// Function Hemingway.HWGameState_DraftLobby.RoleSwapRequestTimedOut
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_DraftLobby_RoleSwapRequestTimedOut final
{
public:
	struct FPGame_ReplicatedTimerId               InTimerId;                                         // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TradeId;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_DraftLobby_RoleSwapRequestTimedOut) == 0x000004, "Wrong alignment on HWGameState_DraftLobby_RoleSwapRequestTimedOut");
static_assert(sizeof(HWGameState_DraftLobby_RoleSwapRequestTimedOut) == 0x000008, "Wrong size on HWGameState_DraftLobby_RoleSwapRequestTimedOut");
static_assert(offsetof(HWGameState_DraftLobby_RoleSwapRequestTimedOut, InTimerId) == 0x000000, "Member 'HWGameState_DraftLobby_RoleSwapRequestTimedOut::InTimerId' has a wrong offset!");
static_assert(offsetof(HWGameState_DraftLobby_RoleSwapRequestTimedOut, TradeId) == 0x000004, "Member 'HWGameState_DraftLobby_RoleSwapRequestTimedOut::TradeId' has a wrong offset!");

// Function Hemingway.HWGameState_DraftLobby.ServerRequestRole
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_DraftLobby_ServerRequestRole final
{
public:
	class AHWPlayerState*                         RequestingPlayerState;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterRole                                CharacterRole;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameState_DraftLobby_ServerRequestRole) == 0x000008, "Wrong alignment on HWGameState_DraftLobby_ServerRequestRole");
static_assert(sizeof(HWGameState_DraftLobby_ServerRequestRole) == 0x000010, "Wrong size on HWGameState_DraftLobby_ServerRequestRole");
static_assert(offsetof(HWGameState_DraftLobby_ServerRequestRole, RequestingPlayerState) == 0x000000, "Member 'HWGameState_DraftLobby_ServerRequestRole::RequestingPlayerState' has a wrong offset!");
static_assert(offsetof(HWGameState_DraftLobby_ServerRequestRole, CharacterRole) == 0x000008, "Member 'HWGameState_DraftLobby_ServerRequestRole::CharacterRole' has a wrong offset!");

// Function Hemingway.HWAITugOfWarManager.CalculateFormationLocation
// 0x0028 (0x0028 - 0x0000)
struct HWAITugOfWarManager_CalculateFormationLocation final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RoleTag;                                           // 0x0004(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OutFormationOffset;                                // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAITugOfWarManager_CalculateFormationLocation) == 0x000008, "Wrong alignment on HWAITugOfWarManager_CalculateFormationLocation");
static_assert(sizeof(HWAITugOfWarManager_CalculateFormationLocation) == 0x000028, "Wrong size on HWAITugOfWarManager_CalculateFormationLocation");
static_assert(offsetof(HWAITugOfWarManager_CalculateFormationLocation, Team) == 0x000000, "Member 'HWAITugOfWarManager_CalculateFormationLocation::Team' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_CalculateFormationLocation, RoleTag) == 0x000004, "Member 'HWAITugOfWarManager_CalculateFormationLocation::RoleTag' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_CalculateFormationLocation, OutFormationOffset) == 0x000010, "Member 'HWAITugOfWarManager_CalculateFormationLocation::OutFormationOffset' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_CalculateFormationLocation, ReturnValue) == 0x000020, "Member 'HWAITugOfWarManager_CalculateFormationLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAITugOfWarManager.CalculateFormationLocationWithForwardOffset
// 0x0028 (0x0028 - 0x0000)
struct HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RoleTag;                                           // 0x0004(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardOffset;                                     // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OutFormationOffset;                                // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset) == 0x000008, "Wrong alignment on HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset");
static_assert(sizeof(HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset) == 0x000028, "Wrong size on HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset");
static_assert(offsetof(HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset, Team) == 0x000000, "Member 'HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset::Team' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset, RoleTag) == 0x000004, "Member 'HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset::RoleTag' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset, ForwardOffset) == 0x00000C, "Member 'HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset::ForwardOffset' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset, OutFormationOffset) == 0x000010, "Member 'HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset::OutFormationOffset' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset, ReturnValue) == 0x000020, "Member 'HWAITugOfWarManager_CalculateFormationLocationWithForwardOffset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAITugOfWarManager.GetCharacterDistanceFromFront
// 0x0010 (0x0010 - 0x0000)
struct HWAITugOfWarManager_GetCharacterDistanceFromFront final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAITugOfWarManager_GetCharacterDistanceFromFront) == 0x000008, "Wrong alignment on HWAITugOfWarManager_GetCharacterDistanceFromFront");
static_assert(sizeof(HWAITugOfWarManager_GetCharacterDistanceFromFront) == 0x000010, "Wrong size on HWAITugOfWarManager_GetCharacterDistanceFromFront");
static_assert(offsetof(HWAITugOfWarManager_GetCharacterDistanceFromFront, Character) == 0x000000, "Member 'HWAITugOfWarManager_GetCharacterDistanceFromFront::Character' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_GetCharacterDistanceFromFront, ReturnValue) == 0x000008, "Member 'HWAITugOfWarManager_GetCharacterDistanceFromFront::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAITugOfWarManager.GetSafeZoneForTeam
// 0x0030 (0x0030 - 0x0000)
struct HWAITugOfWarManager_GetSafeZoneForTeam final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OutMinBounds;                                      // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OutMaxBounds;                                      // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAITugOfWarManager_GetSafeZoneForTeam) == 0x000008, "Wrong alignment on HWAITugOfWarManager_GetSafeZoneForTeam");
static_assert(sizeof(HWAITugOfWarManager_GetSafeZoneForTeam) == 0x000030, "Wrong size on HWAITugOfWarManager_GetSafeZoneForTeam");
static_assert(offsetof(HWAITugOfWarManager_GetSafeZoneForTeam, Team) == 0x000000, "Member 'HWAITugOfWarManager_GetSafeZoneForTeam::Team' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_GetSafeZoneForTeam, OutMinBounds) == 0x000008, "Member 'HWAITugOfWarManager_GetSafeZoneForTeam::OutMinBounds' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_GetSafeZoneForTeam, OutMaxBounds) == 0x000018, "Member 'HWAITugOfWarManager_GetSafeZoneForTeam::OutMaxBounds' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_GetSafeZoneForTeam, ReturnValue) == 0x000028, "Member 'HWAITugOfWarManager_GetSafeZoneForTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAITugOfWarManager.GetSafeZoneFrontForTeam
// 0x0020 (0x0020 - 0x0000)
struct HWAITugOfWarManager_GetSafeZoneFrontForTeam final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OutFrontLocation;                                  // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAITugOfWarManager_GetSafeZoneFrontForTeam) == 0x000008, "Wrong alignment on HWAITugOfWarManager_GetSafeZoneFrontForTeam");
static_assert(sizeof(HWAITugOfWarManager_GetSafeZoneFrontForTeam) == 0x000020, "Wrong size on HWAITugOfWarManager_GetSafeZoneFrontForTeam");
static_assert(offsetof(HWAITugOfWarManager_GetSafeZoneFrontForTeam, Team) == 0x000000, "Member 'HWAITugOfWarManager_GetSafeZoneFrontForTeam::Team' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_GetSafeZoneFrontForTeam, OutFrontLocation) == 0x000008, "Member 'HWAITugOfWarManager_GetSafeZoneFrontForTeam::OutFrontLocation' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_GetSafeZoneFrontForTeam, ReturnValue) == 0x000018, "Member 'HWAITugOfWarManager_GetSafeZoneFrontForTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAITugOfWarManager.GetTugOfWarValue
// 0x0008 (0x0008 - 0x0000)
struct HWAITugOfWarManager_GetTugOfWarValue final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAITugOfWarManager_GetTugOfWarValue) == 0x000004, "Wrong alignment on HWAITugOfWarManager_GetTugOfWarValue");
static_assert(sizeof(HWAITugOfWarManager_GetTugOfWarValue) == 0x000008, "Wrong size on HWAITugOfWarManager_GetTugOfWarValue");
static_assert(offsetof(HWAITugOfWarManager_GetTugOfWarValue, Team) == 0x000000, "Member 'HWAITugOfWarManager_GetTugOfWarValue::Team' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_GetTugOfWarValue, ReturnValue) == 0x000004, "Member 'HWAITugOfWarManager_GetTugOfWarValue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAITugOfWarManager.IsCharacterSafe
// 0x0010 (0x0010 - 0x0000)
struct HWAITugOfWarManager_IsCharacterSafe final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAITugOfWarManager_IsCharacterSafe) == 0x000008, "Wrong alignment on HWAITugOfWarManager_IsCharacterSafe");
static_assert(sizeof(HWAITugOfWarManager_IsCharacterSafe) == 0x000010, "Wrong size on HWAITugOfWarManager_IsCharacterSafe");
static_assert(offsetof(HWAITugOfWarManager_IsCharacterSafe, Character) == 0x000000, "Member 'HWAITugOfWarManager_IsCharacterSafe::Character' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_IsCharacterSafe, ReturnValue) == 0x000008, "Member 'HWAITugOfWarManager_IsCharacterSafe::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAITugOfWarManager.IsLocationInSafeZoneForTeam
// 0x0020 (0x0020 - 0x0000)
struct HWAITugOfWarManager_IsLocationInSafeZoneForTeam final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         Team;                                              // 0x0018(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAITugOfWarManager_IsLocationInSafeZoneForTeam) == 0x000008, "Wrong alignment on HWAITugOfWarManager_IsLocationInSafeZoneForTeam");
static_assert(sizeof(HWAITugOfWarManager_IsLocationInSafeZoneForTeam) == 0x000020, "Wrong size on HWAITugOfWarManager_IsLocationInSafeZoneForTeam");
static_assert(offsetof(HWAITugOfWarManager_IsLocationInSafeZoneForTeam, Location) == 0x000000, "Member 'HWAITugOfWarManager_IsLocationInSafeZoneForTeam::Location' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_IsLocationInSafeZoneForTeam, Team) == 0x000018, "Member 'HWAITugOfWarManager_IsLocationInSafeZoneForTeam::Team' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_IsLocationInSafeZoneForTeam, ReturnValue) == 0x000019, "Member 'HWAITugOfWarManager_IsLocationInSafeZoneForTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAITugOfWarManager.ProjectCharacterLocationToSafeDistance
// 0x0028 (0x0028 - 0x0000)
struct HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance final
{
public:
	const class AHWCharacter_Base*                Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceBuffer;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance) == 0x000008, "Wrong alignment on HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance");
static_assert(sizeof(HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance) == 0x000028, "Wrong size on HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance");
static_assert(offsetof(HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance, Character) == 0x000000, "Member 'HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance::Character' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance, DistanceBuffer) == 0x000008, "Member 'HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance::DistanceBuffer' has a wrong offset!");
static_assert(offsetof(HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance, ReturnValue) == 0x000010, "Member 'HWAITugOfWarManager_ProjectCharacterLocationToSafeDistance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAnimInst_Danzaburou_A01_Deployable.FlipPlayrate
// 0x0100 (0x0100 - 0x0000)
struct HWAnimInst_Danzaburou_A01_Deployable_FlipPlayrate final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x00E8(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAnimInst_Danzaburou_A01_Deployable_FlipPlayrate) == 0x000008, "Wrong alignment on HWAnimInst_Danzaburou_A01_Deployable_FlipPlayrate");
static_assert(sizeof(HWAnimInst_Danzaburou_A01_Deployable_FlipPlayrate) == 0x000100, "Wrong size on HWAnimInst_Danzaburou_A01_Deployable_FlipPlayrate");
static_assert(offsetof(HWAnimInst_Danzaburou_A01_Deployable_FlipPlayrate, ImpactResult) == 0x000000, "Member 'HWAnimInst_Danzaburou_A01_Deployable_FlipPlayrate::ImpactResult' has a wrong offset!");
static_assert(offsetof(HWAnimInst_Danzaburou_A01_Deployable_FlipPlayrate, ImpactVelocity) == 0x0000E8, "Member 'HWAnimInst_Danzaburou_A01_Deployable_FlipPlayrate::ImpactVelocity' has a wrong offset!");

// Function Hemingway.HWGameplayLevitate.bIsUsingCustomProfile
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayLevitate_bIsUsingCustomProfile final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayLevitate_bIsUsingCustomProfile) == 0x000001, "Wrong alignment on HWGameplayLevitate_bIsUsingCustomProfile");
static_assert(sizeof(HWGameplayLevitate_bIsUsingCustomProfile) == 0x000001, "Wrong size on HWGameplayLevitate_bIsUsingCustomProfile");
static_assert(offsetof(HWGameplayLevitate_bIsUsingCustomProfile, ReturnValue) == 0x000000, "Member 'HWGameplayLevitate_bIsUsingCustomProfile::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayLevitate.OnAscentTweenEnded
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayLevitate_OnAscentTweenEnded final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayLevitate_OnAscentTweenEnded) == 0x000008, "Wrong alignment on HWGameplayLevitate_OnAscentTweenEnded");
static_assert(sizeof(HWGameplayLevitate_OnAscentTweenEnded) == 0x000018, "Wrong size on HWGameplayLevitate_OnAscentTweenEnded");
static_assert(offsetof(HWGameplayLevitate_OnAscentTweenEnded, TweenInstance) == 0x000000, "Member 'HWGameplayLevitate_OnAscentTweenEnded::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWGameplayLevitate_OnAscentTweenEnded, TweenTarget) == 0x000008, "Member 'HWGameplayLevitate_OnAscentTweenEnded::TweenTarget' has a wrong offset!");
static_assert(offsetof(HWGameplayLevitate_OnAscentTweenEnded, EndTweenReason) == 0x000010, "Member 'HWGameplayLevitate_OnAscentTweenEnded::EndTweenReason' has a wrong offset!");

// Function Hemingway.HWGameplayLevitate.OnAscentTweenStarted
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayLevitate_OnAscentTweenStarted final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayLevitate_OnAscentTweenStarted) == 0x000008, "Wrong alignment on HWGameplayLevitate_OnAscentTweenStarted");
static_assert(sizeof(HWGameplayLevitate_OnAscentTweenStarted) == 0x000010, "Wrong size on HWGameplayLevitate_OnAscentTweenStarted");
static_assert(offsetof(HWGameplayLevitate_OnAscentTweenStarted, TweenInstance) == 0x000000, "Member 'HWGameplayLevitate_OnAscentTweenStarted::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWGameplayLevitate_OnAscentTweenStarted, TweenTarget) == 0x000008, "Member 'HWGameplayLevitate_OnAscentTweenStarted::TweenTarget' has a wrong offset!");

// Function Hemingway.HWGameplayLevitate.OnDescentTweenEnded
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayLevitate_OnDescentTweenEnded final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayLevitate_OnDescentTweenEnded) == 0x000008, "Wrong alignment on HWGameplayLevitate_OnDescentTweenEnded");
static_assert(sizeof(HWGameplayLevitate_OnDescentTweenEnded) == 0x000018, "Wrong size on HWGameplayLevitate_OnDescentTweenEnded");
static_assert(offsetof(HWGameplayLevitate_OnDescentTweenEnded, TweenInstance) == 0x000000, "Member 'HWGameplayLevitate_OnDescentTweenEnded::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWGameplayLevitate_OnDescentTweenEnded, TweenTarget) == 0x000008, "Member 'HWGameplayLevitate_OnDescentTweenEnded::TweenTarget' has a wrong offset!");
static_assert(offsetof(HWGameplayLevitate_OnDescentTweenEnded, EndTweenReason) == 0x000010, "Member 'HWGameplayLevitate_OnDescentTweenEnded::EndTweenReason' has a wrong offset!");

// Function Hemingway.HWGameplayLevitate.OnDescentTweenStarted
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayLevitate_OnDescentTweenStarted final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayLevitate_OnDescentTweenStarted) == 0x000008, "Wrong alignment on HWGameplayLevitate_OnDescentTweenStarted");
static_assert(sizeof(HWGameplayLevitate_OnDescentTweenStarted) == 0x000010, "Wrong size on HWGameplayLevitate_OnDescentTweenStarted");
static_assert(offsetof(HWGameplayLevitate_OnDescentTweenStarted, TweenInstance) == 0x000000, "Member 'HWGameplayLevitate_OnDescentTweenStarted::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWGameplayLevitate_OnDescentTweenStarted, TweenTarget) == 0x000008, "Member 'HWGameplayLevitate_OnDescentTweenStarted::TweenTarget' has a wrong offset!");

// Function Hemingway.HWGameplayLevitate.DoesAllowCleansingLevitate
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayLevitate_DoesAllowCleansingLevitate final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayLevitate_DoesAllowCleansingLevitate) == 0x000001, "Wrong alignment on HWGameplayLevitate_DoesAllowCleansingLevitate");
static_assert(sizeof(HWGameplayLevitate_DoesAllowCleansingLevitate) == 0x000001, "Wrong size on HWGameplayLevitate_DoesAllowCleansingLevitate");
static_assert(offsetof(HWGameplayLevitate_DoesAllowCleansingLevitate, ReturnValue) == 0x000000, "Member 'HWGameplayLevitate_DoesAllowCleansingLevitate::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayLevitate.GetLevitationIdTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayLevitate_GetLevitationIdTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayLevitate_GetLevitationIdTag) == 0x000004, "Wrong alignment on HWGameplayLevitate_GetLevitationIdTag");
static_assert(sizeof(HWGameplayLevitate_GetLevitationIdTag) == 0x000008, "Wrong size on HWGameplayLevitate_GetLevitationIdTag");
static_assert(offsetof(HWGameplayLevitate_GetLevitationIdTag, ReturnValue) == 0x000000, "Member 'HWGameplayLevitate_GetLevitationIdTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAudioSubsystem.AddAudioComponent
// 0x0018 (0x0018 - 0x0000)
struct HWAudioSubsystem_AddAudioComponent final
{
public:
	struct FGameplayTag                           ComponentTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        AudioComponent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAudioSubsystem_AddAudioComponent) == 0x000008, "Wrong alignment on HWAudioSubsystem_AddAudioComponent");
static_assert(sizeof(HWAudioSubsystem_AddAudioComponent) == 0x000018, "Wrong size on HWAudioSubsystem_AddAudioComponent");
static_assert(offsetof(HWAudioSubsystem_AddAudioComponent, ComponentTag) == 0x000000, "Member 'HWAudioSubsystem_AddAudioComponent::ComponentTag' has a wrong offset!");
static_assert(offsetof(HWAudioSubsystem_AddAudioComponent, AudioComponent) == 0x000008, "Member 'HWAudioSubsystem_AddAudioComponent::AudioComponent' has a wrong offset!");
static_assert(offsetof(HWAudioSubsystem_AddAudioComponent, ReturnValue) == 0x000010, "Member 'HWAudioSubsystem_AddAudioComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAudioSubsystem.PlayMusicTrack
// 0x0038 (0x0038 - 0x0000)
struct HWAudioSubsystem_PlayMusicTrack final
{
public:
	struct FHWAudioTrackPlayInfo                  TrackPlayInfo;                                     // 0x0000(0x0024)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWMusicPackItem*                 MusicPack;                                         // 0x0028(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAudioSubsystem_PlayMusicTrack) == 0x000008, "Wrong alignment on HWAudioSubsystem_PlayMusicTrack");
static_assert(sizeof(HWAudioSubsystem_PlayMusicTrack) == 0x000038, "Wrong size on HWAudioSubsystem_PlayMusicTrack");
static_assert(offsetof(HWAudioSubsystem_PlayMusicTrack, TrackPlayInfo) == 0x000000, "Member 'HWAudioSubsystem_PlayMusicTrack::TrackPlayInfo' has a wrong offset!");
static_assert(offsetof(HWAudioSubsystem_PlayMusicTrack, MusicPack) == 0x000028, "Member 'HWAudioSubsystem_PlayMusicTrack::MusicPack' has a wrong offset!");
static_assert(offsetof(HWAudioSubsystem_PlayMusicTrack, ReturnValue) == 0x000030, "Member 'HWAudioSubsystem_PlayMusicTrack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAudioSubsystem.PlayStinger
// 0x0038 (0x0038 - 0x0000)
struct HWAudioSubsystem_PlayStinger final
{
public:
	struct FHWAudioStingerPlayInfo                StingerPlayInfo;                                   // 0x0000(0x002C)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAudioSubsystem_PlayStinger) == 0x000008, "Wrong alignment on HWAudioSubsystem_PlayStinger");
static_assert(sizeof(HWAudioSubsystem_PlayStinger) == 0x000038, "Wrong size on HWAudioSubsystem_PlayStinger");
static_assert(offsetof(HWAudioSubsystem_PlayStinger, StingerPlayInfo) == 0x000000, "Member 'HWAudioSubsystem_PlayStinger::StingerPlayInfo' has a wrong offset!");
static_assert(offsetof(HWAudioSubsystem_PlayStinger, ReturnValue) == 0x000030, "Member 'HWAudioSubsystem_PlayStinger::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAudioSubsystem.PlayVOAnnouncement
// 0x0028 (0x0028 - 0x0000)
struct HWAudioSubsystem_PlayVOAnnouncement final
{
public:
	struct FAssetRequestKey                       AnnouncementAssetKey;                              // 0x0000(0x001C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAudioSubsystem_PlayVOAnnouncement) == 0x000008, "Wrong alignment on HWAudioSubsystem_PlayVOAnnouncement");
static_assert(sizeof(HWAudioSubsystem_PlayVOAnnouncement) == 0x000028, "Wrong size on HWAudioSubsystem_PlayVOAnnouncement");
static_assert(offsetof(HWAudioSubsystem_PlayVOAnnouncement, AnnouncementAssetKey) == 0x000000, "Member 'HWAudioSubsystem_PlayVOAnnouncement::AnnouncementAssetKey' has a wrong offset!");
static_assert(offsetof(HWAudioSubsystem_PlayVOAnnouncement, ReturnValue) == 0x000020, "Member 'HWAudioSubsystem_PlayVOAnnouncement::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAudioSubsystem.RemoveAudioComponent
// 0x000C (0x000C - 0x0000)
struct HWAudioSubsystem_RemoveAudioComponent final
{
public:
	struct FGameplayTag                           ComponentTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAudioSubsystem_RemoveAudioComponent) == 0x000004, "Wrong alignment on HWAudioSubsystem_RemoveAudioComponent");
static_assert(sizeof(HWAudioSubsystem_RemoveAudioComponent) == 0x00000C, "Wrong size on HWAudioSubsystem_RemoveAudioComponent");
static_assert(offsetof(HWAudioSubsystem_RemoveAudioComponent, ComponentTag) == 0x000000, "Member 'HWAudioSubsystem_RemoveAudioComponent::ComponentTag' has a wrong offset!");
static_assert(offsetof(HWAudioSubsystem_RemoveAudioComponent, ReturnValue) == 0x000008, "Member 'HWAudioSubsystem_RemoveAudioComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAudioSubsystem.DoesAudioComponentExist
// 0x000C (0x000C - 0x0000)
struct HWAudioSubsystem_DoesAudioComponentExist final
{
public:
	struct FGameplayTag                           ComponentTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAudioSubsystem_DoesAudioComponentExist) == 0x000004, "Wrong alignment on HWAudioSubsystem_DoesAudioComponentExist");
static_assert(sizeof(HWAudioSubsystem_DoesAudioComponentExist) == 0x00000C, "Wrong size on HWAudioSubsystem_DoesAudioComponentExist");
static_assert(offsetof(HWAudioSubsystem_DoesAudioComponentExist, ComponentTag) == 0x000000, "Member 'HWAudioSubsystem_DoesAudioComponentExist::ComponentTag' has a wrong offset!");
static_assert(offsetof(HWAudioSubsystem_DoesAudioComponentExist, ReturnValue) == 0x000008, "Member 'HWAudioSubsystem_DoesAudioComponentExist::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAudioSubsystem.GetAudioComponent
// 0x0010 (0x0010 - 0x0000)
struct HWAudioSubsystem_GetAudioComponent final
{
public:
	struct FGameplayTag                           ComponentTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAudioSubsystem_GetAudioComponent) == 0x000008, "Wrong alignment on HWAudioSubsystem_GetAudioComponent");
static_assert(sizeof(HWAudioSubsystem_GetAudioComponent) == 0x000010, "Wrong size on HWAudioSubsystem_GetAudioComponent");
static_assert(offsetof(HWAudioSubsystem_GetAudioComponent, ComponentTag) == 0x000000, "Member 'HWAudioSubsystem_GetAudioComponent::ComponentTag' has a wrong offset!");
static_assert(offsetof(HWAudioSubsystem_GetAudioComponent, ReturnValue) == 0x000008, "Member 'HWAudioSubsystem_GetAudioComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Bari_BellRicochetAiming.GetBariBellToShoot
// 0x0010 (0x0010 - 0x0000)
struct HWInterface_Bari_BellRicochetAiming_GetBariBellToShoot final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWDeployable_Bari_A01*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Bari_BellRicochetAiming_GetBariBellToShoot) == 0x000008, "Wrong alignment on HWInterface_Bari_BellRicochetAiming_GetBariBellToShoot");
static_assert(sizeof(HWInterface_Bari_BellRicochetAiming_GetBariBellToShoot) == 0x000010, "Wrong size on HWInterface_Bari_BellRicochetAiming_GetBariBellToShoot");
static_assert(offsetof(HWInterface_Bari_BellRicochetAiming_GetBariBellToShoot, Index_0) == 0x000000, "Member 'HWInterface_Bari_BellRicochetAiming_GetBariBellToShoot::Index_0' has a wrong offset!");
static_assert(offsetof(HWInterface_Bari_BellRicochetAiming_GetBariBellToShoot, ReturnValue) == 0x000008, "Member 'HWInterface_Bari_BellRicochetAiming_GetBariBellToShoot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Bari_BellRicochetAiming.GetBariBellToShootAimTargetingInfo
// 0x02C0 (0x02C0 - 0x0000)
struct HWInterface_Bari_BellRicochetAiming_GetBariBellToShootAimTargetingInfo final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWTargetData_LocationInfo             ReturnValue;                                       // 0x0010(0x02B0)(ConstParm, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Bari_BellRicochetAiming_GetBariBellToShootAimTargetingInfo) == 0x000010, "Wrong alignment on HWInterface_Bari_BellRicochetAiming_GetBariBellToShootAimTargetingInfo");
static_assert(sizeof(HWInterface_Bari_BellRicochetAiming_GetBariBellToShootAimTargetingInfo) == 0x0002C0, "Wrong size on HWInterface_Bari_BellRicochetAiming_GetBariBellToShootAimTargetingInfo");
static_assert(offsetof(HWInterface_Bari_BellRicochetAiming_GetBariBellToShootAimTargetingInfo, Index_0) == 0x000000, "Member 'HWInterface_Bari_BellRicochetAiming_GetBariBellToShootAimTargetingInfo::Index_0' has a wrong offset!");
static_assert(offsetof(HWInterface_Bari_BellRicochetAiming_GetBariBellToShootAimTargetingInfo, ReturnValue) == 0x000010, "Member 'HWInterface_Bari_BellRicochetAiming_GetBariBellToShootAimTargetingInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_RefireAbility.Refire
// 0x0030 (0x0030 - 0x0000)
struct HWInterface_RefireAbility_Refire final
{
public:
	class UHWEquipmentComponent_Refireable*       RefireComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityRefireInfo                   RefireInfo;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	float                                         ElapsedRefireTime;                                 // 0x0028(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInterface_RefireAbility_Refire) == 0x000008, "Wrong alignment on HWInterface_RefireAbility_Refire");
static_assert(sizeof(HWInterface_RefireAbility_Refire) == 0x000030, "Wrong size on HWInterface_RefireAbility_Refire");
static_assert(offsetof(HWInterface_RefireAbility_Refire, RefireComponent) == 0x000000, "Member 'HWInterface_RefireAbility_Refire::RefireComponent' has a wrong offset!");
static_assert(offsetof(HWInterface_RefireAbility_Refire, RefireInfo) == 0x000008, "Member 'HWInterface_RefireAbility_Refire::RefireInfo' has a wrong offset!");
static_assert(offsetof(HWInterface_RefireAbility_Refire, ElapsedRefireTime) == 0x000028, "Member 'HWInterface_RefireAbility_Refire::ElapsedRefireTime' has a wrong offset!");

// Function Hemingway.HWInterface_RefireAbility.CanRefire
// 0x0078 (0x0078 - 0x0000)
struct HWInterface_RefireAbility_CanRefire final
{
public:
	const class UHWEquipmentComponent_Refireable* RefireComponent;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityRefireInfo                   RefireInfo;                                        // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UHWAbilitySystemComponent*        AbilitySystem;                                     // 0x0028(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceTags;                                        // 0x0030(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetTags;                                        // 0x0050(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInterface_RefireAbility_CanRefire) == 0x000008, "Wrong alignment on HWInterface_RefireAbility_CanRefire");
static_assert(sizeof(HWInterface_RefireAbility_CanRefire) == 0x000078, "Wrong size on HWInterface_RefireAbility_CanRefire");
static_assert(offsetof(HWInterface_RefireAbility_CanRefire, RefireComponent) == 0x000000, "Member 'HWInterface_RefireAbility_CanRefire::RefireComponent' has a wrong offset!");
static_assert(offsetof(HWInterface_RefireAbility_CanRefire, RefireInfo) == 0x000008, "Member 'HWInterface_RefireAbility_CanRefire::RefireInfo' has a wrong offset!");
static_assert(offsetof(HWInterface_RefireAbility_CanRefire, AbilitySystem) == 0x000028, "Member 'HWInterface_RefireAbility_CanRefire::AbilitySystem' has a wrong offset!");
static_assert(offsetof(HWInterface_RefireAbility_CanRefire, SourceTags) == 0x000030, "Member 'HWInterface_RefireAbility_CanRefire::SourceTags' has a wrong offset!");
static_assert(offsetof(HWInterface_RefireAbility_CanRefire, TargetTags) == 0x000050, "Member 'HWInterface_RefireAbility_CanRefire::TargetTags' has a wrong offset!");
static_assert(offsetof(HWInterface_RefireAbility_CanRefire, ReturnValue) == 0x000070, "Member 'HWInterface_RefireAbility_CanRefire::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_CallToAction.GetCTAAffixPath
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_CallToAction_GetCTAAffixPath final
{
public:
	EHWCallToActionAffixPath                      AffixPath;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_CallToAction_GetCTAAffixPath) == 0x000008, "Wrong alignment on HWLibrary_CallToAction_GetCTAAffixPath");
static_assert(sizeof(HWLibrary_CallToAction_GetCTAAffixPath) == 0x000018, "Wrong size on HWLibrary_CallToAction_GetCTAAffixPath");
static_assert(offsetof(HWLibrary_CallToAction_GetCTAAffixPath, AffixPath) == 0x000000, "Member 'HWLibrary_CallToAction_GetCTAAffixPath::AffixPath' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_GetCTAAffixPath, ReturnValue) == 0x000008, "Member 'HWLibrary_CallToAction_GetCTAAffixPath::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_CallToAction.GetCTAAffixPaths
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_CallToAction_GetCTAAffixPaths final
{
public:
	TArray<EHWCallToActionAffixPath>              AffixPaths;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_CallToAction_GetCTAAffixPaths) == 0x000008, "Wrong alignment on HWLibrary_CallToAction_GetCTAAffixPaths");
static_assert(sizeof(HWLibrary_CallToAction_GetCTAAffixPaths) == 0x000020, "Wrong size on HWLibrary_CallToAction_GetCTAAffixPaths");
static_assert(offsetof(HWLibrary_CallToAction_GetCTAAffixPaths, AffixPaths) == 0x000000, "Member 'HWLibrary_CallToAction_GetCTAAffixPaths::AffixPaths' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_GetCTAAffixPaths, ReturnValue) == 0x000010, "Member 'HWLibrary_CallToAction_GetCTAAffixPaths::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_CallToAction.GetCTACollectionAffixPath
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_CallToAction_GetCTACollectionAffixPath final
{
public:
	EHWCollectionItemType                         CollectionType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_CallToAction_GetCTACollectionAffixPath) == 0x000008, "Wrong alignment on HWLibrary_CallToAction_GetCTACollectionAffixPath");
static_assert(sizeof(HWLibrary_CallToAction_GetCTACollectionAffixPath) == 0x000018, "Wrong size on HWLibrary_CallToAction_GetCTACollectionAffixPath");
static_assert(offsetof(HWLibrary_CallToAction_GetCTACollectionAffixPath, CollectionType) == 0x000000, "Member 'HWLibrary_CallToAction_GetCTACollectionAffixPath::CollectionType' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_GetCTACollectionAffixPath, ReturnValue) == 0x000008, "Member 'HWLibrary_CallToAction_GetCTACollectionAffixPath::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_CallToAction.SetCTASeenByItem
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_CallToAction_SetCTASeenByItem final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWInventoryItem*                 InventoryItem;                                     // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWCallToActionAffixPath                      Preffix;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWCallToActionAffixPath                      Suffix;                                            // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SeenAmount;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_CallToAction_SetCTASeenByItem) == 0x000008, "Wrong alignment on HWLibrary_CallToAction_SetCTASeenByItem");
static_assert(sizeof(HWLibrary_CallToAction_SetCTASeenByItem) == 0x000018, "Wrong size on HWLibrary_CallToAction_SetCTASeenByItem");
static_assert(offsetof(HWLibrary_CallToAction_SetCTASeenByItem, WorldContext) == 0x000000, "Member 'HWLibrary_CallToAction_SetCTASeenByItem::WorldContext' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_SetCTASeenByItem, InventoryItem) == 0x000008, "Member 'HWLibrary_CallToAction_SetCTASeenByItem::InventoryItem' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_SetCTASeenByItem, Preffix) == 0x000010, "Member 'HWLibrary_CallToAction_SetCTASeenByItem::Preffix' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_SetCTASeenByItem, Suffix) == 0x000011, "Member 'HWLibrary_CallToAction_SetCTASeenByItem::Suffix' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_SetCTASeenByItem, SeenAmount) == 0x000014, "Member 'HWLibrary_CallToAction_SetCTASeenByItem::SeenAmount' has a wrong offset!");

// Function Hemingway.HWLibrary_CallToAction.SetCTASeenByItemPtr
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_CallToAction_SetCTASeenByItemPtr final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWInventoryItem>        InventoryItemPtr;                                  // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWCallToActionAffixPath                      Preffix;                                           // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWCallToActionAffixPath                      Suffix;                                            // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SeenAmount;                                        // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_CallToAction_SetCTASeenByItemPtr) == 0x000008, "Wrong alignment on HWLibrary_CallToAction_SetCTASeenByItemPtr");
static_assert(sizeof(HWLibrary_CallToAction_SetCTASeenByItemPtr) == 0x000038, "Wrong size on HWLibrary_CallToAction_SetCTASeenByItemPtr");
static_assert(offsetof(HWLibrary_CallToAction_SetCTASeenByItemPtr, WorldContext) == 0x000000, "Member 'HWLibrary_CallToAction_SetCTASeenByItemPtr::WorldContext' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_SetCTASeenByItemPtr, InventoryItemPtr) == 0x000008, "Member 'HWLibrary_CallToAction_SetCTASeenByItemPtr::InventoryItemPtr' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_SetCTASeenByItemPtr, Preffix) == 0x000030, "Member 'HWLibrary_CallToAction_SetCTASeenByItemPtr::Preffix' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_SetCTASeenByItemPtr, Suffix) == 0x000031, "Member 'HWLibrary_CallToAction_SetCTASeenByItemPtr::Suffix' has a wrong offset!");
static_assert(offsetof(HWLibrary_CallToAction_SetCTASeenByItemPtr, SeenAmount) == 0x000034, "Member 'HWLibrary_CallToAction_SetCTASeenByItemPtr::SeenAmount' has a wrong offset!");

// Function Hemingway.HWInterface_GameplayMovementActor.SetLobGroundTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct HWInterface_GameplayMovementActor_SetLobGroundTargetLocation final
{
public:
	struct FVector                                InGroundTargetLocation;                            // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_GameplayMovementActor_SetLobGroundTargetLocation) == 0x000008, "Wrong alignment on HWInterface_GameplayMovementActor_SetLobGroundTargetLocation");
static_assert(sizeof(HWInterface_GameplayMovementActor_SetLobGroundTargetLocation) == 0x000018, "Wrong size on HWInterface_GameplayMovementActor_SetLobGroundTargetLocation");
static_assert(offsetof(HWInterface_GameplayMovementActor_SetLobGroundTargetLocation, InGroundTargetLocation) == 0x000000, "Member 'HWInterface_GameplayMovementActor_SetLobGroundTargetLocation::InGroundTargetLocation' has a wrong offset!");

// Function Hemingway.HWInterface_GameplayMovementActor.SetMovementRange
// 0x0004 (0x0004 - 0x0000)
struct HWInterface_GameplayMovementActor_SetMovementRange final
{
public:
	float                                         Range;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_GameplayMovementActor_SetMovementRange) == 0x000004, "Wrong alignment on HWInterface_GameplayMovementActor_SetMovementRange");
static_assert(sizeof(HWInterface_GameplayMovementActor_SetMovementRange) == 0x000004, "Wrong size on HWInterface_GameplayMovementActor_SetMovementRange");
static_assert(offsetof(HWInterface_GameplayMovementActor_SetMovementRange, Range) == 0x000000, "Member 'HWInterface_GameplayMovementActor_SetMovementRange::Range' has a wrong offset!");

// Function Hemingway.HWInterface_GameplayMovementActor.GetLobGroundTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct HWInterface_GameplayMovementActor_GetLobGroundTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_GameplayMovementActor_GetLobGroundTargetLocation) == 0x000008, "Wrong alignment on HWInterface_GameplayMovementActor_GetLobGroundTargetLocation");
static_assert(sizeof(HWInterface_GameplayMovementActor_GetLobGroundTargetLocation) == 0x000018, "Wrong size on HWInterface_GameplayMovementActor_GetLobGroundTargetLocation");
static_assert(offsetof(HWInterface_GameplayMovementActor_GetLobGroundTargetLocation, ReturnValue) == 0x000000, "Member 'HWInterface_GameplayMovementActor_GetLobGroundTargetLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_GameplayMovementActor.GetMovementRange
// 0x0004 (0x0004 - 0x0000)
struct HWInterface_GameplayMovementActor_GetMovementRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_GameplayMovementActor_GetMovementRange) == 0x000004, "Wrong alignment on HWInterface_GameplayMovementActor_GetMovementRange");
static_assert(sizeof(HWInterface_GameplayMovementActor_GetMovementRange) == 0x000004, "Wrong size on HWInterface_GameplayMovementActor_GetMovementRange");
static_assert(offsetof(HWInterface_GameplayMovementActor_GetMovementRange, ReturnValue) == 0x000000, "Member 'HWInterface_GameplayMovementActor_GetMovementRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_KingArthur.OnRep_Energy
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_KingArthur_OnRep_Energy final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_KingArthur_OnRep_Energy) == 0x000008, "Wrong alignment on HWAttributeSet_KingArthur_OnRep_Energy");
static_assert(sizeof(HWAttributeSet_KingArthur_OnRep_Energy) == 0x000010, "Wrong size on HWAttributeSet_KingArthur_OnRep_Energy");
static_assert(offsetof(HWAttributeSet_KingArthur_OnRep_Energy, OldValue) == 0x000000, "Member 'HWAttributeSet_KingArthur_OnRep_Energy::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_KingArthur.OnRep_EnergyPerTime
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_KingArthur_OnRep_EnergyPerTime final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_KingArthur_OnRep_EnergyPerTime) == 0x000008, "Wrong alignment on HWAttributeSet_KingArthur_OnRep_EnergyPerTime");
static_assert(sizeof(HWAttributeSet_KingArthur_OnRep_EnergyPerTime) == 0x000010, "Wrong size on HWAttributeSet_KingArthur_OnRep_EnergyPerTime");
static_assert(offsetof(HWAttributeSet_KingArthur_OnRep_EnergyPerTime, OldValue) == 0x000000, "Member 'HWAttributeSet_KingArthur_OnRep_EnergyPerTime::OldValue' has a wrong offset!");

// Function Hemingway.HWGodSettingsSubsystem.HandleAbilitySystemActorReplicated
// 0x0010 (0x0010 - 0x0000)
struct HWGodSettingsSubsystem_HandleAbilitySystemActorReplicated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharASA;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSettingsSubsystem_HandleAbilitySystemActorReplicated) == 0x000008, "Wrong alignment on HWGodSettingsSubsystem_HandleAbilitySystemActorReplicated");
static_assert(sizeof(HWGodSettingsSubsystem_HandleAbilitySystemActorReplicated) == 0x000010, "Wrong size on HWGodSettingsSubsystem_HandleAbilitySystemActorReplicated");
static_assert(offsetof(HWGodSettingsSubsystem_HandleAbilitySystemActorReplicated, PlayerState) == 0x000000, "Member 'HWGodSettingsSubsystem_HandleAbilitySystemActorReplicated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWGodSettingsSubsystem_HandleAbilitySystemActorReplicated, CharASA) == 0x000008, "Member 'HWGodSettingsSubsystem_HandleAbilitySystemActorReplicated::CharASA' has a wrong offset!");

// Function Hemingway.HWGodSettingsSubsystem.HandleCharacterItemUpdated
// 0x0018 (0x0018 - 0x0000)
struct HWGodSettingsSubsystem_HandleCharacterItemUpdated final
{
public:
	TScriptInterface<class IHWInterface_LoadoutManagement> LoadoutOwner;                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 CharacterItem;                                     // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSettingsSubsystem_HandleCharacterItemUpdated) == 0x000008, "Wrong alignment on HWGodSettingsSubsystem_HandleCharacterItemUpdated");
static_assert(sizeof(HWGodSettingsSubsystem_HandleCharacterItemUpdated) == 0x000018, "Wrong size on HWGodSettingsSubsystem_HandleCharacterItemUpdated");
static_assert(offsetof(HWGodSettingsSubsystem_HandleCharacterItemUpdated, LoadoutOwner) == 0x000000, "Member 'HWGodSettingsSubsystem_HandleCharacterItemUpdated::LoadoutOwner' has a wrong offset!");
static_assert(offsetof(HWGodSettingsSubsystem_HandleCharacterItemUpdated, CharacterItem) == 0x000010, "Member 'HWGodSettingsSubsystem_HandleCharacterItemUpdated::CharacterItem' has a wrong offset!");

// Function Hemingway.HWGodSettingsSubsystem.HandleGodLoadoutReceived
// 0x0130 (0x0130 - 0x0000)
struct HWGodSettingsSubsystem_HandleGodLoadoutReceived final
{
public:
	const class UHWCharacterItem*                 CharacterItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWGodLoadout                          GodLoadout;                                        // 0x0008(0x0128)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSettingsSubsystem_HandleGodLoadoutReceived) == 0x000008, "Wrong alignment on HWGodSettingsSubsystem_HandleGodLoadoutReceived");
static_assert(sizeof(HWGodSettingsSubsystem_HandleGodLoadoutReceived) == 0x000130, "Wrong size on HWGodSettingsSubsystem_HandleGodLoadoutReceived");
static_assert(offsetof(HWGodSettingsSubsystem_HandleGodLoadoutReceived, CharacterItem) == 0x000000, "Member 'HWGodSettingsSubsystem_HandleGodLoadoutReceived::CharacterItem' has a wrong offset!");
static_assert(offsetof(HWGodSettingsSubsystem_HandleGodLoadoutReceived, GodLoadout) == 0x000008, "Member 'HWGodSettingsSubsystem_HandleGodLoadoutReceived::GodLoadout' has a wrong offset!");

// Function Hemingway.HWGodSettingsSubsystem.HandlePlayerControllerChanged
// 0x0008 (0x0008 - 0x0000)
struct HWGodSettingsSubsystem_HandlePlayerControllerChanged final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSettingsSubsystem_HandlePlayerControllerChanged) == 0x000008, "Wrong alignment on HWGodSettingsSubsystem_HandlePlayerControllerChanged");
static_assert(sizeof(HWGodSettingsSubsystem_HandlePlayerControllerChanged) == 0x000008, "Wrong size on HWGodSettingsSubsystem_HandlePlayerControllerChanged");
static_assert(offsetof(HWGodSettingsSubsystem_HandlePlayerControllerChanged, PlayerController) == 0x000000, "Member 'HWGodSettingsSubsystem_HandlePlayerControllerChanged::PlayerController' has a wrong offset!");

// Function Hemingway.HWGodSettingsSubsystem.HandlePlayerStateReplicated
// 0x0008 (0x0008 - 0x0000)
struct HWGodSettingsSubsystem_HandlePlayerStateReplicated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSettingsSubsystem_HandlePlayerStateReplicated) == 0x000008, "Wrong alignment on HWGodSettingsSubsystem_HandlePlayerStateReplicated");
static_assert(sizeof(HWGodSettingsSubsystem_HandlePlayerStateReplicated) == 0x000008, "Wrong size on HWGodSettingsSubsystem_HandlePlayerStateReplicated");
static_assert(offsetof(HWGodSettingsSubsystem_HandlePlayerStateReplicated, PlayerState) == 0x000000, "Member 'HWGodSettingsSubsystem_HandlePlayerStateReplicated::PlayerState' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Pele.OnRep_Fuel
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Pele_OnRep_Fuel final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Pele_OnRep_Fuel) == 0x000008, "Wrong alignment on HWAttributeSet_Pele_OnRep_Fuel");
static_assert(sizeof(HWAttributeSet_Pele_OnRep_Fuel) == 0x000010, "Wrong size on HWAttributeSet_Pele_OnRep_Fuel");
static_assert(offsetof(HWAttributeSet_Pele_OnRep_Fuel, OldValue) == 0x000000, "Member 'HWAttributeSet_Pele_OnRep_Fuel::OldValue' has a wrong offset!");

// Function Hemingway.HWInterface_Passthrough.GetPassthroughTags
// 0x0020 (0x0020 - 0x0000)
struct HWInterface_Passthrough_GetPassthroughTags final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Passthrough_GetPassthroughTags) == 0x000008, "Wrong alignment on HWInterface_Passthrough_GetPassthroughTags");
static_assert(sizeof(HWInterface_Passthrough_GetPassthroughTags) == 0x000020, "Wrong size on HWInterface_Passthrough_GetPassthroughTags");
static_assert(offsetof(HWInterface_Passthrough_GetPassthroughTags, ReturnValue) == 0x000000, "Member 'HWInterface_Passthrough_GetPassthroughTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Yemoja.OnRep_MaxOmi
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Yemoja_OnRep_MaxOmi final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Yemoja_OnRep_MaxOmi) == 0x000008, "Wrong alignment on HWAttributeSet_Yemoja_OnRep_MaxOmi");
static_assert(sizeof(HWAttributeSet_Yemoja_OnRep_MaxOmi) == 0x000010, "Wrong size on HWAttributeSet_Yemoja_OnRep_MaxOmi");
static_assert(offsetof(HWAttributeSet_Yemoja_OnRep_MaxOmi, OldValue) == 0x000000, "Member 'HWAttributeSet_Yemoja_OnRep_MaxOmi::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Yemoja.OnRep_Omi
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Yemoja_OnRep_Omi final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Yemoja_OnRep_Omi) == 0x000008, "Wrong alignment on HWAttributeSet_Yemoja_OnRep_Omi");
static_assert(sizeof(HWAttributeSet_Yemoja_OnRep_Omi) == 0x000010, "Wrong size on HWAttributeSet_Yemoja_OnRep_Omi");
static_assert(offsetof(HWAttributeSet_Yemoja_OnRep_Omi, OldValue) == 0x000000, "Member 'HWAttributeSet_Yemoja_OnRep_Omi::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Yemoja.OnRep_OmiPerTime
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Yemoja_OnRep_OmiPerTime final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Yemoja_OnRep_OmiPerTime) == 0x000008, "Wrong alignment on HWAttributeSet_Yemoja_OnRep_OmiPerTime");
static_assert(sizeof(HWAttributeSet_Yemoja_OnRep_OmiPerTime) == 0x000010, "Wrong size on HWAttributeSet_Yemoja_OnRep_OmiPerTime");
static_assert(offsetof(HWAttributeSet_Yemoja_OnRep_OmiPerTime, OldValue) == 0x000000, "Member 'HWAttributeSet_Yemoja_OnRep_OmiPerTime::OldValue' has a wrong offset!");

// Function Hemingway.HWLibrary_StatsParsing.AggregateTimeSeries
// 0x0068 (0x0068 - 0x0000)
struct HWLibrary_StatsParsing_AggregateTimeSeries final
{
public:
	TArray<struct FHWCombatLogEvent>              FilteredEvents;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bCumulative;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWGroupingField                              GroupingField;                                     // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FHWTimeValueArray> OutGroupedTimeSeries;                              // 0x0018(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_StatsParsing_AggregateTimeSeries) == 0x000008, "Wrong alignment on HWLibrary_StatsParsing_AggregateTimeSeries");
static_assert(sizeof(HWLibrary_StatsParsing_AggregateTimeSeries) == 0x000068, "Wrong size on HWLibrary_StatsParsing_AggregateTimeSeries");
static_assert(offsetof(HWLibrary_StatsParsing_AggregateTimeSeries, FilteredEvents) == 0x000000, "Member 'HWLibrary_StatsParsing_AggregateTimeSeries::FilteredEvents' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_AggregateTimeSeries, bCumulative) == 0x000010, "Member 'HWLibrary_StatsParsing_AggregateTimeSeries::bCumulative' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_AggregateTimeSeries, GroupingField) == 0x000011, "Member 'HWLibrary_StatsParsing_AggregateTimeSeries::GroupingField' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_AggregateTimeSeries, OutGroupedTimeSeries) == 0x000018, "Member 'HWLibrary_StatsParsing_AggregateTimeSeries::OutGroupedTimeSeries' has a wrong offset!");

// Function Hemingway.HWLibrary_StatsParsing.CreateFilterFor
// 0x00C0 (0x00C0 - 0x0000)
struct HWLibrary_StatsParsing_CreateFilterFor final
{
public:
	class FString                                 RowType;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         RelevantNames;                                     // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWCombatLogEventFilter                OutRowFilter;                                      // 0x0020(0x00A0)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_StatsParsing_CreateFilterFor) == 0x000008, "Wrong alignment on HWLibrary_StatsParsing_CreateFilterFor");
static_assert(sizeof(HWLibrary_StatsParsing_CreateFilterFor) == 0x0000C0, "Wrong size on HWLibrary_StatsParsing_CreateFilterFor");
static_assert(offsetof(HWLibrary_StatsParsing_CreateFilterFor, RowType) == 0x000000, "Member 'HWLibrary_StatsParsing_CreateFilterFor::RowType' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_CreateFilterFor, RelevantNames) == 0x000010, "Member 'HWLibrary_StatsParsing_CreateFilterFor::RelevantNames' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_CreateFilterFor, OutRowFilter) == 0x000020, "Member 'HWLibrary_StatsParsing_CreateFilterFor::OutRowFilter' has a wrong offset!");

// Function Hemingway.HWLibrary_StatsParsing.ExtractTeams
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_StatsParsing_ExtractTeams final
{
public:
	TArray<struct FHWCombatLogEvent>              MatchEvents;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWCombatLogTeamData                   ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_StatsParsing_ExtractTeams) == 0x000008, "Wrong alignment on HWLibrary_StatsParsing_ExtractTeams");
static_assert(sizeof(HWLibrary_StatsParsing_ExtractTeams) == 0x000030, "Wrong size on HWLibrary_StatsParsing_ExtractTeams");
static_assert(offsetof(HWLibrary_StatsParsing_ExtractTeams, MatchEvents) == 0x000000, "Member 'HWLibrary_StatsParsing_ExtractTeams::MatchEvents' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_ExtractTeams, ReturnValue) == 0x000010, "Member 'HWLibrary_StatsParsing_ExtractTeams::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_StatsParsing.FetchAndParseCombatLog
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_StatsParsing_FetchAndParseCombatLog final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  MatchID;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& LoadedCombatLog)> CombatLogLoadedDelegate;                   // 0x0018(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_StatsParsing_FetchAndParseCombatLog) == 0x000008, "Wrong alignment on HWLibrary_StatsParsing_FetchAndParseCombatLog");
static_assert(sizeof(HWLibrary_StatsParsing_FetchAndParseCombatLog) == 0x000028, "Wrong size on HWLibrary_StatsParsing_FetchAndParseCombatLog");
static_assert(offsetof(HWLibrary_StatsParsing_FetchAndParseCombatLog, WorldContextObject) == 0x000000, "Member 'HWLibrary_StatsParsing_FetchAndParseCombatLog::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_FetchAndParseCombatLog, MatchID) == 0x000008, "Member 'HWLibrary_StatsParsing_FetchAndParseCombatLog::MatchID' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_FetchAndParseCombatLog, CombatLogLoadedDelegate) == 0x000018, "Member 'HWLibrary_StatsParsing_FetchAndParseCombatLog::CombatLogLoadedDelegate' has a wrong offset!");

// Function Hemingway.HWLibrary_StatsParsing.FilterMatchEvents
// 0x00C0 (0x00C0 - 0x0000)
struct HWLibrary_StatsParsing_FilterMatchEvents final
{
public:
	TArray<struct FHWCombatLogEvent>              AllEvents;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWCombatLogEventFilter                Filter;                                            // 0x0010(0x00A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FHWCombatLogEvent>              OutFilteredEvents;                                 // 0x00B0(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_StatsParsing_FilterMatchEvents) == 0x000008, "Wrong alignment on HWLibrary_StatsParsing_FilterMatchEvents");
static_assert(sizeof(HWLibrary_StatsParsing_FilterMatchEvents) == 0x0000C0, "Wrong size on HWLibrary_StatsParsing_FilterMatchEvents");
static_assert(offsetof(HWLibrary_StatsParsing_FilterMatchEvents, AllEvents) == 0x000000, "Member 'HWLibrary_StatsParsing_FilterMatchEvents::AllEvents' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_FilterMatchEvents, Filter) == 0x000010, "Member 'HWLibrary_StatsParsing_FilterMatchEvents::Filter' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_FilterMatchEvents, OutFilteredEvents) == 0x0000B0, "Member 'HWLibrary_StatsParsing_FilterMatchEvents::OutFilteredEvents' has a wrong offset!");

// Function Hemingway.HWLibrary_StatsParsing.GenerateTimeSeriesData
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_StatsParsing_GenerateTimeSeriesData final
{
public:
	TArray<struct FHWCombatLogEvent>              MatchEvents;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 EventTypeFilter;                                   // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         SourceActors;                                      // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         TargetActors;                                      // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bCumulative;                                       // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      OutData;                                           // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_StatsParsing_GenerateTimeSeriesData) == 0x000008, "Wrong alignment on HWLibrary_StatsParsing_GenerateTimeSeriesData");
static_assert(sizeof(HWLibrary_StatsParsing_GenerateTimeSeriesData) == 0x000058, "Wrong size on HWLibrary_StatsParsing_GenerateTimeSeriesData");
static_assert(offsetof(HWLibrary_StatsParsing_GenerateTimeSeriesData, MatchEvents) == 0x000000, "Member 'HWLibrary_StatsParsing_GenerateTimeSeriesData::MatchEvents' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_GenerateTimeSeriesData, EventTypeFilter) == 0x000010, "Member 'HWLibrary_StatsParsing_GenerateTimeSeriesData::EventTypeFilter' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_GenerateTimeSeriesData, SourceActors) == 0x000020, "Member 'HWLibrary_StatsParsing_GenerateTimeSeriesData::SourceActors' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_GenerateTimeSeriesData, TargetActors) == 0x000030, "Member 'HWLibrary_StatsParsing_GenerateTimeSeriesData::TargetActors' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_GenerateTimeSeriesData, bCumulative) == 0x000040, "Member 'HWLibrary_StatsParsing_GenerateTimeSeriesData::bCumulative' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_GenerateTimeSeriesData, OutData) == 0x000048, "Member 'HWLibrary_StatsParsing_GenerateTimeSeriesData::OutData' has a wrong offset!");

// Function Hemingway.HWLibrary_StatsParsing.GetNamesForRoles
// 0x0040 (0x0040 - 0x0000)
struct HWLibrary_StatsParsing_GetNamesForRoles final
{
public:
	TArray<struct FHWCombatLogEvent>              MatchEvents;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 RoleName;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         OutNames;                                          // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         OutTeamSplitIndex;                                 // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_StatsParsing_GetNamesForRoles) == 0x000008, "Wrong alignment on HWLibrary_StatsParsing_GetNamesForRoles");
static_assert(sizeof(HWLibrary_StatsParsing_GetNamesForRoles) == 0x000040, "Wrong size on HWLibrary_StatsParsing_GetNamesForRoles");
static_assert(offsetof(HWLibrary_StatsParsing_GetNamesForRoles, MatchEvents) == 0x000000, "Member 'HWLibrary_StatsParsing_GetNamesForRoles::MatchEvents' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_GetNamesForRoles, RoleName) == 0x000010, "Member 'HWLibrary_StatsParsing_GetNamesForRoles::RoleName' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_GetNamesForRoles, TeamId) == 0x000020, "Member 'HWLibrary_StatsParsing_GetNamesForRoles::TeamId' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_GetNamesForRoles, OutNames) == 0x000028, "Member 'HWLibrary_StatsParsing_GetNamesForRoles::OutNames' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_GetNamesForRoles, OutTeamSplitIndex) == 0x000038, "Member 'HWLibrary_StatsParsing_GetNamesForRoles::OutTeamSplitIndex' has a wrong offset!");

// Function Hemingway.HWLibrary_StatsParsing.LoadCombatLog
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_StatsParsing_LoadCombatLog final
{
public:
	class FString                                 FilePath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWCombatLogEvent>              MatchEvents;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_StatsParsing_LoadCombatLog) == 0x000008, "Wrong alignment on HWLibrary_StatsParsing_LoadCombatLog");
static_assert(sizeof(HWLibrary_StatsParsing_LoadCombatLog) == 0x000020, "Wrong size on HWLibrary_StatsParsing_LoadCombatLog");
static_assert(offsetof(HWLibrary_StatsParsing_LoadCombatLog, FilePath) == 0x000000, "Member 'HWLibrary_StatsParsing_LoadCombatLog::FilePath' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_LoadCombatLog, MatchEvents) == 0x000010, "Member 'HWLibrary_StatsParsing_LoadCombatLog::MatchEvents' has a wrong offset!");

// Function Hemingway.HWLibrary_StatsParsing.ProcessCombatLogString
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_StatsParsing_ProcessCombatLogString final
{
public:
	class FString                                 CombatLogString;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWCombatLogEvent>              OutMatchEvents;                                    // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_StatsParsing_ProcessCombatLogString) == 0x000008, "Wrong alignment on HWLibrary_StatsParsing_ProcessCombatLogString");
static_assert(sizeof(HWLibrary_StatsParsing_ProcessCombatLogString) == 0x000020, "Wrong size on HWLibrary_StatsParsing_ProcessCombatLogString");
static_assert(offsetof(HWLibrary_StatsParsing_ProcessCombatLogString, CombatLogString) == 0x000000, "Member 'HWLibrary_StatsParsing_ProcessCombatLogString::CombatLogString' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_ProcessCombatLogString, OutMatchEvents) == 0x000010, "Member 'HWLibrary_StatsParsing_ProcessCombatLogString::OutMatchEvents' has a wrong offset!");

// Function Hemingway.HWLibrary_StatsParsing.UpdateTimeSeriesPlot
// 0x0040 (0x0040 - 0x0000)
struct HWLibrary_StatsParsing_UpdateTimeSeriesPlot final
{
public:
	class UHWTimeSeriesDataSource*                DataSource;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimeSeriesPlot*                        TimeSeriesPlot;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      DataSeries;                                        // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 SeriesName;                                        // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_StatsParsing_UpdateTimeSeriesPlot) == 0x000008, "Wrong alignment on HWLibrary_StatsParsing_UpdateTimeSeriesPlot");
static_assert(sizeof(HWLibrary_StatsParsing_UpdateTimeSeriesPlot) == 0x000040, "Wrong size on HWLibrary_StatsParsing_UpdateTimeSeriesPlot");
static_assert(offsetof(HWLibrary_StatsParsing_UpdateTimeSeriesPlot, DataSource) == 0x000000, "Member 'HWLibrary_StatsParsing_UpdateTimeSeriesPlot::DataSource' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_UpdateTimeSeriesPlot, TimeSeriesPlot) == 0x000008, "Member 'HWLibrary_StatsParsing_UpdateTimeSeriesPlot::TimeSeriesPlot' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_UpdateTimeSeriesPlot, DataSeries) == 0x000010, "Member 'HWLibrary_StatsParsing_UpdateTimeSeriesPlot::DataSeries' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_UpdateTimeSeriesPlot, SeriesName) == 0x000020, "Member 'HWLibrary_StatsParsing_UpdateTimeSeriesPlot::SeriesName' has a wrong offset!");
static_assert(offsetof(HWLibrary_StatsParsing_UpdateTimeSeriesPlot, LineColor) == 0x000030, "Member 'HWLibrary_StatsParsing_UpdateTimeSeriesPlot::LineColor' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.OnGodsRotationVendorReceived
// 0x0001 (0x0001 - 0x0000)
struct HWGodSubsystem_OnGodsRotationVendorReceived final
{
public:
	bool                                          bSuccessfullyLoaded;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_OnGodsRotationVendorReceived) == 0x000001, "Wrong alignment on HWGodSubsystem_OnGodsRotationVendorReceived");
static_assert(sizeof(HWGodSubsystem_OnGodsRotationVendorReceived) == 0x000001, "Wrong size on HWGodSubsystem_OnGodsRotationVendorReceived");
static_assert(offsetof(HWGodSubsystem_OnGodsRotationVendorReceived, bSuccessfullyLoaded) == 0x000000, "Member 'HWGodSubsystem_OnGodsRotationVendorReceived::bSuccessfullyLoaded' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.OnGodsVendorReceived
// 0x0001 (0x0001 - 0x0000)
struct HWGodSubsystem_OnGodsVendorReceived final
{
public:
	bool                                          bSuccessfullyLoaded;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_OnGodsVendorReceived) == 0x000001, "Wrong alignment on HWGodSubsystem_OnGodsVendorReceived");
static_assert(sizeof(HWGodSubsystem_OnGodsVendorReceived) == 0x000001, "Wrong size on HWGodSubsystem_OnGodsVendorReceived");
static_assert(offsetof(HWGodSubsystem_OnGodsVendorReceived, bSuccessfullyLoaded) == 0x000000, "Member 'HWGodSubsystem_OnGodsVendorReceived::bSuccessfullyLoaded' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.OnRHSessionChanged
// 0x0010 (0x0010 - 0x0000)
struct HWGodSubsystem_OnRHSessionChanged final
{
public:
	class URH_JoinedSession*                      OldSession;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_JoinedSession*                      ActiveSession;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_OnRHSessionChanged) == 0x000008, "Wrong alignment on HWGodSubsystem_OnRHSessionChanged");
static_assert(sizeof(HWGodSubsystem_OnRHSessionChanged) == 0x000010, "Wrong size on HWGodSubsystem_OnRHSessionChanged");
static_assert(offsetof(HWGodSubsystem_OnRHSessionChanged, OldSession) == 0x000000, "Member 'HWGodSubsystem_OnRHSessionChanged::OldSession' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_OnRHSessionChanged, ActiveSession) == 0x000008, "Member 'HWGodSubsystem_OnRHSessionChanged::ActiveSession' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.OnSkinsVendorReceived
// 0x0001 (0x0001 - 0x0000)
struct HWGodSubsystem_OnSkinsVendorReceived final
{
public:
	bool                                          bSuccessfullyLoaded;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_OnSkinsVendorReceived) == 0x000001, "Wrong alignment on HWGodSubsystem_OnSkinsVendorReceived");
static_assert(sizeof(HWGodSubsystem_OnSkinsVendorReceived) == 0x000001, "Wrong size on HWGodSubsystem_OnSkinsVendorReceived");
static_assert(offsetof(HWGodSubsystem_OnSkinsVendorReceived, bSuccessfullyLoaded) == 0x000000, "Member 'HWGodSubsystem_OnSkinsVendorReceived::bSuccessfullyLoaded' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.GetGodByItemId
// 0x0020 (0x0020 - 0x0000)
struct HWGodSubsystem_GetGodByItemId final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayableOnly;                                     // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWCharacterItem*                 ReturnValue;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_GetGodByItemId) == 0x000008, "Wrong alignment on HWGodSubsystem_GetGodByItemId");
static_assert(sizeof(HWGodSubsystem_GetGodByItemId) == 0x000020, "Wrong size on HWGodSubsystem_GetGodByItemId");
static_assert(offsetof(HWGodSubsystem_GetGodByItemId, ItemId) == 0x000000, "Member 'HWGodSubsystem_GetGodByItemId::ItemId' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_GetGodByItemId, bPlayableOnly) == 0x000014, "Member 'HWGodSubsystem_GetGodByItemId::bPlayableOnly' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_GetGodByItemId, ReturnValue) == 0x000018, "Member 'HWGodSubsystem_GetGodByItemId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.GetGodByName
// 0x0020 (0x0020 - 0x0000)
struct HWGodSubsystem_GetGodByName final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayableOnly;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWCharacterItem*                 ReturnValue;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_GetGodByName) == 0x000008, "Wrong alignment on HWGodSubsystem_GetGodByName");
static_assert(sizeof(HWGodSubsystem_GetGodByName) == 0x000020, "Wrong size on HWGodSubsystem_GetGodByName");
static_assert(offsetof(HWGodSubsystem_GetGodByName, Name_0) == 0x000000, "Member 'HWGodSubsystem_GetGodByName::Name_0' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_GetGodByName, bPlayableOnly) == 0x000010, "Member 'HWGodSubsystem_GetGodByName::bPlayableOnly' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_GetGodByName, ReturnValue) == 0x000018, "Member 'HWGodSubsystem_GetGodByName::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.GetGodByPrimaryAssetId
// 0x0020 (0x0020 - 0x0000)
struct HWGodSubsystem_GetGodByPrimaryAssetId final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayableOnly;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWCharacterItem*                 ReturnValue;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_GetGodByPrimaryAssetId) == 0x000008, "Wrong alignment on HWGodSubsystem_GetGodByPrimaryAssetId");
static_assert(sizeof(HWGodSubsystem_GetGodByPrimaryAssetId) == 0x000020, "Wrong size on HWGodSubsystem_GetGodByPrimaryAssetId");
static_assert(offsetof(HWGodSubsystem_GetGodByPrimaryAssetId, PrimaryAssetId) == 0x000000, "Member 'HWGodSubsystem_GetGodByPrimaryAssetId::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_GetGodByPrimaryAssetId, bPlayableOnly) == 0x000010, "Member 'HWGodSubsystem_GetGodByPrimaryAssetId::bPlayableOnly' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_GetGodByPrimaryAssetId, ReturnValue) == 0x000018, "Member 'HWGodSubsystem_GetGodByPrimaryAssetId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.GetGodByTag
// 0x0018 (0x0018 - 0x0000)
struct HWGodSubsystem_GetGodByTag final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayableOnly;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWCharacterItem*                 ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_GetGodByTag) == 0x000008, "Wrong alignment on HWGodSubsystem_GetGodByTag");
static_assert(sizeof(HWGodSubsystem_GetGodByTag) == 0x000018, "Wrong size on HWGodSubsystem_GetGodByTag");
static_assert(offsetof(HWGodSubsystem_GetGodByTag, GameplayTag) == 0x000000, "Member 'HWGodSubsystem_GetGodByTag::GameplayTag' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_GetGodByTag, bPlayableOnly) == 0x000008, "Member 'HWGodSubsystem_GetGodByTag::bPlayableOnly' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_GetGodByTag, ReturnValue) == 0x000010, "Member 'HWGodSubsystem_GetGodByTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.GetSkinByItemId
// 0x0020 (0x0020 - 0x0000)
struct HWGodSubsystem_GetSkinByItemId final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayableOnly;                                     // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_GetSkinByItemId) == 0x000008, "Wrong alignment on HWGodSubsystem_GetSkinByItemId");
static_assert(sizeof(HWGodSubsystem_GetSkinByItemId) == 0x000020, "Wrong size on HWGodSubsystem_GetSkinByItemId");
static_assert(offsetof(HWGodSubsystem_GetSkinByItemId, ItemId) == 0x000000, "Member 'HWGodSubsystem_GetSkinByItemId::ItemId' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_GetSkinByItemId, bPlayableOnly) == 0x000014, "Member 'HWGodSubsystem_GetSkinByItemId::bPlayableOnly' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_GetSkinByItemId, ReturnValue) == 0x000018, "Member 'HWGodSubsystem_GetSkinByItemId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.HasLoadedGodsAndSkins
// 0x0001 (0x0001 - 0x0000)
struct HWGodSubsystem_HasLoadedGodsAndSkins final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_HasLoadedGodsAndSkins) == 0x000001, "Wrong alignment on HWGodSubsystem_HasLoadedGodsAndSkins");
static_assert(sizeof(HWGodSubsystem_HasLoadedGodsAndSkins) == 0x000001, "Wrong size on HWGodSubsystem_HasLoadedGodsAndSkins");
static_assert(offsetof(HWGodSubsystem_HasLoadedGodsAndSkins, ReturnValue) == 0x000000, "Member 'HWGodSubsystem_HasLoadedGodsAndSkins::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.IsGodInComingSoon
// 0x000C (0x000C - 0x0000)
struct HWGodSubsystem_IsGodInComingSoon final
{
public:
	struct FGameplayTag                           GodTag;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGodSubsystem_IsGodInComingSoon) == 0x000004, "Wrong alignment on HWGodSubsystem_IsGodInComingSoon");
static_assert(sizeof(HWGodSubsystem_IsGodInComingSoon) == 0x00000C, "Wrong size on HWGodSubsystem_IsGodInComingSoon");
static_assert(offsetof(HWGodSubsystem_IsGodInComingSoon, GodTag) == 0x000000, "Member 'HWGodSubsystem_IsGodInComingSoon::GodTag' has a wrong offset!");
static_assert(offsetof(HWGodSubsystem_IsGodInComingSoon, ReturnValue) == 0x000008, "Member 'HWGodSubsystem_IsGodInComingSoon::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGodSubsystem.IsReady
// 0x0001 (0x0001 - 0x0000)
struct HWGodSubsystem_IsReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodSubsystem_IsReady) == 0x000001, "Wrong alignment on HWGodSubsystem_IsReady");
static_assert(sizeof(HWGodSubsystem_IsReady) == 0x000001, "Wrong size on HWGodSubsystem_IsReady");
static_assert(offsetof(HWGodSubsystem_IsReady, ReturnValue) == 0x000000, "Member 'HWGodSubsystem_IsReady::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_SwapAbility.SwapAbility
// 0x0048 (0x0048 - 0x0000)
struct HWInterface_SwapAbility_SwapAbility final
{
public:
	class UHWEquipmentComponent_AbilitySwap*      AbilitySwapComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilitySwapInfo                     SwapInfo;                                          // 0x0008(0x0040)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_SwapAbility_SwapAbility) == 0x000008, "Wrong alignment on HWInterface_SwapAbility_SwapAbility");
static_assert(sizeof(HWInterface_SwapAbility_SwapAbility) == 0x000048, "Wrong size on HWInterface_SwapAbility_SwapAbility");
static_assert(offsetof(HWInterface_SwapAbility_SwapAbility, AbilitySwapComponent) == 0x000000, "Member 'HWInterface_SwapAbility_SwapAbility::AbilitySwapComponent' has a wrong offset!");
static_assert(offsetof(HWInterface_SwapAbility_SwapAbility, SwapInfo) == 0x000008, "Member 'HWInterface_SwapAbility_SwapAbility::SwapInfo' has a wrong offset!");

// Function Hemingway.HWInterface_SwapAbility.CanSwapAbility
// 0x0058 (0x0058 - 0x0000)
struct HWInterface_SwapAbility_CanSwapAbility final
{
public:
	const class UHWEquipmentComponent_AbilitySwap* AbilitySwapComponent;                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilitySwapInfo                     SwapInfo;                                          // 0x0008(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	const class UHWAbilitySystemComponent*        AbilitySystem;                                     // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInterface_SwapAbility_CanSwapAbility) == 0x000008, "Wrong alignment on HWInterface_SwapAbility_CanSwapAbility");
static_assert(sizeof(HWInterface_SwapAbility_CanSwapAbility) == 0x000058, "Wrong size on HWInterface_SwapAbility_CanSwapAbility");
static_assert(offsetof(HWInterface_SwapAbility_CanSwapAbility, AbilitySwapComponent) == 0x000000, "Member 'HWInterface_SwapAbility_CanSwapAbility::AbilitySwapComponent' has a wrong offset!");
static_assert(offsetof(HWInterface_SwapAbility_CanSwapAbility, SwapInfo) == 0x000008, "Member 'HWInterface_SwapAbility_CanSwapAbility::SwapInfo' has a wrong offset!");
static_assert(offsetof(HWInterface_SwapAbility_CanSwapAbility, AbilitySystem) == 0x000048, "Member 'HWInterface_SwapAbility_CanSwapAbility::AbilitySystem' has a wrong offset!");
static_assert(offsetof(HWInterface_SwapAbility_CanSwapAbility, ReturnValue) == 0x000050, "Member 'HWInterface_SwapAbility_CanSwapAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAutoBuyBuildProfile.GetProfileDesc
// 0x0018 (0x0018 - 0x0000)
struct HWAutoBuyBuildProfile_GetProfileDesc final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoBuyBuildProfile_GetProfileDesc) == 0x000008, "Wrong alignment on HWAutoBuyBuildProfile_GetProfileDesc");
static_assert(sizeof(HWAutoBuyBuildProfile_GetProfileDesc) == 0x000018, "Wrong size on HWAutoBuyBuildProfile_GetProfileDesc");
static_assert(offsetof(HWAutoBuyBuildProfile_GetProfileDesc, ReturnValue) == 0x000000, "Member 'HWAutoBuyBuildProfile_GetProfileDesc::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAutoBuyBuildProfile.GetProfileDisplayName
// 0x0018 (0x0018 - 0x0000)
struct HWAutoBuyBuildProfile_GetProfileDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoBuyBuildProfile_GetProfileDisplayName) == 0x000008, "Wrong alignment on HWAutoBuyBuildProfile_GetProfileDisplayName");
static_assert(sizeof(HWAutoBuyBuildProfile_GetProfileDisplayName) == 0x000018, "Wrong size on HWAutoBuyBuildProfile_GetProfileDisplayName");
static_assert(offsetof(HWAutoBuyBuildProfile_GetProfileDisplayName, ReturnValue) == 0x000000, "Member 'HWAutoBuyBuildProfile_GetProfileDisplayName::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAutoBuyBuildProfile.GetProfileIcon
// 0x0008 (0x0008 - 0x0000)
struct HWAutoBuyBuildProfile_GetProfileIcon final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoBuyBuildProfile_GetProfileIcon) == 0x000008, "Wrong alignment on HWAutoBuyBuildProfile_GetProfileIcon");
static_assert(sizeof(HWAutoBuyBuildProfile_GetProfileIcon) == 0x000008, "Wrong size on HWAutoBuyBuildProfile_GetProfileIcon");
static_assert(offsetof(HWAutoBuyBuildProfile_GetProfileIcon, ReturnValue) == 0x000000, "Member 'HWAutoBuyBuildProfile_GetProfileIcon::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAutoBuyBuildProfile.GetProfileName
// 0x0008 (0x0008 - 0x0000)
struct HWAutoBuyBuildProfile_GetProfileName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoBuyBuildProfile_GetProfileName) == 0x000004, "Wrong alignment on HWAutoBuyBuildProfile_GetProfileName");
static_assert(sizeof(HWAutoBuyBuildProfile_GetProfileName) == 0x000008, "Wrong size on HWAutoBuyBuildProfile_GetProfileName");
static_assert(offsetof(HWAutoBuyBuildProfile_GetProfileName, ReturnValue) == 0x000000, "Member 'HWAutoBuyBuildProfile_GetProfileName::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAutoBuyBuildProfile.GetRecipesToBuild
// 0x0010 (0x0010 - 0x0000)
struct HWAutoBuyBuildProfile_GetRecipesToBuild final
{
public:
	TArray<class UHWEquipmentRecipe*>             ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoBuyBuildProfile_GetRecipesToBuild) == 0x000008, "Wrong alignment on HWAutoBuyBuildProfile_GetRecipesToBuild");
static_assert(sizeof(HWAutoBuyBuildProfile_GetRecipesToBuild) == 0x000010, "Wrong size on HWAutoBuyBuildProfile_GetRecipesToBuild");
static_assert(offsetof(HWAutoBuyBuildProfile_GetRecipesToBuild, ReturnValue) == 0x000000, "Member 'HWAutoBuyBuildProfile_GetRecipesToBuild::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAutoPingWorldActor.MatchesRequiredTags
// 0x0028 (0x0028 - 0x0000)
struct HWAutoPingWorldActor_MatchesRequiredTags final
{
public:
	struct FGameplayTagContainer                  PingTags;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAutoPingWorldActor_MatchesRequiredTags) == 0x000008, "Wrong alignment on HWAutoPingWorldActor_MatchesRequiredTags");
static_assert(sizeof(HWAutoPingWorldActor_MatchesRequiredTags) == 0x000028, "Wrong size on HWAutoPingWorldActor_MatchesRequiredTags");
static_assert(offsetof(HWAutoPingWorldActor_MatchesRequiredTags, PingTags) == 0x000000, "Member 'HWAutoPingWorldActor_MatchesRequiredTags::PingTags' has a wrong offset!");
static_assert(offsetof(HWAutoPingWorldActor_MatchesRequiredTags, ReturnValue) == 0x000020, "Member 'HWAutoPingWorldActor_MatchesRequiredTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_HUD.GetSeamlessTravelActorList
// 0x0018 (0x0018 - 0x0000)
struct HWInterface_HUD_GetSeamlessTravelActorList final
{
public:
	bool                                          bToEntry;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorList;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_HUD_GetSeamlessTravelActorList) == 0x000008, "Wrong alignment on HWInterface_HUD_GetSeamlessTravelActorList");
static_assert(sizeof(HWInterface_HUD_GetSeamlessTravelActorList) == 0x000018, "Wrong size on HWInterface_HUD_GetSeamlessTravelActorList");
static_assert(offsetof(HWInterface_HUD_GetSeamlessTravelActorList, bToEntry) == 0x000000, "Member 'HWInterface_HUD_GetSeamlessTravelActorList::bToEntry' has a wrong offset!");
static_assert(offsetof(HWInterface_HUD_GetSeamlessTravelActorList, ActorList) == 0x000008, "Member 'HWInterface_HUD_GetSeamlessTravelActorList::ActorList' has a wrong offset!");

// Function Hemingway.HWInterface_HUD.GetWorldColorForTags
// 0x0070 (0x0070 - 0x0000)
struct HWInterface_HUD_GetWorldColorForTags final
{
public:
	struct FGameplayTagContainer                  ColorTags;                                         // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FLinearColor> ReturnValue;                                      // 0x0020(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_HUD_GetWorldColorForTags) == 0x000008, "Wrong alignment on HWInterface_HUD_GetWorldColorForTags");
static_assert(sizeof(HWInterface_HUD_GetWorldColorForTags) == 0x000070, "Wrong size on HWInterface_HUD_GetWorldColorForTags");
static_assert(offsetof(HWInterface_HUD_GetWorldColorForTags, ColorTags) == 0x000000, "Member 'HWInterface_HUD_GetWorldColorForTags::ColorTags' has a wrong offset!");
static_assert(offsetof(HWInterface_HUD_GetWorldColorForTags, ReturnValue) == 0x000020, "Member 'HWInterface_HUD_GetWorldColorForTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_HUD.ProcessInput
// 0x000C (0x000C - 0x0000)
struct HWInterface_HUD_ProcessInput final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETriggerEvent                                 TriggerEvent;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInterface_HUD_ProcessInput) == 0x000004, "Wrong alignment on HWInterface_HUD_ProcessInput");
static_assert(sizeof(HWInterface_HUD_ProcessInput) == 0x00000C, "Wrong size on HWInterface_HUD_ProcessInput");
static_assert(offsetof(HWInterface_HUD_ProcessInput, InputTag) == 0x000000, "Member 'HWInterface_HUD_ProcessInput::InputTag' has a wrong offset!");
static_assert(offsetof(HWInterface_HUD_ProcessInput, TriggerEvent) == 0x000008, "Member 'HWInterface_HUD_ProcessInput::TriggerEvent' has a wrong offset!");

// Function Hemingway.HWInterface_HUD.ReceivedGameModeClass
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_HUD_ReceivedGameModeClass final
{
public:
	TSubclassOf<class AGameModeBase>              GameModeClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_HUD_ReceivedGameModeClass) == 0x000008, "Wrong alignment on HWInterface_HUD_ReceivedGameModeClass");
static_assert(sizeof(HWInterface_HUD_ReceivedGameModeClass) == 0x000008, "Wrong size on HWInterface_HUD_ReceivedGameModeClass");
static_assert(offsetof(HWInterface_HUD_ReceivedGameModeClass, GameModeClass) == 0x000000, "Member 'HWInterface_HUD_ReceivedGameModeClass::GameModeClass' has a wrong offset!");

// Function Hemingway.HWBackfillSubsystem.HandleActiveSessionChanged
// 0x0010 (0x0010 - 0x0000)
struct HWBackfillSubsystem_HandleActiveSessionChanged final
{
public:
	class URH_JoinedSession*                      OldSession;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_JoinedSession*                      NewSession;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBackfillSubsystem_HandleActiveSessionChanged) == 0x000008, "Wrong alignment on HWBackfillSubsystem_HandleActiveSessionChanged");
static_assert(sizeof(HWBackfillSubsystem_HandleActiveSessionChanged) == 0x000010, "Wrong size on HWBackfillSubsystem_HandleActiveSessionChanged");
static_assert(offsetof(HWBackfillSubsystem_HandleActiveSessionChanged, OldSession) == 0x000000, "Member 'HWBackfillSubsystem_HandleActiveSessionChanged::OldSession' has a wrong offset!");
static_assert(offsetof(HWBackfillSubsystem_HandleActiveSessionChanged, NewSession) == 0x000008, "Member 'HWBackfillSubsystem_HandleActiveSessionChanged::NewSession' has a wrong offset!");

// Function Hemingway.HWBackfillSubsystem.GetBackfillQueueInfo
// 0x0014 (0x0014 - 0x0000)
struct HWBackfillSubsystem_GetBackfillQueueInfo final
{
public:
	struct FHWBackfillQueueInfo                   ReturnValue;                                       // 0x0000(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBackfillSubsystem_GetBackfillQueueInfo) == 0x000004, "Wrong alignment on HWBackfillSubsystem_GetBackfillQueueInfo");
static_assert(sizeof(HWBackfillSubsystem_GetBackfillQueueInfo) == 0x000014, "Wrong size on HWBackfillSubsystem_GetBackfillQueueInfo");
static_assert(offsetof(HWBackfillSubsystem_GetBackfillQueueInfo, ReturnValue) == 0x000000, "Member 'HWBackfillSubsystem_GetBackfillQueueInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory_VisibilityComponent.CheckAndUpdateMapVisionFor
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_VisibilityComponent_CheckAndUpdateMapVisionFor final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWBotFactory_VisibilityComponent_CheckAndUpdateMapVisionFor) == 0x000004, "Wrong alignment on HWBotFactory_VisibilityComponent_CheckAndUpdateMapVisionFor");
static_assert(sizeof(HWBotFactory_VisibilityComponent_CheckAndUpdateMapVisionFor) == 0x000008, "Wrong size on HWBotFactory_VisibilityComponent_CheckAndUpdateMapVisionFor");
static_assert(offsetof(HWBotFactory_VisibilityComponent_CheckAndUpdateMapVisionFor, TeamId) == 0x000000, "Member 'HWBotFactory_VisibilityComponent_CheckAndUpdateMapVisionFor::TeamId' has a wrong offset!");
static_assert(offsetof(HWBotFactory_VisibilityComponent_CheckAndUpdateMapVisionFor, ReturnValue) == 0x000004, "Member 'HWBotFactory_VisibilityComponent_CheckAndUpdateMapVisionFor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory_VisibilityComponent.DoesTeamNeedUpdatedMapState
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_VisibilityComponent_DoesTeamNeedUpdatedMapState final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWBotFactory_VisibilityComponent_DoesTeamNeedUpdatedMapState) == 0x000004, "Wrong alignment on HWBotFactory_VisibilityComponent_DoesTeamNeedUpdatedMapState");
static_assert(sizeof(HWBotFactory_VisibilityComponent_DoesTeamNeedUpdatedMapState) == 0x000008, "Wrong size on HWBotFactory_VisibilityComponent_DoesTeamNeedUpdatedMapState");
static_assert(offsetof(HWBotFactory_VisibilityComponent_DoesTeamNeedUpdatedMapState, TeamId) == 0x000000, "Member 'HWBotFactory_VisibilityComponent_DoesTeamNeedUpdatedMapState::TeamId' has a wrong offset!");
static_assert(offsetof(HWBotFactory_VisibilityComponent_DoesTeamNeedUpdatedMapState, ReturnValue) == 0x000004, "Member 'HWBotFactory_VisibilityComponent_DoesTeamNeedUpdatedMapState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory_VisibilityComponent.GetLocalTeamMinimapState
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_VisibilityComponent_GetLocalTeamMinimapState final
{
public:
	EFactoryMinimapState                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_VisibilityComponent_GetLocalTeamMinimapState) == 0x000001, "Wrong alignment on HWBotFactory_VisibilityComponent_GetLocalTeamMinimapState");
static_assert(sizeof(HWBotFactory_VisibilityComponent_GetLocalTeamMinimapState) == 0x000001, "Wrong size on HWBotFactory_VisibilityComponent_GetLocalTeamMinimapState");
static_assert(offsetof(HWBotFactory_VisibilityComponent_GetLocalTeamMinimapState, ReturnValue) == 0x000000, "Member 'HWBotFactory_VisibilityComponent_GetLocalTeamMinimapState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory_VisibilityComponent.IsLocalTeamMinimapStateOutOfSync
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_VisibilityComponent_IsLocalTeamMinimapStateOutOfSync final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_VisibilityComponent_IsLocalTeamMinimapStateOutOfSync) == 0x000001, "Wrong alignment on HWBotFactory_VisibilityComponent_IsLocalTeamMinimapStateOutOfSync");
static_assert(sizeof(HWBotFactory_VisibilityComponent_IsLocalTeamMinimapStateOutOfSync) == 0x000001, "Wrong size on HWBotFactory_VisibilityComponent_IsLocalTeamMinimapStateOutOfSync");
static_assert(offsetof(HWBotFactory_VisibilityComponent_IsLocalTeamMinimapStateOutOfSync, ReturnValue) == 0x000000, "Member 'HWBotFactory_VisibilityComponent_IsLocalTeamMinimapStateOutOfSync::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory_VisibilityComponent.SetAllTeamMinimapsTo
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_VisibilityComponent_SetAllTeamMinimapsTo final
{
public:
	EFactoryMinimapState                          CurrentFactoryState;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_VisibilityComponent_SetAllTeamMinimapsTo) == 0x000001, "Wrong alignment on HWBotFactory_VisibilityComponent_SetAllTeamMinimapsTo");
static_assert(sizeof(HWBotFactory_VisibilityComponent_SetAllTeamMinimapsTo) == 0x000001, "Wrong size on HWBotFactory_VisibilityComponent_SetAllTeamMinimapsTo");
static_assert(offsetof(HWBotFactory_VisibilityComponent_SetAllTeamMinimapsTo, CurrentFactoryState) == 0x000000, "Member 'HWBotFactory_VisibilityComponent_SetAllTeamMinimapsTo::CurrentFactoryState' has a wrong offset!");

// Function Hemingway.HWBotFactory_VisibilityComponent.SetSyncedTeamMinimapsTo
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_VisibilityComponent_SetSyncedTeamMinimapsTo final
{
public:
	EFactoryMinimapState                          CurrentFactoryState;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_VisibilityComponent_SetSyncedTeamMinimapsTo) == 0x000001, "Wrong alignment on HWBotFactory_VisibilityComponent_SetSyncedTeamMinimapsTo");
static_assert(sizeof(HWBotFactory_VisibilityComponent_SetSyncedTeamMinimapsTo) == 0x000001, "Wrong size on HWBotFactory_VisibilityComponent_SetSyncedTeamMinimapsTo");
static_assert(offsetof(HWBotFactory_VisibilityComponent_SetSyncedTeamMinimapsTo, CurrentFactoryState) == 0x000000, "Member 'HWBotFactory_VisibilityComponent_SetSyncedTeamMinimapsTo::CurrentFactoryState' has a wrong offset!");

// Function Hemingway.HWBotFactory_VisibilityComponent.SetToEmpty
// 0x0010 (0x0010 - 0x0000)
struct HWBotFactory_VisibilityComponent_SetToEmpty final
{
public:
	class AActor*                                 Causer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRespawning;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWBotFactory_VisibilityComponent_SetToEmpty) == 0x000008, "Wrong alignment on HWBotFactory_VisibilityComponent_SetToEmpty");
static_assert(sizeof(HWBotFactory_VisibilityComponent_SetToEmpty) == 0x000010, "Wrong size on HWBotFactory_VisibilityComponent_SetToEmpty");
static_assert(offsetof(HWBotFactory_VisibilityComponent_SetToEmpty, Causer) == 0x000000, "Member 'HWBotFactory_VisibilityComponent_SetToEmpty::Causer' has a wrong offset!");
static_assert(offsetof(HWBotFactory_VisibilityComponent_SetToEmpty, bIsRespawning) == 0x000008, "Member 'HWBotFactory_VisibilityComponent_SetToEmpty::bIsRespawning' has a wrong offset!");

// Function Hemingway.HWBotFactory_VisibilityComponent.CanLocalTeamSeeCampRespawn
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_VisibilityComponent_CanLocalTeamSeeCampRespawn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_VisibilityComponent_CanLocalTeamSeeCampRespawn) == 0x000001, "Wrong alignment on HWBotFactory_VisibilityComponent_CanLocalTeamSeeCampRespawn");
static_assert(sizeof(HWBotFactory_VisibilityComponent_CanLocalTeamSeeCampRespawn) == 0x000001, "Wrong size on HWBotFactory_VisibilityComponent_CanLocalTeamSeeCampRespawn");
static_assert(offsetof(HWBotFactory_VisibilityComponent_CanLocalTeamSeeCampRespawn, ReturnValue) == 0x000000, "Member 'HWBotFactory_VisibilityComponent_CanLocalTeamSeeCampRespawn::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory_VisibilityComponent.GetServerMapState
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_VisibilityComponent_GetServerMapState final
{
public:
	EFactoryMinimapState                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_VisibilityComponent_GetServerMapState) == 0x000001, "Wrong alignment on HWBotFactory_VisibilityComponent_GetServerMapState");
static_assert(sizeof(HWBotFactory_VisibilityComponent_GetServerMapState) == 0x000001, "Wrong size on HWBotFactory_VisibilityComponent_GetServerMapState");
static_assert(offsetof(HWBotFactory_VisibilityComponent_GetServerMapState, ReturnValue) == 0x000000, "Member 'HWBotFactory_VisibilityComponent_GetServerMapState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.AddShieldEntry
// 0x0018 (0x0018 - 0x0000)
struct HWShieldManagerComponent_AddShieldEntry final
{
public:
	struct FActiveShieldEntry                     NewShield;                                         // 0x0000(0x0018)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_AddShieldEntry) == 0x000008, "Wrong alignment on HWShieldManagerComponent_AddShieldEntry");
static_assert(sizeof(HWShieldManagerComponent_AddShieldEntry) == 0x000018, "Wrong size on HWShieldManagerComponent_AddShieldEntry");
static_assert(offsetof(HWShieldManagerComponent_AddShieldEntry, NewShield) == 0x000000, "Member 'HWShieldManagerComponent_AddShieldEntry::NewShield' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetAllShieldInstances
// 0x0010 (0x0010 - 0x0000)
struct HWShieldManagerComponent_GetAllShieldInstances final
{
public:
	TArray<class UHWShieldInstance*>              OutShieldInstances;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_GetAllShieldInstances) == 0x000008, "Wrong alignment on HWShieldManagerComponent_GetAllShieldInstances");
static_assert(sizeof(HWShieldManagerComponent_GetAllShieldInstances) == 0x000010, "Wrong size on HWShieldManagerComponent_GetAllShieldInstances");
static_assert(offsetof(HWShieldManagerComponent_GetAllShieldInstances, OutShieldInstances) == 0x000000, "Member 'HWShieldManagerComponent_GetAllShieldInstances::OutShieldInstances' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetAllShieldInstancesByGrantingASC
// 0x0018 (0x0018 - 0x0000)
struct HWShieldManagerComponent_GetAllShieldInstancesByGrantingASC final
{
public:
	TArray<class UHWShieldInstance*>              OutShieldInstances;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              GranterASC;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_GetAllShieldInstancesByGrantingASC) == 0x000008, "Wrong alignment on HWShieldManagerComponent_GetAllShieldInstancesByGrantingASC");
static_assert(sizeof(HWShieldManagerComponent_GetAllShieldInstancesByGrantingASC) == 0x000018, "Wrong size on HWShieldManagerComponent_GetAllShieldInstancesByGrantingASC");
static_assert(offsetof(HWShieldManagerComponent_GetAllShieldInstancesByGrantingASC, OutShieldInstances) == 0x000000, "Member 'HWShieldManagerComponent_GetAllShieldInstancesByGrantingASC::OutShieldInstances' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_GetAllShieldInstancesByGrantingASC, GranterASC) == 0x000010, "Member 'HWShieldManagerComponent_GetAllShieldInstancesByGrantingASC::GranterASC' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetAllShieldInstancesByTag
// 0x0018 (0x0018 - 0x0000)
struct HWShieldManagerComponent_GetAllShieldInstancesByTag final
{
public:
	TArray<class UHWShieldInstance*>              OutShieldInstances;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ShieldEffectTag;                                   // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_GetAllShieldInstancesByTag) == 0x000008, "Wrong alignment on HWShieldManagerComponent_GetAllShieldInstancesByTag");
static_assert(sizeof(HWShieldManagerComponent_GetAllShieldInstancesByTag) == 0x000018, "Wrong size on HWShieldManagerComponent_GetAllShieldInstancesByTag");
static_assert(offsetof(HWShieldManagerComponent_GetAllShieldInstancesByTag, OutShieldInstances) == 0x000000, "Member 'HWShieldManagerComponent_GetAllShieldInstancesByTag::OutShieldInstances' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_GetAllShieldInstancesByTag, ShieldEffectTag) == 0x000010, "Member 'HWShieldManagerComponent_GetAllShieldInstancesByTag::ShieldEffectTag' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetAllShieldInstancesByType
// 0x0018 (0x0018 - 0x0000)
struct HWShieldManagerComponent_GetAllShieldInstancesByType final
{
public:
	TArray<class UHWShieldInstance*>              OutShieldInstances;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	EShieldType                                   ShieldType;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWShieldManagerComponent_GetAllShieldInstancesByType) == 0x000008, "Wrong alignment on HWShieldManagerComponent_GetAllShieldInstancesByType");
static_assert(sizeof(HWShieldManagerComponent_GetAllShieldInstancesByType) == 0x000018, "Wrong size on HWShieldManagerComponent_GetAllShieldInstancesByType");
static_assert(offsetof(HWShieldManagerComponent_GetAllShieldInstancesByType, OutShieldInstances) == 0x000000, "Member 'HWShieldManagerComponent_GetAllShieldInstancesByType::OutShieldInstances' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_GetAllShieldInstancesByType, ShieldType) == 0x000010, "Member 'HWShieldManagerComponent_GetAllShieldInstancesByType::ShieldType' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetAllShieldInstancesWithLifetimes
// 0x0010 (0x0010 - 0x0000)
struct HWShieldManagerComponent_GetAllShieldInstancesWithLifetimes final
{
public:
	TArray<class UHWShieldInstance*>              OutShieldInstances;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_GetAllShieldInstancesWithLifetimes) == 0x000008, "Wrong alignment on HWShieldManagerComponent_GetAllShieldInstancesWithLifetimes");
static_assert(sizeof(HWShieldManagerComponent_GetAllShieldInstancesWithLifetimes) == 0x000010, "Wrong size on HWShieldManagerComponent_GetAllShieldInstancesWithLifetimes");
static_assert(offsetof(HWShieldManagerComponent_GetAllShieldInstancesWithLifetimes, OutShieldInstances) == 0x000000, "Member 'HWShieldManagerComponent_GetAllShieldInstancesWithLifetimes::OutShieldInstances' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetHighestPriorityShieldInstance
// 0x0010 (0x0010 - 0x0000)
struct HWShieldManagerComponent_GetHighestPriorityShieldInstance final
{
public:
	EShieldType                                   TargetShieldType;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWShieldInstance*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_GetHighestPriorityShieldInstance) == 0x000008, "Wrong alignment on HWShieldManagerComponent_GetHighestPriorityShieldInstance");
static_assert(sizeof(HWShieldManagerComponent_GetHighestPriorityShieldInstance) == 0x000010, "Wrong size on HWShieldManagerComponent_GetHighestPriorityShieldInstance");
static_assert(offsetof(HWShieldManagerComponent_GetHighestPriorityShieldInstance, TargetShieldType) == 0x000000, "Member 'HWShieldManagerComponent_GetHighestPriorityShieldInstance::TargetShieldType' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_GetHighestPriorityShieldInstance, ReturnValue) == 0x000008, "Member 'HWShieldManagerComponent_GetHighestPriorityShieldInstance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetShieldInstanceByTagAndASC
// 0x0018 (0x0018 - 0x0000)
struct HWShieldManagerComponent_GetShieldInstanceByTagAndASC final
{
public:
	struct FGameplayTag                           ShieldEffectTag;                                   // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              GranterASC;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWShieldInstance*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_GetShieldInstanceByTagAndASC) == 0x000008, "Wrong alignment on HWShieldManagerComponent_GetShieldInstanceByTagAndASC");
static_assert(sizeof(HWShieldManagerComponent_GetShieldInstanceByTagAndASC) == 0x000018, "Wrong size on HWShieldManagerComponent_GetShieldInstanceByTagAndASC");
static_assert(offsetof(HWShieldManagerComponent_GetShieldInstanceByTagAndASC, ShieldEffectTag) == 0x000000, "Member 'HWShieldManagerComponent_GetShieldInstanceByTagAndASC::ShieldEffectTag' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_GetShieldInstanceByTagAndASC, GranterASC) == 0x000008, "Member 'HWShieldManagerComponent_GetShieldInstanceByTagAndASC::GranterASC' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_GetShieldInstanceByTagAndASC, ReturnValue) == 0x000010, "Member 'HWShieldManagerComponent_GetShieldInstanceByTagAndASC::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetTotalMagicalShieldHealth
// 0x0004 (0x0004 - 0x0000)
struct HWShieldManagerComponent_GetTotalMagicalShieldHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_GetTotalMagicalShieldHealth) == 0x000004, "Wrong alignment on HWShieldManagerComponent_GetTotalMagicalShieldHealth");
static_assert(sizeof(HWShieldManagerComponent_GetTotalMagicalShieldHealth) == 0x000004, "Wrong size on HWShieldManagerComponent_GetTotalMagicalShieldHealth");
static_assert(offsetof(HWShieldManagerComponent_GetTotalMagicalShieldHealth, ReturnValue) == 0x000000, "Member 'HWShieldManagerComponent_GetTotalMagicalShieldHealth::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetTotalOmniShieldHealth
// 0x0004 (0x0004 - 0x0000)
struct HWShieldManagerComponent_GetTotalOmniShieldHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_GetTotalOmniShieldHealth) == 0x000004, "Wrong alignment on HWShieldManagerComponent_GetTotalOmniShieldHealth");
static_assert(sizeof(HWShieldManagerComponent_GetTotalOmniShieldHealth) == 0x000004, "Wrong size on HWShieldManagerComponent_GetTotalOmniShieldHealth");
static_assert(offsetof(HWShieldManagerComponent_GetTotalOmniShieldHealth, ReturnValue) == 0x000000, "Member 'HWShieldManagerComponent_GetTotalOmniShieldHealth::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetTotalPhysicalShieldHealth
// 0x0004 (0x0004 - 0x0000)
struct HWShieldManagerComponent_GetTotalPhysicalShieldHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_GetTotalPhysicalShieldHealth) == 0x000004, "Wrong alignment on HWShieldManagerComponent_GetTotalPhysicalShieldHealth");
static_assert(sizeof(HWShieldManagerComponent_GetTotalPhysicalShieldHealth) == 0x000004, "Wrong size on HWShieldManagerComponent_GetTotalPhysicalShieldHealth");
static_assert(offsetof(HWShieldManagerComponent_GetTotalPhysicalShieldHealth, ReturnValue) == 0x000000, "Member 'HWShieldManagerComponent_GetTotalPhysicalShieldHealth::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.GetTotalShieldHealth
// 0x0004 (0x0004 - 0x0000)
struct HWShieldManagerComponent_GetTotalShieldHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_GetTotalShieldHealth) == 0x000004, "Wrong alignment on HWShieldManagerComponent_GetTotalShieldHealth");
static_assert(sizeof(HWShieldManagerComponent_GetTotalShieldHealth) == 0x000004, "Wrong size on HWShieldManagerComponent_GetTotalShieldHealth");
static_assert(offsetof(HWShieldManagerComponent_GetTotalShieldHealth, ReturnValue) == 0x000000, "Member 'HWShieldManagerComponent_GetTotalShieldHealth::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.HandleIncomingShieldModifierEffect
// 0x02C8 (0x02C8 - 0x0000)
struct HWShieldManagerComponent_HandleIncomingShieldModifierEffect final
{
public:
	const class UHWGameplayEffect_ShieldModifier* ShieldModifierEffectCDO;                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0008(0x0018)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0020(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_HandleIncomingShieldModifierEffect) == 0x000008, "Wrong alignment on HWShieldManagerComponent_HandleIncomingShieldModifierEffect");
static_assert(sizeof(HWShieldManagerComponent_HandleIncomingShieldModifierEffect) == 0x0002C8, "Wrong size on HWShieldManagerComponent_HandleIncomingShieldModifierEffect");
static_assert(offsetof(HWShieldManagerComponent_HandleIncomingShieldModifierEffect, ShieldModifierEffectCDO) == 0x000000, "Member 'HWShieldManagerComponent_HandleIncomingShieldModifierEffect::ShieldModifierEffectCDO' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_HandleIncomingShieldModifierEffect, EffectContextHandle) == 0x000008, "Member 'HWShieldManagerComponent_HandleIncomingShieldModifierEffect::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_HandleIncomingShieldModifierEffect, EffectSpec) == 0x000020, "Member 'HWShieldManagerComponent_HandleIncomingShieldModifierEffect::EffectSpec' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.HandleIncomingShieldOwnerEffect
// 0x02D8 (0x02D8 - 0x0000)
struct HWShieldManagerComponent_HandleIncomingShieldOwnerEffect final
{
public:
	const class UHWGameplayEffect_ShieldOwner*    ShieldOwnerEffectCDO;                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0008(0x0018)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0020(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ShieldOwnerActiveEffectHandle;                     // 0x02C8(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWShieldInstance*                      ReturnValue;                                       // 0x02D0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_HandleIncomingShieldOwnerEffect) == 0x000008, "Wrong alignment on HWShieldManagerComponent_HandleIncomingShieldOwnerEffect");
static_assert(sizeof(HWShieldManagerComponent_HandleIncomingShieldOwnerEffect) == 0x0002D8, "Wrong size on HWShieldManagerComponent_HandleIncomingShieldOwnerEffect");
static_assert(offsetof(HWShieldManagerComponent_HandleIncomingShieldOwnerEffect, ShieldOwnerEffectCDO) == 0x000000, "Member 'HWShieldManagerComponent_HandleIncomingShieldOwnerEffect::ShieldOwnerEffectCDO' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_HandleIncomingShieldOwnerEffect, EffectContextHandle) == 0x000008, "Member 'HWShieldManagerComponent_HandleIncomingShieldOwnerEffect::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_HandleIncomingShieldOwnerEffect, EffectSpec) == 0x000020, "Member 'HWShieldManagerComponent_HandleIncomingShieldOwnerEffect::EffectSpec' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_HandleIncomingShieldOwnerEffect, ShieldOwnerActiveEffectHandle) == 0x0002C8, "Member 'HWShieldManagerComponent_HandleIncomingShieldOwnerEffect::ShieldOwnerActiveEffectHandle' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_HandleIncomingShieldOwnerEffect, ReturnValue) == 0x0002D0, "Member 'HWShieldManagerComponent_HandleIncomingShieldOwnerEffect::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.RemoveShieldEntry
// 0x0018 (0x0018 - 0x0000)
struct HWShieldManagerComponent_RemoveShieldEntry final
{
public:
	struct FActiveShieldEntry                     ShieldToRemove;                                    // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldManagerComponent_RemoveShieldEntry) == 0x000008, "Wrong alignment on HWShieldManagerComponent_RemoveShieldEntry");
static_assert(sizeof(HWShieldManagerComponent_RemoveShieldEntry) == 0x000018, "Wrong size on HWShieldManagerComponent_RemoveShieldEntry");
static_assert(offsetof(HWShieldManagerComponent_RemoveShieldEntry, ShieldToRemove) == 0x000000, "Member 'HWShieldManagerComponent_RemoveShieldEntry::ShieldToRemove' has a wrong offset!");

// Function Hemingway.HWShieldManagerComponent.RemoveShieldInstance
// 0x0010 (0x0010 - 0x0000)
struct HWShieldManagerComponent_RemoveShieldInstance final
{
public:
	class UHWShieldInstance*                      ShieldInstanceToRemove;                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWShieldManagerComponent_RemoveShieldInstance) == 0x000008, "Wrong alignment on HWShieldManagerComponent_RemoveShieldInstance");
static_assert(sizeof(HWShieldManagerComponent_RemoveShieldInstance) == 0x000010, "Wrong size on HWShieldManagerComponent_RemoveShieldInstance");
static_assert(offsetof(HWShieldManagerComponent_RemoveShieldInstance, ShieldInstanceToRemove) == 0x000000, "Member 'HWShieldManagerComponent_RemoveShieldInstance::ShieldInstanceToRemove' has a wrong offset!");
static_assert(offsetof(HWShieldManagerComponent_RemoveShieldInstance, ReturnValue) == 0x000008, "Member 'HWShieldManagerComponent_RemoveShieldInstance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Trail.DeactivateTrail
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Trail_DeactivateTrail final
{
public:
	bool                                          bDestroyTrail;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Trail_DeactivateTrail) == 0x000001, "Wrong alignment on HWDeployable_Trail_DeactivateTrail");
static_assert(sizeof(HWDeployable_Trail_DeactivateTrail) == 0x000001, "Wrong size on HWDeployable_Trail_DeactivateTrail");
static_assert(offsetof(HWDeployable_Trail_DeactivateTrail, bDestroyTrail) == 0x000000, "Member 'HWDeployable_Trail_DeactivateTrail::bDestroyTrail' has a wrong offset!");

// Function Hemingway.HWDeployable_Trail.OnTrailBeginOverlap
// 0x0068 (0x0068 - 0x0000)
struct HWDeployable_Trail_OnTrailBeginOverlap final
{
public:
	class UHWSplinePathMeshManagerComponent*      TrailSpline;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OverlappedTarget;                                  // 0x0008(0x0028)(Parm, NativeAccessSpecifierPublic)
	struct FHWSplineOverlapInfo                   TrailOverlapInfo;                                  // 0x0030(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Trail_OnTrailBeginOverlap) == 0x000008, "Wrong alignment on HWDeployable_Trail_OnTrailBeginOverlap");
static_assert(sizeof(HWDeployable_Trail_OnTrailBeginOverlap) == 0x000068, "Wrong size on HWDeployable_Trail_OnTrailBeginOverlap");
static_assert(offsetof(HWDeployable_Trail_OnTrailBeginOverlap, TrailSpline) == 0x000000, "Member 'HWDeployable_Trail_OnTrailBeginOverlap::TrailSpline' has a wrong offset!");
static_assert(offsetof(HWDeployable_Trail_OnTrailBeginOverlap, OverlappedTarget) == 0x000008, "Member 'HWDeployable_Trail_OnTrailBeginOverlap::OverlappedTarget' has a wrong offset!");
static_assert(offsetof(HWDeployable_Trail_OnTrailBeginOverlap, TrailOverlapInfo) == 0x000030, "Member 'HWDeployable_Trail_OnTrailBeginOverlap::TrailOverlapInfo' has a wrong offset!");

// Function Hemingway.HWDeployable_Trail.OnTrailEndOverlap
// 0x0030 (0x0030 - 0x0000)
struct HWDeployable_Trail_OnTrailEndOverlap final
{
public:
	class UHWSplinePathMeshManagerComponent*      TrailSpline;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OverlappedTarget;                                  // 0x0008(0x0028)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Trail_OnTrailEndOverlap) == 0x000008, "Wrong alignment on HWDeployable_Trail_OnTrailEndOverlap");
static_assert(sizeof(HWDeployable_Trail_OnTrailEndOverlap) == 0x000030, "Wrong size on HWDeployable_Trail_OnTrailEndOverlap");
static_assert(offsetof(HWDeployable_Trail_OnTrailEndOverlap, TrailSpline) == 0x000000, "Member 'HWDeployable_Trail_OnTrailEndOverlap::TrailSpline' has a wrong offset!");
static_assert(offsetof(HWDeployable_Trail_OnTrailEndOverlap, OverlappedTarget) == 0x000008, "Member 'HWDeployable_Trail_OnTrailEndOverlap::OverlappedTarget' has a wrong offset!");

// Function Hemingway.HWDeployable_Trail.SetAllowNewTrailSegments
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Trail_SetAllowNewTrailSegments final
{
public:
	bool                                          bAllowNewSegments;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Trail_SetAllowNewTrailSegments) == 0x000001, "Wrong alignment on HWDeployable_Trail_SetAllowNewTrailSegments");
static_assert(sizeof(HWDeployable_Trail_SetAllowNewTrailSegments) == 0x000001, "Wrong size on HWDeployable_Trail_SetAllowNewTrailSegments");
static_assert(offsetof(HWDeployable_Trail_SetAllowNewTrailSegments, bAllowNewSegments) == 0x000000, "Member 'HWDeployable_Trail_SetAllowNewTrailSegments::bAllowNewSegments' has a wrong offset!");

// Function Hemingway.HWDeployable_Trail.GetCurrentSegmentDistance
// 0x0004 (0x0004 - 0x0000)
struct HWDeployable_Trail_GetCurrentSegmentDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Trail_GetCurrentSegmentDistance) == 0x000004, "Wrong alignment on HWDeployable_Trail_GetCurrentSegmentDistance");
static_assert(sizeof(HWDeployable_Trail_GetCurrentSegmentDistance) == 0x000004, "Wrong size on HWDeployable_Trail_GetCurrentSegmentDistance");
static_assert(offsetof(HWDeployable_Trail_GetCurrentSegmentDistance, ReturnValue) == 0x000000, "Member 'HWDeployable_Trail_GetCurrentSegmentDistance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Trail.GetMaxSegmentDistance
// 0x0004 (0x0004 - 0x0000)
struct HWDeployable_Trail_GetMaxSegmentDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Trail_GetMaxSegmentDistance) == 0x000004, "Wrong alignment on HWDeployable_Trail_GetMaxSegmentDistance");
static_assert(sizeof(HWDeployable_Trail_GetMaxSegmentDistance) == 0x000004, "Wrong size on HWDeployable_Trail_GetMaxSegmentDistance");
static_assert(offsetof(HWDeployable_Trail_GetMaxSegmentDistance, ReturnValue) == 0x000000, "Member 'HWDeployable_Trail_GetMaxSegmentDistance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Trail.GetOwnerVelocity
// 0x0018 (0x0018 - 0x0000)
struct HWDeployable_Trail_GetOwnerVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Trail_GetOwnerVelocity) == 0x000008, "Wrong alignment on HWDeployable_Trail_GetOwnerVelocity");
static_assert(sizeof(HWDeployable_Trail_GetOwnerVelocity) == 0x000018, "Wrong size on HWDeployable_Trail_GetOwnerVelocity");
static_assert(offsetof(HWDeployable_Trail_GetOwnerVelocity, ReturnValue) == 0x000000, "Member 'HWDeployable_Trail_GetOwnerVelocity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Trail.GetTrailOverlaps
// 0x0050 (0x0050 - 0x0000)
struct HWDeployable_Trail_GetTrailOverlaps final
{
public:
	TMap<class AActor*, struct FHWSplineOverlapInfo> ReturnValue;                                    // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Trail_GetTrailOverlaps) == 0x000008, "Wrong alignment on HWDeployable_Trail_GetTrailOverlaps");
static_assert(sizeof(HWDeployable_Trail_GetTrailOverlaps) == 0x000050, "Wrong size on HWDeployable_Trail_GetTrailOverlaps");
static_assert(offsetof(HWDeployable_Trail_GetTrailOverlaps, ReturnValue) == 0x000000, "Member 'HWDeployable_Trail_GetTrailOverlaps::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Trail.GetTrailStartLocation
// 0x0018 (0x0018 - 0x0000)
struct HWDeployable_Trail_GetTrailStartLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Trail_GetTrailStartLocation) == 0x000008, "Wrong alignment on HWDeployable_Trail_GetTrailStartLocation");
static_assert(sizeof(HWDeployable_Trail_GetTrailStartLocation) == 0x000018, "Wrong size on HWDeployable_Trail_GetTrailStartLocation");
static_assert(offsetof(HWDeployable_Trail_GetTrailStartLocation, ReturnValue) == 0x000000, "Member 'HWDeployable_Trail_GetTrailStartLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Trail.IsTrailActive
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Trail_IsTrailActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Trail_IsTrailActive) == 0x000001, "Wrong alignment on HWDeployable_Trail_IsTrailActive");
static_assert(sizeof(HWDeployable_Trail_IsTrailActive) == 0x000001, "Wrong size on HWDeployable_Trail_IsTrailActive");
static_assert(offsetof(HWDeployable_Trail_IsTrailActive, ReturnValue) == 0x000000, "Member 'HWDeployable_Trail_IsTrailActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCheatComponent.AddGold
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_AddGold final
{
public:
	int32                                         GoldToAdd;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_AddGold) == 0x000004, "Wrong alignment on HWCheatComponent_AddGold");
static_assert(sizeof(HWCheatComponent_AddGold) == 0x000004, "Wrong size on HWCheatComponent_AddGold");
static_assert(offsetof(HWCheatComponent_AddGold, GoldToAdd) == 0x000000, "Member 'HWCheatComponent_AddGold::GoldToAdd' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ApplyBooster
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ApplyBooster final
{
public:
	struct FGameplayTag                           BoosterTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ApplyBooster) == 0x000004, "Wrong alignment on HWCheatComponent_ApplyBooster");
static_assert(sizeof(HWCheatComponent_ApplyBooster) == 0x000008, "Wrong size on HWCheatComponent_ApplyBooster");
static_assert(offsetof(HWCheatComponent_ApplyBooster, BoosterTag) == 0x000000, "Member 'HWCheatComponent_ApplyBooster::BoosterTag' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsAddGold
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_BotsAddGold final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsAddGold) == 0x000004, "Wrong alignment on HWCheatComponent_BotsAddGold");
static_assert(sizeof(HWCheatComponent_BotsAddGold) == 0x000004, "Wrong size on HWCheatComponent_BotsAddGold");
static_assert(offsetof(HWCheatComponent_BotsAddGold, Amount) == 0x000000, "Member 'HWCheatComponent_BotsAddGold::Amount' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsCooldowns
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_BotsCooldowns final
{
public:
	bool                                          bIgnoreCooldowns;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsCooldowns) == 0x000001, "Wrong alignment on HWCheatComponent_BotsCooldowns");
static_assert(sizeof(HWCheatComponent_BotsCooldowns) == 0x000001, "Wrong size on HWCheatComponent_BotsCooldowns");
static_assert(offsetof(HWCheatComponent_BotsCooldowns, bIgnoreCooldowns) == 0x000000, "Member 'HWCheatComponent_BotsCooldowns::bIgnoreCooldowns' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotShootHUD
// 0x0020 (0x0020 - 0x0000)
struct HWCheatComponent_BotShootHUD final
{
public:
	int32                                         AbilityNumber;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BotName;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotShootHUD) == 0x000008, "Wrong alignment on HWCheatComponent_BotShootHUD");
static_assert(sizeof(HWCheatComponent_BotShootHUD) == 0x000020, "Wrong size on HWCheatComponent_BotShootHUD");
static_assert(offsetof(HWCheatComponent_BotShootHUD, AbilityNumber) == 0x000000, "Member 'HWCheatComponent_BotShootHUD::AbilityNumber' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotShootHUD, BotName) == 0x000008, "Member 'HWCheatComponent_BotShootHUD::BotName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotShootHUD, WaitTime) == 0x000018, "Member 'HWCheatComponent_BotShootHUD::WaitTime' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotShootHUD, Count) == 0x00001C, "Member 'HWCheatComponent_BotShootHUD::Count' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsImmune
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_BotsImmune final
{
public:
	bool                                          bImmunity;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsImmune) == 0x000001, "Wrong alignment on HWCheatComponent_BotsImmune");
static_assert(sizeof(HWCheatComponent_BotsImmune) == 0x000001, "Wrong size on HWCheatComponent_BotsImmune");
static_assert(offsetof(HWCheatComponent_BotsImmune, bImmunity) == 0x000000, "Member 'HWCheatComponent_BotsImmune::bImmunity' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsLevel
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_BotsLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsLevel) == 0x000004, "Wrong alignment on HWCheatComponent_BotsLevel");
static_assert(sizeof(HWCheatComponent_BotsLevel) == 0x000004, "Wrong size on HWCheatComponent_BotsLevel");
static_assert(offsetof(HWCheatComponent_BotsLevel, Level) == 0x000000, "Member 'HWCheatComponent_BotsLevel::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsOrbit
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_BotsOrbit final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlobal;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_BotsOrbit) == 0x000004, "Wrong alignment on HWCheatComponent_BotsOrbit");
static_assert(sizeof(HWCheatComponent_BotsOrbit) == 0x000008, "Wrong size on HWCheatComponent_BotsOrbit");
static_assert(offsetof(HWCheatComponent_BotsOrbit, Radius) == 0x000000, "Member 'HWCheatComponent_BotsOrbit::Radius' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsOrbit, bGlobal) == 0x000004, "Member 'HWCheatComponent_BotsOrbit::bGlobal' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsPatrol
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_BotsPatrol final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlobal;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_BotsPatrol) == 0x000004, "Wrong alignment on HWCheatComponent_BotsPatrol");
static_assert(sizeof(HWCheatComponent_BotsPatrol) == 0x000008, "Wrong size on HWCheatComponent_BotsPatrol");
static_assert(offsetof(HWCheatComponent_BotsPatrol, Distance) == 0x000000, "Member 'HWCheatComponent_BotsPatrol::Distance' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsPatrol, bGlobal) == 0x000004, "Member 'HWCheatComponent_BotsPatrol::bGlobal' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsShoot
// 0x000C (0x000C - 0x0000)
struct HWCheatComponent_BotsShoot final
{
public:
	int32                                         AbilityNumber;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsShoot) == 0x000004, "Wrong alignment on HWCheatComponent_BotsShoot");
static_assert(sizeof(HWCheatComponent_BotsShoot) == 0x00000C, "Wrong size on HWCheatComponent_BotsShoot");
static_assert(offsetof(HWCheatComponent_BotsShoot, AbilityNumber) == 0x000000, "Member 'HWCheatComponent_BotsShoot::AbilityNumber' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShoot, WaitTime) == 0x000004, "Member 'HWCheatComponent_BotsShoot::WaitTime' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShoot, Count) == 0x000008, "Member 'HWCheatComponent_BotsShoot::Count' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsShootOnce
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_BotsShootOnce final
{
public:
	int32                                         AbilityNumber;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsShootOnce) == 0x000004, "Wrong alignment on HWCheatComponent_BotsShootOnce");
static_assert(sizeof(HWCheatComponent_BotsShootOnce) == 0x000008, "Wrong size on HWCheatComponent_BotsShootOnce");
static_assert(offsetof(HWCheatComponent_BotsShootOnce, AbilityNumber) == 0x000000, "Member 'HWCheatComponent_BotsShootOnce::AbilityNumber' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootOnce, WaitTime) == 0x000004, "Member 'HWCheatComponent_BotsShootOnce::WaitTime' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsShootOnceSpecific
// 0x0018 (0x0018 - 0x0000)
struct HWCheatComponent_BotsShootOnceSpecific final
{
public:
	class FString                                 BotName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityNumber;                                     // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsShootOnceSpecific) == 0x000008, "Wrong alignment on HWCheatComponent_BotsShootOnceSpecific");
static_assert(sizeof(HWCheatComponent_BotsShootOnceSpecific) == 0x000018, "Wrong size on HWCheatComponent_BotsShootOnceSpecific");
static_assert(offsetof(HWCheatComponent_BotsShootOnceSpecific, BotName) == 0x000000, "Member 'HWCheatComponent_BotsShootOnceSpecific::BotName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootOnceSpecific, AbilityNumber) == 0x000010, "Member 'HWCheatComponent_BotsShootOnceSpecific::AbilityNumber' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootOnceSpecific, WaitTime) == 0x000014, "Member 'HWCheatComponent_BotsShootOnceSpecific::WaitTime' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsShootSpecific
// 0x0020 (0x0020 - 0x0000)
struct HWCheatComponent_BotsShootSpecific final
{
public:
	class FString                                 BotName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityNumber;                                     // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_BotsShootSpecific) == 0x000008, "Wrong alignment on HWCheatComponent_BotsShootSpecific");
static_assert(sizeof(HWCheatComponent_BotsShootSpecific) == 0x000020, "Wrong size on HWCheatComponent_BotsShootSpecific");
static_assert(offsetof(HWCheatComponent_BotsShootSpecific, BotName) == 0x000000, "Member 'HWCheatComponent_BotsShootSpecific::BotName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootSpecific, AbilityNumber) == 0x000010, "Member 'HWCheatComponent_BotsShootSpecific::AbilityNumber' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootSpecific, WaitTime) == 0x000014, "Member 'HWCheatComponent_BotsShootSpecific::WaitTime' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootSpecific, Count) == 0x000018, "Member 'HWCheatComponent_BotsShootSpecific::Count' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsShootWithRefire
// 0x0018 (0x0018 - 0x0000)
struct HWCheatComponent_BotsShootWithRefire final
{
public:
	int32                                         AbilityNumber;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefireTime;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RefireInput;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsShootWithRefire) == 0x000004, "Wrong alignment on HWCheatComponent_BotsShootWithRefire");
static_assert(sizeof(HWCheatComponent_BotsShootWithRefire) == 0x000018, "Wrong size on HWCheatComponent_BotsShootWithRefire");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefire, AbilityNumber) == 0x000000, "Member 'HWCheatComponent_BotsShootWithRefire::AbilityNumber' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefire, RefireTime) == 0x000004, "Member 'HWCheatComponent_BotsShootWithRefire::RefireTime' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefire, RefireInput) == 0x000008, "Member 'HWCheatComponent_BotsShootWithRefire::RefireInput' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefire, WaitTime) == 0x000010, "Member 'HWCheatComponent_BotsShootWithRefire::WaitTime' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefire, Count) == 0x000014, "Member 'HWCheatComponent_BotsShootWithRefire::Count' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsShootWithRefireSpecific
// 0x0028 (0x0028 - 0x0000)
struct HWCheatComponent_BotsShootWithRefireSpecific final
{
public:
	class FString                                 BotName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityNumber;                                     // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefireTime;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RefireInput;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsShootWithRefireSpecific) == 0x000008, "Wrong alignment on HWCheatComponent_BotsShootWithRefireSpecific");
static_assert(sizeof(HWCheatComponent_BotsShootWithRefireSpecific) == 0x000028, "Wrong size on HWCheatComponent_BotsShootWithRefireSpecific");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefireSpecific, BotName) == 0x000000, "Member 'HWCheatComponent_BotsShootWithRefireSpecific::BotName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefireSpecific, AbilityNumber) == 0x000010, "Member 'HWCheatComponent_BotsShootWithRefireSpecific::AbilityNumber' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefireSpecific, RefireTime) == 0x000014, "Member 'HWCheatComponent_BotsShootWithRefireSpecific::RefireTime' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefireSpecific, RefireInput) == 0x000018, "Member 'HWCheatComponent_BotsShootWithRefireSpecific::RefireInput' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefireSpecific, WaitTime) == 0x000020, "Member 'HWCheatComponent_BotsShootWithRefireSpecific::WaitTime' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_BotsShootWithRefireSpecific, Count) == 0x000024, "Member 'HWCheatComponent_BotsShootWithRefireSpecific::Count' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsSkillsToLevel
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_BotsSkillsToLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsSkillsToLevel) == 0x000004, "Wrong alignment on HWCheatComponent_BotsSkillsToLevel");
static_assert(sizeof(HWCheatComponent_BotsSkillsToLevel) == 0x000004, "Wrong size on HWCheatComponent_BotsSkillsToLevel");
static_assert(offsetof(HWCheatComponent_BotsSkillsToLevel, Level) == 0x000000, "Member 'HWCheatComponent_BotsSkillsToLevel::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.BotsUp
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_BotsUp final
{
public:
	bool                                          bToggle;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_BotsUp) == 0x000001, "Wrong alignment on HWCheatComponent_BotsUp");
static_assert(sizeof(HWCheatComponent_BotsUp) == 0x000001, "Wrong size on HWCheatComponent_BotsUp");
static_assert(offsetof(HWCheatComponent_BotsUp, bToggle) == 0x000000, "Member 'HWCheatComponent_BotsUp::bToggle' has a wrong offset!");

// Function Hemingway.HWCheatComponent.CallVGS
// 0x0010 (0x0010 - 0x0000)
struct HWCheatComponent_CallVGS final
{
public:
	class FString                                 ActionTag;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_CallVGS) == 0x000008, "Wrong alignment on HWCheatComponent_CallVGS");
static_assert(sizeof(HWCheatComponent_CallVGS) == 0x000010, "Wrong size on HWCheatComponent_CallVGS");
static_assert(offsetof(HWCheatComponent_CallVGS, ActionTag) == 0x000000, "Member 'HWCheatComponent_CallVGS::ActionTag' has a wrong offset!");

// Function Hemingway.HWCheatComponent.CharacterTestCheat
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_CharacterTestCheat final
{
public:
	bool                                          bSetActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         testInt;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_CharacterTestCheat) == 0x000004, "Wrong alignment on HWCheatComponent_CharacterTestCheat");
static_assert(sizeof(HWCheatComponent_CharacterTestCheat) == 0x000008, "Wrong size on HWCheatComponent_CharacterTestCheat");
static_assert(offsetof(HWCheatComponent_CharacterTestCheat, bSetActive) == 0x000000, "Member 'HWCheatComponent_CharacterTestCheat::bSetActive' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_CharacterTestCheat, testInt) == 0x000004, "Member 'HWCheatComponent_CharacterTestCheat::testInt' has a wrong offset!");

// Function Hemingway.HWCheatComponent.DebugMinimap
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_DebugMinimap final
{
public:
	class FName                                   UniqueNameTag;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_DebugMinimap) == 0x000004, "Wrong alignment on HWCheatComponent_DebugMinimap");
static_assert(sizeof(HWCheatComponent_DebugMinimap) == 0x000008, "Wrong size on HWCheatComponent_DebugMinimap");
static_assert(offsetof(HWCheatComponent_DebugMinimap, UniqueNameTag) == 0x000000, "Member 'HWCheatComponent_DebugMinimap::UniqueNameTag' has a wrong offset!");

// Function Hemingway.HWCheatComponent.DebugSocket
// 0x0010 (0x0010 - 0x0000)
struct HWCheatComponent_DebugSocket final
{
public:
	class FString                                 SocketName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_DebugSocket) == 0x000008, "Wrong alignment on HWCheatComponent_DebugSocket");
static_assert(sizeof(HWCheatComponent_DebugSocket) == 0x000010, "Wrong size on HWCheatComponent_DebugSocket");
static_assert(offsetof(HWCheatComponent_DebugSocket, SocketName) == 0x000000, "Member 'HWCheatComponent_DebugSocket::SocketName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.DebugStat
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_DebugStat final
{
public:
	class FName                                   StatName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_DebugStat) == 0x000004, "Wrong alignment on HWCheatComponent_DebugStat");
static_assert(sizeof(HWCheatComponent_DebugStat) == 0x000008, "Wrong size on HWCheatComponent_DebugStat");
static_assert(offsetof(HWCheatComponent_DebugStat, StatName) == 0x000000, "Member 'HWCheatComponent_DebugStat::StatName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.DestroyNextAlliedTowerInLane
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_DestroyNextAlliedTowerInLane final
{
public:
	class FName                                   Lane;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_DestroyNextAlliedTowerInLane) == 0x000004, "Wrong alignment on HWCheatComponent_DestroyNextAlliedTowerInLane");
static_assert(sizeof(HWCheatComponent_DestroyNextAlliedTowerInLane) == 0x000008, "Wrong size on HWCheatComponent_DestroyNextAlliedTowerInLane");
static_assert(offsetof(HWCheatComponent_DestroyNextAlliedTowerInLane, Lane) == 0x000000, "Member 'HWCheatComponent_DestroyNextAlliedTowerInLane::Lane' has a wrong offset!");

// Function Hemingway.HWCheatComponent.DestroyNextEnemyTowerInLane
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_DestroyNextEnemyTowerInLane final
{
public:
	class FName                                   Lane;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_DestroyNextEnemyTowerInLane) == 0x000004, "Wrong alignment on HWCheatComponent_DestroyNextEnemyTowerInLane");
static_assert(sizeof(HWCheatComponent_DestroyNextEnemyTowerInLane) == 0x000008, "Wrong size on HWCheatComponent_DestroyNextEnemyTowerInLane");
static_assert(offsetof(HWCheatComponent_DestroyNextEnemyTowerInLane, Lane) == 0x000000, "Member 'HWCheatComponent_DestroyNextEnemyTowerInLane::Lane' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ForceSetFadeParameter
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_ForceSetFadeParameter final
{
public:
	float                                         FadeParameter;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ForceSetFadeParameter) == 0x000004, "Wrong alignment on HWCheatComponent_ForceSetFadeParameter");
static_assert(sizeof(HWCheatComponent_ForceSetFadeParameter) == 0x000004, "Wrong size on HWCheatComponent_ForceSetFadeParameter");
static_assert(offsetof(HWCheatComponent_ForceSetFadeParameter, FadeParameter) == 0x000000, "Member 'HWCheatComponent_ForceSetFadeParameter::FadeParameter' has a wrong offset!");

// Function Hemingway.HWCheatComponent.hmu
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_hmu final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_hmu) == 0x000004, "Wrong alignment on HWCheatComponent_hmu");
static_assert(sizeof(HWCheatComponent_hmu) == 0x000008, "Wrong size on HWCheatComponent_hmu");
static_assert(offsetof(HWCheatComponent_hmu, Name_0) == 0x000000, "Member 'HWCheatComponent_hmu::Name_0' has a wrong offset!");

// Function Hemingway.HWCheatComponent.MorriganTest
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_MorriganTest final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_MorriganTest) == 0x000001, "Wrong alignment on HWCheatComponent_MorriganTest");
static_assert(sizeof(HWCheatComponent_MorriganTest) == 0x000001, "Wrong size on HWCheatComponent_MorriganTest");
static_assert(offsetof(HWCheatComponent_MorriganTest, bEnable) == 0x000000, "Member 'HWCheatComponent_MorriganTest::bEnable' has a wrong offset!");

// Function Hemingway.HWCheatComponent.PopSoundMixModifier
// 0x0010 (0x0010 - 0x0000)
struct HWCheatComponent_PopSoundMixModifier final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_PopSoundMixModifier) == 0x000008, "Wrong alignment on HWCheatComponent_PopSoundMixModifier");
static_assert(sizeof(HWCheatComponent_PopSoundMixModifier) == 0x000010, "Wrong size on HWCheatComponent_PopSoundMixModifier");
static_assert(offsetof(HWCheatComponent_PopSoundMixModifier, Name_0) == 0x000000, "Member 'HWCheatComponent_PopSoundMixModifier::Name_0' has a wrong offset!");

// Function Hemingway.HWCheatComponent.PushSoundMixModifier
// 0x0010 (0x0010 - 0x0000)
struct HWCheatComponent_PushSoundMixModifier final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_PushSoundMixModifier) == 0x000008, "Wrong alignment on HWCheatComponent_PushSoundMixModifier");
static_assert(sizeof(HWCheatComponent_PushSoundMixModifier) == 0x000010, "Wrong size on HWCheatComponent_PushSoundMixModifier");
static_assert(offsetof(HWCheatComponent_PushSoundMixModifier, Name_0) == 0x000000, "Member 'HWCheatComponent_PushSoundMixModifier::Name_0' has a wrong offset!");

// Function Hemingway.HWCheatComponent.QEG
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_QEG final
{
public:
	bool                                          bWin;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_QEG) == 0x000001, "Wrong alignment on HWCheatComponent_QEG");
static_assert(sizeof(HWCheatComponent_QEG) == 0x000001, "Wrong size on HWCheatComponent_QEG");
static_assert(offsetof(HWCheatComponent_QEG, bWin) == 0x000000, "Member 'HWCheatComponent_QEG::bWin' has a wrong offset!");

// Function Hemingway.HWCheatComponent.QuickEndGame
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_QuickEndGame final
{
public:
	bool                                          bWin;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_QuickEndGame) == 0x000001, "Wrong alignment on HWCheatComponent_QuickEndGame");
static_assert(sizeof(HWCheatComponent_QuickEndGame) == 0x000001, "Wrong size on HWCheatComponent_QuickEndGame");
static_assert(offsetof(HWCheatComponent_QuickEndGame, bWin) == 0x000000, "Member 'HWCheatComponent_QuickEndGame::bWin' has a wrong offset!");

// Function Hemingway.HWCheatComponent.RerollCharacter
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_RerollCharacter final
{
public:
	EHWDraftHealerRequirement                     HealerRequirement;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_RerollCharacter) == 0x000001, "Wrong alignment on HWCheatComponent_RerollCharacter");
static_assert(sizeof(HWCheatComponent_RerollCharacter) == 0x000001, "Wrong size on HWCheatComponent_RerollCharacter");
static_assert(offsetof(HWCheatComponent_RerollCharacter, HealerRequirement) == 0x000000, "Member 'HWCheatComponent_RerollCharacter::HealerRequirement' has a wrong offset!");

// Function Hemingway.HWCheatComponent.sc
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_sc final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_sc) == 0x000004, "Wrong alignment on HWCheatComponent_sc");
static_assert(sizeof(HWCheatComponent_sc) == 0x000008, "Wrong size on HWCheatComponent_sc");
static_assert(offsetof(HWCheatComponent_sc, Name_0) == 0x000000, "Member 'HWCheatComponent_sc::Name_0' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerAddGold
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_ServerAddGold final
{
public:
	int32                                         GoldToAdd;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerAddGold) == 0x000004, "Wrong alignment on HWCheatComponent_ServerAddGold");
static_assert(sizeof(HWCheatComponent_ServerAddGold) == 0x000004, "Wrong size on HWCheatComponent_ServerAddGold");
static_assert(offsetof(HWCheatComponent_ServerAddGold, GoldToAdd) == 0x000000, "Member 'HWCheatComponent_ServerAddGold::GoldToAdd' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerApplyBooster
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerApplyBooster final
{
public:
	struct FGameplayTag                           BoosterTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerApplyBooster) == 0x000004, "Wrong alignment on HWCheatComponent_ServerApplyBooster");
static_assert(sizeof(HWCheatComponent_ServerApplyBooster) == 0x000008, "Wrong size on HWCheatComponent_ServerApplyBooster");
static_assert(offsetof(HWCheatComponent_ServerApplyBooster, BoosterTag) == 0x000000, "Member 'HWCheatComponent_ServerApplyBooster::BoosterTag' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerBotsAddGold
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_ServerBotsAddGold final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerBotsAddGold) == 0x000004, "Wrong alignment on HWCheatComponent_ServerBotsAddGold");
static_assert(sizeof(HWCheatComponent_ServerBotsAddGold) == 0x000004, "Wrong size on HWCheatComponent_ServerBotsAddGold");
static_assert(offsetof(HWCheatComponent_ServerBotsAddGold, Amount) == 0x000000, "Member 'HWCheatComponent_ServerBotsAddGold::Amount' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerBotsCooldowns
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerBotsCooldowns final
{
public:
	bool                                          bIgnoreCooldowns;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerBotsCooldowns) == 0x000001, "Wrong alignment on HWCheatComponent_ServerBotsCooldowns");
static_assert(sizeof(HWCheatComponent_ServerBotsCooldowns) == 0x000001, "Wrong size on HWCheatComponent_ServerBotsCooldowns");
static_assert(offsetof(HWCheatComponent_ServerBotsCooldowns, bIgnoreCooldowns) == 0x000000, "Member 'HWCheatComponent_ServerBotsCooldowns::bIgnoreCooldowns' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerBotShootHUD
// 0x0020 (0x0020 - 0x0000)
struct HWCheatComponent_ServerBotShootHUD final
{
public:
	int32                                         AbilityNumber;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BotName;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerBotShootHUD) == 0x000008, "Wrong alignment on HWCheatComponent_ServerBotShootHUD");
static_assert(sizeof(HWCheatComponent_ServerBotShootHUD) == 0x000020, "Wrong size on HWCheatComponent_ServerBotShootHUD");
static_assert(offsetof(HWCheatComponent_ServerBotShootHUD, AbilityNumber) == 0x000000, "Member 'HWCheatComponent_ServerBotShootHUD::AbilityNumber' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerBotShootHUD, BotName) == 0x000008, "Member 'HWCheatComponent_ServerBotShootHUD::BotName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerBotShootHUD, WaitTime) == 0x000018, "Member 'HWCheatComponent_ServerBotShootHUD::WaitTime' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerBotShootHUD, Count) == 0x00001C, "Member 'HWCheatComponent_ServerBotShootHUD::Count' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerBotsImmune
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerBotsImmune final
{
public:
	bool                                          bImmunity;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerBotsImmune) == 0x000001, "Wrong alignment on HWCheatComponent_ServerBotsImmune");
static_assert(sizeof(HWCheatComponent_ServerBotsImmune) == 0x000001, "Wrong size on HWCheatComponent_ServerBotsImmune");
static_assert(offsetof(HWCheatComponent_ServerBotsImmune, bImmunity) == 0x000000, "Member 'HWCheatComponent_ServerBotsImmune::bImmunity' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerBotsLevel
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_ServerBotsLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerBotsLevel) == 0x000004, "Wrong alignment on HWCheatComponent_ServerBotsLevel");
static_assert(sizeof(HWCheatComponent_ServerBotsLevel) == 0x000004, "Wrong size on HWCheatComponent_ServerBotsLevel");
static_assert(offsetof(HWCheatComponent_ServerBotsLevel, Level) == 0x000000, "Member 'HWCheatComponent_ServerBotsLevel::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerBotsOrbit
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerBotsOrbit final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlobal;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_ServerBotsOrbit) == 0x000004, "Wrong alignment on HWCheatComponent_ServerBotsOrbit");
static_assert(sizeof(HWCheatComponent_ServerBotsOrbit) == 0x000008, "Wrong size on HWCheatComponent_ServerBotsOrbit");
static_assert(offsetof(HWCheatComponent_ServerBotsOrbit, Radius) == 0x000000, "Member 'HWCheatComponent_ServerBotsOrbit::Radius' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerBotsOrbit, bGlobal) == 0x000004, "Member 'HWCheatComponent_ServerBotsOrbit::bGlobal' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerBotsPatrol
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerBotsPatrol final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlobal;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_ServerBotsPatrol) == 0x000004, "Wrong alignment on HWCheatComponent_ServerBotsPatrol");
static_assert(sizeof(HWCheatComponent_ServerBotsPatrol) == 0x000008, "Wrong size on HWCheatComponent_ServerBotsPatrol");
static_assert(offsetof(HWCheatComponent_ServerBotsPatrol, Distance) == 0x000000, "Member 'HWCheatComponent_ServerBotsPatrol::Distance' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerBotsPatrol, bGlobal) == 0x000004, "Member 'HWCheatComponent_ServerBotsPatrol::bGlobal' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerBotsShoot
// 0x0028 (0x0028 - 0x0000)
struct HWCheatComponent_ServerBotsShoot final
{
public:
	class FString                                 BotName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityNumber;                                     // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefireTime;                                        // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RefireInput;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerBotsShoot) == 0x000008, "Wrong alignment on HWCheatComponent_ServerBotsShoot");
static_assert(sizeof(HWCheatComponent_ServerBotsShoot) == 0x000028, "Wrong size on HWCheatComponent_ServerBotsShoot");
static_assert(offsetof(HWCheatComponent_ServerBotsShoot, BotName) == 0x000000, "Member 'HWCheatComponent_ServerBotsShoot::BotName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerBotsShoot, AbilityNumber) == 0x000010, "Member 'HWCheatComponent_ServerBotsShoot::AbilityNumber' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerBotsShoot, WaitTime) == 0x000014, "Member 'HWCheatComponent_ServerBotsShoot::WaitTime' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerBotsShoot, Count) == 0x000018, "Member 'HWCheatComponent_ServerBotsShoot::Count' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerBotsShoot, RefireTime) == 0x00001C, "Member 'HWCheatComponent_ServerBotsShoot::RefireTime' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerBotsShoot, RefireInput) == 0x000020, "Member 'HWCheatComponent_ServerBotsShoot::RefireInput' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerBotsSkillsToLevel
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_ServerBotsSkillsToLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerBotsSkillsToLevel) == 0x000004, "Wrong alignment on HWCheatComponent_ServerBotsSkillsToLevel");
static_assert(sizeof(HWCheatComponent_ServerBotsSkillsToLevel) == 0x000004, "Wrong size on HWCheatComponent_ServerBotsSkillsToLevel");
static_assert(offsetof(HWCheatComponent_ServerBotsSkillsToLevel, Level) == 0x000000, "Member 'HWCheatComponent_ServerBotsSkillsToLevel::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerBotsUp
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerBotsUp final
{
public:
	bool                                          bToggle;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerBotsUp) == 0x000001, "Wrong alignment on HWCheatComponent_ServerBotsUp");
static_assert(sizeof(HWCheatComponent_ServerBotsUp) == 0x000001, "Wrong size on HWCheatComponent_ServerBotsUp");
static_assert(offsetof(HWCheatComponent_ServerBotsUp, bToggle) == 0x000000, "Member 'HWCheatComponent_ServerBotsUp::bToggle' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerCharacterTestCheat
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerCharacterTestCheat final
{
public:
	bool                                          bSetActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         testInt;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerCharacterTestCheat) == 0x000004, "Wrong alignment on HWCheatComponent_ServerCharacterTestCheat");
static_assert(sizeof(HWCheatComponent_ServerCharacterTestCheat) == 0x000008, "Wrong size on HWCheatComponent_ServerCharacterTestCheat");
static_assert(offsetof(HWCheatComponent_ServerCharacterTestCheat, bSetActive) == 0x000000, "Member 'HWCheatComponent_ServerCharacterTestCheat::bSetActive' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerCharacterTestCheat, testInt) == 0x000004, "Member 'HWCheatComponent_ServerCharacterTestCheat::testInt' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerDebugMinimap
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerDebugMinimap final
{
public:
	class FName                                   UniqueNameTag;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerDebugMinimap) == 0x000004, "Wrong alignment on HWCheatComponent_ServerDebugMinimap");
static_assert(sizeof(HWCheatComponent_ServerDebugMinimap) == 0x000008, "Wrong size on HWCheatComponent_ServerDebugMinimap");
static_assert(offsetof(HWCheatComponent_ServerDebugMinimap, UniqueNameTag) == 0x000000, "Member 'HWCheatComponent_ServerDebugMinimap::UniqueNameTag' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerDestroyNextTowerInLane
// 0x000C (0x000C - 0x0000)
struct HWCheatComponent_ServerDestroyNextTowerInLane final
{
public:
	class FName                                   Lane;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemy;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_ServerDestroyNextTowerInLane) == 0x000004, "Wrong alignment on HWCheatComponent_ServerDestroyNextTowerInLane");
static_assert(sizeof(HWCheatComponent_ServerDestroyNextTowerInLane) == 0x00000C, "Wrong size on HWCheatComponent_ServerDestroyNextTowerInLane");
static_assert(offsetof(HWCheatComponent_ServerDestroyNextTowerInLane, Lane) == 0x000000, "Member 'HWCheatComponent_ServerDestroyNextTowerInLane::Lane' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerDestroyNextTowerInLane, bEnemy) == 0x000008, "Member 'HWCheatComponent_ServerDestroyNextTowerInLane::bEnemy' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerExec
// 0x0010 (0x0010 - 0x0000)
struct HWCheatComponent_ServerExec final
{
public:
	class FString                                 Request;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerExec) == 0x000008, "Wrong alignment on HWCheatComponent_ServerExec");
static_assert(sizeof(HWCheatComponent_ServerExec) == 0x000010, "Wrong size on HWCheatComponent_ServerExec");
static_assert(offsetof(HWCheatComponent_ServerExec, Request) == 0x000000, "Member 'HWCheatComponent_ServerExec::Request' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerExecCall
// 0x0010 (0x0010 - 0x0000)
struct HWCheatComponent_ServerExecCall final
{
public:
	class FString                                 Request;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerExecCall) == 0x000008, "Wrong alignment on HWCheatComponent_ServerExecCall");
static_assert(sizeof(HWCheatComponent_ServerExecCall) == 0x000010, "Wrong size on HWCheatComponent_ServerExecCall");
static_assert(offsetof(HWCheatComponent_ServerExecCall, Request) == 0x000000, "Member 'HWCheatComponent_ServerExecCall::Request' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerKillAllMinions
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerKillAllMinions final
{
public:
	bool                                          bPreventNewMinions;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerKillAllMinions) == 0x000001, "Wrong alignment on HWCheatComponent_ServerKillAllMinions");
static_assert(sizeof(HWCheatComponent_ServerKillAllMinions) == 0x000001, "Wrong size on HWCheatComponent_ServerKillAllMinions");
static_assert(offsetof(HWCheatComponent_ServerKillAllMinions, bPreventNewMinions) == 0x000000, "Member 'HWCheatComponent_ServerKillAllMinions::bPreventNewMinions' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerQuickEndGame
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerQuickEndGame final
{
public:
	bool                                          bWin;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerQuickEndGame) == 0x000001, "Wrong alignment on HWCheatComponent_ServerQuickEndGame");
static_assert(sizeof(HWCheatComponent_ServerQuickEndGame) == 0x000001, "Wrong size on HWCheatComponent_ServerQuickEndGame");
static_assert(offsetof(HWCheatComponent_ServerQuickEndGame, bWin) == 0x000000, "Member 'HWCheatComponent_ServerQuickEndGame::bWin' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetAnnouncerPack
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerSetAnnouncerPack final
{
public:
	class FName                                   AnnouncerPackName;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetAnnouncerPack) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetAnnouncerPack");
static_assert(sizeof(HWCheatComponent_ServerSetAnnouncerPack) == 0x000008, "Wrong size on HWCheatComponent_ServerSetAnnouncerPack");
static_assert(offsetof(HWCheatComponent_ServerSetAnnouncerPack, AnnouncerPackName) == 0x000000, "Member 'HWCheatComponent_ServerSetAnnouncerPack::AnnouncerPackName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetAutoBuy
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerSetAutoBuy final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetAutoBuy) == 0x000001, "Wrong alignment on HWCheatComponent_ServerSetAutoBuy");
static_assert(sizeof(HWCheatComponent_ServerSetAutoBuy) == 0x000001, "Wrong size on HWCheatComponent_ServerSetAutoBuy");
static_assert(offsetof(HWCheatComponent_ServerSetAutoBuy, bEnable) == 0x000000, "Member 'HWCheatComponent_ServerSetAutoBuy::bEnable' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetAutoSkill
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerSetAutoSkill final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetAutoSkill) == 0x000001, "Wrong alignment on HWCheatComponent_ServerSetAutoSkill");
static_assert(sizeof(HWCheatComponent_ServerSetAutoSkill) == 0x000001, "Wrong size on HWCheatComponent_ServerSetAutoSkill");
static_assert(offsetof(HWCheatComponent_ServerSetAutoSkill, bEnable) == 0x000000, "Member 'HWCheatComponent_ServerSetAutoSkill::bEnable' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetCharacter
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerSetCharacter final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetCharacter) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetCharacter");
static_assert(sizeof(HWCheatComponent_ServerSetCharacter) == 0x000008, "Wrong size on HWCheatComponent_ServerSetCharacter");
static_assert(offsetof(HWCheatComponent_ServerSetCharacter, Name_0) == 0x000000, "Member 'HWCheatComponent_ServerSetCharacter::Name_0' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetCharacterRole
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerSetCharacterRole final
{
public:
	ECharacterRole                                NewRole;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetCharacterRole) == 0x000001, "Wrong alignment on HWCheatComponent_ServerSetCharacterRole");
static_assert(sizeof(HWCheatComponent_ServerSetCharacterRole) == 0x000001, "Wrong size on HWCheatComponent_ServerSetCharacterRole");
static_assert(offsetof(HWCheatComponent_ServerSetCharacterRole, NewRole) == 0x000000, "Member 'HWCheatComponent_ServerSetCharacterRole::NewRole' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetGlobalEmote
// 0x000C (0x000C - 0x0000)
struct HWCheatComponent_ServerSetGlobalEmote final
{
public:
	class FName                                   GlobalEmoteName;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetGlobalEmote) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetGlobalEmote");
static_assert(sizeof(HWCheatComponent_ServerSetGlobalEmote) == 0x00000C, "Wrong size on HWCheatComponent_ServerSetGlobalEmote");
static_assert(offsetof(HWCheatComponent_ServerSetGlobalEmote, GlobalEmoteName) == 0x000000, "Member 'HWCheatComponent_ServerSetGlobalEmote::GlobalEmoteName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSetGlobalEmote, SlotIndex) == 0x000008, "Member 'HWCheatComponent_ServerSetGlobalEmote::SlotIndex' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetInventoryAutoSortEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerSetInventoryAutoSortEnabled final
{
public:
	bool                                          bAutoSortEnabled;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetInventoryAutoSortEnabled) == 0x000001, "Wrong alignment on HWCheatComponent_ServerSetInventoryAutoSortEnabled");
static_assert(sizeof(HWCheatComponent_ServerSetInventoryAutoSortEnabled) == 0x000001, "Wrong size on HWCheatComponent_ServerSetInventoryAutoSortEnabled");
static_assert(offsetof(HWCheatComponent_ServerSetInventoryAutoSortEnabled, bAutoSortEnabled) == 0x000000, "Member 'HWCheatComponent_ServerSetInventoryAutoSortEnabled::bAutoSortEnabled' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetJumpStamp
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerSetJumpStamp final
{
public:
	class FName                                   JumpStampName;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetJumpStamp) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetJumpStamp");
static_assert(sizeof(HWCheatComponent_ServerSetJumpStamp) == 0x000008, "Wrong size on HWCheatComponent_ServerSetJumpStamp");
static_assert(offsetof(HWCheatComponent_ServerSetJumpStamp, JumpStampName) == 0x000000, "Member 'HWCheatComponent_ServerSetJumpStamp::JumpStampName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetLevel
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_ServerSetLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetLevel) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetLevel");
static_assert(sizeof(HWCheatComponent_ServerSetLevel) == 0x000004, "Wrong size on HWCheatComponent_ServerSetLevel");
static_assert(offsetof(HWCheatComponent_ServerSetLevel, Level) == 0x000000, "Member 'HWCheatComponent_ServerSetLevel::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetScore
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerSetScore final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetScore) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetScore");
static_assert(sizeof(HWCheatComponent_ServerSetScore) == 0x000008, "Wrong size on HWCheatComponent_ServerSetScore");
static_assert(offsetof(HWCheatComponent_ServerSetScore, TeamId) == 0x000000, "Member 'HWCheatComponent_ServerSetScore::TeamId' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSetScore, Score) == 0x000004, "Member 'HWCheatComponent_ServerSetScore::Score' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetSkin
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerSetSkin final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetSkin) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetSkin");
static_assert(sizeof(HWCheatComponent_ServerSetSkin) == 0x000008, "Wrong size on HWCheatComponent_ServerSetSkin");
static_assert(offsetof(HWCheatComponent_ServerSetSkin, Name_0) == 0x000000, "Member 'HWCheatComponent_ServerSetSkin::Name_0' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetSoundEmote
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerSetSoundEmote final
{
public:
	class FName                                   SoundEmoteName;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetSoundEmote) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetSoundEmote");
static_assert(sizeof(HWCheatComponent_ServerSetSoundEmote) == 0x000008, "Wrong size on HWCheatComponent_ServerSetSoundEmote");
static_assert(offsetof(HWCheatComponent_ServerSetSoundEmote, SoundEmoteName) == 0x000000, "Member 'HWCheatComponent_ServerSetSoundEmote::SoundEmoteName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetTeam
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_ServerSetTeam final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetTeam) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetTeam");
static_assert(sizeof(HWCheatComponent_ServerSetTeam) == 0x000004, "Wrong size on HWCheatComponent_ServerSetTeam");
static_assert(offsetof(HWCheatComponent_ServerSetTeam, TeamId) == 0x000000, "Member 'HWCheatComponent_ServerSetTeam::TeamId' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetTeleporterSkin
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerSetTeleporterSkin final
{
public:
	class FName                                   TeleporterSkinName;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetTeleporterSkin) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetTeleporterSkin");
static_assert(sizeof(HWCheatComponent_ServerSetTeleporterSkin) == 0x000008, "Wrong size on HWCheatComponent_ServerSetTeleporterSkin");
static_assert(offsetof(HWCheatComponent_ServerSetTeleporterSkin, TeleporterSkinName) == 0x000000, "Member 'HWCheatComponent_ServerSetTeleporterSkin::TeleporterSkinName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetVoicePackType
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_ServerSetVoicePackType final
{
public:
	int32                                         VoicePackType;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetVoicePackType) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetVoicePackType");
static_assert(sizeof(HWCheatComponent_ServerSetVoicePackType) == 0x000004, "Wrong size on HWCheatComponent_ServerSetVoicePackType");
static_assert(offsetof(HWCheatComponent_ServerSetVoicePackType, VoicePackType) == 0x000000, "Member 'HWCheatComponent_ServerSetVoicePackType::VoicePackType' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSetWardSkin
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerSetWardSkin final
{
public:
	class FName                                   WardSkinName;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSetWardSkin) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSetWardSkin");
static_assert(sizeof(HWCheatComponent_ServerSetWardSkin) == 0x000008, "Wrong size on HWCheatComponent_ServerSetWardSkin");
static_assert(offsetof(HWCheatComponent_ServerSetWardSkin, WardSkinName) == 0x000000, "Member 'HWCheatComponent_ServerSetWardSkin::WardSkinName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSlomo
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_ServerSlomo final
{
public:
	float                                         NewTimeDilation;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSlomo) == 0x000004, "Wrong alignment on HWCheatComponent_ServerSlomo");
static_assert(sizeof(HWCheatComponent_ServerSlomo) == 0x000004, "Wrong size on HWCheatComponent_ServerSlomo");
static_assert(offsetof(HWCheatComponent_ServerSlomo, NewTimeDilation) == 0x000000, "Member 'HWCheatComponent_ServerSlomo::NewTimeDilation' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSpawnBot
// 0x0030 (0x0030 - 0x0000)
struct HWCheatComponent_ServerSpawnBot final
{
public:
	class FName                                   BotRowName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BotSkinName;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorName;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0028(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0029(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Count;                                             // 0x002A(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_ServerSpawnBot) == 0x000008, "Wrong alignment on HWCheatComponent_ServerSpawnBot");
static_assert(sizeof(HWCheatComponent_ServerSpawnBot) == 0x000030, "Wrong size on HWCheatComponent_ServerSpawnBot");
static_assert(offsetof(HWCheatComponent_ServerSpawnBot, BotRowName) == 0x000000, "Member 'HWCheatComponent_ServerSpawnBot::BotRowName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSpawnBot, BotSkinName) == 0x000008, "Member 'HWCheatComponent_ServerSpawnBot::BotSkinName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSpawnBot, ActorName) == 0x000018, "Member 'HWCheatComponent_ServerSpawnBot::ActorName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSpawnBot, TeamId) == 0x000028, "Member 'HWCheatComponent_ServerSpawnBot::TeamId' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSpawnBot, Level) == 0x000029, "Member 'HWCheatComponent_ServerSpawnBot::Level' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSpawnBot, Count) == 0x00002A, "Member 'HWCheatComponent_ServerSpawnBot::Count' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSpawnBotHUD
// 0x0030 (0x0030 - 0x0000)
struct HWCheatComponent_ServerSpawnBotHUD final
{
public:
	class FName                                   BotRowName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BotSkinName;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorName;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0028(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0029(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_ServerSpawnBotHUD) == 0x000008, "Wrong alignment on HWCheatComponent_ServerSpawnBotHUD");
static_assert(sizeof(HWCheatComponent_ServerSpawnBotHUD) == 0x000030, "Wrong size on HWCheatComponent_ServerSpawnBotHUD");
static_assert(offsetof(HWCheatComponent_ServerSpawnBotHUD, BotRowName) == 0x000000, "Member 'HWCheatComponent_ServerSpawnBotHUD::BotRowName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSpawnBotHUD, BotSkinName) == 0x000008, "Member 'HWCheatComponent_ServerSpawnBotHUD::BotSkinName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSpawnBotHUD, ActorName) == 0x000018, "Member 'HWCheatComponent_ServerSpawnBotHUD::ActorName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSpawnBotHUD, TeamId) == 0x000028, "Member 'HWCheatComponent_ServerSpawnBotHUD::TeamId' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerSpawnBotHUD, Level) == 0x000029, "Member 'HWCheatComponent_ServerSpawnBotHUD::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSuicideBots
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerSuicideBots final
{
public:
	bool                                          bGodsOnly;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSuicideBots) == 0x000001, "Wrong alignment on HWCheatComponent_ServerSuicideBots");
static_assert(sizeof(HWCheatComponent_ServerSuicideBots) == 0x000001, "Wrong size on HWCheatComponent_ServerSuicideBots");
static_assert(offsetof(HWCheatComponent_ServerSuicideBots, bGodsOnly) == 0x000000, "Member 'HWCheatComponent_ServerSuicideBots::bGodsOnly' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerSuperSonic
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerSuperSonic final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerSuperSonic) == 0x000001, "Wrong alignment on HWCheatComponent_ServerSuperSonic");
static_assert(sizeof(HWCheatComponent_ServerSuperSonic) == 0x000001, "Wrong size on HWCheatComponent_ServerSuperSonic");
static_assert(offsetof(HWCheatComponent_ServerSuperSonic, bEnable) == 0x000000, "Member 'HWCheatComponent_ServerSuperSonic::bEnable' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerTestEffect
// 0x0010 (0x0010 - 0x0000)
struct HWCheatComponent_ServerTestEffect final
{
public:
	class FName                                   EffectName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerTestEffect) == 0x000004, "Wrong alignment on HWCheatComponent_ServerTestEffect");
static_assert(sizeof(HWCheatComponent_ServerTestEffect) == 0x000010, "Wrong size on HWCheatComponent_ServerTestEffect");
static_assert(offsetof(HWCheatComponent_ServerTestEffect, EffectName) == 0x000000, "Member 'HWCheatComponent_ServerTestEffect::EffectName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerTestEffect, Duration) == 0x000008, "Member 'HWCheatComponent_ServerTestEffect::Duration' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerTestEffect, Magnitude) == 0x00000C, "Member 'HWCheatComponent_ServerTestEffect::Magnitude' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerTestEffectOnTarget
// 0x0010 (0x0010 - 0x0000)
struct HWCheatComponent_ServerTestEffectOnTarget final
{
public:
	class FName                                   EffectName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerTestEffectOnTarget) == 0x000004, "Wrong alignment on HWCheatComponent_ServerTestEffectOnTarget");
static_assert(sizeof(HWCheatComponent_ServerTestEffectOnTarget) == 0x000010, "Wrong size on HWCheatComponent_ServerTestEffectOnTarget");
static_assert(offsetof(HWCheatComponent_ServerTestEffectOnTarget, EffectName) == 0x000000, "Member 'HWCheatComponent_ServerTestEffectOnTarget::EffectName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerTestEffectOnTarget, Duration) == 0x000008, "Member 'HWCheatComponent_ServerTestEffectOnTarget::Duration' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerTestEffectOnTarget, Magnitude) == 0x00000C, "Member 'HWCheatComponent_ServerTestEffectOnTarget::Magnitude' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerTestQuest
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_ServerTestQuest final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerTestQuest) == 0x000004, "Wrong alignment on HWCheatComponent_ServerTestQuest");
static_assert(sizeof(HWCheatComponent_ServerTestQuest) == 0x000004, "Wrong size on HWCheatComponent_ServerTestQuest");
static_assert(offsetof(HWCheatComponent_ServerTestQuest, ItemId) == 0x000000, "Member 'HWCheatComponent_ServerTestQuest::ItemId' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerTestTalent
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_ServerTestTalent final
{
public:
	class FName                                   TalentName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerTestTalent) == 0x000004, "Wrong alignment on HWCheatComponent_ServerTestTalent");
static_assert(sizeof(HWCheatComponent_ServerTestTalent) == 0x000008, "Wrong size on HWCheatComponent_ServerTestTalent");
static_assert(offsetof(HWCheatComponent_ServerTestTalent, TalentName) == 0x000000, "Member 'HWCheatComponent_ServerTestTalent::TalentName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerToggleGodBotDebugDisplay
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerToggleGodBotDebugDisplay final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerToggleGodBotDebugDisplay) == 0x000001, "Wrong alignment on HWCheatComponent_ServerToggleGodBotDebugDisplay");
static_assert(sizeof(HWCheatComponent_ServerToggleGodBotDebugDisplay) == 0x000001, "Wrong size on HWCheatComponent_ServerToggleGodBotDebugDisplay");
static_assert(offsetof(HWCheatComponent_ServerToggleGodBotDebugDisplay, bOn) == 0x000000, "Member 'HWCheatComponent_ServerToggleGodBotDebugDisplay::bOn' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerToggleItemEquip
// 0x0018 (0x0018 - 0x0000)
struct HWCheatComponent_ServerToggleItemEquip final
{
public:
	const class UHWEquipmentItem*                 Equipment;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       InventorySlot;                                     // 0x0008(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_ServerToggleItemEquip) == 0x000008, "Wrong alignment on HWCheatComponent_ServerToggleItemEquip");
static_assert(sizeof(HWCheatComponent_ServerToggleItemEquip) == 0x000018, "Wrong size on HWCheatComponent_ServerToggleItemEquip");
static_assert(offsetof(HWCheatComponent_ServerToggleItemEquip, Equipment) == 0x000000, "Member 'HWCheatComponent_ServerToggleItemEquip::Equipment' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_ServerToggleItemEquip, InventorySlot) == 0x000008, "Member 'HWCheatComponent_ServerToggleItemEquip::InventorySlot' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerTogglePrefireTest
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerTogglePrefireTest final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerTogglePrefireTest) == 0x000001, "Wrong alignment on HWCheatComponent_ServerTogglePrefireTest");
static_assert(sizeof(HWCheatComponent_ServerTogglePrefireTest) == 0x000001, "Wrong size on HWCheatComponent_ServerTogglePrefireTest");
static_assert(offsetof(HWCheatComponent_ServerTogglePrefireTest, bOn) == 0x000000, "Member 'HWCheatComponent_ServerTogglePrefireTest::bOn' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ServerTowerKiller
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ServerTowerKiller final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ServerTowerKiller) == 0x000001, "Wrong alignment on HWCheatComponent_ServerTowerKiller");
static_assert(sizeof(HWCheatComponent_ServerTowerKiller) == 0x000001, "Wrong size on HWCheatComponent_ServerTowerKiller");
static_assert(offsetof(HWCheatComponent_ServerTowerKiller, bEnable) == 0x000000, "Member 'HWCheatComponent_ServerTowerKiller::bEnable' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetAbilityTargetingDebug
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_SetAbilityTargetingDebug final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetAbilityTargetingDebug) == 0x000001, "Wrong alignment on HWCheatComponent_SetAbilityTargetingDebug");
static_assert(sizeof(HWCheatComponent_SetAbilityTargetingDebug) == 0x000001, "Wrong size on HWCheatComponent_SetAbilityTargetingDebug");
static_assert(offsetof(HWCheatComponent_SetAbilityTargetingDebug, bEnable) == 0x000000, "Member 'HWCheatComponent_SetAbilityTargetingDebug::bEnable' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetAnnouncerPack
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_SetAnnouncerPack final
{
public:
	class FName                                   AnnouncerPackName;                                 // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetAnnouncerPack) == 0x000004, "Wrong alignment on HWCheatComponent_SetAnnouncerPack");
static_assert(sizeof(HWCheatComponent_SetAnnouncerPack) == 0x000008, "Wrong size on HWCheatComponent_SetAnnouncerPack");
static_assert(offsetof(HWCheatComponent_SetAnnouncerPack, AnnouncerPackName) == 0x000000, "Member 'HWCheatComponent_SetAnnouncerPack::AnnouncerPackName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetAutoBuy
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_SetAutoBuy final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetAutoBuy) == 0x000001, "Wrong alignment on HWCheatComponent_SetAutoBuy");
static_assert(sizeof(HWCheatComponent_SetAutoBuy) == 0x000001, "Wrong size on HWCheatComponent_SetAutoBuy");
static_assert(offsetof(HWCheatComponent_SetAutoBuy, bEnable) == 0x000000, "Member 'HWCheatComponent_SetAutoBuy::bEnable' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetAutoSkill
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_SetAutoSkill final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetAutoSkill) == 0x000001, "Wrong alignment on HWCheatComponent_SetAutoSkill");
static_assert(sizeof(HWCheatComponent_SetAutoSkill) == 0x000001, "Wrong size on HWCheatComponent_SetAutoSkill");
static_assert(offsetof(HWCheatComponent_SetAutoSkill, bEnable) == 0x000000, "Member 'HWCheatComponent_SetAutoSkill::bEnable' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetCharacter
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_SetCharacter final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetCharacter) == 0x000004, "Wrong alignment on HWCheatComponent_SetCharacter");
static_assert(sizeof(HWCheatComponent_SetCharacter) == 0x000008, "Wrong size on HWCheatComponent_SetCharacter");
static_assert(offsetof(HWCheatComponent_SetCharacter, Name_0) == 0x000000, "Member 'HWCheatComponent_SetCharacter::Name_0' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetCharacterRole
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_SetCharacterRole final
{
public:
	ECharacterRole                                NewRole;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetCharacterRole) == 0x000001, "Wrong alignment on HWCheatComponent_SetCharacterRole");
static_assert(sizeof(HWCheatComponent_SetCharacterRole) == 0x000001, "Wrong size on HWCheatComponent_SetCharacterRole");
static_assert(offsetof(HWCheatComponent_SetCharacterRole, NewRole) == 0x000000, "Member 'HWCheatComponent_SetCharacterRole::NewRole' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetGlobalEmote
// 0x000C (0x000C - 0x0000)
struct HWCheatComponent_SetGlobalEmote final
{
public:
	class FName                                   GlobalEmoteName;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetGlobalEmote) == 0x000004, "Wrong alignment on HWCheatComponent_SetGlobalEmote");
static_assert(sizeof(HWCheatComponent_SetGlobalEmote) == 0x00000C, "Wrong size on HWCheatComponent_SetGlobalEmote");
static_assert(offsetof(HWCheatComponent_SetGlobalEmote, GlobalEmoteName) == 0x000000, "Member 'HWCheatComponent_SetGlobalEmote::GlobalEmoteName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SetGlobalEmote, SlotIndex) == 0x000008, "Member 'HWCheatComponent_SetGlobalEmote::SlotIndex' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetInventoryAutoSortEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_SetInventoryAutoSortEnabled final
{
public:
	bool                                          bAutoSortEnabled;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetInventoryAutoSortEnabled) == 0x000001, "Wrong alignment on HWCheatComponent_SetInventoryAutoSortEnabled");
static_assert(sizeof(HWCheatComponent_SetInventoryAutoSortEnabled) == 0x000001, "Wrong size on HWCheatComponent_SetInventoryAutoSortEnabled");
static_assert(offsetof(HWCheatComponent_SetInventoryAutoSortEnabled, bAutoSortEnabled) == 0x000000, "Member 'HWCheatComponent_SetInventoryAutoSortEnabled::bAutoSortEnabled' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetJumpStamp
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_SetJumpStamp final
{
public:
	class FName                                   JumpStampName;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetJumpStamp) == 0x000004, "Wrong alignment on HWCheatComponent_SetJumpStamp");
static_assert(sizeof(HWCheatComponent_SetJumpStamp) == 0x000008, "Wrong size on HWCheatComponent_SetJumpStamp");
static_assert(offsetof(HWCheatComponent_SetJumpStamp, JumpStampName) == 0x000000, "Member 'HWCheatComponent_SetJumpStamp::JumpStampName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetLevel
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_SetLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetLevel) == 0x000004, "Wrong alignment on HWCheatComponent_SetLevel");
static_assert(sizeof(HWCheatComponent_SetLevel) == 0x000004, "Wrong size on HWCheatComponent_SetLevel");
static_assert(offsetof(HWCheatComponent_SetLevel, Level) == 0x000000, "Member 'HWCheatComponent_SetLevel::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetMusicPack
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_SetMusicPack final
{
public:
	class FName                                   MusicPackName;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetMusicPack) == 0x000004, "Wrong alignment on HWCheatComponent_SetMusicPack");
static_assert(sizeof(HWCheatComponent_SetMusicPack) == 0x000008, "Wrong size on HWCheatComponent_SetMusicPack");
static_assert(offsetof(HWCheatComponent_SetMusicPack, MusicPackName) == 0x000000, "Member 'HWCheatComponent_SetMusicPack::MusicPackName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetScore
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_SetScore final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetScore) == 0x000004, "Wrong alignment on HWCheatComponent_SetScore");
static_assert(sizeof(HWCheatComponent_SetScore) == 0x000008, "Wrong size on HWCheatComponent_SetScore");
static_assert(offsetof(HWCheatComponent_SetScore, TeamId) == 0x000000, "Member 'HWCheatComponent_SetScore::TeamId' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SetScore, Score) == 0x000004, "Member 'HWCheatComponent_SetScore::Score' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetSkin
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_SetSkin final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetSkin) == 0x000004, "Wrong alignment on HWCheatComponent_SetSkin");
static_assert(sizeof(HWCheatComponent_SetSkin) == 0x000008, "Wrong size on HWCheatComponent_SetSkin");
static_assert(offsetof(HWCheatComponent_SetSkin, Name_0) == 0x000000, "Member 'HWCheatComponent_SetSkin::Name_0' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetSoundEmote
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_SetSoundEmote final
{
public:
	class FName                                   SoundEmoteName;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetSoundEmote) == 0x000004, "Wrong alignment on HWCheatComponent_SetSoundEmote");
static_assert(sizeof(HWCheatComponent_SetSoundEmote) == 0x000008, "Wrong size on HWCheatComponent_SetSoundEmote");
static_assert(offsetof(HWCheatComponent_SetSoundEmote, SoundEmoteName) == 0x000000, "Member 'HWCheatComponent_SetSoundEmote::SoundEmoteName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetTeam
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_SetTeam final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetTeam) == 0x000004, "Wrong alignment on HWCheatComponent_SetTeam");
static_assert(sizeof(HWCheatComponent_SetTeam) == 0x000004, "Wrong size on HWCheatComponent_SetTeam");
static_assert(offsetof(HWCheatComponent_SetTeam, TeamId) == 0x000000, "Member 'HWCheatComponent_SetTeam::TeamId' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetTeleporterSkin
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_SetTeleporterSkin final
{
public:
	class FName                                   TeleporterSkinName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetTeleporterSkin) == 0x000004, "Wrong alignment on HWCheatComponent_SetTeleporterSkin");
static_assert(sizeof(HWCheatComponent_SetTeleporterSkin) == 0x000008, "Wrong size on HWCheatComponent_SetTeleporterSkin");
static_assert(offsetof(HWCheatComponent_SetTeleporterSkin, TeleporterSkinName) == 0x000000, "Member 'HWCheatComponent_SetTeleporterSkin::TeleporterSkinName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetVoicePackType
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_SetVoicePackType final
{
public:
	int32                                         VoicePackType;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetVoicePackType) == 0x000004, "Wrong alignment on HWCheatComponent_SetVoicePackType");
static_assert(sizeof(HWCheatComponent_SetVoicePackType) == 0x000004, "Wrong size on HWCheatComponent_SetVoicePackType");
static_assert(offsetof(HWCheatComponent_SetVoicePackType, VoicePackType) == 0x000000, "Member 'HWCheatComponent_SetVoicePackType::VoicePackType' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SetWardSkin
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_SetWardSkin final
{
public:
	class FName                                   WardSkinName;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SetWardSkin) == 0x000004, "Wrong alignment on HWCheatComponent_SetWardSkin");
static_assert(sizeof(HWCheatComponent_SetWardSkin) == 0x000008, "Wrong size on HWCheatComponent_SetWardSkin");
static_assert(offsetof(HWCheatComponent_SetWardSkin, WardSkinName) == 0x000000, "Member 'HWCheatComponent_SetWardSkin::WardSkinName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.Slomo
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_Slomo final
{
public:
	float                                         NewTimeDilation;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_Slomo) == 0x000004, "Wrong alignment on HWCheatComponent_Slomo");
static_assert(sizeof(HWCheatComponent_Slomo) == 0x000004, "Wrong size on HWCheatComponent_Slomo");
static_assert(offsetof(HWCheatComponent_Slomo, NewTimeDilation) == 0x000000, "Member 'HWCheatComponent_Slomo::NewTimeDilation' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SpawnBot
// 0x000C (0x000C - 0x0000)
struct HWCheatComponent_SpawnBot final
{
public:
	class FName                                   BotRowName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_SpawnBot) == 0x000004, "Wrong alignment on HWCheatComponent_SpawnBot");
static_assert(sizeof(HWCheatComponent_SpawnBot) == 0x00000C, "Wrong size on HWCheatComponent_SpawnBot");
static_assert(offsetof(HWCheatComponent_SpawnBot, BotRowName) == 0x000000, "Member 'HWCheatComponent_SpawnBot::BotRowName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBot, TeamId) == 0x000008, "Member 'HWCheatComponent_SpawnBot::TeamId' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBot, Level) == 0x000009, "Member 'HWCheatComponent_SpawnBot::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SpawnBotHUD
// 0x0030 (0x0030 - 0x0000)
struct HWCheatComponent_SpawnBotHUD final
{
public:
	class FName                                   BotRowName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BotSkinName;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorName;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0028(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0029(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_SpawnBotHUD) == 0x000008, "Wrong alignment on HWCheatComponent_SpawnBotHUD");
static_assert(sizeof(HWCheatComponent_SpawnBotHUD) == 0x000030, "Wrong size on HWCheatComponent_SpawnBotHUD");
static_assert(offsetof(HWCheatComponent_SpawnBotHUD, BotRowName) == 0x000000, "Member 'HWCheatComponent_SpawnBotHUD::BotRowName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBotHUD, BotSkinName) == 0x000008, "Member 'HWCheatComponent_SpawnBotHUD::BotSkinName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBotHUD, ActorName) == 0x000018, "Member 'HWCheatComponent_SpawnBotHUD::ActorName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBotHUD, TeamId) == 0x000028, "Member 'HWCheatComponent_SpawnBotHUD::TeamId' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBotHUD, Level) == 0x000029, "Member 'HWCheatComponent_SpawnBotHUD::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SpawnBots
// 0x000C (0x000C - 0x0000)
struct HWCheatComponent_SpawnBots final
{
public:
	class FName                                   BotRowName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Count;                                             // 0x000A(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_SpawnBots) == 0x000004, "Wrong alignment on HWCheatComponent_SpawnBots");
static_assert(sizeof(HWCheatComponent_SpawnBots) == 0x00000C, "Wrong size on HWCheatComponent_SpawnBots");
static_assert(offsetof(HWCheatComponent_SpawnBots, BotRowName) == 0x000000, "Member 'HWCheatComponent_SpawnBots::BotRowName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBots, TeamId) == 0x000008, "Member 'HWCheatComponent_SpawnBots::TeamId' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBots, Level) == 0x000009, "Member 'HWCheatComponent_SpawnBots::Level' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBots, Count) == 0x00000A, "Member 'HWCheatComponent_SpawnBots::Count' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SpawnBotWithSkin
// 0x0020 (0x0020 - 0x0000)
struct HWCheatComponent_SpawnBotWithSkin final
{
public:
	class FName                                   BotRowName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BotSkinName;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0019(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_SpawnBotWithSkin) == 0x000008, "Wrong alignment on HWCheatComponent_SpawnBotWithSkin");
static_assert(sizeof(HWCheatComponent_SpawnBotWithSkin) == 0x000020, "Wrong size on HWCheatComponent_SpawnBotWithSkin");
static_assert(offsetof(HWCheatComponent_SpawnBotWithSkin, BotRowName) == 0x000000, "Member 'HWCheatComponent_SpawnBotWithSkin::BotRowName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBotWithSkin, BotSkinName) == 0x000008, "Member 'HWCheatComponent_SpawnBotWithSkin::BotSkinName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBotWithSkin, TeamId) == 0x000018, "Member 'HWCheatComponent_SpawnBotWithSkin::TeamId' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnBotWithSkin, Level) == 0x000019, "Member 'HWCheatComponent_SpawnBotWithSkin::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SpawnNamedBot
// 0x0020 (0x0020 - 0x0000)
struct HWCheatComponent_SpawnNamedBot final
{
public:
	class FName                                   BotRowName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorName;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0019(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_SpawnNamedBot) == 0x000008, "Wrong alignment on HWCheatComponent_SpawnNamedBot");
static_assert(sizeof(HWCheatComponent_SpawnNamedBot) == 0x000020, "Wrong size on HWCheatComponent_SpawnNamedBot");
static_assert(offsetof(HWCheatComponent_SpawnNamedBot, BotRowName) == 0x000000, "Member 'HWCheatComponent_SpawnNamedBot::BotRowName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnNamedBot, ActorName) == 0x000008, "Member 'HWCheatComponent_SpawnNamedBot::ActorName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnNamedBot, TeamId) == 0x000018, "Member 'HWCheatComponent_SpawnNamedBot::TeamId' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_SpawnNamedBot, Level) == 0x000019, "Member 'HWCheatComponent_SpawnNamedBot::Level' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SuicideBots
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_SuicideBots final
{
public:
	bool                                          bGodsOnly;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SuicideBots) == 0x000001, "Wrong alignment on HWCheatComponent_SuicideBots");
static_assert(sizeof(HWCheatComponent_SuicideBots) == 0x000001, "Wrong size on HWCheatComponent_SuicideBots");
static_assert(offsetof(HWCheatComponent_SuicideBots, bGodsOnly) == 0x000000, "Member 'HWCheatComponent_SuicideBots::bGodsOnly' has a wrong offset!");

// Function Hemingway.HWCheatComponent.SuperSonic
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_SuperSonic final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_SuperSonic) == 0x000001, "Wrong alignment on HWCheatComponent_SuperSonic");
static_assert(sizeof(HWCheatComponent_SuperSonic) == 0x000001, "Wrong size on HWCheatComponent_SuperSonic");
static_assert(offsetof(HWCheatComponent_SuperSonic, bEnable) == 0x000000, "Member 'HWCheatComponent_SuperSonic::bEnable' has a wrong offset!");

// Function Hemingway.HWCheatComponent.TestEffect
// 0x0010 (0x0010 - 0x0000)
struct HWCheatComponent_TestEffect final
{
public:
	class FName                                   EffectName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_TestEffect) == 0x000004, "Wrong alignment on HWCheatComponent_TestEffect");
static_assert(sizeof(HWCheatComponent_TestEffect) == 0x000010, "Wrong size on HWCheatComponent_TestEffect");
static_assert(offsetof(HWCheatComponent_TestEffect, EffectName) == 0x000000, "Member 'HWCheatComponent_TestEffect::EffectName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_TestEffect, Duration) == 0x000008, "Member 'HWCheatComponent_TestEffect::Duration' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_TestEffect, Magnitude) == 0x00000C, "Member 'HWCheatComponent_TestEffect::Magnitude' has a wrong offset!");

// Function Hemingway.HWCheatComponent.TestEffectOnTarget
// 0x0010 (0x0010 - 0x0000)
struct HWCheatComponent_TestEffectOnTarget final
{
public:
	class FName                                   EffectName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_TestEffectOnTarget) == 0x000004, "Wrong alignment on HWCheatComponent_TestEffectOnTarget");
static_assert(sizeof(HWCheatComponent_TestEffectOnTarget) == 0x000010, "Wrong size on HWCheatComponent_TestEffectOnTarget");
static_assert(offsetof(HWCheatComponent_TestEffectOnTarget, EffectName) == 0x000000, "Member 'HWCheatComponent_TestEffectOnTarget::EffectName' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_TestEffectOnTarget, Duration) == 0x000008, "Member 'HWCheatComponent_TestEffectOnTarget::Duration' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_TestEffectOnTarget, Magnitude) == 0x00000C, "Member 'HWCheatComponent_TestEffectOnTarget::Magnitude' has a wrong offset!");

// Function Hemingway.HWCheatComponent.TestQuest
// 0x0004 (0x0004 - 0x0000)
struct HWCheatComponent_TestQuest final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_TestQuest) == 0x000004, "Wrong alignment on HWCheatComponent_TestQuest");
static_assert(sizeof(HWCheatComponent_TestQuest) == 0x000004, "Wrong size on HWCheatComponent_TestQuest");
static_assert(offsetof(HWCheatComponent_TestQuest, ItemId) == 0x000000, "Member 'HWCheatComponent_TestQuest::ItemId' has a wrong offset!");

// Function Hemingway.HWCheatComponent.TestTalent
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_TestTalent final
{
public:
	class FName                                   TalentName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_TestTalent) == 0x000004, "Wrong alignment on HWCheatComponent_TestTalent");
static_assert(sizeof(HWCheatComponent_TestTalent) == 0x000008, "Wrong size on HWCheatComponent_TestTalent");
static_assert(offsetof(HWCheatComponent_TestTalent, TalentName) == 0x000000, "Member 'HWCheatComponent_TestTalent::TalentName' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ToggleGodBotDebugDisplay
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ToggleGodBotDebugDisplay final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ToggleGodBotDebugDisplay) == 0x000001, "Wrong alignment on HWCheatComponent_ToggleGodBotDebugDisplay");
static_assert(sizeof(HWCheatComponent_ToggleGodBotDebugDisplay) == 0x000001, "Wrong size on HWCheatComponent_ToggleGodBotDebugDisplay");
static_assert(offsetof(HWCheatComponent_ToggleGodBotDebugDisplay, bOn) == 0x000000, "Member 'HWCheatComponent_ToggleGodBotDebugDisplay::bOn' has a wrong offset!");

// Function Hemingway.HWCheatComponent.TogglePrefireTest
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_TogglePrefireTest final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_TogglePrefireTest) == 0x000001, "Wrong alignment on HWCheatComponent_TogglePrefireTest");
static_assert(sizeof(HWCheatComponent_TogglePrefireTest) == 0x000001, "Wrong size on HWCheatComponent_TogglePrefireTest");
static_assert(offsetof(HWCheatComponent_TogglePrefireTest, bOn) == 0x000000, "Member 'HWCheatComponent_TogglePrefireTest::bOn' has a wrong offset!");

// Function Hemingway.HWCheatComponent.TowerKiller
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_TowerKiller final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_TowerKiller) == 0x000001, "Wrong alignment on HWCheatComponent_TowerKiller");
static_assert(sizeof(HWCheatComponent_TowerKiller) == 0x000001, "Wrong size on HWCheatComponent_TowerKiller");
static_assert(offsetof(HWCheatComponent_TowerKiller, bEnable) == 0x000000, "Member 'HWCheatComponent_TowerKiller::bEnable' has a wrong offset!");

// Function Hemingway.HWCheatComponent.UpdatePlayerRolePreferences
// 0x0018 (0x0018 - 0x0000)
struct HWCheatComponent_UpdatePlayerRolePreferences final
{
public:
	int32                                         AssassinPreference;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SupportPreference;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ADCPreference;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SoloPreference;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MidPreference;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRoleFill;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCheatComponent_UpdatePlayerRolePreferences) == 0x000004, "Wrong alignment on HWCheatComponent_UpdatePlayerRolePreferences");
static_assert(sizeof(HWCheatComponent_UpdatePlayerRolePreferences) == 0x000018, "Wrong size on HWCheatComponent_UpdatePlayerRolePreferences");
static_assert(offsetof(HWCheatComponent_UpdatePlayerRolePreferences, AssassinPreference) == 0x000000, "Member 'HWCheatComponent_UpdatePlayerRolePreferences::AssassinPreference' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_UpdatePlayerRolePreferences, SupportPreference) == 0x000004, "Member 'HWCheatComponent_UpdatePlayerRolePreferences::SupportPreference' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_UpdatePlayerRolePreferences, ADCPreference) == 0x000008, "Member 'HWCheatComponent_UpdatePlayerRolePreferences::ADCPreference' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_UpdatePlayerRolePreferences, SoloPreference) == 0x00000C, "Member 'HWCheatComponent_UpdatePlayerRolePreferences::SoloPreference' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_UpdatePlayerRolePreferences, MidPreference) == 0x000010, "Member 'HWCheatComponent_UpdatePlayerRolePreferences::MidPreference' has a wrong offset!");
static_assert(offsetof(HWCheatComponent_UpdatePlayerRolePreferences, bRoleFill) == 0x000014, "Member 'HWCheatComponent_UpdatePlayerRolePreferences::bRoleFill' has a wrong offset!");

// Function Hemingway.HWCheatComponent.GetOuterController
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_GetOuterController final
{
public:
	class AController*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_GetOuterController) == 0x000008, "Wrong alignment on HWCheatComponent_GetOuterController");
static_assert(sizeof(HWCheatComponent_GetOuterController) == 0x000008, "Wrong size on HWCheatComponent_GetOuterController");
static_assert(offsetof(HWCheatComponent_GetOuterController, ReturnValue) == 0x000000, "Member 'HWCheatComponent_GetOuterController::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCheatComponent.GetOwningAbilitySystem
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_GetOwningAbilitySystem final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_GetOwningAbilitySystem) == 0x000008, "Wrong alignment on HWCheatComponent_GetOwningAbilitySystem");
static_assert(sizeof(HWCheatComponent_GetOwningAbilitySystem) == 0x000008, "Wrong size on HWCheatComponent_GetOwningAbilitySystem");
static_assert(offsetof(HWCheatComponent_GetOwningAbilitySystem, ReturnValue) == 0x000000, "Member 'HWCheatComponent_GetOwningAbilitySystem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCheatComponent.GetOwningCharacter
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_GetOwningCharacter final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_GetOwningCharacter) == 0x000008, "Wrong alignment on HWCheatComponent_GetOwningCharacter");
static_assert(sizeof(HWCheatComponent_GetOwningCharacter) == 0x000008, "Wrong size on HWCheatComponent_GetOwningCharacter");
static_assert(offsetof(HWCheatComponent_GetOwningCharacter, ReturnValue) == 0x000000, "Member 'HWCheatComponent_GetOwningCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCheatComponent.GetOwningCharacterAbilitySystemActor
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_GetOwningCharacterAbilitySystemActor final
{
public:
	class AHWCharacterAbilitySystemActor*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_GetOwningCharacterAbilitySystemActor) == 0x000008, "Wrong alignment on HWCheatComponent_GetOwningCharacterAbilitySystemActor");
static_assert(sizeof(HWCheatComponent_GetOwningCharacterAbilitySystemActor) == 0x000008, "Wrong size on HWCheatComponent_GetOwningCharacterAbilitySystemActor");
static_assert(offsetof(HWCheatComponent_GetOwningCharacterAbilitySystemActor, ReturnValue) == 0x000000, "Member 'HWCheatComponent_GetOwningCharacterAbilitySystemActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCheatComponent.GetOwningLoadoutComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_GetOwningLoadoutComponent final
{
public:
	class UHWLoadoutComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_GetOwningLoadoutComponent) == 0x000008, "Wrong alignment on HWCheatComponent_GetOwningLoadoutComponent");
static_assert(sizeof(HWCheatComponent_GetOwningLoadoutComponent) == 0x000008, "Wrong size on HWCheatComponent_GetOwningLoadoutComponent");
static_assert(offsetof(HWCheatComponent_GetOwningLoadoutComponent, ReturnValue) == 0x000000, "Member 'HWCheatComponent_GetOwningLoadoutComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCheatComponent.GetOwningPlayerState
// 0x0008 (0x0008 - 0x0000)
struct HWCheatComponent_GetOwningPlayerState final
{
public:
	class AHWPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_GetOwningPlayerState) == 0x000008, "Wrong alignment on HWCheatComponent_GetOwningPlayerState");
static_assert(sizeof(HWCheatComponent_GetOwningPlayerState) == 0x000008, "Wrong size on HWCheatComponent_GetOwningPlayerState");
static_assert(offsetof(HWCheatComponent_GetOwningPlayerState, ReturnValue) == 0x000000, "Member 'HWCheatComponent_GetOwningPlayerState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCheatComponent.ValidateCheatPermission
// 0x0001 (0x0001 - 0x0000)
struct HWCheatComponent_ValidateCheatPermission final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCheatComponent_ValidateCheatPermission) == 0x000001, "Wrong alignment on HWCheatComponent_ValidateCheatPermission");
static_assert(sizeof(HWCheatComponent_ValidateCheatPermission) == 0x000001, "Wrong size on HWCheatComponent_ValidateCheatPermission");
static_assert(offsetof(HWCheatComponent_ValidateCheatPermission, ReturnValue) == 0x000000, "Member 'HWCheatComponent_ValidateCheatPermission::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWidgetComponent.SetClampAxes
// 0x0001 (0x0001 - 0x0000)
struct HWWidgetComponent_SetClampAxes final
{
public:
	uint8                                         InAxisToClamp;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWidgetComponent_SetClampAxes) == 0x000001, "Wrong alignment on HWWidgetComponent_SetClampAxes");
static_assert(sizeof(HWWidgetComponent_SetClampAxes) == 0x000001, "Wrong size on HWWidgetComponent_SetClampAxes");
static_assert(offsetof(HWWidgetComponent_SetClampAxes, InAxisToClamp) == 0x000000, "Member 'HWWidgetComponent_SetClampAxes::InAxisToClamp' has a wrong offset!");

// Function Hemingway.HWWidgetComponent.ShouldClampAxes
// 0x0002 (0x0002 - 0x0000)
struct HWWidgetComponent_ShouldClampAxes final
{
public:
	EHWClampAxis                                  Axis;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWidgetComponent_ShouldClampAxes) == 0x000001, "Wrong alignment on HWWidgetComponent_ShouldClampAxes");
static_assert(sizeof(HWWidgetComponent_ShouldClampAxes) == 0x000002, "Wrong size on HWWidgetComponent_ShouldClampAxes");
static_assert(offsetof(HWWidgetComponent_ShouldClampAxes, Axis) == 0x000000, "Member 'HWWidgetComponent_ShouldClampAxes::Axis' has a wrong offset!");
static_assert(offsetof(HWWidgetComponent_ShouldClampAxes, ReturnValue) == 0x000001, "Member 'HWWidgetComponent_ShouldClampAxes::ReturnValue' has a wrong offset!");

// Function Hemingway.HWItemStoreManagerComponent.GamepadClickEquipmentItem
// 0x0010 (0x0010 - 0x0000)
struct HWItemStoreManagerComponent_GamepadClickEquipmentItem final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotTag;                                           // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWItemStoreManagerComponent_GamepadClickEquipmentItem) == 0x000008, "Wrong alignment on HWItemStoreManagerComponent_GamepadClickEquipmentItem");
static_assert(sizeof(HWItemStoreManagerComponent_GamepadClickEquipmentItem) == 0x000010, "Wrong size on HWItemStoreManagerComponent_GamepadClickEquipmentItem");
static_assert(offsetof(HWItemStoreManagerComponent_GamepadClickEquipmentItem, EquipmentItem) == 0x000000, "Member 'HWItemStoreManagerComponent_GamepadClickEquipmentItem::EquipmentItem' has a wrong offset!");
static_assert(offsetof(HWItemStoreManagerComponent_GamepadClickEquipmentItem, SlotTag) == 0x000008, "Member 'HWItemStoreManagerComponent_GamepadClickEquipmentItem::SlotTag' has a wrong offset!");

// Function Hemingway.HWItemStoreManagerComponent.GamepadHoverBuildsIntoEquipmentItem
// 0x0008 (0x0008 - 0x0000)
struct HWItemStoreManagerComponent_GamepadHoverBuildsIntoEquipmentItem final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWItemStoreManagerComponent_GamepadHoverBuildsIntoEquipmentItem) == 0x000008, "Wrong alignment on HWItemStoreManagerComponent_GamepadHoverBuildsIntoEquipmentItem");
static_assert(sizeof(HWItemStoreManagerComponent_GamepadHoverBuildsIntoEquipmentItem) == 0x000008, "Wrong size on HWItemStoreManagerComponent_GamepadHoverBuildsIntoEquipmentItem");
static_assert(offsetof(HWItemStoreManagerComponent_GamepadHoverBuildsIntoEquipmentItem, EquipmentItem) == 0x000000, "Member 'HWItemStoreManagerComponent_GamepadHoverBuildsIntoEquipmentItem::EquipmentItem' has a wrong offset!");

// Function Hemingway.HWItemStoreManagerComponent.GamepadHoverEquipmentItem
// 0x0010 (0x0010 - 0x0000)
struct HWItemStoreManagerComponent_GamepadHoverEquipmentItem final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotTag;                                           // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWItemStoreManagerComponent_GamepadHoverEquipmentItem) == 0x000008, "Wrong alignment on HWItemStoreManagerComponent_GamepadHoverEquipmentItem");
static_assert(sizeof(HWItemStoreManagerComponent_GamepadHoverEquipmentItem) == 0x000010, "Wrong size on HWItemStoreManagerComponent_GamepadHoverEquipmentItem");
static_assert(offsetof(HWItemStoreManagerComponent_GamepadHoverEquipmentItem, EquipmentItem) == 0x000000, "Member 'HWItemStoreManagerComponent_GamepadHoverEquipmentItem::EquipmentItem' has a wrong offset!");
static_assert(offsetof(HWItemStoreManagerComponent_GamepadHoverEquipmentItem, SlotTag) == 0x000008, "Member 'HWItemStoreManagerComponent_GamepadHoverEquipmentItem::SlotTag' has a wrong offset!");

// Function Hemingway.HWItemStoreManagerComponent.SelectComponentItem
// 0x0008 (0x0008 - 0x0000)
struct HWItemStoreManagerComponent_SelectComponentItem final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWItemStoreManagerComponent_SelectComponentItem) == 0x000008, "Wrong alignment on HWItemStoreManagerComponent_SelectComponentItem");
static_assert(sizeof(HWItemStoreManagerComponent_SelectComponentItem) == 0x000008, "Wrong size on HWItemStoreManagerComponent_SelectComponentItem");
static_assert(offsetof(HWItemStoreManagerComponent_SelectComponentItem, EquipmentItem) == 0x000000, "Member 'HWItemStoreManagerComponent_SelectComponentItem::EquipmentItem' has a wrong offset!");

// Function Hemingway.HWItemStoreManagerComponent.SelectEquipmentItem
// 0x0018 (0x0018 - 0x0000)
struct HWItemStoreManagerComponent_SelectEquipmentItem final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotTag;                                           // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWEquipmentItem*                 DefaultSelectedItem;                               // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWItemStoreManagerComponent_SelectEquipmentItem) == 0x000008, "Wrong alignment on HWItemStoreManagerComponent_SelectEquipmentItem");
static_assert(sizeof(HWItemStoreManagerComponent_SelectEquipmentItem) == 0x000018, "Wrong size on HWItemStoreManagerComponent_SelectEquipmentItem");
static_assert(offsetof(HWItemStoreManagerComponent_SelectEquipmentItem, EquipmentItem) == 0x000000, "Member 'HWItemStoreManagerComponent_SelectEquipmentItem::EquipmentItem' has a wrong offset!");
static_assert(offsetof(HWItemStoreManagerComponent_SelectEquipmentItem, SlotTag) == 0x000008, "Member 'HWItemStoreManagerComponent_SelectEquipmentItem::SlotTag' has a wrong offset!");
static_assert(offsetof(HWItemStoreManagerComponent_SelectEquipmentItem, DefaultSelectedItem) == 0x000010, "Member 'HWItemStoreManagerComponent_SelectEquipmentItem::DefaultSelectedItem' has a wrong offset!");

// Function Hemingway.HWItemStoreManagerComponent.SellEquipmentInstance
// 0x0008 (0x0008 - 0x0000)
struct HWItemStoreManagerComponent_SellEquipmentInstance final
{
public:
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWItemStoreManagerComponent_SellEquipmentInstance) == 0x000008, "Wrong alignment on HWItemStoreManagerComponent_SellEquipmentInstance");
static_assert(sizeof(HWItemStoreManagerComponent_SellEquipmentInstance) == 0x000008, "Wrong size on HWItemStoreManagerComponent_SellEquipmentInstance");
static_assert(offsetof(HWItemStoreManagerComponent_SellEquipmentInstance, EquipmentInstance) == 0x000000, "Member 'HWItemStoreManagerComponent_SellEquipmentInstance::EquipmentInstance' has a wrong offset!");

// Function Hemingway.HWItemStoreManagerComponent.TrackEquipmentItem
// 0x0010 (0x0010 - 0x0000)
struct HWItemStoreManagerComponent_TrackEquipmentItem final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotTag;                                           // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWItemStoreManagerComponent_TrackEquipmentItem) == 0x000008, "Wrong alignment on HWItemStoreManagerComponent_TrackEquipmentItem");
static_assert(sizeof(HWItemStoreManagerComponent_TrackEquipmentItem) == 0x000010, "Wrong size on HWItemStoreManagerComponent_TrackEquipmentItem");
static_assert(offsetof(HWItemStoreManagerComponent_TrackEquipmentItem, EquipmentItem) == 0x000000, "Member 'HWItemStoreManagerComponent_TrackEquipmentItem::EquipmentItem' has a wrong offset!");
static_assert(offsetof(HWItemStoreManagerComponent_TrackEquipmentItem, SlotTag) == 0x000008, "Member 'HWItemStoreManagerComponent_TrackEquipmentItem::SlotTag' has a wrong offset!");

// Function Hemingway.HWItemStoreManagerComponent.GetCanCraftInfoFromEquipmentItem
// 0x0088 (0x0088 - 0x0000)
struct HWItemStoreManagerComponent_GetCanCraftInfoFromEquipmentItem final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWCanCraftInfo                        ReturnValue;                                       // 0x0008(0x0080)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWItemStoreManagerComponent_GetCanCraftInfoFromEquipmentItem) == 0x000008, "Wrong alignment on HWItemStoreManagerComponent_GetCanCraftInfoFromEquipmentItem");
static_assert(sizeof(HWItemStoreManagerComponent_GetCanCraftInfoFromEquipmentItem) == 0x000088, "Wrong size on HWItemStoreManagerComponent_GetCanCraftInfoFromEquipmentItem");
static_assert(offsetof(HWItemStoreManagerComponent_GetCanCraftInfoFromEquipmentItem, EquipmentItem) == 0x000000, "Member 'HWItemStoreManagerComponent_GetCanCraftInfoFromEquipmentItem::EquipmentItem' has a wrong offset!");
static_assert(offsetof(HWItemStoreManagerComponent_GetCanCraftInfoFromEquipmentItem, ReturnValue) == 0x000008, "Member 'HWItemStoreManagerComponent_GetCanCraftInfoFromEquipmentItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAnnouncementComponent.AddNewAnnouncement
// 0x0008 (0x0008 - 0x0000)
struct HWAnnouncementComponent_AddNewAnnouncement final
{
public:
	struct FGameplayTag                           AnnouncementTag;                                   // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAnnouncementComponent_AddNewAnnouncement) == 0x000004, "Wrong alignment on HWAnnouncementComponent_AddNewAnnouncement");
static_assert(sizeof(HWAnnouncementComponent_AddNewAnnouncement) == 0x000008, "Wrong size on HWAnnouncementComponent_AddNewAnnouncement");
static_assert(offsetof(HWAnnouncementComponent_AddNewAnnouncement, AnnouncementTag) == 0x000000, "Member 'HWAnnouncementComponent_AddNewAnnouncement::AnnouncementTag' has a wrong offset!");

// Function Hemingway.HWAnnouncementComponent.MulticastSendAnnouncementToClient
// 0x0008 (0x0008 - 0x0000)
struct HWAnnouncementComponent_MulticastSendAnnouncementToClient final
{
public:
	struct FGameplayTag                           AnnouncementTag;                                   // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAnnouncementComponent_MulticastSendAnnouncementToClient) == 0x000004, "Wrong alignment on HWAnnouncementComponent_MulticastSendAnnouncementToClient");
static_assert(sizeof(HWAnnouncementComponent_MulticastSendAnnouncementToClient) == 0x000008, "Wrong size on HWAnnouncementComponent_MulticastSendAnnouncementToClient");
static_assert(offsetof(HWAnnouncementComponent_MulticastSendAnnouncementToClient, AnnouncementTag) == 0x000000, "Member 'HWAnnouncementComponent_MulticastSendAnnouncementToClient::AnnouncementTag' has a wrong offset!");

// Function Hemingway.HWFXCurveComponent.UpdateColorTrack
// 0x0018 (0x0018 - 0x0000)
struct HWFXCurveComponent_UpdateColorTrack final
{
public:
	class FName                                   TrackName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TrackValue;                                        // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFXCurveComponent_UpdateColorTrack) == 0x000004, "Wrong alignment on HWFXCurveComponent_UpdateColorTrack");
static_assert(sizeof(HWFXCurveComponent_UpdateColorTrack) == 0x000018, "Wrong size on HWFXCurveComponent_UpdateColorTrack");
static_assert(offsetof(HWFXCurveComponent_UpdateColorTrack, TrackName) == 0x000000, "Member 'HWFXCurveComponent_UpdateColorTrack::TrackName' has a wrong offset!");
static_assert(offsetof(HWFXCurveComponent_UpdateColorTrack, TrackValue) == 0x000008, "Member 'HWFXCurveComponent_UpdateColorTrack::TrackValue' has a wrong offset!");

// Function Hemingway.HWFXCurveComponent.UpdateScalarTrack
// 0x000C (0x000C - 0x0000)
struct HWFXCurveComponent_UpdateScalarTrack final
{
public:
	class FName                                   TrackName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackValue;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFXCurveComponent_UpdateScalarTrack) == 0x000004, "Wrong alignment on HWFXCurveComponent_UpdateScalarTrack");
static_assert(sizeof(HWFXCurveComponent_UpdateScalarTrack) == 0x00000C, "Wrong size on HWFXCurveComponent_UpdateScalarTrack");
static_assert(offsetof(HWFXCurveComponent_UpdateScalarTrack, TrackName) == 0x000000, "Member 'HWFXCurveComponent_UpdateScalarTrack::TrackName' has a wrong offset!");
static_assert(offsetof(HWFXCurveComponent_UpdateScalarTrack, TrackValue) == 0x000008, "Member 'HWFXCurveComponent_UpdateScalarTrack::TrackValue' has a wrong offset!");

// Function Hemingway.HWFXCurveComponent.GetCharacterOwner
// 0x0008 (0x0008 - 0x0000)
struct HWFXCurveComponent_GetCharacterOwner final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFXCurveComponent_GetCharacterOwner) == 0x000008, "Wrong alignment on HWFXCurveComponent_GetCharacterOwner");
static_assert(sizeof(HWFXCurveComponent_GetCharacterOwner) == 0x000008, "Wrong size on HWFXCurveComponent_GetCharacterOwner");
static_assert(offsetof(HWFXCurveComponent_GetCharacterOwner, ReturnValue) == 0x000000, "Member 'HWFXCurveComponent_GetCharacterOwner::ReturnValue' has a wrong offset!");

// Function Hemingway.HWFXCurveComponent.GetFxID
// 0x0008 (0x0008 - 0x0000)
struct HWFXCurveComponent_GetFxID final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFXCurveComponent_GetFxID) == 0x000004, "Wrong alignment on HWFXCurveComponent_GetFxID");
static_assert(sizeof(HWFXCurveComponent_GetFxID) == 0x000008, "Wrong size on HWFXCurveComponent_GetFxID");
static_assert(offsetof(HWFXCurveComponent_GetFxID, ReturnValue) == 0x000000, "Member 'HWFXCurveComponent_GetFxID::ReturnValue' has a wrong offset!");

// Function Hemingway.HWFXCurveComponent.GetPostProcessMID
// 0x0008 (0x0008 - 0x0000)
struct HWFXCurveComponent_GetPostProcessMID final
{
public:
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFXCurveComponent_GetPostProcessMID) == 0x000008, "Wrong alignment on HWFXCurveComponent_GetPostProcessMID");
static_assert(sizeof(HWFXCurveComponent_GetPostProcessMID) == 0x000008, "Wrong size on HWFXCurveComponent_GetPostProcessMID");
static_assert(offsetof(HWFXCurveComponent_GetPostProcessMID, ReturnValue) == 0x000000, "Member 'HWFXCurveComponent_GetPostProcessMID::ReturnValue' has a wrong offset!");

// Function Hemingway.HWFXCurveComponent.IsPlaying
// 0x0001 (0x0001 - 0x0000)
struct HWFXCurveComponent_IsPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFXCurveComponent_IsPlaying) == 0x000001, "Wrong alignment on HWFXCurveComponent_IsPlaying");
static_assert(sizeof(HWFXCurveComponent_IsPlaying) == 0x000001, "Wrong size on HWFXCurveComponent_IsPlaying");
static_assert(offsetof(HWFXCurveComponent_IsPlaying, ReturnValue) == 0x000000, "Member 'HWFXCurveComponent_IsPlaying::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSplineComponent.DrawDebugSpline
// 0x0024 (0x0024 - 0x0000)
struct HWSplineComponent_DrawDebugSpline final
{
public:
	float                                         splineDistanceSteps;                               // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0004(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSplineComponent_DrawDebugSpline) == 0x000004, "Wrong alignment on HWSplineComponent_DrawDebugSpline");
static_assert(sizeof(HWSplineComponent_DrawDebugSpline) == 0x000024, "Wrong size on HWSplineComponent_DrawDebugSpline");
static_assert(offsetof(HWSplineComponent_DrawDebugSpline, splineDistanceSteps) == 0x000000, "Member 'HWSplineComponent_DrawDebugSpline::splineDistanceSteps' has a wrong offset!");
static_assert(offsetof(HWSplineComponent_DrawDebugSpline, Color) == 0x000004, "Member 'HWSplineComponent_DrawDebugSpline::Color' has a wrong offset!");
static_assert(offsetof(HWSplineComponent_DrawDebugSpline, bPersistentLines) == 0x000014, "Member 'HWSplineComponent_DrawDebugSpline::bPersistentLines' has a wrong offset!");
static_assert(offsetof(HWSplineComponent_DrawDebugSpline, Lifetime) == 0x000018, "Member 'HWSplineComponent_DrawDebugSpline::Lifetime' has a wrong offset!");
static_assert(offsetof(HWSplineComponent_DrawDebugSpline, DepthPriority) == 0x00001C, "Member 'HWSplineComponent_DrawDebugSpline::DepthPriority' has a wrong offset!");
static_assert(offsetof(HWSplineComponent_DrawDebugSpline, Thickness) == 0x000020, "Member 'HWSplineComponent_DrawDebugSpline::Thickness' has a wrong offset!");

// Function Hemingway.HWSplineComponent.SetShouldReplicateSplinePoints
// 0x0001 (0x0001 - 0x0000)
struct HWSplineComponent_SetShouldReplicateSplinePoints final
{
public:
	bool                                          bShouldReplicate;                                  // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSplineComponent_SetShouldReplicateSplinePoints) == 0x000001, "Wrong alignment on HWSplineComponent_SetShouldReplicateSplinePoints");
static_assert(sizeof(HWSplineComponent_SetShouldReplicateSplinePoints) == 0x000001, "Wrong size on HWSplineComponent_SetShouldReplicateSplinePoints");
static_assert(offsetof(HWSplineComponent_SetShouldReplicateSplinePoints, bShouldReplicate) == 0x000000, "Member 'HWSplineComponent_SetShouldReplicateSplinePoints::bShouldReplicate' has a wrong offset!");

// Function Hemingway.HWSplineComponent.HasAuthority
// 0x0001 (0x0001 - 0x0000)
struct HWSplineComponent_HasAuthority final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSplineComponent_HasAuthority) == 0x000001, "Wrong alignment on HWSplineComponent_HasAuthority");
static_assert(sizeof(HWSplineComponent_HasAuthority) == 0x000001, "Wrong size on HWSplineComponent_HasAuthority");
static_assert(offsetof(HWSplineComponent_HasAuthority, ReturnValue) == 0x000000, "Member 'HWSplineComponent_HasAuthority::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSplinePathMeshManagerComponent.HandleOnSplineSegmentBeginOverlap
// 0x0108 (0x0108 - 0x0000)
struct HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap) == 0x000008, "Wrong alignment on HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap");
static_assert(sizeof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap) == 0x000108, "Wrong size on HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap");
static_assert(offsetof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap, OverlappedComp) == 0x000000, "Member 'HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap, Other) == 0x000008, "Member 'HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap::Other' has a wrong offset!");
static_assert(offsetof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap, OtherComp) == 0x000010, "Member 'HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap, bFromSweep) == 0x00001C, "Member 'HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap, SweepResult) == 0x000020, "Member 'HWSplinePathMeshManagerComponent_HandleOnSplineSegmentBeginOverlap::SweepResult' has a wrong offset!");

// Function Hemingway.HWSplinePathMeshManagerComponent.HandleOnSplineSegmentEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap) == 0x000008, "Wrong alignment on HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap");
static_assert(sizeof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap) == 0x000020, "Wrong size on HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap");
static_assert(offsetof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap, OverlappedComp) == 0x000000, "Member 'HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap, Other) == 0x000008, "Member 'HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap::Other' has a wrong offset!");
static_assert(offsetof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap, OtherComp) == 0x000010, "Member 'HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap, OtherBodyIndex) == 0x000018, "Member 'HWSplinePathMeshManagerComponent_HandleOnSplineSegmentEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function Hemingway.HWSplinePathMeshManagerComponent.SetAcceptableCollisionFilter
// 0x0010 (0x0010 - 0x0000)
struct HWSplinePathMeshManagerComponent_SetAcceptableCollisionFilter final
{
public:
	struct FGameplayTargetDataFilterHandle        collisionFilter;                                   // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSplinePathMeshManagerComponent_SetAcceptableCollisionFilter) == 0x000008, "Wrong alignment on HWSplinePathMeshManagerComponent_SetAcceptableCollisionFilter");
static_assert(sizeof(HWSplinePathMeshManagerComponent_SetAcceptableCollisionFilter) == 0x000010, "Wrong size on HWSplinePathMeshManagerComponent_SetAcceptableCollisionFilter");
static_assert(offsetof(HWSplinePathMeshManagerComponent_SetAcceptableCollisionFilter, collisionFilter) == 0x000000, "Member 'HWSplinePathMeshManagerComponent_SetAcceptableCollisionFilter::collisionFilter' has a wrong offset!");

// Function Hemingway.HWSplinePathMeshManagerComponent.SetCollisionProfile
// 0x0008 (0x0008 - 0x0000)
struct HWSplinePathMeshManagerComponent_SetCollisionProfile final
{
public:
	class FName                                   ProfileName;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSplinePathMeshManagerComponent_SetCollisionProfile) == 0x000004, "Wrong alignment on HWSplinePathMeshManagerComponent_SetCollisionProfile");
static_assert(sizeof(HWSplinePathMeshManagerComponent_SetCollisionProfile) == 0x000008, "Wrong size on HWSplinePathMeshManagerComponent_SetCollisionProfile");
static_assert(offsetof(HWSplinePathMeshManagerComponent_SetCollisionProfile, ProfileName) == 0x000000, "Member 'HWSplinePathMeshManagerComponent_SetCollisionProfile::ProfileName' has a wrong offset!");

// Function Hemingway.HWSplinePathMeshManagerComponent.GetOverlapDistance
// 0x0004 (0x0004 - 0x0000)
struct HWSplinePathMeshManagerComponent_GetOverlapDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSplinePathMeshManagerComponent_GetOverlapDistance) == 0x000004, "Wrong alignment on HWSplinePathMeshManagerComponent_GetOverlapDistance");
static_assert(sizeof(HWSplinePathMeshManagerComponent_GetOverlapDistance) == 0x000004, "Wrong size on HWSplinePathMeshManagerComponent_GetOverlapDistance");
static_assert(offsetof(HWSplinePathMeshManagerComponent_GetOverlapDistance, ReturnValue) == 0x000000, "Member 'HWSplinePathMeshManagerComponent_GetOverlapDistance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSplinePathMeshManagerComponent.GetPlacementDistanceInterval
// 0x0004 (0x0004 - 0x0000)
struct HWSplinePathMeshManagerComponent_GetPlacementDistanceInterval final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSplinePathMeshManagerComponent_GetPlacementDistanceInterval) == 0x000004, "Wrong alignment on HWSplinePathMeshManagerComponent_GetPlacementDistanceInterval");
static_assert(sizeof(HWSplinePathMeshManagerComponent_GetPlacementDistanceInterval) == 0x000004, "Wrong size on HWSplinePathMeshManagerComponent_GetPlacementDistanceInterval");
static_assert(offsetof(HWSplinePathMeshManagerComponent_GetPlacementDistanceInterval, ReturnValue) == 0x000000, "Member 'HWSplinePathMeshManagerComponent_GetPlacementDistanceInterval::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSplinePathMeshManagerComponent.GetSkinnedSplineMesh
// 0x0010 (0x0010 - 0x0000)
struct HWSplinePathMeshManagerComponent_GetSkinnedSplineMesh final
{
public:
	EHWSplineSegmentMeshType                      MeshType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSplinePathMeshManagerComponent_GetSkinnedSplineMesh) == 0x000008, "Wrong alignment on HWSplinePathMeshManagerComponent_GetSkinnedSplineMesh");
static_assert(sizeof(HWSplinePathMeshManagerComponent_GetSkinnedSplineMesh) == 0x000010, "Wrong size on HWSplinePathMeshManagerComponent_GetSkinnedSplineMesh");
static_assert(offsetof(HWSplinePathMeshManagerComponent_GetSkinnedSplineMesh, MeshType) == 0x000000, "Member 'HWSplinePathMeshManagerComponent_GetSkinnedSplineMesh::MeshType' has a wrong offset!");
static_assert(offsetof(HWSplinePathMeshManagerComponent_GetSkinnedSplineMesh, ReturnValue) == 0x000008, "Member 'HWSplinePathMeshManagerComponent_GetSkinnedSplineMesh::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.EndInteraction
// 0x0010 (0x0010 - 0x0000)
struct HWInteractableComponent_EndInteraction final
{
public:
	class AActor*                                 InteractInstigator;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCancelled;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInteractableComponent_EndInteraction) == 0x000008, "Wrong alignment on HWInteractableComponent_EndInteraction");
static_assert(sizeof(HWInteractableComponent_EndInteraction) == 0x000010, "Wrong size on HWInteractableComponent_EndInteraction");
static_assert(offsetof(HWInteractableComponent_EndInteraction, InteractInstigator) == 0x000000, "Member 'HWInteractableComponent_EndInteraction::InteractInstigator' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_EndInteraction, bWasCancelled) == 0x000008, "Member 'HWInteractableComponent_EndInteraction::bWasCancelled' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.OnInteractFieldBeginOverlap
// 0x0108 (0x0108 - 0x0000)
struct HWInteractableComponent_OnInteractFieldBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_OnInteractFieldBeginOverlap) == 0x000008, "Wrong alignment on HWInteractableComponent_OnInteractFieldBeginOverlap");
static_assert(sizeof(HWInteractableComponent_OnInteractFieldBeginOverlap) == 0x000108, "Wrong size on HWInteractableComponent_OnInteractFieldBeginOverlap");
static_assert(offsetof(HWInteractableComponent_OnInteractFieldBeginOverlap, OverlappedComp) == 0x000000, "Member 'HWInteractableComponent_OnInteractFieldBeginOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_OnInteractFieldBeginOverlap, OtherActor) == 0x000008, "Member 'HWInteractableComponent_OnInteractFieldBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_OnInteractFieldBeginOverlap, OtherComp) == 0x000010, "Member 'HWInteractableComponent_OnInteractFieldBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_OnInteractFieldBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'HWInteractableComponent_OnInteractFieldBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_OnInteractFieldBeginOverlap, bFromSweep) == 0x00001C, "Member 'HWInteractableComponent_OnInteractFieldBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_OnInteractFieldBeginOverlap, SweepResult) == 0x000020, "Member 'HWInteractableComponent_OnInteractFieldBeginOverlap::SweepResult' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.OnInteractFieldEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct HWInteractableComponent_OnInteractFieldEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInteractableComponent_OnInteractFieldEndOverlap) == 0x000008, "Wrong alignment on HWInteractableComponent_OnInteractFieldEndOverlap");
static_assert(sizeof(HWInteractableComponent_OnInteractFieldEndOverlap) == 0x000020, "Wrong size on HWInteractableComponent_OnInteractFieldEndOverlap");
static_assert(offsetof(HWInteractableComponent_OnInteractFieldEndOverlap, OverlappedComponent) == 0x000000, "Member 'HWInteractableComponent_OnInteractFieldEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_OnInteractFieldEndOverlap, OtherActor) == 0x000008, "Member 'HWInteractableComponent_OnInteractFieldEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_OnInteractFieldEndOverlap, OtherComp) == 0x000010, "Member 'HWInteractableComponent_OnInteractFieldEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_OnInteractFieldEndOverlap, OtherBodyIndex) == 0x000018, "Member 'HWInteractableComponent_OnInteractFieldEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWInteractableComponent_SetEnabled final
{
public:
	bool                                          bShouldEnable;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_SetEnabled) == 0x000001, "Wrong alignment on HWInteractableComponent_SetEnabled");
static_assert(sizeof(HWInteractableComponent_SetEnabled) == 0x000001, "Wrong size on HWInteractableComponent_SetEnabled");
static_assert(offsetof(HWInteractableComponent_SetEnabled, bShouldEnable) == 0x000000, "Member 'HWInteractableComponent_SetEnabled::bShouldEnable' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.SetInteractPromptText
// 0x0018 (0x0018 - 0x0000)
struct HWInteractableComponent_SetInteractPromptText final
{
public:
	class FText                                   NewPromptText;                                     // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_SetInteractPromptText) == 0x000008, "Wrong alignment on HWInteractableComponent_SetInteractPromptText");
static_assert(sizeof(HWInteractableComponent_SetInteractPromptText) == 0x000018, "Wrong size on HWInteractableComponent_SetInteractPromptText");
static_assert(offsetof(HWInteractableComponent_SetInteractPromptText, NewPromptText) == 0x000000, "Member 'HWInteractableComponent_SetInteractPromptText::NewPromptText' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.StartInteraction
// 0x0008 (0x0008 - 0x0000)
struct HWInteractableComponent_StartInteraction final
{
public:
	class AActor*                                 InteractInstigator;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_StartInteraction) == 0x000008, "Wrong alignment on HWInteractableComponent_StartInteraction");
static_assert(sizeof(HWInteractableComponent_StartInteraction) == 0x000008, "Wrong size on HWInteractableComponent_StartInteraction");
static_assert(offsetof(HWInteractableComponent_StartInteraction, InteractInstigator) == 0x000000, "Member 'HWInteractableComponent_StartInteraction::InteractInstigator' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.UpdatePromptVisuals
// 0x0001 (0x0001 - 0x0000)
struct HWInteractableComponent_UpdatePromptVisuals final
{
public:
	bool                                          bShowPrompt;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_UpdatePromptVisuals) == 0x000001, "Wrong alignment on HWInteractableComponent_UpdatePromptVisuals");
static_assert(sizeof(HWInteractableComponent_UpdatePromptVisuals) == 0x000001, "Wrong size on HWInteractableComponent_UpdatePromptVisuals");
static_assert(offsetof(HWInteractableComponent_UpdatePromptVisuals, bShowPrompt) == 0x000000, "Member 'HWInteractableComponent_UpdatePromptVisuals::bShowPrompt' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.CanEverInteractWith
// 0x0010 (0x0010 - 0x0000)
struct HWInteractableComponent_CanEverInteractWith final
{
public:
	const class AActor*                           InteractInstigator;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInteractableComponent_CanEverInteractWith) == 0x000008, "Wrong alignment on HWInteractableComponent_CanEverInteractWith");
static_assert(sizeof(HWInteractableComponent_CanEverInteractWith) == 0x000010, "Wrong size on HWInteractableComponent_CanEverInteractWith");
static_assert(offsetof(HWInteractableComponent_CanEverInteractWith, InteractInstigator) == 0x000000, "Member 'HWInteractableComponent_CanEverInteractWith::InteractInstigator' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_CanEverInteractWith, ReturnValue) == 0x000008, "Member 'HWInteractableComponent_CanEverInteractWith::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.CanInteractWith
// 0x0010 (0x0010 - 0x0000)
struct HWInteractableComponent_CanInteractWith final
{
public:
	const class AActor*                           InteractInstigator;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInteractableComponent_CanInteractWith) == 0x000008, "Wrong alignment on HWInteractableComponent_CanInteractWith");
static_assert(sizeof(HWInteractableComponent_CanInteractWith) == 0x000010, "Wrong size on HWInteractableComponent_CanInteractWith");
static_assert(offsetof(HWInteractableComponent_CanInteractWith, InteractInstigator) == 0x000000, "Member 'HWInteractableComponent_CanInteractWith::InteractInstigator' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_CanInteractWith, ReturnValue) == 0x000008, "Member 'HWInteractableComponent_CanInteractWith::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.CanMoveDuringInteraction
// 0x0001 (0x0001 - 0x0000)
struct HWInteractableComponent_CanMoveDuringInteraction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_CanMoveDuringInteraction) == 0x000001, "Wrong alignment on HWInteractableComponent_CanMoveDuringInteraction");
static_assert(sizeof(HWInteractableComponent_CanMoveDuringInteraction) == 0x000001, "Wrong size on HWInteractableComponent_CanMoveDuringInteraction");
static_assert(offsetof(HWInteractableComponent_CanMoveDuringInteraction, ReturnValue) == 0x000000, "Member 'HWInteractableComponent_CanMoveDuringInteraction::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.GetInteractionTime
// 0x0004 (0x0004 - 0x0000)
struct HWInteractableComponent_GetInteractionTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_GetInteractionTime) == 0x000004, "Wrong alignment on HWInteractableComponent_GetInteractionTime");
static_assert(sizeof(HWInteractableComponent_GetInteractionTime) == 0x000004, "Wrong size on HWInteractableComponent_GetInteractionTime");
static_assert(offsetof(HWInteractableComponent_GetInteractionTime, ReturnValue) == 0x000000, "Member 'HWInteractableComponent_GetInteractionTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.GetInteractMontageTag
// 0x0008 (0x0008 - 0x0000)
struct HWInteractableComponent_GetInteractMontageTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_GetInteractMontageTag) == 0x000004, "Wrong alignment on HWInteractableComponent_GetInteractMontageTag");
static_assert(sizeof(HWInteractableComponent_GetInteractMontageTag) == 0x000008, "Wrong size on HWInteractableComponent_GetInteractMontageTag");
static_assert(offsetof(HWInteractableComponent_GetInteractMontageTag, ReturnValue) == 0x000000, "Member 'HWInteractableComponent_GetInteractMontageTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.GetInteractPromptText
// 0x0018 (0x0018 - 0x0000)
struct HWInteractableComponent_GetInteractPromptText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_GetInteractPromptText) == 0x000008, "Wrong alignment on HWInteractableComponent_GetInteractPromptText");
static_assert(sizeof(HWInteractableComponent_GetInteractPromptText) == 0x000018, "Wrong size on HWInteractableComponent_GetInteractPromptText");
static_assert(offsetof(HWInteractableComponent_GetInteractPromptText, ReturnValue) == 0x000000, "Member 'HWInteractableComponent_GetInteractPromptText::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.IsActorInteractionInProgress
// 0x0010 (0x0010 - 0x0000)
struct HWInteractableComponent_IsActorInteractionInProgress final
{
public:
	const class AActor*                           ActorToCheck;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInteractableComponent_IsActorInteractionInProgress) == 0x000008, "Wrong alignment on HWInteractableComponent_IsActorInteractionInProgress");
static_assert(sizeof(HWInteractableComponent_IsActorInteractionInProgress) == 0x000010, "Wrong size on HWInteractableComponent_IsActorInteractionInProgress");
static_assert(offsetof(HWInteractableComponent_IsActorInteractionInProgress, ActorToCheck) == 0x000000, "Member 'HWInteractableComponent_IsActorInteractionInProgress::ActorToCheck' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_IsActorInteractionInProgress, ReturnValue) == 0x000008, "Member 'HWInteractableComponent_IsActorInteractionInProgress::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWInteractableComponent_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_IsEnabled) == 0x000001, "Wrong alignment on HWInteractableComponent_IsEnabled");
static_assert(sizeof(HWInteractableComponent_IsEnabled) == 0x000001, "Wrong size on HWInteractableComponent_IsEnabled");
static_assert(offsetof(HWInteractableComponent_IsEnabled, ReturnValue) == 0x000000, "Member 'HWInteractableComponent_IsEnabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.IsInInteractionField
// 0x0010 (0x0010 - 0x0000)
struct HWInteractableComponent_IsInInteractionField final
{
public:
	const class AActor*                           ActorToCheck;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInteractableComponent_IsInInteractionField) == 0x000008, "Wrong alignment on HWInteractableComponent_IsInInteractionField");
static_assert(sizeof(HWInteractableComponent_IsInInteractionField) == 0x000010, "Wrong size on HWInteractableComponent_IsInInteractionField");
static_assert(offsetof(HWInteractableComponent_IsInInteractionField, ActorToCheck) == 0x000000, "Member 'HWInteractableComponent_IsInInteractionField::ActorToCheck' has a wrong offset!");
static_assert(offsetof(HWInteractableComponent_IsInInteractionField, ReturnValue) == 0x000008, "Member 'HWInteractableComponent_IsInInteractionField::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.IsInteractionAllowed
// 0x0001 (0x0001 - 0x0000)
struct HWInteractableComponent_IsInteractionAllowed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_IsInteractionAllowed) == 0x000001, "Wrong alignment on HWInteractableComponent_IsInteractionAllowed");
static_assert(sizeof(HWInteractableComponent_IsInteractionAllowed) == 0x000001, "Wrong size on HWInteractableComponent_IsInteractionAllowed");
static_assert(offsetof(HWInteractableComponent_IsInteractionAllowed, ReturnValue) == 0x000000, "Member 'HWInteractableComponent_IsInteractionAllowed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.IsInteractionInProgress
// 0x0001 (0x0001 - 0x0000)
struct HWInteractableComponent_IsInteractionInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_IsInteractionInProgress) == 0x000001, "Wrong alignment on HWInteractableComponent_IsInteractionInProgress");
static_assert(sizeof(HWInteractableComponent_IsInteractionInProgress) == 0x000001, "Wrong size on HWInteractableComponent_IsInteractionInProgress");
static_assert(offsetof(HWInteractableComponent_IsInteractionInProgress, ReturnValue) == 0x000000, "Member 'HWInteractableComponent_IsInteractionInProgress::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractableComponent.ShouldShowPromptVisualsOnClient
// 0x0001 (0x0001 - 0x0000)
struct HWInteractableComponent_ShouldShowPromptVisualsOnClient final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractableComponent_ShouldShowPromptVisualsOnClient) == 0x000001, "Wrong alignment on HWInteractableComponent_ShouldShowPromptVisualsOnClient");
static_assert(sizeof(HWInteractableComponent_ShouldShowPromptVisualsOnClient) == 0x000001, "Wrong size on HWInteractableComponent_ShouldShowPromptVisualsOnClient");
static_assert(offsetof(HWInteractableComponent_ShouldShowPromptVisualsOnClient, ReturnValue) == 0x000000, "Member 'HWInteractableComponent_ShouldShowPromptVisualsOnClient::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstNPC.OnNpcASCUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_AnimInstNPC_OnNpcASCUpdated final
{
public:
	class UHWAbilitySystemComponent*              UpdatedASC;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OldAbilitySystem;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstNPC_OnNpcASCUpdated) == 0x000008, "Wrong alignment on HWCharacter_AnimInstNPC_OnNpcASCUpdated");
static_assert(sizeof(HWCharacter_AnimInstNPC_OnNpcASCUpdated) == 0x000010, "Wrong size on HWCharacter_AnimInstNPC_OnNpcASCUpdated");
static_assert(offsetof(HWCharacter_AnimInstNPC_OnNpcASCUpdated, UpdatedASC) == 0x000000, "Member 'HWCharacter_AnimInstNPC_OnNpcASCUpdated::UpdatedASC' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstNPC_OnNpcASCUpdated, OldAbilitySystem) == 0x000008, "Member 'HWCharacter_AnimInstNPC_OnNpcASCUpdated::OldAbilitySystem' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstNPC.OnStatusNpcTagsUpdated
// 0x000C (0x000C - 0x0000)
struct HWCharacter_AnimInstNPC_OnStatusNpcTagsUpdated final
{
public:
	struct FGameplayTag                           UpdatedStatusTag;                                  // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStackCount;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstNPC_OnStatusNpcTagsUpdated) == 0x000004, "Wrong alignment on HWCharacter_AnimInstNPC_OnStatusNpcTagsUpdated");
static_assert(sizeof(HWCharacter_AnimInstNPC_OnStatusNpcTagsUpdated) == 0x00000C, "Wrong size on HWCharacter_AnimInstNPC_OnStatusNpcTagsUpdated");
static_assert(offsetof(HWCharacter_AnimInstNPC_OnStatusNpcTagsUpdated, UpdatedStatusTag) == 0x000000, "Member 'HWCharacter_AnimInstNPC_OnStatusNpcTagsUpdated::UpdatedStatusTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstNPC_OnStatusNpcTagsUpdated, NewStackCount) == 0x000008, "Member 'HWCharacter_AnimInstNPC_OnStatusNpcTagsUpdated::NewStackCount' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstNPC.PlayHitReaction
// 0x0020 (0x0020 - 0x0000)
struct HWCharacter_AnimInstNPC_PlayHitReaction final
{
public:
	struct FVector                                RelativeDirection;                                 // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthPercent;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacter_AnimInstNPC_PlayHitReaction) == 0x000008, "Wrong alignment on HWCharacter_AnimInstNPC_PlayHitReaction");
static_assert(sizeof(HWCharacter_AnimInstNPC_PlayHitReaction) == 0x000020, "Wrong size on HWCharacter_AnimInstNPC_PlayHitReaction");
static_assert(offsetof(HWCharacter_AnimInstNPC_PlayHitReaction, RelativeDirection) == 0x000000, "Member 'HWCharacter_AnimInstNPC_PlayHitReaction::RelativeDirection' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstNPC_PlayHitReaction, HealthPercent) == 0x000018, "Member 'HWCharacter_AnimInstNPC_PlayHitReaction::HealthPercent' has a wrong offset!");

// Function Hemingway.HWGameplayMovementComponent.ConstrainRotation
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayMovementComponent_ConstrainRotation final
{
public:
	struct FRotator                               RotationToConstrain;                               // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayMovementComponent_ConstrainRotation) == 0x000008, "Wrong alignment on HWGameplayMovementComponent_ConstrainRotation");
static_assert(sizeof(HWGameplayMovementComponent_ConstrainRotation) == 0x000018, "Wrong size on HWGameplayMovementComponent_ConstrainRotation");
static_assert(offsetof(HWGameplayMovementComponent_ConstrainRotation, RotationToConstrain) == 0x000000, "Member 'HWGameplayMovementComponent_ConstrainRotation::RotationToConstrain' has a wrong offset!");

// Function Hemingway.HWGameplayMovementComponent.GetDistanceTraveled
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayMovementComponent_GetDistanceTraveled final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayMovementComponent_GetDistanceTraveled) == 0x000004, "Wrong alignment on HWGameplayMovementComponent_GetDistanceTraveled");
static_assert(sizeof(HWGameplayMovementComponent_GetDistanceTraveled) == 0x000004, "Wrong size on HWGameplayMovementComponent_GetDistanceTraveled");
static_assert(offsetof(HWGameplayMovementComponent_GetDistanceTraveled, ReturnValue) == 0x000000, "Member 'HWGameplayMovementComponent_GetDistanceTraveled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayMovementComponent.GetLobType
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayMovementComponent_GetLobType final
{
public:
	EHWProjectileLobType                          ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayMovementComponent_GetLobType) == 0x000004, "Wrong alignment on HWGameplayMovementComponent_GetLobType");
static_assert(sizeof(HWGameplayMovementComponent_GetLobType) == 0x000004, "Wrong size on HWGameplayMovementComponent_GetLobType");
static_assert(offsetof(HWGameplayMovementComponent_GetLobType, ReturnValue) == 0x000000, "Member 'HWGameplayMovementComponent_GetLobType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayMovementComponent.GetRange
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayMovementComponent_GetRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayMovementComponent_GetRange) == 0x000004, "Wrong alignment on HWGameplayMovementComponent_GetRange");
static_assert(sizeof(HWGameplayMovementComponent_GetRange) == 0x000004, "Wrong size on HWGameplayMovementComponent_GetRange");
static_assert(offsetof(HWGameplayMovementComponent_GetRange, ReturnValue) == 0x000000, "Member 'HWGameplayMovementComponent_GetRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayMovementComponent.HasReachedMaxRange
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayMovementComponent_HasReachedMaxRange final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayMovementComponent_HasReachedMaxRange) == 0x000004, "Wrong alignment on HWGameplayMovementComponent_HasReachedMaxRange");
static_assert(sizeof(HWGameplayMovementComponent_HasReachedMaxRange) == 0x000008, "Wrong size on HWGameplayMovementComponent_HasReachedMaxRange");
static_assert(offsetof(HWGameplayMovementComponent_HasReachedMaxRange, Distance) == 0x000000, "Member 'HWGameplayMovementComponent_HasReachedMaxRange::Distance' has a wrong offset!");
static_assert(offsetof(HWGameplayMovementComponent_HasReachedMaxRange, ReturnValue) == 0x000004, "Member 'HWGameplayMovementComponent_HasReachedMaxRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.AddDisplayInfo
// 0x000C (0x000C - 0x0000)
struct HWDisplayInfoComponent_AddDisplayInfo final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyNextTick;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDisplayInfoComponent_AddDisplayInfo) == 0x000004, "Wrong alignment on HWDisplayInfoComponent_AddDisplayInfo");
static_assert(sizeof(HWDisplayInfoComponent_AddDisplayInfo) == 0x00000C, "Wrong size on HWDisplayInfoComponent_AddDisplayInfo");
static_assert(offsetof(HWDisplayInfoComponent_AddDisplayInfo, DisplayInfoTag) == 0x000000, "Member 'HWDisplayInfoComponent_AddDisplayInfo::DisplayInfoTag' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_AddDisplayInfo, bApplyNextTick) == 0x000008, "Member 'HWDisplayInfoComponent_AddDisplayInfo::bApplyNextTick' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.AddDisplayInfoFromConfig
// 0x0028 (0x0028 - 0x0000)
struct HWDisplayInfoComponent_AddDisplayInfoFromConfig final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWDisplayInfoConfig                   Config;                                            // 0x0008(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bApplyNextTick;                                    // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDisplayInfoComponent_AddDisplayInfoFromConfig) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_AddDisplayInfoFromConfig");
static_assert(sizeof(HWDisplayInfoComponent_AddDisplayInfoFromConfig) == 0x000028, "Wrong size on HWDisplayInfoComponent_AddDisplayInfoFromConfig");
static_assert(offsetof(HWDisplayInfoComponent_AddDisplayInfoFromConfig, DisplayInfoTag) == 0x000000, "Member 'HWDisplayInfoComponent_AddDisplayInfoFromConfig::DisplayInfoTag' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_AddDisplayInfoFromConfig, Config) == 0x000008, "Member 'HWDisplayInfoComponent_AddDisplayInfoFromConfig::Config' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_AddDisplayInfoFromConfig, bApplyNextTick) == 0x000020, "Member 'HWDisplayInfoComponent_AddDisplayInfoFromConfig::bApplyNextTick' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.GetInactiveWidgetComponent
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoComponent_GetInactiveWidgetComponent final
{
public:
	class UHWWidgetComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_GetInactiveWidgetComponent) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_GetInactiveWidgetComponent");
static_assert(sizeof(HWDisplayInfoComponent_GetInactiveWidgetComponent) == 0x000008, "Wrong size on HWDisplayInfoComponent_GetInactiveWidgetComponent");
static_assert(offsetof(HWDisplayInfoComponent_GetInactiveWidgetComponent, ReturnValue) == 0x000000, "Member 'HWDisplayInfoComponent_GetInactiveWidgetComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.HandleCharacterAbilitySystemUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWDisplayInfoComponent_HandleCharacterAbilitySystemUpdated final
{
public:
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OldAbilitySystem;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_HandleCharacterAbilitySystemUpdated) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_HandleCharacterAbilitySystemUpdated");
static_assert(sizeof(HWDisplayInfoComponent_HandleCharacterAbilitySystemUpdated) == 0x000010, "Wrong size on HWDisplayInfoComponent_HandleCharacterAbilitySystemUpdated");
static_assert(offsetof(HWDisplayInfoComponent_HandleCharacterAbilitySystemUpdated, AbilitySystem) == 0x000000, "Member 'HWDisplayInfoComponent_HandleCharacterAbilitySystemUpdated::AbilitySystem' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_HandleCharacterAbilitySystemUpdated, OldAbilitySystem) == 0x000008, "Member 'HWDisplayInfoComponent_HandleCharacterAbilitySystemUpdated::OldAbilitySystem' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.HandleCharacterTeamChanged
// 0x0010 (0x0010 - 0x0000)
struct HWDisplayInfoComponent_HandleCharacterTeamChanged final
{
public:
	class AHWCharacterAbilitySystemActor*         OwningAbilitySystemActor;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamState*                           InTeamState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_HandleCharacterTeamChanged) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_HandleCharacterTeamChanged");
static_assert(sizeof(HWDisplayInfoComponent_HandleCharacterTeamChanged) == 0x000010, "Wrong size on HWDisplayInfoComponent_HandleCharacterTeamChanged");
static_assert(offsetof(HWDisplayInfoComponent_HandleCharacterTeamChanged, OwningAbilitySystemActor) == 0x000000, "Member 'HWDisplayInfoComponent_HandleCharacterTeamChanged::OwningAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_HandleCharacterTeamChanged, InTeamState) == 0x000008, "Member 'HWDisplayInfoComponent_HandleCharacterTeamChanged::InTeamState' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.HandleLocalFoWVisibilityUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoComponent_HandleLocalFoWVisibilityUpdated final
{
public:
	class UHWVisibilityComponent*                 VisibilityComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_HandleLocalFoWVisibilityUpdated) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_HandleLocalFoWVisibilityUpdated");
static_assert(sizeof(HWDisplayInfoComponent_HandleLocalFoWVisibilityUpdated) == 0x000008, "Wrong size on HWDisplayInfoComponent_HandleLocalFoWVisibilityUpdated");
static_assert(offsetof(HWDisplayInfoComponent_HandleLocalFoWVisibilityUpdated, VisibilityComponent) == 0x000000, "Member 'HWDisplayInfoComponent_HandleLocalFoWVisibilityUpdated::VisibilityComponent' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.HandleLocalMinimapVisibilityUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoComponent_HandleLocalMinimapVisibilityUpdated final
{
public:
	class UHWVisibilityComponent*                 VisibilityComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_HandleLocalMinimapVisibilityUpdated) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_HandleLocalMinimapVisibilityUpdated");
static_assert(sizeof(HWDisplayInfoComponent_HandleLocalMinimapVisibilityUpdated) == 0x000008, "Wrong size on HWDisplayInfoComponent_HandleLocalMinimapVisibilityUpdated");
static_assert(offsetof(HWDisplayInfoComponent_HandleLocalMinimapVisibilityUpdated, VisibilityComponent) == 0x000000, "Member 'HWDisplayInfoComponent_HandleLocalMinimapVisibilityUpdated::VisibilityComponent' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.HandleLocalOwnerVisibilityUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoComponent_HandleLocalOwnerVisibilityUpdated final
{
public:
	class UHWVisibilityComponent*                 VisibilityComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_HandleLocalOwnerVisibilityUpdated) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_HandleLocalOwnerVisibilityUpdated");
static_assert(sizeof(HWDisplayInfoComponent_HandleLocalOwnerVisibilityUpdated) == 0x000008, "Wrong size on HWDisplayInfoComponent_HandleLocalOwnerVisibilityUpdated");
static_assert(offsetof(HWDisplayInfoComponent_HandleLocalOwnerVisibilityUpdated, VisibilityComponent) == 0x000000, "Member 'HWDisplayInfoComponent_HandleLocalOwnerVisibilityUpdated::VisibilityComponent' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.HandleOnPawnControllerChanged
// 0x0018 (0x0018 - 0x0000)
struct HWDisplayInfoComponent_HandleOnPawnControllerChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OldController;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            NewController;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_HandleOnPawnControllerChanged) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_HandleOnPawnControllerChanged");
static_assert(sizeof(HWDisplayInfoComponent_HandleOnPawnControllerChanged) == 0x000018, "Wrong size on HWDisplayInfoComponent_HandleOnPawnControllerChanged");
static_assert(offsetof(HWDisplayInfoComponent_HandleOnPawnControllerChanged, Pawn) == 0x000000, "Member 'HWDisplayInfoComponent_HandleOnPawnControllerChanged::Pawn' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_HandleOnPawnControllerChanged, OldController) == 0x000008, "Member 'HWDisplayInfoComponent_HandleOnPawnControllerChanged::OldController' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_HandleOnPawnControllerChanged, NewController) == 0x000010, "Member 'HWDisplayInfoComponent_HandleOnPawnControllerChanged::NewController' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.HandleVisibilityComponentUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoComponent_HandleVisibilityComponentUpdated final
{
public:
	class UHWVisibilityComponent*                 VisibilityComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_HandleVisibilityComponentUpdated) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_HandleVisibilityComponentUpdated");
static_assert(sizeof(HWDisplayInfoComponent_HandleVisibilityComponentUpdated) == 0x000008, "Wrong size on HWDisplayInfoComponent_HandleVisibilityComponentUpdated");
static_assert(offsetof(HWDisplayInfoComponent_HandleVisibilityComponentUpdated, VisibilityComponent) == 0x000000, "Member 'HWDisplayInfoComponent_HandleVisibilityComponentUpdated::VisibilityComponent' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.HideActiveDisplayInfo
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoComponent_HideActiveDisplayInfo final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_HideActiveDisplayInfo) == 0x000004, "Wrong alignment on HWDisplayInfoComponent_HideActiveDisplayInfo");
static_assert(sizeof(HWDisplayInfoComponent_HideActiveDisplayInfo) == 0x000008, "Wrong size on HWDisplayInfoComponent_HideActiveDisplayInfo");
static_assert(offsetof(HWDisplayInfoComponent_HideActiveDisplayInfo, DisplayInfoTag) == 0x000000, "Member 'HWDisplayInfoComponent_HideActiveDisplayInfo::DisplayInfoTag' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.RegisterDisplayInfoConfig
// 0x0020 (0x0020 - 0x0000)
struct HWDisplayInfoComponent_RegisterDisplayInfoConfig final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWDisplayInfoConfig                   NewConfig;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_RegisterDisplayInfoConfig) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_RegisterDisplayInfoConfig");
static_assert(sizeof(HWDisplayInfoComponent_RegisterDisplayInfoConfig) == 0x000020, "Wrong size on HWDisplayInfoComponent_RegisterDisplayInfoConfig");
static_assert(offsetof(HWDisplayInfoComponent_RegisterDisplayInfoConfig, DisplayInfoTag) == 0x000000, "Member 'HWDisplayInfoComponent_RegisterDisplayInfoConfig::DisplayInfoTag' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_RegisterDisplayInfoConfig, NewConfig) == 0x000008, "Member 'HWDisplayInfoComponent_RegisterDisplayInfoConfig::NewConfig' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.RemoveDisplayInfo
// 0x000C (0x000C - 0x0000)
struct HWDisplayInfoComponent_RemoveDisplayInfo final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyNextTick;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDisplayInfoComponent_RemoveDisplayInfo) == 0x000004, "Wrong alignment on HWDisplayInfoComponent_RemoveDisplayInfo");
static_assert(sizeof(HWDisplayInfoComponent_RemoveDisplayInfo) == 0x00000C, "Wrong size on HWDisplayInfoComponent_RemoveDisplayInfo");
static_assert(offsetof(HWDisplayInfoComponent_RemoveDisplayInfo, DisplayInfoTag) == 0x000000, "Member 'HWDisplayInfoComponent_RemoveDisplayInfo::DisplayInfoTag' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_RemoveDisplayInfo, bApplyNextTick) == 0x000008, "Member 'HWDisplayInfoComponent_RemoveDisplayInfo::bApplyNextTick' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.RemoveDisplayInfoConfig
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoComponent_RemoveDisplayInfoConfig final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_RemoveDisplayInfoConfig) == 0x000004, "Wrong alignment on HWDisplayInfoComponent_RemoveDisplayInfoConfig");
static_assert(sizeof(HWDisplayInfoComponent_RemoveDisplayInfoConfig) == 0x000008, "Wrong size on HWDisplayInfoComponent_RemoveDisplayInfoConfig");
static_assert(offsetof(HWDisplayInfoComponent_RemoveDisplayInfoConfig, DisplayInfoTag) == 0x000000, "Member 'HWDisplayInfoComponent_RemoveDisplayInfoConfig::DisplayInfoTag' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.SetFlag
// 0x0002 (0x0002 - 0x0000)
struct HWDisplayInfoComponent_SetFlag final
{
public:
	EHWDisplayInfoComponentFlag                   flag;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivate;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_SetFlag) == 0x000001, "Wrong alignment on HWDisplayInfoComponent_SetFlag");
static_assert(sizeof(HWDisplayInfoComponent_SetFlag) == 0x000002, "Wrong size on HWDisplayInfoComponent_SetFlag");
static_assert(offsetof(HWDisplayInfoComponent_SetFlag, flag) == 0x000000, "Member 'HWDisplayInfoComponent_SetFlag::flag' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_SetFlag, bActivate) == 0x000001, "Member 'HWDisplayInfoComponent_SetFlag::bActivate' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.ShowActiveDisplayInfo
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoComponent_ShowActiveDisplayInfo final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_ShowActiveDisplayInfo) == 0x000004, "Wrong alignment on HWDisplayInfoComponent_ShowActiveDisplayInfo");
static_assert(sizeof(HWDisplayInfoComponent_ShowActiveDisplayInfo) == 0x000008, "Wrong size on HWDisplayInfoComponent_ShowActiveDisplayInfo");
static_assert(offsetof(HWDisplayInfoComponent_ShowActiveDisplayInfo, DisplayInfoTag) == 0x000000, "Member 'HWDisplayInfoComponent_ShowActiveDisplayInfo::DisplayInfoTag' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.ToggleFlag
// 0x0001 (0x0001 - 0x0000)
struct HWDisplayInfoComponent_ToggleFlag final
{
public:
	EHWDisplayInfoComponentFlag                   flag;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_ToggleFlag) == 0x000001, "Wrong alignment on HWDisplayInfoComponent_ToggleFlag");
static_assert(sizeof(HWDisplayInfoComponent_ToggleFlag) == 0x000001, "Wrong size on HWDisplayInfoComponent_ToggleFlag");
static_assert(offsetof(HWDisplayInfoComponent_ToggleFlag, flag) == 0x000000, "Member 'HWDisplayInfoComponent_ToggleFlag::flag' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.UpdateDisplayInfoLifespan
// 0x000C (0x000C - 0x0000)
struct HWDisplayInfoComponent_UpdateDisplayInfoLifespan final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_UpdateDisplayInfoLifespan) == 0x000004, "Wrong alignment on HWDisplayInfoComponent_UpdateDisplayInfoLifespan");
static_assert(sizeof(HWDisplayInfoComponent_UpdateDisplayInfoLifespan) == 0x00000C, "Wrong size on HWDisplayInfoComponent_UpdateDisplayInfoLifespan");
static_assert(offsetof(HWDisplayInfoComponent_UpdateDisplayInfoLifespan, DisplayInfoTag) == 0x000000, "Member 'HWDisplayInfoComponent_UpdateDisplayInfoLifespan::DisplayInfoTag' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_UpdateDisplayInfoLifespan, LifeSpan) == 0x000008, "Member 'HWDisplayInfoComponent_UpdateDisplayInfoLifespan::LifeSpan' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.GetDisplayInfoConfig
// 0x0020 (0x0020 - 0x0000)
struct HWDisplayInfoComponent_GetDisplayInfoConfig final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWDisplayInfoConfig                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_GetDisplayInfoConfig) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_GetDisplayInfoConfig");
static_assert(sizeof(HWDisplayInfoComponent_GetDisplayInfoConfig) == 0x000020, "Wrong size on HWDisplayInfoComponent_GetDisplayInfoConfig");
static_assert(offsetof(HWDisplayInfoComponent_GetDisplayInfoConfig, DisplayInfoTag) == 0x000000, "Member 'HWDisplayInfoComponent_GetDisplayInfoConfig::DisplayInfoTag' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_GetDisplayInfoConfig, ReturnValue) == 0x000008, "Member 'HWDisplayInfoComponent_GetDisplayInfoConfig::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.GetFloatingTextAlignment
// 0x0018 (0x0018 - 0x0000)
struct HWDisplayInfoComponent_GetFloatingTextAlignment final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_GetFloatingTextAlignment) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_GetFloatingTextAlignment");
static_assert(sizeof(HWDisplayInfoComponent_GetFloatingTextAlignment) == 0x000018, "Wrong size on HWDisplayInfoComponent_GetFloatingTextAlignment");
static_assert(offsetof(HWDisplayInfoComponent_GetFloatingTextAlignment, ReturnValue) == 0x000000, "Member 'HWDisplayInfoComponent_GetFloatingTextAlignment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.GetFloatingTextAnchor
// 0x0018 (0x0018 - 0x0000)
struct HWDisplayInfoComponent_GetFloatingTextAnchor final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_GetFloatingTextAnchor) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_GetFloatingTextAnchor");
static_assert(sizeof(HWDisplayInfoComponent_GetFloatingTextAnchor) == 0x000018, "Wrong size on HWDisplayInfoComponent_GetFloatingTextAnchor");
static_assert(offsetof(HWDisplayInfoComponent_GetFloatingTextAnchor, ReturnValue) == 0x000000, "Member 'HWDisplayInfoComponent_GetFloatingTextAnchor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.GetFloatingTextOffset
// 0x0018 (0x0018 - 0x0000)
struct HWDisplayInfoComponent_GetFloatingTextOffset final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_GetFloatingTextOffset) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_GetFloatingTextOffset");
static_assert(sizeof(HWDisplayInfoComponent_GetFloatingTextOffset) == 0x000018, "Wrong size on HWDisplayInfoComponent_GetFloatingTextOffset");
static_assert(offsetof(HWDisplayInfoComponent_GetFloatingTextOffset, ReturnValue) == 0x000000, "Member 'HWDisplayInfoComponent_GetFloatingTextOffset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.GetWorldOverlayAnchor
// 0x0018 (0x0018 - 0x0000)
struct HWDisplayInfoComponent_GetWorldOverlayAnchor final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_GetWorldOverlayAnchor) == 0x000008, "Wrong alignment on HWDisplayInfoComponent_GetWorldOverlayAnchor");
static_assert(sizeof(HWDisplayInfoComponent_GetWorldOverlayAnchor) == 0x000018, "Wrong size on HWDisplayInfoComponent_GetWorldOverlayAnchor");
static_assert(offsetof(HWDisplayInfoComponent_GetWorldOverlayAnchor, ReturnValue) == 0x000000, "Member 'HWDisplayInfoComponent_GetWorldOverlayAnchor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.HasFloatingTextAnchorOverride
// 0x0001 (0x0001 - 0x0000)
struct HWDisplayInfoComponent_HasFloatingTextAnchorOverride final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_HasFloatingTextAnchorOverride) == 0x000001, "Wrong alignment on HWDisplayInfoComponent_HasFloatingTextAnchorOverride");
static_assert(sizeof(HWDisplayInfoComponent_HasFloatingTextAnchorOverride) == 0x000001, "Wrong size on HWDisplayInfoComponent_HasFloatingTextAnchorOverride");
static_assert(offsetof(HWDisplayInfoComponent_HasFloatingTextAnchorOverride, ReturnValue) == 0x000000, "Member 'HWDisplayInfoComponent_HasFloatingTextAnchorOverride::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.HasWorldOverlayAnchorOverride
// 0x0001 (0x0001 - 0x0000)
struct HWDisplayInfoComponent_HasWorldOverlayAnchorOverride final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_HasWorldOverlayAnchorOverride) == 0x000001, "Wrong alignment on HWDisplayInfoComponent_HasWorldOverlayAnchorOverride");
static_assert(sizeof(HWDisplayInfoComponent_HasWorldOverlayAnchorOverride) == 0x000001, "Wrong size on HWDisplayInfoComponent_HasWorldOverlayAnchorOverride");
static_assert(offsetof(HWDisplayInfoComponent_HasWorldOverlayAnchorOverride, ReturnValue) == 0x000000, "Member 'HWDisplayInfoComponent_HasWorldOverlayAnchorOverride::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.IsDisplayInfoActive
// 0x000C (0x000C - 0x0000)
struct HWDisplayInfoComponent_IsDisplayInfoActive final
{
public:
	struct FGameplayTag                           DisplayInfoTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDisplayInfoComponent_IsDisplayInfoActive) == 0x000004, "Wrong alignment on HWDisplayInfoComponent_IsDisplayInfoActive");
static_assert(sizeof(HWDisplayInfoComponent_IsDisplayInfoActive) == 0x00000C, "Wrong size on HWDisplayInfoComponent_IsDisplayInfoActive");
static_assert(offsetof(HWDisplayInfoComponent_IsDisplayInfoActive, DisplayInfoTag) == 0x000000, "Member 'HWDisplayInfoComponent_IsDisplayInfoActive::DisplayInfoTag' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_IsDisplayInfoActive, ReturnValue) == 0x000008, "Member 'HWDisplayInfoComponent_IsDisplayInfoActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoComponent.IsFlagActive
// 0x0002 (0x0002 - 0x0000)
struct HWDisplayInfoComponent_IsFlagActive final
{
public:
	EHWDisplayInfoComponentFlag                   flag;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoComponent_IsFlagActive) == 0x000001, "Wrong alignment on HWDisplayInfoComponent_IsFlagActive");
static_assert(sizeof(HWDisplayInfoComponent_IsFlagActive) == 0x000002, "Wrong size on HWDisplayInfoComponent_IsFlagActive");
static_assert(offsetof(HWDisplayInfoComponent_IsFlagActive, flag) == 0x000000, "Member 'HWDisplayInfoComponent_IsFlagActive::flag' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoComponent_IsFlagActive, ReturnValue) == 0x000001, "Member 'HWDisplayInfoComponent_IsFlagActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoJungleComponent.HandleFactoryMinimapStateUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoJungleComponent_HandleFactoryMinimapStateUpdated final
{
public:
	class AHWBotFactory*                          BotFactory;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoJungleComponent_HandleFactoryMinimapStateUpdated) == 0x000008, "Wrong alignment on HWDisplayInfoJungleComponent_HandleFactoryMinimapStateUpdated");
static_assert(sizeof(HWDisplayInfoJungleComponent_HandleFactoryMinimapStateUpdated) == 0x000008, "Wrong size on HWDisplayInfoJungleComponent_HandleFactoryMinimapStateUpdated");
static_assert(offsetof(HWDisplayInfoJungleComponent_HandleFactoryMinimapStateUpdated, BotFactory) == 0x000000, "Member 'HWDisplayInfoJungleComponent_HandleFactoryMinimapStateUpdated::BotFactory' has a wrong offset!");

// Function Hemingway.HWDisplayInfoJungleComponent.CanLocalTeamSeeRespawns
// 0x0001 (0x0001 - 0x0000)
struct HWDisplayInfoJungleComponent_CanLocalTeamSeeRespawns final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoJungleComponent_CanLocalTeamSeeRespawns) == 0x000001, "Wrong alignment on HWDisplayInfoJungleComponent_CanLocalTeamSeeRespawns");
static_assert(sizeof(HWDisplayInfoJungleComponent_CanLocalTeamSeeRespawns) == 0x000001, "Wrong size on HWDisplayInfoJungleComponent_CanLocalTeamSeeRespawns");
static_assert(offsetof(HWDisplayInfoJungleComponent_CanLocalTeamSeeRespawns, ReturnValue) == 0x000000, "Member 'HWDisplayInfoJungleComponent_CanLocalTeamSeeRespawns::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoJungleComponent.GetCampTypeTag
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoJungleComponent_GetCampTypeTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoJungleComponent_GetCampTypeTag) == 0x000004, "Wrong alignment on HWDisplayInfoJungleComponent_GetCampTypeTag");
static_assert(sizeof(HWDisplayInfoJungleComponent_GetCampTypeTag) == 0x000008, "Wrong size on HWDisplayInfoJungleComponent_GetCampTypeTag");
static_assert(offsetof(HWDisplayInfoJungleComponent_GetCampTypeTag, ReturnValue) == 0x000000, "Member 'HWDisplayInfoJungleComponent_GetCampTypeTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoJungleComponent.GetRespawnTimeInfo
// 0x000C (0x000C - 0x0000)
struct HWDisplayInfoJungleComponent_GetRespawnTimeInfo final
{
public:
	float                                         OutTotalRespawnTime;                               // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutRemainingRespawnTime;                           // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDisplayInfoJungleComponent_GetRespawnTimeInfo) == 0x000004, "Wrong alignment on HWDisplayInfoJungleComponent_GetRespawnTimeInfo");
static_assert(sizeof(HWDisplayInfoJungleComponent_GetRespawnTimeInfo) == 0x00000C, "Wrong size on HWDisplayInfoJungleComponent_GetRespawnTimeInfo");
static_assert(offsetof(HWDisplayInfoJungleComponent_GetRespawnTimeInfo, OutTotalRespawnTime) == 0x000000, "Member 'HWDisplayInfoJungleComponent_GetRespawnTimeInfo::OutTotalRespawnTime' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoJungleComponent_GetRespawnTimeInfo, OutRemainingRespawnTime) == 0x000004, "Member 'HWDisplayInfoJungleComponent_GetRespawnTimeInfo::OutRemainingRespawnTime' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoJungleComponent_GetRespawnTimeInfo, ReturnValue) == 0x000008, "Member 'HWDisplayInfoJungleComponent_GetRespawnTimeInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoJungleComponent.IsCampActive
// 0x0001 (0x0001 - 0x0000)
struct HWDisplayInfoJungleComponent_IsCampActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoJungleComponent_IsCampActive) == 0x000001, "Wrong alignment on HWDisplayInfoJungleComponent_IsCampActive");
static_assert(sizeof(HWDisplayInfoJungleComponent_IsCampActive) == 0x000001, "Wrong size on HWDisplayInfoJungleComponent_IsCampActive");
static_assert(offsetof(HWDisplayInfoJungleComponent_IsCampActive, ReturnValue) == 0x000000, "Member 'HWDisplayInfoJungleComponent_IsCampActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Geb.AnimateBoulderOutro
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Geb_AnimateBoulderOutro final
{
public:
	bool                                          isLeap;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Geb_AnimateBoulderOutro) == 0x000001, "Wrong alignment on HWCharacter_Geb_AnimateBoulderOutro");
static_assert(sizeof(HWCharacter_Geb_AnimateBoulderOutro) == 0x000001, "Wrong size on HWCharacter_Geb_AnimateBoulderOutro");
static_assert(offsetof(HWCharacter_Geb_AnimateBoulderOutro, isLeap) == 0x000000, "Member 'HWCharacter_Geb_AnimateBoulderOutro::isLeap' has a wrong offset!");

// Function Hemingway.HWCharacter_Geb.SetBoulderState
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Geb_SetBoulderState final
{
public:
	EHWBoulderState                               NewBoulderState;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Geb_SetBoulderState) == 0x000001, "Wrong alignment on HWCharacter_Geb_SetBoulderState");
static_assert(sizeof(HWCharacter_Geb_SetBoulderState) == 0x000001, "Wrong size on HWCharacter_Geb_SetBoulderState");
static_assert(offsetof(HWCharacter_Geb_SetBoulderState, NewBoulderState) == 0x000000, "Member 'HWCharacter_Geb_SetBoulderState::NewBoulderState' has a wrong offset!");

// Function Hemingway.HWCharacter_Geb.GetBoulderState
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Geb_GetBoulderState final
{
public:
	EHWBoulderState                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Geb_GetBoulderState) == 0x000001, "Wrong alignment on HWCharacter_Geb_GetBoulderState");
static_assert(sizeof(HWCharacter_Geb_GetBoulderState) == 0x000001, "Wrong size on HWCharacter_Geb_GetBoulderState");
static_assert(offsetof(HWCharacter_Geb_GetBoulderState, ReturnValue) == 0x000000, "Member 'HWCharacter_Geb_GetBoulderState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Geb.IsBoulderStateActive
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Geb_IsBoulderStateActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Geb_IsBoulderStateActive) == 0x000001, "Wrong alignment on HWCharacter_Geb_IsBoulderStateActive");
static_assert(sizeof(HWCharacter_Geb_IsBoulderStateActive) == 0x000001, "Wrong size on HWCharacter_Geb_IsBoulderStateActive");
static_assert(offsetof(HWCharacter_Geb_IsBoulderStateActive, ReturnValue) == 0x000000, "Member 'HWCharacter_Geb_IsBoulderStateActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitAITargetChange.WaitForAITargetChange
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_WaitAITargetChange_WaitForAITargetChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_WaitAITargetChange*      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitAITargetChange_WaitForAITargetChange) == 0x000008, "Wrong alignment on HWAbilityTask_WaitAITargetChange_WaitForAITargetChange");
static_assert(sizeof(HWAbilityTask_WaitAITargetChange_WaitForAITargetChange) == 0x000010, "Wrong size on HWAbilityTask_WaitAITargetChange_WaitForAITargetChange");
static_assert(offsetof(HWAbilityTask_WaitAITargetChange_WaitForAITargetChange, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitAITargetChange_WaitForAITargetChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAITargetChange_WaitForAITargetChange, ReturnValue) == 0x000008, "Member 'HWAbilityTask_WaitAITargetChange_WaitForAITargetChange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Kali.GetBaseA02ProjectileSpline
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Kali_GetBaseA02ProjectileSpline final
{
public:
	int32                                         SplineIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Kali_GetBaseA02ProjectileSpline) == 0x000008, "Wrong alignment on HWCharacter_Kali_GetBaseA02ProjectileSpline");
static_assert(sizeof(HWCharacter_Kali_GetBaseA02ProjectileSpline) == 0x000010, "Wrong size on HWCharacter_Kali_GetBaseA02ProjectileSpline");
static_assert(offsetof(HWCharacter_Kali_GetBaseA02ProjectileSpline, SplineIndex) == 0x000000, "Member 'HWCharacter_Kali_GetBaseA02ProjectileSpline::SplineIndex' has a wrong offset!");
static_assert(offsetof(HWCharacter_Kali_GetBaseA02ProjectileSpline, ReturnValue) == 0x000008, "Member 'HWCharacter_Kali_GetBaseA02ProjectileSpline::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Mulan.AssignRopeTarget
// 0x0028 (0x0028 - 0x0000)
struct HWCharacter_Mulan_AssignRopeTarget final
{
public:
	bool                                          bEnableTether;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class AActor*                           TetherTarget;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WallTetherLocation;                                // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Mulan_AssignRopeTarget) == 0x000008, "Wrong alignment on HWCharacter_Mulan_AssignRopeTarget");
static_assert(sizeof(HWCharacter_Mulan_AssignRopeTarget) == 0x000028, "Wrong size on HWCharacter_Mulan_AssignRopeTarget");
static_assert(offsetof(HWCharacter_Mulan_AssignRopeTarget, bEnableTether) == 0x000000, "Member 'HWCharacter_Mulan_AssignRopeTarget::bEnableTether' has a wrong offset!");
static_assert(offsetof(HWCharacter_Mulan_AssignRopeTarget, TetherTarget) == 0x000008, "Member 'HWCharacter_Mulan_AssignRopeTarget::TetherTarget' has a wrong offset!");
static_assert(offsetof(HWCharacter_Mulan_AssignRopeTarget, WallTetherLocation) == 0x000010, "Member 'HWCharacter_Mulan_AssignRopeTarget::WallTetherLocation' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitGameplayEffectApplied_Self.WaitForGameplayEffectAppliedToSelf
// 0x01D0 (0x01D0 - 0x0000)
struct HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        EffectSourceFilter;                                // 0x0008(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               EffectSourceTagRequirements;                       // 0x0018(0x0088)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               EffectTargetTagRequirements;                       // 0x00A0(0x0088)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               EffectRequirements;                                // 0x0128(0x0088)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x01B0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OptionalExternalOwner;                             // 0x01B8(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ListenForPeriodicEffect;                           // 0x01C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitGameplayEffectApplied_Self* ReturnValue;                                // 0x01C8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf) == 0x000008, "Wrong alignment on HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf");
static_assert(sizeof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf) == 0x0001D0, "Wrong size on HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf, EffectSourceFilter) == 0x000008, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf::EffectSourceFilter' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf, EffectSourceTagRequirements) == 0x000018, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf::EffectSourceTagRequirements' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf, EffectTargetTagRequirements) == 0x0000A0, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf::EffectTargetTagRequirements' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf, EffectRequirements) == 0x000128, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf::EffectRequirements' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf, TriggerOnce) == 0x0001B0, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf::TriggerOnce' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf, OptionalExternalOwner) == 0x0001B8, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf::OptionalExternalOwner' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf, ListenForPeriodicEffect) == 0x0001C0, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf::ListenForPeriodicEffect' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf, ReturnValue) == 0x0001C8, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitForGameplayEffectAppliedToSelf::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitGameplayEffectApplied_Self.WaitGameplayEffectAppliedToSelf_Query
// 0x0278 (0x0278 - 0x0000)
struct HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        EffectSourceFilter;                                // 0x0008(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      EffectSourceTagQuery;                              // 0x0018(0x0048)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      EffectTargetTagQuery;                              // 0x0060(0x0048)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayEffectQuery                   EffectQuery;                                       // 0x00A8(0x01B0)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0258(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OptionalExternalOwner;                             // 0x0260(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ListenForPeriodicEffect;                           // 0x0268(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitGameplayEffectApplied_Self* ReturnValue;                                // 0x0270(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query) == 0x000008, "Wrong alignment on HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query");
static_assert(sizeof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query) == 0x000278, "Wrong size on HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query, EffectSourceFilter) == 0x000008, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query::EffectSourceFilter' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query, EffectSourceTagQuery) == 0x000018, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query::EffectSourceTagQuery' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query, EffectTargetTagQuery) == 0x000060, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query::EffectTargetTagQuery' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query, EffectQuery) == 0x0000A8, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query::EffectQuery' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query, TriggerOnce) == 0x000258, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query::TriggerOnce' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query, OptionalExternalOwner) == 0x000260, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query::OptionalExternalOwner' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query, ListenForPeriodicEffect) == 0x000268, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query::ListenForPeriodicEffect' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query, ReturnValue) == 0x000270, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_WaitGameplayEffectAppliedToSelf_Query::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitGameplayEffectApplied_Self.OnGameplayEffectApplied
// 0x02B8 (0x02B8 - 0x0000)
struct HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied final
{
public:
	class UAbilitySystemComponent*                EffectSourceASC;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    SpecApplied;                                       // 0x0008(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x02B0(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied) == 0x000008, "Wrong alignment on HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied");
static_assert(sizeof(HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied) == 0x0002B8, "Wrong size on HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied, EffectSourceASC) == 0x000000, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied::EffectSourceASC' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied, SpecApplied) == 0x000008, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied::SpecApplied' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied, ActiveHandle) == 0x0002B0, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_OnGameplayEffectApplied::ActiveHandle' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitGameplayEffectApplied_Self.GetTrackedActor
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedActor) == 0x000008, "Wrong alignment on HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedActor");
static_assert(sizeof(HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedActor) == 0x000008, "Wrong size on HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedActor");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedActor, ReturnValue) == 0x000000, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitGameplayEffectApplied_Self.GetTrackedASC
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedASC final
{
public:
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedASC) == 0x000008, "Wrong alignment on HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedASC");
static_assert(sizeof(HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedASC) == 0x000008, "Wrong size on HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedASC");
static_assert(offsetof(HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedASC, ReturnValue) == 0x000000, "Member 'HWAbilityTask_WaitGameplayEffectApplied_Self_GetTrackedASC::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Danzaburou_A01.OnMaxRangedReached
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_Danzaburou_A01_OnMaxRangedReached final
{
public:
	class UHWGameplayMovementComponent*           GameplayMovementComponent;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Danzaburou_A01_OnMaxRangedReached) == 0x000008, "Wrong alignment on HWDeployable_Danzaburou_A01_OnMaxRangedReached");
static_assert(sizeof(HWDeployable_Danzaburou_A01_OnMaxRangedReached) == 0x000008, "Wrong size on HWDeployable_Danzaburou_A01_OnMaxRangedReached");
static_assert(offsetof(HWDeployable_Danzaburou_A01_OnMaxRangedReached, GameplayMovementComponent) == 0x000000, "Member 'HWDeployable_Danzaburou_A01_OnMaxRangedReached::GameplayMovementComponent' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent.GetComponentSettings
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponent_GetComponentSettings final
{
public:
	const class UHWEquipmentComponentSettings*    ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_GetComponentSettings) == 0x000008, "Wrong alignment on HWEquipmentComponent_GetComponentSettings");
static_assert(sizeof(HWEquipmentComponent_GetComponentSettings) == 0x000008, "Wrong size on HWEquipmentComponent_GetComponentSettings");
static_assert(offsetof(HWEquipmentComponent_GetComponentSettings, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_GetComponentSettings::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent.GetIdTag
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponent_GetIdTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_GetIdTag) == 0x000004, "Wrong alignment on HWEquipmentComponent_GetIdTag");
static_assert(sizeof(HWEquipmentComponent_GetIdTag) == 0x000008, "Wrong size on HWEquipmentComponent_GetIdTag");
static_assert(offsetof(HWEquipmentComponent_GetIdTag, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_GetIdTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent.GetOwningAbilitySystem
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponent_GetOwningAbilitySystem final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_GetOwningAbilitySystem) == 0x000008, "Wrong alignment on HWEquipmentComponent_GetOwningAbilitySystem");
static_assert(sizeof(HWEquipmentComponent_GetOwningAbilitySystem) == 0x000008, "Wrong size on HWEquipmentComponent_GetOwningAbilitySystem");
static_assert(offsetof(HWEquipmentComponent_GetOwningAbilitySystem, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_GetOwningAbilitySystem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent.GetOwningEquipment
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponent_GetOwningEquipment final
{
public:
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_GetOwningEquipment) == 0x000008, "Wrong alignment on HWEquipmentComponent_GetOwningEquipment");
static_assert(sizeof(HWEquipmentComponent_GetOwningEquipment) == 0x000008, "Wrong size on HWEquipmentComponent_GetOwningEquipment");
static_assert(offsetof(HWEquipmentComponent_GetOwningEquipment, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_GetOwningEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent.GetOwningInventoryManagerComponent
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponent_GetOwningInventoryManagerComponent final
{
public:
	class UHWInventoryManagerComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_GetOwningInventoryManagerComponent) == 0x000008, "Wrong alignment on HWEquipmentComponent_GetOwningInventoryManagerComponent");
static_assert(sizeof(HWEquipmentComponent_GetOwningInventoryManagerComponent) == 0x000008, "Wrong size on HWEquipmentComponent_GetOwningInventoryManagerComponent");
static_assert(offsetof(HWEquipmentComponent_GetOwningInventoryManagerComponent, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_GetOwningInventoryManagerComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_ChildEquipment.OnEquipmentSlotChanged
// 0x0020 (0x0020 - 0x0000)
struct HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged final
{
public:
	class UHWInventoryManagerComponent*           InventoryManager;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       Slot;                                              // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWInventoryChangeReason                      InventoryChangeReason;                             // 0x001C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged) == 0x000008, "Wrong alignment on HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged");
static_assert(sizeof(HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged) == 0x000020, "Wrong size on HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged");
static_assert(offsetof(HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged, InventoryManager) == 0x000000, "Member 'HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged::InventoryManager' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged, EquipmentInstance) == 0x000008, "Member 'HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged, Slot) == 0x000010, "Member 'HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged::Slot' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged, InventoryChangeReason) == 0x00001C, "Member 'HWEquipmentComponent_ChildEquipment_OnEquipmentSlotChanged::InventoryChangeReason' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_ChildEquipment.OnParentLevelChanged
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentComponent_ChildEquipment_OnParentLevelChanged final
{
public:
	class UHWEquipmentInstance*                   Equipment;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousLevel;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_ChildEquipment_OnParentLevelChanged) == 0x000008, "Wrong alignment on HWEquipmentComponent_ChildEquipment_OnParentLevelChanged");
static_assert(sizeof(HWEquipmentComponent_ChildEquipment_OnParentLevelChanged) == 0x000010, "Wrong size on HWEquipmentComponent_ChildEquipment_OnParentLevelChanged");
static_assert(offsetof(HWEquipmentComponent_ChildEquipment_OnParentLevelChanged, Equipment) == 0x000000, "Member 'HWEquipmentComponent_ChildEquipment_OnParentLevelChanged::Equipment' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_ChildEquipment_OnParentLevelChanged, PreviousLevel) == 0x000008, "Member 'HWEquipmentComponent_ChildEquipment_OnParentLevelChanged::PreviousLevel' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_ChildEquipment.GetParentEquipment
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponent_ChildEquipment_GetParentEquipment final
{
public:
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_ChildEquipment_GetParentEquipment) == 0x000008, "Wrong alignment on HWEquipmentComponent_ChildEquipment_GetParentEquipment");
static_assert(sizeof(HWEquipmentComponent_ChildEquipment_GetParentEquipment) == 0x000008, "Wrong size on HWEquipmentComponent_ChildEquipment_GetParentEquipment");
static_assert(offsetof(HWEquipmentComponent_ChildEquipment_GetParentEquipment, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_ChildEquipment_GetParentEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_ChildEquipment.GetParentEquipmentComponentByClass
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentComponent_ChildEquipment_GetParentEquipmentComponentByClass final
{
public:
	TSubclassOf<class UHWEquipmentComponent>      ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWEquipmentComponent*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_ChildEquipment_GetParentEquipmentComponentByClass) == 0x000008, "Wrong alignment on HWEquipmentComponent_ChildEquipment_GetParentEquipmentComponentByClass");
static_assert(sizeof(HWEquipmentComponent_ChildEquipment_GetParentEquipmentComponentByClass) == 0x000010, "Wrong size on HWEquipmentComponent_ChildEquipment_GetParentEquipmentComponentByClass");
static_assert(offsetof(HWEquipmentComponent_ChildEquipment_GetParentEquipmentComponentByClass, ComponentClass) == 0x000000, "Member 'HWEquipmentComponent_ChildEquipment_GetParentEquipmentComponentByClass::ComponentClass' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_ChildEquipment_GetParentEquipmentComponentByClass, ReturnValue) == 0x000008, "Member 'HWEquipmentComponent_ChildEquipment_GetParentEquipmentComponentByClass::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_ChildEquipment.ShouldUseParentEquipmentFiringInstanceId
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_ChildEquipment_ShouldUseParentEquipmentFiringInstanceId final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_ChildEquipment_ShouldUseParentEquipmentFiringInstanceId) == 0x000001, "Wrong alignment on HWEquipmentComponent_ChildEquipment_ShouldUseParentEquipmentFiringInstanceId");
static_assert(sizeof(HWEquipmentComponent_ChildEquipment_ShouldUseParentEquipmentFiringInstanceId) == 0x000001, "Wrong size on HWEquipmentComponent_ChildEquipment_ShouldUseParentEquipmentFiringInstanceId");
static_assert(offsetof(HWEquipmentComponent_ChildEquipment_ShouldUseParentEquipmentFiringInstanceId, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_ChildEquipment_ShouldUseParentEquipmentFiringInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Statue.GetTargetCharacterToDepict
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_Statue_GetTargetCharacterToDepict final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Statue_GetTargetCharacterToDepict) == 0x000008, "Wrong alignment on HWDeployable_Statue_GetTargetCharacterToDepict");
static_assert(sizeof(HWDeployable_Statue_GetTargetCharacterToDepict) == 0x000008, "Wrong size on HWDeployable_Statue_GetTargetCharacterToDepict");
static_assert(offsetof(HWDeployable_Statue_GetTargetCharacterToDepict, ReturnValue) == 0x000000, "Member 'HWDeployable_Statue_GetTargetCharacterToDepict::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Statue.HandleTagUpdated_TargetLock
// 0x000C (0x000C - 0x0000)
struct HWDeployable_Statue_HandleTagUpdated_TargetLock final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Statue_HandleTagUpdated_TargetLock) == 0x000004, "Wrong alignment on HWDeployable_Statue_HandleTagUpdated_TargetLock");
static_assert(sizeof(HWDeployable_Statue_HandleTagUpdated_TargetLock) == 0x00000C, "Wrong size on HWDeployable_Statue_HandleTagUpdated_TargetLock");
static_assert(offsetof(HWDeployable_Statue_HandleTagUpdated_TargetLock, CallbackTag) == 0x000000, "Member 'HWDeployable_Statue_HandleTagUpdated_TargetLock::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWDeployable_Statue_HandleTagUpdated_TargetLock, NewCount) == 0x000008, "Member 'HWDeployable_Statue_HandleTagUpdated_TargetLock::NewCount' has a wrong offset!");

// Function Hemingway.HWDeployable_Statue.InitializeStatue
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_Statue_InitializeStatue final
{
public:
	class AHWCharacter_Base*                      InTargetCharacter;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Statue_InitializeStatue) == 0x000008, "Wrong alignment on HWDeployable_Statue_InitializeStatue");
static_assert(sizeof(HWDeployable_Statue_InitializeStatue) == 0x000008, "Wrong size on HWDeployable_Statue_InitializeStatue");
static_assert(offsetof(HWDeployable_Statue_InitializeStatue, InTargetCharacter) == 0x000000, "Member 'HWDeployable_Statue_InitializeStatue::InTargetCharacter' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.AddStatusTag
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_AddStatusTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_AddStatusTag) == 0x000004, "Wrong alignment on HWEquipmentInstance_AddStatusTag");
static_assert(sizeof(HWEquipmentInstance_AddStatusTag) == 0x000008, "Wrong size on HWEquipmentInstance_AddStatusTag");
static_assert(offsetof(HWEquipmentInstance_AddStatusTag, Tag) == 0x000000, "Member 'HWEquipmentInstance_AddStatusTag::Tag' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.AssignInputTag
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_AssignInputTag final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_AssignInputTag) == 0x000004, "Wrong alignment on HWEquipmentInstance_AssignInputTag");
static_assert(sizeof(HWEquipmentInstance_AssignInputTag) == 0x000008, "Wrong size on HWEquipmentInstance_AssignInputTag");
static_assert(offsetof(HWEquipmentInstance_AssignInputTag, InputTag) == 0x000000, "Member 'HWEquipmentInstance_AssignInputTag::InputTag' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetCastStyle
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentInstance_GetCastStyle final
{
public:
	EAbilityCastStyle                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetCastStyle) == 0x000001, "Wrong alignment on HWEquipmentInstance_GetCastStyle");
static_assert(sizeof(HWEquipmentInstance_GetCastStyle) == 0x000001, "Wrong size on HWEquipmentInstance_GetCastStyle");
static_assert(offsetof(HWEquipmentInstance_GetCastStyle, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetCastStyle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.HandleAbilityActivationBlockedTagUpdated
// 0x000C (0x000C - 0x0000)
struct HWEquipmentInstance_HandleAbilityActivationBlockedTagUpdated final
{
public:
	struct FGameplayTag                           ActivationBlockTag;                                // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_HandleAbilityActivationBlockedTagUpdated) == 0x000004, "Wrong alignment on HWEquipmentInstance_HandleAbilityActivationBlockedTagUpdated");
static_assert(sizeof(HWEquipmentInstance_HandleAbilityActivationBlockedTagUpdated) == 0x00000C, "Wrong size on HWEquipmentInstance_HandleAbilityActivationBlockedTagUpdated");
static_assert(offsetof(HWEquipmentInstance_HandleAbilityActivationBlockedTagUpdated, ActivationBlockTag) == 0x000000, "Member 'HWEquipmentInstance_HandleAbilityActivationBlockedTagUpdated::ActivationBlockTag' has a wrong offset!");
static_assert(offsetof(HWEquipmentInstance_HandleAbilityActivationBlockedTagUpdated, Count) == 0x000008, "Member 'HWEquipmentInstance_HandleAbilityActivationBlockedTagUpdated::Count' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.OnEquipmentLevelChanged
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentInstance_OnEquipmentLevelChanged final
{
public:
	int32                                         PreviousLevel;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_OnEquipmentLevelChanged) == 0x000004, "Wrong alignment on HWEquipmentInstance_OnEquipmentLevelChanged");
static_assert(sizeof(HWEquipmentInstance_OnEquipmentLevelChanged) == 0x000004, "Wrong size on HWEquipmentInstance_OnEquipmentLevelChanged");
static_assert(offsetof(HWEquipmentInstance_OnEquipmentLevelChanged, PreviousLevel) == 0x000000, "Member 'HWEquipmentInstance_OnEquipmentLevelChanged::PreviousLevel' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.OnRep_AssignedInputTag
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_OnRep_AssignedInputTag final
{
public:
	struct FGameplayTag                           OldInputTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_OnRep_AssignedInputTag) == 0x000004, "Wrong alignment on HWEquipmentInstance_OnRep_AssignedInputTag");
static_assert(sizeof(HWEquipmentInstance_OnRep_AssignedInputTag) == 0x000008, "Wrong size on HWEquipmentInstance_OnRep_AssignedInputTag");
static_assert(offsetof(HWEquipmentInstance_OnRep_AssignedInputTag, OldInputTag) == 0x000000, "Member 'HWEquipmentInstance_OnRep_AssignedInputTag::OldInputTag' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.RefundSkillPoints
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentInstance_RefundSkillPoints final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_RefundSkillPoints) == 0x000004, "Wrong alignment on HWEquipmentInstance_RefundSkillPoints");
static_assert(sizeof(HWEquipmentInstance_RefundSkillPoints) == 0x000004, "Wrong size on HWEquipmentInstance_RefundSkillPoints");
static_assert(offsetof(HWEquipmentInstance_RefundSkillPoints, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_RefundSkillPoints::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.RemoveStatusTag
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_RemoveStatusTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_RemoveStatusTag) == 0x000004, "Wrong alignment on HWEquipmentInstance_RemoveStatusTag");
static_assert(sizeof(HWEquipmentInstance_RemoveStatusTag) == 0x000008, "Wrong size on HWEquipmentInstance_RemoveStatusTag");
static_assert(offsetof(HWEquipmentInstance_RemoveStatusTag, Tag) == 0x000000, "Member 'HWEquipmentInstance_RemoveStatusTag::Tag' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.ServerSetLevel
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentInstance_ServerSetLevel final
{
public:
	int32                                         NewLevel;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_ServerSetLevel) == 0x000004, "Wrong alignment on HWEquipmentInstance_ServerSetLevel");
static_assert(sizeof(HWEquipmentInstance_ServerSetLevel) == 0x000004, "Wrong size on HWEquipmentInstance_ServerSetLevel");
static_assert(offsetof(HWEquipmentInstance_ServerSetLevel, NewLevel) == 0x000000, "Member 'HWEquipmentInstance_ServerSetLevel::NewLevel' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.SetAbilityCastStyle
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentInstance_SetAbilityCastStyle final
{
public:
	EAbilityCastStyle                             InCastStyle;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_SetAbilityCastStyle) == 0x000001, "Wrong alignment on HWEquipmentInstance_SetAbilityCastStyle");
static_assert(sizeof(HWEquipmentInstance_SetAbilityCastStyle) == 0x000001, "Wrong size on HWEquipmentInstance_SetAbilityCastStyle");
static_assert(offsetof(HWEquipmentInstance_SetAbilityCastStyle, InCastStyle) == 0x000000, "Member 'HWEquipmentInstance_SetAbilityCastStyle::InCastStyle' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.SetAbilityPersistentState
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentInstance_SetAbilityPersistentState final
{
public:
	class FString                                 PersistentState;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_SetAbilityPersistentState) == 0x000008, "Wrong alignment on HWEquipmentInstance_SetAbilityPersistentState");
static_assert(sizeof(HWEquipmentInstance_SetAbilityPersistentState) == 0x000010, "Wrong size on HWEquipmentInstance_SetAbilityPersistentState");
static_assert(offsetof(HWEquipmentInstance_SetAbilityPersistentState, PersistentState) == 0x000000, "Member 'HWEquipmentInstance_SetAbilityPersistentState::PersistentState' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.SetIconOverrideTag
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_SetIconOverrideTag final
{
public:
	struct FGameplayTag                           NewIconOverrideTag;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_SetIconOverrideTag) == 0x000004, "Wrong alignment on HWEquipmentInstance_SetIconOverrideTag");
static_assert(sizeof(HWEquipmentInstance_SetIconOverrideTag) == 0x000008, "Wrong size on HWEquipmentInstance_SetIconOverrideTag");
static_assert(offsetof(HWEquipmentInstance_SetIconOverrideTag, NewIconOverrideTag) == 0x000000, "Member 'HWEquipmentInstance_SetIconOverrideTag::NewIconOverrideTag' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.SetInventorySlot
// 0x000C (0x000C - 0x0000)
struct HWEquipmentInstance_SetInventorySlot final
{
public:
	struct FHWInventorySlot                       Slot;                                              // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_SetInventorySlot) == 0x000004, "Wrong alignment on HWEquipmentInstance_SetInventorySlot");
static_assert(sizeof(HWEquipmentInstance_SetInventorySlot) == 0x00000C, "Wrong size on HWEquipmentInstance_SetInventorySlot");
static_assert(offsetof(HWEquipmentInstance_SetInventorySlot, Slot) == 0x000000, "Member 'HWEquipmentInstance_SetInventorySlot::Slot' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.SetLevel
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentInstance_SetLevel final
{
public:
	int32                                         NewLevel;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_SetLevel) == 0x000004, "Wrong alignment on HWEquipmentInstance_SetLevel");
static_assert(sizeof(HWEquipmentInstance_SetLevel) == 0x000004, "Wrong size on HWEquipmentInstance_SetLevel");
static_assert(offsetof(HWEquipmentInstance_SetLevel, NewLevel) == 0x000000, "Member 'HWEquipmentInstance_SetLevel::NewLevel' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.CanEquipmentLevelUp
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentInstance_CanEquipmentLevelUp final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_CanEquipmentLevelUp) == 0x000001, "Wrong alignment on HWEquipmentInstance_CanEquipmentLevelUp");
static_assert(sizeof(HWEquipmentInstance_CanEquipmentLevelUp) == 0x000001, "Wrong size on HWEquipmentInstance_CanEquipmentLevelUp");
static_assert(offsetof(HWEquipmentInstance_CanEquipmentLevelUp, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_CanEquipmentLevelUp::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.CanSetEquipmentLevelTo
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_CanSetEquipmentLevelTo final
{
public:
	int32                                         DesiredLevel;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentInstance_CanSetEquipmentLevelTo) == 0x000004, "Wrong alignment on HWEquipmentInstance_CanSetEquipmentLevelTo");
static_assert(sizeof(HWEquipmentInstance_CanSetEquipmentLevelTo) == 0x000008, "Wrong size on HWEquipmentInstance_CanSetEquipmentLevelTo");
static_assert(offsetof(HWEquipmentInstance_CanSetEquipmentLevelTo, DesiredLevel) == 0x000000, "Member 'HWEquipmentInstance_CanSetEquipmentLevelTo::DesiredLevel' has a wrong offset!");
static_assert(offsetof(HWEquipmentInstance_CanSetEquipmentLevelTo, ReturnValue) == 0x000004, "Member 'HWEquipmentInstance_CanSetEquipmentLevelTo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetAbilityAdditionalActivationBlockTags
// 0x0020 (0x0020 - 0x0000)
struct HWEquipmentInstance_GetAbilityAdditionalActivationBlockTags final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetAbilityAdditionalActivationBlockTags) == 0x000008, "Wrong alignment on HWEquipmentInstance_GetAbilityAdditionalActivationBlockTags");
static_assert(sizeof(HWEquipmentInstance_GetAbilityAdditionalActivationBlockTags) == 0x000020, "Wrong size on HWEquipmentInstance_GetAbilityAdditionalActivationBlockTags");
static_assert(offsetof(HWEquipmentInstance_GetAbilityAdditionalActivationBlockTags, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetAbilityAdditionalActivationBlockTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetAbilityHandle
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentInstance_GetAbilityHandle final
{
public:
	struct FGameplayAbilitySpecHandle             ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetAbilityHandle) == 0x000004, "Wrong alignment on HWEquipmentInstance_GetAbilityHandle");
static_assert(sizeof(HWEquipmentInstance_GetAbilityHandle) == 0x000004, "Wrong size on HWEquipmentInstance_GetAbilityHandle");
static_assert(offsetof(HWEquipmentInstance_GetAbilityHandle, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetAbilityHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetAbilityPersistentState
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentInstance_GetAbilityPersistentState final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetAbilityPersistentState) == 0x000008, "Wrong alignment on HWEquipmentInstance_GetAbilityPersistentState");
static_assert(sizeof(HWEquipmentInstance_GetAbilityPersistentState) == 0x000010, "Wrong size on HWEquipmentInstance_GetAbilityPersistentState");
static_assert(offsetof(HWEquipmentInstance_GetAbilityPersistentState, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetAbilityPersistentState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetCurrentAbilityPhase
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentInstance_GetCurrentAbilityPhase final
{
public:
	EAbilityFlowPhase                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetCurrentAbilityPhase) == 0x000001, "Wrong alignment on HWEquipmentInstance_GetCurrentAbilityPhase");
static_assert(sizeof(HWEquipmentInstance_GetCurrentAbilityPhase) == 0x000001, "Wrong size on HWEquipmentInstance_GetCurrentAbilityPhase");
static_assert(offsetof(HWEquipmentInstance_GetCurrentAbilityPhase, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetCurrentAbilityPhase::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetEquipmentComponentByClass
// 0x0018 (0x0018 - 0x0000)
struct HWEquipmentInstance_GetEquipmentComponentByClass final
{
public:
	TSubclassOf<class UHWEquipmentComponent>      ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ID;                                                // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWEquipmentComponent*                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetEquipmentComponentByClass) == 0x000008, "Wrong alignment on HWEquipmentInstance_GetEquipmentComponentByClass");
static_assert(sizeof(HWEquipmentInstance_GetEquipmentComponentByClass) == 0x000018, "Wrong size on HWEquipmentInstance_GetEquipmentComponentByClass");
static_assert(offsetof(HWEquipmentInstance_GetEquipmentComponentByClass, ComponentClass) == 0x000000, "Member 'HWEquipmentInstance_GetEquipmentComponentByClass::ComponentClass' has a wrong offset!");
static_assert(offsetof(HWEquipmentInstance_GetEquipmentComponentByClass, ID) == 0x000008, "Member 'HWEquipmentInstance_GetEquipmentComponentByClass::ID' has a wrong offset!");
static_assert(offsetof(HWEquipmentInstance_GetEquipmentComponentByClass, ReturnValue) == 0x000010, "Member 'HWEquipmentInstance_GetEquipmentComponentByClass::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetEquipmentInfo
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_GetEquipmentInfo final
{
public:
	const class UHWEquipmentInfo*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetEquipmentInfo) == 0x000008, "Wrong alignment on HWEquipmentInstance_GetEquipmentInfo");
static_assert(sizeof(HWEquipmentInstance_GetEquipmentInfo) == 0x000008, "Wrong size on HWEquipmentInstance_GetEquipmentInfo");
static_assert(offsetof(HWEquipmentInstance_GetEquipmentInfo, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetEquipmentInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetEquipmentInputTag
// 0x000C (0x000C - 0x0000)
struct HWEquipmentInstance_GetEquipmentInputTag final
{
public:
	bool                                          bIsForDisplay;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetEquipmentInputTag) == 0x000004, "Wrong alignment on HWEquipmentInstance_GetEquipmentInputTag");
static_assert(sizeof(HWEquipmentInstance_GetEquipmentInputTag) == 0x00000C, "Wrong size on HWEquipmentInstance_GetEquipmentInputTag");
static_assert(offsetof(HWEquipmentInstance_GetEquipmentInputTag, bIsForDisplay) == 0x000000, "Member 'HWEquipmentInstance_GetEquipmentInputTag::bIsForDisplay' has a wrong offset!");
static_assert(offsetof(HWEquipmentInstance_GetEquipmentInputTag, ReturnValue) == 0x000004, "Member 'HWEquipmentInstance_GetEquipmentInputTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetEquipmentItem
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_GetEquipmentItem final
{
public:
	const class UHWEquipmentItem*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetEquipmentItem) == 0x000008, "Wrong alignment on HWEquipmentInstance_GetEquipmentItem");
static_assert(sizeof(HWEquipmentInstance_GetEquipmentItem) == 0x000008, "Wrong size on HWEquipmentInstance_GetEquipmentItem");
static_assert(offsetof(HWEquipmentInstance_GetEquipmentItem, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetEquipmentItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetEquipmentType
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_GetEquipmentType final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetEquipmentType) == 0x000004, "Wrong alignment on HWEquipmentInstance_GetEquipmentType");
static_assert(sizeof(HWEquipmentInstance_GetEquipmentType) == 0x000008, "Wrong size on HWEquipmentInstance_GetEquipmentType");
static_assert(offsetof(HWEquipmentInstance_GetEquipmentType, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetEquipmentType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetGrantedByEffect
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_GetGrantedByEffect final
{
public:
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetGrantedByEffect) == 0x000004, "Wrong alignment on HWEquipmentInstance_GetGrantedByEffect");
static_assert(sizeof(HWEquipmentInstance_GetGrantedByEffect) == 0x000008, "Wrong size on HWEquipmentInstance_GetGrantedByEffect");
static_assert(offsetof(HWEquipmentInstance_GetGrantedByEffect, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetGrantedByEffect::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetIconOverridesTag
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_GetIconOverridesTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetIconOverridesTag) == 0x000004, "Wrong alignment on HWEquipmentInstance_GetIconOverridesTag");
static_assert(sizeof(HWEquipmentInstance_GetIconOverridesTag) == 0x000008, "Wrong size on HWEquipmentInstance_GetIconOverridesTag");
static_assert(offsetof(HWEquipmentInstance_GetIconOverridesTag, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetIconOverridesTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetInventorySlot
// 0x000C (0x000C - 0x0000)
struct HWEquipmentInstance_GetInventorySlot final
{
public:
	struct FHWInventorySlot                       ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetInventorySlot) == 0x000004, "Wrong alignment on HWEquipmentInstance_GetInventorySlot");
static_assert(sizeof(HWEquipmentInstance_GetInventorySlot) == 0x00000C, "Wrong size on HWEquipmentInstance_GetInventorySlot");
static_assert(offsetof(HWEquipmentInstance_GetInventorySlot, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetInventorySlot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetLevel
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentInstance_GetLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetLevel) == 0x000004, "Wrong alignment on HWEquipmentInstance_GetLevel");
static_assert(sizeof(HWEquipmentInstance_GetLevel) == 0x000004, "Wrong size on HWEquipmentInstance_GetLevel");
static_assert(offsetof(HWEquipmentInstance_GetLevel, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetMaxLevel
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentInstance_GetMaxLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetMaxLevel) == 0x000004, "Wrong alignment on HWEquipmentInstance_GetMaxLevel");
static_assert(sizeof(HWEquipmentInstance_GetMaxLevel) == 0x000004, "Wrong size on HWEquipmentInstance_GetMaxLevel");
static_assert(offsetof(HWEquipmentInstance_GetMaxLevel, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetMaxLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetOwningAbilitySystem
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_GetOwningAbilitySystem final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetOwningAbilitySystem) == 0x000008, "Wrong alignment on HWEquipmentInstance_GetOwningAbilitySystem");
static_assert(sizeof(HWEquipmentInstance_GetOwningAbilitySystem) == 0x000008, "Wrong size on HWEquipmentInstance_GetOwningAbilitySystem");
static_assert(offsetof(HWEquipmentInstance_GetOwningAbilitySystem, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetOwningAbilitySystem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetOwningInventory
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInstance_GetOwningInventory final
{
public:
	class UHWInventoryManagerComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetOwningInventory) == 0x000008, "Wrong alignment on HWEquipmentInstance_GetOwningInventory");
static_assert(sizeof(HWEquipmentInstance_GetOwningInventory) == 0x000008, "Wrong size on HWEquipmentInstance_GetOwningInventory");
static_assert(offsetof(HWEquipmentInstance_GetOwningInventory, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_GetOwningInventory::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetSkillPointsNeededForLvl
// 0x000C (0x000C - 0x0000)
struct HWEquipmentInstance_GetSkillPointsNeededForLvl final
{
public:
	int32                                         CurrentLvl;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewLvl;                                            // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetSkillPointsNeededForLvl) == 0x000004, "Wrong alignment on HWEquipmentInstance_GetSkillPointsNeededForLvl");
static_assert(sizeof(HWEquipmentInstance_GetSkillPointsNeededForLvl) == 0x00000C, "Wrong size on HWEquipmentInstance_GetSkillPointsNeededForLvl");
static_assert(offsetof(HWEquipmentInstance_GetSkillPointsNeededForLvl, CurrentLvl) == 0x000000, "Member 'HWEquipmentInstance_GetSkillPointsNeededForLvl::CurrentLvl' has a wrong offset!");
static_assert(offsetof(HWEquipmentInstance_GetSkillPointsNeededForLvl, NewLvl) == 0x000004, "Member 'HWEquipmentInstance_GetSkillPointsNeededForLvl::NewLvl' has a wrong offset!");
static_assert(offsetof(HWEquipmentInstance_GetSkillPointsNeededForLvl, ReturnValue) == 0x000008, "Member 'HWEquipmentInstance_GetSkillPointsNeededForLvl::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.GetStatusTags
// 0x0020 (0x0020 - 0x0000)
struct HWEquipmentInstance_GetStatusTags final
{
public:
	struct FGameplayTagContainer                  OutStatusTags;                                     // 0x0000(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_GetStatusTags) == 0x000008, "Wrong alignment on HWEquipmentInstance_GetStatusTags");
static_assert(sizeof(HWEquipmentInstance_GetStatusTags) == 0x000020, "Wrong size on HWEquipmentInstance_GetStatusTags");
static_assert(offsetof(HWEquipmentInstance_GetStatusTags, OutStatusTags) == 0x000000, "Member 'HWEquipmentInstance_GetStatusTags::OutStatusTags' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.HasStatusTag
// 0x000C (0x000C - 0x0000)
struct HWEquipmentInstance_HasStatusTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExactMatch;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentInstance_HasStatusTag) == 0x000004, "Wrong alignment on HWEquipmentInstance_HasStatusTag");
static_assert(sizeof(HWEquipmentInstance_HasStatusTag) == 0x00000C, "Wrong size on HWEquipmentInstance_HasStatusTag");
static_assert(offsetof(HWEquipmentInstance_HasStatusTag, Tag) == 0x000000, "Member 'HWEquipmentInstance_HasStatusTag::Tag' has a wrong offset!");
static_assert(offsetof(HWEquipmentInstance_HasStatusTag, bExactMatch) == 0x000008, "Member 'HWEquipmentInstance_HasStatusTag::bExactMatch' has a wrong offset!");
static_assert(offsetof(HWEquipmentInstance_HasStatusTag, ReturnValue) == 0x000009, "Member 'HWEquipmentInstance_HasStatusTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.IsActivatableItem
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentInstance_IsActivatableItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_IsActivatableItem) == 0x000001, "Wrong alignment on HWEquipmentInstance_IsActivatableItem");
static_assert(sizeof(HWEquipmentInstance_IsActivatableItem) == 0x000001, "Wrong size on HWEquipmentInstance_IsActivatableItem");
static_assert(offsetof(HWEquipmentInstance_IsActivatableItem, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_IsActivatableItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.IsEquipped
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentInstance_IsEquipped final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_IsEquipped) == 0x000001, "Wrong alignment on HWEquipmentInstance_IsEquipped");
static_assert(sizeof(HWEquipmentInstance_IsEquipped) == 0x000001, "Wrong size on HWEquipmentInstance_IsEquipped");
static_assert(offsetof(HWEquipmentInstance_IsEquipped, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_IsEquipped::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.IsInInventory
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentInstance_IsInInventory final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_IsInInventory) == 0x000001, "Wrong alignment on HWEquipmentInstance_IsInInventory");
static_assert(sizeof(HWEquipmentInstance_IsInInventory) == 0x000001, "Wrong size on HWEquipmentInstance_IsInInventory");
static_assert(offsetof(HWEquipmentInstance_IsInInventory, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_IsInInventory::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.MakeEffectContext
// 0x0018 (0x0018 - 0x0000)
struct HWEquipmentInstance_MakeEffectContext final
{
public:
	struct FGameplayEffectContextHandle           ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_MakeEffectContext) == 0x000008, "Wrong alignment on HWEquipmentInstance_MakeEffectContext");
static_assert(sizeof(HWEquipmentInstance_MakeEffectContext) == 0x000018, "Wrong size on HWEquipmentInstance_MakeEffectContext");
static_assert(offsetof(HWEquipmentInstance_MakeEffectContext, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_MakeEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInstance.ShouldUseSkillPointToLevel
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentInstance_ShouldUseSkillPointToLevel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInstance_ShouldUseSkillPointToLevel) == 0x000001, "Wrong alignment on HWEquipmentInstance_ShouldUseSkillPointToLevel");
static_assert(sizeof(HWEquipmentInstance_ShouldUseSkillPointToLevel) == 0x000001, "Wrong size on HWEquipmentInstance_ShouldUseSkillPointToLevel");
static_assert(offsetof(HWEquipmentInstance_ShouldUseSkillPointToLevel, ReturnValue) == 0x000000, "Member 'HWEquipmentInstance_ShouldUseSkillPointToLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDraftAuthority.OnAllPlayersConnectedToMatch
// 0x0001 (0x0001 - 0x0000)
struct HWDraftAuthority_OnAllPlayersConnectedToMatch final
{
public:
	bool                                          bDidAllPlayersConnect;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDraftAuthority_OnAllPlayersConnectedToMatch) == 0x000001, "Wrong alignment on HWDraftAuthority_OnAllPlayersConnectedToMatch");
static_assert(sizeof(HWDraftAuthority_OnAllPlayersConnectedToMatch) == 0x000001, "Wrong size on HWDraftAuthority_OnAllPlayersConnectedToMatch");
static_assert(offsetof(HWDraftAuthority_OnAllPlayersConnectedToMatch, bDidAllPlayersConnect) == 0x000000, "Member 'HWDraftAuthority_OnAllPlayersConnectedToMatch::bDidAllPlayersConnect' has a wrong offset!");

// Function Hemingway.HWDraftAuthority.OnGamePhaseStarted
// 0x0008 (0x0008 - 0x0000)
struct HWDraftAuthority_OnGamePhaseStarted final
{
public:
	struct FGameplayTag                           NewPhase;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDraftAuthority_OnGamePhaseStarted) == 0x000004, "Wrong alignment on HWDraftAuthority_OnGamePhaseStarted");
static_assert(sizeof(HWDraftAuthority_OnGamePhaseStarted) == 0x000008, "Wrong size on HWDraftAuthority_OnGamePhaseStarted");
static_assert(offsetof(HWDraftAuthority_OnGamePhaseStarted, NewPhase) == 0x000000, "Member 'HWDraftAuthority_OnGamePhaseStarted::NewPhase' has a wrong offset!");

// Function Hemingway.HWEventManager.AddEvent
// 0x0090 (0x0090 - 0x0000)
struct HWEventManager_AddEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventContext                        EventContext;                                      // 0x0008(0x0088)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEventManager_AddEvent) == 0x000008, "Wrong alignment on HWEventManager_AddEvent");
static_assert(sizeof(HWEventManager_AddEvent) == 0x000090, "Wrong size on HWEventManager_AddEvent");
static_assert(offsetof(HWEventManager_AddEvent, EventTag) == 0x000000, "Member 'HWEventManager_AddEvent::EventTag' has a wrong offset!");
static_assert(offsetof(HWEventManager_AddEvent, EventContext) == 0x000008, "Member 'HWEventManager_AddEvent::EventContext' has a wrong offset!");

// Function Hemingway.HWEventManager.IsQueueEmpty
// 0x0001 (0x0001 - 0x0000)
struct HWEventManager_IsQueueEmpty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEventManager_IsQueueEmpty) == 0x000001, "Wrong alignment on HWEventManager_IsQueueEmpty");
static_assert(sizeof(HWEventManager_IsQueueEmpty) == 0x000001, "Wrong size on HWEventManager_IsQueueEmpty");
static_assert(offsetof(HWEventManager_IsQueueEmpty, ReturnValue) == 0x000000, "Member 'HWEventManager_IsQueueEmpty::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings_Linear.GetManualCollisionRadius
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAimSettings_Linear_GetManualCollisionRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_Linear_GetManualCollisionRadius) == 0x000004, "Wrong alignment on HWAbilityAimSettings_Linear_GetManualCollisionRadius");
static_assert(sizeof(HWAbilityAimSettings_Linear_GetManualCollisionRadius) == 0x000004, "Wrong size on HWAbilityAimSettings_Linear_GetManualCollisionRadius");
static_assert(offsetof(HWAbilityAimSettings_Linear_GetManualCollisionRadius, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_Linear_GetManualCollisionRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings_Linear.GetMaxRange
// 0x0090 (0x0090 - 0x0000)
struct HWAbilityAimSettings_Linear_GetMaxRange final
{
public:
	struct FHWAimTargetingInfo                    AimTargetingInfo;                                  // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0080(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityAimSettings_Linear_GetMaxRange) == 0x000010, "Wrong alignment on HWAbilityAimSettings_Linear_GetMaxRange");
static_assert(sizeof(HWAbilityAimSettings_Linear_GetMaxRange) == 0x000090, "Wrong size on HWAbilityAimSettings_Linear_GetMaxRange");
static_assert(offsetof(HWAbilityAimSettings_Linear_GetMaxRange, AimTargetingInfo) == 0x000000, "Member 'HWAbilityAimSettings_Linear_GetMaxRange::AimTargetingInfo' has a wrong offset!");
static_assert(offsetof(HWAbilityAimSettings_Linear_GetMaxRange, ReturnValue) == 0x000080, "Member 'HWAbilityAimSettings_Linear_GetMaxRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings_Linear.GetWorldCollisionRadius
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAimSettings_Linear_GetWorldCollisionRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_Linear_GetWorldCollisionRadius) == 0x000004, "Wrong alignment on HWAbilityAimSettings_Linear_GetWorldCollisionRadius");
static_assert(sizeof(HWAbilityAimSettings_Linear_GetWorldCollisionRadius) == 0x000004, "Wrong size on HWAbilityAimSettings_Linear_GetWorldCollisionRadius");
static_assert(offsetof(HWAbilityAimSettings_Linear_GetWorldCollisionRadius, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_Linear_GetWorldCollisionRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_Refireable.GetInputTagOverride
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponentSettings_Refireable_GetInputTagOverride final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_Refireable_GetInputTagOverride) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_Refireable_GetInputTagOverride");
static_assert(sizeof(HWEquipmentComponentSettings_Refireable_GetInputTagOverride) == 0x000008, "Wrong size on HWEquipmentComponentSettings_Refireable_GetInputTagOverride");
static_assert(offsetof(HWEquipmentComponentSettings_Refireable_GetInputTagOverride, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_Refireable_GetInputTagOverride::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_Refireable.GetRefireAbility
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponentSettings_Refireable_GetRefireAbility final
{
public:
	TSubclassOf<class UGameplayAbility>           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_Refireable_GetRefireAbility) == 0x000008, "Wrong alignment on HWEquipmentComponentSettings_Refireable_GetRefireAbility");
static_assert(sizeof(HWEquipmentComponentSettings_Refireable_GetRefireAbility) == 0x000008, "Wrong size on HWEquipmentComponentSettings_Refireable_GetRefireAbility");
static_assert(offsetof(HWEquipmentComponentSettings_Refireable_GetRefireAbility, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_Refireable_GetRefireAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_Refireable.GetRefireBehavior
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponentSettings_Refireable_GetRefireBehavior final
{
public:
	ERefireAbilityBehavior                        ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_Refireable_GetRefireBehavior) == 0x000004, "Wrong alignment on HWEquipmentComponentSettings_Refireable_GetRefireBehavior");
static_assert(sizeof(HWEquipmentComponentSettings_Refireable_GetRefireBehavior) == 0x000004, "Wrong size on HWEquipmentComponentSettings_Refireable_GetRefireBehavior");
static_assert(offsetof(HWEquipmentComponentSettings_Refireable_GetRefireBehavior, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_Refireable_GetRefireBehavior::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_Refireable.ShouldAllowMultipleRefires
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponentSettings_Refireable_ShouldAllowMultipleRefires final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_Refireable_ShouldAllowMultipleRefires) == 0x000001, "Wrong alignment on HWEquipmentComponentSettings_Refireable_ShouldAllowMultipleRefires");
static_assert(sizeof(HWEquipmentComponentSettings_Refireable_ShouldAllowMultipleRefires) == 0x000001, "Wrong size on HWEquipmentComponentSettings_Refireable_ShouldAllowMultipleRefires");
static_assert(offsetof(HWEquipmentComponentSettings_Refireable_ShouldAllowMultipleRefires, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_Refireable_ShouldAllowMultipleRefires::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_Refireable.ShouldCancelRefireAbilityImmeditatelyOnRefireWindowEnd
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponentSettings_Refireable_ShouldCancelRefireAbilityImmeditatelyOnRefireWindowEnd final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_Refireable_ShouldCancelRefireAbilityImmeditatelyOnRefireWindowEnd) == 0x000001, "Wrong alignment on HWEquipmentComponentSettings_Refireable_ShouldCancelRefireAbilityImmeditatelyOnRefireWindowEnd");
static_assert(sizeof(HWEquipmentComponentSettings_Refireable_ShouldCancelRefireAbilityImmeditatelyOnRefireWindowEnd) == 0x000001, "Wrong size on HWEquipmentComponentSettings_Refireable_ShouldCancelRefireAbilityImmeditatelyOnRefireWindowEnd");
static_assert(offsetof(HWEquipmentComponentSettings_Refireable_ShouldCancelRefireAbilityImmeditatelyOnRefireWindowEnd, ReturnValue) == 0x000000, "Member 'HWEquipmentComponentSettings_Refireable_ShouldCancelRefireAbilityImmeditatelyOnRefireWindowEnd::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponentSettings_Refireable.ShouldRefireOnTrigger
// 0x0002 (0x0002 - 0x0000)
struct HWEquipmentComponentSettings_Refireable_ShouldRefireOnTrigger final
{
public:
	EHWRefireTrigger                              RefireTrigger;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponentSettings_Refireable_ShouldRefireOnTrigger) == 0x000001, "Wrong alignment on HWEquipmentComponentSettings_Refireable_ShouldRefireOnTrigger");
static_assert(sizeof(HWEquipmentComponentSettings_Refireable_ShouldRefireOnTrigger) == 0x000002, "Wrong size on HWEquipmentComponentSettings_Refireable_ShouldRefireOnTrigger");
static_assert(offsetof(HWEquipmentComponentSettings_Refireable_ShouldRefireOnTrigger, RefireTrigger) == 0x000000, "Member 'HWEquipmentComponentSettings_Refireable_ShouldRefireOnTrigger::RefireTrigger' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponentSettings_Refireable_ShouldRefireOnTrigger, ReturnValue) == 0x000001, "Member 'HWEquipmentComponentSettings_Refireable_ShouldRefireOnTrigger::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Neith_Weave.ActivateLocalTargetingVFX
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Neith_Weave_ActivateLocalTargetingVFX final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Neith_Weave_ActivateLocalTargetingVFX) == 0x000001, "Wrong alignment on HWDeployable_Neith_Weave_ActivateLocalTargetingVFX");
static_assert(sizeof(HWDeployable_Neith_Weave_ActivateLocalTargetingVFX) == 0x000001, "Wrong size on HWDeployable_Neith_Weave_ActivateLocalTargetingVFX");
static_assert(offsetof(HWDeployable_Neith_Weave_ActivateLocalTargetingVFX, bEnable) == 0x000000, "Member 'HWDeployable_Neith_Weave_ActivateLocalTargetingVFX::bEnable' has a wrong offset!");

// Function Hemingway.HWEventStompAssessorBase.ShouldStomp
// 0x01A8 (0x01A8 - 0x0000)
struct HWEventStompAssessorBase_ShouldStomp final
{
public:
	struct FHWEventConfig                         Event1Config;                                      // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWEventContext                        Event1Context;                                     // 0x0048(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWEventConfig                         Event2Config;                                      // 0x00D0(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWEventContext                        Event2Context;                                     // 0x0118(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEventStompAssessorBase_ShouldStomp) == 0x000008, "Wrong alignment on HWEventStompAssessorBase_ShouldStomp");
static_assert(sizeof(HWEventStompAssessorBase_ShouldStomp) == 0x0001A8, "Wrong size on HWEventStompAssessorBase_ShouldStomp");
static_assert(offsetof(HWEventStompAssessorBase_ShouldStomp, Event1Config) == 0x000000, "Member 'HWEventStompAssessorBase_ShouldStomp::Event1Config' has a wrong offset!");
static_assert(offsetof(HWEventStompAssessorBase_ShouldStomp, Event1Context) == 0x000048, "Member 'HWEventStompAssessorBase_ShouldStomp::Event1Context' has a wrong offset!");
static_assert(offsetof(HWEventStompAssessorBase_ShouldStomp, Event2Config) == 0x0000D0, "Member 'HWEventStompAssessorBase_ShouldStomp::Event2Config' has a wrong offset!");
static_assert(offsetof(HWEventStompAssessorBase_ShouldStomp, Event2Context) == 0x000118, "Member 'HWEventStompAssessorBase_ShouldStomp::Event2Context' has a wrong offset!");
static_assert(offsetof(HWEventStompAssessorBase_ShouldStomp, ReturnValue) == 0x0001A0, "Member 'HWEventStompAssessorBase_ShouldStomp::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Mordred_B04.SetDashHitGod
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_Mordred_B04_SetDashHitGod final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Mordred_B04_SetDashHitGod) == 0x000001, "Wrong alignment on HWGameplayAbility_Mordred_B04_SetDashHitGod");
static_assert(sizeof(HWGameplayAbility_Mordred_B04_SetDashHitGod) == 0x000001, "Wrong size on HWGameplayAbility_Mordred_B04_SetDashHitGod");
static_assert(offsetof(HWGameplayAbility_Mordred_B04_SetDashHitGod, bValue) == 0x000000, "Member 'HWGameplayAbility_Mordred_B04_SetDashHitGod::bValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_Stealth.EndStealthOnAbilityStartFire
// 0x0030 (0x0030 - 0x0000)
struct HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  InAbilityTags;                                     // 0x0008(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0028(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire) == 0x000008, "Wrong alignment on HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire");
static_assert(sizeof(HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire) == 0x000030, "Wrong size on HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire");
static_assert(offsetof(HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire, AbilityHandle) == 0x000000, "Member 'HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire, InAbilityTags) == 0x000008, "Member 'HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire::InAbilityTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire, FiringInstanceId) == 0x000028, "Member 'HWGameplayAbility_Stealth_EndStealthOnAbilityStartFire::FiringInstanceId' has a wrong offset!");

// Function Hemingway.HWGameplayDash.CalcDashRotation
// 0x0038 (0x0038 - 0x0000)
struct HWGameplayDash_CalcDashRotation final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_CalcDashRotation) == 0x000008, "Wrong alignment on HWGameplayDash_CalcDashRotation");
static_assert(sizeof(HWGameplayDash_CalcDashRotation) == 0x000038, "Wrong size on HWGameplayDash_CalcDashRotation");
static_assert(offsetof(HWGameplayDash_CalcDashRotation, DeltaTime) == 0x000000, "Member 'HWGameplayDash_CalcDashRotation::DeltaTime' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_CalcDashRotation, Velocity) == 0x000008, "Member 'HWGameplayDash_CalcDashRotation::Velocity' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_CalcDashRotation, ReturnValue) == 0x000020, "Member 'HWGameplayDash_CalcDashRotation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.CalcDashVelocity
// 0x0020 (0x0020 - 0x0000)
struct HWGameplayDash_CalcDashVelocity final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_CalcDashVelocity) == 0x000008, "Wrong alignment on HWGameplayDash_CalcDashVelocity");
static_assert(sizeof(HWGameplayDash_CalcDashVelocity) == 0x000020, "Wrong size on HWGameplayDash_CalcDashVelocity");
static_assert(offsetof(HWGameplayDash_CalcDashVelocity, DeltaTime) == 0x000000, "Member 'HWGameplayDash_CalcDashVelocity::DeltaTime' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_CalcDashVelocity, ReturnValue) == 0x000008, "Member 'HWGameplayDash_CalcDashVelocity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.CanBeInterruptedByKnockback
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_CanBeInterruptedByKnockback final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_CanBeInterruptedByKnockback) == 0x000001, "Wrong alignment on HWGameplayDash_CanBeInterruptedByKnockback");
static_assert(sizeof(HWGameplayDash_CanBeInterruptedByKnockback) == 0x000001, "Wrong size on HWGameplayDash_CanBeInterruptedByKnockback");
static_assert(offsetof(HWGameplayDash_CanBeInterruptedByKnockback, ReturnValue) == 0x000000, "Member 'HWGameplayDash_CanBeInterruptedByKnockback::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.CollectDashHits
// 0x0030 (0x0030 - 0x0000)
struct HWGameplayDash_CollectDashHits final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_CollectDashHits) == 0x000008, "Wrong alignment on HWGameplayDash_CollectDashHits");
static_assert(sizeof(HWGameplayDash_CollectDashHits) == 0x000030, "Wrong size on HWGameplayDash_CollectDashHits");
static_assert(offsetof(HWGameplayDash_CollectDashHits, Start) == 0x000000, "Member 'HWGameplayDash_CollectDashHits::Start' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_CollectDashHits, End) == 0x000018, "Member 'HWGameplayDash_CollectDashHits::End' has a wrong offset!");

// Function Hemingway.HWGameplayDash.EndDash
// 0x0002 (0x0002 - 0x0000)
struct HWGameplayDash_EndDash final
{
public:
	bool                                          bIsInterrupting;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldStartNextQueuedDash;                        // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_EndDash) == 0x000001, "Wrong alignment on HWGameplayDash_EndDash");
static_assert(sizeof(HWGameplayDash_EndDash) == 0x000002, "Wrong size on HWGameplayDash_EndDash");
static_assert(offsetof(HWGameplayDash_EndDash, bIsInterrupting) == 0x000000, "Member 'HWGameplayDash_EndDash::bIsInterrupting' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_EndDash, bShouldStartNextQueuedDash) == 0x000001, "Member 'HWGameplayDash_EndDash::bShouldStartNextQueuedDash' has a wrong offset!");

// Function Hemingway.HWGameplayDash.ExtendDash
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayDash_ExtendDash final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_ExtendDash) == 0x000004, "Wrong alignment on HWGameplayDash_ExtendDash");
static_assert(sizeof(HWGameplayDash_ExtendDash) == 0x000004, "Wrong size on HWGameplayDash_ExtendDash");
static_assert(offsetof(HWGameplayDash_ExtendDash, Distance) == 0x000000, "Member 'HWGameplayDash_ExtendDash::Distance' has a wrong offset!");

// Function Hemingway.HWGameplayDash.GetDashEndClampedSpeed
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayDash_GetDashEndClampedSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_GetDashEndClampedSpeed) == 0x000004, "Wrong alignment on HWGameplayDash_GetDashEndClampedSpeed");
static_assert(sizeof(HWGameplayDash_GetDashEndClampedSpeed) == 0x000004, "Wrong size on HWGameplayDash_GetDashEndClampedSpeed");
static_assert(offsetof(HWGameplayDash_GetDashEndClampedSpeed, ReturnValue) == 0x000000, "Member 'HWGameplayDash_GetDashEndClampedSpeed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.OnCharacterMovementUpdated
// 0x0038 (0x0038 - 0x0000)
struct HWGameplayDash_OnCharacterMovementUpdated final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OldLocation;                                       // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OldVelocity;                                       // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_OnCharacterMovementUpdated) == 0x000008, "Wrong alignment on HWGameplayDash_OnCharacterMovementUpdated");
static_assert(sizeof(HWGameplayDash_OnCharacterMovementUpdated) == 0x000038, "Wrong size on HWGameplayDash_OnCharacterMovementUpdated");
static_assert(offsetof(HWGameplayDash_OnCharacterMovementUpdated, DeltaSeconds) == 0x000000, "Member 'HWGameplayDash_OnCharacterMovementUpdated::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_OnCharacterMovementUpdated, OldLocation) == 0x000008, "Member 'HWGameplayDash_OnCharacterMovementUpdated::OldLocation' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_OnCharacterMovementUpdated, OldVelocity) == 0x000020, "Member 'HWGameplayDash_OnCharacterMovementUpdated::OldVelocity' has a wrong offset!");

// Function Hemingway.HWGameplayDash.OnDashBeginOverlap
// 0x00D0 (0x00D0 - 0x0000)
struct HWGameplayDash_OnDashBeginOverlap final
{
public:
	class UHWAbilityTask_FireAttack*              AttackTask;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityAttackInstance               AttackInstance;                                    // 0x0008(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0088(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  HitTags;                                           // 0x00B0(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_OnDashBeginOverlap) == 0x000008, "Wrong alignment on HWGameplayDash_OnDashBeginOverlap");
static_assert(sizeof(HWGameplayDash_OnDashBeginOverlap) == 0x0000D0, "Wrong size on HWGameplayDash_OnDashBeginOverlap");
static_assert(offsetof(HWGameplayDash_OnDashBeginOverlap, AttackTask) == 0x000000, "Member 'HWGameplayDash_OnDashBeginOverlap::AttackTask' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_OnDashBeginOverlap, AttackInstance) == 0x000008, "Member 'HWGameplayDash_OnDashBeginOverlap::AttackInstance' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_OnDashBeginOverlap, TargetData) == 0x000088, "Member 'HWGameplayDash_OnDashBeginOverlap::TargetData' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_OnDashBeginOverlap, HitTags) == 0x0000B0, "Member 'HWGameplayDash_OnDashBeginOverlap::HitTags' has a wrong offset!");

// Function Hemingway.HWGameplayDash.OnDashCharacterHit
// 0x0110 (0x0110 - 0x0000)
struct HWGameplayDash_OnDashCharacterHit final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0028(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_OnDashCharacterHit) == 0x000008, "Wrong alignment on HWGameplayDash_OnDashCharacterHit");
static_assert(sizeof(HWGameplayDash_OnDashCharacterHit) == 0x000110, "Wrong size on HWGameplayDash_OnDashCharacterHit");
static_assert(offsetof(HWGameplayDash_OnDashCharacterHit, SelfActor) == 0x000000, "Member 'HWGameplayDash_OnDashCharacterHit::SelfActor' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_OnDashCharacterHit, OtherActor) == 0x000008, "Member 'HWGameplayDash_OnDashCharacterHit::OtherActor' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_OnDashCharacterHit, NormalImpulse) == 0x000010, "Member 'HWGameplayDash_OnDashCharacterHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_OnDashCharacterHit, Hit) == 0x000028, "Member 'HWGameplayDash_OnDashCharacterHit::Hit' has a wrong offset!");

// Function Hemingway.HWGameplayDash.OnDashEnded
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_OnDashEnded final
{
public:
	bool                                          bWasInterrupted;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_OnDashEnded) == 0x000001, "Wrong alignment on HWGameplayDash_OnDashEnded");
static_assert(sizeof(HWGameplayDash_OnDashEnded) == 0x000001, "Wrong size on HWGameplayDash_OnDashEnded");
static_assert(offsetof(HWGameplayDash_OnDashEnded, bWasInterrupted) == 0x000000, "Member 'HWGameplayDash_OnDashEnded::bWasInterrupted' has a wrong offset!");

// Function Hemingway.HWGameplayDash.OnDashEndOverlap
// 0x0050 (0x0050 - 0x0000)
struct HWGameplayDash_OnDashEndOverlap final
{
public:
	class UHWAbilityTask_FireAttack*              AttackTask;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  HitTags;                                           // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0028(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_OnDashEndOverlap) == 0x000008, "Wrong alignment on HWGameplayDash_OnDashEndOverlap");
static_assert(sizeof(HWGameplayDash_OnDashEndOverlap) == 0x000050, "Wrong size on HWGameplayDash_OnDashEndOverlap");
static_assert(offsetof(HWGameplayDash_OnDashEndOverlap, AttackTask) == 0x000000, "Member 'HWGameplayDash_OnDashEndOverlap::AttackTask' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_OnDashEndOverlap, HitTags) == 0x000008, "Member 'HWGameplayDash_OnDashEndOverlap::HitTags' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_OnDashEndOverlap, TargetData) == 0x000028, "Member 'HWGameplayDash_OnDashEndOverlap::TargetData' has a wrong offset!");

// Function Hemingway.HWGameplayDash.ShouldClampSpeedOnDashEnd
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_ShouldClampSpeedOnDashEnd final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_ShouldClampSpeedOnDashEnd) == 0x000001, "Wrong alignment on HWGameplayDash_ShouldClampSpeedOnDashEnd");
static_assert(sizeof(HWGameplayDash_ShouldClampSpeedOnDashEnd) == 0x000001, "Wrong size on HWGameplayDash_ShouldClampSpeedOnDashEnd");
static_assert(offsetof(HWGameplayDash_ShouldClampSpeedOnDashEnd, ReturnValue) == 0x000000, "Member 'HWGameplayDash_ShouldClampSpeedOnDashEnd::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.StartDash
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayDash_StartDash final
{
public:
	struct FRotator                               DashRotation;                                      // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_StartDash) == 0x000008, "Wrong alignment on HWGameplayDash_StartDash");
static_assert(sizeof(HWGameplayDash_StartDash) == 0x000018, "Wrong size on HWGameplayDash_StartDash");
static_assert(offsetof(HWGameplayDash_StartDash, DashRotation) == 0x000000, "Member 'HWGameplayDash_StartDash::DashRotation' has a wrong offset!");

// Function Hemingway.HWGameplayDash.UpdateMeshCollisionBounds
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayDash_UpdateMeshCollisionBounds final
{
public:
	const class UHWAbilityAttackSettings_Dash*    DashAttackSettings;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_UpdateMeshCollisionBounds) == 0x000008, "Wrong alignment on HWGameplayDash_UpdateMeshCollisionBounds");
static_assert(sizeof(HWGameplayDash_UpdateMeshCollisionBounds) == 0x000008, "Wrong size on HWGameplayDash_UpdateMeshCollisionBounds");
static_assert(offsetof(HWGameplayDash_UpdateMeshCollisionBounds, DashAttackSettings) == 0x000000, "Member 'HWGameplayDash_UpdateMeshCollisionBounds::DashAttackSettings' has a wrong offset!");

// Function Hemingway.HWGameplayDash.CalcDashEndLocation
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayDash_CalcDashEndLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_CalcDashEndLocation) == 0x000008, "Wrong alignment on HWGameplayDash_CalcDashEndLocation");
static_assert(sizeof(HWGameplayDash_CalcDashEndLocation) == 0x000018, "Wrong size on HWGameplayDash_CalcDashEndLocation");
static_assert(offsetof(HWGameplayDash_CalcDashEndLocation, ReturnValue) == 0x000000, "Member 'HWGameplayDash_CalcDashEndLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.CalcDashSpeed
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayDash_CalcDashSpeed final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_CalcDashSpeed) == 0x000004, "Wrong alignment on HWGameplayDash_CalcDashSpeed");
static_assert(sizeof(HWGameplayDash_CalcDashSpeed) == 0x000008, "Wrong size on HWGameplayDash_CalcDashSpeed");
static_assert(offsetof(HWGameplayDash_CalcDashSpeed, DeltaTime) == 0x000000, "Member 'HWGameplayDash_CalcDashSpeed::DeltaTime' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_CalcDashSpeed, ReturnValue) == 0x000004, "Member 'HWGameplayDash_CalcDashSpeed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.CalcHighlightingTargetList
// 0x0080 (0x0080 - 0x0000)
struct HWGameplayDash_CalcHighlightingTargetList final
{
public:
	struct FHWAttackTargetingInfo                 TargetingInfo;                                     // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetListDataHandle;                              // 0x0048(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings_Dash*    DashAttackSettings;                                // 0x0070(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings*         EndOfDashAttackSetting;                            // 0x0078(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_CalcHighlightingTargetList) == 0x000008, "Wrong alignment on HWGameplayDash_CalcHighlightingTargetList");
static_assert(sizeof(HWGameplayDash_CalcHighlightingTargetList) == 0x000080, "Wrong size on HWGameplayDash_CalcHighlightingTargetList");
static_assert(offsetof(HWGameplayDash_CalcHighlightingTargetList, TargetingInfo) == 0x000000, "Member 'HWGameplayDash_CalcHighlightingTargetList::TargetingInfo' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_CalcHighlightingTargetList, TargetListDataHandle) == 0x000048, "Member 'HWGameplayDash_CalcHighlightingTargetList::TargetListDataHandle' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_CalcHighlightingTargetList, DashAttackSettings) == 0x000070, "Member 'HWGameplayDash_CalcHighlightingTargetList::DashAttackSettings' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_CalcHighlightingTargetList, EndOfDashAttackSetting) == 0x000078, "Member 'HWGameplayDash_CalcHighlightingTargetList::EndOfDashAttackSetting' has a wrong offset!");

// Function Hemingway.HWGameplayDash.CalcInitialDashVelocity
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayDash_CalcInitialDashVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_CalcInitialDashVelocity) == 0x000008, "Wrong alignment on HWGameplayDash_CalcInitialDashVelocity");
static_assert(sizeof(HWGameplayDash_CalcInitialDashVelocity) == 0x000018, "Wrong size on HWGameplayDash_CalcInitialDashVelocity");
static_assert(offsetof(HWGameplayDash_CalcInitialDashVelocity, ReturnValue) == 0x000000, "Member 'HWGameplayDash_CalcInitialDashVelocity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.GetCharacterStartingRotation
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayDash_GetCharacterStartingRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_GetCharacterStartingRotation) == 0x000008, "Wrong alignment on HWGameplayDash_GetCharacterStartingRotation");
static_assert(sizeof(HWGameplayDash_GetCharacterStartingRotation) == 0x000018, "Wrong size on HWGameplayDash_GetCharacterStartingRotation");
static_assert(offsetof(HWGameplayDash_GetCharacterStartingRotation, ReturnValue) == 0x000000, "Member 'HWGameplayDash_GetCharacterStartingRotation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.GetDashBehaviorOnInterrupted
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_GetDashBehaviorOnInterrupted final
{
public:
	EHWEndDashBehavior                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_GetDashBehaviorOnInterrupted) == 0x000001, "Wrong alignment on HWGameplayDash_GetDashBehaviorOnInterrupted");
static_assert(sizeof(HWGameplayDash_GetDashBehaviorOnInterrupted) == 0x000001, "Wrong size on HWGameplayDash_GetDashBehaviorOnInterrupted");
static_assert(offsetof(HWGameplayDash_GetDashBehaviorOnInterrupted, ReturnValue) == 0x000000, "Member 'HWGameplayDash_GetDashBehaviorOnInterrupted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.GetDashDistance
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayDash_GetDashDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_GetDashDistance) == 0x000004, "Wrong alignment on HWGameplayDash_GetDashDistance");
static_assert(sizeof(HWGameplayDash_GetDashDistance) == 0x000004, "Wrong size on HWGameplayDash_GetDashDistance");
static_assert(offsetof(HWGameplayDash_GetDashDistance, ReturnValue) == 0x000000, "Member 'HWGameplayDash_GetDashDistance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.GetDashDuration
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayDash_GetDashDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_GetDashDuration) == 0x000004, "Wrong alignment on HWGameplayDash_GetDashDuration");
static_assert(sizeof(HWGameplayDash_GetDashDuration) == 0x000004, "Wrong size on HWGameplayDash_GetDashDuration");
static_assert(offsetof(HWGameplayDash_GetDashDuration, ReturnValue) == 0x000000, "Member 'HWGameplayDash_GetDashDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.GetDashId
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayDash_GetDashId final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_GetDashId) == 0x000004, "Wrong alignment on HWGameplayDash_GetDashId");
static_assert(sizeof(HWGameplayDash_GetDashId) == 0x000008, "Wrong size on HWGameplayDash_GetDashId");
static_assert(offsetof(HWGameplayDash_GetDashId, ReturnValue) == 0x000000, "Member 'HWGameplayDash_GetDashId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.GetDashingCharacter
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayDash_GetDashingCharacter final
{
public:
	class ACharacter*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_GetDashingCharacter) == 0x000008, "Wrong alignment on HWGameplayDash_GetDashingCharacter");
static_assert(sizeof(HWGameplayDash_GetDashingCharacter) == 0x000008, "Wrong size on HWGameplayDash_GetDashingCharacter");
static_assert(offsetof(HWGameplayDash_GetDashingCharacter, ReturnValue) == 0x000000, "Member 'HWGameplayDash_GetDashingCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.GetDashTurnSpeed
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayDash_GetDashTurnSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_GetDashTurnSpeed) == 0x000004, "Wrong alignment on HWGameplayDash_GetDashTurnSpeed");
static_assert(sizeof(HWGameplayDash_GetDashTurnSpeed) == 0x000004, "Wrong size on HWGameplayDash_GetDashTurnSpeed");
static_assert(offsetof(HWGameplayDash_GetDashTurnSpeed, ReturnValue) == 0x000000, "Member 'HWGameplayDash_GetDashTurnSpeed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.IsActive
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_IsActive) == 0x000001, "Wrong alignment on HWGameplayDash_IsActive");
static_assert(sizeof(HWGameplayDash_IsActive) == 0x000001, "Wrong size on HWGameplayDash_IsActive");
static_assert(offsetof(HWGameplayDash_IsActive, ReturnValue) == 0x000000, "Member 'HWGameplayDash_IsActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.IsAffectedByGravity
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_IsAffectedByGravity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_IsAffectedByGravity) == 0x000001, "Wrong alignment on HWGameplayDash_IsAffectedByGravity");
static_assert(sizeof(HWGameplayDash_IsAffectedByGravity) == 0x000001, "Wrong size on HWGameplayDash_IsAffectedByGravity");
static_assert(offsetof(HWGameplayDash_IsAffectedByGravity, ReturnValue) == 0x000000, "Member 'HWGameplayDash_IsAffectedByGravity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.IsSameDash
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayDash_IsSameDash final
{
public:
	class UHWGameplayDash*                        ComparisonDash;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayDash_IsSameDash) == 0x000008, "Wrong alignment on HWGameplayDash_IsSameDash");
static_assert(sizeof(HWGameplayDash_IsSameDash) == 0x000010, "Wrong size on HWGameplayDash_IsSameDash");
static_assert(offsetof(HWGameplayDash_IsSameDash, ComparisonDash) == 0x000000, "Member 'HWGameplayDash_IsSameDash::ComparisonDash' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_IsSameDash, ReturnValue) == 0x000008, "Member 'HWGameplayDash_IsSameDash::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.IsSteerable
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_IsSteerable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_IsSteerable) == 0x000001, "Wrong alignment on HWGameplayDash_IsSteerable");
static_assert(sizeof(HWGameplayDash_IsSteerable) == 0x000001, "Wrong size on HWGameplayDash_IsSteerable");
static_assert(offsetof(HWGameplayDash_IsSteerable, ReturnValue) == 0x000000, "Member 'HWGameplayDash_IsSteerable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.IsValidDashHit
// 0x0100 (0x0100 - 0x0000)
struct HWGameplayDash_IsValidDashHit final
{
public:
	const class AActor*                           HitActor;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x00E8)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	const class AActor*                           DashingActor;                                      // 0x00F0(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayDash_IsValidDashHit) == 0x000008, "Wrong alignment on HWGameplayDash_IsValidDashHit");
static_assert(sizeof(HWGameplayDash_IsValidDashHit) == 0x000100, "Wrong size on HWGameplayDash_IsValidDashHit");
static_assert(offsetof(HWGameplayDash_IsValidDashHit, HitActor) == 0x000000, "Member 'HWGameplayDash_IsValidDashHit::HitActor' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_IsValidDashHit, Hit) == 0x000008, "Member 'HWGameplayDash_IsValidDashHit::Hit' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_IsValidDashHit, DashingActor) == 0x0000F0, "Member 'HWGameplayDash_IsValidDashHit::DashingActor' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_IsValidDashHit, ReturnValue) == 0x0000F8, "Member 'HWGameplayDash_IsValidDashHit::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.IsVerticalMovementAllowed
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_IsVerticalMovementAllowed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_IsVerticalMovementAllowed) == 0x000001, "Wrong alignment on HWGameplayDash_IsVerticalMovementAllowed");
static_assert(sizeof(HWGameplayDash_IsVerticalMovementAllowed) == 0x000001, "Wrong size on HWGameplayDash_IsVerticalMovementAllowed");
static_assert(offsetof(HWGameplayDash_IsVerticalMovementAllowed, ReturnValue) == 0x000000, "Member 'HWGameplayDash_IsVerticalMovementAllowed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.PredictsCollisions
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_PredictsCollisions final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_PredictsCollisions) == 0x000001, "Wrong alignment on HWGameplayDash_PredictsCollisions");
static_assert(sizeof(HWGameplayDash_PredictsCollisions) == 0x000001, "Wrong size on HWGameplayDash_PredictsCollisions");
static_assert(offsetof(HWGameplayDash_PredictsCollisions, ReturnValue) == 0x000000, "Member 'HWGameplayDash_PredictsCollisions::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.ShouldCollectDashHits
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_ShouldCollectDashHits final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_ShouldCollectDashHits) == 0x000001, "Wrong alignment on HWGameplayDash_ShouldCollectDashHits");
static_assert(sizeof(HWGameplayDash_ShouldCollectDashHits) == 0x000001, "Wrong size on HWGameplayDash_ShouldCollectDashHits");
static_assert(offsetof(HWGameplayDash_ShouldCollectDashHits, ReturnValue) == 0x000000, "Member 'HWGameplayDash_ShouldCollectDashHits::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.ShouldCollisionEndDash
// 0x0100 (0x0100 - 0x0000)
struct HWGameplayDash_ShouldCollisionEndDash final
{
public:
	const class AActor*                           Target;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             DashHit;                                           // 0x0008(0x00E8)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActorOverride;                               // 0x00F0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayDash_ShouldCollisionEndDash) == 0x000008, "Wrong alignment on HWGameplayDash_ShouldCollisionEndDash");
static_assert(sizeof(HWGameplayDash_ShouldCollisionEndDash) == 0x000100, "Wrong size on HWGameplayDash_ShouldCollisionEndDash");
static_assert(offsetof(HWGameplayDash_ShouldCollisionEndDash, Target) == 0x000000, "Member 'HWGameplayDash_ShouldCollisionEndDash::Target' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_ShouldCollisionEndDash, DashHit) == 0x000008, "Member 'HWGameplayDash_ShouldCollisionEndDash::DashHit' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_ShouldCollisionEndDash, SourceActorOverride) == 0x0000F0, "Member 'HWGameplayDash_ShouldCollisionEndDash::SourceActorOverride' has a wrong offset!");
static_assert(offsetof(HWGameplayDash_ShouldCollisionEndDash, ReturnValue) == 0x0000F8, "Member 'HWGameplayDash_ShouldCollisionEndDash::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayDash.ShouldEndDash
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayDash_ShouldEndDash final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayDash_ShouldEndDash) == 0x000001, "Wrong alignment on HWGameplayDash_ShouldEndDash");
static_assert(sizeof(HWGameplayDash_ShouldEndDash) == 0x000001, "Wrong size on HWGameplayDash_ShouldEndDash");
static_assert(offsetof(HWGameplayDash_ShouldEndDash, ReturnValue) == 0x000000, "Member 'HWGameplayDash_ShouldEndDash::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_ShieldModifier.GetShieldEffectTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayEffect_ShieldModifier_GetShieldEffectTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_ShieldModifier_GetShieldEffectTag) == 0x000004, "Wrong alignment on HWGameplayEffect_ShieldModifier_GetShieldEffectTag");
static_assert(sizeof(HWGameplayEffect_ShieldModifier_GetShieldEffectTag) == 0x000008, "Wrong size on HWGameplayEffect_ShieldModifier_GetShieldEffectTag");
static_assert(offsetof(HWGameplayEffect_ShieldModifier_GetShieldEffectTag, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_ShieldModifier_GetShieldEffectTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffectComponent_RemoveOnDamaged.OnTargetDamaged
// 0x0070 (0x0070 - 0x0000)
struct HWGameplayEffectComponent_RemoveOnDamaged_OnTargetDamaged final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffectComponent_RemoveOnDamaged_OnTargetDamaged) == 0x000008, "Wrong alignment on HWGameplayEffectComponent_RemoveOnDamaged_OnTargetDamaged");
static_assert(sizeof(HWGameplayEffectComponent_RemoveOnDamaged_OnTargetDamaged) == 0x000070, "Wrong size on HWGameplayEffectComponent_RemoveOnDamaged_OnTargetDamaged");
static_assert(offsetof(HWGameplayEffectComponent_RemoveOnDamaged_OnTargetDamaged, DamageEventData) == 0x000000, "Member 'HWGameplayEffectComponent_RemoveOnDamaged_OnTargetDamaged::DamageEventData' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.DeathstreakUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_Arena_DeathstreakUpdated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldStat;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStat;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_DeathstreakUpdated) == 0x000008, "Wrong alignment on HWGameState_Arena_DeathstreakUpdated");
static_assert(sizeof(HWGameState_Arena_DeathstreakUpdated) == 0x000010, "Wrong size on HWGameState_Arena_DeathstreakUpdated");
static_assert(offsetof(HWGameState_Arena_DeathstreakUpdated, PlayerState) == 0x000000, "Member 'HWGameState_Arena_DeathstreakUpdated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWGameState_Arena_DeathstreakUpdated, OldStat) == 0x000008, "Member 'HWGameState_Arena_DeathstreakUpdated::OldStat' has a wrong offset!");
static_assert(offsetof(HWGameState_Arena_DeathstreakUpdated, NewStat) == 0x00000C, "Member 'HWGameState_Arena_DeathstreakUpdated::NewStat' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.HandlePhaseChanged
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_Arena_HandlePhaseChanged final
{
public:
	struct FGameplayTag                           NewPhase;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_HandlePhaseChanged) == 0x000004, "Wrong alignment on HWGameState_Arena_HandlePhaseChanged");
static_assert(sizeof(HWGameState_Arena_HandlePhaseChanged) == 0x000008, "Wrong size on HWGameState_Arena_HandlePhaseChanged");
static_assert(offsetof(HWGameState_Arena_HandlePhaseChanged, NewPhase) == 0x000000, "Member 'HWGameState_Arena_HandlePhaseChanged::NewPhase' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.KillstreakUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_Arena_KillstreakUpdated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldStat;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStat;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_KillstreakUpdated) == 0x000008, "Wrong alignment on HWGameState_Arena_KillstreakUpdated");
static_assert(sizeof(HWGameState_Arena_KillstreakUpdated) == 0x000010, "Wrong size on HWGameState_Arena_KillstreakUpdated");
static_assert(offsetof(HWGameState_Arena_KillstreakUpdated, PlayerState) == 0x000000, "Member 'HWGameState_Arena_KillstreakUpdated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWGameState_Arena_KillstreakUpdated, OldStat) == 0x000008, "Member 'HWGameState_Arena_KillstreakUpdated::OldStat' has a wrong offset!");
static_assert(offsetof(HWGameState_Arena_KillstreakUpdated, NewStat) == 0x00000C, "Member 'HWGameState_Arena_KillstreakUpdated::NewStat' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.MulticastKillstreakBonusAwarded
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_Arena_MulticastKillstreakBonusAwarded final
{
public:
	const class AHWPlayerState*                   PlayerState;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_MulticastKillstreakBonusAwarded) == 0x000008, "Wrong alignment on HWGameState_Arena_MulticastKillstreakBonusAwarded");
static_assert(sizeof(HWGameState_Arena_MulticastKillstreakBonusAwarded) == 0x000008, "Wrong size on HWGameState_Arena_MulticastKillstreakBonusAwarded");
static_assert(offsetof(HWGameState_Arena_MulticastKillstreakBonusAwarded, PlayerState) == 0x000000, "Member 'HWGameState_Arena_MulticastKillstreakBonusAwarded::PlayerState' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.MulticastKillstreakBountyAwarded
// 0x0010 (0x0010 - 0x0000)
struct HWGameState_Arena_MulticastKillstreakBountyAwarded final
{
public:
	const class AHWPlayerState*                   KillerPlayer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWPlayerState*                   KilledPlayer;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_MulticastKillstreakBountyAwarded) == 0x000008, "Wrong alignment on HWGameState_Arena_MulticastKillstreakBountyAwarded");
static_assert(sizeof(HWGameState_Arena_MulticastKillstreakBountyAwarded) == 0x000010, "Wrong size on HWGameState_Arena_MulticastKillstreakBountyAwarded");
static_assert(offsetof(HWGameState_Arena_MulticastKillstreakBountyAwarded, KillerPlayer) == 0x000000, "Member 'HWGameState_Arena_MulticastKillstreakBountyAwarded::KillerPlayer' has a wrong offset!");
static_assert(offsetof(HWGameState_Arena_MulticastKillstreakBountyAwarded, KilledPlayer) == 0x000008, "Member 'HWGameState_Arena_MulticastKillstreakBountyAwarded::KilledPlayer' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.MulticastPlayEndSequence
// 0x0001 (0x0001 - 0x0000)
struct HWGameState_Arena_MulticastPlayEndSequence final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_MulticastPlayEndSequence) == 0x000001, "Wrong alignment on HWGameState_Arena_MulticastPlayEndSequence");
static_assert(sizeof(HWGameState_Arena_MulticastPlayEndSequence) == 0x000001, "Wrong size on HWGameState_Arena_MulticastPlayEndSequence");
static_assert(offsetof(HWGameState_Arena_MulticastPlayEndSequence, Team) == 0x000000, "Member 'HWGameState_Arena_MulticastPlayEndSequence::Team' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.MulticastPlaySeigeMinionSpawnedSequence
// 0x0002 (0x0002 - 0x0000)
struct HWGameState_Arena_MulticastPlaySeigeMinionSpawnedSequence final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Border;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_MulticastPlaySeigeMinionSpawnedSequence) == 0x000001, "Wrong alignment on HWGameState_Arena_MulticastPlaySeigeMinionSpawnedSequence");
static_assert(sizeof(HWGameState_Arena_MulticastPlaySeigeMinionSpawnedSequence) == 0x000002, "Wrong size on HWGameState_Arena_MulticastPlaySeigeMinionSpawnedSequence");
static_assert(offsetof(HWGameState_Arena_MulticastPlaySeigeMinionSpawnedSequence, Team) == 0x000000, "Member 'HWGameState_Arena_MulticastPlaySeigeMinionSpawnedSequence::Team' has a wrong offset!");
static_assert(offsetof(HWGameState_Arena_MulticastPlaySeigeMinionSpawnedSequence, Border) == 0x000001, "Member 'HWGameState_Arena_MulticastPlaySeigeMinionSpawnedSequence::Border' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.PlayEndSequence
// 0x0001 (0x0001 - 0x0000)
struct HWGameState_Arena_PlayEndSequence final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_PlayEndSequence) == 0x000001, "Wrong alignment on HWGameState_Arena_PlayEndSequence");
static_assert(sizeof(HWGameState_Arena_PlayEndSequence) == 0x000001, "Wrong size on HWGameState_Arena_PlayEndSequence");
static_assert(offsetof(HWGameState_Arena_PlayEndSequence, Team) == 0x000000, "Member 'HWGameState_Arena_PlayEndSequence::Team' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.PlayerDied
// 0x0080 (0x0080 - 0x0000)
struct HWGameState_Arena_PlayerDied final
{
public:
	class AHWTeamState*                           Team;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         TeamMember;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageEventData                       DeathEventData;                                    // 0x0010(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_PlayerDied) == 0x000008, "Wrong alignment on HWGameState_Arena_PlayerDied");
static_assert(sizeof(HWGameState_Arena_PlayerDied) == 0x000080, "Wrong size on HWGameState_Arena_PlayerDied");
static_assert(offsetof(HWGameState_Arena_PlayerDied, Team) == 0x000000, "Member 'HWGameState_Arena_PlayerDied::Team' has a wrong offset!");
static_assert(offsetof(HWGameState_Arena_PlayerDied, TeamMember) == 0x000008, "Member 'HWGameState_Arena_PlayerDied::TeamMember' has a wrong offset!");
static_assert(offsetof(HWGameState_Arena_PlayerDied, DeathEventData) == 0x000010, "Member 'HWGameState_Arena_PlayerDied::DeathEventData' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.PlayFireworkVFX
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_Arena_PlayFireworkVFX final
{
public:
	class AActor*                                 fireworkActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_PlayFireworkVFX) == 0x000008, "Wrong alignment on HWGameState_Arena_PlayFireworkVFX");
static_assert(sizeof(HWGameState_Arena_PlayFireworkVFX) == 0x000008, "Wrong size on HWGameState_Arena_PlayFireworkVFX");
static_assert(offsetof(HWGameState_Arena_PlayFireworkVFX, fireworkActor) == 0x000000, "Member 'HWGameState_Arena_PlayFireworkVFX::fireworkActor' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.UpdateTeamTickets
// 0x0008 (0x0008 - 0x0000)
struct HWGameState_Arena_UpdateTeamTickets final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TicketsToDeduct;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_UpdateTeamTickets) == 0x000004, "Wrong alignment on HWGameState_Arena_UpdateTeamTickets");
static_assert(sizeof(HWGameState_Arena_UpdateTeamTickets) == 0x000008, "Wrong size on HWGameState_Arena_UpdateTeamTickets");
static_assert(offsetof(HWGameState_Arena_UpdateTeamTickets, Team) == 0x000000, "Member 'HWGameState_Arena_UpdateTeamTickets::Team' has a wrong offset!");
static_assert(offsetof(HWGameState_Arena_UpdateTeamTickets, TicketsToDeduct) == 0x000004, "Member 'HWGameState_Arena_UpdateTeamTickets::TicketsToDeduct' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.GetChaosGodKills
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_Arena_GetChaosGodKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_GetChaosGodKills) == 0x000004, "Wrong alignment on HWGameState_Arena_GetChaosGodKills");
static_assert(sizeof(HWGameState_Arena_GetChaosGodKills) == 0x000004, "Wrong size on HWGameState_Arena_GetChaosGodKills");
static_assert(offsetof(HWGameState_Arena_GetChaosGodKills, ReturnValue) == 0x000000, "Member 'HWGameState_Arena_GetChaosGodKills::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.GetChaosTickets
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_Arena_GetChaosTickets final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_GetChaosTickets) == 0x000004, "Wrong alignment on HWGameState_Arena_GetChaosTickets");
static_assert(sizeof(HWGameState_Arena_GetChaosTickets) == 0x000004, "Wrong size on HWGameState_Arena_GetChaosTickets");
static_assert(offsetof(HWGameState_Arena_GetChaosTickets, ReturnValue) == 0x000000, "Member 'HWGameState_Arena_GetChaosTickets::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.GetKillsToSpawnSiegeMinion
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_Arena_GetKillsToSpawnSiegeMinion final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_GetKillsToSpawnSiegeMinion) == 0x000004, "Wrong alignment on HWGameState_Arena_GetKillsToSpawnSiegeMinion");
static_assert(sizeof(HWGameState_Arena_GetKillsToSpawnSiegeMinion) == 0x000004, "Wrong size on HWGameState_Arena_GetKillsToSpawnSiegeMinion");
static_assert(offsetof(HWGameState_Arena_GetKillsToSpawnSiegeMinion, ReturnValue) == 0x000000, "Member 'HWGameState_Arena_GetKillsToSpawnSiegeMinion::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.GetMaxTickets
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_Arena_GetMaxTickets final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_GetMaxTickets) == 0x000004, "Wrong alignment on HWGameState_Arena_GetMaxTickets");
static_assert(sizeof(HWGameState_Arena_GetMaxTickets) == 0x000004, "Wrong size on HWGameState_Arena_GetMaxTickets");
static_assert(offsetof(HWGameState_Arena_GetMaxTickets, ReturnValue) == 0x000000, "Member 'HWGameState_Arena_GetMaxTickets::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.GetOrderGodKills
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_Arena_GetOrderGodKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_GetOrderGodKills) == 0x000004, "Wrong alignment on HWGameState_Arena_GetOrderGodKills");
static_assert(sizeof(HWGameState_Arena_GetOrderGodKills) == 0x000004, "Wrong size on HWGameState_Arena_GetOrderGodKills");
static_assert(offsetof(HWGameState_Arena_GetOrderGodKills, ReturnValue) == 0x000000, "Member 'HWGameState_Arena_GetOrderGodKills::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameState_Arena.GetOrderTickets
// 0x0004 (0x0004 - 0x0000)
struct HWGameState_Arena_GetOrderTickets final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameState_Arena_GetOrderTickets) == 0x000004, "Wrong alignment on HWGameState_Arena_GetOrderTickets");
static_assert(sizeof(HWGameState_Arena_GetOrderTickets) == 0x000004, "Wrong size on HWGameState_Arena_GetOrderTickets");
static_assert(offsetof(HWGameState_Arena_GetOrderTickets, ReturnValue) == 0x000000, "Member 'HWGameState_Arena_GetOrderTickets::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinEvoEvalComponent.HandleOnNewSkinTagAsset
// 0x0010 (0x0010 - 0x0000)
struct HWSkinEvoEvalComponent_HandleOnNewSkinTagAsset final
{
public:
	TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinEvoEvalComponent_HandleOnNewSkinTagAsset) == 0x000008, "Wrong alignment on HWSkinEvoEvalComponent_HandleOnNewSkinTagAsset");
static_assert(sizeof(HWSkinEvoEvalComponent_HandleOnNewSkinTagAsset) == 0x000010, "Wrong size on HWSkinEvoEvalComponent_HandleOnNewSkinTagAsset");
static_assert(offsetof(HWSkinEvoEvalComponent_HandleOnNewSkinTagAsset, NewSkinTagAsset) == 0x000000, "Member 'HWSkinEvoEvalComponent_HandleOnNewSkinTagAsset::NewSkinTagAsset' has a wrong offset!");

// Function Hemingway.HWSkinEvoEvalComponent.HandleOnSkinTagAssetRemoved
// 0x0010 (0x0010 - 0x0000)
struct HWSkinEvoEvalComponent_HandleOnSkinTagAssetRemoved final
{
public:
	TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove;                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinEvoEvalComponent_HandleOnSkinTagAssetRemoved) == 0x000008, "Wrong alignment on HWSkinEvoEvalComponent_HandleOnSkinTagAssetRemoved");
static_assert(sizeof(HWSkinEvoEvalComponent_HandleOnSkinTagAssetRemoved) == 0x000010, "Wrong size on HWSkinEvoEvalComponent_HandleOnSkinTagAssetRemoved");
static_assert(offsetof(HWSkinEvoEvalComponent_HandleOnSkinTagAssetRemoved, SkinTagAssetToRemove) == 0x000000, "Member 'HWSkinEvoEvalComponent_HandleOnSkinTagAssetRemoved::SkinTagAssetToRemove' has a wrong offset!");

// Function Hemingway.HWSkinEvoEvalComponent.HandleSkinItemUpdated
// 0x0018 (0x0018 - 0x0000)
struct HWSkinEvoEvalComponent_HandleSkinItemUpdated final
{
public:
	TScriptInterface<class IHWInterface_LoadoutManagement> LoadoutOwner;                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWSkinItem*                      NewSkinItem;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinEvoEvalComponent_HandleSkinItemUpdated) == 0x000008, "Wrong alignment on HWSkinEvoEvalComponent_HandleSkinItemUpdated");
static_assert(sizeof(HWSkinEvoEvalComponent_HandleSkinItemUpdated) == 0x000018, "Wrong size on HWSkinEvoEvalComponent_HandleSkinItemUpdated");
static_assert(offsetof(HWSkinEvoEvalComponent_HandleSkinItemUpdated, LoadoutOwner) == 0x000000, "Member 'HWSkinEvoEvalComponent_HandleSkinItemUpdated::LoadoutOwner' has a wrong offset!");
static_assert(offsetof(HWSkinEvoEvalComponent_HandleSkinItemUpdated, NewSkinItem) == 0x000010, "Member 'HWSkinEvoEvalComponent_HandleSkinItemUpdated::NewSkinItem' has a wrong offset!");

// Function Hemingway.HWSkinEvoEvalComponent.SetSkinTag
// 0x000C (0x000C - 0x0000)
struct HWSkinEvoEvalComponent_SetSkinTag final
{
public:
	struct FGameplayTag                           NewSkinTagValue;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSkinEvoEvalComponent_SetSkinTag) == 0x000004, "Wrong alignment on HWSkinEvoEvalComponent_SetSkinTag");
static_assert(sizeof(HWSkinEvoEvalComponent_SetSkinTag) == 0x00000C, "Wrong size on HWSkinEvoEvalComponent_SetSkinTag");
static_assert(offsetof(HWSkinEvoEvalComponent_SetSkinTag, NewSkinTagValue) == 0x000000, "Member 'HWSkinEvoEvalComponent_SetSkinTag::NewSkinTagValue' has a wrong offset!");
static_assert(offsetof(HWSkinEvoEvalComponent_SetSkinTag, ReturnValue) == 0x000008, "Member 'HWSkinEvoEvalComponent_SetSkinTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent.OnLocalPlayerStateChanged
// 0x0008 (0x0008 - 0x0000)
struct HWVisibilityComponent_OnLocalPlayerStateChanged final
{
public:
	class AHWPlayerState*                         HWPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVisibilityComponent_OnLocalPlayerStateChanged) == 0x000008, "Wrong alignment on HWVisibilityComponent_OnLocalPlayerStateChanged");
static_assert(sizeof(HWVisibilityComponent_OnLocalPlayerStateChanged) == 0x000008, "Wrong size on HWVisibilityComponent_OnLocalPlayerStateChanged");
static_assert(offsetof(HWVisibilityComponent_OnLocalPlayerStateChanged, HWPlayerState) == 0x000000, "Member 'HWVisibilityComponent_OnLocalPlayerStateChanged::HWPlayerState' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent.OnLocalTeamChanged
// 0x0010 (0x0010 - 0x0000)
struct HWVisibilityComponent_OnLocalTeamChanged final
{
public:
	class AController*                            Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x0008(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVisibilityComponent_OnLocalTeamChanged) == 0x000008, "Wrong alignment on HWVisibilityComponent_OnLocalTeamChanged");
static_assert(sizeof(HWVisibilityComponent_OnLocalTeamChanged) == 0x000010, "Wrong size on HWVisibilityComponent_OnLocalTeamChanged");
static_assert(offsetof(HWVisibilityComponent_OnLocalTeamChanged, Controller) == 0x000000, "Member 'HWVisibilityComponent_OnLocalTeamChanged::Controller' has a wrong offset!");
static_assert(offsetof(HWVisibilityComponent_OnLocalTeamChanged, TeamId) == 0x000008, "Member 'HWVisibilityComponent_OnLocalTeamChanged::TeamId' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent.IsMeshStealthedForTarget
// 0x0010 (0x0010 - 0x0000)
struct HWVisibilityComponent_IsMeshStealthedForTarget final
{
public:
	const class AActor*                           TargetActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVisibilityComponent_IsMeshStealthedForTarget) == 0x000008, "Wrong alignment on HWVisibilityComponent_IsMeshStealthedForTarget");
static_assert(sizeof(HWVisibilityComponent_IsMeshStealthedForTarget) == 0x000010, "Wrong size on HWVisibilityComponent_IsMeshStealthedForTarget");
static_assert(offsetof(HWVisibilityComponent_IsMeshStealthedForTarget, TargetActor) == 0x000000, "Member 'HWVisibilityComponent_IsMeshStealthedForTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(HWVisibilityComponent_IsMeshStealthedForTarget, ReturnValue) == 0x000008, "Member 'HWVisibilityComponent_IsMeshStealthedForTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent.IsMinimapVisibleToTeam
// 0x0002 (0x0002 - 0x0000)
struct HWVisibilityComponent_IsMinimapVisibleToTeam final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVisibilityComponent_IsMinimapVisibleToTeam) == 0x000001, "Wrong alignment on HWVisibilityComponent_IsMinimapVisibleToTeam");
static_assert(sizeof(HWVisibilityComponent_IsMinimapVisibleToTeam) == 0x000002, "Wrong size on HWVisibilityComponent_IsMinimapVisibleToTeam");
static_assert(offsetof(HWVisibilityComponent_IsMinimapVisibleToTeam, TeamId) == 0x000000, "Member 'HWVisibilityComponent_IsMinimapVisibleToTeam::TeamId' has a wrong offset!");
static_assert(offsetof(HWVisibilityComponent_IsMinimapVisibleToTeam, ReturnValue) == 0x000001, "Member 'HWVisibilityComponent_IsMinimapVisibleToTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWControlModule_DeathSpectator.GoToNextSpectateTarget
// 0x0001 (0x0001 - 0x0000)
struct HWControlModule_DeathSpectator_GoToNextSpectateTarget final
{
public:
	bool                                          bWasDeath;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWControlModule_DeathSpectator_GoToNextSpectateTarget) == 0x000001, "Wrong alignment on HWControlModule_DeathSpectator_GoToNextSpectateTarget");
static_assert(sizeof(HWControlModule_DeathSpectator_GoToNextSpectateTarget) == 0x000001, "Wrong size on HWControlModule_DeathSpectator_GoToNextSpectateTarget");
static_assert(offsetof(HWControlModule_DeathSpectator_GoToNextSpectateTarget, bWasDeath) == 0x000000, "Member 'HWControlModule_DeathSpectator_GoToNextSpectateTarget::bWasDeath' has a wrong offset!");

// Function Hemingway.HWControlModule_DeathSpectator.OnRep_CurrentSpectateTargetInfo
// 0x0008 (0x0008 - 0x0000)
struct HWControlModule_DeathSpectator_OnRep_CurrentSpectateTargetInfo final
{
public:
	struct FHWSpectateTargetIndexInfo             PreviousSpectateTargetInfo;                        // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWControlModule_DeathSpectator_OnRep_CurrentSpectateTargetInfo) == 0x000004, "Wrong alignment on HWControlModule_DeathSpectator_OnRep_CurrentSpectateTargetInfo");
static_assert(sizeof(HWControlModule_DeathSpectator_OnRep_CurrentSpectateTargetInfo) == 0x000008, "Wrong size on HWControlModule_DeathSpectator_OnRep_CurrentSpectateTargetInfo");
static_assert(offsetof(HWControlModule_DeathSpectator_OnRep_CurrentSpectateTargetInfo, PreviousSpectateTargetInfo) == 0x000000, "Member 'HWControlModule_DeathSpectator_OnRep_CurrentSpectateTargetInfo::PreviousSpectateTargetInfo' has a wrong offset!");

// Function Hemingway.HWControlModule_DeathSpectator.OnSpectateTargetBotsSet
// 0x0008 (0x0008 - 0x0000)
struct HWControlModule_DeathSpectator_OnSpectateTargetBotsSet final
{
public:
	class AHWBotFactory*                          BotFactory;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWControlModule_DeathSpectator_OnSpectateTargetBotsSet) == 0x000008, "Wrong alignment on HWControlModule_DeathSpectator_OnSpectateTargetBotsSet");
static_assert(sizeof(HWControlModule_DeathSpectator_OnSpectateTargetBotsSet) == 0x000008, "Wrong size on HWControlModule_DeathSpectator_OnSpectateTargetBotsSet");
static_assert(offsetof(HWControlModule_DeathSpectator_OnSpectateTargetBotsSet, BotFactory) == 0x000000, "Member 'HWControlModule_DeathSpectator_OnSpectateTargetBotsSet::BotFactory' has a wrong offset!");

// Function Hemingway.HWControlModule_DeathSpectator.OnSpectateTargetCanSpectateStatusChanged
// 0x0010 (0x0010 - 0x0000)
struct HWControlModule_DeathSpectator_OnSpectateTargetCanSpectateStatusChanged final
{
public:
	class AHWCharacter_Base*                      Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSpectate;                                      // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWControlModule_DeathSpectator_OnSpectateTargetCanSpectateStatusChanged) == 0x000008, "Wrong alignment on HWControlModule_DeathSpectator_OnSpectateTargetCanSpectateStatusChanged");
static_assert(sizeof(HWControlModule_DeathSpectator_OnSpectateTargetCanSpectateStatusChanged) == 0x000010, "Wrong size on HWControlModule_DeathSpectator_OnSpectateTargetCanSpectateStatusChanged");
static_assert(offsetof(HWControlModule_DeathSpectator_OnSpectateTargetCanSpectateStatusChanged, Character) == 0x000000, "Member 'HWControlModule_DeathSpectator_OnSpectateTargetCanSpectateStatusChanged::Character' has a wrong offset!");
static_assert(offsetof(HWControlModule_DeathSpectator_OnSpectateTargetCanSpectateStatusChanged, bCanSpectate) == 0x000008, "Member 'HWControlModule_DeathSpectator_OnSpectateTargetCanSpectateStatusChanged::bCanSpectate' has a wrong offset!");

// Function Hemingway.HWControlModule_DeathSpectator.OnSpectatingTargetPawnSet
// 0x0018 (0x0018 - 0x0000)
struct HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet final
{
public:
	class APlayerState*                           SetPlayerState;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  NewlySetPawn;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  PreviousPawn;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet) == 0x000008, "Wrong alignment on HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet");
static_assert(sizeof(HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet) == 0x000018, "Wrong size on HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet");
static_assert(offsetof(HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet, SetPlayerState) == 0x000000, "Member 'HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet::SetPlayerState' has a wrong offset!");
static_assert(offsetof(HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet, NewlySetPawn) == 0x000008, "Member 'HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet::NewlySetPawn' has a wrong offset!");
static_assert(offsetof(HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet, PreviousPawn) == 0x000010, "Member 'HWControlModule_DeathSpectator_OnSpectatingTargetPawnSet::PreviousPawn' has a wrong offset!");

// Function Hemingway.HWControlModule_DeathSpectator.OnTeamChanged
// 0x0010 (0x0010 - 0x0000)
struct HWControlModule_DeathSpectator_OnTeamChanged final
{
public:
	class AController*                            Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x0008(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWControlModule_DeathSpectator_OnTeamChanged) == 0x000008, "Wrong alignment on HWControlModule_DeathSpectator_OnTeamChanged");
static_assert(sizeof(HWControlModule_DeathSpectator_OnTeamChanged) == 0x000010, "Wrong size on HWControlModule_DeathSpectator_OnTeamChanged");
static_assert(offsetof(HWControlModule_DeathSpectator_OnTeamChanged, Controller) == 0x000000, "Member 'HWControlModule_DeathSpectator_OnTeamChanged::Controller' has a wrong offset!");
static_assert(offsetof(HWControlModule_DeathSpectator_OnTeamChanged, TeamId) == 0x000008, "Member 'HWControlModule_DeathSpectator_OnTeamChanged::TeamId' has a wrong offset!");

// Function Hemingway.HWControlModule_DeathSpectator.ServerSetSpectatorTarget
// 0x0008 (0x0008 - 0x0000)
struct HWControlModule_DeathSpectator_ServerSetSpectatorTarget final
{
public:
	int32                                         DesiredSpectateIndex;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasDeath;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWControlModule_DeathSpectator_ServerSetSpectatorTarget) == 0x000004, "Wrong alignment on HWControlModule_DeathSpectator_ServerSetSpectatorTarget");
static_assert(sizeof(HWControlModule_DeathSpectator_ServerSetSpectatorTarget) == 0x000008, "Wrong size on HWControlModule_DeathSpectator_ServerSetSpectatorTarget");
static_assert(offsetof(HWControlModule_DeathSpectator_ServerSetSpectatorTarget, DesiredSpectateIndex) == 0x000000, "Member 'HWControlModule_DeathSpectator_ServerSetSpectatorTarget::DesiredSpectateIndex' has a wrong offset!");
static_assert(offsetof(HWControlModule_DeathSpectator_ServerSetSpectatorTarget, bWasDeath) == 0x000004, "Member 'HWControlModule_DeathSpectator_ServerSetSpectatorTarget::bWasDeath' has a wrong offset!");

// Function Hemingway.HWControlModule_DeathSpectator.GetSpectatorViewTarget
// 0x0008 (0x0008 - 0x0000)
struct HWControlModule_DeathSpectator_GetSpectatorViewTarget final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWControlModule_DeathSpectator_GetSpectatorViewTarget) == 0x000008, "Wrong alignment on HWControlModule_DeathSpectator_GetSpectatorViewTarget");
static_assert(sizeof(HWControlModule_DeathSpectator_GetSpectatorViewTarget) == 0x000008, "Wrong size on HWControlModule_DeathSpectator_GetSpectatorViewTarget");
static_assert(offsetof(HWControlModule_DeathSpectator_GetSpectatorViewTarget, ReturnValue) == 0x000000, "Member 'HWControlModule_DeathSpectator_GetSpectatorViewTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_CC_Effect.CanApplyDiminishingReturns
// 0x0001 (0x0001 - 0x0000)
struct HWInterface_CC_Effect_CanApplyDiminishingReturns final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_CC_Effect_CanApplyDiminishingReturns) == 0x000001, "Wrong alignment on HWInterface_CC_Effect_CanApplyDiminishingReturns");
static_assert(sizeof(HWInterface_CC_Effect_CanApplyDiminishingReturns) == 0x000001, "Wrong size on HWInterface_CC_Effect_CanApplyDiminishingReturns");
static_assert(offsetof(HWInterface_CC_Effect_CanApplyDiminishingReturns, ReturnValue) == 0x000000, "Member 'HWInterface_CC_Effect_CanApplyDiminishingReturns::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_CC_Effect.CanBeAffectedByCrowdControlReduction
// 0x0001 (0x0001 - 0x0000)
struct HWInterface_CC_Effect_CanBeAffectedByCrowdControlReduction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_CC_Effect_CanBeAffectedByCrowdControlReduction) == 0x000001, "Wrong alignment on HWInterface_CC_Effect_CanBeAffectedByCrowdControlReduction");
static_assert(sizeof(HWInterface_CC_Effect_CanBeAffectedByCrowdControlReduction) == 0x000001, "Wrong size on HWInterface_CC_Effect_CanBeAffectedByCrowdControlReduction");
static_assert(offsetof(HWInterface_CC_Effect_CanBeAffectedByCrowdControlReduction, ReturnValue) == 0x000000, "Member 'HWInterface_CC_Effect_CanBeAffectedByCrowdControlReduction::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_CC_Effect.GetDiminishingReturnStacks
// 0x0004 (0x0004 - 0x0000)
struct HWInterface_CC_Effect_GetDiminishingReturnStacks final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_CC_Effect_GetDiminishingReturnStacks) == 0x000004, "Wrong alignment on HWInterface_CC_Effect_GetDiminishingReturnStacks");
static_assert(sizeof(HWInterface_CC_Effect_GetDiminishingReturnStacks) == 0x000004, "Wrong size on HWInterface_CC_Effect_GetDiminishingReturnStacks");
static_assert(offsetof(HWInterface_CC_Effect_GetDiminishingReturnStacks, ReturnValue) == 0x000000, "Member 'HWInterface_CC_Effect_GetDiminishingReturnStacks::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_CC_Effect.IsHardCC
// 0x0001 (0x0001 - 0x0000)
struct HWInterface_CC_Effect_IsHardCC final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_CC_Effect_IsHardCC) == 0x000001, "Wrong alignment on HWInterface_CC_Effect_IsHardCC");
static_assert(sizeof(HWInterface_CC_Effect_IsHardCC) == 0x000001, "Wrong size on HWInterface_CC_Effect_IsHardCC");
static_assert(offsetof(HWInterface_CC_Effect_IsHardCC, ReturnValue) == 0x000000, "Member 'HWInterface_CC_Effect_IsHardCC::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_CC_Effect.IsSoftCC
// 0x0001 (0x0001 - 0x0000)
struct HWInterface_CC_Effect_IsSoftCC final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_CC_Effect_IsSoftCC) == 0x000001, "Wrong alignment on HWInterface_CC_Effect_IsSoftCC");
static_assert(sizeof(HWInterface_CC_Effect_IsSoftCC) == 0x000001, "Wrong size on HWInterface_CC_Effect_IsSoftCC");
static_assert(offsetof(HWInterface_CC_Effect_IsSoftCC, ReturnValue) == 0x000000, "Member 'HWInterface_CC_Effect_IsSoftCC::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Damagable.CustomDamageEventDataOverride
// 0x0070 (0x0070 - 0x0000)
struct HWInterface_Damagable_CustomDamageEventDataOverride final
{
public:
	struct FDamageEventData                       OutDamageEvent;                                    // 0x0000(0x0070)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Damagable_CustomDamageEventDataOverride) == 0x000008, "Wrong alignment on HWInterface_Damagable_CustomDamageEventDataOverride");
static_assert(sizeof(HWInterface_Damagable_CustomDamageEventDataOverride) == 0x000070, "Wrong size on HWInterface_Damagable_CustomDamageEventDataOverride");
static_assert(offsetof(HWInterface_Damagable_CustomDamageEventDataOverride, OutDamageEvent) == 0x000000, "Member 'HWInterface_Damagable_CustomDamageEventDataOverride::OutDamageEvent' has a wrong offset!");

// Function Hemingway.HWInterface_Damagable.Die
// 0x0070 (0x0070 - 0x0000)
struct HWInterface_Damagable_Die final
{
public:
	struct FDamageEventData                       DeathDamageReceivedEvent;                          // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Damagable_Die) == 0x000008, "Wrong alignment on HWInterface_Damagable_Die");
static_assert(sizeof(HWInterface_Damagable_Die) == 0x000070, "Wrong size on HWInterface_Damagable_Die");
static_assert(offsetof(HWInterface_Damagable_Die, DeathDamageReceivedEvent) == 0x000000, "Member 'HWInterface_Damagable_Die::DeathDamageReceivedEvent' has a wrong offset!");

// Function Hemingway.HWInterface_Damagable.OnDamageTaken
// 0x0070 (0x0070 - 0x0000)
struct HWInterface_Damagable_OnDamageTaken final
{
public:
	struct FDamageEventData                       DamageEvent;                                       // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Damagable_OnDamageTaken) == 0x000008, "Wrong alignment on HWInterface_Damagable_OnDamageTaken");
static_assert(sizeof(HWInterface_Damagable_OnDamageTaken) == 0x000070, "Wrong size on HWInterface_Damagable_OnDamageTaken");
static_assert(offsetof(HWInterface_Damagable_OnDamageTaken, DamageEvent) == 0x000000, "Member 'HWInterface_Damagable_OnDamageTaken::DamageEvent' has a wrong offset!");

// Function Hemingway.HWInterface_Damagable.OnHealed
// 0x0040 (0x0040 - 0x0000)
struct HWInterface_Damagable_OnHealed final
{
public:
	struct FHealEventData                         HealEvent;                                         // 0x0000(0x0040)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Damagable_OnHealed) == 0x000008, "Wrong alignment on HWInterface_Damagable_OnHealed");
static_assert(sizeof(HWInterface_Damagable_OnHealed) == 0x000040, "Wrong size on HWInterface_Damagable_OnHealed");
static_assert(offsetof(HWInterface_Damagable_OnHealed, HealEvent) == 0x000000, "Member 'HWInterface_Damagable_OnHealed::HealEvent' has a wrong offset!");

// Function Hemingway.HWInterface_Damagable.CanBeAffectedByCrit
// 0x0001 (0x0001 - 0x0000)
struct HWInterface_Damagable_CanBeAffectedByCrit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Damagable_CanBeAffectedByCrit) == 0x000001, "Wrong alignment on HWInterface_Damagable_CanBeAffectedByCrit");
static_assert(sizeof(HWInterface_Damagable_CanBeAffectedByCrit) == 0x000001, "Wrong size on HWInterface_Damagable_CanBeAffectedByCrit");
static_assert(offsetof(HWInterface_Damagable_CanBeAffectedByCrit, ReturnValue) == 0x000000, "Member 'HWInterface_Damagable_CanBeAffectedByCrit::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Damagable.CanBeAffectedByLifeSteal
// 0x0001 (0x0001 - 0x0000)
struct HWInterface_Damagable_CanBeAffectedByLifeSteal final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Damagable_CanBeAffectedByLifeSteal) == 0x000001, "Wrong alignment on HWInterface_Damagable_CanBeAffectedByLifeSteal");
static_assert(sizeof(HWInterface_Damagable_CanBeAffectedByLifeSteal) == 0x000001, "Wrong size on HWInterface_Damagable_CanBeAffectedByLifeSteal");
static_assert(offsetof(HWInterface_Damagable_CanBeAffectedByLifeSteal, ReturnValue) == 0x000000, "Member 'HWInterface_Damagable_CanBeAffectedByLifeSteal::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Damagable.CanBeDamagedBy
// 0x0018 (0x0018 - 0x0000)
struct HWInterface_Damagable_CanBeDamagedBy final
{
public:
	const class AActor*                           SourceActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilitySystemComponent*        SourceASC;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInterface_Damagable_CanBeDamagedBy) == 0x000008, "Wrong alignment on HWInterface_Damagable_CanBeDamagedBy");
static_assert(sizeof(HWInterface_Damagable_CanBeDamagedBy) == 0x000018, "Wrong size on HWInterface_Damagable_CanBeDamagedBy");
static_assert(offsetof(HWInterface_Damagable_CanBeDamagedBy, SourceActor) == 0x000000, "Member 'HWInterface_Damagable_CanBeDamagedBy::SourceActor' has a wrong offset!");
static_assert(offsetof(HWInterface_Damagable_CanBeDamagedBy, SourceASC) == 0x000008, "Member 'HWInterface_Damagable_CanBeDamagedBy::SourceASC' has a wrong offset!");
static_assert(offsetof(HWInterface_Damagable_CanBeDamagedBy, ReturnValue) == 0x000010, "Member 'HWInterface_Damagable_CanBeDamagedBy::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Damagable.GetCritEffectiveness
// 0x0004 (0x0004 - 0x0000)
struct HWInterface_Damagable_GetCritEffectiveness final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Damagable_GetCritEffectiveness) == 0x000004, "Wrong alignment on HWInterface_Damagable_GetCritEffectiveness");
static_assert(sizeof(HWInterface_Damagable_GetCritEffectiveness) == 0x000004, "Wrong size on HWInterface_Damagable_GetCritEffectiveness");
static_assert(offsetof(HWInterface_Damagable_GetCritEffectiveness, ReturnValue) == 0x000000, "Member 'HWInterface_Damagable_GetCritEffectiveness::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Damagable.GetLifeStealEffectiveness
// 0x0004 (0x0004 - 0x0000)
struct HWInterface_Damagable_GetLifeStealEffectiveness final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Damagable_GetLifeStealEffectiveness) == 0x000004, "Wrong alignment on HWInterface_Damagable_GetLifeStealEffectiveness");
static_assert(sizeof(HWInterface_Damagable_GetLifeStealEffectiveness) == 0x000004, "Wrong size on HWInterface_Damagable_GetLifeStealEffectiveness");
static_assert(offsetof(HWInterface_Damagable_GetLifeStealEffectiveness, ReturnValue) == 0x000000, "Member 'HWInterface_Damagable_GetLifeStealEffectiveness::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Damagable.Interface_IsDead
// 0x0001 (0x0001 - 0x0000)
struct HWInterface_Damagable_Interface_IsDead final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Damagable_Interface_IsDead) == 0x000001, "Wrong alignment on HWInterface_Damagable_Interface_IsDead");
static_assert(sizeof(HWInterface_Damagable_Interface_IsDead) == 0x000001, "Wrong size on HWInterface_Damagable_Interface_IsDead");
static_assert(offsetof(HWInterface_Damagable_Interface_IsDead, ReturnValue) == 0x000000, "Member 'HWInterface_Damagable_Interface_IsDead::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Bellona_Passive.OnBellonaAbilityFire
// 0x0030 (0x0030 - 0x0000)
struct HWAbility_Bellona_Passive_OnBellonaAbilityFire final
{
public:
	struct FGameplayAbilitySpecHandle             FiredAbilityHandle;                                // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  FiredAbilityTags;                                  // 0x0008(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0028(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Bellona_Passive_OnBellonaAbilityFire) == 0x000008, "Wrong alignment on HWAbility_Bellona_Passive_OnBellonaAbilityFire");
static_assert(sizeof(HWAbility_Bellona_Passive_OnBellonaAbilityFire) == 0x000030, "Wrong size on HWAbility_Bellona_Passive_OnBellonaAbilityFire");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaAbilityFire, FiredAbilityHandle) == 0x000000, "Member 'HWAbility_Bellona_Passive_OnBellonaAbilityFire::FiredAbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaAbilityFire, FiredAbilityTags) == 0x000008, "Member 'HWAbility_Bellona_Passive_OnBellonaAbilityFire::FiredAbilityTags' has a wrong offset!");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaAbilityFire, FiringInstanceId) == 0x000028, "Member 'HWAbility_Bellona_Passive_OnBellonaAbilityFire::FiringInstanceId' has a wrong offset!");

// Function Hemingway.HWAbility_Bellona_Passive.OnBellonaApplyDamageHit
// 0x0158 (0x0158 - 0x0000)
struct HWAbility_Bellona_Passive_OnBellonaApplyDamageHit final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDamageEventData                       DamageEventData;                                   // 0x00E8(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Bellona_Passive_OnBellonaApplyDamageHit) == 0x000008, "Wrong alignment on HWAbility_Bellona_Passive_OnBellonaApplyDamageHit");
static_assert(sizeof(HWAbility_Bellona_Passive_OnBellonaApplyDamageHit) == 0x000158, "Wrong size on HWAbility_Bellona_Passive_OnBellonaApplyDamageHit");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaApplyDamageHit, HitResult) == 0x000000, "Member 'HWAbility_Bellona_Passive_OnBellonaApplyDamageHit::HitResult' has a wrong offset!");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaApplyDamageHit, DamageEventData) == 0x0000E8, "Member 'HWAbility_Bellona_Passive_OnBellonaApplyDamageHit::DamageEventData' has a wrong offset!");

// Function Hemingway.HWAbility_Bellona_Passive.OnBellonaDamageTaken
// 0x0070 (0x0070 - 0x0000)
struct HWAbility_Bellona_Passive_OnBellonaDamageTaken final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Bellona_Passive_OnBellonaDamageTaken) == 0x000008, "Wrong alignment on HWAbility_Bellona_Passive_OnBellonaDamageTaken");
static_assert(sizeof(HWAbility_Bellona_Passive_OnBellonaDamageTaken) == 0x000070, "Wrong size on HWAbility_Bellona_Passive_OnBellonaDamageTaken");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaDamageTaken, DamageEventData) == 0x000000, "Member 'HWAbility_Bellona_Passive_OnBellonaDamageTaken::DamageEventData' has a wrong offset!");

// Function Hemingway.HWAbility_Bellona_Passive.OnBellonaDied
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Bellona_Passive_OnBellonaDied final
{
public:
	class AHWCharacterAbilitySystemActor*         CharacterAbilitySystemActor;                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnTimeDuration;                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Bellona_Passive_OnBellonaDied) == 0x000008, "Wrong alignment on HWAbility_Bellona_Passive_OnBellonaDied");
static_assert(sizeof(HWAbility_Bellona_Passive_OnBellonaDied) == 0x000010, "Wrong size on HWAbility_Bellona_Passive_OnBellonaDied");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaDied, CharacterAbilitySystemActor) == 0x000000, "Member 'HWAbility_Bellona_Passive_OnBellonaDied::CharacterAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaDied, RespawnTimeDuration) == 0x000008, "Member 'HWAbility_Bellona_Passive_OnBellonaDied::RespawnTimeDuration' has a wrong offset!");

// Function Hemingway.HWAbility_Bellona_Passive.OnBellonaInhandActivate
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Bellona_Passive_OnBellonaInhandActivate final
{
public:
	class UGameplayAbility*                       ActivatedAbility;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Bellona_Passive_OnBellonaInhandActivate) == 0x000008, "Wrong alignment on HWAbility_Bellona_Passive_OnBellonaInhandActivate");
static_assert(sizeof(HWAbility_Bellona_Passive_OnBellonaInhandActivate) == 0x000008, "Wrong size on HWAbility_Bellona_Passive_OnBellonaInhandActivate");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaInhandActivate, ActivatedAbility) == 0x000000, "Member 'HWAbility_Bellona_Passive_OnBellonaInhandActivate::ActivatedAbility' has a wrong offset!");

// Function Hemingway.HWAbility_Bellona_Passive.OnBellonaInhandEndFire
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Bellona_Passive_OnBellonaInhandEndFire final
{
public:
	const class UGameplayAbility*                 EndingAbility;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Bellona_Passive_OnBellonaInhandEndFire) == 0x000008, "Wrong alignment on HWAbility_Bellona_Passive_OnBellonaInhandEndFire");
static_assert(sizeof(HWAbility_Bellona_Passive_OnBellonaInhandEndFire) == 0x000008, "Wrong size on HWAbility_Bellona_Passive_OnBellonaInhandEndFire");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaInhandEndFire, EndingAbility) == 0x000000, "Member 'HWAbility_Bellona_Passive_OnBellonaInhandEndFire::EndingAbility' has a wrong offset!");

// Function Hemingway.HWAbility_Bellona_Passive.OnBellonaInhandRefire
// 0x0028 (0x0028 - 0x0000)
struct HWAbility_Bellona_Passive_OnBellonaInhandRefire final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BellonaAbilityTags;                                // 0x0008(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Bellona_Passive_OnBellonaInhandRefire) == 0x000008, "Wrong alignment on HWAbility_Bellona_Passive_OnBellonaInhandRefire");
static_assert(sizeof(HWAbility_Bellona_Passive_OnBellonaInhandRefire) == 0x000028, "Wrong size on HWAbility_Bellona_Passive_OnBellonaInhandRefire");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaInhandRefire, AbilityHandle) == 0x000000, "Member 'HWAbility_Bellona_Passive_OnBellonaInhandRefire::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbility_Bellona_Passive_OnBellonaInhandRefire, BellonaAbilityTags) == 0x000008, "Member 'HWAbility_Bellona_Passive_OnBellonaInhandRefire::BellonaAbilityTags' has a wrong offset!");

// Function Hemingway.HWAbility_Bellona_Passive.SwapEquippedInhandWeapon
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Bellona_Passive_SwapEquippedInhandWeapon final
{
public:
	EHWBellonaInhandWeaponType                    WeaponTypeToEquip;                                 // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Bellona_Passive_SwapEquippedInhandWeapon) == 0x000001, "Wrong alignment on HWAbility_Bellona_Passive_SwapEquippedInhandWeapon");
static_assert(sizeof(HWAbility_Bellona_Passive_SwapEquippedInhandWeapon) == 0x000001, "Wrong size on HWAbility_Bellona_Passive_SwapEquippedInhandWeapon");
static_assert(offsetof(HWAbility_Bellona_Passive_SwapEquippedInhandWeapon, WeaponTypeToEquip) == 0x000000, "Member 'HWAbility_Bellona_Passive_SwapEquippedInhandWeapon::WeaponTypeToEquip' has a wrong offset!");

// Function Hemingway.HWInterface_Interactable.ShouldApplyInteractBlocker
// 0x0018 (0x0018 - 0x0000)
struct HWInterface_Interactable_ShouldApplyInteractBlocker final
{
public:
	const class AActor*                           OverlappedActor;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           OtherActor;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInterface_Interactable_ShouldApplyInteractBlocker) == 0x000008, "Wrong alignment on HWInterface_Interactable_ShouldApplyInteractBlocker");
static_assert(sizeof(HWInterface_Interactable_ShouldApplyInteractBlocker) == 0x000018, "Wrong size on HWInterface_Interactable_ShouldApplyInteractBlocker");
static_assert(offsetof(HWInterface_Interactable_ShouldApplyInteractBlocker, OverlappedActor) == 0x000000, "Member 'HWInterface_Interactable_ShouldApplyInteractBlocker::OverlappedActor' has a wrong offset!");
static_assert(offsetof(HWInterface_Interactable_ShouldApplyInteractBlocker, OtherActor) == 0x000008, "Member 'HWInterface_Interactable_ShouldApplyInteractBlocker::OtherActor' has a wrong offset!");
static_assert(offsetof(HWInterface_Interactable_ShouldApplyInteractBlocker, ReturnValue) == 0x000010, "Member 'HWInterface_Interactable_ShouldApplyInteractBlocker::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Danzaburou_A03.BreakIllusion
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Danzaburou_A03_BreakIllusion final
{
public:
	bool                                          bInShouldDestroy;                                  // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Danzaburou_A03_BreakIllusion) == 0x000001, "Wrong alignment on HWDeployable_Danzaburou_A03_BreakIllusion");
static_assert(sizeof(HWDeployable_Danzaburou_A03_BreakIllusion) == 0x000001, "Wrong size on HWDeployable_Danzaburou_A03_BreakIllusion");
static_assert(offsetof(HWDeployable_Danzaburou_A03_BreakIllusion, bInShouldDestroy) == 0x000000, "Member 'HWDeployable_Danzaburou_A03_BreakIllusion::bInShouldDestroy' has a wrong offset!");

// Function Hemingway.HWDeployable_Danzaburou_A03.OnDanzaburouDamaged
// 0x0070 (0x0070 - 0x0000)
struct HWDeployable_Danzaburou_A03_OnDanzaburouDamaged final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Danzaburou_A03_OnDanzaburouDamaged) == 0x000008, "Wrong alignment on HWDeployable_Danzaburou_A03_OnDanzaburouDamaged");
static_assert(sizeof(HWDeployable_Danzaburou_A03_OnDanzaburouDamaged) == 0x000070, "Wrong size on HWDeployable_Danzaburou_A03_OnDanzaburouDamaged");
static_assert(offsetof(HWDeployable_Danzaburou_A03_OnDanzaburouDamaged, DamageEventData) == 0x000000, "Member 'HWDeployable_Danzaburou_A03_OnDanzaburouDamaged::DamageEventData' has a wrong offset!");

// Function Hemingway.HWDeployable_Danzaburou_A03.OnDanzaburouFired
// 0x0030 (0x0030 - 0x0000)
struct HWDeployable_Danzaburou_A03_OnDanzaburouFired final
{
public:
	struct FGameplayAbilitySpecHandle             InSpecHandle;                                      // 0x0000(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  InTags;                                            // 0x0008(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             InFiringInstanceId;                                // 0x0028(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Danzaburou_A03_OnDanzaburouFired) == 0x000008, "Wrong alignment on HWDeployable_Danzaburou_A03_OnDanzaburouFired");
static_assert(sizeof(HWDeployable_Danzaburou_A03_OnDanzaburouFired) == 0x000030, "Wrong size on HWDeployable_Danzaburou_A03_OnDanzaburouFired");
static_assert(offsetof(HWDeployable_Danzaburou_A03_OnDanzaburouFired, InSpecHandle) == 0x000000, "Member 'HWDeployable_Danzaburou_A03_OnDanzaburouFired::InSpecHandle' has a wrong offset!");
static_assert(offsetof(HWDeployable_Danzaburou_A03_OnDanzaburouFired, InTags) == 0x000008, "Member 'HWDeployable_Danzaburou_A03_OnDanzaburouFired::InTags' has a wrong offset!");
static_assert(offsetof(HWDeployable_Danzaburou_A03_OnDanzaburouFired, InFiringInstanceId) == 0x000028, "Member 'HWDeployable_Danzaburou_A03_OnDanzaburouFired::InFiringInstanceId' has a wrong offset!");

// Function Hemingway.HWDeployable_Danzaburou_A03.CanBreakIllusion
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Danzaburou_A03_CanBreakIllusion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Danzaburou_A03_CanBreakIllusion) == 0x000001, "Wrong alignment on HWDeployable_Danzaburou_A03_CanBreakIllusion");
static_assert(sizeof(HWDeployable_Danzaburou_A03_CanBreakIllusion) == 0x000001, "Wrong size on HWDeployable_Danzaburou_A03_CanBreakIllusion");
static_assert(offsetof(HWDeployable_Danzaburou_A03_CanBreakIllusion, ReturnValue) == 0x000000, "Member 'HWDeployable_Danzaburou_A03_CanBreakIllusion::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Danzaburou_A03.CanTriggerExplosion
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Danzaburou_A03_CanTriggerExplosion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Danzaburou_A03_CanTriggerExplosion) == 0x000001, "Wrong alignment on HWDeployable_Danzaburou_A03_CanTriggerExplosion");
static_assert(sizeof(HWDeployable_Danzaburou_A03_CanTriggerExplosion) == 0x000001, "Wrong size on HWDeployable_Danzaburou_A03_CanTriggerExplosion");
static_assert(offsetof(HWDeployable_Danzaburou_A03_CanTriggerExplosion, ReturnValue) == 0x000000, "Member 'HWDeployable_Danzaburou_A03_CanTriggerExplosion::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Danzaburou_A03.IsDanzaburouFiringAttacks
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Danzaburou_A03_IsDanzaburouFiringAttacks final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Danzaburou_A03_IsDanzaburouFiringAttacks) == 0x000001, "Wrong alignment on HWDeployable_Danzaburou_A03_IsDanzaburouFiringAttacks");
static_assert(sizeof(HWDeployable_Danzaburou_A03_IsDanzaburouFiringAttacks) == 0x000001, "Wrong size on HWDeployable_Danzaburou_A03_IsDanzaburouFiringAttacks");
static_assert(offsetof(HWDeployable_Danzaburou_A03_IsDanzaburouFiringAttacks, ReturnValue) == 0x000000, "Member 'HWDeployable_Danzaburou_A03_IsDanzaburouFiringAttacks::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_RefireableActor.CanRefire
// 0x0001 (0x0001 - 0x0000)
struct HWInterface_RefireableActor_CanRefire final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_RefireableActor_CanRefire) == 0x000001, "Wrong alignment on HWInterface_RefireableActor_CanRefire");
static_assert(sizeof(HWInterface_RefireableActor_CanRefire) == 0x000001, "Wrong size on HWInterface_RefireableActor_CanRefire");
static_assert(offsetof(HWInterface_RefireableActor_CanRefire, ReturnValue) == 0x000000, "Member 'HWInterface_RefireableActor_CanRefire::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_TransformOverrideActor.GetCustomTransformOverride
// 0x0060 (0x0060 - 0x0000)
struct HWInterface_TransformOverrideActor_GetCustomTransformOverride final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_TransformOverrideActor_GetCustomTransformOverride) == 0x000010, "Wrong alignment on HWInterface_TransformOverrideActor_GetCustomTransformOverride");
static_assert(sizeof(HWInterface_TransformOverrideActor_GetCustomTransformOverride) == 0x000060, "Wrong size on HWInterface_TransformOverrideActor_GetCustomTransformOverride");
static_assert(offsetof(HWInterface_TransformOverrideActor_GetCustomTransformOverride, ReturnValue) == 0x000000, "Member 'HWInterface_TransformOverrideActor_GetCustomTransformOverride::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractable_Hecate_PSV.HandleOnNewSkinTagAsset
// 0x0010 (0x0010 - 0x0000)
struct HWInteractable_Hecate_PSV_HandleOnNewSkinTagAsset final
{
public:
	TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractable_Hecate_PSV_HandleOnNewSkinTagAsset) == 0x000008, "Wrong alignment on HWInteractable_Hecate_PSV_HandleOnNewSkinTagAsset");
static_assert(sizeof(HWInteractable_Hecate_PSV_HandleOnNewSkinTagAsset) == 0x000010, "Wrong size on HWInteractable_Hecate_PSV_HandleOnNewSkinTagAsset");
static_assert(offsetof(HWInteractable_Hecate_PSV_HandleOnNewSkinTagAsset, NewSkinTagAsset) == 0x000000, "Member 'HWInteractable_Hecate_PSV_HandleOnNewSkinTagAsset::NewSkinTagAsset' has a wrong offset!");

// Function Hemingway.HWInteractable_Hecate_PSV.HandleOnSkinTagAssetRemoved
// 0x0010 (0x0010 - 0x0000)
struct HWInteractable_Hecate_PSV_HandleOnSkinTagAssetRemoved final
{
public:
	TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove;                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractable_Hecate_PSV_HandleOnSkinTagAssetRemoved) == 0x000008, "Wrong alignment on HWInteractable_Hecate_PSV_HandleOnSkinTagAssetRemoved");
static_assert(sizeof(HWInteractable_Hecate_PSV_HandleOnSkinTagAssetRemoved) == 0x000010, "Wrong size on HWInteractable_Hecate_PSV_HandleOnSkinTagAssetRemoved");
static_assert(offsetof(HWInteractable_Hecate_PSV_HandleOnSkinTagAssetRemoved, SkinTagAssetToRemove) == 0x000000, "Member 'HWInteractable_Hecate_PSV_HandleOnSkinTagAssetRemoved::SkinTagAssetToRemove' has a wrong offset!");

// Function Hemingway.HWInteractable_Hecate_PSV.HandleTagUpdated_AttachedActorDied
// 0x000C (0x000C - 0x0000)
struct HWInteractable_Hecate_PSV_HandleTagUpdated_AttachedActorDied final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractable_Hecate_PSV_HandleTagUpdated_AttachedActorDied) == 0x000004, "Wrong alignment on HWInteractable_Hecate_PSV_HandleTagUpdated_AttachedActorDied");
static_assert(sizeof(HWInteractable_Hecate_PSV_HandleTagUpdated_AttachedActorDied) == 0x00000C, "Wrong size on HWInteractable_Hecate_PSV_HandleTagUpdated_AttachedActorDied");
static_assert(offsetof(HWInteractable_Hecate_PSV_HandleTagUpdated_AttachedActorDied, CallbackTag) == 0x000000, "Member 'HWInteractable_Hecate_PSV_HandleTagUpdated_AttachedActorDied::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWInteractable_Hecate_PSV_HandleTagUpdated_AttachedActorDied, NewCount) == 0x000008, "Member 'HWInteractable_Hecate_PSV_HandleTagUpdated_AttachedActorDied::NewCount' has a wrong offset!");

// Function Hemingway.HWInteractable_Hecate_PSV.OnInteractionCancelled
// 0x0010 (0x0010 - 0x0000)
struct HWInteractable_Hecate_PSV_OnInteractionCancelled final
{
public:
	class UHWInteractableComponent*               InInteractComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InteractInstigator;                                // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractable_Hecate_PSV_OnInteractionCancelled) == 0x000008, "Wrong alignment on HWInteractable_Hecate_PSV_OnInteractionCancelled");
static_assert(sizeof(HWInteractable_Hecate_PSV_OnInteractionCancelled) == 0x000010, "Wrong size on HWInteractable_Hecate_PSV_OnInteractionCancelled");
static_assert(offsetof(HWInteractable_Hecate_PSV_OnInteractionCancelled, InInteractComponent) == 0x000000, "Member 'HWInteractable_Hecate_PSV_OnInteractionCancelled::InInteractComponent' has a wrong offset!");
static_assert(offsetof(HWInteractable_Hecate_PSV_OnInteractionCancelled, InteractInstigator) == 0x000008, "Member 'HWInteractable_Hecate_PSV_OnInteractionCancelled::InteractInstigator' has a wrong offset!");

// Function Hemingway.HWInteractable_Hecate_PSV.OnInteractionCompleted
// 0x0010 (0x0010 - 0x0000)
struct HWInteractable_Hecate_PSV_OnInteractionCompleted final
{
public:
	class UHWInteractableComponent*               InInteractComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InteractInstigator;                                // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractable_Hecate_PSV_OnInteractionCompleted) == 0x000008, "Wrong alignment on HWInteractable_Hecate_PSV_OnInteractionCompleted");
static_assert(sizeof(HWInteractable_Hecate_PSV_OnInteractionCompleted) == 0x000010, "Wrong size on HWInteractable_Hecate_PSV_OnInteractionCompleted");
static_assert(offsetof(HWInteractable_Hecate_PSV_OnInteractionCompleted, InInteractComponent) == 0x000000, "Member 'HWInteractable_Hecate_PSV_OnInteractionCompleted::InInteractComponent' has a wrong offset!");
static_assert(offsetof(HWInteractable_Hecate_PSV_OnInteractionCompleted, InteractInstigator) == 0x000008, "Member 'HWInteractable_Hecate_PSV_OnInteractionCompleted::InteractInstigator' has a wrong offset!");

// Function Hemingway.HWInteractable_Hecate_PSV.SwapSkinTags
// 0x0010 (0x0010 - 0x0000)
struct HWInteractable_Hecate_PSV_SwapSkinTags final
{
public:
	struct FGameplayTag                           NewSkinTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OldSkinTag;                                        // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractable_Hecate_PSV_SwapSkinTags) == 0x000004, "Wrong alignment on HWInteractable_Hecate_PSV_SwapSkinTags");
static_assert(sizeof(HWInteractable_Hecate_PSV_SwapSkinTags) == 0x000010, "Wrong size on HWInteractable_Hecate_PSV_SwapSkinTags");
static_assert(offsetof(HWInteractable_Hecate_PSV_SwapSkinTags, NewSkinTag) == 0x000000, "Member 'HWInteractable_Hecate_PSV_SwapSkinTags::NewSkinTag' has a wrong offset!");
static_assert(offsetof(HWInteractable_Hecate_PSV_SwapSkinTags, OldSkinTag) == 0x000008, "Member 'HWInteractable_Hecate_PSV_SwapSkinTags::OldSkinTag' has a wrong offset!");

// Function Hemingway.HWInteractable_Hecate_PSV.CanBeActivated
// 0x0001 (0x0001 - 0x0000)
struct HWInteractable_Hecate_PSV_CanBeActivated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractable_Hecate_PSV_CanBeActivated) == 0x000001, "Wrong alignment on HWInteractable_Hecate_PSV_CanBeActivated");
static_assert(sizeof(HWInteractable_Hecate_PSV_CanBeActivated) == 0x000001, "Wrong size on HWInteractable_Hecate_PSV_CanBeActivated");
static_assert(offsetof(HWInteractable_Hecate_PSV_CanBeActivated, ReturnValue) == 0x000000, "Member 'HWInteractable_Hecate_PSV_CanBeActivated::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractable_Hecate_PSV.GetCurrentSkin
// 0x0008 (0x0008 - 0x0000)
struct HWInteractable_Hecate_PSV_GetCurrentSkin final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractable_Hecate_PSV_GetCurrentSkin) == 0x000008, "Wrong alignment on HWInteractable_Hecate_PSV_GetCurrentSkin");
static_assert(sizeof(HWInteractable_Hecate_PSV_GetCurrentSkin) == 0x000008, "Wrong size on HWInteractable_Hecate_PSV_GetCurrentSkin");
static_assert(offsetof(HWInteractable_Hecate_PSV_GetCurrentSkin, ReturnValue) == 0x000000, "Member 'HWInteractable_Hecate_PSV_GetCurrentSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInteractable_Hecate_PSV.GetHecateOwner
// 0x0008 (0x0008 - 0x0000)
struct HWInteractable_Hecate_PSV_GetHecateOwner final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInteractable_Hecate_PSV_GetHecateOwner) == 0x000008, "Wrong alignment on HWInteractable_Hecate_PSV_GetHecateOwner");
static_assert(sizeof(HWInteractable_Hecate_PSV_GetHecateOwner) == 0x000008, "Wrong size on HWInteractable_Hecate_PSV_GetHecateOwner");
static_assert(offsetof(HWInteractable_Hecate_PSV_GetHecateOwner, ReturnValue) == 0x000000, "Member 'HWInteractable_Hecate_PSV_GetHecateOwner::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_VoiceComponent.TriggerLocalVoiceEvent
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_VoiceComponent_TriggerLocalVoiceEvent final
{
public:
	struct FGameplayTag                           VoiceEvent;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_VoiceComponent_TriggerLocalVoiceEvent) == 0x000004, "Wrong alignment on HWInterface_VoiceComponent_TriggerLocalVoiceEvent");
static_assert(sizeof(HWInterface_VoiceComponent_TriggerLocalVoiceEvent) == 0x000008, "Wrong size on HWInterface_VoiceComponent_TriggerLocalVoiceEvent");
static_assert(offsetof(HWInterface_VoiceComponent_TriggerLocalVoiceEvent, VoiceEvent) == 0x000000, "Member 'HWInterface_VoiceComponent_TriggerLocalVoiceEvent::VoiceEvent' has a wrong offset!");

// Function Hemingway.HWInterface_VoiceComponent.GetVoiceComponent
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_VoiceComponent_GetVoiceComponent final
{
public:
	class UHWVoiceComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_VoiceComponent_GetVoiceComponent) == 0x000008, "Wrong alignment on HWInterface_VoiceComponent_GetVoiceComponent");
static_assert(sizeof(HWInterface_VoiceComponent_GetVoiceComponent) == 0x000008, "Wrong size on HWInterface_VoiceComponent_GetVoiceComponent");
static_assert(offsetof(HWInterface_VoiceComponent_GetVoiceComponent, ReturnValue) == 0x000000, "Member 'HWInterface_VoiceComponent_GetVoiceComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EquipmentSystem.EqualEqual_FHWInventorySlot
// 0x001C (0x001C - 0x0000)
struct HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot final
{
public:
	struct FHWInventorySlot                       A;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       B;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot) == 0x000004, "Wrong alignment on HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot");
static_assert(sizeof(HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot) == 0x00001C, "Wrong size on HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot");
static_assert(offsetof(HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot, A) == 0x000000, "Member 'HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot, B) == 0x00000C, "Member 'HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot, ReturnValue) == 0x000018, "Member 'HWLibrary_EquipmentSystem_EqualEqual_FHWInventorySlot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EquipmentSystem.GetEquipmentLevelFromEffectContext
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_EquipmentSystem_GetEquipmentLevelFromEffectContext final
{
public:
	struct FGameplayEffectContextHandle           ContextHandle;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EquipmentSystem_GetEquipmentLevelFromEffectContext) == 0x000008, "Wrong alignment on HWLibrary_EquipmentSystem_GetEquipmentLevelFromEffectContext");
static_assert(sizeof(HWLibrary_EquipmentSystem_GetEquipmentLevelFromEffectContext) == 0x000020, "Wrong size on HWLibrary_EquipmentSystem_GetEquipmentLevelFromEffectContext");
static_assert(offsetof(HWLibrary_EquipmentSystem_GetEquipmentLevelFromEffectContext, ContextHandle) == 0x000000, "Member 'HWLibrary_EquipmentSystem_GetEquipmentLevelFromEffectContext::ContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_EquipmentSystem_GetEquipmentLevelFromEffectContext, ReturnValue) == 0x000018, "Member 'HWLibrary_EquipmentSystem_GetEquipmentLevelFromEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EquipmentSystem.GetInventorySlotFromAbility
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_EquipmentSystem_GetInventorySlotFromAbility final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySystemComponent*              OwningAbilitySystem;                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EquipmentSystem_GetInventorySlotFromAbility) == 0x000008, "Wrong alignment on HWLibrary_EquipmentSystem_GetInventorySlotFromAbility");
static_assert(sizeof(HWLibrary_EquipmentSystem_GetInventorySlotFromAbility) == 0x000020, "Wrong size on HWLibrary_EquipmentSystem_GetInventorySlotFromAbility");
static_assert(offsetof(HWLibrary_EquipmentSystem_GetInventorySlotFromAbility, AbilityHandle) == 0x000000, "Member 'HWLibrary_EquipmentSystem_GetInventorySlotFromAbility::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_EquipmentSystem_GetInventorySlotFromAbility, OwningAbilitySystem) == 0x000008, "Member 'HWLibrary_EquipmentSystem_GetInventorySlotFromAbility::OwningAbilitySystem' has a wrong offset!");
static_assert(offsetof(HWLibrary_EquipmentSystem_GetInventorySlotFromAbility, ReturnValue) == 0x000010, "Member 'HWLibrary_EquipmentSystem_GetInventorySlotFromAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EquipmentSystem.NotEqual_FHWInventorySlot
// 0x001C (0x001C - 0x0000)
struct HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot final
{
public:
	struct FHWInventorySlot                       A;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       B;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot) == 0x000004, "Wrong alignment on HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot");
static_assert(sizeof(HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot) == 0x00001C, "Wrong size on HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot");
static_assert(offsetof(HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot, A) == 0x000000, "Member 'HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot, B) == 0x00000C, "Member 'HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot, ReturnValue) == 0x000018, "Member 'HWLibrary_EquipmentSystem_NotEqual_FHWInventorySlot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.BP_OnLandingTargetingCancelled
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingCancelled final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetingData;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingCancelled) == 0x000008, "Wrong alignment on HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingCancelled");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingCancelled) == 0x000028, "Wrong size on HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingCancelled");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingCancelled, TargetingData) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingCancelled::TargetingData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.BP_OnLandingTargetingConfirmed
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingConfirmed final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetingData;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingConfirmed) == 0x000008, "Wrong alignment on HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingConfirmed");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingConfirmed) == 0x000028, "Wrong size on HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingConfirmed");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingConfirmed, TargetingData) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_BP_OnLandingTargetingConfirmed::TargetingData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.GetBackwardDeployableTargetData
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_JingWei_A04_GetBackwardDeployableTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_GetBackwardDeployableTargetData) == 0x000008, "Wrong alignment on HWGameplayAbility_JingWei_A04_GetBackwardDeployableTargetData");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_GetBackwardDeployableTargetData) == 0x000028, "Wrong size on HWGameplayAbility_JingWei_A04_GetBackwardDeployableTargetData");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_GetBackwardDeployableTargetData, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_GetBackwardDeployableTargetData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.GetBackwardProjectileTargetData
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_JingWei_A04_GetBackwardProjectileTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_GetBackwardProjectileTargetData) == 0x000008, "Wrong alignment on HWGameplayAbility_JingWei_A04_GetBackwardProjectileTargetData");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_GetBackwardProjectileTargetData) == 0x000028, "Wrong size on HWGameplayAbility_JingWei_A04_GetBackwardProjectileTargetData");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_GetBackwardProjectileTargetData, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_GetBackwardProjectileTargetData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.GetTweenBackwardTargetData
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_JingWei_A04_GetTweenBackwardTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_GetTweenBackwardTargetData) == 0x000008, "Wrong alignment on HWGameplayAbility_JingWei_A04_GetTweenBackwardTargetData");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_GetTweenBackwardTargetData) == 0x000028, "Wrong size on HWGameplayAbility_JingWei_A04_GetTweenBackwardTargetData");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_GetTweenBackwardTargetData, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_GetTweenBackwardTargetData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.GetTweenForwardTargetData
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_JingWei_A04_GetTweenForwardTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_GetTweenForwardTargetData) == 0x000008, "Wrong alignment on HWGameplayAbility_JingWei_A04_GetTweenForwardTargetData");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_GetTweenForwardTargetData) == 0x000028, "Wrong size on HWGameplayAbility_JingWei_A04_GetTweenForwardTargetData");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_GetTweenForwardTargetData, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_GetTweenForwardTargetData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.OnLandingCastStyleCancelled
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_JingWei_A04_OnLandingCastStyleCancelled final
{
public:
	float                                         TimeElapsed;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputReleased;                                    // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_OnLandingCastStyleCancelled) == 0x000004, "Wrong alignment on HWGameplayAbility_JingWei_A04_OnLandingCastStyleCancelled");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_OnLandingCastStyleCancelled) == 0x000008, "Wrong size on HWGameplayAbility_JingWei_A04_OnLandingCastStyleCancelled");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_OnLandingCastStyleCancelled, TimeElapsed) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_OnLandingCastStyleCancelled::TimeElapsed' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_OnLandingCastStyleCancelled, bInputReleased) == 0x000004, "Member 'HWGameplayAbility_JingWei_A04_OnLandingCastStyleCancelled::bInputReleased' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.OnLandingCastStyleConfirmed
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_JingWei_A04_OnLandingCastStyleConfirmed final
{
public:
	float                                         TimeElapsed;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputReleased;                                    // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_OnLandingCastStyleConfirmed) == 0x000004, "Wrong alignment on HWGameplayAbility_JingWei_A04_OnLandingCastStyleConfirmed");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_OnLandingCastStyleConfirmed) == 0x000008, "Wrong size on HWGameplayAbility_JingWei_A04_OnLandingCastStyleConfirmed");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_OnLandingCastStyleConfirmed, TimeElapsed) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_OnLandingCastStyleConfirmed::TimeElapsed' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_OnLandingCastStyleConfirmed, bInputReleased) == 0x000004, "Member 'HWGameplayAbility_JingWei_A04_OnLandingCastStyleConfirmed::bInputReleased' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.OnLandingTargetingCancelled
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_JingWei_A04_OnLandingTargetingCancelled final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetingData;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_OnLandingTargetingCancelled) == 0x000008, "Wrong alignment on HWGameplayAbility_JingWei_A04_OnLandingTargetingCancelled");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_OnLandingTargetingCancelled) == 0x000028, "Wrong size on HWGameplayAbility_JingWei_A04_OnLandingTargetingCancelled");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_OnLandingTargetingCancelled, TargetingData) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_OnLandingTargetingCancelled::TargetingData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.OnLandingTargetingConfirmed
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_JingWei_A04_OnLandingTargetingConfirmed final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetingData;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_OnLandingTargetingConfirmed) == 0x000008, "Wrong alignment on HWGameplayAbility_JingWei_A04_OnLandingTargetingConfirmed");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_OnLandingTargetingConfirmed) == 0x000028, "Wrong size on HWGameplayAbility_JingWei_A04_OnLandingTargetingConfirmed");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_OnLandingTargetingConfirmed, TargetingData) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_OnLandingTargetingConfirmed::TargetingData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_JingWei_A04.GetForwardTargetData
// 0x0028 (0x0028 - 0x0000)
struct HWGameplayAbility_JingWei_A04_GetForwardTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_JingWei_A04_GetForwardTargetData) == 0x000008, "Wrong alignment on HWGameplayAbility_JingWei_A04_GetForwardTargetData");
static_assert(sizeof(HWGameplayAbility_JingWei_A04_GetForwardTargetData) == 0x000028, "Wrong size on HWGameplayAbility_JingWei_A04_GetForwardTargetData");
static_assert(offsetof(HWGameplayAbility_JingWei_A04_GetForwardTargetData, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_JingWei_A04_GetForwardTargetData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.BroadcastGameplayTagEvent
// 0x000C (0x000C - 0x0000)
struct HWPassiveMeterComponent_BroadcastGameplayTagEvent final
{
public:
	struct FGameplayTag                           EventGameplayTag;                                  // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stack;                                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_BroadcastGameplayTagEvent) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_BroadcastGameplayTagEvent");
static_assert(sizeof(HWPassiveMeterComponent_BroadcastGameplayTagEvent) == 0x00000C, "Wrong size on HWPassiveMeterComponent_BroadcastGameplayTagEvent");
static_assert(offsetof(HWPassiveMeterComponent_BroadcastGameplayTagEvent, EventGameplayTag) == 0x000000, "Member 'HWPassiveMeterComponent_BroadcastGameplayTagEvent::EventGameplayTag' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_BroadcastGameplayTagEvent, Stack) == 0x000008, "Member 'HWPassiveMeterComponent_BroadcastGameplayTagEvent::Stack' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.OnActiveFamiliarsUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWPassiveMeterComponent_OnActiveFamiliarsUpdated final
{
public:
	class UHWFamiliarManagerComponent*            FamiliarManager;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_OnActiveFamiliarsUpdated) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_OnActiveFamiliarsUpdated");
static_assert(sizeof(HWPassiveMeterComponent_OnActiveFamiliarsUpdated) == 0x000008, "Wrong size on HWPassiveMeterComponent_OnActiveFamiliarsUpdated");
static_assert(offsetof(HWPassiveMeterComponent_OnActiveFamiliarsUpdated, FamiliarManager) == 0x000000, "Member 'HWPassiveMeterComponent_OnActiveFamiliarsUpdated::FamiliarManager' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.OnFamiliarAdded
// 0x0050 (0x0050 - 0x0000)
struct HWPassiveMeterComponent_OnFamiliarAdded final
{
public:
	struct FHWActiveFamiliarInfo                  FamiliarInfo;                                      // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_OnFamiliarAdded) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_OnFamiliarAdded");
static_assert(sizeof(HWPassiveMeterComponent_OnFamiliarAdded) == 0x000050, "Wrong size on HWPassiveMeterComponent_OnFamiliarAdded");
static_assert(offsetof(HWPassiveMeterComponent_OnFamiliarAdded, FamiliarInfo) == 0x000000, "Member 'HWPassiveMeterComponent_OnFamiliarAdded::FamiliarInfo' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.OnFamiliarManagerChanged
// 0x0010 (0x0010 - 0x0000)
struct HWPassiveMeterComponent_OnFamiliarManagerChanged final
{
public:
	class AHWCharacterAbilitySystemActor*         CharacterAbilitySystemActor;                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWFamiliarManagerComponent*            NewFamiliarManager;                                // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_OnFamiliarManagerChanged) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_OnFamiliarManagerChanged");
static_assert(sizeof(HWPassiveMeterComponent_OnFamiliarManagerChanged) == 0x000010, "Wrong size on HWPassiveMeterComponent_OnFamiliarManagerChanged");
static_assert(offsetof(HWPassiveMeterComponent_OnFamiliarManagerChanged, CharacterAbilitySystemActor) == 0x000000, "Member 'HWPassiveMeterComponent_OnFamiliarManagerChanged::CharacterAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_OnFamiliarManagerChanged, NewFamiliarManager) == 0x000008, "Member 'HWPassiveMeterComponent_OnFamiliarManagerChanged::NewFamiliarManager' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.OnFamiliarRemoved
// 0x0050 (0x0050 - 0x0000)
struct HWPassiveMeterComponent_OnFamiliarRemoved final
{
public:
	struct FHWActiveFamiliarInfo                  FamiliarInfo;                                      // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_OnFamiliarRemoved) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_OnFamiliarRemoved");
static_assert(sizeof(HWPassiveMeterComponent_OnFamiliarRemoved) == 0x000050, "Wrong size on HWPassiveMeterComponent_OnFamiliarRemoved");
static_assert(offsetof(HWPassiveMeterComponent_OnFamiliarRemoved, FamiliarInfo) == 0x000000, "Member 'HWPassiveMeterComponent_OnFamiliarRemoved::FamiliarInfo' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.OnFamiliarTrackedAttributeChanged
// 0x0090 (0x0090 - 0x0000)
struct HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged final
{
public:
	struct FHWActiveFamiliarInfo                  FamiliarInfo;                                      // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     GameplayAttribute;                                 // 0x0050(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldValue;                                          // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x008C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged");
static_assert(sizeof(HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged) == 0x000090, "Wrong size on HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged");
static_assert(offsetof(HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged, FamiliarInfo) == 0x000000, "Member 'HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged::FamiliarInfo' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged, GameplayAttribute) == 0x000050, "Member 'HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged::GameplayAttribute' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged, OldValue) == 0x000088, "Member 'HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged::OldValue' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged, NewValue) == 0x00008C, "Member 'HWPassiveMeterComponent_OnFamiliarTrackedAttributeChanged::NewValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.OnInventoryManagerChanged
// 0x0010 (0x0010 - 0x0000)
struct HWPassiveMeterComponent_OnInventoryManagerChanged final
{
public:
	class AHWCharacterAbilitySystemActor*         CharacterAbilitySystemActor;                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWInventoryManagerComponent*           NewInventoryManager;                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_OnInventoryManagerChanged) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_OnInventoryManagerChanged");
static_assert(sizeof(HWPassiveMeterComponent_OnInventoryManagerChanged) == 0x000010, "Wrong size on HWPassiveMeterComponent_OnInventoryManagerChanged");
static_assert(offsetof(HWPassiveMeterComponent_OnInventoryManagerChanged, CharacterAbilitySystemActor) == 0x000000, "Member 'HWPassiveMeterComponent_OnInventoryManagerChanged::CharacterAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_OnInventoryManagerChanged, NewInventoryManager) == 0x000008, "Member 'HWPassiveMeterComponent_OnInventoryManagerChanged::NewInventoryManager' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.OnRep_FilledPips
// 0x0004 (0x0004 - 0x0000)
struct HWPassiveMeterComponent_OnRep_FilledPips final
{
public:
	int32                                         OldFilledPips;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_OnRep_FilledPips) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_OnRep_FilledPips");
static_assert(sizeof(HWPassiveMeterComponent_OnRep_FilledPips) == 0x000004, "Wrong size on HWPassiveMeterComponent_OnRep_FilledPips");
static_assert(offsetof(HWPassiveMeterComponent_OnRep_FilledPips, OldFilledPips) == 0x000000, "Member 'HWPassiveMeterComponent_OnRep_FilledPips::OldFilledPips' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.OnRep_LargePipData
// 0x0020 (0x0020 - 0x0000)
struct HWPassiveMeterComponent_OnRep_LargePipData final
{
public:
	struct FHWPassiveMeterLargePipData            OldLargePipData;                                   // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_OnRep_LargePipData) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_OnRep_LargePipData");
static_assert(sizeof(HWPassiveMeterComponent_OnRep_LargePipData) == 0x000020, "Wrong size on HWPassiveMeterComponent_OnRep_LargePipData");
static_assert(offsetof(HWPassiveMeterComponent_OnRep_LargePipData, OldLargePipData) == 0x000000, "Member 'HWPassiveMeterComponent_OnRep_LargePipData::OldLargePipData' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.OnRep_MeterFill
// 0x0004 (0x0004 - 0x0000)
struct HWPassiveMeterComponent_OnRep_MeterFill final
{
public:
	float                                         OldMeterFill;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_OnRep_MeterFill) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_OnRep_MeterFill");
static_assert(sizeof(HWPassiveMeterComponent_OnRep_MeterFill) == 0x000004, "Wrong size on HWPassiveMeterComponent_OnRep_MeterFill");
static_assert(offsetof(HWPassiveMeterComponent_OnRep_MeterFill, OldMeterFill) == 0x000000, "Member 'HWPassiveMeterComponent_OnRep_MeterFill::OldMeterFill' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.OnTrackedAttributeChanged
// 0x0040 (0x0040 - 0x0000)
struct HWPassiveMeterComponent_OnTrackedAttributeChanged final
{
public:
	struct FGameplayAttribute                     GameplayAttribute;                                 // 0x0000(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldValue;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_OnTrackedAttributeChanged) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_OnTrackedAttributeChanged");
static_assert(sizeof(HWPassiveMeterComponent_OnTrackedAttributeChanged) == 0x000040, "Wrong size on HWPassiveMeterComponent_OnTrackedAttributeChanged");
static_assert(offsetof(HWPassiveMeterComponent_OnTrackedAttributeChanged, GameplayAttribute) == 0x000000, "Member 'HWPassiveMeterComponent_OnTrackedAttributeChanged::GameplayAttribute' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_OnTrackedAttributeChanged, OldValue) == 0x000038, "Member 'HWPassiveMeterComponent_OnTrackedAttributeChanged::OldValue' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_OnTrackedAttributeChanged, NewValue) == 0x00003C, "Member 'HWPassiveMeterComponent_OnTrackedAttributeChanged::NewValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.RemoveDataField
// 0x0008 (0x0008 - 0x0000)
struct HWPassiveMeterComponent_RemoveDataField final
{
public:
	struct FGameplayTag                           InFieldTag;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_RemoveDataField) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_RemoveDataField");
static_assert(sizeof(HWPassiveMeterComponent_RemoveDataField) == 0x000008, "Wrong size on HWPassiveMeterComponent_RemoveDataField");
static_assert(offsetof(HWPassiveMeterComponent_RemoveDataField, InFieldTag) == 0x000000, "Member 'HWPassiveMeterComponent_RemoveDataField::InFieldTag' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.SetDataField
// 0x0020 (0x0020 - 0x0000)
struct HWPassiveMeterComponent_SetDataField final
{
public:
	struct FHWPassiveMeterDataField               InDataField;                                       // 0x0000(0x0020)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_SetDataField) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_SetDataField");
static_assert(sizeof(HWPassiveMeterComponent_SetDataField) == 0x000020, "Wrong size on HWPassiveMeterComponent_SetDataField");
static_assert(offsetof(HWPassiveMeterComponent_SetDataField, InDataField) == 0x000000, "Member 'HWPassiveMeterComponent_SetDataField::InDataField' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.SetDataFieldFloatValue
// 0x0010 (0x0010 - 0x0000)
struct HWPassiveMeterComponent_SetDataFieldFloatValue final
{
public:
	struct FGameplayTag                           InFieldTag;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InFloatValue;                                      // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InFloatValue2;                                     // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_SetDataFieldFloatValue) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_SetDataFieldFloatValue");
static_assert(sizeof(HWPassiveMeterComponent_SetDataFieldFloatValue) == 0x000010, "Wrong size on HWPassiveMeterComponent_SetDataFieldFloatValue");
static_assert(offsetof(HWPassiveMeterComponent_SetDataFieldFloatValue, InFieldTag) == 0x000000, "Member 'HWPassiveMeterComponent_SetDataFieldFloatValue::InFieldTag' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_SetDataFieldFloatValue, InFloatValue) == 0x000008, "Member 'HWPassiveMeterComponent_SetDataFieldFloatValue::InFloatValue' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_SetDataFieldFloatValue, InFloatValue2) == 0x00000C, "Member 'HWPassiveMeterComponent_SetDataFieldFloatValue::InFloatValue2' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.SetDataFieldIntValue
// 0x0010 (0x0010 - 0x0000)
struct HWPassiveMeterComponent_SetDataFieldIntValue final
{
public:
	struct FGameplayTag                           InFieldTag;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InIntValue;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InIntValue2;                                       // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_SetDataFieldIntValue) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_SetDataFieldIntValue");
static_assert(sizeof(HWPassiveMeterComponent_SetDataFieldIntValue) == 0x000010, "Wrong size on HWPassiveMeterComponent_SetDataFieldIntValue");
static_assert(offsetof(HWPassiveMeterComponent_SetDataFieldIntValue, InFieldTag) == 0x000000, "Member 'HWPassiveMeterComponent_SetDataFieldIntValue::InFieldTag' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_SetDataFieldIntValue, InIntValue) == 0x000008, "Member 'HWPassiveMeterComponent_SetDataFieldIntValue::InIntValue' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_SetDataFieldIntValue, InIntValue2) == 0x00000C, "Member 'HWPassiveMeterComponent_SetDataFieldIntValue::InIntValue2' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.SetDataFieldObjectValue
// 0x0010 (0x0010 - 0x0000)
struct HWPassiveMeterComponent_SetDataFieldObjectValue final
{
public:
	struct FGameplayTag                           InFieldTag;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_SetDataFieldObjectValue) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_SetDataFieldObjectValue");
static_assert(sizeof(HWPassiveMeterComponent_SetDataFieldObjectValue) == 0x000010, "Wrong size on HWPassiveMeterComponent_SetDataFieldObjectValue");
static_assert(offsetof(HWPassiveMeterComponent_SetDataFieldObjectValue, InFieldTag) == 0x000000, "Member 'HWPassiveMeterComponent_SetDataFieldObjectValue::InFieldTag' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_SetDataFieldObjectValue, InObject) == 0x000008, "Member 'HWPassiveMeterComponent_SetDataFieldObjectValue::InObject' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.SetFilledPips
// 0x0004 (0x0004 - 0x0000)
struct HWPassiveMeterComponent_SetFilledPips final
{
public:
	int32                                         InFilledPips;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_SetFilledPips) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_SetFilledPips");
static_assert(sizeof(HWPassiveMeterComponent_SetFilledPips) == 0x000004, "Wrong size on HWPassiveMeterComponent_SetFilledPips");
static_assert(offsetof(HWPassiveMeterComponent_SetFilledPips, InFilledPips) == 0x000000, "Member 'HWPassiveMeterComponent_SetFilledPips::InFilledPips' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.SetLargePipData
// 0x0020 (0x0020 - 0x0000)
struct HWPassiveMeterComponent_SetLargePipData final
{
public:
	struct FHWPassiveMeterLargePipData            InLargePipData;                                    // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_SetLargePipData) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_SetLargePipData");
static_assert(sizeof(HWPassiveMeterComponent_SetLargePipData) == 0x000020, "Wrong size on HWPassiveMeterComponent_SetLargePipData");
static_assert(offsetof(HWPassiveMeterComponent_SetLargePipData, InLargePipData) == 0x000000, "Member 'HWPassiveMeterComponent_SetLargePipData::InLargePipData' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.SetMeterFill
// 0x0004 (0x0004 - 0x0000)
struct HWPassiveMeterComponent_SetMeterFill final
{
public:
	float                                         InMeterFill;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_SetMeterFill) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_SetMeterFill");
static_assert(sizeof(HWPassiveMeterComponent_SetMeterFill) == 0x000004, "Wrong size on HWPassiveMeterComponent_SetMeterFill");
static_assert(offsetof(HWPassiveMeterComponent_SetMeterFill, InMeterFill) == 0x000000, "Member 'HWPassiveMeterComponent_SetMeterFill::InMeterFill' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.GetAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWPassiveMeterComponent_GetAbilitySystemComponent final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_GetAbilitySystemComponent) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_GetAbilitySystemComponent");
static_assert(sizeof(HWPassiveMeterComponent_GetAbilitySystemComponent) == 0x000008, "Wrong size on HWPassiveMeterComponent_GetAbilitySystemComponent");
static_assert(offsetof(HWPassiveMeterComponent_GetAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWPassiveMeterComponent_GetAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.GetAllDataFields
// 0x0010 (0x0010 - 0x0000)
struct HWPassiveMeterComponent_GetAllDataFields final
{
public:
	TArray<struct FHWPassiveMeterDataField>       ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_GetAllDataFields) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_GetAllDataFields");
static_assert(sizeof(HWPassiveMeterComponent_GetAllDataFields) == 0x000010, "Wrong size on HWPassiveMeterComponent_GetAllDataFields");
static_assert(offsetof(HWPassiveMeterComponent_GetAllDataFields, ReturnValue) == 0x000000, "Member 'HWPassiveMeterComponent_GetAllDataFields::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.GetCharacterAbilitySystemActor
// 0x0008 (0x0008 - 0x0000)
struct HWPassiveMeterComponent_GetCharacterAbilitySystemActor final
{
public:
	class AHWCharacterAbilitySystemActor*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_GetCharacterAbilitySystemActor) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_GetCharacterAbilitySystemActor");
static_assert(sizeof(HWPassiveMeterComponent_GetCharacterAbilitySystemActor) == 0x000008, "Wrong size on HWPassiveMeterComponent_GetCharacterAbilitySystemActor");
static_assert(offsetof(HWPassiveMeterComponent_GetCharacterAbilitySystemActor, ReturnValue) == 0x000000, "Member 'HWPassiveMeterComponent_GetCharacterAbilitySystemActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.GetDataFieldByTag
// 0x0030 (0x0030 - 0x0000)
struct HWPassiveMeterComponent_GetDataFieldByTag final
{
public:
	struct FGameplayTag                           InFieldTag;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWPassiveMeterDataField               OutDataField;                                      // 0x0008(0x0020)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPassiveMeterComponent_GetDataFieldByTag) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_GetDataFieldByTag");
static_assert(sizeof(HWPassiveMeterComponent_GetDataFieldByTag) == 0x000030, "Wrong size on HWPassiveMeterComponent_GetDataFieldByTag");
static_assert(offsetof(HWPassiveMeterComponent_GetDataFieldByTag, InFieldTag) == 0x000000, "Member 'HWPassiveMeterComponent_GetDataFieldByTag::InFieldTag' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_GetDataFieldByTag, OutDataField) == 0x000008, "Member 'HWPassiveMeterComponent_GetDataFieldByTag::OutDataField' has a wrong offset!");
static_assert(offsetof(HWPassiveMeterComponent_GetDataFieldByTag, ReturnValue) == 0x000028, "Member 'HWPassiveMeterComponent_GetDataFieldByTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.GetFilledPips
// 0x0004 (0x0004 - 0x0000)
struct HWPassiveMeterComponent_GetFilledPips final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_GetFilledPips) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_GetFilledPips");
static_assert(sizeof(HWPassiveMeterComponent_GetFilledPips) == 0x000004, "Wrong size on HWPassiveMeterComponent_GetFilledPips");
static_assert(offsetof(HWPassiveMeterComponent_GetFilledPips, ReturnValue) == 0x000000, "Member 'HWPassiveMeterComponent_GetFilledPips::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.GetLargePipData
// 0x0020 (0x0020 - 0x0000)
struct HWPassiveMeterComponent_GetLargePipData final
{
public:
	struct FHWPassiveMeterLargePipData            ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_GetLargePipData) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_GetLargePipData");
static_assert(sizeof(HWPassiveMeterComponent_GetLargePipData) == 0x000020, "Wrong size on HWPassiveMeterComponent_GetLargePipData");
static_assert(offsetof(HWPassiveMeterComponent_GetLargePipData, ReturnValue) == 0x000000, "Member 'HWPassiveMeterComponent_GetLargePipData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.GetMeterFill
// 0x0004 (0x0004 - 0x0000)
struct HWPassiveMeterComponent_GetMeterFill final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_GetMeterFill) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_GetMeterFill");
static_assert(sizeof(HWPassiveMeterComponent_GetMeterFill) == 0x000004, "Wrong size on HWPassiveMeterComponent_GetMeterFill");
static_assert(offsetof(HWPassiveMeterComponent_GetMeterFill, ReturnValue) == 0x000000, "Member 'HWPassiveMeterComponent_GetMeterFill::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.GetOwningInventoryManager
// 0x0008 (0x0008 - 0x0000)
struct HWPassiveMeterComponent_GetOwningInventoryManager final
{
public:
	class UHWInventoryManagerComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_GetOwningInventoryManager) == 0x000008, "Wrong alignment on HWPassiveMeterComponent_GetOwningInventoryManager");
static_assert(sizeof(HWPassiveMeterComponent_GetOwningInventoryManager) == 0x000008, "Wrong size on HWPassiveMeterComponent_GetOwningInventoryManager");
static_assert(offsetof(HWPassiveMeterComponent_GetOwningInventoryManager, ReturnValue) == 0x000000, "Member 'HWPassiveMeterComponent_GetOwningInventoryManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.GetShouldShowMeter
// 0x0001 (0x0001 - 0x0000)
struct HWPassiveMeterComponent_GetShouldShowMeter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_GetShouldShowMeter) == 0x000001, "Wrong alignment on HWPassiveMeterComponent_GetShouldShowMeter");
static_assert(sizeof(HWPassiveMeterComponent_GetShouldShowMeter) == 0x000001, "Wrong size on HWPassiveMeterComponent_GetShouldShowMeter");
static_assert(offsetof(HWPassiveMeterComponent_GetShouldShowMeter, ReturnValue) == 0x000000, "Member 'HWPassiveMeterComponent_GetShouldShowMeter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeterComponent.GetTotalPips
// 0x0004 (0x0004 - 0x0000)
struct HWPassiveMeterComponent_GetTotalPips final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeterComponent_GetTotalPips) == 0x000004, "Wrong alignment on HWPassiveMeterComponent_GetTotalPips");
static_assert(sizeof(HWPassiveMeterComponent_GetTotalPips) == 0x000004, "Wrong size on HWPassiveMeterComponent_GetTotalPips");
static_assert(offsetof(HWPassiveMeterComponent_GetTotalPips, ReturnValue) == 0x000000, "Member 'HWPassiveMeterComponent_GetTotalPips::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_PhysicsImpulse.CanAirJuggle
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_PhysicsImpulse_CanAirJuggle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_PhysicsImpulse_CanAirJuggle) == 0x000001, "Wrong alignment on HWGameplayEffect_PhysicsImpulse_CanAirJuggle");
static_assert(sizeof(HWGameplayEffect_PhysicsImpulse_CanAirJuggle) == 0x000001, "Wrong size on HWGameplayEffect_PhysicsImpulse_CanAirJuggle");
static_assert(offsetof(HWGameplayEffect_PhysicsImpulse_CanAirJuggle, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_PhysicsImpulse_CanAirJuggle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_PhysicsImpulse.GetHorizontalVelocity
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayEffect_PhysicsImpulse_GetHorizontalVelocity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_PhysicsImpulse_GetHorizontalVelocity) == 0x000004, "Wrong alignment on HWGameplayEffect_PhysicsImpulse_GetHorizontalVelocity");
static_assert(sizeof(HWGameplayEffect_PhysicsImpulse_GetHorizontalVelocity) == 0x000004, "Wrong size on HWGameplayEffect_PhysicsImpulse_GetHorizontalVelocity");
static_assert(offsetof(HWGameplayEffect_PhysicsImpulse_GetHorizontalVelocity, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_PhysicsImpulse_GetHorizontalVelocity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_PhysicsImpulse.GetImpulseHeight
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayEffect_PhysicsImpulse_GetImpulseHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_PhysicsImpulse_GetImpulseHeight) == 0x000004, "Wrong alignment on HWGameplayEffect_PhysicsImpulse_GetImpulseHeight");
static_assert(sizeof(HWGameplayEffect_PhysicsImpulse_GetImpulseHeight) == 0x000004, "Wrong size on HWGameplayEffect_PhysicsImpulse_GetImpulseHeight");
static_assert(offsetof(HWGameplayEffect_PhysicsImpulse_GetImpulseHeight, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_PhysicsImpulse_GetImpulseHeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_PhysicsImpulse.GetImpulseVectorOverrideType
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_PhysicsImpulse_GetImpulseVectorOverrideType final
{
public:
	EHWImpulseVectorOverrideType                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_PhysicsImpulse_GetImpulseVectorOverrideType) == 0x000001, "Wrong alignment on HWGameplayEffect_PhysicsImpulse_GetImpulseVectorOverrideType");
static_assert(sizeof(HWGameplayEffect_PhysicsImpulse_GetImpulseVectorOverrideType) == 0x000001, "Wrong size on HWGameplayEffect_PhysicsImpulse_GetImpulseVectorOverrideType");
static_assert(offsetof(HWGameplayEffect_PhysicsImpulse_GetImpulseVectorOverrideType, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_PhysicsImpulse_GetImpulseVectorOverrideType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_PhysicsImpulse.GetResetsHorizontalMomentum
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_PhysicsImpulse_GetResetsHorizontalMomentum final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_PhysicsImpulse_GetResetsHorizontalMomentum) == 0x000001, "Wrong alignment on HWGameplayEffect_PhysicsImpulse_GetResetsHorizontalMomentum");
static_assert(sizeof(HWGameplayEffect_PhysicsImpulse_GetResetsHorizontalMomentum) == 0x000001, "Wrong size on HWGameplayEffect_PhysicsImpulse_GetResetsHorizontalMomentum");
static_assert(offsetof(HWGameplayEffect_PhysicsImpulse_GetResetsHorizontalMomentum, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_PhysicsImpulse_GetResetsHorizontalMomentum::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_PhysicsImpulse.GetResetsVerticalMomentum
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_PhysicsImpulse_GetResetsVerticalMomentum final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_PhysicsImpulse_GetResetsVerticalMomentum) == 0x000001, "Wrong alignment on HWGameplayEffect_PhysicsImpulse_GetResetsVerticalMomentum");
static_assert(sizeof(HWGameplayEffect_PhysicsImpulse_GetResetsVerticalMomentum) == 0x000001, "Wrong size on HWGameplayEffect_PhysicsImpulse_GetResetsVerticalMomentum");
static_assert(offsetof(HWGameplayEffect_PhysicsImpulse_GetResetsVerticalMomentum, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_PhysicsImpulse_GetResetsVerticalMomentum::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_PhysicsImpulse.GetTimeInAir
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayEffect_PhysicsImpulse_GetTimeInAir final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_PhysicsImpulse_GetTimeInAir) == 0x000004, "Wrong alignment on HWGameplayEffect_PhysicsImpulse_GetTimeInAir");
static_assert(sizeof(HWGameplayEffect_PhysicsImpulse_GetTimeInAir) == 0x000004, "Wrong size on HWGameplayEffect_PhysicsImpulse_GetTimeInAir");
static_assert(offsetof(HWGameplayEffect_PhysicsImpulse_GetTimeInAir, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_PhysicsImpulse_GetTimeInAir::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_PhysicsImpulse.IsFixedHeightImpulse
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_PhysicsImpulse_IsFixedHeightImpulse final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_PhysicsImpulse_IsFixedHeightImpulse) == 0x000001, "Wrong alignment on HWGameplayEffect_PhysicsImpulse_IsFixedHeightImpulse");
static_assert(sizeof(HWGameplayEffect_PhysicsImpulse_IsFixedHeightImpulse) == 0x000001, "Wrong size on HWGameplayEffect_PhysicsImpulse_IsFixedHeightImpulse");
static_assert(offsetof(HWGameplayEffect_PhysicsImpulse_IsFixedHeightImpulse, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_PhysicsImpulse_IsFixedHeightImpulse::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_PhysicsImpulse.ShouldLandAtGroundHeight
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_PhysicsImpulse_ShouldLandAtGroundHeight final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_PhysicsImpulse_ShouldLandAtGroundHeight) == 0x000001, "Wrong alignment on HWGameplayEffect_PhysicsImpulse_ShouldLandAtGroundHeight");
static_assert(sizeof(HWGameplayEffect_PhysicsImpulse_ShouldLandAtGroundHeight) == 0x000001, "Wrong size on HWGameplayEffect_PhysicsImpulse_ShouldLandAtGroundHeight");
static_assert(offsetof(HWGameplayEffect_PhysicsImpulse_ShouldLandAtGroundHeight, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_PhysicsImpulse_ShouldLandAtGroundHeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_PhysicsImpulse.ShouldUseEffectCauserAsOrigin
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_PhysicsImpulse_ShouldUseEffectCauserAsOrigin final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_PhysicsImpulse_ShouldUseEffectCauserAsOrigin) == 0x000001, "Wrong alignment on HWGameplayEffect_PhysicsImpulse_ShouldUseEffectCauserAsOrigin");
static_assert(sizeof(HWGameplayEffect_PhysicsImpulse_ShouldUseEffectCauserAsOrigin) == 0x000001, "Wrong size on HWGameplayEffect_PhysicsImpulse_ShouldUseEffectCauserAsOrigin");
static_assert(offsetof(HWGameplayEffect_PhysicsImpulse_ShouldUseEffectCauserAsOrigin, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_PhysicsImpulse_ShouldUseEffectCauserAsOrigin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPassiveMeter_NuWa.HandleActiveGameplayEffectTimeChange
// 0x0010 (0x0010 - 0x0000)
struct HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange final
{
public:
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewStartTime;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewDuration;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange) == 0x000004, "Wrong alignment on HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange");
static_assert(sizeof(HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange) == 0x000010, "Wrong size on HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange");
static_assert(offsetof(HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange, EffectHandle) == 0x000000, "Member 'HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange::EffectHandle' has a wrong offset!");
static_assert(offsetof(HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange, NewStartTime) == 0x000008, "Member 'HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange::NewStartTime' has a wrong offset!");
static_assert(offsetof(HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange, NewDuration) == 0x00000C, "Member 'HWPassiveMeter_NuWa_HandleActiveGameplayEffectTimeChange::NewDuration' has a wrong offset!");

// Function Hemingway.HWPhaseLogic.GetChaosTeamState
// 0x0008 (0x0008 - 0x0000)
struct HWPhaseLogic_GetChaosTeamState final
{
public:
	class AHWTeamState*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPhaseLogic_GetChaosTeamState) == 0x000008, "Wrong alignment on HWPhaseLogic_GetChaosTeamState");
static_assert(sizeof(HWPhaseLogic_GetChaosTeamState) == 0x000008, "Wrong size on HWPhaseLogic_GetChaosTeamState");
static_assert(offsetof(HWPhaseLogic_GetChaosTeamState, ReturnValue) == 0x000000, "Member 'HWPhaseLogic_GetChaosTeamState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPhaseLogic.GetGameState
// 0x0008 (0x0008 - 0x0000)
struct HWPhaseLogic_GetGameState final
{
public:
	class AHWGameState*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPhaseLogic_GetGameState) == 0x000008, "Wrong alignment on HWPhaseLogic_GetGameState");
static_assert(sizeof(HWPhaseLogic_GetGameState) == 0x000008, "Wrong size on HWPhaseLogic_GetGameState");
static_assert(offsetof(HWPhaseLogic_GetGameState, ReturnValue) == 0x000000, "Member 'HWPhaseLogic_GetGameState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPhaseLogic.GetOrderTeamState
// 0x0008 (0x0008 - 0x0000)
struct HWPhaseLogic_GetOrderTeamState final
{
public:
	class AHWTeamState*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPhaseLogic_GetOrderTeamState) == 0x000008, "Wrong alignment on HWPhaseLogic_GetOrderTeamState");
static_assert(sizeof(HWPhaseLogic_GetOrderTeamState) == 0x000008, "Wrong size on HWPhaseLogic_GetOrderTeamState");
static_assert(offsetof(HWPhaseLogic_GetOrderTeamState, ReturnValue) == 0x000000, "Member 'HWPhaseLogic_GetOrderTeamState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPhaseLogic.GetTeamState
// 0x0010 (0x0010 - 0x0000)
struct HWPhaseLogic_GetTeamState final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWTeamState*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPhaseLogic_GetTeamState) == 0x000008, "Wrong alignment on HWPhaseLogic_GetTeamState");
static_assert(sizeof(HWPhaseLogic_GetTeamState) == 0x000010, "Wrong size on HWPhaseLogic_GetTeamState");
static_assert(offsetof(HWPhaseLogic_GetTeamState, TeamId) == 0x000000, "Member 'HWPhaseLogic_GetTeamState::TeamId' has a wrong offset!");
static_assert(offsetof(HWPhaseLogic_GetTeamState, ReturnValue) == 0x000008, "Member 'HWPhaseLogic_GetTeamState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPhaseLogic_Backfill.HandleKickDelegateResolved
// 0x00B8 (0x00B8 - 0x0000)
struct HWPhaseLogic_Backfill_HandleKickDelegateResolved final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URH_SessionView*                        pSession;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ErrorInfo                          ErrorInfo;                                         // 0x0010(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPhaseLogic_Backfill_HandleKickDelegateResolved) == 0x000008, "Wrong alignment on HWPhaseLogic_Backfill_HandleKickDelegateResolved");
static_assert(sizeof(HWPhaseLogic_Backfill_HandleKickDelegateResolved) == 0x0000B8, "Wrong size on HWPhaseLogic_Backfill_HandleKickDelegateResolved");
static_assert(offsetof(HWPhaseLogic_Backfill_HandleKickDelegateResolved, bSuccess) == 0x000000, "Member 'HWPhaseLogic_Backfill_HandleKickDelegateResolved::bSuccess' has a wrong offset!");
static_assert(offsetof(HWPhaseLogic_Backfill_HandleKickDelegateResolved, pSession) == 0x000008, "Member 'HWPhaseLogic_Backfill_HandleKickDelegateResolved::pSession' has a wrong offset!");
static_assert(offsetof(HWPhaseLogic_Backfill_HandleKickDelegateResolved, ErrorInfo) == 0x000010, "Member 'HWPhaseLogic_Backfill_HandleKickDelegateResolved::ErrorInfo' has a wrong offset!");

// Function Hemingway.HWPhaseLogic_Backfill.HandleSessionUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWPhaseLogic_Backfill_HandleSessionUpdated final
{
public:
	class URH_SessionView*                        SessionView;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPhaseLogic_Backfill_HandleSessionUpdated) == 0x000008, "Wrong alignment on HWPhaseLogic_Backfill_HandleSessionUpdated");
static_assert(sizeof(HWPhaseLogic_Backfill_HandleSessionUpdated) == 0x000008, "Wrong size on HWPhaseLogic_Backfill_HandleSessionUpdated");
static_assert(offsetof(HWPhaseLogic_Backfill_HandleSessionUpdated, SessionView) == 0x000000, "Member 'HWPhaseLogic_Backfill_HandleSessionUpdated::SessionView' has a wrong offset!");

// Function Hemingway.HWAbilityTask_FireAttack.FireAttack
// 0x00C0 (0x00C0 - 0x0000)
struct HWAbilityTask_FireAttack_FireAttack final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityAttackInstance               Attack;                                            // 0x0010(0x0080)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       AttackAimOverride_0;                               // 0x0090(0x0028)(ConstParm, Parm, NativeAccessSpecifierPublic)
	class UHWAbilityTask_FireAttack*              ReturnValue;                                       // 0x00B8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_FireAttack_FireAttack) == 0x000008, "Wrong alignment on HWAbilityTask_FireAttack_FireAttack");
static_assert(sizeof(HWAbilityTask_FireAttack_FireAttack) == 0x0000C0, "Wrong size on HWAbilityTask_FireAttack_FireAttack");
static_assert(offsetof(HWAbilityTask_FireAttack_FireAttack, OwningAbility) == 0x000000, "Member 'HWAbilityTask_FireAttack_FireAttack::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_FireAttack_FireAttack, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_FireAttack_FireAttack::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_FireAttack_FireAttack, Attack) == 0x000010, "Member 'HWAbilityTask_FireAttack_FireAttack::Attack' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_FireAttack_FireAttack, AttackAimOverride_0) == 0x000090, "Member 'HWAbilityTask_FireAttack_FireAttack::AttackAimOverride_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_FireAttack_FireAttack, ReturnValue) == 0x0000B8, "Member 'HWAbilityTask_FireAttack_FireAttack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_FireAttack.FireAttackById
// 0x0048 (0x0048 - 0x0000)
struct HWAbilityTask_FireAttack_FireAttackById final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ID;                                                // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       AttackAimOverride_0;                               // 0x0018(0x0028)(ConstParm, Parm, NativeAccessSpecifierPublic)
	class UHWAbilityTask_FireAttack*              ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_FireAttack_FireAttackById) == 0x000008, "Wrong alignment on HWAbilityTask_FireAttack_FireAttackById");
static_assert(sizeof(HWAbilityTask_FireAttack_FireAttackById) == 0x000048, "Wrong size on HWAbilityTask_FireAttack_FireAttackById");
static_assert(offsetof(HWAbilityTask_FireAttack_FireAttackById, OwningAbility) == 0x000000, "Member 'HWAbilityTask_FireAttack_FireAttackById::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_FireAttack_FireAttackById, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_FireAttack_FireAttackById::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_FireAttack_FireAttackById, ID) == 0x000010, "Member 'HWAbilityTask_FireAttack_FireAttackById::ID' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_FireAttack_FireAttackById, AttackAimOverride_0) == 0x000018, "Member 'HWAbilityTask_FireAttack_FireAttackById::AttackAimOverride_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_FireAttack_FireAttackById, ReturnValue) == 0x000040, "Member 'HWAbilityTask_FireAttack_FireAttackById::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_FireAttack.GetAttackAim
// 0x0028 (0x0028 - 0x0000)
struct HWAbilityTask_FireAttack_GetAttackAim final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_FireAttack_GetAttackAim) == 0x000008, "Wrong alignment on HWAbilityTask_FireAttack_GetAttackAim");
static_assert(sizeof(HWAbilityTask_FireAttack_GetAttackAim) == 0x000028, "Wrong size on HWAbilityTask_FireAttack_GetAttackAim");
static_assert(offsetof(HWAbilityTask_FireAttack_GetAttackAim, ReturnValue) == 0x000000, "Member 'HWAbilityTask_FireAttack_GetAttackAim::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_FireAttack.GetAttackAimOverride
// 0x0028 (0x0028 - 0x0000)
struct HWAbilityTask_FireAttack_GetAttackAimOverride final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_FireAttack_GetAttackAimOverride) == 0x000008, "Wrong alignment on HWAbilityTask_FireAttack_GetAttackAimOverride");
static_assert(sizeof(HWAbilityTask_FireAttack_GetAttackAimOverride) == 0x000028, "Wrong size on HWAbilityTask_FireAttack_GetAttackAimOverride");
static_assert(offsetof(HWAbilityTask_FireAttack_GetAttackAimOverride, ReturnValue) == 0x000000, "Member 'HWAbilityTask_FireAttack_GetAttackAimOverride::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_FireAttack.GetAttackId
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_FireAttack_GetAttackId final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_FireAttack_GetAttackId) == 0x000004, "Wrong alignment on HWAbilityTask_FireAttack_GetAttackId");
static_assert(sizeof(HWAbilityTask_FireAttack_GetAttackId) == 0x000008, "Wrong size on HWAbilityTask_FireAttack_GetAttackId");
static_assert(offsetof(HWAbilityTask_FireAttack_GetAttackId, ReturnValue) == 0x000000, "Member 'HWAbilityTask_FireAttack_GetAttackId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_FireAttack.GetAttackInstance
// 0x0080 (0x0080 - 0x0000)
struct HWAbilityTask_FireAttack_GetAttackInstance final
{
public:
	struct FHWAbilityAttackInstance               ReturnValue;                                       // 0x0000(0x0080)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_FireAttack_GetAttackInstance) == 0x000008, "Wrong alignment on HWAbilityTask_FireAttack_GetAttackInstance");
static_assert(sizeof(HWAbilityTask_FireAttack_GetAttackInstance) == 0x000080, "Wrong size on HWAbilityTask_FireAttack_GetAttackInstance");
static_assert(offsetof(HWAbilityTask_FireAttack_GetAttackInstance, ReturnValue) == 0x000000, "Member 'HWAbilityTask_FireAttack_GetAttackInstance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_CollisionProxy.HandleNewAvatarActor
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_Attack_CollisionProxy_HandleNewAvatarActor final
{
public:
	class AActor*                                 NewAvatarActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Attack_CollisionProxy_HandleNewAvatarActor) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_CollisionProxy_HandleNewAvatarActor");
static_assert(sizeof(HWAbilityTask_Attack_CollisionProxy_HandleNewAvatarActor) == 0x000008, "Wrong size on HWAbilityTask_Attack_CollisionProxy_HandleNewAvatarActor");
static_assert(offsetof(HWAbilityTask_Attack_CollisionProxy_HandleNewAvatarActor, NewAvatarActor) == 0x000000, "Member 'HWAbilityTask_Attack_CollisionProxy_HandleNewAvatarActor::NewAvatarActor' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_CollisionProxy.OnAbilityLevelChanged
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_Attack_CollisionProxy_OnAbilityLevelChanged final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Attack_CollisionProxy_OnAbilityLevelChanged) == 0x000004, "Wrong alignment on HWAbilityTask_Attack_CollisionProxy_OnAbilityLevelChanged");
static_assert(sizeof(HWAbilityTask_Attack_CollisionProxy_OnAbilityLevelChanged) == 0x000008, "Wrong size on HWAbilityTask_Attack_CollisionProxy_OnAbilityLevelChanged");
static_assert(offsetof(HWAbilityTask_Attack_CollisionProxy_OnAbilityLevelChanged, AbilityHandle) == 0x000000, "Member 'HWAbilityTask_Attack_CollisionProxy_OnAbilityLevelChanged::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_CollisionProxy_OnAbilityLevelChanged, Level) == 0x000004, "Member 'HWAbilityTask_Attack_CollisionProxy_OnAbilityLevelChanged::Level' has a wrong offset!");

// Function Hemingway.HWPhaseLogic_WaitForConnections.OnPlayerConnected
// 0x0008 (0x0008 - 0x0000)
struct HWPhaseLogic_WaitForConnections_OnPlayerConnected final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPhaseLogic_WaitForConnections_OnPlayerConnected) == 0x000008, "Wrong alignment on HWPhaseLogic_WaitForConnections_OnPlayerConnected");
static_assert(sizeof(HWPhaseLogic_WaitForConnections_OnPlayerConnected) == 0x000008, "Wrong size on HWPhaseLogic_WaitForConnections_OnPlayerConnected");
static_assert(offsetof(HWPhaseLogic_WaitForConnections_OnPlayerConnected, PlayerController) == 0x000000, "Member 'HWPhaseLogic_WaitForConnections_OnPlayerConnected::PlayerController' has a wrong offset!");

// Function Hemingway.HWPhaseLogic_WaitForConnections.OnSessionUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWPhaseLogic_WaitForConnections_OnSessionUpdated final
{
public:
	class URH_SessionView*                        SessionView;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPhaseLogic_WaitForConnections_OnSessionUpdated) == 0x000008, "Wrong alignment on HWPhaseLogic_WaitForConnections_OnSessionUpdated");
static_assert(sizeof(HWPhaseLogic_WaitForConnections_OnSessionUpdated) == 0x000008, "Wrong size on HWPhaseLogic_WaitForConnections_OnSessionUpdated");
static_assert(offsetof(HWPhaseLogic_WaitForConnections_OnSessionUpdated, SessionView) == 0x000000, "Member 'HWPhaseLogic_WaitForConnections_OnSessionUpdated::SessionView' has a wrong offset!");

// Function Hemingway.HWPingManager.AddPing
// 0x0030 (0x0030 - 0x0000)
struct HWPingManager_AddPing final
{
public:
	struct FGameplayTag                           PingTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PingLocation;                                      // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PingOwner;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWPingSource                                 PingSource;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendChatNotification;                             // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPingManager_AddPing) == 0x000008, "Wrong alignment on HWPingManager_AddPing");
static_assert(sizeof(HWPingManager_AddPing) == 0x000030, "Wrong size on HWPingManager_AddPing");
static_assert(offsetof(HWPingManager_AddPing, PingTag) == 0x000000, "Member 'HWPingManager_AddPing::PingTag' has a wrong offset!");
static_assert(offsetof(HWPingManager_AddPing, PingLocation) == 0x000008, "Member 'HWPingManager_AddPing::PingLocation' has a wrong offset!");
static_assert(offsetof(HWPingManager_AddPing, PingOwner) == 0x000020, "Member 'HWPingManager_AddPing::PingOwner' has a wrong offset!");
static_assert(offsetof(HWPingManager_AddPing, PingSource) == 0x000028, "Member 'HWPingManager_AddPing::PingSource' has a wrong offset!");
static_assert(offsetof(HWPingManager_AddPing, bSendChatNotification) == 0x000029, "Member 'HWPingManager_AddPing::bSendChatNotification' has a wrong offset!");

// Function Hemingway.HWPingManager.HandlePingActorRecycled
// 0x0008 (0x0008 - 0x0000)
struct HWPingManager_HandlePingActorRecycled final
{
public:
	class AHWPingWorldActor*                      InPingActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPingManager_HandlePingActorRecycled) == 0x000008, "Wrong alignment on HWPingManager_HandlePingActorRecycled");
static_assert(sizeof(HWPingManager_HandlePingActorRecycled) == 0x000008, "Wrong size on HWPingManager_HandlePingActorRecycled");
static_assert(offsetof(HWPingManager_HandlePingActorRecycled, InPingActor) == 0x000000, "Member 'HWPingManager_HandlePingActorRecycled::InPingActor' has a wrong offset!");

// Function Hemingway.HWPingManager.MulticastSendPing
// 0x0030 (0x0030 - 0x0000)
struct HWPingManager_MulticastSendPing final
{
public:
	struct FGameplayTag                           PingTag;                                           // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PingLocation;                                      // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PingOwner;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWPingSource                                 PingSource;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPingManager_MulticastSendPing) == 0x000008, "Wrong alignment on HWPingManager_MulticastSendPing");
static_assert(sizeof(HWPingManager_MulticastSendPing) == 0x000030, "Wrong size on HWPingManager_MulticastSendPing");
static_assert(offsetof(HWPingManager_MulticastSendPing, PingTag) == 0x000000, "Member 'HWPingManager_MulticastSendPing::PingTag' has a wrong offset!");
static_assert(offsetof(HWPingManager_MulticastSendPing, PingLocation) == 0x000008, "Member 'HWPingManager_MulticastSendPing::PingLocation' has a wrong offset!");
static_assert(offsetof(HWPingManager_MulticastSendPing, PingOwner) == 0x000020, "Member 'HWPingManager_MulticastSendPing::PingOwner' has a wrong offset!");
static_assert(offsetof(HWPingManager_MulticastSendPing, PingSource) == 0x000028, "Member 'HWPingManager_MulticastSendPing::PingSource' has a wrong offset!");

// Function Hemingway.HWPlaneOfExistenceVolume.GetPlaneIdentifierTag
// 0x0008 (0x0008 - 0x0000)
struct HWPlaneOfExistenceVolume_GetPlaneIdentifierTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlaneOfExistenceVolume_GetPlaneIdentifierTag) == 0x000004, "Wrong alignment on HWPlaneOfExistenceVolume_GetPlaneIdentifierTag");
static_assert(sizeof(HWPlaneOfExistenceVolume_GetPlaneIdentifierTag) == 0x000008, "Wrong size on HWPlaneOfExistenceVolume_GetPlaneIdentifierTag");
static_assert(offsetof(HWPlaneOfExistenceVolume_GetPlaneIdentifierTag, ReturnValue) == 0x000000, "Member 'HWPlaneOfExistenceVolume_GetPlaneIdentifierTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.GetCTAPath
// 0x0058 (0x0058 - 0x0000)
struct HWInventoryItem_GetCTAPath final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWInventoryItem>        Item;                                              // 0x0008(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             InItemId;                                          // 0x0030(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryItem_GetCTAPath) == 0x000008, "Wrong alignment on HWInventoryItem_GetCTAPath");
static_assert(sizeof(HWInventoryItem_GetCTAPath) == 0x000058, "Wrong size on HWInventoryItem_GetCTAPath");
static_assert(offsetof(HWInventoryItem_GetCTAPath, WorldContext) == 0x000000, "Member 'HWInventoryItem_GetCTAPath::WorldContext' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_GetCTAPath, Item) == 0x000008, "Member 'HWInventoryItem_GetCTAPath::Item' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_GetCTAPath, InItemId) == 0x000030, "Member 'HWInventoryItem_GetCTAPath::InItemId' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_GetCTAPath, ReturnValue) == 0x000048, "Member 'HWInventoryItem_GetCTAPath::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.GetItemDisabledReason
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryItem_GetItemDisabledReason final
{
public:
	struct FRH_ItemId                             InItemId;                                          // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWItemDisabledReason                         ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryItem_GetItemDisabledReason) == 0x000004, "Wrong alignment on HWInventoryItem_GetItemDisabledReason");
static_assert(sizeof(HWInventoryItem_GetItemDisabledReason) == 0x000018, "Wrong size on HWInventoryItem_GetItemDisabledReason");
static_assert(offsetof(HWInventoryItem_GetItemDisabledReason, InItemId) == 0x000000, "Member 'HWInventoryItem_GetItemDisabledReason::InItemId' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_GetItemDisabledReason, ReturnValue) == 0x000014, "Member 'HWInventoryItem_GetItemDisabledReason::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.GetItemIdOwnershipCount
// 0x0020 (0x0020 - 0x0000)
struct HWInventoryItem_GetItemIdOwnershipCount final
{
public:
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             InItemId;                                          // 0x0008(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryItem_GetItemIdOwnershipCount) == 0x000008, "Wrong alignment on HWInventoryItem_GetItemIdOwnershipCount");
static_assert(sizeof(HWInventoryItem_GetItemIdOwnershipCount) == 0x000020, "Wrong size on HWInventoryItem_GetItemIdOwnershipCount");
static_assert(offsetof(HWInventoryItem_GetItemIdOwnershipCount, PlayerInfo) == 0x000000, "Member 'HWInventoryItem_GetItemIdOwnershipCount::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_GetItemIdOwnershipCount, InItemId) == 0x000008, "Member 'HWInventoryItem_GetItemIdOwnershipCount::InItemId' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_GetItemIdOwnershipCount, ReturnValue) == 0x00001C, "Member 'HWInventoryItem_GetItemIdOwnershipCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.IsAlwaysOwnedItem
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryItem_IsAlwaysOwnedItem final
{
public:
	struct FRH_ItemId                             InItemId;                                          // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryItem_IsAlwaysOwnedItem) == 0x000004, "Wrong alignment on HWInventoryItem_IsAlwaysOwnedItem");
static_assert(sizeof(HWInventoryItem_IsAlwaysOwnedItem) == 0x000018, "Wrong size on HWInventoryItem_IsAlwaysOwnedItem");
static_assert(offsetof(HWInventoryItem_IsAlwaysOwnedItem, InItemId) == 0x000000, "Member 'HWInventoryItem_IsAlwaysOwnedItem::InItemId' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_IsAlwaysOwnedItem, ReturnValue) == 0x000014, "Member 'HWInventoryItem_IsAlwaysOwnedItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.IsItemEnabled
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryItem_IsItemEnabled final
{
public:
	struct FRH_ItemId                             InItemId;                                          // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckTempDisabled;                                // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryItem_IsItemEnabled) == 0x000004, "Wrong alignment on HWInventoryItem_IsItemEnabled");
static_assert(sizeof(HWInventoryItem_IsItemEnabled) == 0x000018, "Wrong size on HWInventoryItem_IsItemEnabled");
static_assert(offsetof(HWInventoryItem_IsItemEnabled, InItemId) == 0x000000, "Member 'HWInventoryItem_IsItemEnabled::InItemId' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_IsItemEnabled, bCheckTempDisabled) == 0x000014, "Member 'HWInventoryItem_IsItemEnabled::bCheckTempDisabled' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_IsItemEnabled, ReturnValue) == 0x000015, "Member 'HWInventoryItem_IsItemEnabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.ShouldShowCTA
// 0x0030 (0x0030 - 0x0000)
struct HWInventoryItem_ShouldShowCTA final
{
public:
	TSoftObjectPtr<class UHWInventoryItem>        Item;                                              // 0x0000(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryItem_ShouldShowCTA) == 0x000008, "Wrong alignment on HWInventoryItem_ShouldShowCTA");
static_assert(sizeof(HWInventoryItem_ShouldShowCTA) == 0x000030, "Wrong size on HWInventoryItem_ShouldShowCTA");
static_assert(offsetof(HWInventoryItem_ShouldShowCTA, Item) == 0x000000, "Member 'HWInventoryItem_ShouldShowCTA::Item' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_ShouldShowCTA, ReturnValue) == 0x000028, "Member 'HWInventoryItem_ShouldShowCTA::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.GetItemDisplayNameCAPS
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryItem_GetItemDisplayNameCAPS final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryItem_GetItemDisplayNameCAPS) == 0x000008, "Wrong alignment on HWInventoryItem_GetItemDisplayNameCAPS");
static_assert(sizeof(HWInventoryItem_GetItemDisplayNameCAPS) == 0x000018, "Wrong size on HWInventoryItem_GetItemDisplayNameCAPS");
static_assert(offsetof(HWInventoryItem_GetItemDisplayNameCAPS, ReturnValue) == 0x000000, "Member 'HWInventoryItem_GetItemDisplayNameCAPS::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.GetOwnershipCount
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryItem_GetOwnershipCount final
{
public:
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 CharacterContextItem;                              // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryItem_GetOwnershipCount) == 0x000008, "Wrong alignment on HWInventoryItem_GetOwnershipCount");
static_assert(sizeof(HWInventoryItem_GetOwnershipCount) == 0x000018, "Wrong size on HWInventoryItem_GetOwnershipCount");
static_assert(offsetof(HWInventoryItem_GetOwnershipCount, PlayerInfo) == 0x000000, "Member 'HWInventoryItem_GetOwnershipCount::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_GetOwnershipCount, CharacterContextItem) == 0x000008, "Member 'HWInventoryItem_GetOwnershipCount::CharacterContextItem' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_GetOwnershipCount, ReturnValue) == 0x000010, "Member 'HWInventoryItem_GetOwnershipCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.GetPendingPurchaseRequest
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryItem_GetPendingPurchaseRequest final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URHStorePurchaseRequest*                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryItem_GetPendingPurchaseRequest) == 0x000008, "Wrong alignment on HWInventoryItem_GetPendingPurchaseRequest");
static_assert(sizeof(HWInventoryItem_GetPendingPurchaseRequest) == 0x000010, "Wrong size on HWInventoryItem_GetPendingPurchaseRequest");
static_assert(offsetof(HWInventoryItem_GetPendingPurchaseRequest, WorldContextObject) == 0x000000, "Member 'HWInventoryItem_GetPendingPurchaseRequest::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_GetPendingPurchaseRequest, ReturnValue) == 0x000008, "Member 'HWInventoryItem_GetPendingPurchaseRequest::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.GetStoreItem
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryItem_GetStoreItem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URHStoreItem*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryItem_GetStoreItem) == 0x000008, "Wrong alignment on HWInventoryItem_GetStoreItem");
static_assert(sizeof(HWInventoryItem_GetStoreItem) == 0x000010, "Wrong size on HWInventoryItem_GetStoreItem");
static_assert(offsetof(HWInventoryItem_GetStoreItem, WorldContextObject) == 0x000000, "Member 'HWInventoryItem_GetStoreItem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_GetStoreItem, ReturnValue) == 0x000008, "Member 'HWInventoryItem_GetStoreItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.HasPendingPurchaseRequest
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryItem_HasPendingPurchaseRequest final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryItem_HasPendingPurchaseRequest) == 0x000008, "Wrong alignment on HWInventoryItem_HasPendingPurchaseRequest");
static_assert(sizeof(HWInventoryItem_HasPendingPurchaseRequest) == 0x000010, "Wrong size on HWInventoryItem_HasPendingPurchaseRequest");
static_assert(offsetof(HWInventoryItem_HasPendingPurchaseRequest, WorldContextObject) == 0x000000, "Member 'HWInventoryItem_HasPendingPurchaseRequest::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_HasPendingPurchaseRequest, ReturnValue) == 0x000008, "Member 'HWInventoryItem_HasPendingPurchaseRequest::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.IsOwnedCached
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryItem_IsOwnedCached final
{
public:
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 CharacterContextItem;                              // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryItem_IsOwnedCached) == 0x000008, "Wrong alignment on HWInventoryItem_IsOwnedCached");
static_assert(sizeof(HWInventoryItem_IsOwnedCached) == 0x000018, "Wrong size on HWInventoryItem_IsOwnedCached");
static_assert(offsetof(HWInventoryItem_IsOwnedCached, PlayerInfo) == 0x000000, "Member 'HWInventoryItem_IsOwnedCached::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_IsOwnedCached, CharacterContextItem) == 0x000008, "Member 'HWInventoryItem_IsOwnedCached::CharacterContextItem' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_IsOwnedCached, ReturnValue) == 0x000010, "Member 'HWInventoryItem_IsOwnedCached::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryItem.IsPurchasable
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryItem_IsPurchasable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryItem_IsPurchasable) == 0x000008, "Wrong alignment on HWInventoryItem_IsPurchasable");
static_assert(sizeof(HWInventoryItem_IsPurchasable) == 0x000010, "Wrong size on HWInventoryItem_IsPurchasable");
static_assert(offsetof(HWInventoryItem_IsPurchasable, WorldContextObject) == 0x000000, "Member 'HWInventoryItem_IsPurchasable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWInventoryItem_IsPurchasable, ReturnValue) == 0x000008, "Member 'HWInventoryItem_IsPurchasable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelItem.GetSlot
// 0x0008 (0x0008 - 0x0000)
struct HWApparelItem_GetSlot final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWApparelItem_GetSlot) == 0x000004, "Wrong alignment on HWApparelItem_GetSlot");
static_assert(sizeof(HWApparelItem_GetSlot) == 0x000008, "Wrong size on HWApparelItem_GetSlot");
static_assert(offsetof(HWApparelItem_GetSlot, ReturnValue) == 0x000000, "Member 'HWApparelItem_GetSlot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.ApplyGameplayEffect
// 0x0060 (0x0060 - 0x0000)
struct HWProjectile_ApplyGameplayEffect final
{
public:
	TArray<struct FActiveGameplayEffectHandle>    OutAppliedEffects;                                 // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0018(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0040(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelOverride;                                     // 0x005C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_ApplyGameplayEffect) == 0x000008, "Wrong alignment on HWProjectile_ApplyGameplayEffect");
static_assert(sizeof(HWProjectile_ApplyGameplayEffect) == 0x000060, "Wrong size on HWProjectile_ApplyGameplayEffect");
static_assert(offsetof(HWProjectile_ApplyGameplayEffect, OutAppliedEffects) == 0x000000, "Member 'HWProjectile_ApplyGameplayEffect::OutAppliedEffects' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffect, GameplayEffect) == 0x000010, "Member 'HWProjectile_ApplyGameplayEffect::GameplayEffect' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffect, TargetData) == 0x000018, "Member 'HWProjectile_ApplyGameplayEffect::TargetData' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffect, EffectContext) == 0x000040, "Member 'HWProjectile_ApplyGameplayEffect::EffectContext' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffect, StackCount) == 0x000058, "Member 'HWProjectile_ApplyGameplayEffect::StackCount' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffect, LevelOverride) == 0x00005C, "Member 'HWProjectile_ApplyGameplayEffect::LevelOverride' has a wrong offset!");

// Function Hemingway.HWProjectile.ApplyGameplayEffectSpec
// 0x0038 (0x0038 - 0x0000)
struct HWProjectile_ApplyGameplayEffectSpec final
{
public:
	struct FGameplayEffectSpecHandle              EffectSpecHandle;                                  // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_ApplyGameplayEffectSpec) == 0x000008, "Wrong alignment on HWProjectile_ApplyGameplayEffectSpec");
static_assert(sizeof(HWProjectile_ApplyGameplayEffectSpec) == 0x000038, "Wrong size on HWProjectile_ApplyGameplayEffectSpec");
static_assert(offsetof(HWProjectile_ApplyGameplayEffectSpec, EffectSpecHandle) == 0x000000, "Member 'HWProjectile_ApplyGameplayEffectSpec::EffectSpecHandle' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffectSpec, TargetData) == 0x000010, "Member 'HWProjectile_ApplyGameplayEffectSpec::TargetData' has a wrong offset!");

// Function Hemingway.HWProjectile.ApplyGameplayEffectsWithGroupTag
// 0x0060 (0x0060 - 0x0000)
struct HWProjectile_ApplyGameplayEffectsWithGroupTag final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EffectGroupTag;                                    // 0x0028(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0030(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelOverride;                                     // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_ApplyGameplayEffectsWithGroupTag) == 0x000008, "Wrong alignment on HWProjectile_ApplyGameplayEffectsWithGroupTag");
static_assert(sizeof(HWProjectile_ApplyGameplayEffectsWithGroupTag) == 0x000060, "Wrong size on HWProjectile_ApplyGameplayEffectsWithGroupTag");
static_assert(offsetof(HWProjectile_ApplyGameplayEffectsWithGroupTag, TargetData) == 0x000000, "Member 'HWProjectile_ApplyGameplayEffectsWithGroupTag::TargetData' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffectsWithGroupTag, EffectGroupTag) == 0x000028, "Member 'HWProjectile_ApplyGameplayEffectsWithGroupTag::EffectGroupTag' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffectsWithGroupTag, EffectContext) == 0x000030, "Member 'HWProjectile_ApplyGameplayEffectsWithGroupTag::EffectContext' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffectsWithGroupTag, StackCount) == 0x000048, "Member 'HWProjectile_ApplyGameplayEffectsWithGroupTag::StackCount' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffectsWithGroupTag, LevelOverride) == 0x00004C, "Member 'HWProjectile_ApplyGameplayEffectsWithGroupTag::LevelOverride' has a wrong offset!");
static_assert(offsetof(HWProjectile_ApplyGameplayEffectsWithGroupTag, ReturnValue) == 0x000050, "Member 'HWProjectile_ApplyGameplayEffectsWithGroupTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.BeginDestroyProjectile
// 0x00F8 (0x00F8 - 0x0000)
struct HWProjectile_BeginDestroyProjectile final
{
public:
	EHWDestroyProjectileReason                    DestroyReason;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             DestroyHit;                                        // 0x0008(0x00E8)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bDestroyImmediately;                               // 0x00F0(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWProjectile_BeginDestroyProjectile) == 0x000008, "Wrong alignment on HWProjectile_BeginDestroyProjectile");
static_assert(sizeof(HWProjectile_BeginDestroyProjectile) == 0x0000F8, "Wrong size on HWProjectile_BeginDestroyProjectile");
static_assert(offsetof(HWProjectile_BeginDestroyProjectile, DestroyReason) == 0x000000, "Member 'HWProjectile_BeginDestroyProjectile::DestroyReason' has a wrong offset!");
static_assert(offsetof(HWProjectile_BeginDestroyProjectile, DestroyHit) == 0x000008, "Member 'HWProjectile_BeginDestroyProjectile::DestroyHit' has a wrong offset!");
static_assert(offsetof(HWProjectile_BeginDestroyProjectile, bDestroyImmediately) == 0x0000F0, "Member 'HWProjectile_BeginDestroyProjectile::bDestroyImmediately' has a wrong offset!");

// Function Hemingway.HWProjectile.BP_OnInitializeProjectile
// 0x0008 (0x0008 - 0x0000)
struct HWProjectile_BP_OnInitializeProjectile final
{
public:
	const class UHWAbilityTask_SpawnProjectile*   SpawnTask;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_BP_OnInitializeProjectile) == 0x000008, "Wrong alignment on HWProjectile_BP_OnInitializeProjectile");
static_assert(sizeof(HWProjectile_BP_OnInitializeProjectile) == 0x000008, "Wrong size on HWProjectile_BP_OnInitializeProjectile");
static_assert(offsetof(HWProjectile_BP_OnInitializeProjectile, SpawnTask) == 0x000000, "Member 'HWProjectile_BP_OnInitializeProjectile::SpawnTask' has a wrong offset!");

// Function Hemingway.HWProjectile.BP_OnProjectileDestroyed
// 0x00F0 (0x00F0 - 0x0000)
struct HWProjectile_BP_OnProjectileDestroyed final
{
public:
	EHWDestroyProjectileReason                    DestroyReason;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             DestroyHit;                                        // 0x0008(0x00E8)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_BP_OnProjectileDestroyed) == 0x000008, "Wrong alignment on HWProjectile_BP_OnProjectileDestroyed");
static_assert(sizeof(HWProjectile_BP_OnProjectileDestroyed) == 0x0000F0, "Wrong size on HWProjectile_BP_OnProjectileDestroyed");
static_assert(offsetof(HWProjectile_BP_OnProjectileDestroyed, DestroyReason) == 0x000000, "Member 'HWProjectile_BP_OnProjectileDestroyed::DestroyReason' has a wrong offset!");
static_assert(offsetof(HWProjectile_BP_OnProjectileDestroyed, DestroyHit) == 0x000008, "Member 'HWProjectile_BP_OnProjectileDestroyed::DestroyHit' has a wrong offset!");

// Function Hemingway.HWProjectile.BP_SpawnDeployable
// 0x0160 (0x0160 - 0x0000)
struct HWProjectile_BP_SpawnDeployable final
{
public:
	struct FTransform                             SpawnTransform;                                    // 0x0000(0x0060)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DeployableConfigTag;                               // 0x0060(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeployableLvl;                                     // 0x0068(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitTrigger;                                        // 0x0070(0x00E8)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AHWDeployable*                          ReturnValue;                                       // 0x0158(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_BP_SpawnDeployable) == 0x000010, "Wrong alignment on HWProjectile_BP_SpawnDeployable");
static_assert(sizeof(HWProjectile_BP_SpawnDeployable) == 0x000160, "Wrong size on HWProjectile_BP_SpawnDeployable");
static_assert(offsetof(HWProjectile_BP_SpawnDeployable, SpawnTransform) == 0x000000, "Member 'HWProjectile_BP_SpawnDeployable::SpawnTransform' has a wrong offset!");
static_assert(offsetof(HWProjectile_BP_SpawnDeployable, DeployableConfigTag) == 0x000060, "Member 'HWProjectile_BP_SpawnDeployable::DeployableConfigTag' has a wrong offset!");
static_assert(offsetof(HWProjectile_BP_SpawnDeployable, DeployableLvl) == 0x000068, "Member 'HWProjectile_BP_SpawnDeployable::DeployableLvl' has a wrong offset!");
static_assert(offsetof(HWProjectile_BP_SpawnDeployable, HitTrigger) == 0x000070, "Member 'HWProjectile_BP_SpawnDeployable::HitTrigger' has a wrong offset!");
static_assert(offsetof(HWProjectile_BP_SpawnDeployable, ReturnValue) == 0x000158, "Member 'HWProjectile_BP_SpawnDeployable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetTargetCollisionSettingsCollisionRadius
// 0x0004 (0x0004 - 0x0000)
struct HWProjectile_GetTargetCollisionSettingsCollisionRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetTargetCollisionSettingsCollisionRadius) == 0x000004, "Wrong alignment on HWProjectile_GetTargetCollisionSettingsCollisionRadius");
static_assert(sizeof(HWProjectile_GetTargetCollisionSettingsCollisionRadius) == 0x000004, "Wrong size on HWProjectile_GetTargetCollisionSettingsCollisionRadius");
static_assert(offsetof(HWProjectile_GetTargetCollisionSettingsCollisionRadius, ReturnValue) == 0x000000, "Member 'HWProjectile_GetTargetCollisionSettingsCollisionRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.HandleOnPawnControllerChanged
// 0x0018 (0x0018 - 0x0000)
struct HWProjectile_HandleOnPawnControllerChanged final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OldController;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            NewController;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_HandleOnPawnControllerChanged) == 0x000008, "Wrong alignment on HWProjectile_HandleOnPawnControllerChanged");
static_assert(sizeof(HWProjectile_HandleOnPawnControllerChanged) == 0x000018, "Wrong size on HWProjectile_HandleOnPawnControllerChanged");
static_assert(offsetof(HWProjectile_HandleOnPawnControllerChanged, Pawn) == 0x000000, "Member 'HWProjectile_HandleOnPawnControllerChanged::Pawn' has a wrong offset!");
static_assert(offsetof(HWProjectile_HandleOnPawnControllerChanged, OldController) == 0x000008, "Member 'HWProjectile_HandleOnPawnControllerChanged::OldController' has a wrong offset!");
static_assert(offsetof(HWProjectile_HandleOnPawnControllerChanged, NewController) == 0x000010, "Member 'HWProjectile_HandleOnPawnControllerChanged::NewController' has a wrong offset!");

// Function Hemingway.HWProjectile.InitializeProjectile
// 0x0028 (0x0028 - 0x0000)
struct HWProjectile_InitializeProjectile final
{
public:
	int32                                         InstanceId;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWGameplayAbility*                     InAbilityOwner;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings_Projectile* InProjectileAttackSettings;                     // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityTask_SpawnProjectile*   SpawnTask;                                         // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWProjectile_InitializeProjectile) == 0x000008, "Wrong alignment on HWProjectile_InitializeProjectile");
static_assert(sizeof(HWProjectile_InitializeProjectile) == 0x000028, "Wrong size on HWProjectile_InitializeProjectile");
static_assert(offsetof(HWProjectile_InitializeProjectile, InstanceId) == 0x000000, "Member 'HWProjectile_InitializeProjectile::InstanceId' has a wrong offset!");
static_assert(offsetof(HWProjectile_InitializeProjectile, InAbilityOwner) == 0x000008, "Member 'HWProjectile_InitializeProjectile::InAbilityOwner' has a wrong offset!");
static_assert(offsetof(HWProjectile_InitializeProjectile, InProjectileAttackSettings) == 0x000010, "Member 'HWProjectile_InitializeProjectile::InProjectileAttackSettings' has a wrong offset!");
static_assert(offsetof(HWProjectile_InitializeProjectile, SpawnTask) == 0x000018, "Member 'HWProjectile_InitializeProjectile::SpawnTask' has a wrong offset!");
static_assert(offsetof(HWProjectile_InitializeProjectile, Range) == 0x000020, "Member 'HWProjectile_InitializeProjectile::Range' has a wrong offset!");

// Function Hemingway.HWProjectile.MaxRangeReached
// 0x0008 (0x0008 - 0x0000)
struct HWProjectile_MaxRangeReached final
{
public:
	class UHWGameplayMovementComponent*           MovementComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_MaxRangeReached) == 0x000008, "Wrong alignment on HWProjectile_MaxRangeReached");
static_assert(sizeof(HWProjectile_MaxRangeReached) == 0x000008, "Wrong size on HWProjectile_MaxRangeReached");
static_assert(offsetof(HWProjectile_MaxRangeReached, MovementComponent) == 0x000000, "Member 'HWProjectile_MaxRangeReached::MovementComponent' has a wrong offset!");

// Function Hemingway.HWProjectile.OnDeployableBeginSpawning
// 0x0100 (0x0100 - 0x0000)
struct HWProjectile_OnDeployableBeginSpawning final
{
public:
	class AHWDeployable*                          SpawnedDeployable;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWProjectileDeployableConfig          DeployableConfig;                                  // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitTrigger;                                        // 0x0018(0x00E8)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_OnDeployableBeginSpawning) == 0x000008, "Wrong alignment on HWProjectile_OnDeployableBeginSpawning");
static_assert(sizeof(HWProjectile_OnDeployableBeginSpawning) == 0x000100, "Wrong size on HWProjectile_OnDeployableBeginSpawning");
static_assert(offsetof(HWProjectile_OnDeployableBeginSpawning, SpawnedDeployable) == 0x000000, "Member 'HWProjectile_OnDeployableBeginSpawning::SpawnedDeployable' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnDeployableBeginSpawning, DeployableConfig) == 0x000008, "Member 'HWProjectile_OnDeployableBeginSpawning::DeployableConfig' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnDeployableBeginSpawning, HitTrigger) == 0x000018, "Member 'HWProjectile_OnDeployableBeginSpawning::HitTrigger' has a wrong offset!");

// Function Hemingway.HWProjectile.OnDeployableSpawned
// 0x0100 (0x0100 - 0x0000)
struct HWProjectile_OnDeployableSpawned final
{
public:
	class AHWDeployable*                          SpawnedDeployable;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWProjectileDeployableConfig          DeployableConfig;                                  // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitTrigger;                                        // 0x0018(0x00E8)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_OnDeployableSpawned) == 0x000008, "Wrong alignment on HWProjectile_OnDeployableSpawned");
static_assert(sizeof(HWProjectile_OnDeployableSpawned) == 0x000100, "Wrong size on HWProjectile_OnDeployableSpawned");
static_assert(offsetof(HWProjectile_OnDeployableSpawned, SpawnedDeployable) == 0x000000, "Member 'HWProjectile_OnDeployableSpawned::SpawnedDeployable' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnDeployableSpawned, DeployableConfig) == 0x000008, "Member 'HWProjectile_OnDeployableSpawned::DeployableConfig' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnDeployableSpawned, HitTrigger) == 0x000018, "Member 'HWProjectile_OnDeployableSpawned::HitTrigger' has a wrong offset!");

// Function Hemingway.HWProjectile.OnHomingTargetDestroyed
// 0x0008 (0x0008 - 0x0000)
struct HWProjectile_OnHomingTargetDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_OnHomingTargetDestroyed) == 0x000008, "Wrong alignment on HWProjectile_OnHomingTargetDestroyed");
static_assert(sizeof(HWProjectile_OnHomingTargetDestroyed) == 0x000008, "Wrong size on HWProjectile_OnHomingTargetDestroyed");
static_assert(offsetof(HWProjectile_OnHomingTargetDestroyed, DestroyedActor) == 0x000000, "Member 'HWProjectile_OnHomingTargetDestroyed::DestroyedActor' has a wrong offset!");

// Function Hemingway.HWProjectile.OnHomingTargetDied
// 0x0010 (0x0010 - 0x0000)
struct HWProjectile_OnHomingTargetDied final
{
public:
	class AHWCharacterAbilitySystemActor*         CharacterAbilitySystemActor;                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnTimerDuration;                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWProjectile_OnHomingTargetDied) == 0x000008, "Wrong alignment on HWProjectile_OnHomingTargetDied");
static_assert(sizeof(HWProjectile_OnHomingTargetDied) == 0x000010, "Wrong size on HWProjectile_OnHomingTargetDied");
static_assert(offsetof(HWProjectile_OnHomingTargetDied, CharacterAbilitySystemActor) == 0x000000, "Member 'HWProjectile_OnHomingTargetDied::CharacterAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnHomingTargetDied, RespawnTimerDuration) == 0x000008, "Member 'HWProjectile_OnHomingTargetDied::RespawnTimerDuration' has a wrong offset!");

// Function Hemingway.HWProjectile.OnHomingTargetPlaneOfExistenceChanged
// 0x000C (0x000C - 0x0000)
struct HWProjectile_OnHomingTargetPlaneOfExistenceChanged final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_OnHomingTargetPlaneOfExistenceChanged) == 0x000004, "Wrong alignment on HWProjectile_OnHomingTargetPlaneOfExistenceChanged");
static_assert(sizeof(HWProjectile_OnHomingTargetPlaneOfExistenceChanged) == 0x00000C, "Wrong size on HWProjectile_OnHomingTargetPlaneOfExistenceChanged");
static_assert(offsetof(HWProjectile_OnHomingTargetPlaneOfExistenceChanged, CallbackTag) == 0x000000, "Member 'HWProjectile_OnHomingTargetPlaneOfExistenceChanged::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnHomingTargetPlaneOfExistenceChanged, NewCount) == 0x000008, "Member 'HWProjectile_OnHomingTargetPlaneOfExistenceChanged::NewCount' has a wrong offset!");

// Function Hemingway.HWProjectile.OnHomingTargetUntargetableStateChanged
// 0x000C (0x000C - 0x0000)
struct HWProjectile_OnHomingTargetUntargetableStateChanged final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_OnHomingTargetUntargetableStateChanged) == 0x000004, "Wrong alignment on HWProjectile_OnHomingTargetUntargetableStateChanged");
static_assert(sizeof(HWProjectile_OnHomingTargetUntargetableStateChanged) == 0x00000C, "Wrong size on HWProjectile_OnHomingTargetUntargetableStateChanged");
static_assert(offsetof(HWProjectile_OnHomingTargetUntargetableStateChanged, CallbackTag) == 0x000000, "Member 'HWProjectile_OnHomingTargetUntargetableStateChanged::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnHomingTargetUntargetableStateChanged, NewCount) == 0x000008, "Member 'HWProjectile_OnHomingTargetUntargetableStateChanged::NewCount' has a wrong offset!");

// Function Hemingway.HWProjectile.OnProjectileExplosionHitTarget
// 0x0028 (0x0028 - 0x0000)
struct HWProjectile_OnProjectileExplosionHitTarget final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_OnProjectileExplosionHitTarget) == 0x000008, "Wrong alignment on HWProjectile_OnProjectileExplosionHitTarget");
static_assert(sizeof(HWProjectile_OnProjectileExplosionHitTarget) == 0x000028, "Wrong size on HWProjectile_OnProjectileExplosionHitTarget");
static_assert(offsetof(HWProjectile_OnProjectileExplosionHitTarget, TargetData) == 0x000000, "Member 'HWProjectile_OnProjectileExplosionHitTarget::TargetData' has a wrong offset!");

// Function Hemingway.HWProjectile.OnProjectileHitTarget
// 0x0028 (0x0028 - 0x0000)
struct HWProjectile_OnProjectileHitTarget final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_OnProjectileHitTarget) == 0x000008, "Wrong alignment on HWProjectile_OnProjectileHitTarget");
static_assert(sizeof(HWProjectile_OnProjectileHitTarget) == 0x000028, "Wrong size on HWProjectile_OnProjectileHitTarget");
static_assert(offsetof(HWProjectile_OnProjectileHitTarget, TargetData) == 0x000000, "Member 'HWProjectile_OnProjectileHitTarget::TargetData' has a wrong offset!");

// Function Hemingway.HWProjectile.OnProjectileTargetOverlap
// 0x0108 (0x0108 - 0x0000)
struct HWProjectile_OnProjectileTargetOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromSweep;                                         // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_OnProjectileTargetOverlap) == 0x000008, "Wrong alignment on HWProjectile_OnProjectileTargetOverlap");
static_assert(sizeof(HWProjectile_OnProjectileTargetOverlap) == 0x000108, "Wrong size on HWProjectile_OnProjectileTargetOverlap");
static_assert(offsetof(HWProjectile_OnProjectileTargetOverlap, OverlappedComp) == 0x000000, "Member 'HWProjectile_OnProjectileTargetOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnProjectileTargetOverlap, OtherActor) == 0x000008, "Member 'HWProjectile_OnProjectileTargetOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnProjectileTargetOverlap, OtherComp) == 0x000010, "Member 'HWProjectile_OnProjectileTargetOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnProjectileTargetOverlap, OtherBodyIndex) == 0x000018, "Member 'HWProjectile_OnProjectileTargetOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnProjectileTargetOverlap, FromSweep) == 0x00001C, "Member 'HWProjectile_OnProjectileTargetOverlap::FromSweep' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnProjectileTargetOverlap, SweepResult) == 0x000020, "Member 'HWProjectile_OnProjectileTargetOverlap::SweepResult' has a wrong offset!");

// Function Hemingway.HWProjectile.OnProjectileWorldHit
// 0x0118 (0x0118 - 0x0000)
struct HWProjectile_OnProjectileWorldHit final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0030(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_OnProjectileWorldHit) == 0x000008, "Wrong alignment on HWProjectile_OnProjectileWorldHit");
static_assert(sizeof(HWProjectile_OnProjectileWorldHit) == 0x000118, "Wrong size on HWProjectile_OnProjectileWorldHit");
static_assert(offsetof(HWProjectile_OnProjectileWorldHit, HitComponent) == 0x000000, "Member 'HWProjectile_OnProjectileWorldHit::HitComponent' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnProjectileWorldHit, OtherActor) == 0x000008, "Member 'HWProjectile_OnProjectileWorldHit::OtherActor' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnProjectileWorldHit, OtherComponent) == 0x000010, "Member 'HWProjectile_OnProjectileWorldHit::OtherComponent' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnProjectileWorldHit, NormalImpulse) == 0x000018, "Member 'HWProjectile_OnProjectileWorldHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnProjectileWorldHit, Hit) == 0x000030, "Member 'HWProjectile_OnProjectileWorldHit::Hit' has a wrong offset!");

// Function Hemingway.HWProjectile.OnSpawnExplosionFx
// 0x0108 (0x0108 - 0x0000)
struct HWProjectile_OnSpawnExplosionFx final
{
public:
	struct FVector                                ExplosionLocation;                                 // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWDestroyProjectileReason                    ExplodeReason;                                     // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ExplosionHitInfo;                                  // 0x0020(0x00E8)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_OnSpawnExplosionFx) == 0x000008, "Wrong alignment on HWProjectile_OnSpawnExplosionFx");
static_assert(sizeof(HWProjectile_OnSpawnExplosionFx) == 0x000108, "Wrong size on HWProjectile_OnSpawnExplosionFx");
static_assert(offsetof(HWProjectile_OnSpawnExplosionFx, ExplosionLocation) == 0x000000, "Member 'HWProjectile_OnSpawnExplosionFx::ExplosionLocation' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnSpawnExplosionFx, ExplodeReason) == 0x000018, "Member 'HWProjectile_OnSpawnExplosionFx::ExplodeReason' has a wrong offset!");
static_assert(offsetof(HWProjectile_OnSpawnExplosionFx, ExplosionHitInfo) == 0x000020, "Member 'HWProjectile_OnSpawnExplosionFx::ExplosionHitInfo' has a wrong offset!");

// Function Hemingway.HWProjectile.PerformExplosionAttack
// 0x00E8 (0x00E8 - 0x0000)
struct HWProjectile_PerformExplosionAttack final
{
public:
	struct FHitResult                             DestroyHit;                                        // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_PerformExplosionAttack) == 0x000008, "Wrong alignment on HWProjectile_PerformExplosionAttack");
static_assert(sizeof(HWProjectile_PerformExplosionAttack) == 0x0000E8, "Wrong size on HWProjectile_PerformExplosionAttack");
static_assert(offsetof(HWProjectile_PerformExplosionAttack, DestroyHit) == 0x000000, "Member 'HWProjectile_PerformExplosionAttack::DestroyHit' has a wrong offset!");

// Function Hemingway.HWProjectile.ProcessProjectileTargetOverlap
// 0x00F0 (0x00F0 - 0x0000)
struct HWProjectile_ProcessProjectileTargetOverlap final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_ProcessProjectileTargetOverlap) == 0x000008, "Wrong alignment on HWProjectile_ProcessProjectileTargetOverlap");
static_assert(sizeof(HWProjectile_ProcessProjectileTargetOverlap) == 0x0000F0, "Wrong size on HWProjectile_ProcessProjectileTargetOverlap");
static_assert(offsetof(HWProjectile_ProcessProjectileTargetOverlap, HitActor) == 0x000000, "Member 'HWProjectile_ProcessProjectileTargetOverlap::HitActor' has a wrong offset!");
static_assert(offsetof(HWProjectile_ProcessProjectileTargetOverlap, Hit) == 0x000008, "Member 'HWProjectile_ProcessProjectileTargetOverlap::Hit' has a wrong offset!");

// Function Hemingway.HWProjectile.SetHomingTarget
// 0x0008 (0x0008 - 0x0000)
struct HWProjectile_SetHomingTarget final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_SetHomingTarget) == 0x000008, "Wrong alignment on HWProjectile_SetHomingTarget");
static_assert(sizeof(HWProjectile_SetHomingTarget) == 0x000008, "Wrong size on HWProjectile_SetHomingTarget");
static_assert(offsetof(HWProjectile_SetHomingTarget, Target) == 0x000000, "Member 'HWProjectile_SetHomingTarget::Target' has a wrong offset!");

// Function Hemingway.HWProjectile.SetProjectileLevel
// 0x0004 (0x0004 - 0x0000)
struct HWProjectile_SetProjectileLevel final
{
public:
	int32                                         NewLevel;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_SetProjectileLevel) == 0x000004, "Wrong alignment on HWProjectile_SetProjectileLevel");
static_assert(sizeof(HWProjectile_SetProjectileLevel) == 0x000004, "Wrong size on HWProjectile_SetProjectileLevel");
static_assert(offsetof(HWProjectile_SetProjectileLevel, NewLevel) == 0x000000, "Member 'HWProjectile_SetProjectileLevel::NewLevel' has a wrong offset!");

// Function Hemingway.HWProjectile.SetRange
// 0x0004 (0x0004 - 0x0000)
struct HWProjectile_SetRange final
{
public:
	float                                         Range;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_SetRange) == 0x000004, "Wrong alignment on HWProjectile_SetRange");
static_assert(sizeof(HWProjectile_SetRange) == 0x000004, "Wrong size on HWProjectile_SetRange");
static_assert(offsetof(HWProjectile_SetRange, Range) == 0x000000, "Member 'HWProjectile_SetRange::Range' has a wrong offset!");

// Function Hemingway.HWProjectile.SetSpeed
// 0x0004 (0x0004 - 0x0000)
struct HWProjectile_SetSpeed final
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_SetSpeed) == 0x000004, "Wrong alignment on HWProjectile_SetSpeed");
static_assert(sizeof(HWProjectile_SetSpeed) == 0x000004, "Wrong size on HWProjectile_SetSpeed");
static_assert(offsetof(HWProjectile_SetSpeed, Speed) == 0x000000, "Member 'HWProjectile_SetSpeed::Speed' has a wrong offset!");

// Function Hemingway.HWProjectile.SpawnMuzzleFlashVFX
// 0x0030 (0x0030 - 0x0000)
struct HWProjectile_SpawnMuzzleFlashVFX final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_SpawnMuzzleFlashVFX) == 0x000008, "Wrong alignment on HWProjectile_SpawnMuzzleFlashVFX");
static_assert(sizeof(HWProjectile_SpawnMuzzleFlashVFX) == 0x000030, "Wrong size on HWProjectile_SpawnMuzzleFlashVFX");
static_assert(offsetof(HWProjectile_SpawnMuzzleFlashVFX, Location) == 0x000000, "Member 'HWProjectile_SpawnMuzzleFlashVFX::Location' has a wrong offset!");
static_assert(offsetof(HWProjectile_SpawnMuzzleFlashVFX, Rotation) == 0x000018, "Member 'HWProjectile_SpawnMuzzleFlashVFX::Rotation' has a wrong offset!");

// Function Hemingway.HWProjectile.SpawnProjectileDestroyVFX
// 0x0030 (0x0030 - 0x0000)
struct HWProjectile_SpawnProjectileDestroyVFX final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_SpawnProjectileDestroyVFX) == 0x000008, "Wrong alignment on HWProjectile_SpawnProjectileDestroyVFX");
static_assert(sizeof(HWProjectile_SpawnProjectileDestroyVFX) == 0x000030, "Wrong size on HWProjectile_SpawnProjectileDestroyVFX");
static_assert(offsetof(HWProjectile_SpawnProjectileDestroyVFX, Location) == 0x000000, "Member 'HWProjectile_SpawnProjectileDestroyVFX::Location' has a wrong offset!");
static_assert(offsetof(HWProjectile_SpawnProjectileDestroyVFX, Rotation) == 0x000018, "Member 'HWProjectile_SpawnProjectileDestroyVFX::Rotation' has a wrong offset!");

// Function Hemingway.HWProjectile.CalcHighlightingTargetList
// 0x0078 (0x0078 - 0x0000)
struct HWProjectile_CalcHighlightingTargetList final
{
public:
	struct FHWAttackTargetingInfo                 TargetingInfo;                                     // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings_Projectile* AttackSettings;                                 // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetListDataHandle;                              // 0x0050(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_CalcHighlightingTargetList) == 0x000008, "Wrong alignment on HWProjectile_CalcHighlightingTargetList");
static_assert(sizeof(HWProjectile_CalcHighlightingTargetList) == 0x000078, "Wrong size on HWProjectile_CalcHighlightingTargetList");
static_assert(offsetof(HWProjectile_CalcHighlightingTargetList, TargetingInfo) == 0x000000, "Member 'HWProjectile_CalcHighlightingTargetList::TargetingInfo' has a wrong offset!");
static_assert(offsetof(HWProjectile_CalcHighlightingTargetList, AttackSettings) == 0x000048, "Member 'HWProjectile_CalcHighlightingTargetList::AttackSettings' has a wrong offset!");
static_assert(offsetof(HWProjectile_CalcHighlightingTargetList, TargetListDataHandle) == 0x000050, "Member 'HWProjectile_CalcHighlightingTargetList::TargetListDataHandle' has a wrong offset!");

// Function Hemingway.HWProjectile.GetAllDeployableConfigForSpawnTrigger
// 0x0018 (0x0018 - 0x0000)
struct HWProjectile_GetAllDeployableConfigForSpawnTrigger final
{
public:
	EHWProjectileSpawnDeployableTrigger           SpawnTrigger;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHWProjectileDeployableConfig>  OutDeployableConfigs;                              // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetAllDeployableConfigForSpawnTrigger) == 0x000008, "Wrong alignment on HWProjectile_GetAllDeployableConfigForSpawnTrigger");
static_assert(sizeof(HWProjectile_GetAllDeployableConfigForSpawnTrigger) == 0x000018, "Wrong size on HWProjectile_GetAllDeployableConfigForSpawnTrigger");
static_assert(offsetof(HWProjectile_GetAllDeployableConfigForSpawnTrigger, SpawnTrigger) == 0x000000, "Member 'HWProjectile_GetAllDeployableConfigForSpawnTrigger::SpawnTrigger' has a wrong offset!");
static_assert(offsetof(HWProjectile_GetAllDeployableConfigForSpawnTrigger, OutDeployableConfigs) == 0x000008, "Member 'HWProjectile_GetAllDeployableConfigForSpawnTrigger::OutDeployableConfigs' has a wrong offset!");

// Function Hemingway.HWProjectile.GetApparelComponent
// 0x0008 (0x0008 - 0x0000)
struct HWProjectile_GetApparelComponent final
{
public:
	class UHWApparelComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetApparelComponent) == 0x000008, "Wrong alignment on HWProjectile_GetApparelComponent");
static_assert(sizeof(HWProjectile_GetApparelComponent) == 0x000008, "Wrong size on HWProjectile_GetApparelComponent");
static_assert(offsetof(HWProjectile_GetApparelComponent, ReturnValue) == 0x000000, "Member 'HWProjectile_GetApparelComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetCurrentSkin
// 0x0008 (0x0008 - 0x0000)
struct HWProjectile_GetCurrentSkin final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetCurrentSkin) == 0x000008, "Wrong alignment on HWProjectile_GetCurrentSkin");
static_assert(sizeof(HWProjectile_GetCurrentSkin) == 0x000008, "Wrong size on HWProjectile_GetCurrentSkin");
static_assert(offsetof(HWProjectile_GetCurrentSkin, ReturnValue) == 0x000000, "Member 'HWProjectile_GetCurrentSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetEffectSpecForEffect
// 0x0018 (0x0018 - 0x0000)
struct HWProjectile_GetEffectSpecForEffect final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecHandle              ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetEffectSpecForEffect) == 0x000008, "Wrong alignment on HWProjectile_GetEffectSpecForEffect");
static_assert(sizeof(HWProjectile_GetEffectSpecForEffect) == 0x000018, "Wrong size on HWProjectile_GetEffectSpecForEffect");
static_assert(offsetof(HWProjectile_GetEffectSpecForEffect, GameplayEffect) == 0x000000, "Member 'HWProjectile_GetEffectSpecForEffect::GameplayEffect' has a wrong offset!");
static_assert(offsetof(HWProjectile_GetEffectSpecForEffect, ReturnValue) == 0x000008, "Member 'HWProjectile_GetEffectSpecForEffect::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetFiringInstanceId
// 0x0008 (0x0008 - 0x0000)
struct HWProjectile_GetFiringInstanceId final
{
public:
	struct FHWAbilityFiringInstanceId             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetFiringInstanceId) == 0x000004, "Wrong alignment on HWProjectile_GetFiringInstanceId");
static_assert(sizeof(HWProjectile_GetFiringInstanceId) == 0x000008, "Wrong size on HWProjectile_GetFiringInstanceId");
static_assert(offsetof(HWProjectile_GetFiringInstanceId, ReturnValue) == 0x000000, "Member 'HWProjectile_GetFiringInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetHomingTarget
// 0x0008 (0x0008 - 0x0000)
struct HWProjectile_GetHomingTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetHomingTarget) == 0x000008, "Wrong alignment on HWProjectile_GetHomingTarget");
static_assert(sizeof(HWProjectile_GetHomingTarget) == 0x000008, "Wrong size on HWProjectile_GetHomingTarget");
static_assert(offsetof(HWProjectile_GetHomingTarget, ReturnValue) == 0x000000, "Member 'HWProjectile_GetHomingTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetOriginalEquipmentItem
// 0x0028 (0x0028 - 0x0000)
struct HWProjectile_GetOriginalEquipmentItem final
{
public:
	TSoftObjectPtr<class UHWEquipmentItem>        ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetOriginalEquipmentItem) == 0x000008, "Wrong alignment on HWProjectile_GetOriginalEquipmentItem");
static_assert(sizeof(HWProjectile_GetOriginalEquipmentItem) == 0x000028, "Wrong size on HWProjectile_GetOriginalEquipmentItem");
static_assert(offsetof(HWProjectile_GetOriginalEquipmentItem, ReturnValue) == 0x000000, "Member 'HWProjectile_GetOriginalEquipmentItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetProjectileInstanceId
// 0x0004 (0x0004 - 0x0000)
struct HWProjectile_GetProjectileInstanceId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetProjectileInstanceId) == 0x000004, "Wrong alignment on HWProjectile_GetProjectileInstanceId");
static_assert(sizeof(HWProjectile_GetProjectileInstanceId) == 0x000004, "Wrong size on HWProjectile_GetProjectileInstanceId");
static_assert(offsetof(HWProjectile_GetProjectileInstanceId, ReturnValue) == 0x000000, "Member 'HWProjectile_GetProjectileInstanceId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetProjectileLevel
// 0x0004 (0x0004 - 0x0000)
struct HWProjectile_GetProjectileLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetProjectileLevel) == 0x000004, "Wrong alignment on HWProjectile_GetProjectileLevel");
static_assert(sizeof(HWProjectile_GetProjectileLevel) == 0x000004, "Wrong size on HWProjectile_GetProjectileLevel");
static_assert(offsetof(HWProjectile_GetProjectileLevel, ReturnValue) == 0x000000, "Member 'HWProjectile_GetProjectileLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetProjectileMovementComponent
// 0x0008 (0x0008 - 0x0000)
struct HWProjectile_GetProjectileMovementComponent final
{
public:
	class UHWProjectileMovementComponent*         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetProjectileMovementComponent) == 0x000008, "Wrong alignment on HWProjectile_GetProjectileMovementComponent");
static_assert(sizeof(HWProjectile_GetProjectileMovementComponent) == 0x000008, "Wrong size on HWProjectile_GetProjectileMovementComponent");
static_assert(offsetof(HWProjectile_GetProjectileMovementComponent, ReturnValue) == 0x000000, "Member 'HWProjectile_GetProjectileMovementComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetProjectileRange
// 0x0004 (0x0004 - 0x0000)
struct HWProjectile_GetProjectileRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetProjectileRange) == 0x000004, "Wrong alignment on HWProjectile_GetProjectileRange");
static_assert(sizeof(HWProjectile_GetProjectileRange) == 0x000004, "Wrong size on HWProjectile_GetProjectileRange");
static_assert(offsetof(HWProjectile_GetProjectileRange, ReturnValue) == 0x000000, "Member 'HWProjectile_GetProjectileRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.GetSpawnOrigin
// 0x0060 (0x0060 - 0x0000)
struct HWProjectile_GetSpawnOrigin final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_GetSpawnOrigin) == 0x000010, "Wrong alignment on HWProjectile_GetSpawnOrigin");
static_assert(sizeof(HWProjectile_GetSpawnOrigin) == 0x000060, "Wrong size on HWProjectile_GetSpawnOrigin");
static_assert(offsetof(HWProjectile_GetSpawnOrigin, ReturnValue) == 0x000000, "Member 'HWProjectile_GetSpawnOrigin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.HasAoeExplosion
// 0x0001 (0x0001 - 0x0000)
struct HWProjectile_HasAoeExplosion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_HasAoeExplosion) == 0x000001, "Wrong alignment on HWProjectile_HasAoeExplosion");
static_assert(sizeof(HWProjectile_HasAoeExplosion) == 0x000001, "Wrong size on HWProjectile_HasAoeExplosion");
static_assert(offsetof(HWProjectile_HasAoeExplosion, ReturnValue) == 0x000000, "Member 'HWProjectile_HasAoeExplosion::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.HasGameNetworkAuthority
// 0x0001 (0x0001 - 0x0000)
struct HWProjectile_HasGameNetworkAuthority final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_HasGameNetworkAuthority) == 0x000001, "Wrong alignment on HWProjectile_HasGameNetworkAuthority");
static_assert(sizeof(HWProjectile_HasGameNetworkAuthority) == 0x000001, "Wrong size on HWProjectile_HasGameNetworkAuthority");
static_assert(offsetof(HWProjectile_HasGameNetworkAuthority, ReturnValue) == 0x000000, "Member 'HWProjectile_HasGameNetworkAuthority::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.HasValidHomingTarget
// 0x0001 (0x0001 - 0x0000)
struct HWProjectile_HasValidHomingTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_HasValidHomingTarget) == 0x000001, "Wrong alignment on HWProjectile_HasValidHomingTarget");
static_assert(sizeof(HWProjectile_HasValidHomingTarget) == 0x000001, "Wrong size on HWProjectile_HasValidHomingTarget");
static_assert(offsetof(HWProjectile_HasValidHomingTarget, ReturnValue) == 0x000000, "Member 'HWProjectile_HasValidHomingTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.IsEnemyActor
// 0x0010 (0x0010 - 0x0000)
struct HWProjectile_IsEnemyActor final
{
public:
	const class AActor*                           OtherActor;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWProjectile_IsEnemyActor) == 0x000008, "Wrong alignment on HWProjectile_IsEnemyActor");
static_assert(sizeof(HWProjectile_IsEnemyActor) == 0x000010, "Wrong size on HWProjectile_IsEnemyActor");
static_assert(offsetof(HWProjectile_IsEnemyActor, OtherActor) == 0x000000, "Member 'HWProjectile_IsEnemyActor::OtherActor' has a wrong offset!");
static_assert(offsetof(HWProjectile_IsEnemyActor, ReturnValue) == 0x000008, "Member 'HWProjectile_IsEnemyActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.IsHitInRange
// 0x0160 (0x0160 - 0x0000)
struct HWProjectile_IsHitInRange final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x00F0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0150(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0154(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0xB];                                      // 0x0155(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWProjectile_IsHitInRange) == 0x000010, "Wrong alignment on HWProjectile_IsHitInRange");
static_assert(sizeof(HWProjectile_IsHitInRange) == 0x000160, "Wrong size on HWProjectile_IsHitInRange");
static_assert(offsetof(HWProjectile_IsHitInRange, Hit) == 0x000000, "Member 'HWProjectile_IsHitInRange::Hit' has a wrong offset!");
static_assert(offsetof(HWProjectile_IsHitInRange, SpawnTransform) == 0x0000F0, "Member 'HWProjectile_IsHitInRange::SpawnTransform' has a wrong offset!");
static_assert(offsetof(HWProjectile_IsHitInRange, Range) == 0x000150, "Member 'HWProjectile_IsHitInRange::Range' has a wrong offset!");
static_assert(offsetof(HWProjectile_IsHitInRange, ReturnValue) == 0x000154, "Member 'HWProjectile_IsHitInRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.IsHomingProjectile
// 0x0001 (0x0001 - 0x0000)
struct HWProjectile_IsHomingProjectile final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_IsHomingProjectile) == 0x000001, "Wrong alignment on HWProjectile_IsHomingProjectile");
static_assert(sizeof(HWProjectile_IsHomingProjectile) == 0x000001, "Wrong size on HWProjectile_IsHomingProjectile");
static_assert(offsetof(HWProjectile_IsHomingProjectile, ReturnValue) == 0x000000, "Member 'HWProjectile_IsHomingProjectile::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.IsProjectileBeingDestroyed
// 0x0001 (0x0001 - 0x0000)
struct HWProjectile_IsProjectileBeingDestroyed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_IsProjectileBeingDestroyed) == 0x000001, "Wrong alignment on HWProjectile_IsProjectileBeingDestroyed");
static_assert(sizeof(HWProjectile_IsProjectileBeingDestroyed) == 0x000001, "Wrong size on HWProjectile_IsProjectileBeingDestroyed");
static_assert(offsetof(HWProjectile_IsProjectileBeingDestroyed, ReturnValue) == 0x000000, "Member 'HWProjectile_IsProjectileBeingDestroyed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.MakeOutgoingSpecUsingEffectSpecMap
// 0x0038 (0x0038 - 0x0000)
struct HWProjectile_MakeOutgoingSpecUsingEffectSpecMap final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           Context;                                           // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	int32                                         LevelOverride;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectSpecHandle              ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_MakeOutgoingSpecUsingEffectSpecMap) == 0x000008, "Wrong alignment on HWProjectile_MakeOutgoingSpecUsingEffectSpecMap");
static_assert(sizeof(HWProjectile_MakeOutgoingSpecUsingEffectSpecMap) == 0x000038, "Wrong size on HWProjectile_MakeOutgoingSpecUsingEffectSpecMap");
static_assert(offsetof(HWProjectile_MakeOutgoingSpecUsingEffectSpecMap, GameplayEffectClass) == 0x000000, "Member 'HWProjectile_MakeOutgoingSpecUsingEffectSpecMap::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(HWProjectile_MakeOutgoingSpecUsingEffectSpecMap, Context) == 0x000008, "Member 'HWProjectile_MakeOutgoingSpecUsingEffectSpecMap::Context' has a wrong offset!");
static_assert(offsetof(HWProjectile_MakeOutgoingSpecUsingEffectSpecMap, LevelOverride) == 0x000020, "Member 'HWProjectile_MakeOutgoingSpecUsingEffectSpecMap::LevelOverride' has a wrong offset!");
static_assert(offsetof(HWProjectile_MakeOutgoingSpecUsingEffectSpecMap, ReturnValue) == 0x000028, "Member 'HWProjectile_MakeOutgoingSpecUsingEffectSpecMap::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.MakeProjectileEffectContext
// 0x0018 (0x0018 - 0x0000)
struct HWProjectile_MakeProjectileEffectContext final
{
public:
	struct FGameplayEffectContextHandle           ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_MakeProjectileEffectContext) == 0x000008, "Wrong alignment on HWProjectile_MakeProjectileEffectContext");
static_assert(sizeof(HWProjectile_MakeProjectileEffectContext) == 0x000018, "Wrong size on HWProjectile_MakeProjectileEffectContext");
static_assert(offsetof(HWProjectile_MakeProjectileEffectContext, ReturnValue) == 0x000000, "Member 'HWProjectile_MakeProjectileEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.MakeProjectileEffectContextWithHitResult
// 0x0100 (0x0100 - 0x0000)
struct HWProjectile_MakeProjectileEffectContextWithHitResult final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           ReturnValue;                                       // 0x00E8(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_MakeProjectileEffectContextWithHitResult) == 0x000008, "Wrong alignment on HWProjectile_MakeProjectileEffectContextWithHitResult");
static_assert(sizeof(HWProjectile_MakeProjectileEffectContextWithHitResult) == 0x000100, "Wrong size on HWProjectile_MakeProjectileEffectContextWithHitResult");
static_assert(offsetof(HWProjectile_MakeProjectileEffectContextWithHitResult, HitResult) == 0x000000, "Member 'HWProjectile_MakeProjectileEffectContextWithHitResult::HitResult' has a wrong offset!");
static_assert(offsetof(HWProjectile_MakeProjectileEffectContextWithHitResult, ReturnValue) == 0x0000E8, "Member 'HWProjectile_MakeProjectileEffectContextWithHitResult::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.ShouldApplyHitEffectsToActor
// 0x0030 (0x0030 - 0x0000)
struct HWProjectile_ShouldApplyHitEffectsToActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        InAcceptableProjectileHitFilterHandle;             // 0x0008(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        InAllyAcceptableProjectileHitFilterHandle;         // 0x0018(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWProjectile_ShouldApplyHitEffectsToActor) == 0x000008, "Wrong alignment on HWProjectile_ShouldApplyHitEffectsToActor");
static_assert(sizeof(HWProjectile_ShouldApplyHitEffectsToActor) == 0x000030, "Wrong size on HWProjectile_ShouldApplyHitEffectsToActor");
static_assert(offsetof(HWProjectile_ShouldApplyHitEffectsToActor, TargetActor) == 0x000000, "Member 'HWProjectile_ShouldApplyHitEffectsToActor::TargetActor' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldApplyHitEffectsToActor, InAcceptableProjectileHitFilterHandle) == 0x000008, "Member 'HWProjectile_ShouldApplyHitEffectsToActor::InAcceptableProjectileHitFilterHandle' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldApplyHitEffectsToActor, InAllyAcceptableProjectileHitFilterHandle) == 0x000018, "Member 'HWProjectile_ShouldApplyHitEffectsToActor::InAllyAcceptableProjectileHitFilterHandle' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldApplyHitEffectsToActor, ReturnValue) == 0x000028, "Member 'HWProjectile_ShouldApplyHitEffectsToActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.ShouldDestroyOnTargetHit
// 0x0030 (0x0030 - 0x0000)
struct HWProjectile_ShouldDestroyOnTargetHit final
{
public:
	const class AActor*                           OtherActor;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        InAllyAcceptableProjectileHitFilter;               // 0x0008(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        InDestroyOnTargetHitFilter;                        // 0x0018(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWProjectile_ShouldDestroyOnTargetHit) == 0x000008, "Wrong alignment on HWProjectile_ShouldDestroyOnTargetHit");
static_assert(sizeof(HWProjectile_ShouldDestroyOnTargetHit) == 0x000030, "Wrong size on HWProjectile_ShouldDestroyOnTargetHit");
static_assert(offsetof(HWProjectile_ShouldDestroyOnTargetHit, OtherActor) == 0x000000, "Member 'HWProjectile_ShouldDestroyOnTargetHit::OtherActor' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldDestroyOnTargetHit, InAllyAcceptableProjectileHitFilter) == 0x000008, "Member 'HWProjectile_ShouldDestroyOnTargetHit::InAllyAcceptableProjectileHitFilter' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldDestroyOnTargetHit, InDestroyOnTargetHitFilter) == 0x000018, "Member 'HWProjectile_ShouldDestroyOnTargetHit::InDestroyOnTargetHitFilter' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldDestroyOnTargetHit, ReturnValue) == 0x000028, "Member 'HWProjectile_ShouldDestroyOnTargetHit::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.ShouldDestroyOnWorldHit
// 0x0100 (0x0100 - 0x0000)
struct HWProjectile_ShouldDestroyOnWorldHit final
{
public:
	const class AActor*                           OtherActor;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0010(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsPredicting;                                     // 0x00F8(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F9(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWProjectile_ShouldDestroyOnWorldHit) == 0x000008, "Wrong alignment on HWProjectile_ShouldDestroyOnWorldHit");
static_assert(sizeof(HWProjectile_ShouldDestroyOnWorldHit) == 0x000100, "Wrong size on HWProjectile_ShouldDestroyOnWorldHit");
static_assert(offsetof(HWProjectile_ShouldDestroyOnWorldHit, OtherActor) == 0x000000, "Member 'HWProjectile_ShouldDestroyOnWorldHit::OtherActor' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldDestroyOnWorldHit, OtherComponent) == 0x000008, "Member 'HWProjectile_ShouldDestroyOnWorldHit::OtherComponent' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldDestroyOnWorldHit, Hit) == 0x000010, "Member 'HWProjectile_ShouldDestroyOnWorldHit::Hit' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldDestroyOnWorldHit, bIsPredicting) == 0x0000F8, "Member 'HWProjectile_ShouldDestroyOnWorldHit::bIsPredicting' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldDestroyOnWorldHit, ReturnValue) == 0x0000F9, "Member 'HWProjectile_ShouldDestroyOnWorldHit::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.ShouldExplodeOnTrigger
// 0x000C (0x000C - 0x0000)
struct HWProjectile_ShouldExplodeOnTrigger final
{
public:
	EHWDestroyProjectileReason                    ExplodeTrigger;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityLevel;                                      // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWProjectile_ShouldExplodeOnTrigger) == 0x000004, "Wrong alignment on HWProjectile_ShouldExplodeOnTrigger");
static_assert(sizeof(HWProjectile_ShouldExplodeOnTrigger) == 0x00000C, "Wrong size on HWProjectile_ShouldExplodeOnTrigger");
static_assert(offsetof(HWProjectile_ShouldExplodeOnTrigger, ExplodeTrigger) == 0x000000, "Member 'HWProjectile_ShouldExplodeOnTrigger::ExplodeTrigger' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldExplodeOnTrigger, AbilityLevel) == 0x000004, "Member 'HWProjectile_ShouldExplodeOnTrigger::AbilityLevel' has a wrong offset!");
static_assert(offsetof(HWProjectile_ShouldExplodeOnTrigger, ReturnValue) == 0x000008, "Member 'HWProjectile_ShouldExplodeOnTrigger::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectile.ShouldUseTargetLocationForExplosionLocation
// 0x0001 (0x0001 - 0x0000)
struct HWProjectile_ShouldUseTargetLocationForExplosionLocation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectile_ShouldUseTargetLocationForExplosionLocation) == 0x000001, "Wrong alignment on HWProjectile_ShouldUseTargetLocationForExplosionLocation");
static_assert(sizeof(HWProjectile_ShouldUseTargetLocationForExplosionLocation) == 0x000001, "Wrong size on HWProjectile_ShouldUseTargetLocationForExplosionLocation");
static_assert(offsetof(HWProjectile_ShouldUseTargetLocationForExplosionLocation, ReturnValue) == 0x000000, "Member 'HWProjectile_ShouldUseTargetLocationForExplosionLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWMapItem.GetAllTexturesForGameplayTag
// 0x0058 (0x0058 - 0x0000)
struct HWMapItem_GetAllTexturesForGameplayTag final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSoftObjectPtr<class UTexture2D>> OutTextures;                         // 0x0008(0x0050)(Parm, OutParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMapItem_GetAllTexturesForGameplayTag) == 0x000008, "Wrong alignment on HWMapItem_GetAllTexturesForGameplayTag");
static_assert(sizeof(HWMapItem_GetAllTexturesForGameplayTag) == 0x000058, "Wrong size on HWMapItem_GetAllTexturesForGameplayTag");
static_assert(offsetof(HWMapItem_GetAllTexturesForGameplayTag, GameplayTag) == 0x000000, "Member 'HWMapItem_GetAllTexturesForGameplayTag::GameplayTag' has a wrong offset!");
static_assert(offsetof(HWMapItem_GetAllTexturesForGameplayTag, OutTextures) == 0x000008, "Member 'HWMapItem_GetAllTexturesForGameplayTag::OutTextures' has a wrong offset!");

// Function Hemingway.HWMapItem.GetTextureForExactGameplayTag
// 0x0030 (0x0030 - 0x0000)
struct HWMapItem_GetTextureForExactGameplayTag final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMapItem_GetTextureForExactGameplayTag) == 0x000008, "Wrong alignment on HWMapItem_GetTextureForExactGameplayTag");
static_assert(sizeof(HWMapItem_GetTextureForExactGameplayTag) == 0x000030, "Wrong size on HWMapItem_GetTextureForExactGameplayTag");
static_assert(offsetof(HWMapItem_GetTextureForExactGameplayTag, GameplayTag) == 0x000000, "Member 'HWMapItem_GetTextureForExactGameplayTag::GameplayTag' has a wrong offset!");
static_assert(offsetof(HWMapItem_GetTextureForExactGameplayTag, ReturnValue) == 0x000008, "Member 'HWMapItem_GetTextureForExactGameplayTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_Damage.GetBaseDamageStackMuliplier
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayEffect_Damage_GetBaseDamageStackMuliplier final
{
public:
	int32                                         StackCount;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_Damage_GetBaseDamageStackMuliplier) == 0x000004, "Wrong alignment on HWGameplayEffect_Damage_GetBaseDamageStackMuliplier");
static_assert(sizeof(HWGameplayEffect_Damage_GetBaseDamageStackMuliplier) == 0x000008, "Wrong size on HWGameplayEffect_Damage_GetBaseDamageStackMuliplier");
static_assert(offsetof(HWGameplayEffect_Damage_GetBaseDamageStackMuliplier, StackCount) == 0x000000, "Member 'HWGameplayEffect_Damage_GetBaseDamageStackMuliplier::StackCount' has a wrong offset!");
static_assert(offsetof(HWGameplayEffect_Damage_GetBaseDamageStackMuliplier, ReturnValue) == 0x000004, "Member 'HWGameplayEffect_Damage_GetBaseDamageStackMuliplier::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_Damage.GetDamageType
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayEffect_Damage_GetDamageType final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_Damage_GetDamageType) == 0x000004, "Wrong alignment on HWGameplayEffect_Damage_GetDamageType");
static_assert(sizeof(HWGameplayEffect_Damage_GetDamageType) == 0x000008, "Wrong size on HWGameplayEffect_Damage_GetDamageType");
static_assert(offsetof(HWGameplayEffect_Damage_GetDamageType, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_Damage_GetDamageType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_Damage.GetFloatingTextTagOverride
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayEffect_Damage_GetFloatingTextTagOverride final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_Damage_GetFloatingTextTagOverride) == 0x000004, "Wrong alignment on HWGameplayEffect_Damage_GetFloatingTextTagOverride");
static_assert(sizeof(HWGameplayEffect_Damage_GetFloatingTextTagOverride) == 0x000008, "Wrong size on HWGameplayEffect_Damage_GetFloatingTextTagOverride");
static_assert(offsetof(HWGameplayEffect_Damage_GetFloatingTextTagOverride, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_Damage_GetFloatingTextTagOverride::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_Damage.GetScalingDamageStackMuliplier
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayEffect_Damage_GetScalingDamageStackMuliplier final
{
public:
	int32                                         StackCount;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_Damage_GetScalingDamageStackMuliplier) == 0x000004, "Wrong alignment on HWGameplayEffect_Damage_GetScalingDamageStackMuliplier");
static_assert(sizeof(HWGameplayEffect_Damage_GetScalingDamageStackMuliplier) == 0x000008, "Wrong size on HWGameplayEffect_Damage_GetScalingDamageStackMuliplier");
static_assert(offsetof(HWGameplayEffect_Damage_GetScalingDamageStackMuliplier, StackCount) == 0x000000, "Member 'HWGameplayEffect_Damage_GetScalingDamageStackMuliplier::StackCount' has a wrong offset!");
static_assert(offsetof(HWGameplayEffect_Damage_GetScalingDamageStackMuliplier, ReturnValue) == 0x000004, "Member 'HWGameplayEffect_Damage_GetScalingDamageStackMuliplier::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_Damage.GetSuppressDamageNumbers
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_Damage_GetSuppressDamageNumbers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_Damage_GetSuppressDamageNumbers) == 0x000001, "Wrong alignment on HWGameplayEffect_Damage_GetSuppressDamageNumbers");
static_assert(sizeof(HWGameplayEffect_Damage_GetSuppressDamageNumbers) == 0x000001, "Wrong size on HWGameplayEffect_Damage_GetSuppressDamageNumbers");
static_assert(offsetof(HWGameplayEffect_Damage_GetSuppressDamageNumbers, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_Damage_GetSuppressDamageNumbers::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQuest.WantsToTrackMatchForPlayer
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_WantsToTrackMatchForPlayer final
{
public:
	const class AHWPlayerState*                   Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQuest_WantsToTrackMatchForPlayer) == 0x000008, "Wrong alignment on HWQuest_WantsToTrackMatchForPlayer");
static_assert(sizeof(HWQuest_WantsToTrackMatchForPlayer) == 0x000010, "Wrong size on HWQuest_WantsToTrackMatchForPlayer");
static_assert(offsetof(HWQuest_WantsToTrackMatchForPlayer, Player) == 0x000000, "Member 'HWQuest_WantsToTrackMatchForPlayer::Player' has a wrong offset!");
static_assert(offsetof(HWQuest_WantsToTrackMatchForPlayer, ReturnValue) == 0x000008, "Member 'HWQuest_WantsToTrackMatchForPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWActiveQuest.AddTransientProgress
// 0x0004 (0x0004 - 0x0000)
struct HWActiveQuest_AddTransientProgress final
{
public:
	int32                                         CountToIncreaseProgress;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWActiveQuest_AddTransientProgress) == 0x000004, "Wrong alignment on HWActiveQuest_AddTransientProgress");
static_assert(sizeof(HWActiveQuest_AddTransientProgress) == 0x000004, "Wrong size on HWActiveQuest_AddTransientProgress");
static_assert(offsetof(HWActiveQuest_AddTransientProgress, CountToIncreaseProgress) == 0x000000, "Member 'HWActiveQuest_AddTransientProgress::CountToIncreaseProgress' has a wrong offset!");

// Function Hemingway.HWActiveQuest.AwardQuestProgress
// 0x0004 (0x0004 - 0x0000)
struct HWActiveQuest_AwardQuestProgress final
{
public:
	int32                                         CountToIncreaseProgress;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWActiveQuest_AwardQuestProgress) == 0x000004, "Wrong alignment on HWActiveQuest_AwardQuestProgress");
static_assert(sizeof(HWActiveQuest_AwardQuestProgress) == 0x000004, "Wrong size on HWActiveQuest_AwardQuestProgress");
static_assert(offsetof(HWActiveQuest_AwardQuestProgress, CountToIncreaseProgress) == 0x000000, "Member 'HWActiveQuest_AwardQuestProgress::CountToIncreaseProgress' has a wrong offset!");

// Function Hemingway.HWActiveQuest.GetCurrentQuestProgress
// 0x0004 (0x0004 - 0x0000)
struct HWActiveQuest_GetCurrentQuestProgress final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWActiveQuest_GetCurrentQuestProgress) == 0x000004, "Wrong alignment on HWActiveQuest_GetCurrentQuestProgress");
static_assert(sizeof(HWActiveQuest_GetCurrentQuestProgress) == 0x000004, "Wrong size on HWActiveQuest_GetCurrentQuestProgress");
static_assert(offsetof(HWActiveQuest_GetCurrentQuestProgress, ReturnValue) == 0x000000, "Member 'HWActiveQuest_GetCurrentQuestProgress::ReturnValue' has a wrong offset!");

// Function Hemingway.HWActiveQuest.GetRemainingCoopProgressAvailable
// 0x0008 (0x0008 - 0x0000)
struct HWActiveQuest_GetRemainingCoopProgressAvailable final
{
public:
	int32                                         CountToIncreaseProgress;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWActiveQuest_GetRemainingCoopProgressAvailable) == 0x000004, "Wrong alignment on HWActiveQuest_GetRemainingCoopProgressAvailable");
static_assert(sizeof(HWActiveQuest_GetRemainingCoopProgressAvailable) == 0x000008, "Wrong size on HWActiveQuest_GetRemainingCoopProgressAvailable");
static_assert(offsetof(HWActiveQuest_GetRemainingCoopProgressAvailable, CountToIncreaseProgress) == 0x000000, "Member 'HWActiveQuest_GetRemainingCoopProgressAvailable::CountToIncreaseProgress' has a wrong offset!");
static_assert(offsetof(HWActiveQuest_GetRemainingCoopProgressAvailable, ReturnValue) == 0x000004, "Member 'HWActiveQuest_GetRemainingCoopProgressAvailable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWActiveQuest.TrackQuestForPlayer
// 0x0010 (0x0010 - 0x0000)
struct HWActiveQuest_TrackQuestForPlayer final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWActiveQuest_TrackQuestForPlayer) == 0x000008, "Wrong alignment on HWActiveQuest_TrackQuestForPlayer");
static_assert(sizeof(HWActiveQuest_TrackQuestForPlayer) == 0x000010, "Wrong size on HWActiveQuest_TrackQuestForPlayer");
static_assert(offsetof(HWActiveQuest_TrackQuestForPlayer, TrackedQuest) == 0x000000, "Member 'HWActiveQuest_TrackQuestForPlayer::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWActiveQuest_TrackQuestForPlayer, CharAbSysActor) == 0x000008, "Member 'HWActiveQuest_TrackQuestForPlayer::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWActiveQuest.GetCurrentWorldTime
// 0x0004 (0x0004 - 0x0000)
struct HWActiveQuest_GetCurrentWorldTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWActiveQuest_GetCurrentWorldTime) == 0x000004, "Wrong alignment on HWActiveQuest_GetCurrentWorldTime");
static_assert(sizeof(HWActiveQuest_GetCurrentWorldTime) == 0x000004, "Wrong size on HWActiveQuest_GetCurrentWorldTime");
static_assert(offsetof(HWActiveQuest_GetCurrentWorldTime, ReturnValue) == 0x000000, "Member 'HWActiveQuest_GetCurrentWorldTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQuest_AbilityTagListener.HandleAbilityEvent
// 0x0004 (0x0004 - 0x0000)
struct HWQuest_AbilityTagListener_HandleAbilityEvent final
{
public:
	int32                                         ProgressToAward;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_AbilityTagListener_HandleAbilityEvent) == 0x000004, "Wrong alignment on HWQuest_AbilityTagListener_HandleAbilityEvent");
static_assert(sizeof(HWQuest_AbilityTagListener_HandleAbilityEvent) == 0x000004, "Wrong size on HWQuest_AbilityTagListener_HandleAbilityEvent");
static_assert(offsetof(HWQuest_AbilityTagListener_HandleAbilityEvent, ProgressToAward) == 0x000000, "Member 'HWQuest_AbilityTagListener_HandleAbilityEvent::ProgressToAward' has a wrong offset!");

// Function Hemingway.HWQuest_AbilityTagListener.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_AbilityTagListener_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_AbilityTagListener_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_AbilityTagListener_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_AbilityTagListener_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_AbilityTagListener_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_AbilityTagListener_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_AbilityTagListener_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_AbilityTagListener_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_AbilityTagListener_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWAbilitySystemGlobals.SetAbilityTargetingDebug
// 0x0001 (0x0001 - 0x0000)
struct HWAbilitySystemGlobals_SetAbilityTargetingDebug final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemGlobals_SetAbilityTargetingDebug) == 0x000001, "Wrong alignment on HWAbilitySystemGlobals_SetAbilityTargetingDebug");
static_assert(sizeof(HWAbilitySystemGlobals_SetAbilityTargetingDebug) == 0x000001, "Wrong size on HWAbilitySystemGlobals_SetAbilityTargetingDebug");
static_assert(offsetof(HWAbilitySystemGlobals_SetAbilityTargetingDebug, bOn) == 0x000000, "Member 'HWAbilitySystemGlobals_SetAbilityTargetingDebug::bOn' has a wrong offset!");

// Function Hemingway.HWAbilitySystemGlobals.IsAbilityTargetingDebugEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWAbilitySystemGlobals_IsAbilityTargetingDebugEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemGlobals_IsAbilityTargetingDebugEnabled) == 0x000001, "Wrong alignment on HWAbilitySystemGlobals_IsAbilityTargetingDebugEnabled");
static_assert(sizeof(HWAbilitySystemGlobals_IsAbilityTargetingDebugEnabled) == 0x000001, "Wrong size on HWAbilitySystemGlobals_IsAbilityTargetingDebugEnabled");
static_assert(offsetof(HWAbilitySystemGlobals_IsAbilityTargetingDebugEnabled, ReturnValue) == 0x000000, "Member 'HWAbilitySystemGlobals_IsAbilityTargetingDebugEnabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotGoal.TriggerOnGoalReached
// 0x0008 (0x0008 - 0x0000)
struct HWBotGoal_TriggerOnGoalReached final
{
public:
	class AActor*                                 BotInstigator;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotGoal_TriggerOnGoalReached) == 0x000008, "Wrong alignment on HWBotGoal_TriggerOnGoalReached");
static_assert(sizeof(HWBotGoal_TriggerOnGoalReached) == 0x000008, "Wrong size on HWBotGoal_TriggerOnGoalReached");
static_assert(offsetof(HWBotGoal_TriggerOnGoalReached, BotInstigator) == 0x000000, "Member 'HWBotGoal_TriggerOnGoalReached::BotInstigator' has a wrong offset!");

// Function Hemingway.HWQuest_DamageByType.OnDealtDamage
// 0x0070 (0x0070 - 0x0000)
struct HWQuest_DamageByType_OnDealtDamage final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_DamageByType_OnDealtDamage) == 0x000008, "Wrong alignment on HWQuest_DamageByType_OnDealtDamage");
static_assert(sizeof(HWQuest_DamageByType_OnDealtDamage) == 0x000070, "Wrong size on HWQuest_DamageByType_OnDealtDamage");
static_assert(offsetof(HWQuest_DamageByType_OnDealtDamage, DamageEventData) == 0x000000, "Member 'HWQuest_DamageByType_OnDealtDamage::DamageEventData' has a wrong offset!");

// Function Hemingway.HWQuest_DamageByType.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_DamageByType_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_DamageByType_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_DamageByType_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_DamageByType_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_DamageByType_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_DamageByType_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_DamageByType_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_DamageByType_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_DamageByType_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWQuest_DistanceTravelled.OnMovementUpdated
// 0x0038 (0x0038 - 0x0000)
struct HWQuest_DistanceTravelled_OnMovementUpdated final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OldLocation;                                       // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OldVelocity;                                       // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_DistanceTravelled_OnMovementUpdated) == 0x000008, "Wrong alignment on HWQuest_DistanceTravelled_OnMovementUpdated");
static_assert(sizeof(HWQuest_DistanceTravelled_OnMovementUpdated) == 0x000038, "Wrong size on HWQuest_DistanceTravelled_OnMovementUpdated");
static_assert(offsetof(HWQuest_DistanceTravelled_OnMovementUpdated, DeltaSeconds) == 0x000000, "Member 'HWQuest_DistanceTravelled_OnMovementUpdated::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(HWQuest_DistanceTravelled_OnMovementUpdated, OldLocation) == 0x000008, "Member 'HWQuest_DistanceTravelled_OnMovementUpdated::OldLocation' has a wrong offset!");
static_assert(offsetof(HWQuest_DistanceTravelled_OnMovementUpdated, OldVelocity) == 0x000020, "Member 'HWQuest_DistanceTravelled_OnMovementUpdated::OldVelocity' has a wrong offset!");

// Function Hemingway.HWQuest_DistanceTravelled.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_DistanceTravelled_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_DistanceTravelled_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_DistanceTravelled_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_DistanceTravelled_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_DistanceTravelled_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_DistanceTravelled_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_DistanceTravelled_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_DistanceTravelled_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_DistanceTravelled_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWQuest_HealingByType.OnHealingDone
// 0x0040 (0x0040 - 0x0000)
struct HWQuest_HealingByType_OnHealingDone final
{
public:
	struct FHealEventData                         HealEventData;                                     // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_HealingByType_OnHealingDone) == 0x000008, "Wrong alignment on HWQuest_HealingByType_OnHealingDone");
static_assert(sizeof(HWQuest_HealingByType_OnHealingDone) == 0x000040, "Wrong size on HWQuest_HealingByType_OnHealingDone");
static_assert(offsetof(HWQuest_HealingByType_OnHealingDone, HealEventData) == 0x000000, "Member 'HWQuest_HealingByType_OnHealingDone::HealEventData' has a wrong offset!");

// Function Hemingway.HWQuest_HealingByType.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_HealingByType_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_HealingByType_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_HealingByType_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_HealingByType_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_HealingByType_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_HealingByType_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_HealingByType_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_HealingByType_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_HealingByType_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.ActivateLocalGameplayCue
// 0x00E8 (0x00E8 - 0x0000)
struct HWLibrary_AbilitySystem_ActivateLocalGameplayCue final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0010(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_ActivateLocalGameplayCue) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_ActivateLocalGameplayCue");
static_assert(sizeof(HWLibrary_AbilitySystem_ActivateLocalGameplayCue) == 0x0000E8, "Wrong size on HWLibrary_AbilitySystem_ActivateLocalGameplayCue");
static_assert(offsetof(HWLibrary_AbilitySystem_ActivateLocalGameplayCue, Target) == 0x000000, "Member 'HWLibrary_AbilitySystem_ActivateLocalGameplayCue::Target' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_ActivateLocalGameplayCue, GameplayCueTag) == 0x000008, "Member 'HWLibrary_AbilitySystem_ActivateLocalGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_ActivateLocalGameplayCue, GameplayCueParameters) == 0x000010, "Member 'HWLibrary_AbilitySystem_ActivateLocalGameplayCue::GameplayCueParameters' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.AddHitToMultiHitTargetData
// 0x0118 (0x0118 - 0x0000)
struct HWLibrary_AbilitySystem_AddHitToMultiHitTargetData final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandleToModify;                          // 0x00E8(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         TargetDataIndexToModify;                           // 0x0110(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_AddHitToMultiHitTargetData) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_AddHitToMultiHitTargetData");
static_assert(sizeof(HWLibrary_AbilitySystem_AddHitToMultiHitTargetData) == 0x000118, "Wrong size on HWLibrary_AbilitySystem_AddHitToMultiHitTargetData");
static_assert(offsetof(HWLibrary_AbilitySystem_AddHitToMultiHitTargetData, Hit) == 0x000000, "Member 'HWLibrary_AbilitySystem_AddHitToMultiHitTargetData::Hit' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_AddHitToMultiHitTargetData, TargetDataHandleToModify) == 0x0000E8, "Member 'HWLibrary_AbilitySystem_AddHitToMultiHitTargetData::TargetDataHandleToModify' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_AddHitToMultiHitTargetData, TargetDataIndexToModify) == 0x000110, "Member 'HWLibrary_AbilitySystem_AddHitToMultiHitTargetData::TargetDataIndexToModify' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.AddMultiHitResultsToTargetData
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetDataHandleToModify;                          // 0x0000(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandleToAdd;                             // 0x0028(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         TargetDataIndexToModify;                           // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetDataIndexToAdd;                              // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData");
static_assert(sizeof(HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData) == 0x000058, "Wrong size on HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData");
static_assert(offsetof(HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData, TargetDataHandleToModify) == 0x000000, "Member 'HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData::TargetDataHandleToModify' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData, TargetDataHandleToAdd) == 0x000028, "Member 'HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData::TargetDataHandleToAdd' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData, TargetDataIndexToModify) == 0x000050, "Member 'HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData::TargetDataIndexToModify' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData, TargetDataIndexToAdd) == 0x000054, "Member 'HWLibrary_AbilitySystem_AddMultiHitResultsToTargetData::TargetDataIndexToAdd' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.AddSingleHitTargetDataToMultiHitTargetData
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetDataHandleToModify;                          // 0x0000(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandleToAdd;                             // 0x0028(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         TargetDataIndexToModify;                           // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetDataIndexToAdd;                              // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData");
static_assert(sizeof(HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData) == 0x000058, "Wrong size on HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData");
static_assert(offsetof(HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData, TargetDataHandleToModify) == 0x000000, "Member 'HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData::TargetDataHandleToModify' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData, TargetDataHandleToAdd) == 0x000028, "Member 'HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData::TargetDataHandleToAdd' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData, TargetDataIndexToModify) == 0x000050, "Member 'HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData::TargetDataIndexToModify' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData, TargetDataIndexToAdd) == 0x000054, "Member 'HWLibrary_AbilitySystem_AddSingleHitTargetDataToMultiHitTargetData::TargetDataIndexToAdd' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.BP_GetHWAbilitySystem
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_AbilitySystem_BP_GetHWAbilitySystem final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_BP_GetHWAbilitySystem) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_BP_GetHWAbilitySystem");
static_assert(sizeof(HWLibrary_AbilitySystem_BP_GetHWAbilitySystem) == 0x000018, "Wrong size on HWLibrary_AbilitySystem_BP_GetHWAbilitySystem");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_GetHWAbilitySystem, Actor) == 0x000000, "Member 'HWLibrary_AbilitySystem_BP_GetHWAbilitySystem::Actor' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_GetHWAbilitySystem, bSuccess) == 0x000008, "Member 'HWLibrary_AbilitySystem_BP_GetHWAbilitySystem::bSuccess' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_GetHWAbilitySystem, ReturnValue) == 0x000010, "Member 'HWLibrary_AbilitySystem_BP_GetHWAbilitySystem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.BP_MulticastSendGameplayEventToActor
// 0x00C0 (0x00C0 - 0x0000)
struct HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor final
{
public:
	class AActor*                                 EventReciever;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor");
static_assert(sizeof(HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor) == 0x0000C0, "Wrong size on HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor, EventReciever) == 0x000000, "Member 'HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor::EventReciever' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor, EventTag) == 0x000008, "Member 'HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor::EventTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor, Payload) == 0x000010, "Member 'HWLibrary_AbilitySystem_BP_MulticastSendGameplayEventToActor::Payload' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.BP_OwningClientSendGameplayEventToActor
// 0x00C0 (0x00C0 - 0x0000)
struct HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor final
{
public:
	class AActor*                                 EventReciever;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor");
static_assert(sizeof(HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor) == 0x0000C0, "Wrong size on HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor, EventReciever) == 0x000000, "Member 'HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor::EventReciever' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor, EventTag) == 0x000008, "Member 'HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor::EventTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor, Payload) == 0x000010, "Member 'HWLibrary_AbilitySystem_BP_OwningClientSendGameplayEventToActor::Payload' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.BP_ServerSendGameplayEventToActor
// 0x00C0 (0x00C0 - 0x0000)
struct HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor final
{
public:
	class AActor*                                 EventReciever;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor");
static_assert(sizeof(HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor) == 0x0000C0, "Wrong size on HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor, EventReciever) == 0x000000, "Member 'HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor::EventReciever' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor, EventTag) == 0x000008, "Member 'HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor::EventTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor, Payload) == 0x000010, "Member 'HWLibrary_AbilitySystem_BP_ServerSendGameplayEventToActor::Payload' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CalculateCooldownMultiplier
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_AbilitySystem_CalculateCooldownMultiplier final
{
public:
	const class UHWGameplayAbility*               InstigatingAbility;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownRate;                                      // 0x0008(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutCooldownMultiplier;                             // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_CalculateCooldownMultiplier) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_CalculateCooldownMultiplier");
static_assert(sizeof(HWLibrary_AbilitySystem_CalculateCooldownMultiplier) == 0x000010, "Wrong size on HWLibrary_AbilitySystem_CalculateCooldownMultiplier");
static_assert(offsetof(HWLibrary_AbilitySystem_CalculateCooldownMultiplier, InstigatingAbility) == 0x000000, "Member 'HWLibrary_AbilitySystem_CalculateCooldownMultiplier::InstigatingAbility' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CalculateCooldownMultiplier, CooldownRate) == 0x000008, "Member 'HWLibrary_AbilitySystem_CalculateCooldownMultiplier::CooldownRate' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CalculateCooldownMultiplier, OutCooldownMultiplier) == 0x00000C, "Member 'HWLibrary_AbilitySystem_CalculateCooldownMultiplier::OutCooldownMultiplier' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CalculateCooldownMultiplierForOffhands
// 0x0008 (0x0008 - 0x0000)
struct HWLibrary_AbilitySystem_CalculateCooldownMultiplierForOffhands final
{
public:
	float                                         CooldownRate;                                      // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutCooldownMultiplier;                             // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_CalculateCooldownMultiplierForOffhands) == 0x000004, "Wrong alignment on HWLibrary_AbilitySystem_CalculateCooldownMultiplierForOffhands");
static_assert(sizeof(HWLibrary_AbilitySystem_CalculateCooldownMultiplierForOffhands) == 0x000008, "Wrong size on HWLibrary_AbilitySystem_CalculateCooldownMultiplierForOffhands");
static_assert(offsetof(HWLibrary_AbilitySystem_CalculateCooldownMultiplierForOffhands, CooldownRate) == 0x000000, "Member 'HWLibrary_AbilitySystem_CalculateCooldownMultiplierForOffhands::CooldownRate' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CalculateCooldownMultiplierForOffhands, OutCooldownMultiplier) == 0x000004, "Member 'HWLibrary_AbilitySystem_CalculateCooldownMultiplierForOffhands::OutCooldownMultiplier' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CalculateFinalCooldownDuration
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_AbilitySystem_CalculateFinalCooldownDuration final
{
public:
	float                                         BaseCooldownDuration;                              // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownMultiplier;                                // 0x0004(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownFlatDelta;                                 // 0x0008(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_CalculateFinalCooldownDuration) == 0x000004, "Wrong alignment on HWLibrary_AbilitySystem_CalculateFinalCooldownDuration");
static_assert(sizeof(HWLibrary_AbilitySystem_CalculateFinalCooldownDuration) == 0x000010, "Wrong size on HWLibrary_AbilitySystem_CalculateFinalCooldownDuration");
static_assert(offsetof(HWLibrary_AbilitySystem_CalculateFinalCooldownDuration, BaseCooldownDuration) == 0x000000, "Member 'HWLibrary_AbilitySystem_CalculateFinalCooldownDuration::BaseCooldownDuration' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CalculateFinalCooldownDuration, CooldownMultiplier) == 0x000004, "Member 'HWLibrary_AbilitySystem_CalculateFinalCooldownDuration::CooldownMultiplier' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CalculateFinalCooldownDuration, CooldownFlatDelta) == 0x000008, "Member 'HWLibrary_AbilitySystem_CalculateFinalCooldownDuration::CooldownFlatDelta' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CalculateFinalCooldownDuration, ReturnValue) == 0x00000C, "Member 'HWLibrary_AbilitySystem_CalculateFinalCooldownDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CanEffectApplyAttributeModifiers
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers final
{
public:
	class UAbilitySystemComponent*                TargetASC;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            Effect;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0018(0x0018)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers");
static_assert(sizeof(HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers) == 0x000038, "Wrong size on HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers");
static_assert(offsetof(HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers, TargetASC) == 0x000000, "Member 'HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers::TargetASC' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers, Effect) == 0x000008, "Member 'HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers::Effect' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers, Level) == 0x000010, "Member 'HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers::Level' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers, EffectContext) == 0x000018, "Member 'HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers::EffectContext' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers, ReturnValue) == 0x000030, "Member 'HWLibrary_AbilitySystem_CanEffectApplyAttributeModifiers::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CheckAbilityForId
// 0x0008 (0x0008 - 0x0000)
struct HWLibrary_AbilitySystem_CheckAbilityForId final
{
public:
	const class UClass*                           BaseAbilityClass;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_CheckAbilityForId) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_CheckAbilityForId");
static_assert(sizeof(HWLibrary_AbilitySystem_CheckAbilityForId) == 0x000008, "Wrong size on HWLibrary_AbilitySystem_CheckAbilityForId");
static_assert(offsetof(HWLibrary_AbilitySystem_CheckAbilityForId, BaseAbilityClass) == 0x000000, "Member 'HWLibrary_AbilitySystem_CheckAbilityForId::BaseAbilityClass' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CloneEffectsToASC
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_AbilitySystem_CloneEffectsToASC final
{
public:
	struct FGameplayTagContainer                  EffectTypesToClone;                                // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UAbilitySystemComponent*          FromASC;                                           // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ToASC;                                             // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_CloneEffectsToASC) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_CloneEffectsToASC");
static_assert(sizeof(HWLibrary_AbilitySystem_CloneEffectsToASC) == 0x000030, "Wrong size on HWLibrary_AbilitySystem_CloneEffectsToASC");
static_assert(offsetof(HWLibrary_AbilitySystem_CloneEffectsToASC, EffectTypesToClone) == 0x000000, "Member 'HWLibrary_AbilitySystem_CloneEffectsToASC::EffectTypesToClone' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CloneEffectsToASC, FromASC) == 0x000020, "Member 'HWLibrary_AbilitySystem_CloneEffectsToASC::FromASC' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CloneEffectsToASC, ToASC) == 0x000028, "Member 'HWLibrary_AbilitySystem_CloneEffectsToASC::ToASC' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CreateAimTargetDataFromLocation
// 0x0050 (0x0050 - 0x0000)
struct HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation final
{
public:
	struct FVector                                AimLocation;                                       // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       AbilityInstance;                                   // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0028(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation");
static_assert(sizeof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation) == 0x000050, "Wrong size on HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation, AimLocation) == 0x000000, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation::AimLocation' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation, SourceActor) == 0x000018, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation::SourceActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation, AbilityInstance) == 0x000020, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation::AbilityInstance' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation, ReturnValue) == 0x000028, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CreateAimTargetDataFromLocationInfo
// 0x02F0 (0x02F0 - 0x0000)
struct HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo final
{
public:
	struct FHWTargetData_LocationInfo             LocationInfo;                                      // 0x0000(0x02B0)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x02B0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       AbilityInstance;                                   // 0x02B8(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x02C0(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo) == 0x000010, "Wrong alignment on HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo");
static_assert(sizeof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo) == 0x0002F0, "Wrong size on HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo, LocationInfo) == 0x000000, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo::LocationInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo, SourceActor) == 0x0002B0, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo::SourceActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo, AbilityInstance) == 0x0002B8, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo::AbilityInstance' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo, ReturnValue) == 0x0002C0, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromLocationInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CreateAimTargetDataFromSpline
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_AbilitySystem_CreateAimTargetDataFromSpline final
{
public:
	const class USplineComponent*                 SplinePath;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_CreateAimTargetDataFromSpline) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_CreateAimTargetDataFromSpline");
static_assert(sizeof(HWLibrary_AbilitySystem_CreateAimTargetDataFromSpline) == 0x000030, "Wrong size on HWLibrary_AbilitySystem_CreateAimTargetDataFromSpline");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromSpline, SplinePath) == 0x000000, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromSpline::SplinePath' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromSpline, ReturnValue) == 0x000008, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromSpline::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CreateAimTargetDataFromStartAndEndLocation
// 0x00C0 (0x00C0 - 0x0000)
struct HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation final
{
public:
	struct FTransform                             AimOrigin;                                         // 0x0000(0x0060)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimEndLocation;                                    // 0x0060(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0078(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       AbilityInstance;                                   // 0x0080(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateOrignToEnd;                                 // 0x0088(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOffsetAimByLastValidHeight;                       // 0x0089(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0090(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation) == 0x000010, "Wrong alignment on HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation");
static_assert(sizeof(HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation) == 0x0000C0, "Wrong size on HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation, AimOrigin) == 0x000000, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation::AimOrigin' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation, AimEndLocation) == 0x000060, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation::AimEndLocation' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation, SourceActor) == 0x000078, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation::SourceActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation, AbilityInstance) == 0x000080, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation::AbilityInstance' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation, bRotateOrignToEnd) == 0x000088, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation::bRotateOrignToEnd' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation, bOffsetAimByLastValidHeight) == 0x000089, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation::bOffsetAimByLastValidHeight' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation, ReturnValue) == 0x000090, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromStartAndEndLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CreateAimTargetDataFromTransform
// 0x00A0 (0x00A0 - 0x0000)
struct HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform final
{
public:
	struct FTransform                             AimLocation;                                       // 0x0000(0x0060)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0060(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       AbilityInstance;                                   // 0x0068(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0070(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform) == 0x000010, "Wrong alignment on HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform");
static_assert(sizeof(HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform) == 0x0000A0, "Wrong size on HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform, AimLocation) == 0x000000, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform::AimLocation' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform, SourceActor) == 0x000060, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform::SourceActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform, AbilityInstance) == 0x000068, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform::AbilityInstance' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform, ReturnValue) == 0x000070, "Member 'HWLibrary_AbilitySystem_CreateAimTargetDataFromTransform::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.CreateSingleHitTargetDataFromActor
// 0x0048 (0x0048 - 0x0000)
struct HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetDataHitNormal;                               // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0020(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor");
static_assert(sizeof(HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor) == 0x000048, "Wrong size on HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor, Target) == 0x000000, "Member 'HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor::Target' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor, TargetDataHitNormal) == 0x000008, "Member 'HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor::TargetDataHitNormal' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor, ReturnValue) == 0x000020, "Member 'HWLibrary_AbilitySystem_CreateSingleHitTargetDataFromActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.DeactivateLocalGameplayCue
// 0x00E8 (0x00E8 - 0x0000)
struct HWLibrary_AbilitySystem_DeactivateLocalGameplayCue final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0010(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_DeactivateLocalGameplayCue) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_DeactivateLocalGameplayCue");
static_assert(sizeof(HWLibrary_AbilitySystem_DeactivateLocalGameplayCue) == 0x0000E8, "Wrong size on HWLibrary_AbilitySystem_DeactivateLocalGameplayCue");
static_assert(offsetof(HWLibrary_AbilitySystem_DeactivateLocalGameplayCue, Target) == 0x000000, "Member 'HWLibrary_AbilitySystem_DeactivateLocalGameplayCue::Target' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_DeactivateLocalGameplayCue, GameplayCueTag) == 0x000008, "Member 'HWLibrary_AbilitySystem_DeactivateLocalGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_DeactivateLocalGameplayCue, GameplayCueParameters) == 0x000010, "Member 'HWLibrary_AbilitySystem_DeactivateLocalGameplayCue::GameplayCueParameters' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.DoesTargetDataHaveValidTarget
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0028(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget");
static_assert(sizeof(HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget) == 0x000030, "Wrong size on HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget");
static_assert(offsetof(HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget, TargetDataHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget, Index_0) == 0x000028, "Member 'HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget::Index_0' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget, ReturnValue) == 0x00002C, "Member 'HWLibrary_AbilitySystem_DoesTargetDataHaveValidTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.ExecuteLocalGameplayCue
// 0x00E8 (0x00E8 - 0x0000)
struct HWLibrary_AbilitySystem_ExecuteLocalGameplayCue final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0010(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_ExecuteLocalGameplayCue) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_ExecuteLocalGameplayCue");
static_assert(sizeof(HWLibrary_AbilitySystem_ExecuteLocalGameplayCue) == 0x0000E8, "Wrong size on HWLibrary_AbilitySystem_ExecuteLocalGameplayCue");
static_assert(offsetof(HWLibrary_AbilitySystem_ExecuteLocalGameplayCue, Target) == 0x000000, "Member 'HWLibrary_AbilitySystem_ExecuteLocalGameplayCue::Target' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_ExecuteLocalGameplayCue, GameplayCueTag) == 0x000008, "Member 'HWLibrary_AbilitySystem_ExecuteLocalGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_ExecuteLocalGameplayCue, GameplayCueParameters) == 0x000010, "Member 'HWLibrary_AbilitySystem_ExecuteLocalGameplayCue::GameplayCueParameters' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetEffectContextFromActiveEffect
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_AbilitySystem_GetEffectContextFromActiveEffect final
{
public:
	struct FActiveGameplayEffectHandle            ActiveEffectHandle;                                // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetEffectContextFromActiveEffect) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetEffectContextFromActiveEffect");
static_assert(sizeof(HWLibrary_AbilitySystem_GetEffectContextFromActiveEffect) == 0x000020, "Wrong size on HWLibrary_AbilitySystem_GetEffectContextFromActiveEffect");
static_assert(offsetof(HWLibrary_AbilitySystem_GetEffectContextFromActiveEffect, ActiveEffectHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetEffectContextFromActiveEffect::ActiveEffectHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetEffectContextFromActiveEffect, ReturnValue) == 0x000008, "Member 'HWLibrary_AbilitySystem_GetEffectContextFromActiveEffect::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetFiringInstanceIdFromEffectContext
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_AbilitySystem_GetFiringInstanceIdFromEffectContext final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetFiringInstanceIdFromEffectContext) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetFiringInstanceIdFromEffectContext");
static_assert(sizeof(HWLibrary_AbilitySystem_GetFiringInstanceIdFromEffectContext) == 0x000020, "Wrong size on HWLibrary_AbilitySystem_GetFiringInstanceIdFromEffectContext");
static_assert(offsetof(HWLibrary_AbilitySystem_GetFiringInstanceIdFromEffectContext, EffectContextHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetFiringInstanceIdFromEffectContext::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetFiringInstanceIdFromEffectContext, ReturnValue) == 0x000018, "Member 'HWLibrary_AbilitySystem_GetFiringInstanceIdFromEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetGameplayEffectClassFromEffectSpec
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_AbilitySystem_GetGameplayEffectClassFromEffectSpec final
{
public:
	struct FGameplayEffectSpecHandle              EffectSpecHandle;                                  // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetGameplayEffectClassFromEffectSpec) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetGameplayEffectClassFromEffectSpec");
static_assert(sizeof(HWLibrary_AbilitySystem_GetGameplayEffectClassFromEffectSpec) == 0x000018, "Wrong size on HWLibrary_AbilitySystem_GetGameplayEffectClassFromEffectSpec");
static_assert(offsetof(HWLibrary_AbilitySystem_GetGameplayEffectClassFromEffectSpec, EffectSpecHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetGameplayEffectClassFromEffectSpec::EffectSpecHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetGameplayEffectClassFromEffectSpec, ReturnValue) == 0x000010, "Member 'HWLibrary_AbilitySystem_GetGameplayEffectClassFromEffectSpec::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetHitActorFromEffectContext
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_AbilitySystem_GetHitActorFromEffectContext final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetHitActorFromEffectContext) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetHitActorFromEffectContext");
static_assert(sizeof(HWLibrary_AbilitySystem_GetHitActorFromEffectContext) == 0x000020, "Wrong size on HWLibrary_AbilitySystem_GetHitActorFromEffectContext");
static_assert(offsetof(HWLibrary_AbilitySystem_GetHitActorFromEffectContext, EffectContextHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetHitActorFromEffectContext::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetHitActorFromEffectContext, ReturnValue) == 0x000018, "Member 'HWLibrary_AbilitySystem_GetHitActorFromEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetInstigatingAbilityCDOAbilityTagsFromEffectContext
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_AbilitySystem_GetInstigatingAbilityCDOAbilityTagsFromEffectContext final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0018(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetInstigatingAbilityCDOAbilityTagsFromEffectContext) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetInstigatingAbilityCDOAbilityTagsFromEffectContext");
static_assert(sizeof(HWLibrary_AbilitySystem_GetInstigatingAbilityCDOAbilityTagsFromEffectContext) == 0x000038, "Wrong size on HWLibrary_AbilitySystem_GetInstigatingAbilityCDOAbilityTagsFromEffectContext");
static_assert(offsetof(HWLibrary_AbilitySystem_GetInstigatingAbilityCDOAbilityTagsFromEffectContext, EffectContextHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetInstigatingAbilityCDOAbilityTagsFromEffectContext::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetInstigatingAbilityCDOAbilityTagsFromEffectContext, ReturnValue) == 0x000018, "Member 'HWLibrary_AbilitySystem_GetInstigatingAbilityCDOAbilityTagsFromEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetInstigatingAbilityCDOFromEffectContext
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_AbilitySystem_GetInstigatingAbilityCDOFromEffectContext final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	const class UGameplayAbility*                 ReturnValue;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetInstigatingAbilityCDOFromEffectContext) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetInstigatingAbilityCDOFromEffectContext");
static_assert(sizeof(HWLibrary_AbilitySystem_GetInstigatingAbilityCDOFromEffectContext) == 0x000020, "Wrong size on HWLibrary_AbilitySystem_GetInstigatingAbilityCDOFromEffectContext");
static_assert(offsetof(HWLibrary_AbilitySystem_GetInstigatingAbilityCDOFromEffectContext, EffectContextHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetInstigatingAbilityCDOFromEffectContext::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetInstigatingAbilityCDOFromEffectContext, ReturnValue) == 0x000018, "Member 'HWLibrary_AbilitySystem_GetInstigatingAbilityCDOFromEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetInstigatingAbilityInstanceFromEffectContext
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_AbilitySystem_GetInstigatingAbilityInstanceFromEffectContext final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	const class UGameplayAbility*                 ReturnValue;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetInstigatingAbilityInstanceFromEffectContext) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetInstigatingAbilityInstanceFromEffectContext");
static_assert(sizeof(HWLibrary_AbilitySystem_GetInstigatingAbilityInstanceFromEffectContext) == 0x000020, "Wrong size on HWLibrary_AbilitySystem_GetInstigatingAbilityInstanceFromEffectContext");
static_assert(offsetof(HWLibrary_AbilitySystem_GetInstigatingAbilityInstanceFromEffectContext, EffectContextHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetInstigatingAbilityInstanceFromEffectContext::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetInstigatingAbilityInstanceFromEffectContext, ReturnValue) == 0x000018, "Member 'HWLibrary_AbilitySystem_GetInstigatingAbilityInstanceFromEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetInstigatorAbilitySystemComponentFromEffectContext
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_AbilitySystem_GetInstigatorAbilitySystemComponentFromEffectContext final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetInstigatorAbilitySystemComponentFromEffectContext) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetInstigatorAbilitySystemComponentFromEffectContext");
static_assert(sizeof(HWLibrary_AbilitySystem_GetInstigatorAbilitySystemComponentFromEffectContext) == 0x000020, "Wrong size on HWLibrary_AbilitySystem_GetInstigatorAbilitySystemComponentFromEffectContext");
static_assert(offsetof(HWLibrary_AbilitySystem_GetInstigatorAbilitySystemComponentFromEffectContext, EffectContextHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetInstigatorAbilitySystemComponentFromEffectContext::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetInstigatorAbilitySystemComponentFromEffectContext, ReturnValue) == 0x000018, "Member 'HWLibrary_AbilitySystem_GetInstigatorAbilitySystemComponentFromEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetLevelConfigForAbility
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_AbilitySystem_GetLevelConfigForAbility final
{
public:
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0008(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityLevelConfig*            ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetLevelConfigForAbility) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetLevelConfigForAbility");
static_assert(sizeof(HWLibrary_AbilitySystem_GetLevelConfigForAbility) == 0x000018, "Wrong size on HWLibrary_AbilitySystem_GetLevelConfigForAbility");
static_assert(offsetof(HWLibrary_AbilitySystem_GetLevelConfigForAbility, AbilitySystem) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetLevelConfigForAbility::AbilitySystem' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetLevelConfigForAbility, AbilityHandle) == 0x000008, "Member 'HWLibrary_AbilitySystem_GetLevelConfigForAbility::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetLevelConfigForAbility, Level) == 0x00000C, "Member 'HWLibrary_AbilitySystem_GetLevelConfigForAbility::Level' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetLevelConfigForAbility, ReturnValue) == 0x000010, "Member 'HWLibrary_AbilitySystem_GetLevelConfigForAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetLevelFromActiveEffect
// 0x000C (0x000C - 0x0000)
struct HWLibrary_AbilitySystem_GetLevelFromActiveEffect final
{
public:
	struct FActiveGameplayEffectHandle            ActiveEffectHandle;                                // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetLevelFromActiveEffect) == 0x000004, "Wrong alignment on HWLibrary_AbilitySystem_GetLevelFromActiveEffect");
static_assert(sizeof(HWLibrary_AbilitySystem_GetLevelFromActiveEffect) == 0x00000C, "Wrong size on HWLibrary_AbilitySystem_GetLevelFromActiveEffect");
static_assert(offsetof(HWLibrary_AbilitySystem_GetLevelFromActiveEffect, ActiveEffectHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetLevelFromActiveEffect::ActiveEffectHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetLevelFromActiveEffect, ReturnValue) == 0x000008, "Member 'HWLibrary_AbilitySystem_GetLevelFromActiveEffect::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetLevelFromEffectSpecRef
// 0x02B0 (0x02B0 - 0x0000)
struct HWLibrary_AbilitySystem_GetLevelFromEffectSpecRef final
{
public:
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0000(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x02A8(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_GetLevelFromEffectSpecRef) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetLevelFromEffectSpecRef");
static_assert(sizeof(HWLibrary_AbilitySystem_GetLevelFromEffectSpecRef) == 0x0002B0, "Wrong size on HWLibrary_AbilitySystem_GetLevelFromEffectSpecRef");
static_assert(offsetof(HWLibrary_AbilitySystem_GetLevelFromEffectSpecRef, EffectSpec) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetLevelFromEffectSpecRef::EffectSpec' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetLevelFromEffectSpecRef, ReturnValue) == 0x0002A8, "Member 'HWLibrary_AbilitySystem_GetLevelFromEffectSpecRef::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetMultiHitResultsFromTargetData
// 0x0040 (0x0040 - 0x0000)
struct HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData");
static_assert(sizeof(HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData) == 0x000040, "Wrong size on HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData");
static_assert(offsetof(HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData, TargetData) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData::TargetData' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData, Index_0) == 0x000028, "Member 'HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData::Index_0' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData, ReturnValue) == 0x000030, "Member 'HWLibrary_AbilitySystem_GetMultiHitResultsFromTargetData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetOriginalInstigatorAbilitySystemComponentFromEffectContext
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_AbilitySystem_GetOriginalInstigatorAbilitySystemComponentFromEffectContext final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetOriginalInstigatorAbilitySystemComponentFromEffectContext) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetOriginalInstigatorAbilitySystemComponentFromEffectContext");
static_assert(sizeof(HWLibrary_AbilitySystem_GetOriginalInstigatorAbilitySystemComponentFromEffectContext) == 0x000020, "Wrong size on HWLibrary_AbilitySystem_GetOriginalInstigatorAbilitySystemComponentFromEffectContext");
static_assert(offsetof(HWLibrary_AbilitySystem_GetOriginalInstigatorAbilitySystemComponentFromEffectContext, EffectContextHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetOriginalInstigatorAbilitySystemComponentFromEffectContext::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetOriginalInstigatorAbilitySystemComponentFromEffectContext, ReturnValue) == 0x000018, "Member 'HWLibrary_AbilitySystem_GetOriginalInstigatorAbilitySystemComponentFromEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetOwningAbilitySystemFromActiveEffect
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_AbilitySystem_GetOwningAbilitySystemFromActiveEffect final
{
public:
	struct FActiveGameplayEffectHandle            ActiveEffectHandle;                                // 0x0000(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetOwningAbilitySystemFromActiveEffect) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetOwningAbilitySystemFromActiveEffect");
static_assert(sizeof(HWLibrary_AbilitySystem_GetOwningAbilitySystemFromActiveEffect) == 0x000010, "Wrong size on HWLibrary_AbilitySystem_GetOwningAbilitySystemFromActiveEffect");
static_assert(offsetof(HWLibrary_AbilitySystem_GetOwningAbilitySystemFromActiveEffect, ActiveEffectHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetOwningAbilitySystemFromActiveEffect::ActiveEffectHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetOwningAbilitySystemFromActiveEffect, ReturnValue) == 0x000008, "Member 'HWLibrary_AbilitySystem_GetOwningAbilitySystemFromActiveEffect::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetPrimaryAbilityInstance
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_AbilitySystem_GetPrimaryAbilityInstance final
{
public:
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0008(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayAbility*                       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstance) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetPrimaryAbilityInstance");
static_assert(sizeof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstance) == 0x000018, "Wrong size on HWLibrary_AbilitySystem_GetPrimaryAbilityInstance");
static_assert(offsetof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstance, AbilitySystem) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetPrimaryAbilityInstance::AbilitySystem' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstance, AbilityHandle) == 0x000008, "Member 'HWLibrary_AbilitySystem_GetPrimaryAbilityInstance::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstance, ReturnValue) == 0x000010, "Member 'HWLibrary_AbilitySystem_GetPrimaryAbilityInstance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetPrimaryAbilityInstanceBasedOnEquipmentItem
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem final
{
public:
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWEquipmentItem*                       EquipmentItem;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem");
static_assert(sizeof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem) == 0x000018, "Wrong size on HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem");
static_assert(offsetof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem, AbilitySystem) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem::AbilitySystem' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem, EquipmentItem) == 0x000008, "Member 'HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem::EquipmentItem' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem, ReturnValue) == 0x000010, "Member 'HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnEquipmentItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetPrimaryAbilityInstanceBasedOnInventorySlot
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot final
{
public:
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       InventorySlot;                                     // 0x0008(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayAbility*                       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot");
static_assert(sizeof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot) == 0x000020, "Wrong size on HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot");
static_assert(offsetof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot, AbilitySystem) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot::AbilitySystem' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot, InventorySlot) == 0x000008, "Member 'HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot::InventorySlot' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot, ReturnValue) == 0x000018, "Member 'HWLibrary_AbilitySystem_GetPrimaryAbilityInstanceBasedOnInventorySlot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetTargetVectorFromEffectContext
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_AbilitySystem_GetTargetVectorFromEffectContext final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetTargetVectorFromEffectContext) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetTargetVectorFromEffectContext");
static_assert(sizeof(HWLibrary_AbilitySystem_GetTargetVectorFromEffectContext) == 0x000030, "Wrong size on HWLibrary_AbilitySystem_GetTargetVectorFromEffectContext");
static_assert(offsetof(HWLibrary_AbilitySystem_GetTargetVectorFromEffectContext, EffectContextHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetTargetVectorFromEffectContext::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetTargetVectorFromEffectContext, ReturnValue) == 0x000018, "Member 'HWLibrary_AbilitySystem_GetTargetVectorFromEffectContext::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GrantAbilitySetToASC
// 0x0050 (0x0050 - 0x0000)
struct HWLibrary_AbilitySystem_GrantAbilitySetToASC final
{
public:
	const class UHWAbilitySet*                    AbilitySetToGrant;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              ASC;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilitySet_GrantedHandles           OutGrantedHandles;                                 // 0x0010(0x0040)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GrantAbilitySetToASC) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GrantAbilitySetToASC");
static_assert(sizeof(HWLibrary_AbilitySystem_GrantAbilitySetToASC) == 0x000050, "Wrong size on HWLibrary_AbilitySystem_GrantAbilitySetToASC");
static_assert(offsetof(HWLibrary_AbilitySystem_GrantAbilitySetToASC, AbilitySetToGrant) == 0x000000, "Member 'HWLibrary_AbilitySystem_GrantAbilitySetToASC::AbilitySetToGrant' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GrantAbilitySetToASC, ASC) == 0x000008, "Member 'HWLibrary_AbilitySystem_GrantAbilitySetToASC::ASC' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GrantAbilitySetToASC, OutGrantedHandles) == 0x000010, "Member 'HWLibrary_AbilitySystem_GrantAbilitySetToASC::OutGrantedHandles' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.IsActiveEffectValid
// 0x000C (0x000C - 0x0000)
struct HWLibrary_AbilitySystem_IsActiveEffectValid final
{
public:
	struct FActiveGameplayEffectHandle            ActiveEffectHandle;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_IsActiveEffectValid) == 0x000004, "Wrong alignment on HWLibrary_AbilitySystem_IsActiveEffectValid");
static_assert(sizeof(HWLibrary_AbilitySystem_IsActiveEffectValid) == 0x00000C, "Wrong size on HWLibrary_AbilitySystem_IsActiveEffectValid");
static_assert(offsetof(HWLibrary_AbilitySystem_IsActiveEffectValid, ActiveEffectHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_IsActiveEffectValid::ActiveEffectHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_IsActiveEffectValid, ReturnValue) == 0x000008, "Member 'HWLibrary_AbilitySystem_IsActiveEffectValid::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.IsShouldIgnoreCooldownsCheatActive
// 0x0001 (0x0001 - 0x0000)
struct HWLibrary_AbilitySystem_IsShouldIgnoreCooldownsCheatActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_IsShouldIgnoreCooldownsCheatActive) == 0x000001, "Wrong alignment on HWLibrary_AbilitySystem_IsShouldIgnoreCooldownsCheatActive");
static_assert(sizeof(HWLibrary_AbilitySystem_IsShouldIgnoreCooldownsCheatActive) == 0x000001, "Wrong size on HWLibrary_AbilitySystem_IsShouldIgnoreCooldownsCheatActive");
static_assert(offsetof(HWLibrary_AbilitySystem_IsShouldIgnoreCooldownsCheatActive, ReturnValue) == 0x000000, "Member 'HWLibrary_AbilitySystem_IsShouldIgnoreCooldownsCheatActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.IsShouldIgnoreCostsCheatActive
// 0x0001 (0x0001 - 0x0000)
struct HWLibrary_AbilitySystem_IsShouldIgnoreCostsCheatActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_IsShouldIgnoreCostsCheatActive) == 0x000001, "Wrong alignment on HWLibrary_AbilitySystem_IsShouldIgnoreCostsCheatActive");
static_assert(sizeof(HWLibrary_AbilitySystem_IsShouldIgnoreCostsCheatActive) == 0x000001, "Wrong size on HWLibrary_AbilitySystem_IsShouldIgnoreCostsCheatActive");
static_assert(offsetof(HWLibrary_AbilitySystem_IsShouldIgnoreCostsCheatActive, ReturnValue) == 0x000000, "Member 'HWLibrary_AbilitySystem_IsShouldIgnoreCostsCheatActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.IsTaskActive
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_AbilitySystem_IsTaskActive final
{
public:
	const class UGameplayTask*                    Task;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_IsTaskActive) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_IsTaskActive");
static_assert(sizeof(HWLibrary_AbilitySystem_IsTaskActive) == 0x000010, "Wrong size on HWLibrary_AbilitySystem_IsTaskActive");
static_assert(offsetof(HWLibrary_AbilitySystem_IsTaskActive, Task) == 0x000000, "Member 'HWLibrary_AbilitySystem_IsTaskActive::Task' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_IsTaskActive, ReturnValue) == 0x000008, "Member 'HWLibrary_AbilitySystem_IsTaskActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.ModifyActiveEffectStackCount
// 0x000C (0x000C - 0x0000)
struct HWLibrary_AbilitySystem_ModifyActiveEffectStackCount final
{
public:
	struct FActiveGameplayEffectHandle            ActiveEffectHandle;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStackCount;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_ModifyActiveEffectStackCount) == 0x000004, "Wrong alignment on HWLibrary_AbilitySystem_ModifyActiveEffectStackCount");
static_assert(sizeof(HWLibrary_AbilitySystem_ModifyActiveEffectStackCount) == 0x00000C, "Wrong size on HWLibrary_AbilitySystem_ModifyActiveEffectStackCount");
static_assert(offsetof(HWLibrary_AbilitySystem_ModifyActiveEffectStackCount, ActiveEffectHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_ModifyActiveEffectStackCount::ActiveEffectHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_ModifyActiveEffectStackCount, NewStackCount) == 0x000008, "Member 'HWLibrary_AbilitySystem_ModifyActiveEffectStackCount::NewStackCount' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.ModifyGoldAttribute
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_AbilitySystem_ModifyGoldAttribute final
{
public:
	class UAbilitySystemComponent*                AbilitySystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayModOp                                ModifierType;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Amount;                                            // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GoldModReason;                                     // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_ModifyGoldAttribute) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_ModifyGoldAttribute");
static_assert(sizeof(HWLibrary_AbilitySystem_ModifyGoldAttribute) == 0x000018, "Wrong size on HWLibrary_AbilitySystem_ModifyGoldAttribute");
static_assert(offsetof(HWLibrary_AbilitySystem_ModifyGoldAttribute, AbilitySystem) == 0x000000, "Member 'HWLibrary_AbilitySystem_ModifyGoldAttribute::AbilitySystem' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_ModifyGoldAttribute, ModifierType) == 0x000008, "Member 'HWLibrary_AbilitySystem_ModifyGoldAttribute::ModifierType' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_ModifyGoldAttribute, Amount) == 0x00000C, "Member 'HWLibrary_AbilitySystem_ModifyGoldAttribute::Amount' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_ModifyGoldAttribute, GoldModReason) == 0x000010, "Member 'HWLibrary_AbilitySystem_ModifyGoldAttribute::GoldModReason' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.RemoveActiveGameplayEffectFromEffectOwner
// 0x0008 (0x0008 - 0x0000)
struct HWLibrary_AbilitySystem_RemoveActiveGameplayEffectFromEffectOwner final
{
public:
	struct FActiveGameplayEffectHandle            ActiveEffectHandle;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_RemoveActiveGameplayEffectFromEffectOwner) == 0x000004, "Wrong alignment on HWLibrary_AbilitySystem_RemoveActiveGameplayEffectFromEffectOwner");
static_assert(sizeof(HWLibrary_AbilitySystem_RemoveActiveGameplayEffectFromEffectOwner) == 0x000008, "Wrong size on HWLibrary_AbilitySystem_RemoveActiveGameplayEffectFromEffectOwner");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveActiveGameplayEffectFromEffectOwner, ActiveEffectHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_RemoveActiveGameplayEffectFromEffectOwner::ActiveEffectHandle' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.RemoveHitResultFromMultiHitTargetDataAt
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt final
{
public:
	int32                                         RemoveAtIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       InTargetData;                                      // 0x0008(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         TargetDataIndexToModify;                           // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt");
static_assert(sizeof(HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt) == 0x000038, "Wrong size on HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt, RemoveAtIndex) == 0x000000, "Member 'HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt::RemoveAtIndex' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt, InTargetData) == 0x000008, "Member 'HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt::InTargetData' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt, TargetDataIndexToModify) == 0x000030, "Member 'HWLibrary_AbilitySystem_RemoveHitResultFromMultiHitTargetDataAt::TargetDataIndexToModify' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.RemoveMultiHitResultsFromTargetDataByTag
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag final
{
public:
	const class AHWCharacter_Base*                InstigatingCharacter;                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       InTargetData;                                      // 0x0028(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         TargetDataIndexToModify;                           // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemyTargets;                                     // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFriendlyTargets;                                  // 0x0055(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelfTarget;                                       // 0x0056(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckAllTags;                                     // 0x0057(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag");
static_assert(sizeof(HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag) == 0x000058, "Wrong size on HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag, InstigatingCharacter) == 0x000000, "Member 'HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag::InstigatingCharacter' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag, GameplayTags) == 0x000008, "Member 'HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag::GameplayTags' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag, InTargetData) == 0x000028, "Member 'HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag::InTargetData' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag, TargetDataIndexToModify) == 0x000050, "Member 'HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag::TargetDataIndexToModify' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag, bEnemyTargets) == 0x000054, "Member 'HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag::bEnemyTargets' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag, bFriendlyTargets) == 0x000055, "Member 'HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag::bFriendlyTargets' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag, bSelfTarget) == 0x000056, "Member 'HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag::bSelfTarget' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag, bCheckAllTags) == 0x000057, "Member 'HWLibrary_AbilitySystem_RemoveMultiHitResultsFromTargetDataByTag::bCheckAllTags' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.SetEffectCauserOnEffectContext
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_AbilitySystem_SetEffectCauserOnEffectContext final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 NewEffectCauser;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_SetEffectCauserOnEffectContext) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_SetEffectCauserOnEffectContext");
static_assert(sizeof(HWLibrary_AbilitySystem_SetEffectCauserOnEffectContext) == 0x000020, "Wrong size on HWLibrary_AbilitySystem_SetEffectCauserOnEffectContext");
static_assert(offsetof(HWLibrary_AbilitySystem_SetEffectCauserOnEffectContext, EffectContextHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_SetEffectCauserOnEffectContext::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_SetEffectCauserOnEffectContext, NewEffectCauser) == 0x000018, "Member 'HWLibrary_AbilitySystem_SetEffectCauserOnEffectContext::NewEffectCauser' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.SetTargetVectorOnEffectContext
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_AbilitySystem_SetTargetVectorOnEffectContext final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FVector                                TargetVector;                                      // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_SetTargetVectorOnEffectContext) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_SetTargetVectorOnEffectContext");
static_assert(sizeof(HWLibrary_AbilitySystem_SetTargetVectorOnEffectContext) == 0x000030, "Wrong size on HWLibrary_AbilitySystem_SetTargetVectorOnEffectContext");
static_assert(offsetof(HWLibrary_AbilitySystem_SetTargetVectorOnEffectContext, EffectContextHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_SetTargetVectorOnEffectContext::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_SetTargetVectorOnEffectContext, TargetVector) == 0x000018, "Member 'HWLibrary_AbilitySystem_SetTargetVectorOnEffectContext::TargetVector' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.UpdateTargetDataLocationInfo
// 0x0180 (0x0180 - 0x0000)
struct HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetDataHandleToModify;                          // 0x0000(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         TargetDataIndexToModify;                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  SourceLoc;                                         // 0x0030(0x00A0)(ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetingLocationInfo  TargetLoc;                                         // 0x00D0(0x00A0)(ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x0170(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0xF];                                      // 0x0171(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo) == 0x000010, "Wrong alignment on HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo");
static_assert(sizeof(HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo) == 0x000180, "Wrong size on HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo");
static_assert(offsetof(HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo, TargetDataHandleToModify) == 0x000000, "Member 'HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo::TargetDataHandleToModify' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo, TargetDataIndexToModify) == 0x000028, "Member 'HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo::TargetDataIndexToModify' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo, SourceLoc) == 0x000030, "Member 'HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo::SourceLoc' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo, TargetLoc) == 0x0000D0, "Member 'HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo::TargetLoc' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo, bIsValid) == 0x000170, "Member 'HWLibrary_AbilitySystem_UpdateTargetDataLocationInfo::bIsValid' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.WasActiveEffectSuccessfullyApplied
// 0x000C (0x000C - 0x0000)
struct HWLibrary_AbilitySystem_WasActiveEffectSuccessfullyApplied final
{
public:
	struct FActiveGameplayEffectHandle            ActiveEffectHandle;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_AbilitySystem_WasActiveEffectSuccessfullyApplied) == 0x000004, "Wrong alignment on HWLibrary_AbilitySystem_WasActiveEffectSuccessfullyApplied");
static_assert(sizeof(HWLibrary_AbilitySystem_WasActiveEffectSuccessfullyApplied) == 0x00000C, "Wrong size on HWLibrary_AbilitySystem_WasActiveEffectSuccessfullyApplied");
static_assert(offsetof(HWLibrary_AbilitySystem_WasActiveEffectSuccessfullyApplied, ActiveEffectHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_WasActiveEffectSuccessfullyApplied::ActiveEffectHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_WasActiveEffectSuccessfullyApplied, ReturnValue) == 0x000008, "Member 'HWLibrary_AbilitySystem_WasActiveEffectSuccessfullyApplied::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_AbilitySystem.GetEffectTagsFromEffectSpec
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_AbilitySystem_GetEffectTagsFromEffectSpec final
{
public:
	struct FGameplayEffectSpecHandle              EffectSpecHandle;                                  // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_AbilitySystem_GetEffectTagsFromEffectSpec) == 0x000008, "Wrong alignment on HWLibrary_AbilitySystem_GetEffectTagsFromEffectSpec");
static_assert(sizeof(HWLibrary_AbilitySystem_GetEffectTagsFromEffectSpec) == 0x000030, "Wrong size on HWLibrary_AbilitySystem_GetEffectTagsFromEffectSpec");
static_assert(offsetof(HWLibrary_AbilitySystem_GetEffectTagsFromEffectSpec, EffectSpecHandle) == 0x000000, "Member 'HWLibrary_AbilitySystem_GetEffectTagsFromEffectSpec::EffectSpecHandle' has a wrong offset!");
static_assert(offsetof(HWLibrary_AbilitySystem_GetEffectTagsFromEffectSpec, ReturnValue) == 0x000010, "Member 'HWLibrary_AbilitySystem_GetEffectTagsFromEffectSpec::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAladdinArenaManager.OnDeployableDestroyed
// 0x0008 (0x0008 - 0x0000)
struct HWAladdinArenaManager_OnDeployableDestroyed final
{
public:
	class AHWDeployable*                          DeployableDestroyed;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAladdinArenaManager_OnDeployableDestroyed) == 0x000008, "Wrong alignment on HWAladdinArenaManager_OnDeployableDestroyed");
static_assert(sizeof(HWAladdinArenaManager_OnDeployableDestroyed) == 0x000008, "Wrong size on HWAladdinArenaManager_OnDeployableDestroyed");
static_assert(offsetof(HWAladdinArenaManager_OnDeployableDestroyed, DeployableDestroyed) == 0x000000, "Member 'HWAladdinArenaManager_OnDeployableDestroyed::DeployableDestroyed' has a wrong offset!");

// Function Hemingway.HWAladdinArenaManager.OnDeployableSpawned
// 0x0008 (0x0008 - 0x0000)
struct HWAladdinArenaManager_OnDeployableSpawned final
{
public:
	class AHWDeployable*                          DeployableSpawned;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAladdinArenaManager_OnDeployableSpawned) == 0x000008, "Wrong alignment on HWAladdinArenaManager_OnDeployableSpawned");
static_assert(sizeof(HWAladdinArenaManager_OnDeployableSpawned) == 0x000008, "Wrong size on HWAladdinArenaManager_OnDeployableSpawned");
static_assert(offsetof(HWAladdinArenaManager_OnDeployableSpawned, DeployableSpawned) == 0x000000, "Member 'HWAladdinArenaManager_OnDeployableSpawned::DeployableSpawned' has a wrong offset!");

// Function Hemingway.HWAladdinArenaManager.OnFamiliarDestroyed
// 0x0050 (0x0050 - 0x0000)
struct HWAladdinArenaManager_OnFamiliarDestroyed final
{
public:
	struct FHWActiveFamiliarInfo                  FamiliarDestroyed;                                 // 0x0000(0x0050)(Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAladdinArenaManager_OnFamiliarDestroyed) == 0x000008, "Wrong alignment on HWAladdinArenaManager_OnFamiliarDestroyed");
static_assert(sizeof(HWAladdinArenaManager_OnFamiliarDestroyed) == 0x000050, "Wrong size on HWAladdinArenaManager_OnFamiliarDestroyed");
static_assert(offsetof(HWAladdinArenaManager_OnFamiliarDestroyed, FamiliarDestroyed) == 0x000000, "Member 'HWAladdinArenaManager_OnFamiliarDestroyed::FamiliarDestroyed' has a wrong offset!");

// Function Hemingway.HWAladdinArenaManager.OnFamiliarSpawned
// 0x0050 (0x0050 - 0x0000)
struct HWAladdinArenaManager_OnFamiliarSpawned final
{
public:
	struct FHWActiveFamiliarInfo                  FamiliarSpawned;                                   // 0x0000(0x0050)(Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAladdinArenaManager_OnFamiliarSpawned) == 0x000008, "Wrong alignment on HWAladdinArenaManager_OnFamiliarSpawned");
static_assert(sizeof(HWAladdinArenaManager_OnFamiliarSpawned) == 0x000050, "Wrong size on HWAladdinArenaManager_OnFamiliarSpawned");
static_assert(offsetof(HWAladdinArenaManager_OnFamiliarSpawned, FamiliarSpawned) == 0x000000, "Member 'HWAladdinArenaManager_OnFamiliarSpawned::FamiliarSpawned' has a wrong offset!");

// Function Hemingway.HWAladdinArenaManager.OnRep_AladdinSkinOwner
// 0x0008 (0x0008 - 0x0000)
struct HWAladdinArenaManager_OnRep_AladdinSkinOwner final
{
public:
	TWeakObjectPtr<class AHWCharacter_Base>       PreviousSkinOwner;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAladdinArenaManager_OnRep_AladdinSkinOwner) == 0x000004, "Wrong alignment on HWAladdinArenaManager_OnRep_AladdinSkinOwner");
static_assert(sizeof(HWAladdinArenaManager_OnRep_AladdinSkinOwner) == 0x000008, "Wrong size on HWAladdinArenaManager_OnRep_AladdinSkinOwner");
static_assert(offsetof(HWAladdinArenaManager_OnRep_AladdinSkinOwner, PreviousSkinOwner) == 0x000000, "Member 'HWAladdinArenaManager_OnRep_AladdinSkinOwner::PreviousSkinOwner' has a wrong offset!");

// Function Hemingway.HWAladdinArenaManager.RegisterAladdinSkinOwner
// 0x0008 (0x0008 - 0x0000)
struct HWAladdinArenaManager_RegisterAladdinSkinOwner final
{
public:
	class AHWCharacter_Base*                      Aladdin;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAladdinArenaManager_RegisterAladdinSkinOwner) == 0x000008, "Wrong alignment on HWAladdinArenaManager_RegisterAladdinSkinOwner");
static_assert(sizeof(HWAladdinArenaManager_RegisterAladdinSkinOwner) == 0x000008, "Wrong size on HWAladdinArenaManager_RegisterAladdinSkinOwner");
static_assert(offsetof(HWAladdinArenaManager_RegisterAladdinSkinOwner, Aladdin) == 0x000000, "Member 'HWAladdinArenaManager_RegisterAladdinSkinOwner::Aladdin' has a wrong offset!");

// Function Hemingway.HWQuest_TagApplicationByType.OnGameplayEffectApplied
// 0x02A8 (0x02A8 - 0x0000)
struct HWQuest_TagApplicationByType_OnGameplayEffectApplied final
{
public:
	struct FGameplayEffectSpec                    ActiveEffect;                                      // 0x0000(0x02A8)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TagApplicationByType_OnGameplayEffectApplied) == 0x000008, "Wrong alignment on HWQuest_TagApplicationByType_OnGameplayEffectApplied");
static_assert(sizeof(HWQuest_TagApplicationByType_OnGameplayEffectApplied) == 0x0002A8, "Wrong size on HWQuest_TagApplicationByType_OnGameplayEffectApplied");
static_assert(offsetof(HWQuest_TagApplicationByType_OnGameplayEffectApplied, ActiveEffect) == 0x000000, "Member 'HWQuest_TagApplicationByType_OnGameplayEffectApplied::ActiveEffect' has a wrong offset!");

// Function Hemingway.HWQuest_TagApplicationByType.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_TagApplicationByType_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TagApplicationByType_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_TagApplicationByType_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_TagApplicationByType_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_TagApplicationByType_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_TagApplicationByType_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_TagApplicationByType_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_TagApplicationByType_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_TagApplicationByType_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWQuest_TimeWithTagApplied.OnTagAddedOrRemoved
// 0x0018 (0x0018 - 0x0000)
struct HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TagCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved) == 0x000008, "Wrong alignment on HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved");
static_assert(sizeof(HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved) == 0x000018, "Wrong size on HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved");
static_assert(offsetof(HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved, Tag) == 0x000000, "Member 'HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved::Tag' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved, TagCount) == 0x000008, "Member 'HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved::TagCount' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved, AbilitySystem) == 0x000010, "Member 'HWQuest_TimeWithTagApplied_OnTagAddedOrRemoved::AbilitySystem' has a wrong offset!");

// Function Hemingway.HWQuest_TimeWithTagApplied.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_TimeWithTagApplied_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TimeWithTagApplied_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_TimeWithTagApplied_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_TimeWithTagApplied_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_TimeWithTagApplied_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_TimeWithTagApplied_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_TimeWithTagApplied_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeWithTagApplied_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_TimeWithTagApplied_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWQuest_TimeWithTagAppliedToTargets.OnGameplayEffectApplied
// 0x02A8 (0x02A8 - 0x0000)
struct HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectApplied final
{
public:
	struct FGameplayEffectSpec                    ActiveEffect;                                      // 0x0000(0x02A8)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectApplied) == 0x000008, "Wrong alignment on HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectApplied");
static_assert(sizeof(HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectApplied) == 0x0002A8, "Wrong size on HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectApplied");
static_assert(offsetof(HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectApplied, ActiveEffect) == 0x000000, "Member 'HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectApplied::ActiveEffect' has a wrong offset!");

// Function Hemingway.HWQuest_TimeWithTagAppliedToTargets.OnGameplayEffectAppliedCallback
// 0x02B8 (0x02B8 - 0x0000)
struct HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback final
{
public:
	class UAbilitySystemComponent*                Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    SpecApplied;                                       // 0x0008(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x02B0(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback) == 0x000008, "Wrong alignment on HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback");
static_assert(sizeof(HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback) == 0x0002B8, "Wrong size on HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback");
static_assert(offsetof(HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback, Target) == 0x000000, "Member 'HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback::Target' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback, SpecApplied) == 0x000008, "Member 'HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback::SpecApplied' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback, ActiveHandle) == 0x0002B0, "Member 'HWQuest_TimeWithTagAppliedToTargets_OnGameplayEffectAppliedCallback::ActiveHandle' has a wrong offset!");

// Function Hemingway.HWQuest_TimeWithTagAppliedToTargets.OnTargetTagAddedOrRemoved
// 0x0018 (0x0018 - 0x0000)
struct HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TagCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved) == 0x000008, "Wrong alignment on HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved");
static_assert(sizeof(HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved) == 0x000018, "Wrong size on HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved");
static_assert(offsetof(HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved, Tag) == 0x000000, "Member 'HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved::Tag' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved, TagCount) == 0x000008, "Member 'HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved::TagCount' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved, AbilitySystem) == 0x000010, "Member 'HWQuest_TimeWithTagAppliedToTargets_OnTargetTagAddedOrRemoved::AbilitySystem' has a wrong offset!");

// Function Hemingway.HWQuest_TimeWithTagAppliedToTargets.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_TimeWithTagAppliedToTargets_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TimeWithTagAppliedToTargets_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_TimeWithTagAppliedToTargets_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_TimeWithTagAppliedToTargets_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_TimeWithTagAppliedToTargets_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_TimeWithTagAppliedToTargets_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_TimeWithTagAppliedToTargets_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeWithTagAppliedToTargets_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_TimeWithTagAppliedToTargets_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWRankedSubsystem.GetEliteSoloQueueLossThreshold
// 0x0004 (0x0004 - 0x0000)
struct HWRankedSubsystem_GetEliteSoloQueueLossThreshold final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRankedSubsystem_GetEliteSoloQueueLossThreshold) == 0x000004, "Wrong alignment on HWRankedSubsystem_GetEliteSoloQueueLossThreshold");
static_assert(sizeof(HWRankedSubsystem_GetEliteSoloQueueLossThreshold) == 0x000004, "Wrong size on HWRankedSubsystem_GetEliteSoloQueueLossThreshold");
static_assert(offsetof(HWRankedSubsystem_GetEliteSoloQueueLossThreshold, ReturnValue) == 0x000000, "Member 'HWRankedSubsystem_GetEliteSoloQueueLossThreshold::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRankedSubsystem.GetEliteSoloQueueThreshold
// 0x0004 (0x0004 - 0x0000)
struct HWRankedSubsystem_GetEliteSoloQueueThreshold final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRankedSubsystem_GetEliteSoloQueueThreshold) == 0x000004, "Wrong alignment on HWRankedSubsystem_GetEliteSoloQueueThreshold");
static_assert(sizeof(HWRankedSubsystem_GetEliteSoloQueueThreshold) == 0x000004, "Wrong size on HWRankedSubsystem_GetEliteSoloQueueThreshold");
static_assert(offsetof(HWRankedSubsystem_GetEliteSoloQueueThreshold, ReturnValue) == 0x000000, "Member 'HWRankedSubsystem_GetEliteSoloQueueThreshold::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRankedSubsystem.GetRankedConfigByGamemode
// 0x0030 (0x0030 - 0x0000)
struct HWRankedSubsystem_GetRankedConfigByGamemode final
{
public:
	TSubclassOf<class AHWGameMode>                GameModeClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWRankedConfig>         ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRankedSubsystem_GetRankedConfigByGamemode) == 0x000008, "Wrong alignment on HWRankedSubsystem_GetRankedConfigByGamemode");
static_assert(sizeof(HWRankedSubsystem_GetRankedConfigByGamemode) == 0x000030, "Wrong size on HWRankedSubsystem_GetRankedConfigByGamemode");
static_assert(offsetof(HWRankedSubsystem_GetRankedConfigByGamemode, GameModeClass) == 0x000000, "Member 'HWRankedSubsystem_GetRankedConfigByGamemode::GameModeClass' has a wrong offset!");
static_assert(offsetof(HWRankedSubsystem_GetRankedConfigByGamemode, ReturnValue) == 0x000008, "Member 'HWRankedSubsystem_GetRankedConfigByGamemode::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRankedSubsystem.GrantEliteQueueItem
// 0x0010 (0x0010 - 0x0000)
struct HWRankedSubsystem_GrantEliteQueueItem final
{
public:
	class URH_PlayerInfo*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillRating;                                       // 0x0008(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWRankedSubsystem_GrantEliteQueueItem) == 0x000008, "Wrong alignment on HWRankedSubsystem_GrantEliteQueueItem");
static_assert(sizeof(HWRankedSubsystem_GrantEliteQueueItem) == 0x000010, "Wrong size on HWRankedSubsystem_GrantEliteQueueItem");
static_assert(offsetof(HWRankedSubsystem_GrantEliteQueueItem, Player) == 0x000000, "Member 'HWRankedSubsystem_GrantEliteQueueItem::Player' has a wrong offset!");
static_assert(offsetof(HWRankedSubsystem_GrantEliteQueueItem, SkillRating) == 0x000008, "Member 'HWRankedSubsystem_GrantEliteQueueItem::SkillRating' has a wrong offset!");

// Function Hemingway.HWReticle.BP_OnCalcReticlePlacementPosition
// 0x0048 (0x0048 - 0x0000)
struct HWReticle_BP_OnCalcReticlePlacementPosition final
{
public:
	struct FVector                                PlacementLoc;                                      // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPoint;                                          // 0x0030(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_BP_OnCalcReticlePlacementPosition) == 0x000008, "Wrong alignment on HWReticle_BP_OnCalcReticlePlacementPosition");
static_assert(sizeof(HWReticle_BP_OnCalcReticlePlacementPosition) == 0x000048, "Wrong size on HWReticle_BP_OnCalcReticlePlacementPosition");
static_assert(offsetof(HWReticle_BP_OnCalcReticlePlacementPosition, PlacementLoc) == 0x000000, "Member 'HWReticle_BP_OnCalcReticlePlacementPosition::PlacementLoc' has a wrong offset!");
static_assert(offsetof(HWReticle_BP_OnCalcReticlePlacementPosition, Origin) == 0x000018, "Member 'HWReticle_BP_OnCalcReticlePlacementPosition::Origin' has a wrong offset!");
static_assert(offsetof(HWReticle_BP_OnCalcReticlePlacementPosition, EndPoint) == 0x000030, "Member 'HWReticle_BP_OnCalcReticlePlacementPosition::EndPoint' has a wrong offset!");

// Function Hemingway.HWReticle.BP_OnRenderBehaviorDetermined
// 0x0001 (0x0001 - 0x0000)
struct HWReticle_BP_OnRenderBehaviorDetermined final
{
public:
	EReticleRenderBehavior                        RenderBehavior;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_BP_OnRenderBehaviorDetermined) == 0x000001, "Wrong alignment on HWReticle_BP_OnRenderBehaviorDetermined");
static_assert(sizeof(HWReticle_BP_OnRenderBehaviorDetermined) == 0x000001, "Wrong size on HWReticle_BP_OnRenderBehaviorDetermined");
static_assert(offsetof(HWReticle_BP_OnRenderBehaviorDetermined, RenderBehavior) == 0x000000, "Member 'HWReticle_BP_OnRenderBehaviorDetermined::RenderBehavior' has a wrong offset!");

// Function Hemingway.HWReticle.HandlePrefireTransition
// 0x0001 (0x0001 - 0x0000)
struct HWReticle_HandlePrefireTransition final
{
public:
	bool                                          bIsEnteringPrefire;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_HandlePrefireTransition) == 0x000001, "Wrong alignment on HWReticle_HandlePrefireTransition");
static_assert(sizeof(HWReticle_HandlePrefireTransition) == 0x000001, "Wrong size on HWReticle_HandlePrefireTransition");
static_assert(offsetof(HWReticle_HandlePrefireTransition, bIsEnteringPrefire) == 0x000000, "Member 'HWReticle_HandlePrefireTransition::bIsEnteringPrefire' has a wrong offset!");

// Function Hemingway.HWReticle.UpdateReticleRendering
// 0x0010 (0x0010 - 0x0000)
struct HWReticle_UpdateReticleRendering final
{
public:
	EReticleRenderBehavior                        RenderBehavior;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_UpdateReticleRendering) == 0x000008, "Wrong alignment on HWReticle_UpdateReticleRendering");
static_assert(sizeof(HWReticle_UpdateReticleRendering) == 0x000010, "Wrong size on HWReticle_UpdateReticleRendering");
static_assert(offsetof(HWReticle_UpdateReticleRendering, RenderBehavior) == 0x000000, "Member 'HWReticle_UpdateReticleRendering::RenderBehavior' has a wrong offset!");
static_assert(offsetof(HWReticle_UpdateReticleRendering, NiagaraComponent) == 0x000008, "Member 'HWReticle_UpdateReticleRendering::NiagaraComponent' has a wrong offset!");

// Function Hemingway.HWReticle.CalcCustomPlacementPosition
// 0x0028 (0x0028 - 0x0000)
struct HWReticle_CalcCustomPlacementPosition final
{
public:
	const class AHWTargeter*                      Targeter;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutFoundValidPlacement;                            // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_CalcCustomPlacementPosition) == 0x000008, "Wrong alignment on HWReticle_CalcCustomPlacementPosition");
static_assert(sizeof(HWReticle_CalcCustomPlacementPosition) == 0x000028, "Wrong size on HWReticle_CalcCustomPlacementPosition");
static_assert(offsetof(HWReticle_CalcCustomPlacementPosition, Targeter) == 0x000000, "Member 'HWReticle_CalcCustomPlacementPosition::Targeter' has a wrong offset!");
static_assert(offsetof(HWReticle_CalcCustomPlacementPosition, OutFoundValidPlacement) == 0x000008, "Member 'HWReticle_CalcCustomPlacementPosition::OutFoundValidPlacement' has a wrong offset!");
static_assert(offsetof(HWReticle_CalcCustomPlacementPosition, ReturnValue) == 0x000010, "Member 'HWReticle_CalcCustomPlacementPosition::ReturnValue' has a wrong offset!");

// Function Hemingway.HWReticle.GetApparelComponent
// 0x0008 (0x0008 - 0x0000)
struct HWReticle_GetApparelComponent final
{
public:
	class UHWApparelComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_GetApparelComponent) == 0x000008, "Wrong alignment on HWReticle_GetApparelComponent");
static_assert(sizeof(HWReticle_GetApparelComponent) == 0x000008, "Wrong size on HWReticle_GetApparelComponent");
static_assert(offsetof(HWReticle_GetApparelComponent, ReturnValue) == 0x000000, "Member 'HWReticle_GetApparelComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWReticle.GetCurrentSkin
// 0x0008 (0x0008 - 0x0000)
struct HWReticle_GetCurrentSkin final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_GetCurrentSkin) == 0x000008, "Wrong alignment on HWReticle_GetCurrentSkin");
static_assert(sizeof(HWReticle_GetCurrentSkin) == 0x000008, "Wrong size on HWReticle_GetCurrentSkin");
static_assert(offsetof(HWReticle_GetCurrentSkin, ReturnValue) == 0x000000, "Member 'HWReticle_GetCurrentSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWReticle.GetRadialPlayerSelectorTarget
// 0x0008 (0x0008 - 0x0000)
struct HWReticle_GetRadialPlayerSelectorTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_GetRadialPlayerSelectorTarget) == 0x000008, "Wrong alignment on HWReticle_GetRadialPlayerSelectorTarget");
static_assert(sizeof(HWReticle_GetRadialPlayerSelectorTarget) == 0x000008, "Wrong size on HWReticle_GetRadialPlayerSelectorTarget");
static_assert(offsetof(HWReticle_GetRadialPlayerSelectorTarget, ReturnValue) == 0x000000, "Member 'HWReticle_GetRadialPlayerSelectorTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWReticle.IsSkinningReady
// 0x0001 (0x0001 - 0x0000)
struct HWReticle_IsSkinningReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_IsSkinningReady) == 0x000001, "Wrong alignment on HWReticle_IsSkinningReady");
static_assert(sizeof(HWReticle_IsSkinningReady) == 0x000001, "Wrong size on HWReticle_IsSkinningReady");
static_assert(offsetof(HWReticle_IsSkinningReady, ReturnValue) == 0x000000, "Member 'HWReticle_IsSkinningReady::ReturnValue' has a wrong offset!");

// Function Hemingway.HWReticle.ShouldShowReticle
// 0x0001 (0x0001 - 0x0000)
struct HWReticle_ShouldShowReticle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_ShouldShowReticle) == 0x000001, "Wrong alignment on HWReticle_ShouldShowReticle");
static_assert(sizeof(HWReticle_ShouldShowReticle) == 0x000001, "Wrong size on HWReticle_ShouldShowReticle");
static_assert(offsetof(HWReticle_ShouldShowReticle, ReturnValue) == 0x000000, "Member 'HWReticle_ShouldShowReticle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWReticle.ShouldShowReticleInPhase
// 0x0002 (0x0002 - 0x0000)
struct HWReticle_ShouldShowReticleInPhase final
{
public:
	EAbilityFlowPhase                             AbilityPhase;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_ShouldShowReticleInPhase) == 0x000001, "Wrong alignment on HWReticle_ShouldShowReticleInPhase");
static_assert(sizeof(HWReticle_ShouldShowReticleInPhase) == 0x000002, "Wrong size on HWReticle_ShouldShowReticleInPhase");
static_assert(offsetof(HWReticle_ShouldShowReticleInPhase, AbilityPhase) == 0x000000, "Member 'HWReticle_ShouldShowReticleInPhase::AbilityPhase' has a wrong offset!");
static_assert(offsetof(HWReticle_ShouldShowReticleInPhase, ReturnValue) == 0x000001, "Member 'HWReticle_ShouldShowReticleInPhase::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_Deployable.OnDeployableBeginSpawning
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_Attack_Deployable_OnDeployableBeginSpawning final
{
public:
	class AHWDeployable*                          SpawnedDeployable;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Attack_Deployable_OnDeployableBeginSpawning) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_Deployable_OnDeployableBeginSpawning");
static_assert(sizeof(HWAbilityTask_Attack_Deployable_OnDeployableBeginSpawning) == 0x000008, "Wrong size on HWAbilityTask_Attack_Deployable_OnDeployableBeginSpawning");
static_assert(offsetof(HWAbilityTask_Attack_Deployable_OnDeployableBeginSpawning, SpawnedDeployable) == 0x000000, "Member 'HWAbilityTask_Attack_Deployable_OnDeployableBeginSpawning::SpawnedDeployable' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_Deployable.OnDeployableSpawned
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_Attack_Deployable_OnDeployableSpawned final
{
public:
	class AHWDeployable*                          SpawnedDeployable;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Attack_Deployable_OnDeployableSpawned) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_Deployable_OnDeployableSpawned");
static_assert(sizeof(HWAbilityTask_Attack_Deployable_OnDeployableSpawned) == 0x000008, "Wrong size on HWAbilityTask_Attack_Deployable_OnDeployableSpawned");
static_assert(offsetof(HWAbilityTask_Attack_Deployable_OnDeployableSpawned, SpawnedDeployable) == 0x000000, "Member 'HWAbilityTask_Attack_Deployable_OnDeployableSpawned::SpawnedDeployable' has a wrong offset!");

// Function Hemingway.HWReticle_Mulan_A03_WallIndicator.CalcPredictedWorldHit
// 0x00E8 (0x00E8 - 0x0000)
struct HWReticle_Mulan_A03_WallIndicator_CalcPredictedWorldHit final
{
public:
	struct FHitResult                             ReturnValue;                                       // 0x0000(0x00E8)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_Mulan_A03_WallIndicator_CalcPredictedWorldHit) == 0x000008, "Wrong alignment on HWReticle_Mulan_A03_WallIndicator_CalcPredictedWorldHit");
static_assert(sizeof(HWReticle_Mulan_A03_WallIndicator_CalcPredictedWorldHit) == 0x0000E8, "Wrong size on HWReticle_Mulan_A03_WallIndicator_CalcPredictedWorldHit");
static_assert(offsetof(HWReticle_Mulan_A03_WallIndicator_CalcPredictedWorldHit, ReturnValue) == 0x000000, "Member 'HWReticle_Mulan_A03_WallIndicator_CalcPredictedWorldHit::ReturnValue' has a wrong offset!");

// Function Hemingway.HWReticle_Mulan_A03_WallIndicator.IsEvolved
// 0x0001 (0x0001 - 0x0000)
struct HWReticle_Mulan_A03_WallIndicator_IsEvolved final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_Mulan_A03_WallIndicator_IsEvolved) == 0x000001, "Wrong alignment on HWReticle_Mulan_A03_WallIndicator_IsEvolved");
static_assert(sizeof(HWReticle_Mulan_A03_WallIndicator_IsEvolved) == 0x000001, "Wrong size on HWReticle_Mulan_A03_WallIndicator_IsEvolved");
static_assert(offsetof(HWReticle_Mulan_A03_WallIndicator_IsEvolved, ReturnValue) == 0x000000, "Member 'HWReticle_Mulan_A03_WallIndicator_IsEvolved::ReturnValue' has a wrong offset!");

// Function Hemingway.HWReticle_Ricochet.UpdateRicochetReticle
// 0x0038 (0x0038 - 0x0000)
struct HWReticle_Ricochet_UpdateRicochetReticle final
{
public:
	class UNiagaraComponent*                      ReticleFx;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       AimDataHandle;                                     // 0x0008(0x0028)(Parm, NativeAccessSpecifierPublic)
	int32                                         RicochetIndex;                                     // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFinalRicochet;                                  // 0x0034(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWReticle_Ricochet_UpdateRicochetReticle) == 0x000008, "Wrong alignment on HWReticle_Ricochet_UpdateRicochetReticle");
static_assert(sizeof(HWReticle_Ricochet_UpdateRicochetReticle) == 0x000038, "Wrong size on HWReticle_Ricochet_UpdateRicochetReticle");
static_assert(offsetof(HWReticle_Ricochet_UpdateRicochetReticle, ReticleFx) == 0x000000, "Member 'HWReticle_Ricochet_UpdateRicochetReticle::ReticleFx' has a wrong offset!");
static_assert(offsetof(HWReticle_Ricochet_UpdateRicochetReticle, AimDataHandle) == 0x000008, "Member 'HWReticle_Ricochet_UpdateRicochetReticle::AimDataHandle' has a wrong offset!");
static_assert(offsetof(HWReticle_Ricochet_UpdateRicochetReticle, RicochetIndex) == 0x000030, "Member 'HWReticle_Ricochet_UpdateRicochetReticle::RicochetIndex' has a wrong offset!");
static_assert(offsetof(HWReticle_Ricochet_UpdateRicochetReticle, bIsFinalRicochet) == 0x000034, "Member 'HWReticle_Ricochet_UpdateRicochetReticle::bIsFinalRicochet' has a wrong offset!");

// Function Hemingway.HWReticle_VGS.UpdateReticleDisplay
// 0x0008 (0x0008 - 0x0000)
struct HWReticle_VGS_UpdateReticleDisplay final
{
public:
	struct FGameplayTag                           DisplayTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_VGS_UpdateReticleDisplay) == 0x000004, "Wrong alignment on HWReticle_VGS_UpdateReticleDisplay");
static_assert(sizeof(HWReticle_VGS_UpdateReticleDisplay) == 0x000008, "Wrong size on HWReticle_VGS_UpdateReticleDisplay");
static_assert(offsetof(HWReticle_VGS_UpdateReticleDisplay, DisplayTag) == 0x000000, "Member 'HWReticle_VGS_UpdateReticleDisplay::DisplayTag' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_AllowPassThrough.GetPassThroughCharacterTags
// 0x0020 (0x0020 - 0x0000)
struct HWGameplayEffect_AllowPassThrough_GetPassThroughCharacterTags final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_AllowPassThrough_GetPassThroughCharacterTags) == 0x000008, "Wrong alignment on HWGameplayEffect_AllowPassThrough_GetPassThroughCharacterTags");
static_assert(sizeof(HWGameplayEffect_AllowPassThrough_GetPassThroughCharacterTags) == 0x000020, "Wrong size on HWGameplayEffect_AllowPassThrough_GetPassThroughCharacterTags");
static_assert(offsetof(HWGameplayEffect_AllowPassThrough_GetPassThroughCharacterTags, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_AllowPassThrough_GetPassThroughCharacterTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.DoesPlayerHaveRolePreferences
// 0x0010 (0x0010 - 0x0000)
struct HWRoleSubsystem_DoesPlayerHaveRolePreferences final
{
public:
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWRoleSubsystem_DoesPlayerHaveRolePreferences) == 0x000008, "Wrong alignment on HWRoleSubsystem_DoesPlayerHaveRolePreferences");
static_assert(sizeof(HWRoleSubsystem_DoesPlayerHaveRolePreferences) == 0x000010, "Wrong size on HWRoleSubsystem_DoesPlayerHaveRolePreferences");
static_assert(offsetof(HWRoleSubsystem_DoesPlayerHaveRolePreferences, PlayerInfo) == 0x000000, "Member 'HWRoleSubsystem_DoesPlayerHaveRolePreferences::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_DoesPlayerHaveRolePreferences, ReturnValue) == 0x000008, "Member 'HWRoleSubsystem_DoesPlayerHaveRolePreferences::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.FetchLocalPlayerRolePreferences
// 0x0018 (0x0018 - 0x0000)
struct HWRoleSubsystem_FetchLocalPlayerRolePreferences final
{
public:
	class URH_PlayerInfo*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHWRolePreferenceData& RolePreferences, bool bSuccess)> RolesFetchedDelegate; // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRoleSubsystem_FetchLocalPlayerRolePreferences) == 0x000008, "Wrong alignment on HWRoleSubsystem_FetchLocalPlayerRolePreferences");
static_assert(sizeof(HWRoleSubsystem_FetchLocalPlayerRolePreferences) == 0x000018, "Wrong size on HWRoleSubsystem_FetchLocalPlayerRolePreferences");
static_assert(offsetof(HWRoleSubsystem_FetchLocalPlayerRolePreferences, Player) == 0x000000, "Member 'HWRoleSubsystem_FetchLocalPlayerRolePreferences::Player' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_FetchLocalPlayerRolePreferences, RolesFetchedDelegate) == 0x000008, "Member 'HWRoleSubsystem_FetchLocalPlayerRolePreferences::RolesFetchedDelegate' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.GetAllCachedRolePreferences
// 0x0078 (0x0078 - 0x0000)
struct HWRoleSubsystem_GetAllCachedRolePreferences final
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWRolePreferenceData                  ReturnValue;                                       // 0x0020(0x0058)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRoleSubsystem_GetAllCachedRolePreferences) == 0x000008, "Wrong alignment on HWRoleSubsystem_GetAllCachedRolePreferences");
static_assert(sizeof(HWRoleSubsystem_GetAllCachedRolePreferences) == 0x000078, "Wrong size on HWRoleSubsystem_GetAllCachedRolePreferences");
static_assert(offsetof(HWRoleSubsystem_GetAllCachedRolePreferences, PlayerId) == 0x000000, "Member 'HWRoleSubsystem_GetAllCachedRolePreferences::PlayerId' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_GetAllCachedRolePreferences, ReturnValue) == 0x000020, "Member 'HWRoleSubsystem_GetAllCachedRolePreferences::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.GetCachedRolePreference
// 0x0028 (0x0028 - 0x0000)
struct HWRoleSubsystem_GetCachedRolePreference final
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterRole                                RoleTag;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRoleSubsystem_GetCachedRolePreference) == 0x000004, "Wrong alignment on HWRoleSubsystem_GetCachedRolePreference");
static_assert(sizeof(HWRoleSubsystem_GetCachedRolePreference) == 0x000028, "Wrong size on HWRoleSubsystem_GetCachedRolePreference");
static_assert(offsetof(HWRoleSubsystem_GetCachedRolePreference, PlayerId) == 0x000000, "Member 'HWRoleSubsystem_GetCachedRolePreference::PlayerId' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_GetCachedRolePreference, RoleTag) == 0x000020, "Member 'HWRoleSubsystem_GetCachedRolePreference::RoleTag' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_GetCachedRolePreference, ReturnValue) == 0x000024, "Member 'HWRoleSubsystem_GetCachedRolePreference::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.GetCachedRolePriority
// 0x0010 (0x0010 - 0x0000)
struct HWRoleSubsystem_GetCachedRolePriority final
{
public:
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWRoleSubsystem_GetCachedRolePriority) == 0x000008, "Wrong alignment on HWRoleSubsystem_GetCachedRolePriority");
static_assert(sizeof(HWRoleSubsystem_GetCachedRolePriority) == 0x000010, "Wrong size on HWRoleSubsystem_GetCachedRolePriority");
static_assert(offsetof(HWRoleSubsystem_GetCachedRolePriority, PlayerInfo) == 0x000000, "Member 'HWRoleSubsystem_GetCachedRolePriority::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_GetCachedRolePriority, ReturnValue) == 0x000008, "Member 'HWRoleSubsystem_GetCachedRolePriority::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.OnLocalPlayerSettingsLoaded
// 0x0070 (0x0070 - 0x0000)
struct HWRoleSubsystem_OnLocalPlayerSettingsLoaded final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_PlayerSettingsDataWrapper          Response;                                          // 0x0008(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class URH_PlayerInfo*                         Player;                                            // 0x0068(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRoleSubsystem_OnLocalPlayerSettingsLoaded) == 0x000008, "Wrong alignment on HWRoleSubsystem_OnLocalPlayerSettingsLoaded");
static_assert(sizeof(HWRoleSubsystem_OnLocalPlayerSettingsLoaded) == 0x000070, "Wrong size on HWRoleSubsystem_OnLocalPlayerSettingsLoaded");
static_assert(offsetof(HWRoleSubsystem_OnLocalPlayerSettingsLoaded, bSuccess) == 0x000000, "Member 'HWRoleSubsystem_OnLocalPlayerSettingsLoaded::bSuccess' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_OnLocalPlayerSettingsLoaded, Response) == 0x000008, "Member 'HWRoleSubsystem_OnLocalPlayerSettingsLoaded::Response' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_OnLocalPlayerSettingsLoaded, Player) == 0x000068, "Member 'HWRoleSubsystem_OnLocalPlayerSettingsLoaded::Player' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.OnPlayerRolePreferencesSaved
// 0x0110 (0x0110 - 0x0000)
struct HWRoleSubsystem_OnPlayerRolePreferencesSaved final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_PlayerSettingsDataWrapper          Response;                                          // 0x0008(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FRH_ErrorInfo                          ErrorInfo;                                         // 0x0068(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRoleSubsystem_OnPlayerRolePreferencesSaved) == 0x000008, "Wrong alignment on HWRoleSubsystem_OnPlayerRolePreferencesSaved");
static_assert(sizeof(HWRoleSubsystem_OnPlayerRolePreferencesSaved) == 0x000110, "Wrong size on HWRoleSubsystem_OnPlayerRolePreferencesSaved");
static_assert(offsetof(HWRoleSubsystem_OnPlayerRolePreferencesSaved, bSuccess) == 0x000000, "Member 'HWRoleSubsystem_OnPlayerRolePreferencesSaved::bSuccess' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_OnPlayerRolePreferencesSaved, Response) == 0x000008, "Member 'HWRoleSubsystem_OnPlayerRolePreferencesSaved::Response' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_OnPlayerRolePreferencesSaved, ErrorInfo) == 0x000068, "Member 'HWRoleSubsystem_OnPlayerRolePreferencesSaved::ErrorInfo' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.OnPlayerSettingsLoaded
// 0x0070 (0x0070 - 0x0000)
struct HWRoleSubsystem_OnPlayerSettingsLoaded final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_PlayerSettingsDataWrapper          Response;                                          // 0x0008(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0068(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRoleSubsystem_OnPlayerSettingsLoaded) == 0x000008, "Wrong alignment on HWRoleSubsystem_OnPlayerSettingsLoaded");
static_assert(sizeof(HWRoleSubsystem_OnPlayerSettingsLoaded) == 0x000070, "Wrong size on HWRoleSubsystem_OnPlayerSettingsLoaded");
static_assert(offsetof(HWRoleSubsystem_OnPlayerSettingsLoaded, bSuccess) == 0x000000, "Member 'HWRoleSubsystem_OnPlayerSettingsLoaded::bSuccess' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_OnPlayerSettingsLoaded, Response) == 0x000008, "Member 'HWRoleSubsystem_OnPlayerSettingsLoaded::Response' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_OnPlayerSettingsLoaded, PlayerInfo) == 0x000068, "Member 'HWRoleSubsystem_OnPlayerSettingsLoaded::PlayerInfo' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.UpdateCachedPlayedRole
// 0x0024 (0x0024 - 0x0000)
struct HWRoleSubsystem_UpdateCachedPlayedRole final
{
public:
	struct FHWPersistentPlayerId                  PlayerId;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterRole                                RoleTag;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWRoleSubsystem_UpdateCachedPlayedRole) == 0x000004, "Wrong alignment on HWRoleSubsystem_UpdateCachedPlayedRole");
static_assert(sizeof(HWRoleSubsystem_UpdateCachedPlayedRole) == 0x000024, "Wrong size on HWRoleSubsystem_UpdateCachedPlayedRole");
static_assert(offsetof(HWRoleSubsystem_UpdateCachedPlayedRole, PlayerId) == 0x000000, "Member 'HWRoleSubsystem_UpdateCachedPlayedRole::PlayerId' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_UpdateCachedPlayedRole, RoleTag) == 0x000020, "Member 'HWRoleSubsystem_UpdateCachedPlayedRole::RoleTag' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.UpdateRolePreferences
// 0x0060 (0x0060 - 0x0000)
struct HWRoleSubsystem_UpdateRolePreferences final
{
public:
	class URH_PlayerInfo*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWRolePreferenceData                  NewRolePreferences;                                // 0x0008(0x0058)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRoleSubsystem_UpdateRolePreferences) == 0x000008, "Wrong alignment on HWRoleSubsystem_UpdateRolePreferences");
static_assert(sizeof(HWRoleSubsystem_UpdateRolePreferences) == 0x000060, "Wrong size on HWRoleSubsystem_UpdateRolePreferences");
static_assert(offsetof(HWRoleSubsystem_UpdateRolePreferences, Player) == 0x000000, "Member 'HWRoleSubsystem_UpdateRolePreferences::Player' has a wrong offset!");
static_assert(offsetof(HWRoleSubsystem_UpdateRolePreferences, NewRolePreferences) == 0x000008, "Member 'HWRoleSubsystem_UpdateRolePreferences::NewRolePreferences' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.GetAllCachedPlayedRoles
// 0x0050 (0x0050 - 0x0000)
struct HWRoleSubsystem_GetAllCachedPlayedRoles final
{
public:
	TMap<struct FHWPersistentPlayerId, ECharacterRole> ReturnValue;                                  // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRoleSubsystem_GetAllCachedPlayedRoles) == 0x000008, "Wrong alignment on HWRoleSubsystem_GetAllCachedPlayedRoles");
static_assert(sizeof(HWRoleSubsystem_GetAllCachedPlayedRoles) == 0x000050, "Wrong size on HWRoleSubsystem_GetAllCachedPlayedRoles");
static_assert(offsetof(HWRoleSubsystem_GetAllCachedPlayedRoles, ReturnValue) == 0x000000, "Member 'HWRoleSubsystem_GetAllCachedPlayedRoles::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRoleSubsystem.GetRoleConfig
// 0x0008 (0x0008 - 0x0000)
struct HWRoleSubsystem_GetRoleConfig final
{
public:
	class UHWRoleConfig*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRoleSubsystem_GetRoleConfig) == 0x000008, "Wrong alignment on HWRoleSubsystem_GetRoleConfig");
static_assert(sizeof(HWRoleSubsystem_GetRoleConfig) == 0x000008, "Wrong size on HWRoleSubsystem_GetRoleConfig");
static_assert(offsetof(HWRoleSubsystem_GetRoleConfig, ReturnValue) == 0x000000, "Member 'HWRoleSubsystem_GetRoleConfig::ReturnValue' has a wrong offset!");

// Function Hemingway.HWReticle_Dash.BP_OnCalcDashReticlePlacementPosition
// 0x0060 (0x0060 - 0x0000)
struct HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition final
{
public:
	struct FVector                                PlacementLoc;                                      // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxDashEndLoc;                                     // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActualEndDashLoc;                                  // 0x0030(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitActorLocation;                                  // 0x0048(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition) == 0x000008, "Wrong alignment on HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition");
static_assert(sizeof(HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition) == 0x000060, "Wrong size on HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition");
static_assert(offsetof(HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition, PlacementLoc) == 0x000000, "Member 'HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition::PlacementLoc' has a wrong offset!");
static_assert(offsetof(HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition, MaxDashEndLoc) == 0x000018, "Member 'HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition::MaxDashEndLoc' has a wrong offset!");
static_assert(offsetof(HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition, ActualEndDashLoc) == 0x000030, "Member 'HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition::ActualEndDashLoc' has a wrong offset!");
static_assert(offsetof(HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition, HitActorLocation) == 0x000048, "Member 'HWReticle_Dash_BP_OnCalcDashReticlePlacementPosition::HitActorLocation' has a wrong offset!");

// Function Hemingway.HWSettingsVersionManager.GetCurrentKeybindsSettingsVersion
// 0x0004 (0x0004 - 0x0000)
struct HWSettingsVersionManager_GetCurrentKeybindsSettingsVersion final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSettingsVersionManager_GetCurrentKeybindsSettingsVersion) == 0x000004, "Wrong alignment on HWSettingsVersionManager_GetCurrentKeybindsSettingsVersion");
static_assert(sizeof(HWSettingsVersionManager_GetCurrentKeybindsSettingsVersion) == 0x000004, "Wrong size on HWSettingsVersionManager_GetCurrentKeybindsSettingsVersion");
static_assert(offsetof(HWSettingsVersionManager_GetCurrentKeybindsSettingsVersion, ReturnValue) == 0x000000, "Member 'HWSettingsVersionManager_GetCurrentKeybindsSettingsVersion::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSettingsVersionManager.GetCurrentPlayerSettingsVersion
// 0x0004 (0x0004 - 0x0000)
struct HWSettingsVersionManager_GetCurrentPlayerSettingsVersion final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSettingsVersionManager_GetCurrentPlayerSettingsVersion) == 0x000004, "Wrong alignment on HWSettingsVersionManager_GetCurrentPlayerSettingsVersion");
static_assert(sizeof(HWSettingsVersionManager_GetCurrentPlayerSettingsVersion) == 0x000004, "Wrong size on HWSettingsVersionManager_GetCurrentPlayerSettingsVersion");
static_assert(offsetof(HWSettingsVersionManager_GetCurrentPlayerSettingsVersion, ReturnValue) == 0x000000, "Member 'HWSettingsVersionManager_GetCurrentPlayerSettingsVersion::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSimpleTeamActor.OnRep_TeamID
// 0x0001 (0x0001 - 0x0000)
struct HWSimpleTeamActor_OnRep_TeamID final
{
public:
	struct FGenericTeamId                         OldTeamId;                                         // 0x0000(0x0001)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSimpleTeamActor_OnRep_TeamID) == 0x000001, "Wrong alignment on HWSimpleTeamActor_OnRep_TeamID");
static_assert(sizeof(HWSimpleTeamActor_OnRep_TeamID) == 0x000001, "Wrong size on HWSimpleTeamActor_OnRep_TeamID");
static_assert(offsetof(HWSimpleTeamActor_OnRep_TeamID, OldTeamId) == 0x000000, "Member 'HWSimpleTeamActor_OnRep_TeamID::OldTeamId' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshActor.StartDestroy
// 0x0001 (0x0001 - 0x0000)
struct HWSkeletalMeshActor_StartDestroy final
{
public:
	bool                                          bSkipTimeAfterDeath;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkeletalMeshActor_StartDestroy) == 0x000001, "Wrong alignment on HWSkeletalMeshActor_StartDestroy");
static_assert(sizeof(HWSkeletalMeshActor_StartDestroy) == 0x000001, "Wrong size on HWSkeletalMeshActor_StartDestroy");
static_assert(offsetof(HWSkeletalMeshActor_StartDestroy, bSkipTimeAfterDeath) == 0x000000, "Member 'HWSkeletalMeshActor_StartDestroy::bSkipTimeAfterDeath' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshActor.GetApparelComponent
// 0x0008 (0x0008 - 0x0000)
struct HWSkeletalMeshActor_GetApparelComponent final
{
public:
	class UHWApparelComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkeletalMeshActor_GetApparelComponent) == 0x000008, "Wrong alignment on HWSkeletalMeshActor_GetApparelComponent");
static_assert(sizeof(HWSkeletalMeshActor_GetApparelComponent) == 0x000008, "Wrong size on HWSkeletalMeshActor_GetApparelComponent");
static_assert(offsetof(HWSkeletalMeshActor_GetApparelComponent, ReturnValue) == 0x000000, "Member 'HWSkeletalMeshActor_GetApparelComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshActor.GetCurrentSkin
// 0x0008 (0x0008 - 0x0000)
struct HWSkeletalMeshActor_GetCurrentSkin final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkeletalMeshActor_GetCurrentSkin) == 0x000008, "Wrong alignment on HWSkeletalMeshActor_GetCurrentSkin");
static_assert(sizeof(HWSkeletalMeshActor_GetCurrentSkin) == 0x000008, "Wrong size on HWSkeletalMeshActor_GetCurrentSkin");
static_assert(offsetof(HWSkeletalMeshActor_GetCurrentSkin, ReturnValue) == 0x000000, "Member 'HWSkeletalMeshActor_GetCurrentSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshActor.IsSkinningReady
// 0x0001 (0x0001 - 0x0000)
struct HWSkeletalMeshActor_IsSkinningReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkeletalMeshActor_IsSkinningReady) == 0x000001, "Wrong alignment on HWSkeletalMeshActor_IsSkinningReady");
static_assert(sizeof(HWSkeletalMeshActor_IsSkinningReady) == 0x000001, "Wrong size on HWSkeletalMeshActor_IsSkinningReady");
static_assert(offsetof(HWSkeletalMeshActor_IsSkinningReady, ReturnValue) == 0x000000, "Member 'HWSkeletalMeshActor_IsSkinningReady::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinNameBranch.BranchOnSkinName
// 0x0018 (0x0018 - 0x0000)
struct HWSkinNameBranch_BranchOnSkinName final
{
public:
	class FString                                 InputString;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinNameBranch_BranchOnSkinName) == 0x000008, "Wrong alignment on HWSkinNameBranch_BranchOnSkinName");
static_assert(sizeof(HWSkinNameBranch_BranchOnSkinName) == 0x000018, "Wrong size on HWSkinNameBranch_BranchOnSkinName");
static_assert(offsetof(HWSkinNameBranch_BranchOnSkinName, InputString) == 0x000000, "Member 'HWSkinNameBranch_BranchOnSkinName::InputString' has a wrong offset!");
static_assert(offsetof(HWSkinNameBranch_BranchOnSkinName, bIsValid) == 0x000010, "Member 'HWSkinNameBranch_BranchOnSkinName::bIsValid' has a wrong offset!");
static_assert(offsetof(HWSkinNameBranch_BranchOnSkinName, ReturnValue) == 0x000014, "Member 'HWSkinNameBranch_BranchOnSkinName::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_Projectile.FireHomingProjectileAttackById
// 0x0050 (0x0050 - 0x0000)
struct HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ID;                                                // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingTarget_0;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       AimData;                                           // 0x0020(0x0028)(Parm, NativeAccessSpecifierPublic)
	class UHWAbilityTask_Attack_Projectile*       ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById");
static_assert(sizeof(HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById) == 0x000050, "Wrong size on HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById");
static_assert(offsetof(HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById, OwningAbility) == 0x000000, "Member 'HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById, ID) == 0x000010, "Member 'HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById::ID' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById, HomingTarget_0) == 0x000018, "Member 'HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById::HomingTarget_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById, AimData) == 0x000020, "Member 'HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById::AimData' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById, ReturnValue) == 0x000048, "Member 'HWAbilityTask_Attack_Projectile_FireHomingProjectileAttackById::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinSelectReplicatedActor.OnPlayerInventoryUpdated
// 0x0018 (0x0018 - 0x0000)
struct HWSkinSelectReplicatedActor_OnPlayerInventoryUpdated final
{
public:
	TArray<int32>                                 UpdatedInventoryIds;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinSelectReplicatedActor_OnPlayerInventoryUpdated) == 0x000008, "Wrong alignment on HWSkinSelectReplicatedActor_OnPlayerInventoryUpdated");
static_assert(sizeof(HWSkinSelectReplicatedActor_OnPlayerInventoryUpdated) == 0x000018, "Wrong size on HWSkinSelectReplicatedActor_OnPlayerInventoryUpdated");
static_assert(offsetof(HWSkinSelectReplicatedActor_OnPlayerInventoryUpdated, UpdatedInventoryIds) == 0x000000, "Member 'HWSkinSelectReplicatedActor_OnPlayerInventoryUpdated::UpdatedInventoryIds' has a wrong offset!");
static_assert(offsetof(HWSkinSelectReplicatedActor_OnPlayerInventoryUpdated, PlayerInfo) == 0x000010, "Member 'HWSkinSelectReplicatedActor_OnPlayerInventoryUpdated::PlayerInfo' has a wrong offset!");

// Function Hemingway.HWTargeter.AdjustAimLocationToGround
// 0x0050 (0x0050 - 0x0000)
struct HWTargeter_AdjustAimLocationToGround final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWGroundTargetValidationType                 ValidationBehavior;                                // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OutAdjustedLocation;                               // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           InSourceActor;                                     // 0x0040(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualCollisionRadius;                             // 0x0048(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x004C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWTargeter_AdjustAimLocationToGround) == 0x000008, "Wrong alignment on HWTargeter_AdjustAimLocationToGround");
static_assert(sizeof(HWTargeter_AdjustAimLocationToGround) == 0x000050, "Wrong size on HWTargeter_AdjustAimLocationToGround");
static_assert(offsetof(HWTargeter_AdjustAimLocationToGround, WorldContextObject) == 0x000000, "Member 'HWTargeter_AdjustAimLocationToGround::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWTargeter_AdjustAimLocationToGround, Origin) == 0x000008, "Member 'HWTargeter_AdjustAimLocationToGround::Origin' has a wrong offset!");
static_assert(offsetof(HWTargeter_AdjustAimLocationToGround, ValidationBehavior) == 0x000020, "Member 'HWTargeter_AdjustAimLocationToGround::ValidationBehavior' has a wrong offset!");
static_assert(offsetof(HWTargeter_AdjustAimLocationToGround, OutAdjustedLocation) == 0x000028, "Member 'HWTargeter_AdjustAimLocationToGround::OutAdjustedLocation' has a wrong offset!");
static_assert(offsetof(HWTargeter_AdjustAimLocationToGround, InSourceActor) == 0x000040, "Member 'HWTargeter_AdjustAimLocationToGround::InSourceActor' has a wrong offset!");
static_assert(offsetof(HWTargeter_AdjustAimLocationToGround, ManualCollisionRadius) == 0x000048, "Member 'HWTargeter_AdjustAimLocationToGround::ManualCollisionRadius' has a wrong offset!");
static_assert(offsetof(HWTargeter_AdjustAimLocationToGround, ReturnValue) == 0x00004C, "Member 'HWTargeter_AdjustAimLocationToGround::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcBoxTargeting
// 0x00B0 (0x00B0 - 0x0000)
struct HWTargeter_CalcBoxTargeting final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxTargetingData                      BoxTargetingData;                                  // 0x0008(0x0080)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OutTargetListDataHandle;                           // 0x0088(0x0028)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_CalcBoxTargeting) == 0x000008, "Wrong alignment on HWTargeter_CalcBoxTargeting");
static_assert(sizeof(HWTargeter_CalcBoxTargeting) == 0x0000B0, "Wrong size on HWTargeter_CalcBoxTargeting");
static_assert(offsetof(HWTargeter_CalcBoxTargeting, WorldContext) == 0x000000, "Member 'HWTargeter_CalcBoxTargeting::WorldContext' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcBoxTargeting, BoxTargetingData) == 0x000008, "Member 'HWTargeter_CalcBoxTargeting::BoxTargetingData' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcBoxTargeting, OutTargetListDataHandle) == 0x000088, "Member 'HWTargeter_CalcBoxTargeting::OutTargetListDataHandle' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcBoxTargetingByObjectType
// 0x00B8 (0x00B8 - 0x0000)
struct HWTargeter_CalcBoxTargetingByObjectType final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxTargetingData                      BoxTargetingData;                                  // 0x0008(0x0080)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OutTargetListDataHandle;                           // 0x0088(0x0028)(Parm, OutParm, NativeAccessSpecifierPublic)
	ECollisionChannel                             ObjectTypeChannel;                                 // 0x00B0(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWTargeter_CalcBoxTargetingByObjectType) == 0x000008, "Wrong alignment on HWTargeter_CalcBoxTargetingByObjectType");
static_assert(sizeof(HWTargeter_CalcBoxTargetingByObjectType) == 0x0000B8, "Wrong size on HWTargeter_CalcBoxTargetingByObjectType");
static_assert(offsetof(HWTargeter_CalcBoxTargetingByObjectType, WorldContext) == 0x000000, "Member 'HWTargeter_CalcBoxTargetingByObjectType::WorldContext' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcBoxTargetingByObjectType, BoxTargetingData) == 0x000008, "Member 'HWTargeter_CalcBoxTargetingByObjectType::BoxTargetingData' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcBoxTargetingByObjectType, OutTargetListDataHandle) == 0x000088, "Member 'HWTargeter_CalcBoxTargetingByObjectType::OutTargetListDataHandle' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcBoxTargetingByObjectType, ObjectTypeChannel) == 0x0000B0, "Member 'HWTargeter_CalcBoxTargetingByObjectType::ObjectTypeChannel' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcCircularWedgeTargeting
// 0x00B0 (0x00B0 - 0x0000)
struct HWTargeter_CalcCircularWedgeTargeting final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCircularWedgeTargetingData            WedgeTargetingData;                                // 0x0008(0x0080)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OutTargetListDataHandle;                           // 0x0088(0x0028)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_CalcCircularWedgeTargeting) == 0x000008, "Wrong alignment on HWTargeter_CalcCircularWedgeTargeting");
static_assert(sizeof(HWTargeter_CalcCircularWedgeTargeting) == 0x0000B0, "Wrong size on HWTargeter_CalcCircularWedgeTargeting");
static_assert(offsetof(HWTargeter_CalcCircularWedgeTargeting, WorldContext) == 0x000000, "Member 'HWTargeter_CalcCircularWedgeTargeting::WorldContext' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcCircularWedgeTargeting, WedgeTargetingData) == 0x000008, "Member 'HWTargeter_CalcCircularWedgeTargeting::WedgeTargetingData' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcCircularWedgeTargeting, OutTargetListDataHandle) == 0x000088, "Member 'HWTargeter_CalcCircularWedgeTargeting::OutTargetListDataHandle' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcCircularWedgeTargetingByObjectType
// 0x00B8 (0x00B8 - 0x0000)
struct HWTargeter_CalcCircularWedgeTargetingByObjectType final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCircularWedgeTargetingData            WedgeTargetingData;                                // 0x0008(0x0080)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OutTargetListDataHandle;                           // 0x0088(0x0028)(Parm, OutParm, NativeAccessSpecifierPublic)
	ECollisionChannel                             ObjectTypeChannel;                                 // 0x00B0(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWTargeter_CalcCircularWedgeTargetingByObjectType) == 0x000008, "Wrong alignment on HWTargeter_CalcCircularWedgeTargetingByObjectType");
static_assert(sizeof(HWTargeter_CalcCircularWedgeTargetingByObjectType) == 0x0000B8, "Wrong size on HWTargeter_CalcCircularWedgeTargetingByObjectType");
static_assert(offsetof(HWTargeter_CalcCircularWedgeTargetingByObjectType, WorldContext) == 0x000000, "Member 'HWTargeter_CalcCircularWedgeTargetingByObjectType::WorldContext' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcCircularWedgeTargetingByObjectType, WedgeTargetingData) == 0x000008, "Member 'HWTargeter_CalcCircularWedgeTargetingByObjectType::WedgeTargetingData' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcCircularWedgeTargetingByObjectType, OutTargetListDataHandle) == 0x000088, "Member 'HWTargeter_CalcCircularWedgeTargetingByObjectType::OutTargetListDataHandle' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcCircularWedgeTargetingByObjectType, ObjectTypeChannel) == 0x0000B0, "Member 'HWTargeter_CalcCircularWedgeTargetingByObjectType::ObjectTypeChannel' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcLineAttackTargeting
// 0x00A8 (0x00A8 - 0x0000)
struct HWTargeter_CalcLineAttackTargeting final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLineAttackTargetingData               LineAttackTargetingData;                           // 0x0008(0x0078)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OutTargetListDataHandle;                           // 0x0080(0x0028)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_CalcLineAttackTargeting) == 0x000008, "Wrong alignment on HWTargeter_CalcLineAttackTargeting");
static_assert(sizeof(HWTargeter_CalcLineAttackTargeting) == 0x0000A8, "Wrong size on HWTargeter_CalcLineAttackTargeting");
static_assert(offsetof(HWTargeter_CalcLineAttackTargeting, WorldContext) == 0x000000, "Member 'HWTargeter_CalcLineAttackTargeting::WorldContext' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcLineAttackTargeting, LineAttackTargetingData) == 0x000008, "Member 'HWTargeter_CalcLineAttackTargeting::LineAttackTargetingData' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcLineAttackTargeting, OutTargetListDataHandle) == 0x000080, "Member 'HWTargeter_CalcLineAttackTargeting::OutTargetListDataHandle' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcRadialHitLocation
// 0x0060 (0x0060 - 0x0000)
struct HWTargeter_CalcRadialHitLocation final
{
public:
	struct FVector                                AimOrigin;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetExtent;                                      // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_CalcRadialHitLocation) == 0x000008, "Wrong alignment on HWTargeter_CalcRadialHitLocation");
static_assert(sizeof(HWTargeter_CalcRadialHitLocation) == 0x000060, "Wrong size on HWTargeter_CalcRadialHitLocation");
static_assert(offsetof(HWTargeter_CalcRadialHitLocation, AimOrigin) == 0x000000, "Member 'HWTargeter_CalcRadialHitLocation::AimOrigin' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcRadialHitLocation, TargetLocation) == 0x000018, "Member 'HWTargeter_CalcRadialHitLocation::TargetLocation' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcRadialHitLocation, TargetExtent) == 0x000030, "Member 'HWTargeter_CalcRadialHitLocation::TargetExtent' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcRadialHitLocation, ReturnValue) == 0x000048, "Member 'HWTargeter_CalcRadialHitLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcSphereTargeting
// 0x00A8 (0x00A8 - 0x0000)
struct HWTargeter_CalcSphereTargeting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSphereTargetingData                   SphereTargetingData;                               // 0x0008(0x0078)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OutTargetListDataHandle;                           // 0x0080(0x0028)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_CalcSphereTargeting) == 0x000008, "Wrong alignment on HWTargeter_CalcSphereTargeting");
static_assert(sizeof(HWTargeter_CalcSphereTargeting) == 0x0000A8, "Wrong size on HWTargeter_CalcSphereTargeting");
static_assert(offsetof(HWTargeter_CalcSphereTargeting, WorldContextObject) == 0x000000, "Member 'HWTargeter_CalcSphereTargeting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcSphereTargeting, SphereTargetingData) == 0x000008, "Member 'HWTargeter_CalcSphereTargeting::SphereTargetingData' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcSphereTargeting, OutTargetListDataHandle) == 0x000080, "Member 'HWTargeter_CalcSphereTargeting::OutTargetListDataHandle' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcSphereTargetingByObjectType
// 0x00B0 (0x00B0 - 0x0000)
struct HWTargeter_CalcSphereTargetingByObjectType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSphereTargetingData                   SphereTargetingData;                               // 0x0008(0x0078)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OutTargetListDataHandle;                           // 0x0080(0x0028)(Parm, OutParm, NativeAccessSpecifierPublic)
	ECollisionChannel                             ObjectTypeChannel;                                 // 0x00A8(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWTargeter_CalcSphereTargetingByObjectType) == 0x000008, "Wrong alignment on HWTargeter_CalcSphereTargetingByObjectType");
static_assert(sizeof(HWTargeter_CalcSphereTargetingByObjectType) == 0x0000B0, "Wrong size on HWTargeter_CalcSphereTargetingByObjectType");
static_assert(offsetof(HWTargeter_CalcSphereTargetingByObjectType, WorldContextObject) == 0x000000, "Member 'HWTargeter_CalcSphereTargetingByObjectType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcSphereTargetingByObjectType, SphereTargetingData) == 0x000008, "Member 'HWTargeter_CalcSphereTargetingByObjectType::SphereTargetingData' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcSphereTargetingByObjectType, OutTargetListDataHandle) == 0x000080, "Member 'HWTargeter_CalcSphereTargetingByObjectType::OutTargetListDataHandle' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcSphereTargetingByObjectType, ObjectTypeChannel) == 0x0000A8, "Member 'HWTargeter_CalcSphereTargetingByObjectType::ObjectTypeChannel' has a wrong offset!");

// Function Hemingway.HWTargeter.DrawDebugCircularWedge
// 0x0050 (0x0050 - 0x0000)
struct HWTargeter_DrawDebugCircularWedge final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                vOrigin;                                           // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                vRotation;                                         // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fRadius;                                           // 0x0038(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fAngle;                                            // 0x003C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fHeight;                                           // 0x0040(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0044(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_DrawDebugCircularWedge) == 0x000008, "Wrong alignment on HWTargeter_DrawDebugCircularWedge");
static_assert(sizeof(HWTargeter_DrawDebugCircularWedge) == 0x000050, "Wrong size on HWTargeter_DrawDebugCircularWedge");
static_assert(offsetof(HWTargeter_DrawDebugCircularWedge, WorldContextObject) == 0x000000, "Member 'HWTargeter_DrawDebugCircularWedge::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWTargeter_DrawDebugCircularWedge, vOrigin) == 0x000008, "Member 'HWTargeter_DrawDebugCircularWedge::vOrigin' has a wrong offset!");
static_assert(offsetof(HWTargeter_DrawDebugCircularWedge, vRotation) == 0x000020, "Member 'HWTargeter_DrawDebugCircularWedge::vRotation' has a wrong offset!");
static_assert(offsetof(HWTargeter_DrawDebugCircularWedge, fRadius) == 0x000038, "Member 'HWTargeter_DrawDebugCircularWedge::fRadius' has a wrong offset!");
static_assert(offsetof(HWTargeter_DrawDebugCircularWedge, fAngle) == 0x00003C, "Member 'HWTargeter_DrawDebugCircularWedge::fAngle' has a wrong offset!");
static_assert(offsetof(HWTargeter_DrawDebugCircularWedge, fHeight) == 0x000040, "Member 'HWTargeter_DrawDebugCircularWedge::fHeight' has a wrong offset!");
static_assert(offsetof(HWTargeter_DrawDebugCircularWedge, Color) == 0x000044, "Member 'HWTargeter_DrawDebugCircularWedge::Color' has a wrong offset!");
static_assert(offsetof(HWTargeter_DrawDebugCircularWedge, bPersistentLines) == 0x000048, "Member 'HWTargeter_DrawDebugCircularWedge::bPersistentLines' has a wrong offset!");
static_assert(offsetof(HWTargeter_DrawDebugCircularWedge, Lifetime) == 0x00004C, "Member 'HWTargeter_DrawDebugCircularWedge::Lifetime' has a wrong offset!");

// Function Hemingway.HWTargeter.GetTargetDataHandleForType
// 0x0070 (0x0070 - 0x0000)
struct HWTargeter_GetTargetDataHandleForType final
{
public:
	const class UHWGameplayAbility*               AbilityInstance;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackID;                                          // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetDataTypeSlot                           Type;                                              // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0018(0x0028)(Parm, NativeAccessSpecifierPublic)
	bool                                          bBreakTargetListIntoIndividualTargetDatas;         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0048(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_GetTargetDataHandleForType) == 0x000008, "Wrong alignment on HWTargeter_GetTargetDataHandleForType");
static_assert(sizeof(HWTargeter_GetTargetDataHandleForType) == 0x000070, "Wrong size on HWTargeter_GetTargetDataHandleForType");
static_assert(offsetof(HWTargeter_GetTargetDataHandleForType, AbilityInstance) == 0x000000, "Member 'HWTargeter_GetTargetDataHandleForType::AbilityInstance' has a wrong offset!");
static_assert(offsetof(HWTargeter_GetTargetDataHandleForType, AttackID) == 0x000008, "Member 'HWTargeter_GetTargetDataHandleForType::AttackID' has a wrong offset!");
static_assert(offsetof(HWTargeter_GetTargetDataHandleForType, Type) == 0x000010, "Member 'HWTargeter_GetTargetDataHandleForType::Type' has a wrong offset!");
static_assert(offsetof(HWTargeter_GetTargetDataHandleForType, TargetDataHandle) == 0x000018, "Member 'HWTargeter_GetTargetDataHandleForType::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(HWTargeter_GetTargetDataHandleForType, bBreakTargetListIntoIndividualTargetDatas) == 0x000040, "Member 'HWTargeter_GetTargetDataHandleForType::bBreakTargetListIntoIndividualTargetDatas' has a wrong offset!");
static_assert(offsetof(HWTargeter_GetTargetDataHandleForType, ReturnValue) == 0x000048, "Member 'HWTargeter_GetTargetDataHandleForType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.GetTargetDataIndexForType
// 0x0018 (0x0018 - 0x0000)
struct HWTargeter_GetTargetDataIndexForType final
{
public:
	const class UHWGameplayAbility*               AbilityInstance;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackID;                                          // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetDataTypeSlot                           Type;                                              // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_GetTargetDataIndexForType) == 0x000008, "Wrong alignment on HWTargeter_GetTargetDataIndexForType");
static_assert(sizeof(HWTargeter_GetTargetDataIndexForType) == 0x000018, "Wrong size on HWTargeter_GetTargetDataIndexForType");
static_assert(offsetof(HWTargeter_GetTargetDataIndexForType, AbilityInstance) == 0x000000, "Member 'HWTargeter_GetTargetDataIndexForType::AbilityInstance' has a wrong offset!");
static_assert(offsetof(HWTargeter_GetTargetDataIndexForType, AttackID) == 0x000008, "Member 'HWTargeter_GetTargetDataIndexForType::AttackID' has a wrong offset!");
static_assert(offsetof(HWTargeter_GetTargetDataIndexForType, Type) == 0x000010, "Member 'HWTargeter_GetTargetDataIndexForType::Type' has a wrong offset!");
static_assert(offsetof(HWTargeter_GetTargetDataIndexForType, ReturnValue) == 0x000014, "Member 'HWTargeter_GetTargetDataIndexForType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.IsInWedge
// 0x0060 (0x0060 - 0x0000)
struct HWTargeter_IsInWedge final
{
public:
	struct FVector                                TargetPosition;                                    // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetCollisionRadius;                             // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WedgeOrigin;                                       // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimDirection;                                      // 0x0038(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0050(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0054(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumRadius;                                     // 0x0058(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x005C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWTargeter_IsInWedge) == 0x000008, "Wrong alignment on HWTargeter_IsInWedge");
static_assert(sizeof(HWTargeter_IsInWedge) == 0x000060, "Wrong size on HWTargeter_IsInWedge");
static_assert(offsetof(HWTargeter_IsInWedge, TargetPosition) == 0x000000, "Member 'HWTargeter_IsInWedge::TargetPosition' has a wrong offset!");
static_assert(offsetof(HWTargeter_IsInWedge, TargetCollisionRadius) == 0x000018, "Member 'HWTargeter_IsInWedge::TargetCollisionRadius' has a wrong offset!");
static_assert(offsetof(HWTargeter_IsInWedge, WedgeOrigin) == 0x000020, "Member 'HWTargeter_IsInWedge::WedgeOrigin' has a wrong offset!");
static_assert(offsetof(HWTargeter_IsInWedge, AimDirection) == 0x000038, "Member 'HWTargeter_IsInWedge::AimDirection' has a wrong offset!");
static_assert(offsetof(HWTargeter_IsInWedge, Angle) == 0x000050, "Member 'HWTargeter_IsInWedge::Angle' has a wrong offset!");
static_assert(offsetof(HWTargeter_IsInWedge, Radius) == 0x000054, "Member 'HWTargeter_IsInWedge::Radius' has a wrong offset!");
static_assert(offsetof(HWTargeter_IsInWedge, MinimumRadius) == 0x000058, "Member 'HWTargeter_IsInWedge::MinimumRadius' has a wrong offset!");
static_assert(offsetof(HWTargeter_IsInWedge, ReturnValue) == 0x00005C, "Member 'HWTargeter_IsInWedge::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcGroundTargetAim
// 0x0060 (0x0060 - 0x0000)
struct HWTargeter_CalcGroundTargetAim final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetingAimHandle;                                // 0x0000(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UHWAbilityAimSettings_GroundTarget* AimSettings;                                     // 0x0028(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPredicting;                                       // 0x0030(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugAim;                                     // 0x0031(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0038(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_CalcGroundTargetAim) == 0x000008, "Wrong alignment on HWTargeter_CalcGroundTargetAim");
static_assert(sizeof(HWTargeter_CalcGroundTargetAim) == 0x000060, "Wrong size on HWTargeter_CalcGroundTargetAim");
static_assert(offsetof(HWTargeter_CalcGroundTargetAim, TargetingAimHandle) == 0x000000, "Member 'HWTargeter_CalcGroundTargetAim::TargetingAimHandle' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcGroundTargetAim, AimSettings) == 0x000028, "Member 'HWTargeter_CalcGroundTargetAim::AimSettings' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcGroundTargetAim, bPredicting) == 0x000030, "Member 'HWTargeter_CalcGroundTargetAim::bPredicting' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcGroundTargetAim, bShowDebugAim) == 0x000031, "Member 'HWTargeter_CalcGroundTargetAim::bShowDebugAim' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcGroundTargetAim, ReturnValue) == 0x000038, "Member 'HWTargeter_CalcGroundTargetAim::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcLockOnAim
// 0x00E0 (0x00E0 - 0x0000)
struct HWTargeter_CalcLockOnAim final
{
public:
	struct FHWAimTargetingInfo                    AimTargetingInfo;                                  // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetingAimHandle;                                // 0x0080(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UHWAbilityAimSettings_LockOn*     AimSettings;                                       // 0x00A8(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugAim;                                     // 0x00B0(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x00B8(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_CalcLockOnAim) == 0x000010, "Wrong alignment on HWTargeter_CalcLockOnAim");
static_assert(sizeof(HWTargeter_CalcLockOnAim) == 0x0000E0, "Wrong size on HWTargeter_CalcLockOnAim");
static_assert(offsetof(HWTargeter_CalcLockOnAim, AimTargetingInfo) == 0x000000, "Member 'HWTargeter_CalcLockOnAim::AimTargetingInfo' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcLockOnAim, TargetingAimHandle) == 0x000080, "Member 'HWTargeter_CalcLockOnAim::TargetingAimHandle' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcLockOnAim, AimSettings) == 0x0000A8, "Member 'HWTargeter_CalcLockOnAim::AimSettings' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcLockOnAim, bShowDebugAim) == 0x0000B0, "Member 'HWTargeter_CalcLockOnAim::bShowDebugAim' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcLockOnAim, ReturnValue) == 0x0000B8, "Member 'HWTargeter_CalcLockOnAim::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.CalcSelfAim
// 0x00E0 (0x00E0 - 0x0000)
struct HWTargeter_CalcSelfAim final
{
public:
	struct FHWAimTargetingInfo                    AimTargetingInfo;                                  // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetingAimHandle;                                // 0x0080(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UHWAbilityAimSettings_Self*       AimSettings;                                       // 0x00A8(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x00B0(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWTargeter_CalcSelfAim) == 0x000010, "Wrong alignment on HWTargeter_CalcSelfAim");
static_assert(sizeof(HWTargeter_CalcSelfAim) == 0x0000E0, "Wrong size on HWTargeter_CalcSelfAim");
static_assert(offsetof(HWTargeter_CalcSelfAim, AimTargetingInfo) == 0x000000, "Member 'HWTargeter_CalcSelfAim::AimTargetingInfo' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcSelfAim, TargetingAimHandle) == 0x000080, "Member 'HWTargeter_CalcSelfAim::TargetingAimHandle' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcSelfAim, AimSettings) == 0x0000A8, "Member 'HWTargeter_CalcSelfAim::AimSettings' has a wrong offset!");
static_assert(offsetof(HWTargeter_CalcSelfAim, ReturnValue) == 0x0000B0, "Member 'HWTargeter_CalcSelfAim::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.CreateReticle
// 0x0018 (0x0018 - 0x0000)
struct HWTargeter_CreateReticle final
{
public:
	TSubclassOf<class AHWReticle>                 InReticleClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToReticleList;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWReticle*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_CreateReticle) == 0x000008, "Wrong alignment on HWTargeter_CreateReticle");
static_assert(sizeof(HWTargeter_CreateReticle) == 0x000018, "Wrong size on HWTargeter_CreateReticle");
static_assert(offsetof(HWTargeter_CreateReticle, InReticleClass) == 0x000000, "Member 'HWTargeter_CreateReticle::InReticleClass' has a wrong offset!");
static_assert(offsetof(HWTargeter_CreateReticle, bAddToReticleList) == 0x000008, "Member 'HWTargeter_CreateReticle::bAddToReticleList' has a wrong offset!");
static_assert(offsetof(HWTargeter_CreateReticle, ReturnValue) == 0x000010, "Member 'HWTargeter_CreateReticle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.DisableTargetingForAttacks
// 0x0020 (0x0020 - 0x0000)
struct HWTargeter_DisableTargetingForAttacks final
{
public:
	struct FGameplayTagContainer                  Attacks;                                           // 0x0000(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_DisableTargetingForAttacks) == 0x000008, "Wrong alignment on HWTargeter_DisableTargetingForAttacks");
static_assert(sizeof(HWTargeter_DisableTargetingForAttacks) == 0x000020, "Wrong size on HWTargeter_DisableTargetingForAttacks");
static_assert(offsetof(HWTargeter_DisableTargetingForAttacks, Attacks) == 0x000000, "Member 'HWTargeter_DisableTargetingForAttacks::Attacks' has a wrong offset!");

// Function Hemingway.HWTargeter.EnableTargetingForAttacks
// 0x0028 (0x0028 - 0x0000)
struct HWTargeter_EnableTargetingForAttacks final
{
public:
	struct FGameplayTagContainer                  Attacks;                                           // 0x0000(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          bResetCurrentTargetingAttacks;                     // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableServerTargeting;                            // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWTargeter_EnableTargetingForAttacks) == 0x000008, "Wrong alignment on HWTargeter_EnableTargetingForAttacks");
static_assert(sizeof(HWTargeter_EnableTargetingForAttacks) == 0x000028, "Wrong size on HWTargeter_EnableTargetingForAttacks");
static_assert(offsetof(HWTargeter_EnableTargetingForAttacks, Attacks) == 0x000000, "Member 'HWTargeter_EnableTargetingForAttacks::Attacks' has a wrong offset!");
static_assert(offsetof(HWTargeter_EnableTargetingForAttacks, bResetCurrentTargetingAttacks) == 0x000020, "Member 'HWTargeter_EnableTargetingForAttacks::bResetCurrentTargetingAttacks' has a wrong offset!");
static_assert(offsetof(HWTargeter_EnableTargetingForAttacks, bEnableServerTargeting) == 0x000021, "Member 'HWTargeter_EnableTargetingForAttacks::bEnableServerTargeting' has a wrong offset!");

// Function Hemingway.HWTargeter.SetActorTickEnabledOnServer
// 0x0001 (0x0001 - 0x0000)
struct HWTargeter_SetActorTickEnabledOnServer final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_SetActorTickEnabledOnServer) == 0x000001, "Wrong alignment on HWTargeter_SetActorTickEnabledOnServer");
static_assert(sizeof(HWTargeter_SetActorTickEnabledOnServer) == 0x000001, "Wrong size on HWTargeter_SetActorTickEnabledOnServer");
static_assert(offsetof(HWTargeter_SetActorTickEnabledOnServer, bEnable) == 0x000000, "Member 'HWTargeter_SetActorTickEnabledOnServer::bEnable' has a wrong offset!");

// Function Hemingway.HWTargeter.SetTargetingExpiring
// 0x0001 (0x0001 - 0x0000)
struct HWTargeter_SetTargetingExpiring final
{
public:
	bool                                          bExpiring;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_SetTargetingExpiring) == 0x000001, "Wrong alignment on HWTargeter_SetTargetingExpiring");
static_assert(sizeof(HWTargeter_SetTargetingExpiring) == 0x000001, "Wrong size on HWTargeter_SetTargetingExpiring");
static_assert(offsetof(HWTargeter_SetTargetingExpiring, bExpiring) == 0x000000, "Member 'HWTargeter_SetTargetingExpiring::bExpiring' has a wrong offset!");

// Function Hemingway.HWTargeter.WasLastAimTargetGood
// 0x0001 (0x0001 - 0x0000)
struct HWTargeter_WasLastAimTargetGood final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_WasLastAimTargetGood) == 0x000001, "Wrong alignment on HWTargeter_WasLastAimTargetGood");
static_assert(sizeof(HWTargeter_WasLastAimTargetGood) == 0x000001, "Wrong size on HWTargeter_WasLastAimTargetGood");
static_assert(offsetof(HWTargeter_WasLastAimTargetGood, ReturnValue) == 0x000000, "Member 'HWTargeter_WasLastAimTargetGood::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.CreateTargetingDataSnapshot
// 0x0028 (0x0028 - 0x0000)
struct HWTargeter_CreateTargetingDataSnapshot final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_CreateTargetingDataSnapshot) == 0x000008, "Wrong alignment on HWTargeter_CreateTargetingDataSnapshot");
static_assert(sizeof(HWTargeter_CreateTargetingDataSnapshot) == 0x000028, "Wrong size on HWTargeter_CreateTargetingDataSnapshot");
static_assert(offsetof(HWTargeter_CreateTargetingDataSnapshot, ReturnValue) == 0x000000, "Member 'HWTargeter_CreateTargetingDataSnapshot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.GetCurrentLevelConfig
// 0x0008 (0x0008 - 0x0000)
struct HWTargeter_GetCurrentLevelConfig final
{
public:
	const class UHWAbilityLevelConfig*            ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_GetCurrentLevelConfig) == 0x000008, "Wrong alignment on HWTargeter_GetCurrentLevelConfig");
static_assert(sizeof(HWTargeter_GetCurrentLevelConfig) == 0x000008, "Wrong size on HWTargeter_GetCurrentLevelConfig");
static_assert(offsetof(HWTargeter_GetCurrentLevelConfig, ReturnValue) == 0x000000, "Member 'HWTargeter_GetCurrentLevelConfig::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.GetCurrentlyTargetingAttacks
// 0x0020 (0x0020 - 0x0000)
struct HWTargeter_GetCurrentlyTargetingAttacks final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_GetCurrentlyTargetingAttacks) == 0x000008, "Wrong alignment on HWTargeter_GetCurrentlyTargetingAttacks");
static_assert(sizeof(HWTargeter_GetCurrentlyTargetingAttacks) == 0x000020, "Wrong size on HWTargeter_GetCurrentlyTargetingAttacks");
static_assert(offsetof(HWTargeter_GetCurrentlyTargetingAttacks, ReturnValue) == 0x000000, "Member 'HWTargeter_GetCurrentlyTargetingAttacks::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.GetReticleByClass
// 0x0010 (0x0010 - 0x0000)
struct HWTargeter_GetReticleByClass final
{
public:
	TSubclassOf<class AHWReticle>                 InReticleClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWReticle*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_GetReticleByClass) == 0x000008, "Wrong alignment on HWTargeter_GetReticleByClass");
static_assert(sizeof(HWTargeter_GetReticleByClass) == 0x000010, "Wrong size on HWTargeter_GetReticleByClass");
static_assert(offsetof(HWTargeter_GetReticleByClass, InReticleClass) == 0x000000, "Member 'HWTargeter_GetReticleByClass::InReticleClass' has a wrong offset!");
static_assert(offsetof(HWTargeter_GetReticleByClass, ReturnValue) == 0x000008, "Member 'HWTargeter_GetReticleByClass::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.GetReticleById
// 0x0010 (0x0010 - 0x0000)
struct HWTargeter_GetReticleById final
{
public:
	struct FGameplayTag                           AttackID;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWReticle*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTargeter_GetReticleById) == 0x000008, "Wrong alignment on HWTargeter_GetReticleById");
static_assert(sizeof(HWTargeter_GetReticleById) == 0x000010, "Wrong size on HWTargeter_GetReticleById");
static_assert(offsetof(HWTargeter_GetReticleById, AttackID) == 0x000000, "Member 'HWTargeter_GetReticleById::AttackID' has a wrong offset!");
static_assert(offsetof(HWTargeter_GetReticleById, ReturnValue) == 0x000008, "Member 'HWTargeter_GetReticleById::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTargeter.IsAttackCurrrentlyTargeting
// 0x000C (0x000C - 0x0000)
struct HWTargeter_IsAttackCurrrentlyTargeting final
{
public:
	struct FGameplayTag                           AttackID;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWTargeter_IsAttackCurrrentlyTargeting) == 0x000004, "Wrong alignment on HWTargeter_IsAttackCurrrentlyTargeting");
static_assert(sizeof(HWTargeter_IsAttackCurrrentlyTargeting) == 0x00000C, "Wrong size on HWTargeter_IsAttackCurrrentlyTargeting");
static_assert(offsetof(HWTargeter_IsAttackCurrrentlyTargeting, AttackID) == 0x000000, "Member 'HWTargeter_IsAttackCurrrentlyTargeting::AttackID' has a wrong offset!");
static_assert(offsetof(HWTargeter_IsAttackCurrrentlyTargeting, ReturnValue) == 0x000008, "Member 'HWTargeter_IsAttackCurrrentlyTargeting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.HandleGetGodMasteryLevel
// 0x0018 (0x0018 - 0x0000)
struct HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel final
{
public:
	const class UHWCharacterItem*                 Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class URH_PlayerInfo*                   InPlayerInfo;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelProgressPercent;                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel");
static_assert(sizeof(HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel) == 0x000018, "Wrong size on HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel");
static_assert(offsetof(HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel, Character) == 0x000000, "Member 'HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel::Character' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel, InPlayerInfo) == 0x000008, "Member 'HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel::InPlayerInfo' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel, Level) == 0x000010, "Member 'HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel::Level' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel, LevelProgressPercent) == 0x000014, "Member 'HWCharacterAbilitySystemActor_HandleGetGodMasteryLevel::LevelProgressPercent' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.IgnoresAbilityForTrackingFailedFire
// 0x0010 (0x0010 - 0x0000)
struct HWCharacterAbilitySystemActor_IgnoresAbilityForTrackingFailedFire final
{
public:
	const class UGameplayAbility*                 Ability;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterAbilitySystemActor_IgnoresAbilityForTrackingFailedFire) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_IgnoresAbilityForTrackingFailedFire");
static_assert(sizeof(HWCharacterAbilitySystemActor_IgnoresAbilityForTrackingFailedFire) == 0x000010, "Wrong size on HWCharacterAbilitySystemActor_IgnoresAbilityForTrackingFailedFire");
static_assert(offsetof(HWCharacterAbilitySystemActor_IgnoresAbilityForTrackingFailedFire, Ability) == 0x000000, "Member 'HWCharacterAbilitySystemActor_IgnoresAbilityForTrackingFailedFire::Ability' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_IgnoresAbilityForTrackingFailedFire, ReturnValue) == 0x000008, "Member 'HWCharacterAbilitySystemActor_IgnoresAbilityForTrackingFailedFire::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.OnAbilityActivated
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_OnAbilityActivated final
{
public:
	class UGameplayAbility*                       Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_OnAbilityActivated) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_OnAbilityActivated");
static_assert(sizeof(HWCharacterAbilitySystemActor_OnAbilityActivated) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_OnAbilityActivated");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnAbilityActivated, Ability) == 0x000000, "Member 'HWCharacterAbilitySystemActor_OnAbilityActivated::Ability' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.OnAbilityFailedActivation
// 0x0028 (0x0028 - 0x0000)
struct HWCharacterAbilitySystemActor_OnAbilityFailedActivation final
{
public:
	const class UGameplayAbility*                 Ability;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FailedTags;                                        // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_OnAbilityFailedActivation) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_OnAbilityFailedActivation");
static_assert(sizeof(HWCharacterAbilitySystemActor_OnAbilityFailedActivation) == 0x000028, "Wrong size on HWCharacterAbilitySystemActor_OnAbilityFailedActivation");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnAbilityFailedActivation, Ability) == 0x000000, "Member 'HWCharacterAbilitySystemActor_OnAbilityFailedActivation::Ability' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnAbilityFailedActivation, FailedTags) == 0x000008, "Member 'HWCharacterAbilitySystemActor_OnAbilityFailedActivation::FailedTags' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.OnDeployableSpawned
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_OnDeployableSpawned final
{
public:
	class AHWDeployable*                          SpawnedDeployable;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_OnDeployableSpawned) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_OnDeployableSpawned");
static_assert(sizeof(HWCharacterAbilitySystemActor_OnDeployableSpawned) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_OnDeployableSpawned");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnDeployableSpawned, SpawnedDeployable) == 0x000000, "Member 'HWCharacterAbilitySystemActor_OnDeployableSpawned::SpawnedDeployable' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.OnInventoryEquipmentPurchased
// 0x0018 (0x0018 - 0x0000)
struct HWCharacterAbilitySystemActor_OnInventoryEquipmentPurchased final
{
public:
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       Slot;                                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterAbilitySystemActor_OnInventoryEquipmentPurchased) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_OnInventoryEquipmentPurchased");
static_assert(sizeof(HWCharacterAbilitySystemActor_OnInventoryEquipmentPurchased) == 0x000018, "Wrong size on HWCharacterAbilitySystemActor_OnInventoryEquipmentPurchased");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnInventoryEquipmentPurchased, EquipmentInstance) == 0x000000, "Member 'HWCharacterAbilitySystemActor_OnInventoryEquipmentPurchased::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnInventoryEquipmentPurchased, Slot) == 0x000008, "Member 'HWCharacterAbilitySystemActor_OnInventoryEquipmentPurchased::Slot' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.OnReceiveOwningPlayerGodLoadout
// 0x0130 (0x0130 - 0x0000)
struct HWCharacterAbilitySystemActor_OnReceiveOwningPlayerGodLoadout final
{
public:
	const class UHWCharacterItem*                 InCharacterItem;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWGodLoadout                          InGodLoadout;                                      // 0x0008(0x0128)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_OnReceiveOwningPlayerGodLoadout) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_OnReceiveOwningPlayerGodLoadout");
static_assert(sizeof(HWCharacterAbilitySystemActor_OnReceiveOwningPlayerGodLoadout) == 0x000130, "Wrong size on HWCharacterAbilitySystemActor_OnReceiveOwningPlayerGodLoadout");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnReceiveOwningPlayerGodLoadout, InCharacterItem) == 0x000000, "Member 'HWCharacterAbilitySystemActor_OnReceiveOwningPlayerGodLoadout::InCharacterItem' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnReceiveOwningPlayerGodLoadout, InGodLoadout) == 0x000008, "Member 'HWCharacterAbilitySystemActor_OnReceiveOwningPlayerGodLoadout::InGodLoadout' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.OnReceiveOwningPlayerLoadout
// 0x00B8 (0x00B8 - 0x0000)
struct HWCharacterAbilitySystemActor_OnReceiveOwningPlayerLoadout final
{
public:
	struct FHWPlayerLoadout                       InPlayerLoadout;                                   // 0x0000(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_OnReceiveOwningPlayerLoadout) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_OnReceiveOwningPlayerLoadout");
static_assert(sizeof(HWCharacterAbilitySystemActor_OnReceiveOwningPlayerLoadout) == 0x0000B8, "Wrong size on HWCharacterAbilitySystemActor_OnReceiveOwningPlayerLoadout");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnReceiveOwningPlayerLoadout, InPlayerLoadout) == 0x000000, "Member 'HWCharacterAbilitySystemActor_OnReceiveOwningPlayerLoadout::InPlayerLoadout' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.OnRep_GrantedDynamicItems
// 0x0010 (0x0010 - 0x0000)
struct HWCharacterAbilitySystemActor_OnRep_GrantedDynamicItems final
{
public:
	TArray<struct FHWDynamicItemInfo>             OldGrantedDynamicItems;                            // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_OnRep_GrantedDynamicItems) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_OnRep_GrantedDynamicItems");
static_assert(sizeof(HWCharacterAbilitySystemActor_OnRep_GrantedDynamicItems) == 0x000010, "Wrong size on HWCharacterAbilitySystemActor_OnRep_GrantedDynamicItems");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnRep_GrantedDynamicItems, OldGrantedDynamicItems) == 0x000000, "Member 'HWCharacterAbilitySystemActor_OnRep_GrantedDynamicItems::OldGrantedDynamicItems' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.OnTeamMemberAdded
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_OnTeamMemberAdded final
{
public:
	class AHWPlayerState*                         TeamMember;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_OnTeamMemberAdded) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_OnTeamMemberAdded");
static_assert(sizeof(HWCharacterAbilitySystemActor_OnTeamMemberAdded) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_OnTeamMemberAdded");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnTeamMemberAdded, TeamMember) == 0x000000, "Member 'HWCharacterAbilitySystemActor_OnTeamMemberAdded::TeamMember' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.OnTeamMemberRemoved
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_OnTeamMemberRemoved final
{
public:
	class AHWPlayerState*                         TeamMember;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_OnTeamMemberRemoved) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_OnTeamMemberRemoved");
static_assert(sizeof(HWCharacterAbilitySystemActor_OnTeamMemberRemoved) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_OnTeamMemberRemoved");
static_assert(offsetof(HWCharacterAbilitySystemActor_OnTeamMemberRemoved, TeamMember) == 0x000000, "Member 'HWCharacterAbilitySystemActor_OnTeamMemberRemoved::TeamMember' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.SetLevel
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_SetLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSetXp;                                       // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterAbilitySystemActor_SetLevel) == 0x000004, "Wrong alignment on HWCharacterAbilitySystemActor_SetLevel");
static_assert(sizeof(HWCharacterAbilitySystemActor_SetLevel) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_SetLevel");
static_assert(offsetof(HWCharacterAbilitySystemActor_SetLevel, Level) == 0x000000, "Member 'HWCharacterAbilitySystemActor_SetLevel::Level' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_SetLevel, bForceSetXp) == 0x000004, "Member 'HWCharacterAbilitySystemActor_SetLevel::bForceSetXp' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.TriggerPotentialFireBugReport
// 0x0028 (0x0028 - 0x0000)
struct HWCharacterAbilitySystemActor_TriggerPotentialFireBugReport final
{
public:
	const class UGameplayAbility*                 Ability;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FailedTags;                                        // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_TriggerPotentialFireBugReport) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_TriggerPotentialFireBugReport");
static_assert(sizeof(HWCharacterAbilitySystemActor_TriggerPotentialFireBugReport) == 0x000028, "Wrong size on HWCharacterAbilitySystemActor_TriggerPotentialFireBugReport");
static_assert(offsetof(HWCharacterAbilitySystemActor_TriggerPotentialFireBugReport, Ability) == 0x000000, "Member 'HWCharacterAbilitySystemActor_TriggerPotentialFireBugReport::Ability' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_TriggerPotentialFireBugReport, FailedTags) == 0x000008, "Member 'HWCharacterAbilitySystemActor_TriggerPotentialFireBugReport::FailedTags' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetAbilitySystemComponent final
{
public:
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetAbilitySystemComponent) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetAbilitySystemComponent");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetAbilitySystemComponent) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetAbilitySystemComponent");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetAutoBuyComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetAutoBuyComponent final
{
public:
	class UHWAutoBuyComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetAutoBuyComponent) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetAutoBuyComponent");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetAutoBuyComponent) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetAutoBuyComponent");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetAutoBuyComponent, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetAutoBuyComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetAutoSkillComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetAutoSkillComponent final
{
public:
	class UHWAutoSkillComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetAutoSkillComponent) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetAutoSkillComponent");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetAutoSkillComponent) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetAutoSkillComponent");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetAutoSkillComponent, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetAutoSkillComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetCharacterMasteryLevel
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterAbilitySystemActor_GetCharacterMasteryLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetCharacterMasteryLevel) == 0x000004, "Wrong alignment on HWCharacterAbilitySystemActor_GetCharacterMasteryLevel");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetCharacterMasteryLevel) == 0x000004, "Wrong size on HWCharacterAbilitySystemActor_GetCharacterMasteryLevel");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetCharacterMasteryLevel, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetCharacterMasteryLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetCharacterOwner
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetCharacterOwner final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetCharacterOwner) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetCharacterOwner");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetCharacterOwner) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetCharacterOwner");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetCharacterOwner, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetCharacterOwner::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetCritProbability
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetCritProbability final
{
public:
	class UHWCritProbability*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetCritProbability) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetCritProbability");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetCritProbability) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetCritProbability");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetCritProbability, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetCritProbability::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetCurrentCharacterInfo
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetCurrentCharacterInfo final
{
public:
	const class UHWCharacterInfo*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetCurrentCharacterInfo) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetCurrentCharacterInfo");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetCurrentCharacterInfo) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetCurrentCharacterInfo");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetCurrentCharacterInfo, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetCurrentCharacterInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetCurrentCharacterItem
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetCurrentCharacterItem final
{
public:
	const class UHWCharacterItem*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetCurrentCharacterItem) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetCurrentCharacterItem");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetCurrentCharacterItem) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetCurrentCharacterItem");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetCurrentCharacterItem, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetCurrentCharacterItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetCurrentPlayerState
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetCurrentPlayerState final
{
public:
	class AHWPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetCurrentPlayerState) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetCurrentPlayerState");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetCurrentPlayerState) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetCurrentPlayerState");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetCurrentPlayerState, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetCurrentPlayerState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetCurrentSkinItem
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetCurrentSkinItem final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetCurrentSkinItem) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetCurrentSkinItem");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetCurrentSkinItem) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetCurrentSkinItem");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetCurrentSkinItem, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetCurrentSkinItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetExpectedRespawnTimeRemaining
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterAbilitySystemActor_GetExpectedRespawnTimeRemaining final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetExpectedRespawnTimeRemaining) == 0x000004, "Wrong alignment on HWCharacterAbilitySystemActor_GetExpectedRespawnTimeRemaining");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetExpectedRespawnTimeRemaining) == 0x000004, "Wrong size on HWCharacterAbilitySystemActor_GetExpectedRespawnTimeRemaining");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetExpectedRespawnTimeRemaining, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetExpectedRespawnTimeRemaining::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetExpectedRespawnTimestamp
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterAbilitySystemActor_GetExpectedRespawnTimestamp final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetExpectedRespawnTimestamp) == 0x000004, "Wrong alignment on HWCharacterAbilitySystemActor_GetExpectedRespawnTimestamp");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetExpectedRespawnTimestamp) == 0x000004, "Wrong size on HWCharacterAbilitySystemActor_GetExpectedRespawnTimestamp");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetExpectedRespawnTimestamp, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetExpectedRespawnTimestamp::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetFamiliarComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetFamiliarComponent final
{
public:
	class UHWFamiliarComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetFamiliarComponent) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetFamiliarComponent");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetFamiliarComponent) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetFamiliarComponent");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetFamiliarComponent, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetFamiliarComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetFamiliarManager
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetFamiliarManager final
{
public:
	class UHWFamiliarManagerComponent*            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetFamiliarManager) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetFamiliarManager");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetFamiliarManager) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetFamiliarManager");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetFamiliarManager, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetFamiliarManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetHWAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetHWAbilitySystemComponent final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetHWAbilitySystemComponent) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetHWAbilitySystemComponent");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetHWAbilitySystemComponent) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetHWAbilitySystemComponent");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetHWAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetHWAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetInventoryManager
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetInventoryManager final
{
public:
	class UHWInventoryManagerComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetInventoryManager) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetInventoryManager");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetInventoryManager) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetInventoryManager");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetInventoryManager, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetInventoryManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetLevelByXp
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetLevelByXp final
{
public:
	int32                                         XP;                                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetLevelByXp) == 0x000004, "Wrong alignment on HWCharacterAbilitySystemActor_GetLevelByXp");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetLevelByXp) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetLevelByXp");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetLevelByXp, XP) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetLevelByXp::XP' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetLevelByXp, ReturnValue) == 0x000004, "Member 'HWCharacterAbilitySystemActor_GetLevelByXp::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetLoadoutComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetLoadoutComponent final
{
public:
	class UHWLoadoutComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetLoadoutComponent) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetLoadoutComponent");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetLoadoutComponent) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetLoadoutComponent");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetLoadoutComponent, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetLoadoutComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetMaxLevel
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterAbilitySystemActor_GetMaxLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetMaxLevel) == 0x000004, "Wrong alignment on HWCharacterAbilitySystemActor_GetMaxLevel");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetMaxLevel) == 0x000004, "Wrong size on HWCharacterAbilitySystemActor_GetMaxLevel");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetMaxLevel, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetMaxLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetOwningController
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetOwningController final
{
public:
	class AController*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetOwningController) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetOwningController");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetOwningController) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetOwningController");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetOwningController, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetOwningController::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetPassiveMeterComponent
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetPassiveMeterComponent final
{
public:
	class UHWPassiveMeterComponent*               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetPassiveMeterComponent) == 0x000008, "Wrong alignment on HWCharacterAbilitySystemActor_GetPassiveMeterComponent");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetPassiveMeterComponent) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetPassiveMeterComponent");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetPassiveMeterComponent, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetPassiveMeterComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetRespawnTransform
// 0x0060 (0x0060 - 0x0000)
struct HWCharacterAbilitySystemActor_GetRespawnTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetRespawnTransform) == 0x000010, "Wrong alignment on HWCharacterAbilitySystemActor_GetRespawnTransform");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetRespawnTransform) == 0x000060, "Wrong size on HWCharacterAbilitySystemActor_GetRespawnTransform");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetRespawnTransform, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetRespawnTransform::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.GetXpRequirementByLevel
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterAbilitySystemActor_GetXpRequirementByLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_GetXpRequirementByLevel) == 0x000004, "Wrong alignment on HWCharacterAbilitySystemActor_GetXpRequirementByLevel");
static_assert(sizeof(HWCharacterAbilitySystemActor_GetXpRequirementByLevel) == 0x000008, "Wrong size on HWCharacterAbilitySystemActor_GetXpRequirementByLevel");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetXpRequirementByLevel, Level) == 0x000000, "Member 'HWCharacterAbilitySystemActor_GetXpRequirementByLevel::Level' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_GetXpRequirementByLevel, ReturnValue) == 0x000004, "Member 'HWCharacterAbilitySystemActor_GetXpRequirementByLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.IsAIControlled
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterAbilitySystemActor_IsAIControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_IsAIControlled) == 0x000001, "Wrong alignment on HWCharacterAbilitySystemActor_IsAIControlled");
static_assert(sizeof(HWCharacterAbilitySystemActor_IsAIControlled) == 0x000001, "Wrong size on HWCharacterAbilitySystemActor_IsAIControlled");
static_assert(offsetof(HWCharacterAbilitySystemActor_IsAIControlled, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_IsAIControlled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.IsAwaitingRespawn
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterAbilitySystemActor_IsAwaitingRespawn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_IsAwaitingRespawn) == 0x000001, "Wrong alignment on HWCharacterAbilitySystemActor_IsAwaitingRespawn");
static_assert(sizeof(HWCharacterAbilitySystemActor_IsAwaitingRespawn) == 0x000001, "Wrong size on HWCharacterAbilitySystemActor_IsAwaitingRespawn");
static_assert(offsetof(HWCharacterAbilitySystemActor_IsAwaitingRespawn, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_IsAwaitingRespawn::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.IsDebugIgnoreCooldown
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterAbilitySystemActor_IsDebugIgnoreCooldown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_IsDebugIgnoreCooldown) == 0x000001, "Wrong alignment on HWCharacterAbilitySystemActor_IsDebugIgnoreCooldown");
static_assert(sizeof(HWCharacterAbilitySystemActor_IsDebugIgnoreCooldown) == 0x000001, "Wrong size on HWCharacterAbilitySystemActor_IsDebugIgnoreCooldown");
static_assert(offsetof(HWCharacterAbilitySystemActor_IsDebugIgnoreCooldown, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_IsDebugIgnoreCooldown::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.IsDebugIgnoreCosts
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterAbilitySystemActor_IsDebugIgnoreCosts final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_IsDebugIgnoreCosts) == 0x000001, "Wrong alignment on HWCharacterAbilitySystemActor_IsDebugIgnoreCosts");
static_assert(sizeof(HWCharacterAbilitySystemActor_IsDebugIgnoreCosts) == 0x000001, "Wrong size on HWCharacterAbilitySystemActor_IsDebugIgnoreCosts");
static_assert(offsetof(HWCharacterAbilitySystemActor_IsDebugIgnoreCosts, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_IsDebugIgnoreCosts::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.IsFamiliar
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterAbilitySystemActor_IsFamiliar final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_IsFamiliar) == 0x000001, "Wrong alignment on HWCharacterAbilitySystemActor_IsFamiliar");
static_assert(sizeof(HWCharacterAbilitySystemActor_IsFamiliar) == 0x000001, "Wrong size on HWCharacterAbilitySystemActor_IsFamiliar");
static_assert(offsetof(HWCharacterAbilitySystemActor_IsFamiliar, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_IsFamiliar::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.IsInputCategoryAllowed
// 0x0002 (0x0002 - 0x0000)
struct HWCharacterAbilitySystemActor_IsInputCategoryAllowed final
{
public:
	EHWAllowedInputCategory                       Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_IsInputCategoryAllowed) == 0x000001, "Wrong alignment on HWCharacterAbilitySystemActor_IsInputCategoryAllowed");
static_assert(sizeof(HWCharacterAbilitySystemActor_IsInputCategoryAllowed) == 0x000002, "Wrong size on HWCharacterAbilitySystemActor_IsInputCategoryAllowed");
static_assert(offsetof(HWCharacterAbilitySystemActor_IsInputCategoryAllowed, Category) == 0x000000, "Member 'HWCharacterAbilitySystemActor_IsInputCategoryAllowed::Category' has a wrong offset!");
static_assert(offsetof(HWCharacterAbilitySystemActor_IsInputCategoryAllowed, ReturnValue) == 0x000001, "Member 'HWCharacterAbilitySystemActor_IsInputCategoryAllowed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.IsLocallyControlled
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterAbilitySystemActor_IsLocallyControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_IsLocallyControlled) == 0x000001, "Wrong alignment on HWCharacterAbilitySystemActor_IsLocallyControlled");
static_assert(sizeof(HWCharacterAbilitySystemActor_IsLocallyControlled) == 0x000001, "Wrong size on HWCharacterAbilitySystemActor_IsLocallyControlled");
static_assert(offsetof(HWCharacterAbilitySystemActor_IsLocallyControlled, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_IsLocallyControlled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.IsPlayableCharacter
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterAbilitySystemActor_IsPlayableCharacter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_IsPlayableCharacter) == 0x000001, "Wrong alignment on HWCharacterAbilitySystemActor_IsPlayableCharacter");
static_assert(sizeof(HWCharacterAbilitySystemActor_IsPlayableCharacter) == 0x000001, "Wrong size on HWCharacterAbilitySystemActor_IsPlayableCharacter");
static_assert(offsetof(HWCharacterAbilitySystemActor_IsPlayableCharacter, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_IsPlayableCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterAbilitySystemActor.IsPlayerControlled
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterAbilitySystemActor_IsPlayerControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterAbilitySystemActor_IsPlayerControlled) == 0x000001, "Wrong alignment on HWCharacterAbilitySystemActor_IsPlayerControlled");
static_assert(sizeof(HWCharacterAbilitySystemActor_IsPlayerControlled) == 0x000001, "Wrong size on HWCharacterAbilitySystemActor_IsPlayerControlled");
static_assert(offsetof(HWCharacterAbilitySystemActor_IsPlayerControlled, ReturnValue) == 0x000000, "Member 'HWCharacterAbilitySystemActor_IsPlayerControlled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTimeSeriesDataSource.AddDataPoint
// 0x0010 (0x0010 - 0x0000)
struct HWTimeSeriesDataSource_AddDataPoint final
{
public:
	class FName                                   SeriesId;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTimeSeriesDataSource_AddDataPoint) == 0x000004, "Wrong alignment on HWTimeSeriesDataSource_AddDataPoint");
static_assert(sizeof(HWTimeSeriesDataSource_AddDataPoint) == 0x000010, "Wrong size on HWTimeSeriesDataSource_AddDataPoint");
static_assert(offsetof(HWTimeSeriesDataSource_AddDataPoint, SeriesId) == 0x000000, "Member 'HWTimeSeriesDataSource_AddDataPoint::SeriesId' has a wrong offset!");
static_assert(offsetof(HWTimeSeriesDataSource_AddDataPoint, Time) == 0x000008, "Member 'HWTimeSeriesDataSource_AddDataPoint::Time' has a wrong offset!");
static_assert(offsetof(HWTimeSeriesDataSource_AddDataPoint, Value) == 0x00000C, "Member 'HWTimeSeriesDataSource_AddDataPoint::Value' has a wrong offset!");

// Function Hemingway.HWTimeSeriesDataSource.AddTimeSeries
// 0x0020 (0x0020 - 0x0000)
struct HWTimeSeriesDataSource_AddTimeSeries final
{
public:
	class FName                                   SeriesId;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SeriesName;                                        // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTimeSeriesDataSource_AddTimeSeries) == 0x000008, "Wrong alignment on HWTimeSeriesDataSource_AddTimeSeries");
static_assert(sizeof(HWTimeSeriesDataSource_AddTimeSeries) == 0x000020, "Wrong size on HWTimeSeriesDataSource_AddTimeSeries");
static_assert(offsetof(HWTimeSeriesDataSource_AddTimeSeries, SeriesId) == 0x000000, "Member 'HWTimeSeriesDataSource_AddTimeSeries::SeriesId' has a wrong offset!");
static_assert(offsetof(HWTimeSeriesDataSource_AddTimeSeries, SeriesName) == 0x000008, "Member 'HWTimeSeriesDataSource_AddTimeSeries::SeriesName' has a wrong offset!");

// Function Hemingway.HWVectorFieldWaypointComponent.Generate
// 0x000C (0x000C - 0x0000)
struct HWVectorFieldWaypointComponent_Generate final
{
public:
	int32                                         tileCountX;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         tileCountY;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         endPointDistance;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVectorFieldWaypointComponent_Generate) == 0x000004, "Wrong alignment on HWVectorFieldWaypointComponent_Generate");
static_assert(sizeof(HWVectorFieldWaypointComponent_Generate) == 0x00000C, "Wrong size on HWVectorFieldWaypointComponent_Generate");
static_assert(offsetof(HWVectorFieldWaypointComponent_Generate, tileCountX) == 0x000000, "Member 'HWVectorFieldWaypointComponent_Generate::tileCountX' has a wrong offset!");
static_assert(offsetof(HWVectorFieldWaypointComponent_Generate, tileCountY) == 0x000004, "Member 'HWVectorFieldWaypointComponent_Generate::tileCountY' has a wrong offset!");
static_assert(offsetof(HWVectorFieldWaypointComponent_Generate, endPointDistance) == 0x000008, "Member 'HWVectorFieldWaypointComponent_Generate::endPointDistance' has a wrong offset!");

// Function Hemingway.HWVectorFieldWaypointComponent.GetAvgVectorValue
// 0x0038 (0x0038 - 0x0000)
struct HWVectorFieldWaypointComponent_GetAvgVectorValue final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVectorFieldWaypointComponent_GetAvgVectorValue) == 0x000008, "Wrong alignment on HWVectorFieldWaypointComponent_GetAvgVectorValue");
static_assert(sizeof(HWVectorFieldWaypointComponent_GetAvgVectorValue) == 0x000038, "Wrong size on HWVectorFieldWaypointComponent_GetAvgVectorValue");
static_assert(offsetof(HWVectorFieldWaypointComponent_GetAvgVectorValue, Location) == 0x000000, "Member 'HWVectorFieldWaypointComponent_GetAvgVectorValue::Location' has a wrong offset!");
static_assert(offsetof(HWVectorFieldWaypointComponent_GetAvgVectorValue, Radius) == 0x000018, "Member 'HWVectorFieldWaypointComponent_GetAvgVectorValue::Radius' has a wrong offset!");
static_assert(offsetof(HWVectorFieldWaypointComponent_GetAvgVectorValue, ReturnValue) == 0x000020, "Member 'HWVectorFieldWaypointComponent_GetAvgVectorValue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWVectorFieldWaypointComponent.GetVectorValue
// 0x0030 (0x0030 - 0x0000)
struct HWVectorFieldWaypointComponent_GetVectorValue final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVectorFieldWaypointComponent_GetVectorValue) == 0x000008, "Wrong alignment on HWVectorFieldWaypointComponent_GetVectorValue");
static_assert(sizeof(HWVectorFieldWaypointComponent_GetVectorValue) == 0x000030, "Wrong size on HWVectorFieldWaypointComponent_GetVectorValue");
static_assert(offsetof(HWVectorFieldWaypointComponent_GetVectorValue, Location) == 0x000000, "Member 'HWVectorFieldWaypointComponent_GetVectorValue::Location' has a wrong offset!");
static_assert(offsetof(HWVectorFieldWaypointComponent_GetVectorValue, ReturnValue) == 0x000018, "Member 'HWVectorFieldWaypointComponent_GetVectorValue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitForAtributeChanged_Enhanced.WaitForAttributeChange_Enhanced
// 0x00F0 (0x00F0 - 0x0000)
struct HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWWaitForAttributeChangedConfig       Config;                                            // 0x0010(0x00D0)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 OptionalExternalOwner;                             // 0x00E0(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_WaitForAtributeChanged_Enhanced* ReturnValue;                               // 0x00E8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced) == 0x000008, "Wrong alignment on HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced");
static_assert(sizeof(HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced) == 0x0000F0, "Wrong size on HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced");
static_assert(offsetof(HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced, Config) == 0x000010, "Member 'HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced::Config' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced, OptionalExternalOwner) == 0x0000E0, "Member 'HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced::OptionalExternalOwner' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced, ReturnValue) == 0x0000E8, "Member 'HWAbilityTask_WaitForAtributeChanged_Enhanced_WaitForAttributeChange_Enhanced::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_ListenForContinousFireState.OnAbilityInputPressed
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityTask_ListenForContinousFireState_OnAbilityInputPressed final
{
public:
	float                                         TimeWaited;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_ListenForContinousFireState_OnAbilityInputPressed) == 0x000004, "Wrong alignment on HWAbilityTask_ListenForContinousFireState_OnAbilityInputPressed");
static_assert(sizeof(HWAbilityTask_ListenForContinousFireState_OnAbilityInputPressed) == 0x000004, "Wrong size on HWAbilityTask_ListenForContinousFireState_OnAbilityInputPressed");
static_assert(offsetof(HWAbilityTask_ListenForContinousFireState_OnAbilityInputPressed, TimeWaited) == 0x000000, "Member 'HWAbilityTask_ListenForContinousFireState_OnAbilityInputPressed::TimeWaited' has a wrong offset!");

// Function Hemingway.HWAbilityTask_ListenForContinousFireState.OnAbilityInputReleased
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityTask_ListenForContinousFireState_OnAbilityInputReleased final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_ListenForContinousFireState_OnAbilityInputReleased) == 0x000004, "Wrong alignment on HWAbilityTask_ListenForContinousFireState_OnAbilityInputReleased");
static_assert(sizeof(HWAbilityTask_ListenForContinousFireState_OnAbilityInputReleased) == 0x000004, "Wrong size on HWAbilityTask_ListenForContinousFireState_OnAbilityInputReleased");
static_assert(offsetof(HWAbilityTask_ListenForContinousFireState_OnAbilityInputReleased, TimeHeld) == 0x000000, "Member 'HWAbilityTask_ListenForContinousFireState_OnAbilityInputReleased::TimeHeld' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitQuickCastInput.WaitForQuickCastInput
// 0x0018 (0x0018 - 0x0000)
struct HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_WaitQuickCastInput*      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput) == 0x000008, "Wrong alignment on HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput");
static_assert(sizeof(HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput) == 0x000018, "Wrong size on HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput");
static_assert(offsetof(HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput, ReturnValue) == 0x000010, "Member 'HWAbilityTask_WaitQuickCastInput_WaitForQuickCastInput::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitQuickCastInput.OnAbilityInputReleased
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityTask_WaitQuickCastInput_OnAbilityInputReleased final
{
public:
	float                                         TimeHeld;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitQuickCastInput_OnAbilityInputReleased) == 0x000004, "Wrong alignment on HWAbilityTask_WaitQuickCastInput_OnAbilityInputReleased");
static_assert(sizeof(HWAbilityTask_WaitQuickCastInput_OnAbilityInputReleased) == 0x000004, "Wrong size on HWAbilityTask_WaitQuickCastInput_OnAbilityInputReleased");
static_assert(offsetof(HWAbilityTask_WaitQuickCastInput_OnAbilityInputReleased, TimeHeld) == 0x000000, "Member 'HWAbilityTask_WaitQuickCastInput_OnAbilityInputReleased::TimeHeld' has a wrong offset!");

// Function Hemingway.HWVectorFieldFollowerComponent.AddEffectorActor
// 0x0018 (0x0018 - 0x0000)
struct HWVectorFieldFollowerComponent_AddEffectorActor final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWVectorFieldFollowCalc*               inCalculation;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWeight;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVectorFieldFollowerComponent_AddEffectorActor) == 0x000008, "Wrong alignment on HWVectorFieldFollowerComponent_AddEffectorActor");
static_assert(sizeof(HWVectorFieldFollowerComponent_AddEffectorActor) == 0x000018, "Wrong size on HWVectorFieldFollowerComponent_AddEffectorActor");
static_assert(offsetof(HWVectorFieldFollowerComponent_AddEffectorActor, InActor) == 0x000000, "Member 'HWVectorFieldFollowerComponent_AddEffectorActor::InActor' has a wrong offset!");
static_assert(offsetof(HWVectorFieldFollowerComponent_AddEffectorActor, inCalculation) == 0x000008, "Member 'HWVectorFieldFollowerComponent_AddEffectorActor::inCalculation' has a wrong offset!");
static_assert(offsetof(HWVectorFieldFollowerComponent_AddEffectorActor, InWeight) == 0x000010, "Member 'HWVectorFieldFollowerComponent_AddEffectorActor::InWeight' has a wrong offset!");

// Function Hemingway.HWVectorFieldFollowerComponent.AddEffectorActorAsObstacle
// 0x0008 (0x0008 - 0x0000)
struct HWVectorFieldFollowerComponent_AddEffectorActorAsObstacle final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVectorFieldFollowerComponent_AddEffectorActorAsObstacle) == 0x000008, "Wrong alignment on HWVectorFieldFollowerComponent_AddEffectorActorAsObstacle");
static_assert(sizeof(HWVectorFieldFollowerComponent_AddEffectorActorAsObstacle) == 0x000008, "Wrong size on HWVectorFieldFollowerComponent_AddEffectorActorAsObstacle");
static_assert(offsetof(HWVectorFieldFollowerComponent_AddEffectorActorAsObstacle, InActor) == 0x000000, "Member 'HWVectorFieldFollowerComponent_AddEffectorActorAsObstacle::InActor' has a wrong offset!");

// Function Hemingway.HWVectorFieldFollowerComponent.AddEffectorLocation
// 0x0028 (0x0028 - 0x0000)
struct HWVectorFieldFollowerComponent_AddEffectorLocation final
{
public:
	struct FVector                                InLocation;                                        // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWVectorFieldFollowCalc*               inCalculation;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWeight;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVectorFieldFollowerComponent_AddEffectorLocation) == 0x000008, "Wrong alignment on HWVectorFieldFollowerComponent_AddEffectorLocation");
static_assert(sizeof(HWVectorFieldFollowerComponent_AddEffectorLocation) == 0x000028, "Wrong size on HWVectorFieldFollowerComponent_AddEffectorLocation");
static_assert(offsetof(HWVectorFieldFollowerComponent_AddEffectorLocation, InLocation) == 0x000000, "Member 'HWVectorFieldFollowerComponent_AddEffectorLocation::InLocation' has a wrong offset!");
static_assert(offsetof(HWVectorFieldFollowerComponent_AddEffectorLocation, inCalculation) == 0x000018, "Member 'HWVectorFieldFollowerComponent_AddEffectorLocation::inCalculation' has a wrong offset!");
static_assert(offsetof(HWVectorFieldFollowerComponent_AddEffectorLocation, InWeight) == 0x000020, "Member 'HWVectorFieldFollowerComponent_AddEffectorLocation::InWeight' has a wrong offset!");

// Function Hemingway.HWVectorFieldFollowerComponent.SetWaypoint
// 0x0010 (0x0010 - 0x0000)
struct HWVectorFieldFollowerComponent_SetWaypoint final
{
public:
	class AActor*                                 inWaypointActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWeight;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVectorFieldFollowerComponent_SetWaypoint) == 0x000008, "Wrong alignment on HWVectorFieldFollowerComponent_SetWaypoint");
static_assert(sizeof(HWVectorFieldFollowerComponent_SetWaypoint) == 0x000010, "Wrong size on HWVectorFieldFollowerComponent_SetWaypoint");
static_assert(offsetof(HWVectorFieldFollowerComponent_SetWaypoint, inWaypointActor) == 0x000000, "Member 'HWVectorFieldFollowerComponent_SetWaypoint::inWaypointActor' has a wrong offset!");
static_assert(offsetof(HWVectorFieldFollowerComponent_SetWaypoint, InWeight) == 0x000008, "Member 'HWVectorFieldFollowerComponent_SetWaypoint::InWeight' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitAbilityFire.WaitForAbilityFire
// 0x0028 (0x0028 - 0x0000)
struct HWAbilityTask_WaitAbilityFire_WaitForAbilityFire final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithTag;                                           // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithoutTag;                                        // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitAbilityFire*         ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire) == 0x000008, "Wrong alignment on HWAbilityTask_WaitAbilityFire_WaitForAbilityFire");
static_assert(sizeof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire) == 0x000028, "Wrong size on HWAbilityTask_WaitAbilityFire_WaitForAbilityFire");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitAbilityFire_WaitForAbilityFire::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire, WithTag) == 0x000008, "Member 'HWAbilityTask_WaitAbilityFire_WaitForAbilityFire::WithTag' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire, WithoutTag) == 0x000010, "Member 'HWAbilityTask_WaitAbilityFire_WaitForAbilityFire::WithoutTag' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire, TriggerOnce) == 0x000018, "Member 'HWAbilityTask_WaitAbilityFire_WaitForAbilityFire::TriggerOnce' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire, ReturnValue) == 0x000020, "Member 'HWAbilityTask_WaitAbilityFire_WaitForAbilityFire::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitAbilityFire.WaitForAbilityFire_Query
// 0x0060 (0x0060 - 0x0000)
struct HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      Query;                                             // 0x0008(0x0048)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitAbilityFire*         ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query) == 0x000008, "Wrong alignment on HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query");
static_assert(sizeof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query) == 0x000060, "Wrong size on HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query, Query) == 0x000008, "Member 'HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query::Query' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query, TriggerOnce) == 0x000050, "Member 'HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query::TriggerOnce' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query, ReturnValue) == 0x000058, "Member 'HWAbilityTask_WaitAbilityFire_WaitForAbilityFire_Query::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitAbilityFire.OnAbilityFire
// 0x0030 (0x0030 - 0x0000)
struct HWAbilityTask_WaitAbilityFire_OnAbilityFire final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0008(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0028(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitAbilityFire_OnAbilityFire) == 0x000008, "Wrong alignment on HWAbilityTask_WaitAbilityFire_OnAbilityFire");
static_assert(sizeof(HWAbilityTask_WaitAbilityFire_OnAbilityFire) == 0x000030, "Wrong size on HWAbilityTask_WaitAbilityFire_OnAbilityFire");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_OnAbilityFire, AbilityHandle) == 0x000000, "Member 'HWAbilityTask_WaitAbilityFire_OnAbilityFire::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_OnAbilityFire, AbilityTags) == 0x000008, "Member 'HWAbilityTask_WaitAbilityFire_OnAbilityFire::AbilityTags' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityFire_OnAbilityFire, FiringInstanceId) == 0x000028, "Member 'HWAbilityTask_WaitAbilityFire_OnAbilityFire::FiringInstanceId' has a wrong offset!");

// Function Hemingway.HWVoiceComponent.AttemptPlayVoiceEvent
// 0x0028 (0x0028 - 0x0000)
struct HWVoiceComponent_AttemptPlayVoiceEvent final
{
public:
	struct FHWVoiceOverQueue                      Event;                                             // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVoiceComponent_AttemptPlayVoiceEvent) == 0x000008, "Wrong alignment on HWVoiceComponent_AttemptPlayVoiceEvent");
static_assert(sizeof(HWVoiceComponent_AttemptPlayVoiceEvent) == 0x000028, "Wrong size on HWVoiceComponent_AttemptPlayVoiceEvent");
static_assert(offsetof(HWVoiceComponent_AttemptPlayVoiceEvent, Event) == 0x000000, "Member 'HWVoiceComponent_AttemptPlayVoiceEvent::Event' has a wrong offset!");

// Function Hemingway.HWVoiceComponent.OnQueuedEventAudioFinished
// 0x0008 (0x0008 - 0x0000)
struct HWVoiceComponent_OnQueuedEventAudioFinished final
{
public:
	class UAudioComponent*                        FinishedComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVoiceComponent_OnQueuedEventAudioFinished) == 0x000008, "Wrong alignment on HWVoiceComponent_OnQueuedEventAudioFinished");
static_assert(sizeof(HWVoiceComponent_OnQueuedEventAudioFinished) == 0x000008, "Wrong size on HWVoiceComponent_OnQueuedEventAudioFinished");
static_assert(offsetof(HWVoiceComponent_OnQueuedEventAudioFinished, FinishedComponent) == 0x000000, "Member 'HWVoiceComponent_OnQueuedEventAudioFinished::FinishedComponent' has a wrong offset!");

// Function Hemingway.HWVoiceComponent.SetActiveEvent
// 0x0028 (0x0028 - 0x0000)
struct HWVoiceComponent_SetActiveEvent final
{
public:
	struct FHWVoiceOverQueue                      NewActiveEvent;                                    // 0x0000(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVoiceComponent_SetActiveEvent) == 0x000008, "Wrong alignment on HWVoiceComponent_SetActiveEvent");
static_assert(sizeof(HWVoiceComponent_SetActiveEvent) == 0x000028, "Wrong size on HWVoiceComponent_SetActiveEvent");
static_assert(offsetof(HWVoiceComponent_SetActiveEvent, NewActiveEvent) == 0x000000, "Member 'HWVoiceComponent_SetActiveEvent::NewActiveEvent' has a wrong offset!");

// Function Hemingway.HWVoiceComponent.TriggerLocalEvent
// 0x0010 (0x0010 - 0x0000)
struct HWVoiceComponent_TriggerLocalEvent final
{
public:
	struct FGameplayTag                           EventType;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           SkinnableActorOverride;                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVoiceComponent_TriggerLocalEvent) == 0x000008, "Wrong alignment on HWVoiceComponent_TriggerLocalEvent");
static_assert(sizeof(HWVoiceComponent_TriggerLocalEvent) == 0x000010, "Wrong size on HWVoiceComponent_TriggerLocalEvent");
static_assert(offsetof(HWVoiceComponent_TriggerLocalEvent, EventType) == 0x000000, "Member 'HWVoiceComponent_TriggerLocalEvent::EventType' has a wrong offset!");
static_assert(offsetof(HWVoiceComponent_TriggerLocalEvent, SkinnableActorOverride) == 0x000008, "Member 'HWVoiceComponent_TriggerLocalEvent::SkinnableActorOverride' has a wrong offset!");

// Function Hemingway.HWVoiceComponent.CanPlayVoice
// 0x0010 (0x0010 - 0x0000)
struct HWVoiceComponent_CanPlayVoice final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToPlay;                                      // 0x0008(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVoiceComponent_CanPlayVoice) == 0x000004, "Wrong alignment on HWVoiceComponent_CanPlayVoice");
static_assert(sizeof(HWVoiceComponent_CanPlayVoice) == 0x000010, "Wrong size on HWVoiceComponent_CanPlayVoice");
static_assert(offsetof(HWVoiceComponent_CanPlayVoice, EventTag) == 0x000000, "Member 'HWVoiceComponent_CanPlayVoice::EventTag' has a wrong offset!");
static_assert(offsetof(HWVoiceComponent_CanPlayVoice, ChanceToPlay) == 0x000008, "Member 'HWVoiceComponent_CanPlayVoice::ChanceToPlay' has a wrong offset!");
static_assert(offsetof(HWVoiceComponent_CanPlayVoice, ReturnValue) == 0x00000C, "Member 'HWVoiceComponent_CanPlayVoice::ReturnValue' has a wrong offset!");

// Function Hemingway.HWVoiceComponent.GetActiveEvent
// 0x0028 (0x0028 - 0x0000)
struct HWVoiceComponent_GetActiveEvent final
{
public:
	struct FHWVoiceOverQueue                      ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVoiceComponent_GetActiveEvent) == 0x000008, "Wrong alignment on HWVoiceComponent_GetActiveEvent");
static_assert(sizeof(HWVoiceComponent_GetActiveEvent) == 0x000028, "Wrong size on HWVoiceComponent_GetActiveEvent");
static_assert(offsetof(HWVoiceComponent_GetActiveEvent, ReturnValue) == 0x000000, "Member 'HWVoiceComponent_GetActiveEvent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypoint.GetDistanceAlongRoute
// 0x0028 (0x0028 - 0x0000)
struct HWWaypoint_GetDistanceAlongRoute final
{
public:
	class AHWWaypoint*                            TargetPathWaypoint;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                QueryLocation;                                     // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypoint_GetDistanceAlongRoute) == 0x000008, "Wrong alignment on HWWaypoint_GetDistanceAlongRoute");
static_assert(sizeof(HWWaypoint_GetDistanceAlongRoute) == 0x000028, "Wrong size on HWWaypoint_GetDistanceAlongRoute");
static_assert(offsetof(HWWaypoint_GetDistanceAlongRoute, TargetPathWaypoint) == 0x000000, "Member 'HWWaypoint_GetDistanceAlongRoute::TargetPathWaypoint' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetDistanceAlongRoute, QueryLocation) == 0x000008, "Member 'HWWaypoint_GetDistanceAlongRoute::QueryLocation' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetDistanceAlongRoute, Direction) == 0x000020, "Member 'HWWaypoint_GetDistanceAlongRoute::Direction' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetDistanceAlongRoute, ReturnValue) == 0x000024, "Member 'HWWaypoint_GetDistanceAlongRoute::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypoint.GetLocationAlongRoute
// 0x0028 (0x0028 - 0x0000)
struct HWWaypoint_GetLocationAlongRoute final
{
public:
	class AHWWaypoint*                            SamplePathWaypoint;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypoint_GetLocationAlongRoute) == 0x000008, "Wrong alignment on HWWaypoint_GetLocationAlongRoute");
static_assert(sizeof(HWWaypoint_GetLocationAlongRoute) == 0x000028, "Wrong size on HWWaypoint_GetLocationAlongRoute");
static_assert(offsetof(HWWaypoint_GetLocationAlongRoute, SamplePathWaypoint) == 0x000000, "Member 'HWWaypoint_GetLocationAlongRoute::SamplePathWaypoint' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetLocationAlongRoute, Distance) == 0x000008, "Member 'HWWaypoint_GetLocationAlongRoute::Distance' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetLocationAlongRoute, Direction) == 0x00000C, "Member 'HWWaypoint_GetLocationAlongRoute::Direction' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetLocationAlongRoute, ReturnValue) == 0x000010, "Member 'HWWaypoint_GetLocationAlongRoute::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypoint.GetTotalRouteDistance
// 0x0010 (0x0010 - 0x0000)
struct HWWaypoint_GetTotalRouteDistance final
{
public:
	class AHWWaypoint*                            TargetPathWaypoint;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypoint_GetTotalRouteDistance) == 0x000008, "Wrong alignment on HWWaypoint_GetTotalRouteDistance");
static_assert(sizeof(HWWaypoint_GetTotalRouteDistance) == 0x000010, "Wrong size on HWWaypoint_GetTotalRouteDistance");
static_assert(offsetof(HWWaypoint_GetTotalRouteDistance, TargetPathWaypoint) == 0x000000, "Member 'HWWaypoint_GetTotalRouteDistance::TargetPathWaypoint' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetTotalRouteDistance, Direction) == 0x000008, "Member 'HWWaypoint_GetTotalRouteDistance::Direction' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetTotalRouteDistance, ReturnValue) == 0x00000C, "Member 'HWWaypoint_GetTotalRouteDistance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypoint.GetWaypointPathArray
// 0x0020 (0x0020 - 0x0000)
struct HWWaypoint_GetWaypointPathArray final
{
public:
	TArray<class AHWWaypoint*>                    OutResult;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class AHWWaypoint*                            PathWaypoint;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReversed;                                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWWaypoint_GetWaypointPathArray) == 0x000008, "Wrong alignment on HWWaypoint_GetWaypointPathArray");
static_assert(sizeof(HWWaypoint_GetWaypointPathArray) == 0x000020, "Wrong size on HWWaypoint_GetWaypointPathArray");
static_assert(offsetof(HWWaypoint_GetWaypointPathArray, OutResult) == 0x000000, "Member 'HWWaypoint_GetWaypointPathArray::OutResult' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetWaypointPathArray, PathWaypoint) == 0x000010, "Member 'HWWaypoint_GetWaypointPathArray::PathWaypoint' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetWaypointPathArray, bReversed) == 0x000018, "Member 'HWWaypoint_GetWaypointPathArray::bReversed' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetWaypointPathArray, ReturnValue) == 0x000019, "Member 'HWWaypoint_GetWaypointPathArray::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypoint.GetWaypointPathDirectionEndpoint
// 0x0018 (0x0018 - 0x0000)
struct HWWaypoint_GetWaypointPathDirectionEndpoint final
{
public:
	class AHWWaypoint*                            PathWaypoint;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWWaypoint*                            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypoint_GetWaypointPathDirectionEndpoint) == 0x000008, "Wrong alignment on HWWaypoint_GetWaypointPathDirectionEndpoint");
static_assert(sizeof(HWWaypoint_GetWaypointPathDirectionEndpoint) == 0x000018, "Wrong size on HWWaypoint_GetWaypointPathDirectionEndpoint");
static_assert(offsetof(HWWaypoint_GetWaypointPathDirectionEndpoint, PathWaypoint) == 0x000000, "Member 'HWWaypoint_GetWaypointPathDirectionEndpoint::PathWaypoint' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetWaypointPathDirectionEndpoint, Direction) == 0x000008, "Member 'HWWaypoint_GetWaypointPathDirectionEndpoint::Direction' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetWaypointPathDirectionEndpoint, ReturnValue) == 0x000010, "Member 'HWWaypoint_GetWaypointPathDirectionEndpoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypoint.GetWaypointPathEndpoint
// 0x0018 (0x0018 - 0x0000)
struct HWWaypoint_GetWaypointPathEndpoint final
{
public:
	class AHWWaypoint*                            PathWaypoint;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReversed;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWWaypoint*                            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypoint_GetWaypointPathEndpoint) == 0x000008, "Wrong alignment on HWWaypoint_GetWaypointPathEndpoint");
static_assert(sizeof(HWWaypoint_GetWaypointPathEndpoint) == 0x000018, "Wrong size on HWWaypoint_GetWaypointPathEndpoint");
static_assert(offsetof(HWWaypoint_GetWaypointPathEndpoint, PathWaypoint) == 0x000000, "Member 'HWWaypoint_GetWaypointPathEndpoint::PathWaypoint' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetWaypointPathEndpoint, bReversed) == 0x000008, "Member 'HWWaypoint_GetWaypointPathEndpoint::bReversed' has a wrong offset!");
static_assert(offsetof(HWWaypoint_GetWaypointPathEndpoint, ReturnValue) == 0x000010, "Member 'HWWaypoint_GetWaypointPathEndpoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypoint.IsPathWaypoint
// 0x0010 (0x0010 - 0x0000)
struct HWWaypoint_IsPathWaypoint final
{
public:
	class AHWWaypoint*                            Waypoint;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWWaypoint_IsPathWaypoint) == 0x000008, "Wrong alignment on HWWaypoint_IsPathWaypoint");
static_assert(sizeof(HWWaypoint_IsPathWaypoint) == 0x000010, "Wrong size on HWWaypoint_IsPathWaypoint");
static_assert(offsetof(HWWaypoint_IsPathWaypoint, Waypoint) == 0x000000, "Member 'HWWaypoint_IsPathWaypoint::Waypoint' has a wrong offset!");
static_assert(offsetof(HWWaypoint_IsPathWaypoint, ReturnValue) == 0x000008, "Member 'HWWaypoint_IsPathWaypoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypoint.ReversePathDirection
// 0x0002 (0x0002 - 0x0000)
struct HWWaypoint_ReversePathDirection final
{
public:
	EWaypointPathDirectionType                    Direction;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypoint_ReversePathDirection) == 0x000001, "Wrong alignment on HWWaypoint_ReversePathDirection");
static_assert(sizeof(HWWaypoint_ReversePathDirection) == 0x000002, "Wrong size on HWWaypoint_ReversePathDirection");
static_assert(offsetof(HWWaypoint_ReversePathDirection, Direction) == 0x000000, "Member 'HWWaypoint_ReversePathDirection::Direction' has a wrong offset!");
static_assert(offsetof(HWWaypoint_ReversePathDirection, ReturnValue) == 0x000001, "Member 'HWWaypoint_ReversePathDirection::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypoint.GetAllLinkedWaypoints
// 0x0010 (0x0010 - 0x0000)
struct HWWaypoint_GetAllLinkedWaypoints final
{
public:
	TArray<class AHWWaypoint*>                    Waypoints;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypoint_GetAllLinkedWaypoints) == 0x000008, "Wrong alignment on HWWaypoint_GetAllLinkedWaypoints");
static_assert(sizeof(HWWaypoint_GetAllLinkedWaypoints) == 0x000010, "Wrong size on HWWaypoint_GetAllLinkedWaypoints");
static_assert(offsetof(HWWaypoint_GetAllLinkedWaypoints, Waypoints) == 0x000000, "Member 'HWWaypoint_GetAllLinkedWaypoints::Waypoints' has a wrong offset!");

// Function Hemingway.HWWaypointSet.GetClosestWaypoint
// 0x0030 (0x0030 - 0x0000)
struct HWWaypointSet_GetClosestWaypoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHWWaypoint*>                    WayPointsToAvoid;                                  // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AHWWaypoint*                            ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypointSet_GetClosestWaypoint) == 0x000008, "Wrong alignment on HWWaypointSet_GetClosestWaypoint");
static_assert(sizeof(HWWaypointSet_GetClosestWaypoint) == 0x000030, "Wrong size on HWWaypointSet_GetClosestWaypoint");
static_assert(offsetof(HWWaypointSet_GetClosestWaypoint, Location) == 0x000000, "Member 'HWWaypointSet_GetClosestWaypoint::Location' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetClosestWaypoint, WayPointsToAvoid) == 0x000018, "Member 'HWWaypointSet_GetClosestWaypoint::WayPointsToAvoid' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetClosestWaypoint, ReturnValue) == 0x000028, "Member 'HWWaypointSet_GetClosestWaypoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypointSet.GetClosestWaypointInLane
// 0x0038 (0x0038 - 0x0000)
struct HWWaypointSet_GetClosestWaypointInLane final
{
public:
	class FName                                   LaneId;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHWWaypoint*>                    WayPointsToAvoid;                                  // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AHWWaypoint*                            ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypointSet_GetClosestWaypointInLane) == 0x000008, "Wrong alignment on HWWaypointSet_GetClosestWaypointInLane");
static_assert(sizeof(HWWaypointSet_GetClosestWaypointInLane) == 0x000038, "Wrong size on HWWaypointSet_GetClosestWaypointInLane");
static_assert(offsetof(HWWaypointSet_GetClosestWaypointInLane, LaneId) == 0x000000, "Member 'HWWaypointSet_GetClosestWaypointInLane::LaneId' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetClosestWaypointInLane, Location) == 0x000008, "Member 'HWWaypointSet_GetClosestWaypointInLane::Location' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetClosestWaypointInLane, WayPointsToAvoid) == 0x000020, "Member 'HWWaypointSet_GetClosestWaypointInLane::WayPointsToAvoid' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetClosestWaypointInLane, ReturnValue) == 0x000030, "Member 'HWWaypointSet_GetClosestWaypointInLane::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypointSet.GetEndpointLanePathFromClosestPoint
// 0x0040 (0x0040 - 0x0000)
struct HWWaypointSet_GetEndpointLanePathFromClosestPoint final
{
public:
	class FName                                   PathId;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWWaypoint*>                    OutResults;                                        // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWWaypointSet_GetEndpointLanePathFromClosestPoint) == 0x000008, "Wrong alignment on HWWaypointSet_GetEndpointLanePathFromClosestPoint");
static_assert(sizeof(HWWaypointSet_GetEndpointLanePathFromClosestPoint) == 0x000040, "Wrong size on HWWaypointSet_GetEndpointLanePathFromClosestPoint");
static_assert(offsetof(HWWaypointSet_GetEndpointLanePathFromClosestPoint, PathId) == 0x000000, "Member 'HWWaypointSet_GetEndpointLanePathFromClosestPoint::PathId' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetEndpointLanePathFromClosestPoint, Location) == 0x000008, "Member 'HWWaypointSet_GetEndpointLanePathFromClosestPoint::Location' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetEndpointLanePathFromClosestPoint, Direction) == 0x000020, "Member 'HWWaypointSet_GetEndpointLanePathFromClosestPoint::Direction' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetEndpointLanePathFromClosestPoint, OutResults) == 0x000028, "Member 'HWWaypointSet_GetEndpointLanePathFromClosestPoint::OutResults' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetEndpointLanePathFromClosestPoint, ReturnValue) == 0x000038, "Member 'HWWaypointSet_GetEndpointLanePathFromClosestPoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypointSet.GetNearGoalWaypointInLane
// 0x0040 (0x0040 - 0x0000)
struct HWWaypointSet_GetNearGoalWaypointInLane final
{
public:
	class FName                                   LaneId;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaypointPathDirectionType                    Direction;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHWWaypoint*>                    WayPointsToAvoid;                                  // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AHWWaypoint*                            ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypointSet_GetNearGoalWaypointInLane) == 0x000008, "Wrong alignment on HWWaypointSet_GetNearGoalWaypointInLane");
static_assert(sizeof(HWWaypointSet_GetNearGoalWaypointInLane) == 0x000040, "Wrong size on HWWaypointSet_GetNearGoalWaypointInLane");
static_assert(offsetof(HWWaypointSet_GetNearGoalWaypointInLane, LaneId) == 0x000000, "Member 'HWWaypointSet_GetNearGoalWaypointInLane::LaneId' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetNearGoalWaypointInLane, Location) == 0x000008, "Member 'HWWaypointSet_GetNearGoalWaypointInLane::Location' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetNearGoalWaypointInLane, Direction) == 0x000020, "Member 'HWWaypointSet_GetNearGoalWaypointInLane::Direction' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetNearGoalWaypointInLane, WayPointsToAvoid) == 0x000028, "Member 'HWWaypointSet_GetNearGoalWaypointInLane::WayPointsToAvoid' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetNearGoalWaypointInLane, ReturnValue) == 0x000038, "Member 'HWWaypointSet_GetNearGoalWaypointInLane::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypointSet.GetPresetWaypointPath
// 0x0020 (0x0020 - 0x0000)
struct HWWaypointSet_GetPresetWaypointPath final
{
public:
	class FName                                   PathId;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHWWaypoint*>                    OutResults;                                        // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWWaypointSet_GetPresetWaypointPath) == 0x000008, "Wrong alignment on HWWaypointSet_GetPresetWaypointPath");
static_assert(sizeof(HWWaypointSet_GetPresetWaypointPath) == 0x000020, "Wrong size on HWWaypointSet_GetPresetWaypointPath");
static_assert(offsetof(HWWaypointSet_GetPresetWaypointPath, PathId) == 0x000000, "Member 'HWWaypointSet_GetPresetWaypointPath::PathId' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetPresetWaypointPath, OutResults) == 0x000008, "Member 'HWWaypointSet_GetPresetWaypointPath::OutResults' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetPresetWaypointPath, ReturnValue) == 0x000018, "Member 'HWWaypointSet_GetPresetWaypointPath::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypointSet.GetTeamTargetPathInLane
// 0x0040 (0x0040 - 0x0000)
struct HWWaypointSet_GetTeamTargetPathInLane final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PathId;                                            // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHWWaypoint*>                    OutResults;                                        // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWWaypointSet_GetTeamTargetPathInLane) == 0x000008, "Wrong alignment on HWWaypointSet_GetTeamTargetPathInLane");
static_assert(sizeof(HWWaypointSet_GetTeamTargetPathInLane) == 0x000040, "Wrong size on HWWaypointSet_GetTeamTargetPathInLane");
static_assert(offsetof(HWWaypointSet_GetTeamTargetPathInLane, TeamId) == 0x000000, "Member 'HWWaypointSet_GetTeamTargetPathInLane::TeamId' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetTeamTargetPathInLane, Location) == 0x000008, "Member 'HWWaypointSet_GetTeamTargetPathInLane::Location' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetTeamTargetPathInLane, PathId) == 0x000020, "Member 'HWWaypointSet_GetTeamTargetPathInLane::PathId' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetTeamTargetPathInLane, OutResults) == 0x000028, "Member 'HWWaypointSet_GetTeamTargetPathInLane::OutResults' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetTeamTargetPathInLane, ReturnValue) == 0x000038, "Member 'HWWaypointSet_GetTeamTargetPathInLane::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypointSet.GetTeamTargetWaypoint
// 0x0030 (0x0030 - 0x0000)
struct HWWaypointSet_GetTeamTargetWaypoint final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClosest;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWWaypoint*                            ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWWaypointSet_GetTeamTargetWaypoint) == 0x000008, "Wrong alignment on HWWaypointSet_GetTeamTargetWaypoint");
static_assert(sizeof(HWWaypointSet_GetTeamTargetWaypoint) == 0x000030, "Wrong size on HWWaypointSet_GetTeamTargetWaypoint");
static_assert(offsetof(HWWaypointSet_GetTeamTargetWaypoint, TeamId) == 0x000000, "Member 'HWWaypointSet_GetTeamTargetWaypoint::TeamId' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetTeamTargetWaypoint, Location) == 0x000008, "Member 'HWWaypointSet_GetTeamTargetWaypoint::Location' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetTeamTargetWaypoint, bClosest) == 0x000020, "Member 'HWWaypointSet_GetTeamTargetWaypoint::bClosest' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_GetTeamTargetWaypoint, ReturnValue) == 0x000028, "Member 'HWWaypointSet_GetTeamTargetWaypoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypointSet.PickPathFromPresets
// 0x0058 (0x0058 - 0x0000)
struct HWWaypointSet_PickPathFromPresets final
{
public:
	TArray<class AHWWaypoint*>                    OutResults;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHWWaypoint*>                    WayPointsToAvoid;                                  // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWWaypointSet_PickPathFromPresets) == 0x000008, "Wrong alignment on HWWaypointSet_PickPathFromPresets");
static_assert(sizeof(HWWaypointSet_PickPathFromPresets) == 0x000058, "Wrong size on HWWaypointSet_PickPathFromPresets");
static_assert(offsetof(HWWaypointSet_PickPathFromPresets, OutResults) == 0x000000, "Member 'HWWaypointSet_PickPathFromPresets::OutResults' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_PickPathFromPresets, StartLocation) == 0x000010, "Member 'HWWaypointSet_PickPathFromPresets::StartLocation' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_PickPathFromPresets, EndLocation) == 0x000028, "Member 'HWWaypointSet_PickPathFromPresets::EndLocation' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_PickPathFromPresets, WayPointsToAvoid) == 0x000040, "Member 'HWWaypointSet_PickPathFromPresets::WayPointsToAvoid' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_PickPathFromPresets, ReturnValue) == 0x000050, "Member 'HWWaypointSet_PickPathFromPresets::ReturnValue' has a wrong offset!");

// Function Hemingway.HWWaypointSet.PickPathFromWaypoints
// 0x0058 (0x0058 - 0x0000)
struct HWWaypointSet_PickPathFromWaypoints final
{
public:
	TArray<class AHWWaypoint*>                    OutResults;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHWWaypoint*>                    WayPointsToAvoid;                                  // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWWaypointSet_PickPathFromWaypoints) == 0x000008, "Wrong alignment on HWWaypointSet_PickPathFromWaypoints");
static_assert(sizeof(HWWaypointSet_PickPathFromWaypoints) == 0x000058, "Wrong size on HWWaypointSet_PickPathFromWaypoints");
static_assert(offsetof(HWWaypointSet_PickPathFromWaypoints, OutResults) == 0x000000, "Member 'HWWaypointSet_PickPathFromWaypoints::OutResults' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_PickPathFromWaypoints, StartLocation) == 0x000010, "Member 'HWWaypointSet_PickPathFromWaypoints::StartLocation' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_PickPathFromWaypoints, EndLocation) == 0x000028, "Member 'HWWaypointSet_PickPathFromWaypoints::EndLocation' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_PickPathFromWaypoints, WayPointsToAvoid) == 0x000040, "Member 'HWWaypointSet_PickPathFromWaypoints::WayPointsToAvoid' has a wrong offset!");
static_assert(offsetof(HWWaypointSet_PickPathFromWaypoints, ReturnValue) == 0x000050, "Member 'HWWaypointSet_PickPathFromWaypoints::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_Dash.OnDashEnded
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_Attack_Dash_OnDashEnded final
{
public:
	class UHWGameplayDash*                        Dash;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasInterrupted;                                   // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_Attack_Dash_OnDashEnded) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_Dash_OnDashEnded");
static_assert(sizeof(HWAbilityTask_Attack_Dash_OnDashEnded) == 0x000010, "Wrong size on HWAbilityTask_Attack_Dash_OnDashEnded");
static_assert(offsetof(HWAbilityTask_Attack_Dash_OnDashEnded, Dash) == 0x000000, "Member 'HWAbilityTask_Attack_Dash_OnDashEnded::Dash' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_Dash_OnDashEnded, bWasInterrupted) == 0x000008, "Member 'HWAbilityTask_Attack_Dash_OnDashEnded::bWasInterrupted' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_Dash.OnDashStarted
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_Attack_Dash_OnDashStarted final
{
public:
	class UHWGameplayDash*                        Dash;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Attack_Dash_OnDashStarted) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_Dash_OnDashStarted");
static_assert(sizeof(HWAbilityTask_Attack_Dash_OnDashStarted) == 0x000008, "Wrong size on HWAbilityTask_Attack_Dash_OnDashStarted");
static_assert(offsetof(HWAbilityTask_Attack_Dash_OnDashStarted, Dash) == 0x000000, "Member 'HWAbilityTask_Attack_Dash_OnDashStarted::Dash' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Refireable.OnRep_RefireWindowInfo
// 0x0018 (0x0018 - 0x0000)
struct HWEquipmentComponent_Refireable_OnRep_RefireWindowInfo final
{
public:
	struct FHWRefireWindowInfo                    OldRefireWindowInfo;                               // 0x0000(0x0018)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Refireable_OnRep_RefireWindowInfo) == 0x000008, "Wrong alignment on HWEquipmentComponent_Refireable_OnRep_RefireWindowInfo");
static_assert(sizeof(HWEquipmentComponent_Refireable_OnRep_RefireWindowInfo) == 0x000018, "Wrong size on HWEquipmentComponent_Refireable_OnRep_RefireWindowInfo");
static_assert(offsetof(HWEquipmentComponent_Refireable_OnRep_RefireWindowInfo, OldRefireWindowInfo) == 0x000000, "Member 'HWEquipmentComponent_Refireable_OnRep_RefireWindowInfo::OldRefireWindowInfo' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Refireable.StartRefireWindow
// 0x0030 (0x0030 - 0x0000)
struct HWEquipmentComponent_Refireable_StartRefireWindow final
{
public:
	float                                         RefireWindowTime;                                  // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWAbilityRefireInfo                   RefireInfo;                                        // 0x0008(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          bIsRestartingWindow;                               // 0x0028(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_Refireable_StartRefireWindow) == 0x000008, "Wrong alignment on HWEquipmentComponent_Refireable_StartRefireWindow");
static_assert(sizeof(HWEquipmentComponent_Refireable_StartRefireWindow) == 0x000030, "Wrong size on HWEquipmentComponent_Refireable_StartRefireWindow");
static_assert(offsetof(HWEquipmentComponent_Refireable_StartRefireWindow, RefireWindowTime) == 0x000000, "Member 'HWEquipmentComponent_Refireable_StartRefireWindow::RefireWindowTime' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_Refireable_StartRefireWindow, RefireInfo) == 0x000008, "Member 'HWEquipmentComponent_Refireable_StartRefireWindow::RefireInfo' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_Refireable_StartRefireWindow, bIsRestartingWindow) == 0x000028, "Member 'HWEquipmentComponent_Refireable_StartRefireWindow::bIsRestartingWindow' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Refireable.TriggerRefire
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentComponent_Refireable_TriggerRefire final
{
public:
	class UHWGameplayAbility*                     AbilityInstance;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_Refireable_TriggerRefire) == 0x000008, "Wrong alignment on HWEquipmentComponent_Refireable_TriggerRefire");
static_assert(sizeof(HWEquipmentComponent_Refireable_TriggerRefire) == 0x000010, "Wrong size on HWEquipmentComponent_Refireable_TriggerRefire");
static_assert(offsetof(HWEquipmentComponent_Refireable_TriggerRefire, AbilityInstance) == 0x000000, "Member 'HWEquipmentComponent_Refireable_TriggerRefire::AbilityInstance' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_Refireable_TriggerRefire, ReturnValue) == 0x000008, "Member 'HWEquipmentComponent_Refireable_TriggerRefire::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Refireable.GetElapsedRefireTime
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Refireable_GetElapsedRefireTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Refireable_GetElapsedRefireTime) == 0x000004, "Wrong alignment on HWEquipmentComponent_Refireable_GetElapsedRefireTime");
static_assert(sizeof(HWEquipmentComponent_Refireable_GetElapsedRefireTime) == 0x000004, "Wrong size on HWEquipmentComponent_Refireable_GetElapsedRefireTime");
static_assert(offsetof(HWEquipmentComponent_Refireable_GetElapsedRefireTime, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Refireable_GetElapsedRefireTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Refireable.GetLastRefireTimeStamp
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Refireable_GetLastRefireTimeStamp final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Refireable_GetLastRefireTimeStamp) == 0x000004, "Wrong alignment on HWEquipmentComponent_Refireable_GetLastRefireTimeStamp");
static_assert(sizeof(HWEquipmentComponent_Refireable_GetLastRefireTimeStamp) == 0x000004, "Wrong size on HWEquipmentComponent_Refireable_GetLastRefireTimeStamp");
static_assert(offsetof(HWEquipmentComponent_Refireable_GetLastRefireTimeStamp, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Refireable_GetLastRefireTimeStamp::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Refireable.GetRefireAbilityHandle
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Refireable_GetRefireAbilityHandle final
{
public:
	struct FGameplayAbilitySpecHandle             ReturnValue;                                       // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Refireable_GetRefireAbilityHandle) == 0x000004, "Wrong alignment on HWEquipmentComponent_Refireable_GetRefireAbilityHandle");
static_assert(sizeof(HWEquipmentComponent_Refireable_GetRefireAbilityHandle) == 0x000004, "Wrong size on HWEquipmentComponent_Refireable_GetRefireAbilityHandle");
static_assert(offsetof(HWEquipmentComponent_Refireable_GetRefireAbilityHandle, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Refireable_GetRefireAbilityHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Refireable.GetRefireBehavior
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Refireable_GetRefireBehavior final
{
public:
	ERefireAbilityBehavior                        ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Refireable_GetRefireBehavior) == 0x000004, "Wrong alignment on HWEquipmentComponent_Refireable_GetRefireBehavior");
static_assert(sizeof(HWEquipmentComponent_Refireable_GetRefireBehavior) == 0x000004, "Wrong size on HWEquipmentComponent_Refireable_GetRefireBehavior");
static_assert(offsetof(HWEquipmentComponent_Refireable_GetRefireBehavior, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Refireable_GetRefireBehavior::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Refireable.GetRefireDuration
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Refireable_GetRefireDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Refireable_GetRefireDuration) == 0x000004, "Wrong alignment on HWEquipmentComponent_Refireable_GetRefireDuration");
static_assert(sizeof(HWEquipmentComponent_Refireable_GetRefireDuration) == 0x000004, "Wrong size on HWEquipmentComponent_Refireable_GetRefireDuration");
static_assert(offsetof(HWEquipmentComponent_Refireable_GetRefireDuration, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Refireable_GetRefireDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Refireable.IsRefireWindowActive
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Refireable_IsRefireWindowActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Refireable_IsRefireWindowActive) == 0x000001, "Wrong alignment on HWEquipmentComponent_Refireable_IsRefireWindowActive");
static_assert(sizeof(HWEquipmentComponent_Refireable_IsRefireWindowActive) == 0x000001, "Wrong size on HWEquipmentComponent_Refireable_IsRefireWindowActive");
static_assert(offsetof(HWEquipmentComponent_Refireable_IsRefireWindowActive, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Refireable_IsRefireWindowActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Refireable.ShouldRefireOnTrigger
// 0x0002 (0x0002 - 0x0000)
struct HWEquipmentComponent_Refireable_ShouldRefireOnTrigger final
{
public:
	EHWRefireTrigger                              RefireTrigger;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Refireable_ShouldRefireOnTrigger) == 0x000001, "Wrong alignment on HWEquipmentComponent_Refireable_ShouldRefireOnTrigger");
static_assert(sizeof(HWEquipmentComponent_Refireable_ShouldRefireOnTrigger) == 0x000002, "Wrong size on HWEquipmentComponent_Refireable_ShouldRefireOnTrigger");
static_assert(offsetof(HWEquipmentComponent_Refireable_ShouldRefireOnTrigger, RefireTrigger) == 0x000000, "Member 'HWEquipmentComponent_Refireable_ShouldRefireOnTrigger::RefireTrigger' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_Refireable_ShouldRefireOnTrigger, ReturnValue) == 0x000001, "Member 'HWEquipmentComponent_Refireable_ShouldRefireOnTrigger::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings_GroundTarget.GetManualCollisionRadius
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAimSettings_GroundTarget_GetManualCollisionRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_GroundTarget_GetManualCollisionRadius) == 0x000004, "Wrong alignment on HWAbilityAimSettings_GroundTarget_GetManualCollisionRadius");
static_assert(sizeof(HWAbilityAimSettings_GroundTarget_GetManualCollisionRadius) == 0x000004, "Wrong size on HWAbilityAimSettings_GroundTarget_GetManualCollisionRadius");
static_assert(offsetof(HWAbilityAimSettings_GroundTarget_GetManualCollisionRadius, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_GroundTarget_GetManualCollisionRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings_GroundTarget.GetMaxRange
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAimSettings_GroundTarget_GetMaxRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_GroundTarget_GetMaxRange) == 0x000004, "Wrong alignment on HWAbilityAimSettings_GroundTarget_GetMaxRange");
static_assert(sizeof(HWAbilityAimSettings_GroundTarget_GetMaxRange) == 0x000004, "Wrong size on HWAbilityAimSettings_GroundTarget_GetMaxRange");
static_assert(offsetof(HWAbilityAimSettings_GroundTarget_GetMaxRange, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_GroundTarget_GetMaxRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSettings_GroundTarget.GetMinRange
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAimSettings_GroundTarget_GetMinRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSettings_GroundTarget_GetMinRange) == 0x000004, "Wrong alignment on HWAbilityAimSettings_GroundTarget_GetMinRange");
static_assert(sizeof(HWAbilityAimSettings_GroundTarget_GetMinRange) == 0x000004, "Wrong size on HWAbilityAimSettings_GroundTarget_GetMinRange");
static_assert(offsetof(HWAbilityAimSettings_GroundTarget_GetMinRange, ReturnValue) == 0x000000, "Member 'HWAbilityAimSettings_GroundTarget_GetMinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.ActivateSpawning
// 0x0003 (0x0003 - 0x0000)
struct HWBotFactory_ActivateSpawning final
{
public:
	bool                                          bKillExistingBots;                                 // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTimer;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetLevelingActive;                                // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_ActivateSpawning) == 0x000001, "Wrong alignment on HWBotFactory_ActivateSpawning");
static_assert(sizeof(HWBotFactory_ActivateSpawning) == 0x000003, "Wrong size on HWBotFactory_ActivateSpawning");
static_assert(offsetof(HWBotFactory_ActivateSpawning, bKillExistingBots) == 0x000000, "Member 'HWBotFactory_ActivateSpawning::bKillExistingBots' has a wrong offset!");
static_assert(offsetof(HWBotFactory_ActivateSpawning, bOverrideTimer) == 0x000001, "Member 'HWBotFactory_ActivateSpawning::bOverrideTimer' has a wrong offset!");
static_assert(offsetof(HWBotFactory_ActivateSpawning, bSetLevelingActive) == 0x000002, "Member 'HWBotFactory_ActivateSpawning::bSetLevelingActive' has a wrong offset!");

// Function Hemingway.HWBotFactory.AdvanceSpawnWaveNumber
// 0x0004 (0x0004 - 0x0000)
struct HWBotFactory_AdvanceSpawnWaveNumber final
{
public:
	int32                                         Increment;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_AdvanceSpawnWaveNumber) == 0x000004, "Wrong alignment on HWBotFactory_AdvanceSpawnWaveNumber");
static_assert(sizeof(HWBotFactory_AdvanceSpawnWaveNumber) == 0x000004, "Wrong size on HWBotFactory_AdvanceSpawnWaveNumber");
static_assert(offsetof(HWBotFactory_AdvanceSpawnWaveNumber, Increment) == 0x000000, "Member 'HWBotFactory_AdvanceSpawnWaveNumber::Increment' has a wrong offset!");

// Function Hemingway.HWBotFactory.DeactivateSpawning
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_DeactivateSpawning final
{
public:
	bool                                          bKillExistingBots;                                 // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_DeactivateSpawning) == 0x000001, "Wrong alignment on HWBotFactory_DeactivateSpawning");
static_assert(sizeof(HWBotFactory_DeactivateSpawning) == 0x000001, "Wrong size on HWBotFactory_DeactivateSpawning");
static_assert(offsetof(HWBotFactory_DeactivateSpawning, bKillExistingBots) == 0x000000, "Member 'HWBotFactory_DeactivateSpawning::bKillExistingBots' has a wrong offset!");

// Function Hemingway.HWBotFactory.DespawnGodBot
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_DespawnGodBot final
{
public:
	bool                                          bAllowRespawn;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_DespawnGodBot) == 0x000001, "Wrong alignment on HWBotFactory_DespawnGodBot");
static_assert(sizeof(HWBotFactory_DespawnGodBot) == 0x000001, "Wrong size on HWBotFactory_DespawnGodBot");
static_assert(offsetof(HWBotFactory_DespawnGodBot, bAllowRespawn) == 0x000000, "Member 'HWBotFactory_DespawnGodBot::bAllowRespawn' has a wrong offset!");

// Function Hemingway.HWBotFactory.DetermineNextSpawnPoint
// 0x0028 (0x0028 - 0x0000)
struct HWBotFactory_DetermineNextSpawnPoint final
{
public:
	TSoftObjectPtr<class AActor>                  ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_DetermineNextSpawnPoint) == 0x000008, "Wrong alignment on HWBotFactory_DetermineNextSpawnPoint");
static_assert(sizeof(HWBotFactory_DetermineNextSpawnPoint) == 0x000028, "Wrong size on HWBotFactory_DetermineNextSpawnPoint");
static_assert(offsetof(HWBotFactory_DetermineNextSpawnPoint, ReturnValue) == 0x000000, "Member 'HWBotFactory_DetermineNextSpawnPoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetLocalTeamMinimapState
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_GetLocalTeamMinimapState final
{
public:
	EFactoryMinimapState                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetLocalTeamMinimapState) == 0x000001, "Wrong alignment on HWBotFactory_GetLocalTeamMinimapState");
static_assert(sizeof(HWBotFactory_GetLocalTeamMinimapState) == 0x000001, "Wrong size on HWBotFactory_GetLocalTeamMinimapState");
static_assert(offsetof(HWBotFactory_GetLocalTeamMinimapState, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetLocalTeamMinimapState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.InitializeSpawnedBotAI
// 0x00B8 (0x00B8 - 0x0000)
struct HWBotFactory_InitializeSpawnedBotAI final
{
public:
	class AHWCharacter_Base*                      characterSpawned;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAIBotConfig                         botConfig;                                         // 0x0008(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_InitializeSpawnedBotAI) == 0x000008, "Wrong alignment on HWBotFactory_InitializeSpawnedBotAI");
static_assert(sizeof(HWBotFactory_InitializeSpawnedBotAI) == 0x0000B8, "Wrong size on HWBotFactory_InitializeSpawnedBotAI");
static_assert(offsetof(HWBotFactory_InitializeSpawnedBotAI, characterSpawned) == 0x000000, "Member 'HWBotFactory_InitializeSpawnedBotAI::characterSpawned' has a wrong offset!");
static_assert(offsetof(HWBotFactory_InitializeSpawnedBotAI, botConfig) == 0x000008, "Member 'HWBotFactory_InitializeSpawnedBotAI::botConfig' has a wrong offset!");

// Function Hemingway.HWBotFactory.OnBotFinishedDestroy
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_OnBotFinishedDestroy final
{
public:
	class AHWCharacter_Base*                      DestroyedBot;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_OnBotFinishedDestroy) == 0x000008, "Wrong alignment on HWBotFactory_OnBotFinishedDestroy");
static_assert(sizeof(HWBotFactory_OnBotFinishedDestroy) == 0x000008, "Wrong size on HWBotFactory_OnBotFinishedDestroy");
static_assert(offsetof(HWBotFactory_OnBotFinishedDestroy, DestroyedBot) == 0x000000, "Member 'HWBotFactory_OnBotFinishedDestroy::DestroyedBot' has a wrong offset!");

// Function Hemingway.HWBotFactory.OnFactoryEmptied
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_OnFactoryEmptied final
{
public:
	class AActor*                                 Causer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_OnFactoryEmptied) == 0x000008, "Wrong alignment on HWBotFactory_OnFactoryEmptied");
static_assert(sizeof(HWBotFactory_OnFactoryEmptied) == 0x000008, "Wrong size on HWBotFactory_OnFactoryEmptied");
static_assert(offsetof(HWBotFactory_OnFactoryEmptied, Causer) == 0x000000, "Member 'HWBotFactory_OnFactoryEmptied::Causer' has a wrong offset!");

// Function Hemingway.HWBotFactory.OnGamePhaseStarted
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_OnGamePhaseStarted final
{
public:
	struct FGameplayTag                           PhaseTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_OnGamePhaseStarted) == 0x000004, "Wrong alignment on HWBotFactory_OnGamePhaseStarted");
static_assert(sizeof(HWBotFactory_OnGamePhaseStarted) == 0x000008, "Wrong size on HWBotFactory_OnGamePhaseStarted");
static_assert(offsetof(HWBotFactory_OnGamePhaseStarted, PhaseTag) == 0x000000, "Member 'HWBotFactory_OnGamePhaseStarted::PhaseTag' has a wrong offset!");

// Function Hemingway.HWBotFactory.OnSpawnBotDied
// 0x0010 (0x0010 - 0x0000)
struct HWBotFactory_OnSpawnBotDied final
{
public:
	class AHWCharacter_Base*                      characterKilled;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_OnSpawnBotDied) == 0x000008, "Wrong alignment on HWBotFactory_OnSpawnBotDied");
static_assert(sizeof(HWBotFactory_OnSpawnBotDied) == 0x000010, "Wrong size on HWBotFactory_OnSpawnBotDied");
static_assert(offsetof(HWBotFactory_OnSpawnBotDied, characterKilled) == 0x000000, "Member 'HWBotFactory_OnSpawnBotDied::characterKilled' has a wrong offset!");
static_assert(offsetof(HWBotFactory_OnSpawnBotDied, Killer) == 0x000008, "Member 'HWBotFactory_OnSpawnBotDied::Killer' has a wrong offset!");

// Function Hemingway.HWBotFactory.OnSpawnedBot
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_OnSpawnedBot final
{
public:
	class AHWCharacter_Base*                      characterSpawned;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_OnSpawnedBot) == 0x000008, "Wrong alignment on HWBotFactory_OnSpawnedBot");
static_assert(sizeof(HWBotFactory_OnSpawnedBot) == 0x000008, "Wrong size on HWBotFactory_OnSpawnedBot");
static_assert(offsetof(HWBotFactory_OnSpawnedBot, characterSpawned) == 0x000000, "Member 'HWBotFactory_OnSpawnedBot::characterSpawned' has a wrong offset!");

// Function Hemingway.HWBotFactory.OnVisibilityCompMinimapStateChanged
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_OnVisibilityCompMinimapStateChanged final
{
public:
	class UHWBotFactory_VisibilityComponent*      Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_OnVisibilityCompMinimapStateChanged) == 0x000008, "Wrong alignment on HWBotFactory_OnVisibilityCompMinimapStateChanged");
static_assert(sizeof(HWBotFactory_OnVisibilityCompMinimapStateChanged) == 0x000008, "Wrong size on HWBotFactory_OnVisibilityCompMinimapStateChanged");
static_assert(offsetof(HWBotFactory_OnVisibilityCompMinimapStateChanged, Comp) == 0x000000, "Member 'HWBotFactory_OnVisibilityCompMinimapStateChanged::Comp' has a wrong offset!");

// Function Hemingway.HWBotFactory.ResolveBotOutOfCombatLogic
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_ResolveBotOutOfCombatLogic final
{
public:
	class AHWCharacter_Base*                      Bot;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_ResolveBotOutOfCombatLogic) == 0x000008, "Wrong alignment on HWBotFactory_ResolveBotOutOfCombatLogic");
static_assert(sizeof(HWBotFactory_ResolveBotOutOfCombatLogic) == 0x000008, "Wrong size on HWBotFactory_ResolveBotOutOfCombatLogic");
static_assert(offsetof(HWBotFactory_ResolveBotOutOfCombatLogic, Bot) == 0x000000, "Member 'HWBotFactory_ResolveBotOutOfCombatLogic::Bot' has a wrong offset!");

// Function Hemingway.HWBotFactory.SetAllowGodBotRespawn
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_SetAllowGodBotRespawn final
{
public:
	bool                                          bAllow;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_SetAllowGodBotRespawn) == 0x000001, "Wrong alignment on HWBotFactory_SetAllowGodBotRespawn");
static_assert(sizeof(HWBotFactory_SetAllowGodBotRespawn) == 0x000001, "Wrong size on HWBotFactory_SetAllowGodBotRespawn");
static_assert(offsetof(HWBotFactory_SetAllowGodBotRespawn, bAllow) == 0x000000, "Member 'HWBotFactory_SetAllowGodBotRespawn::bAllow' has a wrong offset!");

// Function Hemingway.HWBotFactory.SetCurrentSpawnTable
// 0x000C (0x000C - 0x0000)
struct HWBotFactory_SetCurrentSpawnTable final
{
public:
	struct FGameplayTag                           SpawnTableTag;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwapAfterCurrentWaveEnds;                         // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWBotFactory_SetCurrentSpawnTable) == 0x000004, "Wrong alignment on HWBotFactory_SetCurrentSpawnTable");
static_assert(sizeof(HWBotFactory_SetCurrentSpawnTable) == 0x00000C, "Wrong size on HWBotFactory_SetCurrentSpawnTable");
static_assert(offsetof(HWBotFactory_SetCurrentSpawnTable, SpawnTableTag) == 0x000000, "Member 'HWBotFactory_SetCurrentSpawnTable::SpawnTableTag' has a wrong offset!");
static_assert(offsetof(HWBotFactory_SetCurrentSpawnTable, bSwapAfterCurrentWaveEnds) == 0x000008, "Member 'HWBotFactory_SetCurrentSpawnTable::bSwapAfterCurrentWaveEnds' has a wrong offset!");

// Function Hemingway.HWBotFactory.SetGodBotStart
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_SetGodBotStart final
{
public:
	class AActor*                                 BotStart;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_SetGodBotStart) == 0x000008, "Wrong alignment on HWBotFactory_SetGodBotStart");
static_assert(sizeof(HWBotFactory_SetGodBotStart) == 0x000008, "Wrong size on HWBotFactory_SetGodBotStart");
static_assert(offsetof(HWBotFactory_SetGodBotStart, BotStart) == 0x000000, "Member 'HWBotFactory_SetGodBotStart::BotStart' has a wrong offset!");

// Function Hemingway.HWBotFactory.SetLevelingActive
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_SetLevelingActive final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_SetLevelingActive) == 0x000001, "Wrong alignment on HWBotFactory_SetLevelingActive");
static_assert(sizeof(HWBotFactory_SetLevelingActive) == 0x000001, "Wrong size on HWBotFactory_SetLevelingActive");
static_assert(offsetof(HWBotFactory_SetLevelingActive, bActive) == 0x000000, "Member 'HWBotFactory_SetLevelingActive::bActive' has a wrong offset!");

// Function Hemingway.HWBotFactory.SetSpawnWaveindex
// 0x0004 (0x0004 - 0x0000)
struct HWBotFactory_SetSpawnWaveindex final
{
public:
	int32                                         newWaveIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_SetSpawnWaveindex) == 0x000004, "Wrong alignment on HWBotFactory_SetSpawnWaveindex");
static_assert(sizeof(HWBotFactory_SetSpawnWaveindex) == 0x000004, "Wrong size on HWBotFactory_SetSpawnWaveindex");
static_assert(offsetof(HWBotFactory_SetSpawnWaveindex, newWaveIndex) == 0x000000, "Member 'HWBotFactory_SetSpawnWaveindex::newWaveIndex' has a wrong offset!");

// Function Hemingway.HWBotFactory.SpawnBot
// 0x00E0 (0x00E0 - 0x0000)
struct HWBotFactory_SpawnBot final
{
public:
	struct FFactoryBotEntry                       BotEntryToSpawn;                                   // 0x0000(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FFactorySpawnEntry                     BotSpawnEntry;                                     // 0x00B8(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsRespawn;                                        // 0x00D0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x00D8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_SpawnBot) == 0x000008, "Wrong alignment on HWBotFactory_SpawnBot");
static_assert(sizeof(HWBotFactory_SpawnBot) == 0x0000E0, "Wrong size on HWBotFactory_SpawnBot");
static_assert(offsetof(HWBotFactory_SpawnBot, BotEntryToSpawn) == 0x000000, "Member 'HWBotFactory_SpawnBot::BotEntryToSpawn' has a wrong offset!");
static_assert(offsetof(HWBotFactory_SpawnBot, BotSpawnEntry) == 0x0000B8, "Member 'HWBotFactory_SpawnBot::BotSpawnEntry' has a wrong offset!");
static_assert(offsetof(HWBotFactory_SpawnBot, bIsRespawn) == 0x0000D0, "Member 'HWBotFactory_SpawnBot::bIsRespawn' has a wrong offset!");
static_assert(offsetof(HWBotFactory_SpawnBot, ReturnValue) == 0x0000D8, "Member 'HWBotFactory_SpawnBot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.SpawnGodBot
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_SpawnGodBot final
{
public:
	bool                                          bIsRespawn;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_SpawnGodBot) == 0x000001, "Wrong alignment on HWBotFactory_SpawnGodBot");
static_assert(sizeof(HWBotFactory_SpawnGodBot) == 0x000001, "Wrong size on HWBotFactory_SpawnGodBot");
static_assert(offsetof(HWBotFactory_SpawnGodBot, bIsRespawn) == 0x000000, "Member 'HWBotFactory_SpawnGodBot::bIsRespawn' has a wrong offset!");

// Function Hemingway.HWBotFactory.SpawnGodBotSpecific
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_SpawnGodBotSpecific final
{
public:
	const class UHWCharacterItem*                 Item;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_SpawnGodBotSpecific) == 0x000008, "Wrong alignment on HWBotFactory_SpawnGodBotSpecific");
static_assert(sizeof(HWBotFactory_SpawnGodBotSpecific) == 0x000008, "Wrong size on HWBotFactory_SpawnGodBotSpecific");
static_assert(offsetof(HWBotFactory_SpawnGodBotSpecific, Item) == 0x000000, "Member 'HWBotFactory_SpawnGodBotSpecific::Item' has a wrong offset!");

// Function Hemingway.HWBotFactory.ToggleOneWaveMode
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_ToggleOneWaveMode final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_ToggleOneWaveMode) == 0x000001, "Wrong alignment on HWBotFactory_ToggleOneWaveMode");
static_assert(sizeof(HWBotFactory_ToggleOneWaveMode) == 0x000001, "Wrong size on HWBotFactory_ToggleOneWaveMode");
static_assert(offsetof(HWBotFactory_ToggleOneWaveMode, bOn) == 0x000000, "Member 'HWBotFactory_ToggleOneWaveMode::bOn' has a wrong offset!");

// Function Hemingway.HWBotFactory.TriggerFactoryRewards
// 0x0010 (0x0010 - 0x0000)
struct HWBotFactory_TriggerFactoryRewards final
{
public:
	EFactoryRewardTrigger                         ETriggerType;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_TriggerFactoryRewards) == 0x000008, "Wrong alignment on HWBotFactory_TriggerFactoryRewards");
static_assert(sizeof(HWBotFactory_TriggerFactoryRewards) == 0x000010, "Wrong size on HWBotFactory_TriggerFactoryRewards");
static_assert(offsetof(HWBotFactory_TriggerFactoryRewards, ETriggerType) == 0x000000, "Member 'HWBotFactory_TriggerFactoryRewards::ETriggerType' has a wrong offset!");
static_assert(offsetof(HWBotFactory_TriggerFactoryRewards, Killer) == 0x000008, "Member 'HWBotFactory_TriggerFactoryRewards::Killer' has a wrong offset!");

// Function Hemingway.HWBotFactory.AreAnyBotsAlive
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_AreAnyBotsAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_AreAnyBotsAlive) == 0x000001, "Wrong alignment on HWBotFactory_AreAnyBotsAlive");
static_assert(sizeof(HWBotFactory_AreAnyBotsAlive) == 0x000001, "Wrong size on HWBotFactory_AreAnyBotsAlive");
static_assert(offsetof(HWBotFactory_AreAnyBotsAlive, ReturnValue) == 0x000000, "Member 'HWBotFactory_AreAnyBotsAlive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetAssetTags
// 0x0020 (0x0020 - 0x0000)
struct HWBotFactory_GetAssetTags final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetAssetTags) == 0x000008, "Wrong alignment on HWBotFactory_GetAssetTags");
static_assert(sizeof(HWBotFactory_GetAssetTags) == 0x000020, "Wrong size on HWBotFactory_GetAssetTags");
static_assert(offsetof(HWBotFactory_GetAssetTags, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetAssetTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetCurrentSpawnPoint
// 0x0028 (0x0028 - 0x0000)
struct HWBotFactory_GetCurrentSpawnPoint final
{
public:
	TSoftObjectPtr<class AActor>                  ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetCurrentSpawnPoint) == 0x000008, "Wrong alignment on HWBotFactory_GetCurrentSpawnPoint");
static_assert(sizeof(HWBotFactory_GetCurrentSpawnPoint) == 0x000028, "Wrong size on HWBotFactory_GetCurrentSpawnPoint");
static_assert(offsetof(HWBotFactory_GetCurrentSpawnPoint, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetCurrentSpawnPoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetCurrentSpawnWaveIndex
// 0x0004 (0x0004 - 0x0000)
struct HWBotFactory_GetCurrentSpawnWaveIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetCurrentSpawnWaveIndex) == 0x000004, "Wrong alignment on HWBotFactory_GetCurrentSpawnWaveIndex");
static_assert(sizeof(HWBotFactory_GetCurrentSpawnWaveIndex) == 0x000004, "Wrong size on HWBotFactory_GetCurrentSpawnWaveIndex");
static_assert(offsetof(HWBotFactory_GetCurrentSpawnWaveIndex, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetCurrentSpawnWaveIndex::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetIdentifyingWaypoint
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_GetIdentifyingWaypoint final
{
public:
	class AHWWaypoint*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetIdentifyingWaypoint) == 0x000008, "Wrong alignment on HWBotFactory_GetIdentifyingWaypoint");
static_assert(sizeof(HWBotFactory_GetIdentifyingWaypoint) == 0x000008, "Wrong size on HWBotFactory_GetIdentifyingWaypoint");
static_assert(offsetof(HWBotFactory_GetIdentifyingWaypoint, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetIdentifyingWaypoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetLeashOrDetectionRadius
// 0x0004 (0x0004 - 0x0000)
struct HWBotFactory_GetLeashOrDetectionRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetLeashOrDetectionRadius) == 0x000004, "Wrong alignment on HWBotFactory_GetLeashOrDetectionRadius");
static_assert(sizeof(HWBotFactory_GetLeashOrDetectionRadius) == 0x000004, "Wrong size on HWBotFactory_GetLeashOrDetectionRadius");
static_assert(offsetof(HWBotFactory_GetLeashOrDetectionRadius, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetLeashOrDetectionRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetLocalTeamCanSeeRespawnTimer
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_GetLocalTeamCanSeeRespawnTimer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetLocalTeamCanSeeRespawnTimer) == 0x000001, "Wrong alignment on HWBotFactory_GetLocalTeamCanSeeRespawnTimer");
static_assert(sizeof(HWBotFactory_GetLocalTeamCanSeeRespawnTimer) == 0x000001, "Wrong size on HWBotFactory_GetLocalTeamCanSeeRespawnTimer");
static_assert(offsetof(HWBotFactory_GetLocalTeamCanSeeRespawnTimer, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetLocalTeamCanSeeRespawnTimer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetNumBotsPastPastDistanceInLane
// 0x0008 (0x0008 - 0x0000)
struct HWBotFactory_GetNumBotsPastPastDistanceInLane final
{
public:
	float                                         LaneDistancePercentage;                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetNumBotsPastPastDistanceInLane) == 0x000004, "Wrong alignment on HWBotFactory_GetNumBotsPastPastDistanceInLane");
static_assert(sizeof(HWBotFactory_GetNumBotsPastPastDistanceInLane) == 0x000008, "Wrong size on HWBotFactory_GetNumBotsPastPastDistanceInLane");
static_assert(offsetof(HWBotFactory_GetNumBotsPastPastDistanceInLane, LaneDistancePercentage) == 0x000000, "Member 'HWBotFactory_GetNumBotsPastPastDistanceInLane::LaneDistancePercentage' has a wrong offset!");
static_assert(offsetof(HWBotFactory_GetNumBotsPastPastDistanceInLane, ReturnValue) == 0x000004, "Member 'HWBotFactory_GetNumBotsPastPastDistanceInLane::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetNumOfSpawnWaves
// 0x0004 (0x0004 - 0x0000)
struct HWBotFactory_GetNumOfSpawnWaves final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetNumOfSpawnWaves) == 0x000004, "Wrong alignment on HWBotFactory_GetNumOfSpawnWaves");
static_assert(sizeof(HWBotFactory_GetNumOfSpawnWaves) == 0x000004, "Wrong size on HWBotFactory_GetNumOfSpawnWaves");
static_assert(offsetof(HWBotFactory_GetNumOfSpawnWaves, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetNumOfSpawnWaves::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetPathDirection
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_GetPathDirection final
{
public:
	EWaypointPathDirectionType                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetPathDirection) == 0x000001, "Wrong alignment on HWBotFactory_GetPathDirection");
static_assert(sizeof(HWBotFactory_GetPathDirection) == 0x000001, "Wrong size on HWBotFactory_GetPathDirection");
static_assert(offsetof(HWBotFactory_GetPathDirection, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetPathDirection::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetRemainingWaveRespawnTime
// 0x0004 (0x0004 - 0x0000)
struct HWBotFactory_GetRemainingWaveRespawnTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetRemainingWaveRespawnTime) == 0x000004, "Wrong alignment on HWBotFactory_GetRemainingWaveRespawnTime");
static_assert(sizeof(HWBotFactory_GetRemainingWaveRespawnTime) == 0x000004, "Wrong size on HWBotFactory_GetRemainingWaveRespawnTime");
static_assert(offsetof(HWBotFactory_GetRemainingWaveRespawnTime, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetRemainingWaveRespawnTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetSpawningTeamNum
// 0x0004 (0x0004 - 0x0000)
struct HWBotFactory_GetSpawningTeamNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetSpawningTeamNum) == 0x000004, "Wrong alignment on HWBotFactory_GetSpawningTeamNum");
static_assert(sizeof(HWBotFactory_GetSpawningTeamNum) == 0x000004, "Wrong size on HWBotFactory_GetSpawningTeamNum");
static_assert(offsetof(HWBotFactory_GetSpawningTeamNum, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetSpawningTeamNum::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.GetWaveRespawnTime
// 0x0004 (0x0004 - 0x0000)
struct HWBotFactory_GetWaveRespawnTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_GetWaveRespawnTime) == 0x000004, "Wrong alignment on HWBotFactory_GetWaveRespawnTime");
static_assert(sizeof(HWBotFactory_GetWaveRespawnTime) == 0x000004, "Wrong size on HWBotFactory_GetWaveRespawnTime");
static_assert(offsetof(HWBotFactory_GetWaveRespawnTime, ReturnValue) == 0x000000, "Member 'HWBotFactory_GetWaveRespawnTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.HasActiveBots
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_HasActiveBots final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_HasActiveBots) == 0x000001, "Wrong alignment on HWBotFactory_HasActiveBots");
static_assert(sizeof(HWBotFactory_HasActiveBots) == 0x000001, "Wrong size on HWBotFactory_HasActiveBots");
static_assert(offsetof(HWBotFactory_HasActiveBots, ReturnValue) == 0x000000, "Member 'HWBotFactory_HasActiveBots::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.IsActivelySpawning
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_IsActivelySpawning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_IsActivelySpawning) == 0x000001, "Wrong alignment on HWBotFactory_IsActivelySpawning");
static_assert(sizeof(HWBotFactory_IsActivelySpawning) == 0x000001, "Wrong size on HWBotFactory_IsActivelySpawning");
static_assert(offsetof(HWBotFactory_IsActivelySpawning, ReturnValue) == 0x000000, "Member 'HWBotFactory_IsActivelySpawning::ReturnValue' has a wrong offset!");

// Function Hemingway.HWBotFactory.IsAGodBotFactory
// 0x0001 (0x0001 - 0x0000)
struct HWBotFactory_IsAGodBotFactory final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWBotFactory_IsAGodBotFactory) == 0x000001, "Wrong alignment on HWBotFactory_IsAGodBotFactory");
static_assert(sizeof(HWBotFactory_IsAGodBotFactory) == 0x000001, "Wrong size on HWBotFactory_IsAGodBotFactory");
static_assert(offsetof(HWBotFactory_IsAGodBotFactory, ReturnValue) == 0x000000, "Member 'HWBotFactory_IsAGodBotFactory::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentItem.GetAnnounceAcquisitionTag
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentItem_GetAnnounceAcquisitionTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentItem_GetAnnounceAcquisitionTag) == 0x000004, "Wrong alignment on HWEquipmentItem_GetAnnounceAcquisitionTag");
static_assert(sizeof(HWEquipmentItem_GetAnnounceAcquisitionTag) == 0x000008, "Wrong size on HWEquipmentItem_GetAnnounceAcquisitionTag");
static_assert(offsetof(HWEquipmentItem_GetAnnounceAcquisitionTag, ReturnValue) == 0x000000, "Member 'HWEquipmentItem_GetAnnounceAcquisitionTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentItem.GetBaseCurrencyValue
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentItem_GetBaseCurrencyValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentItem_GetBaseCurrencyValue) == 0x000004, "Wrong alignment on HWEquipmentItem_GetBaseCurrencyValue");
static_assert(sizeof(HWEquipmentItem_GetBaseCurrencyValue) == 0x000004, "Wrong size on HWEquipmentItem_GetBaseCurrencyValue");
static_assert(offsetof(HWEquipmentItem_GetBaseCurrencyValue, ReturnValue) == 0x000000, "Member 'HWEquipmentItem_GetBaseCurrencyValue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentItem.ShouldCommitTransaction
// 0x0002 (0x0002 - 0x0000)
struct HWEquipmentItem_ShouldCommitTransaction final
{
public:
	EItemTransactionRule                          ItemTransactionRule;                               // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentItem_ShouldCommitTransaction) == 0x000001, "Wrong alignment on HWEquipmentItem_ShouldCommitTransaction");
static_assert(sizeof(HWEquipmentItem_ShouldCommitTransaction) == 0x000002, "Wrong size on HWEquipmentItem_ShouldCommitTransaction");
static_assert(offsetof(HWEquipmentItem_ShouldCommitTransaction, ItemTransactionRule) == 0x000000, "Member 'HWEquipmentItem_ShouldCommitTransaction::ItemTransactionRule' has a wrong offset!");
static_assert(offsetof(HWEquipmentItem_ShouldCommitTransaction, ReturnValue) == 0x000001, "Member 'HWEquipmentItem_ShouldCommitTransaction::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSetting_Custom.BP_CalcAim
// 0x00B0 (0x00B0 - 0x0000)
struct HWAbilityAimSetting_Custom_BP_CalcAim final
{
public:
	struct FHWAimTargetingInfo                    AimTargetingInfo;                                  // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetingAimHandle;                                // 0x0080(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityAimSetting_Custom_BP_CalcAim) == 0x000010, "Wrong alignment on HWAbilityAimSetting_Custom_BP_CalcAim");
static_assert(sizeof(HWAbilityAimSetting_Custom_BP_CalcAim) == 0x0000B0, "Wrong size on HWAbilityAimSetting_Custom_BP_CalcAim");
static_assert(offsetof(HWAbilityAimSetting_Custom_BP_CalcAim, AimTargetingInfo) == 0x000000, "Member 'HWAbilityAimSetting_Custom_BP_CalcAim::AimTargetingInfo' has a wrong offset!");
static_assert(offsetof(HWAbilityAimSetting_Custom_BP_CalcAim, TargetingAimHandle) == 0x000080, "Member 'HWAbilityAimSetting_Custom_BP_CalcAim::TargetingAimHandle' has a wrong offset!");

// Function Hemingway.HWAbilityAimSetting_Custom.BP_GetAimDirectionOffset
// 0x0030 (0x0030 - 0x0000)
struct HWAbilityAimSetting_Custom_BP_GetAimDirectionOffset final
{
public:
	struct FRotator                               OriginalOffset;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSetting_Custom_BP_GetAimDirectionOffset) == 0x000008, "Wrong alignment on HWAbilityAimSetting_Custom_BP_GetAimDirectionOffset");
static_assert(sizeof(HWAbilityAimSetting_Custom_BP_GetAimDirectionOffset) == 0x000030, "Wrong size on HWAbilityAimSetting_Custom_BP_GetAimDirectionOffset");
static_assert(offsetof(HWAbilityAimSetting_Custom_BP_GetAimDirectionOffset, OriginalOffset) == 0x000000, "Member 'HWAbilityAimSetting_Custom_BP_GetAimDirectionOffset::OriginalOffset' has a wrong offset!");
static_assert(offsetof(HWAbilityAimSetting_Custom_BP_GetAimDirectionOffset, ReturnValue) == 0x000018, "Member 'HWAbilityAimSetting_Custom_BP_GetAimDirectionOffset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSetting_Custom.BP_GetPositionOffset
// 0x0030 (0x0030 - 0x0000)
struct HWAbilityAimSetting_Custom_BP_GetPositionOffset final
{
public:
	struct FVector                                OriginalOffset;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSetting_Custom_BP_GetPositionOffset) == 0x000008, "Wrong alignment on HWAbilityAimSetting_Custom_BP_GetPositionOffset");
static_assert(sizeof(HWAbilityAimSetting_Custom_BP_GetPositionOffset) == 0x000030, "Wrong size on HWAbilityAimSetting_Custom_BP_GetPositionOffset");
static_assert(offsetof(HWAbilityAimSetting_Custom_BP_GetPositionOffset, OriginalOffset) == 0x000000, "Member 'HWAbilityAimSetting_Custom_BP_GetPositionOffset::OriginalOffset' has a wrong offset!");
static_assert(offsetof(HWAbilityAimSetting_Custom_BP_GetPositionOffset, ReturnValue) == 0x000018, "Member 'HWAbilityAimSetting_Custom_BP_GetPositionOffset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAimSetting_Custom.GetCustomAimSetting
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityAimSetting_Custom_GetCustomAimSetting final
{
public:
	struct FGameplayTag                           AimSettingId;                                      // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAimSettings*            ReturnValue;                                       // 0x0008(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAimSetting_Custom_GetCustomAimSetting) == 0x000008, "Wrong alignment on HWAbilityAimSetting_Custom_GetCustomAimSetting");
static_assert(sizeof(HWAbilityAimSetting_Custom_GetCustomAimSetting) == 0x000010, "Wrong size on HWAbilityAimSetting_Custom_GetCustomAimSetting");
static_assert(offsetof(HWAbilityAimSetting_Custom_GetCustomAimSetting, AimSettingId) == 0x000000, "Member 'HWAbilityAimSetting_Custom_GetCustomAimSetting::AimSettingId' has a wrong offset!");
static_assert(offsetof(HWAbilityAimSetting_Custom_GetCustomAimSetting, ReturnValue) == 0x000008, "Member 'HWAbilityAimSetting_Custom_GetCustomAimSetting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_SpawnDeployable.SpawnDeployableTask
// 0x0090 (0x0090 - 0x0000)
struct HWAbilityTask_SpawnDeployable_SpawnDeployableTask final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHWDeployable>              DeployableClass;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0020(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustToGround;                                   // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_SpawnDeployable*         ReturnValue;                                       // 0x0088(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_SpawnDeployable_SpawnDeployableTask) == 0x000010, "Wrong alignment on HWAbilityTask_SpawnDeployable_SpawnDeployableTask");
static_assert(sizeof(HWAbilityTask_SpawnDeployable_SpawnDeployableTask) == 0x000090, "Wrong size on HWAbilityTask_SpawnDeployable_SpawnDeployableTask");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTask, OwningAbility) == 0x000000, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTask::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTask, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTask::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTask, DeployableClass) == 0x000010, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTask::DeployableClass' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTask, SpawnTransform) == 0x000020, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTask::SpawnTransform' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTask, bAdjustToGround) == 0x000080, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTask::bAdjustToGround' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTask, ReturnValue) == 0x000088, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTask::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_SpawnDeployable.SpawnDeployableTaskUsingAimData
// 0x0070 (0x0070 - 0x0000)
struct HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHWDeployable>              DeployableClass;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetAimData;                                     // 0x0018(0x0028)(Parm, NativeAccessSpecifierPublic)
	bool                                          bAdjustToGround;                                   // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAimOriginForSpawn;                             // 0x0041(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocationOffset;                               // 0x0048(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateImmediateTickOnPhaseTimers;               // 0x0060(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_SpawnDeployable*         ReturnValue;                                       // 0x0068(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData) == 0x000008, "Wrong alignment on HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData");
static_assert(sizeof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData) == 0x000070, "Wrong size on HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData, OwningAbility) == 0x000000, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData, DeployableClass) == 0x000010, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData::DeployableClass' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData, TargetAimData) == 0x000018, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData::TargetAimData' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData, bAdjustToGround) == 0x000040, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData::bAdjustToGround' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData, bUseAimOriginForSpawn) == 0x000041, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData::bUseAimOriginForSpawn' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData, SpawnLocationOffset) == 0x000048, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData::SpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData, bSimulateImmediateTickOnPhaseTimers) == 0x000060, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData::bSimulateImmediateTickOnPhaseTimers' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData, ReturnValue) == 0x000068, "Member 'HWAbilityTask_SpawnDeployable_SpawnDeployableTaskUsingAimData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentItem_AbilityTooltipData.GetNamedValueOptions
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentItem_AbilityTooltipData_GetNamedValueOptions final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentItem_AbilityTooltipData_GetNamedValueOptions) == 0x000008, "Wrong alignment on HWEquipmentItem_AbilityTooltipData_GetNamedValueOptions");
static_assert(sizeof(HWEquipmentItem_AbilityTooltipData_GetNamedValueOptions) == 0x000010, "Wrong size on HWEquipmentItem_AbilityTooltipData_GetNamedValueOptions");
static_assert(offsetof(HWEquipmentItem_AbilityTooltipData_GetNamedValueOptions, ReturnValue) == 0x000000, "Member 'HWEquipmentItem_AbilityTooltipData_GetNamedValueOptions::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_InstantShape.GetPriorityFilters
// 0x0018 (0x0018 - 0x0000)
struct HWAbilityAttackSettings_InstantShape_GetPriorityFilters final
{
public:
	class AActor*                                 Avatar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTargetDataFilterHandle> ReturnValue;                                      // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_InstantShape_GetPriorityFilters) == 0x000008, "Wrong alignment on HWAbilityAttackSettings_InstantShape_GetPriorityFilters");
static_assert(sizeof(HWAbilityAttackSettings_InstantShape_GetPriorityFilters) == 0x000018, "Wrong size on HWAbilityAttackSettings_InstantShape_GetPriorityFilters");
static_assert(offsetof(HWAbilityAttackSettings_InstantShape_GetPriorityFilters, Avatar) == 0x000000, "Member 'HWAbilityAttackSettings_InstantShape_GetPriorityFilters::Avatar' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_InstantShape_GetPriorityFilters, ReturnValue) == 0x000008, "Member 'HWAbilityAttackSettings_InstantShape_GetPriorityFilters::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_Projectile.GetAllyAcceptableTargetFilter
// 0x0020 (0x0020 - 0x0000)
struct HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter final
{
public:
	class AActor*                                 Avatar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPredicting;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTargetDataFilterHandle        ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter) == 0x000008, "Wrong alignment on HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter");
static_assert(sizeof(HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter) == 0x000020, "Wrong size on HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter");
static_assert(offsetof(HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter, Avatar) == 0x000000, "Member 'HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter::Avatar' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter, bIsPredicting) == 0x000008, "Member 'HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter::bIsPredicting' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter, ReturnValue) == 0x000010, "Member 'HWAbilityAttackSettings_Projectile_GetAllyAcceptableTargetFilter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_Projectile.GetDestroyProjectileOnAllyTargetFilter
// 0x0020 (0x0020 - 0x0000)
struct HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter final
{
public:
	class AActor*                                 Avatar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPredicting;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTargetDataFilterHandle        ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter) == 0x000008, "Wrong alignment on HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter");
static_assert(sizeof(HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter) == 0x000020, "Wrong size on HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter");
static_assert(offsetof(HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter, Avatar) == 0x000000, "Member 'HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter::Avatar' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter, bIsPredicting) == 0x000008, "Member 'HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter::bIsPredicting' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter, ReturnValue) == 0x000010, "Member 'HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnAllyTargetFilter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_Projectile.GetDestroyProjectileOnTargetFilter
// 0x0020 (0x0020 - 0x0000)
struct HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter final
{
public:
	class AActor*                                 Avatar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPredicting;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTargetDataFilterHandle        ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter) == 0x000008, "Wrong alignment on HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter");
static_assert(sizeof(HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter) == 0x000020, "Wrong size on HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter");
static_assert(offsetof(HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter, Avatar) == 0x000000, "Member 'HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter::Avatar' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter, bIsPredicting) == 0x000008, "Member 'HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter::bIsPredicting' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter, ReturnValue) == 0x000010, "Member 'HWAbilityAttackSettings_Projectile_GetDestroyProjectileOnTargetFilter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.EqualEqual_FHWEventCharacter
// 0x007C (0x007C - 0x0000)
struct HWLibrary_EventSystem_EqualEqual_FHWEventCharacter final
{
public:
	struct FHWEventCharacter                      A;                                                 // 0x0000(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FHWEventCharacter                      B;                                                 // 0x003C(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EventSystem_EqualEqual_FHWEventCharacter) == 0x000004, "Wrong alignment on HWLibrary_EventSystem_EqualEqual_FHWEventCharacter");
static_assert(sizeof(HWLibrary_EventSystem_EqualEqual_FHWEventCharacter) == 0x00007C, "Wrong size on HWLibrary_EventSystem_EqualEqual_FHWEventCharacter");
static_assert(offsetof(HWLibrary_EventSystem_EqualEqual_FHWEventCharacter, A) == 0x000000, "Member 'HWLibrary_EventSystem_EqualEqual_FHWEventCharacter::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_EqualEqual_FHWEventCharacter, B) == 0x00003C, "Member 'HWLibrary_EventSystem_EqualEqual_FHWEventCharacter::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_EqualEqual_FHWEventCharacter, ReturnValue) == 0x000078, "Member 'HWLibrary_EventSystem_EqualEqual_FHWEventCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.GetCharacterItemFromEventCharacterData
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventCharacter                      EventCharacter;                                    // 0x0008(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FPrimaryAssetId& PrimaryAssetId, const class UHWCharacterItem* CharacterItem)> Delegate; // 0x0044(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData) == 0x000008, "Wrong alignment on HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData");
static_assert(sizeof(HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData) == 0x000058, "Wrong size on HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData");
static_assert(offsetof(HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData, WorldContextObject) == 0x000000, "Member 'HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData, EventCharacter) == 0x000008, "Member 'HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData::EventCharacter' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData, Delegate) == 0x000044, "Member 'HWLibrary_EventSystem_GetCharacterItemFromEventCharacterData::Delegate' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.GetDisplayNameFromEventCharacterData
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventCharacter                      EventCharacter;                                    // 0x0008(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FHWEventCharacter& EventCharacter, const class FText& DisplayName, const class UHWCharacterItem* CharacterItem)> Delegate; // 0x0044(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData) == 0x000008, "Wrong alignment on HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData");
static_assert(sizeof(HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData) == 0x000058, "Wrong size on HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData");
static_assert(offsetof(HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData, WorldContextObject) == 0x000000, "Member 'HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData, EventCharacter) == 0x000008, "Member 'HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData::EventCharacter' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData, Delegate) == 0x000044, "Member 'HWLibrary_EventSystem_GetDisplayNameFromEventCharacterData::Delegate' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.GetLocalAttitudeTowardsEventCharacter
// 0x0048 (0x0048 - 0x0000)
struct HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventCharacter                      EventCharacter;                                    // 0x0008(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	ETeamAttitude                                 ReturnValue;                                       // 0x0044(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter) == 0x000008, "Wrong alignment on HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter");
static_assert(sizeof(HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter) == 0x000048, "Wrong size on HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter");
static_assert(offsetof(HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter, WorldContextObject) == 0x000000, "Member 'HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter, EventCharacter) == 0x000008, "Member 'HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter::EventCharacter' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter, ReturnValue) == 0x000044, "Member 'HWLibrary_EventSystem_GetLocalAttitudeTowardsEventCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.GetNameColorFromEventCharacterData
// 0x0058 (0x0058 - 0x0000)
struct HWLibrary_EventSystem_GetNameColorFromEventCharacterData final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventCharacter                      EventCharacter;                                    // 0x0008(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FHWEventCharacter& EventCharacter, const class UHWCollectionItem* NameColorItem)> Delegate; // 0x0044(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EventSystem_GetNameColorFromEventCharacterData) == 0x000008, "Wrong alignment on HWLibrary_EventSystem_GetNameColorFromEventCharacterData");
static_assert(sizeof(HWLibrary_EventSystem_GetNameColorFromEventCharacterData) == 0x000058, "Wrong size on HWLibrary_EventSystem_GetNameColorFromEventCharacterData");
static_assert(offsetof(HWLibrary_EventSystem_GetNameColorFromEventCharacterData, WorldContextObject) == 0x000000, "Member 'HWLibrary_EventSystem_GetNameColorFromEventCharacterData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_GetNameColorFromEventCharacterData, EventCharacter) == 0x000008, "Member 'HWLibrary_EventSystem_GetNameColorFromEventCharacterData::EventCharacter' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_GetNameColorFromEventCharacterData, Delegate) == 0x000044, "Member 'HWLibrary_EventSystem_GetNameColorFromEventCharacterData::Delegate' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.IsEventCharacterAnNPC
// 0x0040 (0x0040 - 0x0000)
struct HWLibrary_EventSystem_IsEventCharacterAnNPC final
{
public:
	struct FHWEventCharacter                      EventCharacter;                                    // 0x0000(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EventSystem_IsEventCharacterAnNPC) == 0x000004, "Wrong alignment on HWLibrary_EventSystem_IsEventCharacterAnNPC");
static_assert(sizeof(HWLibrary_EventSystem_IsEventCharacterAnNPC) == 0x000040, "Wrong size on HWLibrary_EventSystem_IsEventCharacterAnNPC");
static_assert(offsetof(HWLibrary_EventSystem_IsEventCharacterAnNPC, EventCharacter) == 0x000000, "Member 'HWLibrary_EventSystem_IsEventCharacterAnNPC::EventCharacter' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_IsEventCharacterAnNPC, ReturnValue) == 0x00003C, "Member 'HWLibrary_EventSystem_IsEventCharacterAnNPC::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.IsEventCharacterLocalPlayer
// 0x0048 (0x0048 - 0x0000)
struct HWLibrary_EventSystem_IsEventCharacterLocalPlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventCharacter                      EventCharacter;                                    // 0x0008(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0044(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EventSystem_IsEventCharacterLocalPlayer) == 0x000008, "Wrong alignment on HWLibrary_EventSystem_IsEventCharacterLocalPlayer");
static_assert(sizeof(HWLibrary_EventSystem_IsEventCharacterLocalPlayer) == 0x000048, "Wrong size on HWLibrary_EventSystem_IsEventCharacterLocalPlayer");
static_assert(offsetof(HWLibrary_EventSystem_IsEventCharacterLocalPlayer, WorldContextObject) == 0x000000, "Member 'HWLibrary_EventSystem_IsEventCharacterLocalPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_IsEventCharacterLocalPlayer, EventCharacter) == 0x000008, "Member 'HWLibrary_EventSystem_IsEventCharacterLocalPlayer::EventCharacter' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_IsEventCharacterLocalPlayer, ReturnValue) == 0x000044, "Member 'HWLibrary_EventSystem_IsEventCharacterLocalPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.LocalPlayerMatchesEventCharacterOrIsSpectator
// 0x0048 (0x0048 - 0x0000)
struct HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventCharacter                      EventCharacter;                                    // 0x0008(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0044(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator) == 0x000008, "Wrong alignment on HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator");
static_assert(sizeof(HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator) == 0x000048, "Wrong size on HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator");
static_assert(offsetof(HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator, WorldContextObject) == 0x000000, "Member 'HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator, EventCharacter) == 0x000008, "Member 'HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator::EventCharacter' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator, ReturnValue) == 0x000044, "Member 'HWLibrary_EventSystem_LocalPlayerMatchesEventCharacterOrIsSpectator::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.NotEqual_FHWEventCharacter
// 0x007C (0x007C - 0x0000)
struct HWLibrary_EventSystem_NotEqual_FHWEventCharacter final
{
public:
	struct FHWEventCharacter                      A;                                                 // 0x0000(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FHWEventCharacter                      B;                                                 // 0x003C(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EventSystem_NotEqual_FHWEventCharacter) == 0x000004, "Wrong alignment on HWLibrary_EventSystem_NotEqual_FHWEventCharacter");
static_assert(sizeof(HWLibrary_EventSystem_NotEqual_FHWEventCharacter) == 0x00007C, "Wrong size on HWLibrary_EventSystem_NotEqual_FHWEventCharacter");
static_assert(offsetof(HWLibrary_EventSystem_NotEqual_FHWEventCharacter, A) == 0x000000, "Member 'HWLibrary_EventSystem_NotEqual_FHWEventCharacter::A' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_NotEqual_FHWEventCharacter, B) == 0x00003C, "Member 'HWLibrary_EventSystem_NotEqual_FHWEventCharacter::B' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_NotEqual_FHWEventCharacter, ReturnValue) == 0x000078, "Member 'HWLibrary_EventSystem_NotEqual_FHWEventCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.PlaySoftSoundOnAccoladeAudioComponent
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_EventSystem_PlaySoftSoundOnAccoladeAudioComponent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMetaSoundSource>        SoundToPlay;                                       // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_EventSystem_PlaySoftSoundOnAccoladeAudioComponent) == 0x000008, "Wrong alignment on HWLibrary_EventSystem_PlaySoftSoundOnAccoladeAudioComponent");
static_assert(sizeof(HWLibrary_EventSystem_PlaySoftSoundOnAccoladeAudioComponent) == 0x000030, "Wrong size on HWLibrary_EventSystem_PlaySoftSoundOnAccoladeAudioComponent");
static_assert(offsetof(HWLibrary_EventSystem_PlaySoftSoundOnAccoladeAudioComponent, WorldContextObject) == 0x000000, "Member 'HWLibrary_EventSystem_PlaySoftSoundOnAccoladeAudioComponent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_PlaySoftSoundOnAccoladeAudioComponent, SoundToPlay) == 0x000008, "Member 'HWLibrary_EventSystem_PlaySoftSoundOnAccoladeAudioComponent::SoundToPlay' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.PlaySoundOnAccoladeAudioComponent
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_EventSystem_PlaySoundOnAccoladeAudioComponent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMetaSoundSource*                       SoundToPlay;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_EventSystem_PlaySoundOnAccoladeAudioComponent) == 0x000008, "Wrong alignment on HWLibrary_EventSystem_PlaySoundOnAccoladeAudioComponent");
static_assert(sizeof(HWLibrary_EventSystem_PlaySoundOnAccoladeAudioComponent) == 0x000010, "Wrong size on HWLibrary_EventSystem_PlaySoundOnAccoladeAudioComponent");
static_assert(offsetof(HWLibrary_EventSystem_PlaySoundOnAccoladeAudioComponent, WorldContextObject) == 0x000000, "Member 'HWLibrary_EventSystem_PlaySoundOnAccoladeAudioComponent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_PlaySoundOnAccoladeAudioComponent, SoundToPlay) == 0x000008, "Member 'HWLibrary_EventSystem_PlaySoundOnAccoladeAudioComponent::SoundToPlay' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.ShouldUseGodNameInsteadOfPlayerName
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_EventSystem_ShouldUseGodNameInsteadOfPlayerName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_EventSystem_ShouldUseGodNameInsteadOfPlayerName) == 0x000008, "Wrong alignment on HWLibrary_EventSystem_ShouldUseGodNameInsteadOfPlayerName");
static_assert(sizeof(HWLibrary_EventSystem_ShouldUseGodNameInsteadOfPlayerName) == 0x000010, "Wrong size on HWLibrary_EventSystem_ShouldUseGodNameInsteadOfPlayerName");
static_assert(offsetof(HWLibrary_EventSystem_ShouldUseGodNameInsteadOfPlayerName, WorldContextObject) == 0x000000, "Member 'HWLibrary_EventSystem_ShouldUseGodNameInsteadOfPlayerName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_EventSystem_ShouldUseGodNameInsteadOfPlayerName, ReturnValue) == 0x000008, "Member 'HWLibrary_EventSystem_ShouldUseGodNameInsteadOfPlayerName::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_EventSystem.StopAccoladeAudioComponent
// 0x0008 (0x0008 - 0x0000)
struct HWLibrary_EventSystem_StopAccoladeAudioComponent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_EventSystem_StopAccoladeAudioComponent) == 0x000008, "Wrong alignment on HWLibrary_EventSystem_StopAccoladeAudioComponent");
static_assert(sizeof(HWLibrary_EventSystem_StopAccoladeAudioComponent) == 0x000008, "Wrong size on HWLibrary_EventSystem_StopAccoladeAudioComponent");
static_assert(offsetof(HWLibrary_EventSystem_StopAccoladeAudioComponent, WorldContextObject) == 0x000000, "Member 'HWLibrary_EventSystem_StopAccoladeAudioComponent::WorldContextObject' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitTargetData.HWWaitForTargetingData
// 0x0050 (0x0050 - 0x0000)
struct HWAbilityTask_WaitTargetData_HWWaitForTargetingData final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayTargetingConfirmation                ConfirmationType;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AHWTargeter>                InTargeterClass;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AttacksToTarget;                                   // 0x0020(0x0020)(Parm, NativeAccessSpecifierPublic)
	bool                                          bCancelOnConfirmFailure;                           // 0x0040(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableServerTargeting;                            // 0x0041(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitTargetData*          ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitTargetData_HWWaitForTargetingData) == 0x000008, "Wrong alignment on HWAbilityTask_WaitTargetData_HWWaitForTargetingData");
static_assert(sizeof(HWAbilityTask_WaitTargetData_HWWaitForTargetingData) == 0x000050, "Wrong size on HWAbilityTask_WaitTargetData_HWWaitForTargetingData");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingData, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingData::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingData, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingData::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingData, ConfirmationType) == 0x000010, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingData::ConfirmationType' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingData, InTargeterClass) == 0x000018, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingData::InTargeterClass' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingData, AttacksToTarget) == 0x000020, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingData::AttacksToTarget' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingData, bCancelOnConfirmFailure) == 0x000040, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingData::bCancelOnConfirmFailure' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingData, bEnableServerTargeting) == 0x000041, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingData::bEnableServerTargeting' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingData, ReturnValue) == 0x000048, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitTargetData.HWWaitForTargetingDataUsingActor
// 0x0050 (0x0050 - 0x0000)
struct HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayTargetingConfirmation                ConfirmationType;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWTargeter*                            InTargeter;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AttacksToTarget;                                   // 0x0020(0x0020)(Parm, NativeAccessSpecifierPublic)
	bool                                          bCancelOnConfirmFailure;                           // 0x0040(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyTargetActorOnTaskDestroy_0;                // 0x0041(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableServerTargeting;                            // 0x0042(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitTargetData*          ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor) == 0x000008, "Wrong alignment on HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor");
static_assert(sizeof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor) == 0x000050, "Wrong size on HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor, ConfirmationType) == 0x000010, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor::ConfirmationType' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor, InTargeter) == 0x000018, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor::InTargeter' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor, AttacksToTarget) == 0x000020, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor::AttacksToTarget' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor, bCancelOnConfirmFailure) == 0x000040, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor::bCancelOnConfirmFailure' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor, bDestroyTargetActorOnTaskDestroy_0) == 0x000041, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor::bDestroyTargetActorOnTaskDestroy_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor, bEnableServerTargeting) == 0x000042, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor::bEnableServerTargeting' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor, ReturnValue) == 0x000048, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitTargetData.HWWaitForTargetingDataUsingCastStyle
// 0x0048 (0x0048 - 0x0000)
struct HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTargeter*                            InTargeter;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AttacksToTarget;                                   // 0x0018(0x0020)(Parm, NativeAccessSpecifierPublic)
	EAbilityCastStyle                             DesiredCastStyle;                                  // 0x0038(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelOnConfirmFailure;                           // 0x0039(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyTargetActorOnTaskDestroy_0;                // 0x003A(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableServerTargeting;                            // 0x003B(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventAbilityInputFromConfirming_0;              // 0x003C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCleanUpTargeterOnTargetingCancelled_0;            // 0x003D(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitTargetData*          ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle) == 0x000008, "Wrong alignment on HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle");
static_assert(sizeof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle) == 0x000048, "Wrong size on HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, InTargeter) == 0x000010, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::InTargeter' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, AttacksToTarget) == 0x000018, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::AttacksToTarget' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, DesiredCastStyle) == 0x000038, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::DesiredCastStyle' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, bCancelOnConfirmFailure) == 0x000039, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::bCancelOnConfirmFailure' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, bDestroyTargetActorOnTaskDestroy_0) == 0x00003A, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::bDestroyTargetActorOnTaskDestroy_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, bEnableServerTargeting) == 0x00003B, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::bEnableServerTargeting' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, bPreventAbilityInputFromConfirming_0) == 0x00003C, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::bPreventAbilityInputFromConfirming_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, bCleanUpTargeterOnTargetingCancelled_0) == 0x00003D, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::bCleanUpTargeterOnTargetingCancelled_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle, ReturnValue) == 0x000040, "Member 'HWAbilityTask_WaitTargetData_HWWaitForTargetingDataUsingCastStyle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitTargetData.ForceConfirm
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityTask_WaitTargetData_ForceConfirm final
{
public:
	bool                                          EndTask_0;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitTargetData_ForceConfirm) == 0x000001, "Wrong alignment on HWAbilityTask_WaitTargetData_ForceConfirm");
static_assert(sizeof(HWAbilityTask_WaitTargetData_ForceConfirm) == 0x000001, "Wrong size on HWAbilityTask_WaitTargetData_ForceConfirm");
static_assert(offsetof(HWAbilityTask_WaitTargetData_ForceConfirm, EndTask_0) == 0x000000, "Member 'HWAbilityTask_WaitTargetData_ForceConfirm::EndTask_0' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitTargetData.OnCastStyleInputCancelled
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_WaitTargetData_OnCastStyleInputCancelled final
{
public:
	float                                         InputHeldTime;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputReleased;                                    // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_WaitTargetData_OnCastStyleInputCancelled) == 0x000004, "Wrong alignment on HWAbilityTask_WaitTargetData_OnCastStyleInputCancelled");
static_assert(sizeof(HWAbilityTask_WaitTargetData_OnCastStyleInputCancelled) == 0x000008, "Wrong size on HWAbilityTask_WaitTargetData_OnCastStyleInputCancelled");
static_assert(offsetof(HWAbilityTask_WaitTargetData_OnCastStyleInputCancelled, InputHeldTime) == 0x000000, "Member 'HWAbilityTask_WaitTargetData_OnCastStyleInputCancelled::InputHeldTime' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_OnCastStyleInputCancelled, bInputReleased) == 0x000004, "Member 'HWAbilityTask_WaitTargetData_OnCastStyleInputCancelled::bInputReleased' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitTargetData.OnCastStyleInputConfirmed
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_WaitTargetData_OnCastStyleInputConfirmed final
{
public:
	float                                         InputHeldTime;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputReleased;                                    // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_WaitTargetData_OnCastStyleInputConfirmed) == 0x000004, "Wrong alignment on HWAbilityTask_WaitTargetData_OnCastStyleInputConfirmed");
static_assert(sizeof(HWAbilityTask_WaitTargetData_OnCastStyleInputConfirmed) == 0x000008, "Wrong size on HWAbilityTask_WaitTargetData_OnCastStyleInputConfirmed");
static_assert(offsetof(HWAbilityTask_WaitTargetData_OnCastStyleInputConfirmed, InputHeldTime) == 0x000000, "Member 'HWAbilityTask_WaitTargetData_OnCastStyleInputConfirmed::InputHeldTime' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitTargetData_OnCastStyleInputConfirmed, bInputReleased) == 0x000004, "Member 'HWAbilityTask_WaitTargetData_OnCastStyleInputConfirmed::bInputReleased' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_Sphere.GetRadius
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAttackSettings_Sphere_GetRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_Sphere_GetRadius) == 0x000004, "Wrong alignment on HWAbilityAttackSettings_Sphere_GetRadius");
static_assert(sizeof(HWAbilityAttackSettings_Sphere_GetRadius) == 0x000004, "Wrong size on HWAbilityAttackSettings_Sphere_GetRadius");
static_assert(offsetof(HWAbilityAttackSettings_Sphere_GetRadius, ReturnValue) == 0x000000, "Member 'HWAbilityAttackSettings_Sphere_GetRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_Wedge.GetAngle
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAttackSettings_Wedge_GetAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_Wedge_GetAngle) == 0x000004, "Wrong alignment on HWAbilityAttackSettings_Wedge_GetAngle");
static_assert(sizeof(HWAbilityAttackSettings_Wedge_GetAngle) == 0x000004, "Wrong size on HWAbilityAttackSettings_Wedge_GetAngle");
static_assert(offsetof(HWAbilityAttackSettings_Wedge_GetAngle, ReturnValue) == 0x000000, "Member 'HWAbilityAttackSettings_Wedge_GetAngle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_Wedge.GetHeight
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAttackSettings_Wedge_GetHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_Wedge_GetHeight) == 0x000004, "Wrong alignment on HWAbilityAttackSettings_Wedge_GetHeight");
static_assert(sizeof(HWAbilityAttackSettings_Wedge_GetHeight) == 0x000004, "Wrong size on HWAbilityAttackSettings_Wedge_GetHeight");
static_assert(offsetof(HWAbilityAttackSettings_Wedge_GetHeight, ReturnValue) == 0x000000, "Member 'HWAbilityAttackSettings_Wedge_GetHeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_Wedge.GetMinRadius
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAttackSettings_Wedge_GetMinRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_Wedge_GetMinRadius) == 0x000004, "Wrong alignment on HWAbilityAttackSettings_Wedge_GetMinRadius");
static_assert(sizeof(HWAbilityAttackSettings_Wedge_GetMinRadius) == 0x000004, "Wrong size on HWAbilityAttackSettings_Wedge_GetMinRadius");
static_assert(offsetof(HWAbilityAttackSettings_Wedge_GetMinRadius, ReturnValue) == 0x000000, "Member 'HWAbilityAttackSettings_Wedge_GetMinRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_Wedge.GetRadius
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityAttackSettings_Wedge_GetRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_Wedge_GetRadius) == 0x000004, "Wrong alignment on HWAbilityAttackSettings_Wedge_GetRadius");
static_assert(sizeof(HWAbilityAttackSettings_Wedge_GetRadius) == 0x000004, "Wrong size on HWAbilityAttackSettings_Wedge_GetRadius");
static_assert(offsetof(HWAbilityAttackSettings_Wedge_GetRadius, ReturnValue) == 0x000000, "Member 'HWAbilityAttackSettings_Wedge_GetRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityAttackSettings_Wedge.GetWedgeTargetingData
// 0x0090 (0x0090 - 0x0000)
struct HWAbilityAttackSettings_Wedge_GetWedgeTargetingData final
{
public:
	class AActor*                                 AvatarActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPredicting;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCircularWedgeTargetingData            ReturnValue;                                       // 0x0010(0x0080)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityAttackSettings_Wedge_GetWedgeTargetingData) == 0x000008, "Wrong alignment on HWAbilityAttackSettings_Wedge_GetWedgeTargetingData");
static_assert(sizeof(HWAbilityAttackSettings_Wedge_GetWedgeTargetingData) == 0x000090, "Wrong size on HWAbilityAttackSettings_Wedge_GetWedgeTargetingData");
static_assert(offsetof(HWAbilityAttackSettings_Wedge_GetWedgeTargetingData, AvatarActor) == 0x000000, "Member 'HWAbilityAttackSettings_Wedge_GetWedgeTargetingData::AvatarActor' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_Wedge_GetWedgeTargetingData, bIsPredicting) == 0x000008, "Member 'HWAbilityAttackSettings_Wedge_GetWedgeTargetingData::bIsPredicting' has a wrong offset!");
static_assert(offsetof(HWAbilityAttackSettings_Wedge_GetWedgeTargetingData, ReturnValue) == 0x000010, "Member 'HWAbilityAttackSettings_Wedge_GetWedgeTargetingData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.CanHitCurrentAITargetOnly
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityLevelConfig_CanHitCurrentAITargetOnly final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_CanHitCurrentAITargetOnly) == 0x000001, "Wrong alignment on HWAbilityLevelConfig_CanHitCurrentAITargetOnly");
static_assert(sizeof(HWAbilityLevelConfig_CanHitCurrentAITargetOnly) == 0x000001, "Wrong size on HWAbilityLevelConfig_CanHitCurrentAITargetOnly");
static_assert(offsetof(HWAbilityLevelConfig_CanHitCurrentAITargetOnly, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_CanHitCurrentAITargetOnly::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAbilityPhaseDuration
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityLevelConfig_GetAbilityPhaseDuration final
{
public:
	EAbilityFlowPhase                             Phase;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAbilityPhaseDuration) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetAbilityPhaseDuration");
static_assert(sizeof(HWAbilityLevelConfig_GetAbilityPhaseDuration) == 0x000008, "Wrong size on HWAbilityLevelConfig_GetAbilityPhaseDuration");
static_assert(offsetof(HWAbilityLevelConfig_GetAbilityPhaseDuration, Phase) == 0x000000, "Member 'HWAbilityLevelConfig_GetAbilityPhaseDuration::Phase' has a wrong offset!");
static_assert(offsetof(HWAbilityLevelConfig_GetAbilityPhaseDuration, ReturnValue) == 0x000004, "Member 'HWAbilityLevelConfig_GetAbilityPhaseDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAIBaseWeight
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityLevelConfig_GetAIBaseWeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAIBaseWeight) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetAIBaseWeight");
static_assert(sizeof(HWAbilityLevelConfig_GetAIBaseWeight) == 0x000004, "Wrong size on HWAbilityLevelConfig_GetAIBaseWeight");
static_assert(offsetof(HWAbilityLevelConfig_GetAIBaseWeight, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_GetAIBaseWeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAIDesiredRange
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityLevelConfig_GetAIDesiredRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAIDesiredRange) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetAIDesiredRange");
static_assert(sizeof(HWAbilityLevelConfig_GetAIDesiredRange) == 0x000004, "Wrong size on HWAbilityLevelConfig_GetAIDesiredRange");
static_assert(offsetof(HWAbilityLevelConfig_GetAIDesiredRange, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_GetAIDesiredRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAIEffectRadius
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityLevelConfig_GetAIEffectRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAIEffectRadius) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetAIEffectRadius");
static_assert(sizeof(HWAbilityLevelConfig_GetAIEffectRadius) == 0x000004, "Wrong size on HWAbilityLevelConfig_GetAIEffectRadius");
static_assert(offsetof(HWAbilityLevelConfig_GetAIEffectRadius, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_GetAIEffectRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAIMinimumRange
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityLevelConfig_GetAIMinimumRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAIMinimumRange) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetAIMinimumRange");
static_assert(sizeof(HWAbilityLevelConfig_GetAIMinimumRange) == 0x000004, "Wrong size on HWAbilityLevelConfig_GetAIMinimumRange");
static_assert(offsetof(HWAbilityLevelConfig_GetAIMinimumRange, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_GetAIMinimumRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAIModifierWeight
// 0x000C (0x000C - 0x0000)
struct HWAbilityLevelConfig_GetAIModifierWeight final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAIModifierWeight) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetAIModifierWeight");
static_assert(sizeof(HWAbilityLevelConfig_GetAIModifierWeight) == 0x00000C, "Wrong size on HWAbilityLevelConfig_GetAIModifierWeight");
static_assert(offsetof(HWAbilityLevelConfig_GetAIModifierWeight, Tag) == 0x000000, "Member 'HWAbilityLevelConfig_GetAIModifierWeight::Tag' has a wrong offset!");
static_assert(offsetof(HWAbilityLevelConfig_GetAIModifierWeight, ReturnValue) == 0x000008, "Member 'HWAbilityLevelConfig_GetAIModifierWeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAimSetting
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityLevelConfig_GetAimSetting final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWAbilityAimSettings*            ReturnValue;                                       // 0x0008(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAimSetting) == 0x000008, "Wrong alignment on HWAbilityLevelConfig_GetAimSetting");
static_assert(sizeof(HWAbilityLevelConfig_GetAimSetting) == 0x000010, "Wrong size on HWAbilityLevelConfig_GetAimSetting");
static_assert(offsetof(HWAbilityLevelConfig_GetAimSetting, ID) == 0x000000, "Member 'HWAbilityLevelConfig_GetAimSetting::ID' has a wrong offset!");
static_assert(offsetof(HWAbilityLevelConfig_GetAimSetting, ReturnValue) == 0x000008, "Member 'HWAbilityLevelConfig_GetAimSetting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAimSettingForAttack
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityLevelConfig_GetAimSettingForAttack final
{
public:
	struct FGameplayTag                           AttackID;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAimSettings*            ReturnValue;                                       // 0x0008(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAimSettingForAttack) == 0x000008, "Wrong alignment on HWAbilityLevelConfig_GetAimSettingForAttack");
static_assert(sizeof(HWAbilityLevelConfig_GetAimSettingForAttack) == 0x000010, "Wrong size on HWAbilityLevelConfig_GetAimSettingForAttack");
static_assert(offsetof(HWAbilityLevelConfig_GetAimSettingForAttack, AttackID) == 0x000000, "Member 'HWAbilityLevelConfig_GetAimSettingForAttack::AttackID' has a wrong offset!");
static_assert(offsetof(HWAbilityLevelConfig_GetAimSettingForAttack, ReturnValue) == 0x000008, "Member 'HWAbilityLevelConfig_GetAimSettingForAttack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAIPredictionSpeed
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityLevelConfig_GetAIPredictionSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAIPredictionSpeed) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetAIPredictionSpeed");
static_assert(sizeof(HWAbilityLevelConfig_GetAIPredictionSpeed) == 0x000004, "Wrong size on HWAbilityLevelConfig_GetAIPredictionSpeed");
static_assert(offsetof(HWAbilityLevelConfig_GetAIPredictionSpeed, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_GetAIPredictionSpeed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAIUsageCooldownDuration
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityLevelConfig_GetAIUsageCooldownDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAIUsageCooldownDuration) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetAIUsageCooldownDuration");
static_assert(sizeof(HWAbilityLevelConfig_GetAIUsageCooldownDuration) == 0x000004, "Wrong size on HWAbilityLevelConfig_GetAIUsageCooldownDuration");
static_assert(offsetof(HWAbilityLevelConfig_GetAIUsageCooldownDuration, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_GetAIUsageCooldownDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAttackSetting
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityLevelConfig_GetAttackSetting final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWAbilityAttackSettings*         ReturnValue;                                       // 0x0008(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAttackSetting) == 0x000008, "Wrong alignment on HWAbilityLevelConfig_GetAttackSetting");
static_assert(sizeof(HWAbilityLevelConfig_GetAttackSetting) == 0x000010, "Wrong size on HWAbilityLevelConfig_GetAttackSetting");
static_assert(offsetof(HWAbilityLevelConfig_GetAttackSetting, ID) == 0x000000, "Member 'HWAbilityLevelConfig_GetAttackSetting::ID' has a wrong offset!");
static_assert(offsetof(HWAbilityLevelConfig_GetAttackSetting, ReturnValue) == 0x000008, "Member 'HWAbilityLevelConfig_GetAttackSetting::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetAttackSettingForAttack
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityLevelConfig_GetAttackSettingForAttack final
{
public:
	struct FGameplayTag                           AttackID;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings*         ReturnValue;                                       // 0x0008(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetAttackSettingForAttack) == 0x000008, "Wrong alignment on HWAbilityLevelConfig_GetAttackSettingForAttack");
static_assert(sizeof(HWAbilityLevelConfig_GetAttackSettingForAttack) == 0x000010, "Wrong size on HWAbilityLevelConfig_GetAttackSettingForAttack");
static_assert(offsetof(HWAbilityLevelConfig_GetAttackSettingForAttack, AttackID) == 0x000000, "Member 'HWAbilityLevelConfig_GetAttackSettingForAttack::AttackID' has a wrong offset!");
static_assert(offsetof(HWAbilityLevelConfig_GetAttackSettingForAttack, ReturnValue) == 0x000008, "Member 'HWAbilityLevelConfig_GetAttackSettingForAttack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetCooldownDuration
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityLevelConfig_GetCooldownDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetCooldownDuration) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetCooldownDuration");
static_assert(sizeof(HWAbilityLevelConfig_GetCooldownDuration) == 0x000004, "Wrong size on HWAbilityLevelConfig_GetCooldownDuration");
static_assert(offsetof(HWAbilityLevelConfig_GetCooldownDuration, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_GetCooldownDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetEffectsForGroups
// 0x0038 (0x0038 - 0x0000)
struct HWAbilityLevelConfig_GetEffectsForGroups final
{
public:
	struct FGameplayTagContainer                  EffectGroupTags;                                   // 0x0000(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CurrentAttackId;                                   // 0x0020(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    OutEffects;                                        // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetEffectsForGroups) == 0x000008, "Wrong alignment on HWAbilityLevelConfig_GetEffectsForGroups");
static_assert(sizeof(HWAbilityLevelConfig_GetEffectsForGroups) == 0x000038, "Wrong size on HWAbilityLevelConfig_GetEffectsForGroups");
static_assert(offsetof(HWAbilityLevelConfig_GetEffectsForGroups, EffectGroupTags) == 0x000000, "Member 'HWAbilityLevelConfig_GetEffectsForGroups::EffectGroupTags' has a wrong offset!");
static_assert(offsetof(HWAbilityLevelConfig_GetEffectsForGroups, CurrentAttackId) == 0x000020, "Member 'HWAbilityLevelConfig_GetEffectsForGroups::CurrentAttackId' has a wrong offset!");
static_assert(offsetof(HWAbilityLevelConfig_GetEffectsForGroups, OutEffects) == 0x000028, "Member 'HWAbilityLevelConfig_GetEffectsForGroups::OutEffects' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetLevel
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityLevelConfig_GetLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetLevel) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetLevel");
static_assert(sizeof(HWAbilityLevelConfig_GetLevel) == 0x000004, "Wrong size on HWAbilityLevelConfig_GetLevel");
static_assert(offsetof(HWAbilityLevelConfig_GetLevel, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_GetLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.GetTotalAbilityPhaseDuration
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityLevelConfig_GetTotalAbilityPhaseDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_GetTotalAbilityPhaseDuration) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_GetTotalAbilityPhaseDuration");
static_assert(sizeof(HWAbilityLevelConfig_GetTotalAbilityPhaseDuration) == 0x000004, "Wrong size on HWAbilityLevelConfig_GetTotalAbilityPhaseDuration");
static_assert(offsetof(HWAbilityLevelConfig_GetTotalAbilityPhaseDuration, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_GetTotalAbilityPhaseDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.HasAITag
// 0x000C (0x000C - 0x0000)
struct HWAbilityLevelConfig_HasAITag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityLevelConfig_HasAITag) == 0x000004, "Wrong alignment on HWAbilityLevelConfig_HasAITag");
static_assert(sizeof(HWAbilityLevelConfig_HasAITag) == 0x00000C, "Wrong size on HWAbilityLevelConfig_HasAITag");
static_assert(offsetof(HWAbilityLevelConfig_HasAITag, Tag) == 0x000000, "Member 'HWAbilityLevelConfig_HasAITag::Tag' has a wrong offset!");
static_assert(offsetof(HWAbilityLevelConfig_HasAITag, ReturnValue) == 0x000008, "Member 'HWAbilityLevelConfig_HasAITag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityLevelConfig.ShouldAIPredictSourceLocation
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityLevelConfig_ShouldAIPredictSourceLocation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityLevelConfig_ShouldAIPredictSourceLocation) == 0x000001, "Wrong alignment on HWAbilityLevelConfig_ShouldAIPredictSourceLocation");
static_assert(sizeof(HWAbilityLevelConfig_ShouldAIPredictSourceLocation) == 0x000001, "Wrong size on HWAbilityLevelConfig_ShouldAIPredictSourceLocation");
static_assert(offsetof(HWAbilityLevelConfig_ShouldAIPredictSourceLocation, ReturnValue) == 0x000000, "Member 'HWAbilityLevelConfig_ShouldAIPredictSourceLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Deployable.GetAvatarDeployableFromActorInfo
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Deployable_GetAvatarDeployableFromActorInfo final
{
public:
	class AHWDeployable*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Deployable_GetAvatarDeployableFromActorInfo) == 0x000008, "Wrong alignment on HWAbility_Deployable_GetAvatarDeployableFromActorInfo");
static_assert(sizeof(HWAbility_Deployable_GetAvatarDeployableFromActorInfo) == 0x000008, "Wrong size on HWAbility_Deployable_GetAvatarDeployableFromActorInfo");
static_assert(offsetof(HWAbility_Deployable_GetAvatarDeployableFromActorInfo, ReturnValue) == 0x000000, "Member 'HWAbility_Deployable_GetAvatarDeployableFromActorInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Deployable_BounceChain.ApplyGameplayEffectToHitTarget
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Deployable_BounceChain_ApplyGameplayEffectToHitTarget final
{
public:
	class AActor*                                 HitTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Deployable_BounceChain_ApplyGameplayEffectToHitTarget) == 0x000008, "Wrong alignment on HWAbility_Deployable_BounceChain_ApplyGameplayEffectToHitTarget");
static_assert(sizeof(HWAbility_Deployable_BounceChain_ApplyGameplayEffectToHitTarget) == 0x000008, "Wrong size on HWAbility_Deployable_BounceChain_ApplyGameplayEffectToHitTarget");
static_assert(offsetof(HWAbility_Deployable_BounceChain_ApplyGameplayEffectToHitTarget, HitTarget) == 0x000000, "Member 'HWAbility_Deployable_BounceChain_ApplyGameplayEffectToHitTarget::HitTarget' has a wrong offset!");

// Function Hemingway.HWAbility_Deployable_BounceChain.MoveDeployableToHitTarget
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Deployable_BounceChain_MoveDeployableToHitTarget final
{
public:
	class AActor*                                 HitTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Deployable_BounceChain_MoveDeployableToHitTarget) == 0x000008, "Wrong alignment on HWAbility_Deployable_BounceChain_MoveDeployableToHitTarget");
static_assert(sizeof(HWAbility_Deployable_BounceChain_MoveDeployableToHitTarget) == 0x000008, "Wrong size on HWAbility_Deployable_BounceChain_MoveDeployableToHitTarget");
static_assert(offsetof(HWAbility_Deployable_BounceChain_MoveDeployableToHitTarget, HitTarget) == 0x000000, "Member 'HWAbility_Deployable_BounceChain_MoveDeployableToHitTarget::HitTarget' has a wrong offset!");

// Function Hemingway.HWAbility_Deployable_BounceChain.TrackHitTarget
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Deployable_BounceChain_TrackHitTarget final
{
public:
	class AActor*                                 HitTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Deployable_BounceChain_TrackHitTarget) == 0x000008, "Wrong alignment on HWAbility_Deployable_BounceChain_TrackHitTarget");
static_assert(sizeof(HWAbility_Deployable_BounceChain_TrackHitTarget) == 0x000008, "Wrong size on HWAbility_Deployable_BounceChain_TrackHitTarget");
static_assert(offsetof(HWAbility_Deployable_BounceChain_TrackHitTarget, HitTarget) == 0x000000, "Member 'HWAbility_Deployable_BounceChain_TrackHitTarget::HitTarget' has a wrong offset!");

// Function Hemingway.HWAbility_Deployable_BounceChain.MakeGameplayEffectSpecs
// 0x0018 (0x0018 - 0x0000)
struct HWAbility_Deployable_BounceChain_MakeGameplayEffectSpecs final
{
public:
	class AActor*                                 HitTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectSpecHandle>      ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Deployable_BounceChain_MakeGameplayEffectSpecs) == 0x000008, "Wrong alignment on HWAbility_Deployable_BounceChain_MakeGameplayEffectSpecs");
static_assert(sizeof(HWAbility_Deployable_BounceChain_MakeGameplayEffectSpecs) == 0x000018, "Wrong size on HWAbility_Deployable_BounceChain_MakeGameplayEffectSpecs");
static_assert(offsetof(HWAbility_Deployable_BounceChain_MakeGameplayEffectSpecs, HitTarget) == 0x000000, "Member 'HWAbility_Deployable_BounceChain_MakeGameplayEffectSpecs::HitTarget' has a wrong offset!");
static_assert(offsetof(HWAbility_Deployable_BounceChain_MakeGameplayEffectSpecs, ReturnValue) == 0x000008, "Member 'HWAbility_Deployable_BounceChain_MakeGameplayEffectSpecs::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Deployable_BounceChain.SelectNextHitTarget
// 0x0018 (0x0018 - 0x0000)
struct HWAbility_Deployable_BounceChain_SelectNextHitTarget final
{
public:
	TArray<class AActor*>                         HitTargets;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Deployable_BounceChain_SelectNextHitTarget) == 0x000008, "Wrong alignment on HWAbility_Deployable_BounceChain_SelectNextHitTarget");
static_assert(sizeof(HWAbility_Deployable_BounceChain_SelectNextHitTarget) == 0x000018, "Wrong size on HWAbility_Deployable_BounceChain_SelectNextHitTarget");
static_assert(offsetof(HWAbility_Deployable_BounceChain_SelectNextHitTarget, HitTargets) == 0x000000, "Member 'HWAbility_Deployable_BounceChain_SelectNextHitTarget::HitTargets' has a wrong offset!");
static_assert(offsetof(HWAbility_Deployable_BounceChain_SelectNextHitTarget, ReturnValue) == 0x000010, "Member 'HWAbility_Deployable_BounceChain_SelectNextHitTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.GetAssociatedCharacter
// 0x0028 (0x0028 - 0x0000)
struct HWCollectionItem_GetAssociatedCharacter final
{
public:
	TSoftObjectPtr<class UHWCharacterItem>        ReturnValue;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCollectionItem_GetAssociatedCharacter) == 0x000008, "Wrong alignment on HWCollectionItem_GetAssociatedCharacter");
static_assert(sizeof(HWCollectionItem_GetAssociatedCharacter) == 0x000028, "Wrong size on HWCollectionItem_GetAssociatedCharacter");
static_assert(offsetof(HWCollectionItem_GetAssociatedCharacter, ReturnValue) == 0x000000, "Member 'HWCollectionItem_GetAssociatedCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.GetAssociatedCharacterFull
// 0x0048 (0x0048 - 0x0000)
struct HWCollectionItem_GetAssociatedCharacterFull final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             InItemId;                                          // 0x0008(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWCharacterItem>        ReturnValue;                                       // 0x0020(0x0028)(ConstParm, Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCollectionItem_GetAssociatedCharacterFull) == 0x000008, "Wrong alignment on HWCollectionItem_GetAssociatedCharacterFull");
static_assert(sizeof(HWCollectionItem_GetAssociatedCharacterFull) == 0x000048, "Wrong size on HWCollectionItem_GetAssociatedCharacterFull");
static_assert(offsetof(HWCollectionItem_GetAssociatedCharacterFull, WorldContextObject) == 0x000000, "Member 'HWCollectionItem_GetAssociatedCharacterFull::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_GetAssociatedCharacterFull, InItemId) == 0x000008, "Member 'HWCollectionItem_GetAssociatedCharacterFull::InItemId' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_GetAssociatedCharacterFull, ReturnValue) == 0x000020, "Member 'HWCollectionItem_GetAssociatedCharacterFull::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.GetCollectionItemStatus
// 0x0020 (0x0020 - 0x0000)
struct HWCollectionItem_GetCollectionItemStatus final
{
public:
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 CharacterContextItem;                              // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWInventoryItem*                 OtherContextItem;                                  // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWCollectionItemStatus                       ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCollectionItem_GetCollectionItemStatus) == 0x000008, "Wrong alignment on HWCollectionItem_GetCollectionItemStatus");
static_assert(sizeof(HWCollectionItem_GetCollectionItemStatus) == 0x000020, "Wrong size on HWCollectionItem_GetCollectionItemStatus");
static_assert(offsetof(HWCollectionItem_GetCollectionItemStatus, PlayerInfo) == 0x000000, "Member 'HWCollectionItem_GetCollectionItemStatus::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_GetCollectionItemStatus, CharacterContextItem) == 0x000008, "Member 'HWCollectionItem_GetCollectionItemStatus::CharacterContextItem' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_GetCollectionItemStatus, OtherContextItem) == 0x000010, "Member 'HWCollectionItem_GetCollectionItemStatus::OtherContextItem' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_GetCollectionItemStatus, ReturnValue) == 0x000018, "Member 'HWCollectionItem_GetCollectionItemStatus::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.GetCollectionType
// 0x0001 (0x0001 - 0x0000)
struct HWCollectionItem_GetCollectionType final
{
public:
	EHWCollectionItemType                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCollectionItem_GetCollectionType) == 0x000001, "Wrong alignment on HWCollectionItem_GetCollectionType");
static_assert(sizeof(HWCollectionItem_GetCollectionType) == 0x000001, "Wrong size on HWCollectionItem_GetCollectionType");
static_assert(offsetof(HWCollectionItem_GetCollectionType, ReturnValue) == 0x000000, "Member 'HWCollectionItem_GetCollectionType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.GetCosmeticMaterials
// 0x0018 (0x0018 - 0x0000)
struct HWCollectionItem_GetCosmeticMaterials final
{
public:
	class FName                                   AssetKey;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWCosmeticMaterialSet                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCollectionItem_GetCosmeticMaterials) == 0x000008, "Wrong alignment on HWCollectionItem_GetCosmeticMaterials");
static_assert(sizeof(HWCollectionItem_GetCosmeticMaterials) == 0x000018, "Wrong size on HWCollectionItem_GetCosmeticMaterials");
static_assert(offsetof(HWCollectionItem_GetCosmeticMaterials, AssetKey) == 0x000000, "Member 'HWCollectionItem_GetCosmeticMaterials::AssetKey' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_GetCosmeticMaterials, ReturnValue) == 0x000008, "Member 'HWCollectionItem_GetCosmeticMaterials::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.GetCosmeticNiagaraSystem
// 0x0030 (0x0030 - 0x0000)
struct HWCollectionItem_GetCosmeticNiagaraSystem final
{
public:
	class FName                                   AssetKey;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCollectionItem_GetCosmeticNiagaraSystem) == 0x000008, "Wrong alignment on HWCollectionItem_GetCosmeticNiagaraSystem");
static_assert(sizeof(HWCollectionItem_GetCosmeticNiagaraSystem) == 0x000030, "Wrong size on HWCollectionItem_GetCosmeticNiagaraSystem");
static_assert(offsetof(HWCollectionItem_GetCosmeticNiagaraSystem, AssetKey) == 0x000000, "Member 'HWCollectionItem_GetCosmeticNiagaraSystem::AssetKey' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_GetCosmeticNiagaraSystem, ReturnValue) == 0x000008, "Member 'HWCollectionItem_GetCosmeticNiagaraSystem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.GetCosmeticSkeletalMesh
// 0x0030 (0x0030 - 0x0000)
struct HWCollectionItem_GetCosmeticSkeletalMesh final
{
public:
	class FName                                   AssetKey;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCollectionItem_GetCosmeticSkeletalMesh) == 0x000008, "Wrong alignment on HWCollectionItem_GetCosmeticSkeletalMesh");
static_assert(sizeof(HWCollectionItem_GetCosmeticSkeletalMesh) == 0x000030, "Wrong size on HWCollectionItem_GetCosmeticSkeletalMesh");
static_assert(offsetof(HWCollectionItem_GetCosmeticSkeletalMesh, AssetKey) == 0x000000, "Member 'HWCollectionItem_GetCosmeticSkeletalMesh::AssetKey' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_GetCosmeticSkeletalMesh, ReturnValue) == 0x000008, "Member 'HWCollectionItem_GetCosmeticSkeletalMesh::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.GetCosmeticSound
// 0x0030 (0x0030 - 0x0000)
struct HWCollectionItem_GetCosmeticSound final
{
public:
	class FName                                   AssetKey;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCollectionItem_GetCosmeticSound) == 0x000008, "Wrong alignment on HWCollectionItem_GetCosmeticSound");
static_assert(sizeof(HWCollectionItem_GetCosmeticSound) == 0x000030, "Wrong size on HWCollectionItem_GetCosmeticSound");
static_assert(offsetof(HWCollectionItem_GetCosmeticSound, AssetKey) == 0x000000, "Member 'HWCollectionItem_GetCosmeticSound::AssetKey' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_GetCosmeticSound, ReturnValue) == 0x000008, "Member 'HWCollectionItem_GetCosmeticSound::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.GetCosmeticStaticMesh
// 0x0030 (0x0030 - 0x0000)
struct HWCollectionItem_GetCosmeticStaticMesh final
{
public:
	class FName                                   AssetKey;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCollectionItem_GetCosmeticStaticMesh) == 0x000008, "Wrong alignment on HWCollectionItem_GetCosmeticStaticMesh");
static_assert(sizeof(HWCollectionItem_GetCosmeticStaticMesh) == 0x000030, "Wrong size on HWCollectionItem_GetCosmeticStaticMesh");
static_assert(offsetof(HWCollectionItem_GetCosmeticStaticMesh, AssetKey) == 0x000000, "Member 'HWCollectionItem_GetCosmeticStaticMesh::AssetKey' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_GetCosmeticStaticMesh, ReturnValue) == 0x000008, "Member 'HWCollectionItem_GetCosmeticStaticMesh::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.IsComingSoon
// 0x0001 (0x0001 - 0x0000)
struct HWCollectionItem_IsComingSoon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCollectionItem_IsComingSoon) == 0x000001, "Wrong alignment on HWCollectionItem_IsComingSoon");
static_assert(sizeof(HWCollectionItem_IsComingSoon) == 0x000001, "Wrong size on HWCollectionItem_IsComingSoon");
static_assert(offsetof(HWCollectionItem_IsComingSoon, ReturnValue) == 0x000000, "Member 'HWCollectionItem_IsComingSoon::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.IsEquipped
// 0x0018 (0x0018 - 0x0000)
struct HWCollectionItem_IsEquipped final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 EquippedToCharacter;                               // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsiderVariantSkin;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCollectionItem_IsEquipped) == 0x000008, "Wrong alignment on HWCollectionItem_IsEquipped");
static_assert(sizeof(HWCollectionItem_IsEquipped) == 0x000018, "Wrong size on HWCollectionItem_IsEquipped");
static_assert(offsetof(HWCollectionItem_IsEquipped, WorldContextObject) == 0x000000, "Member 'HWCollectionItem_IsEquipped::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_IsEquipped, EquippedToCharacter) == 0x000008, "Member 'HWCollectionItem_IsEquipped::EquippedToCharacter' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_IsEquipped, bConsiderVariantSkin) == 0x000010, "Member 'HWCollectionItem_IsEquipped::bConsiderVariantSkin' has a wrong offset!");
static_assert(offsetof(HWCollectionItem_IsEquipped, ReturnValue) == 0x000011, "Member 'HWCollectionItem_IsEquipped::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCollectionItem.IsUnobtainable
// 0x0001 (0x0001 - 0x0000)
struct HWCollectionItem_IsUnobtainable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCollectionItem_IsUnobtainable) == 0x000001, "Wrong alignment on HWCollectionItem_IsUnobtainable");
static_assert(sizeof(HWCollectionItem_IsUnobtainable) == 0x000001, "Wrong size on HWCollectionItem_IsUnobtainable");
static_assert(offsetof(HWCollectionItem_IsUnobtainable, ReturnValue) == 0x000000, "Member 'HWCollectionItem_IsUnobtainable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetAbilityPotential
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterItem_GetAbilityPotential final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetAbilityPotential) == 0x000004, "Wrong alignment on HWCharacterItem_GetAbilityPotential");
static_assert(sizeof(HWCharacterItem_GetAbilityPotential) == 0x000004, "Wrong size on HWCharacterItem_GetAbilityPotential");
static_assert(offsetof(HWCharacterItem_GetAbilityPotential, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetAbilityPotential::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetAbilityStart
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterItem_GetAbilityStart final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetAbilityStart) == 0x000004, "Wrong alignment on HWCharacterItem_GetAbilityStart");
static_assert(sizeof(HWCharacterItem_GetAbilityStart) == 0x000004, "Wrong size on HWCharacterItem_GetAbilityStart");
static_assert(offsetof(HWCharacterItem_GetAbilityStart, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetAbilityStart::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetAllTexturesForGameplayTag
// 0x0058 (0x0058 - 0x0000)
struct HWCharacterItem_GetAllTexturesForGameplayTag final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSoftObjectPtr<class UTexture2D>> OutTextures;                         // 0x0008(0x0050)(Parm, OutParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetAllTexturesForGameplayTag) == 0x000008, "Wrong alignment on HWCharacterItem_GetAllTexturesForGameplayTag");
static_assert(sizeof(HWCharacterItem_GetAllTexturesForGameplayTag) == 0x000058, "Wrong size on HWCharacterItem_GetAllTexturesForGameplayTag");
static_assert(offsetof(HWCharacterItem_GetAllTexturesForGameplayTag, GameplayTag) == 0x000000, "Member 'HWCharacterItem_GetAllTexturesForGameplayTag::GameplayTag' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetAllTexturesForGameplayTag, OutTextures) == 0x000008, "Member 'HWCharacterItem_GetAllTexturesForGameplayTag::OutTextures' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetCharacterDescriptorTags
// 0x0020 (0x0020 - 0x0000)
struct HWCharacterItem_GetCharacterDescriptorTags final
{
public:
	struct FGameplayTagContainer                  OutTags;                                           // 0x0000(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetCharacterDescriptorTags) == 0x000008, "Wrong alignment on HWCharacterItem_GetCharacterDescriptorTags");
static_assert(sizeof(HWCharacterItem_GetCharacterDescriptorTags) == 0x000020, "Wrong size on HWCharacterItem_GetCharacterDescriptorTags");
static_assert(offsetof(HWCharacterItem_GetCharacterDescriptorTags, OutTags) == 0x000000, "Member 'HWCharacterItem_GetCharacterDescriptorTags::OutTags' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetCharacterHealerTier
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterItem_GetCharacterHealerTier final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetCharacterHealerTier) == 0x000004, "Wrong alignment on HWCharacterItem_GetCharacterHealerTier");
static_assert(sizeof(HWCharacterItem_GetCharacterHealerTier) == 0x000004, "Wrong size on HWCharacterItem_GetCharacterHealerTier");
static_assert(offsetof(HWCharacterItem_GetCharacterHealerTier, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetCharacterHealerTier::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetCharacterStat
// 0x0010 (0x0010 - 0x0000)
struct HWCharacterItem_GetCharacterStat final
{
public:
	struct FGameplayTag                           StatTag;                                           // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetCharacterStat) == 0x000004, "Wrong alignment on HWCharacterItem_GetCharacterStat");
static_assert(sizeof(HWCharacterItem_GetCharacterStat) == 0x000010, "Wrong size on HWCharacterItem_GetCharacterStat");
static_assert(offsetof(HWCharacterItem_GetCharacterStat, StatTag) == 0x000000, "Member 'HWCharacterItem_GetCharacterStat::StatTag' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetCharacterStat, Level) == 0x000008, "Member 'HWCharacterItem_GetCharacterStat::Level' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetCharacterStat, ReturnValue) == 0x00000C, "Member 'HWCharacterItem_GetCharacterStat::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetCharacterTitle
// 0x0018 (0x0018 - 0x0000)
struct HWCharacterItem_GetCharacterTitle final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetCharacterTitle) == 0x000008, "Wrong alignment on HWCharacterItem_GetCharacterTitle");
static_assert(sizeof(HWCharacterItem_GetCharacterTitle) == 0x000018, "Wrong size on HWCharacterItem_GetCharacterTitle");
static_assert(offsetof(HWCharacterItem_GetCharacterTitle, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetCharacterTitle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetCharacterTitleCaps
// 0x0018 (0x0018 - 0x0000)
struct HWCharacterItem_GetCharacterTitleCaps final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetCharacterTitleCaps) == 0x000008, "Wrong alignment on HWCharacterItem_GetCharacterTitleCaps");
static_assert(sizeof(HWCharacterItem_GetCharacterTitleCaps) == 0x000018, "Wrong size on HWCharacterItem_GetCharacterTitleCaps");
static_assert(offsetof(HWCharacterItem_GetCharacterTitleCaps, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetCharacterTitleCaps::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetCollectionInfo
// 0x0020 (0x0020 - 0x0000)
struct HWCharacterItem_GetCollectionInfo final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWCharacterCollectionInfo             OutCollectionInfo;                                 // 0x0008(0x0014)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterItem_GetCollectionInfo) == 0x000004, "Wrong alignment on HWCharacterItem_GetCollectionInfo");
static_assert(sizeof(HWCharacterItem_GetCollectionInfo) == 0x000020, "Wrong size on HWCharacterItem_GetCollectionInfo");
static_assert(offsetof(HWCharacterItem_GetCollectionInfo, Tag) == 0x000000, "Member 'HWCharacterItem_GetCollectionInfo::Tag' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetCollectionInfo, OutCollectionInfo) == 0x000008, "Member 'HWCharacterItem_GetCollectionInfo::OutCollectionInfo' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetCollectionInfo, ReturnValue) == 0x00001C, "Member 'HWCharacterItem_GetCollectionInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetCollectionItemByItemId
// 0x0040 (0x0040 - 0x0000)
struct HWCharacterItem_GetCollectionItemByItemId final
{
public:
	struct FRH_ItemId                             InItemId;                                          // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHWCollectionItem>       ReturnValue;                                       // 0x0018(0x0028)(ConstParm, Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetCollectionItemByItemId) == 0x000008, "Wrong alignment on HWCharacterItem_GetCollectionItemByItemId");
static_assert(sizeof(HWCharacterItem_GetCollectionItemByItemId) == 0x000040, "Wrong size on HWCharacterItem_GetCollectionItemByItemId");
static_assert(offsetof(HWCharacterItem_GetCollectionItemByItemId, InItemId) == 0x000000, "Member 'HWCharacterItem_GetCollectionItemByItemId::InItemId' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetCollectionItemByItemId, ReturnValue) == 0x000018, "Member 'HWCharacterItem_GetCollectionItemByItemId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetCompatibleTalents
// 0x0010 (0x0010 - 0x0000)
struct HWCharacterItem_GetCompatibleTalents final
{
public:
	TArray<TSoftObjectPtr<class UHWEquipmentItem>> ReturnValue;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetCompatibleTalents) == 0x000008, "Wrong alignment on HWCharacterItem_GetCompatibleTalents");
static_assert(sizeof(HWCharacterItem_GetCompatibleTalents) == 0x000010, "Wrong size on HWCharacterItem_GetCompatibleTalents");
static_assert(offsetof(HWCharacterItem_GetCompatibleTalents, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetCompatibleTalents::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetCustomLevel
// 0x0028 (0x0028 - 0x0000)
struct HWCharacterItem_GetCustomLevel final
{
public:
	TSoftObjectPtr<class UWorld>                  ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetCustomLevel) == 0x000008, "Wrong alignment on HWCharacterItem_GetCustomLevel");
static_assert(sizeof(HWCharacterItem_GetCustomLevel) == 0x000028, "Wrong size on HWCharacterItem_GetCustomLevel");
static_assert(offsetof(HWCharacterItem_GetCustomLevel, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetCustomLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetDefensePotential
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterItem_GetDefensePotential final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetDefensePotential) == 0x000004, "Wrong alignment on HWCharacterItem_GetDefensePotential");
static_assert(sizeof(HWCharacterItem_GetDefensePotential) == 0x000004, "Wrong size on HWCharacterItem_GetDefensePotential");
static_assert(offsetof(HWCharacterItem_GetDefensePotential, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetDefensePotential::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetDefenseStart
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterItem_GetDefenseStart final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetDefenseStart) == 0x000004, "Wrong alignment on HWCharacterItem_GetDefenseStart");
static_assert(sizeof(HWCharacterItem_GetDefenseStart) == 0x000004, "Wrong size on HWCharacterItem_GetDefenseStart");
static_assert(offsetof(HWCharacterItem_GetDefenseStart, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetDefenseStart::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetGodQuestEntryByCollectionItem
// 0x00C0 (0x00C0 - 0x0000)
struct HWCharacterItem_GetGodQuestEntryByCollectionItem final
{
public:
	const class UHWCollectionItem*                CollectionItem;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGodQuestEntry                         OutQuestEntry;                                     // 0x0008(0x00B0)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterItem_GetGodQuestEntryByCollectionItem) == 0x000008, "Wrong alignment on HWCharacterItem_GetGodQuestEntryByCollectionItem");
static_assert(sizeof(HWCharacterItem_GetGodQuestEntryByCollectionItem) == 0x0000C0, "Wrong size on HWCharacterItem_GetGodQuestEntryByCollectionItem");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByCollectionItem, CollectionItem) == 0x000000, "Member 'HWCharacterItem_GetGodQuestEntryByCollectionItem::CollectionItem' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByCollectionItem, OutQuestEntry) == 0x000008, "Member 'HWCharacterItem_GetGodQuestEntryByCollectionItem::OutQuestEntry' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByCollectionItem, ReturnValue) == 0x0000B8, "Member 'HWCharacterItem_GetGodQuestEntryByCollectionItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetGodQuestEntryByCollectionItemPtr
// 0x00E0 (0x00E0 - 0x0000)
struct HWCharacterItem_GetGodQuestEntryByCollectionItemPtr final
{
public:
	TSoftObjectPtr<class UHWCollectionItem>       CollectionItem;                                    // 0x0000(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGodQuestEntry                         OutQuestEntry;                                     // 0x0028(0x00B0)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00D8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterItem_GetGodQuestEntryByCollectionItemPtr) == 0x000008, "Wrong alignment on HWCharacterItem_GetGodQuestEntryByCollectionItemPtr");
static_assert(sizeof(HWCharacterItem_GetGodQuestEntryByCollectionItemPtr) == 0x0000E0, "Wrong size on HWCharacterItem_GetGodQuestEntryByCollectionItemPtr");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByCollectionItemPtr, CollectionItem) == 0x000000, "Member 'HWCharacterItem_GetGodQuestEntryByCollectionItemPtr::CollectionItem' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByCollectionItemPtr, OutQuestEntry) == 0x000028, "Member 'HWCharacterItem_GetGodQuestEntryByCollectionItemPtr::OutQuestEntry' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByCollectionItemPtr, ReturnValue) == 0x0000D8, "Member 'HWCharacterItem_GetGodQuestEntryByCollectionItemPtr::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetGodQuestEntryByQuestItem
// 0x00E0 (0x00E0 - 0x0000)
struct HWCharacterItem_GetGodQuestEntryByQuestItem final
{
public:
	TSoftObjectPtr<class UHWQuest>                QuestItem;                                         // 0x0000(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGodQuestEntry                         OutQuestEntry;                                     // 0x0028(0x00B0)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00D8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterItem_GetGodQuestEntryByQuestItem) == 0x000008, "Wrong alignment on HWCharacterItem_GetGodQuestEntryByQuestItem");
static_assert(sizeof(HWCharacterItem_GetGodQuestEntryByQuestItem) == 0x0000E0, "Wrong size on HWCharacterItem_GetGodQuestEntryByQuestItem");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByQuestItem, QuestItem) == 0x000000, "Member 'HWCharacterItem_GetGodQuestEntryByQuestItem::QuestItem' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByQuestItem, OutQuestEntry) == 0x000028, "Member 'HWCharacterItem_GetGodQuestEntryByQuestItem::OutQuestEntry' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByQuestItem, ReturnValue) == 0x0000D8, "Member 'HWCharacterItem_GetGodQuestEntryByQuestItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetGodQuestEntryByQuestItemId
// 0x00D0 (0x00D0 - 0x0000)
struct HWCharacterItem_GetGodQuestEntryByQuestItemId final
{
public:
	struct FRH_ItemId                             InQuestItemId;                                     // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGodQuestEntry                         OutQuestEntry;                                     // 0x0018(0x00B0)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterItem_GetGodQuestEntryByQuestItemId) == 0x000008, "Wrong alignment on HWCharacterItem_GetGodQuestEntryByQuestItemId");
static_assert(sizeof(HWCharacterItem_GetGodQuestEntryByQuestItemId) == 0x0000D0, "Wrong size on HWCharacterItem_GetGodQuestEntryByQuestItemId");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByQuestItemId, InQuestItemId) == 0x000000, "Member 'HWCharacterItem_GetGodQuestEntryByQuestItemId::InQuestItemId' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByQuestItemId, OutQuestEntry) == 0x000018, "Member 'HWCharacterItem_GetGodQuestEntryByQuestItemId::OutQuestEntry' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetGodQuestEntryByQuestItemId, ReturnValue) == 0x0000C8, "Member 'HWCharacterItem_GetGodQuestEntryByQuestItemId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetIntelligenceScaling
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterItem_GetIntelligenceScaling final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetIntelligenceScaling) == 0x000004, "Wrong alignment on HWCharacterItem_GetIntelligenceScaling");
static_assert(sizeof(HWCharacterItem_GetIntelligenceScaling) == 0x000004, "Wrong size on HWCharacterItem_GetIntelligenceScaling");
static_assert(offsetof(HWCharacterItem_GetIntelligenceScaling, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetIntelligenceScaling::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetOffensePotential
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterItem_GetOffensePotential final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetOffensePotential) == 0x000004, "Wrong alignment on HWCharacterItem_GetOffensePotential");
static_assert(sizeof(HWCharacterItem_GetOffensePotential) == 0x000004, "Wrong size on HWCharacterItem_GetOffensePotential");
static_assert(offsetof(HWCharacterItem_GetOffensePotential, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetOffensePotential::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetOffenseStart
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterItem_GetOffenseStart final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetOffenseStart) == 0x000004, "Wrong alignment on HWCharacterItem_GetOffenseStart");
static_assert(sizeof(HWCharacterItem_GetOffenseStart) == 0x000004, "Wrong size on HWCharacterItem_GetOffenseStart");
static_assert(offsetof(HWCharacterItem_GetOffenseStart, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetOffenseStart::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetOwnershipIdByCollectionItem
// 0x0020 (0x0020 - 0x0000)
struct HWCharacterItem_GetOwnershipIdByCollectionItem final
{
public:
	const class UHWCollectionItem*                CollectionItem;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             ReturnValue;                                       // 0x0008(0x0014)(ConstParm, Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterItem_GetOwnershipIdByCollectionItem) == 0x000008, "Wrong alignment on HWCharacterItem_GetOwnershipIdByCollectionItem");
static_assert(sizeof(HWCharacterItem_GetOwnershipIdByCollectionItem) == 0x000020, "Wrong size on HWCharacterItem_GetOwnershipIdByCollectionItem");
static_assert(offsetof(HWCharacterItem_GetOwnershipIdByCollectionItem, CollectionItem) == 0x000000, "Member 'HWCharacterItem_GetOwnershipIdByCollectionItem::CollectionItem' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetOwnershipIdByCollectionItem, ReturnValue) == 0x000008, "Member 'HWCharacterItem_GetOwnershipIdByCollectionItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetRoleInfo
// 0x0010 (0x0010 - 0x0000)
struct HWCharacterItem_GetRoleInfo final
{
public:
	TArray<struct FCharacterRoleInfo>             ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetRoleInfo) == 0x000008, "Wrong alignment on HWCharacterItem_GetRoleInfo");
static_assert(sizeof(HWCharacterItem_GetRoleInfo) == 0x000010, "Wrong size on HWCharacterItem_GetRoleInfo");
static_assert(offsetof(HWCharacterItem_GetRoleInfo, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetRoleInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetSkinItemsForCharacterItem
// 0x0010 (0x0010 - 0x0000)
struct HWCharacterItem_GetSkinItemsForCharacterItem final
{
public:
	TArray<TSoftObjectPtr<class UHWSkinItem>>     OutSkinItems;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetSkinItemsForCharacterItem) == 0x000008, "Wrong alignment on HWCharacterItem_GetSkinItemsForCharacterItem");
static_assert(sizeof(HWCharacterItem_GetSkinItemsForCharacterItem) == 0x000010, "Wrong size on HWCharacterItem_GetSkinItemsForCharacterItem");
static_assert(offsetof(HWCharacterItem_GetSkinItemsForCharacterItem, OutSkinItems) == 0x000000, "Member 'HWCharacterItem_GetSkinItemsForCharacterItem::OutSkinItems' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetStrengthScaling
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterItem_GetStrengthScaling final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetStrengthScaling) == 0x000004, "Wrong alignment on HWCharacterItem_GetStrengthScaling");
static_assert(sizeof(HWCharacterItem_GetStrengthScaling) == 0x000004, "Wrong size on HWCharacterItem_GetStrengthScaling");
static_assert(offsetof(HWCharacterItem_GetStrengthScaling, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetStrengthScaling::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetTextureForExactGameplayTag
// 0x0030 (0x0030 - 0x0000)
struct HWCharacterItem_GetTextureForExactGameplayTag final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetTextureForExactGameplayTag) == 0x000008, "Wrong alignment on HWCharacterItem_GetTextureForExactGameplayTag");
static_assert(sizeof(HWCharacterItem_GetTextureForExactGameplayTag) == 0x000030, "Wrong size on HWCharacterItem_GetTextureForExactGameplayTag");
static_assert(offsetof(HWCharacterItem_GetTextureForExactGameplayTag, GameplayTag) == 0x000000, "Member 'HWCharacterItem_GetTextureForExactGameplayTag::GameplayTag' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_GetTextureForExactGameplayTag, ReturnValue) == 0x000008, "Member 'HWCharacterItem_GetTextureForExactGameplayTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.GetVoicePackItem
// 0x0028 (0x0028 - 0x0000)
struct HWCharacterItem_GetVoicePackItem final
{
public:
	TSoftObjectPtr<class UHWVoicePackItem>        ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_GetVoicePackItem) == 0x000008, "Wrong alignment on HWCharacterItem_GetVoicePackItem");
static_assert(sizeof(HWCharacterItem_GetVoicePackItem) == 0x000028, "Wrong size on HWCharacterItem_GetVoicePackItem");
static_assert(offsetof(HWCharacterItem_GetVoicePackItem, ReturnValue) == 0x000000, "Member 'HWCharacterItem_GetVoicePackItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.IsFavoriteGod
// 0x0010 (0x0010 - 0x0000)
struct HWCharacterItem_IsFavoriteGod final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterItem_IsFavoriteGod) == 0x000008, "Wrong alignment on HWCharacterItem_IsFavoriteGod");
static_assert(sizeof(HWCharacterItem_IsFavoriteGod) == 0x000010, "Wrong size on HWCharacterItem_IsFavoriteGod");
static_assert(offsetof(HWCharacterItem_IsFavoriteGod, WorldContextObject) == 0x000000, "Member 'HWCharacterItem_IsFavoriteGod::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_IsFavoriteGod, ReturnValue) == 0x000008, "Member 'HWCharacterItem_IsFavoriteGod::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.IsInRotation
// 0x0010 (0x0010 - 0x0000)
struct HWCharacterItem_IsInRotation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterItem_IsInRotation) == 0x000008, "Wrong alignment on HWCharacterItem_IsInRotation");
static_assert(sizeof(HWCharacterItem_IsInRotation) == 0x000010, "Wrong size on HWCharacterItem_IsInRotation");
static_assert(offsetof(HWCharacterItem_IsInRotation, WorldContextObject) == 0x000000, "Member 'HWCharacterItem_IsInRotation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_IsInRotation, ReturnValue) == 0x000008, "Member 'HWCharacterItem_IsInRotation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterItem.SetIsFavoriteGod
// 0x0010 (0x0010 - 0x0000)
struct HWCharacterItem_SetIsFavoriteGod final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFavorite;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCharacterItem_SetIsFavoriteGod) == 0x000008, "Wrong alignment on HWCharacterItem_SetIsFavoriteGod");
static_assert(sizeof(HWCharacterItem_SetIsFavoriteGod) == 0x000010, "Wrong size on HWCharacterItem_SetIsFavoriteGod");
static_assert(offsetof(HWCharacterItem_SetIsFavoriteGod, WorldContextObject) == 0x000000, "Member 'HWCharacterItem_SetIsFavoriteGod::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWCharacterItem_SetIsFavoriteGod, bIsFavorite) == 0x000008, "Member 'HWCharacterItem_SetIsFavoriteGod::bIsFavorite' has a wrong offset!");

// Function Hemingway.HWCharacterItem.ValidatePantheon
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterItem_ValidatePantheon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterItem_ValidatePantheon) == 0x000001, "Wrong alignment on HWCharacterItem_ValidatePantheon");
static_assert(sizeof(HWCharacterItem_ValidatePantheon) == 0x000001, "Wrong size on HWCharacterItem_ValidatePantheon");
static_assert(offsetof(HWCharacterItem_ValidatePantheon, ReturnValue) == 0x000000, "Member 'HWCharacterItem_ValidatePantheon::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Interact.OnAvatarDamaged
// 0x0070 (0x0070 - 0x0000)
struct HWAbility_Interact_OnAvatarDamaged final
{
public:
	struct FDamageEventData                       DamgageEventData;                                  // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Interact_OnAvatarDamaged) == 0x000008, "Wrong alignment on HWAbility_Interact_OnAvatarDamaged");
static_assert(sizeof(HWAbility_Interact_OnAvatarDamaged) == 0x000070, "Wrong size on HWAbility_Interact_OnAvatarDamaged");
static_assert(offsetof(HWAbility_Interact_OnAvatarDamaged, DamgageEventData) == 0x000000, "Member 'HWAbility_Interact_OnAvatarDamaged::DamgageEventData' has a wrong offset!");

// Function Hemingway.HWAbility_Interact.OnInteractionEnded
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Interact_OnInteractionEnded final
{
public:
	bool                                          bWasCancelled;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Interact_OnInteractionEnded) == 0x000001, "Wrong alignment on HWAbility_Interact_OnInteractionEnded");
static_assert(sizeof(HWAbility_Interact_OnInteractionEnded) == 0x000001, "Wrong size on HWAbility_Interact_OnInteractionEnded");
static_assert(offsetof(HWAbility_Interact_OnInteractionEnded, bWasCancelled) == 0x000000, "Member 'HWAbility_Interact_OnInteractionEnded::bWasCancelled' has a wrong offset!");

// Function Hemingway.HWAbility_Interact.FindClosestInteractable
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Interact_FindClosestInteractable final
{
public:
	const class AActor*                           Avatar;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWInteractableComponent*               ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Interact_FindClosestInteractable) == 0x000008, "Wrong alignment on HWAbility_Interact_FindClosestInteractable");
static_assert(sizeof(HWAbility_Interact_FindClosestInteractable) == 0x000010, "Wrong size on HWAbility_Interact_FindClosestInteractable");
static_assert(offsetof(HWAbility_Interact_FindClosestInteractable, Avatar) == 0x000000, "Member 'HWAbility_Interact_FindClosestInteractable::Avatar' has a wrong offset!");
static_assert(offsetof(HWAbility_Interact_FindClosestInteractable, ReturnValue) == 0x000008, "Member 'HWAbility_Interact_FindClosestInteractable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_ListenOtherAbilityFire.OnListenedAbilityFired
// 0x0030 (0x0030 - 0x0000)
struct HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  FiredAbilityTags;                                  // 0x0008(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0028(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired) == 0x000008, "Wrong alignment on HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired");
static_assert(sizeof(HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired) == 0x000030, "Wrong size on HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired");
static_assert(offsetof(HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired, AbilityHandle) == 0x000000, "Member 'HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired, FiredAbilityTags) == 0x000008, "Member 'HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired::FiredAbilityTags' has a wrong offset!");
static_assert(offsetof(HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired, FiringInstanceId) == 0x000028, "Member 'HWAbility_ListenOtherAbilityFire_OnListenedAbilityFired::FiringInstanceId' has a wrong offset!");

// Function Hemingway.HWAbility_PassiveItem.BP_OnGameplayEffectAppliedToOwner
// 0x0040 (0x0040 - 0x0000)
struct HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner final
{
public:
	const class AActor*                           Target;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EffectAssetTags;                                   // 0x0010(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecHandle              EffectSpecHandle;                                  // 0x0030(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner) == 0x000008, "Wrong alignment on HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner");
static_assert(sizeof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner) == 0x000040, "Wrong size on HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner");
static_assert(offsetof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner, Target) == 0x000000, "Member 'HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner::Target' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner, ActiveHandle) == 0x000008, "Member 'HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner::ActiveHandle' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner, EffectAssetTags) == 0x000010, "Member 'HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner::EffectAssetTags' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner, EffectSpecHandle) == 0x000030, "Member 'HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToOwner::EffectSpecHandle' has a wrong offset!");

// Function Hemingway.HWAbility_PassiveItem.BP_OnGameplayEffectAppliedToTarget
// 0x0040 (0x0040 - 0x0000)
struct HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget final
{
public:
	const class AActor*                           Target;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EffectAssetTags;                                   // 0x0010(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecHandle              EffectSpecHandle;                                  // 0x0030(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget) == 0x000008, "Wrong alignment on HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget");
static_assert(sizeof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget) == 0x000040, "Wrong size on HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget");
static_assert(offsetof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget, Target) == 0x000000, "Member 'HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget::Target' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget, ActiveHandle) == 0x000008, "Member 'HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget::ActiveHandle' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget, EffectAssetTags) == 0x000010, "Member 'HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget::EffectAssetTags' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget, EffectSpecHandle) == 0x000030, "Member 'HWAbility_PassiveItem_BP_OnGameplayEffectAppliedToTarget::EffectSpecHandle' has a wrong offset!");

// Function Hemingway.HWAbility_PassiveItem.OnAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_PassiveItem_OnAbilityEnded final
{
public:
	const class UGameplayAbility*                 EndedAbility;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_PassiveItem_OnAbilityEnded) == 0x000008, "Wrong alignment on HWAbility_PassiveItem_OnAbilityEnded");
static_assert(sizeof(HWAbility_PassiveItem_OnAbilityEnded) == 0x000008, "Wrong size on HWAbility_PassiveItem_OnAbilityEnded");
static_assert(offsetof(HWAbility_PassiveItem_OnAbilityEnded, EndedAbility) == 0x000000, "Member 'HWAbility_PassiveItem_OnAbilityEnded::EndedAbility' has a wrong offset!");

// Function Hemingway.HWAbility_PassiveItem.OnAbilityFired
// 0x0030 (0x0030 - 0x0000)
struct HWAbility_PassiveItem_OnAbilityFired final
{
public:
	struct FGameplayAbilitySpecHandle             FiredAbilityHandle;                                // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  FiredAbilityTags;                                  // 0x0008(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0028(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_PassiveItem_OnAbilityFired) == 0x000008, "Wrong alignment on HWAbility_PassiveItem_OnAbilityFired");
static_assert(sizeof(HWAbility_PassiveItem_OnAbilityFired) == 0x000030, "Wrong size on HWAbility_PassiveItem_OnAbilityFired");
static_assert(offsetof(HWAbility_PassiveItem_OnAbilityFired, FiredAbilityHandle) == 0x000000, "Member 'HWAbility_PassiveItem_OnAbilityFired::FiredAbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_OnAbilityFired, FiredAbilityTags) == 0x000008, "Member 'HWAbility_PassiveItem_OnAbilityFired::FiredAbilityTags' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_OnAbilityFired, FiringInstanceId) == 0x000028, "Member 'HWAbility_PassiveItem_OnAbilityFired::FiringInstanceId' has a wrong offset!");

// Function Hemingway.HWAbility_PassiveItem.OnGameplayEffectAppliedToOwner
// 0x0020 (0x0020 - 0x0000)
struct HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0008(0x0010)(Parm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x0018(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner) == 0x000008, "Wrong alignment on HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner");
static_assert(sizeof(HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner) == 0x000020, "Wrong size on HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner");
static_assert(offsetof(HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner, Owner) == 0x000000, "Member 'HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner::Owner' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner, SpecHandle) == 0x000008, "Member 'HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner::SpecHandle' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner, ActiveHandle) == 0x000018, "Member 'HWAbility_PassiveItem_OnGameplayEffectAppliedToOwner::ActiveHandle' has a wrong offset!");

// Function Hemingway.HWAbility_PassiveItem.OnGameplayEffectAppliedToTarget
// 0x0020 (0x0020 - 0x0000)
struct HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0008(0x0010)(Parm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x0018(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget) == 0x000008, "Wrong alignment on HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget");
static_assert(sizeof(HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget) == 0x000020, "Wrong size on HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget");
static_assert(offsetof(HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget, Target) == 0x000000, "Member 'HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget::Target' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget, SpecHandle) == 0x000008, "Member 'HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget::SpecHandle' has a wrong offset!");
static_assert(offsetof(HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget, ActiveHandle) == 0x000018, "Member 'HWAbility_PassiveItem_OnGameplayEffectAppliedToTarget::ActiveHandle' has a wrong offset!");

// Function Hemingway.HWAbility_PassiveItem.OnOwnerDealtDamage
// 0x0070 (0x0070 - 0x0000)
struct HWAbility_PassiveItem_OnOwnerDealtDamage final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_PassiveItem_OnOwnerDealtDamage) == 0x000008, "Wrong alignment on HWAbility_PassiveItem_OnOwnerDealtDamage");
static_assert(sizeof(HWAbility_PassiveItem_OnOwnerDealtDamage) == 0x000070, "Wrong size on HWAbility_PassiveItem_OnOwnerDealtDamage");
static_assert(offsetof(HWAbility_PassiveItem_OnOwnerDealtDamage, DamageEventData) == 0x000000, "Member 'HWAbility_PassiveItem_OnOwnerDealtDamage::DamageEventData' has a wrong offset!");

// Function Hemingway.HWAutoBuyComponent.OnShopVendorChanged
// 0x0010 (0x0010 - 0x0000)
struct HWAutoBuyComponent_OnShopVendorChanged final
{
public:
	class UHWInventoryManagerComponent*           InventoryManagerComponent;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWShopVendorVolume*              NewShop;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoBuyComponent_OnShopVendorChanged) == 0x000008, "Wrong alignment on HWAutoBuyComponent_OnShopVendorChanged");
static_assert(sizeof(HWAutoBuyComponent_OnShopVendorChanged) == 0x000010, "Wrong size on HWAutoBuyComponent_OnShopVendorChanged");
static_assert(offsetof(HWAutoBuyComponent_OnShopVendorChanged, InventoryManagerComponent) == 0x000000, "Member 'HWAutoBuyComponent_OnShopVendorChanged::InventoryManagerComponent' has a wrong offset!");
static_assert(offsetof(HWAutoBuyComponent_OnShopVendorChanged, NewShop) == 0x000008, "Member 'HWAutoBuyComponent_OnShopVendorChanged::NewShop' has a wrong offset!");

// Function Hemingway.HWAutoBuyComponent.GetAutoBuyState
// 0x0001 (0x0001 - 0x0000)
struct HWAutoBuyComponent_GetAutoBuyState final
{
public:
	EHWAutoBuyState                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoBuyComponent_GetAutoBuyState) == 0x000001, "Wrong alignment on HWAutoBuyComponent_GetAutoBuyState");
static_assert(sizeof(HWAutoBuyComponent_GetAutoBuyState) == 0x000001, "Wrong size on HWAutoBuyComponent_GetAutoBuyState");
static_assert(offsetof(HWAutoBuyComponent_GetAutoBuyState, ReturnValue) == 0x000000, "Member 'HWAutoBuyComponent_GetAutoBuyState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAutoBuyComponent.IsAllowedToUseAutoBuy
// 0x0001 (0x0001 - 0x0000)
struct HWAutoBuyComponent_IsAllowedToUseAutoBuy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoBuyComponent_IsAllowedToUseAutoBuy) == 0x000001, "Wrong alignment on HWAutoBuyComponent_IsAllowedToUseAutoBuy");
static_assert(sizeof(HWAutoBuyComponent_IsAllowedToUseAutoBuy) == 0x000001, "Wrong size on HWAutoBuyComponent_IsAllowedToUseAutoBuy");
static_assert(offsetof(HWAutoBuyComponent_IsAllowedToUseAutoBuy, ReturnValue) == 0x000000, "Member 'HWAutoBuyComponent_IsAllowedToUseAutoBuy::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Push.OnActorBump
// 0x0110 (0x0110 - 0x0000)
struct HWAbility_Push_OnActorBump final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0028(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Push_OnActorBump) == 0x000008, "Wrong alignment on HWAbility_Push_OnActorBump");
static_assert(sizeof(HWAbility_Push_OnActorBump) == 0x000110, "Wrong size on HWAbility_Push_OnActorBump");
static_assert(offsetof(HWAbility_Push_OnActorBump, SelfActor) == 0x000000, "Member 'HWAbility_Push_OnActorBump::SelfActor' has a wrong offset!");
static_assert(offsetof(HWAbility_Push_OnActorBump, OtherActor) == 0x000008, "Member 'HWAbility_Push_OnActorBump::OtherActor' has a wrong offset!");
static_assert(offsetof(HWAbility_Push_OnActorBump, NormalImpulse) == 0x000010, "Member 'HWAbility_Push_OnActorBump::NormalImpulse' has a wrong offset!");
static_assert(offsetof(HWAbility_Push_OnActorBump, Hit) == 0x000028, "Member 'HWAbility_Push_OnActorBump::Hit' has a wrong offset!");

// Function Hemingway.HWAbility_Push.OnActorHandleSuccessfulBump
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Push_OnActorHandleSuccessfulBump final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Push_OnActorHandleSuccessfulBump) == 0x000008, "Wrong alignment on HWAbility_Push_OnActorHandleSuccessfulBump");
static_assert(sizeof(HWAbility_Push_OnActorHandleSuccessfulBump) == 0x000010, "Wrong size on HWAbility_Push_OnActorHandleSuccessfulBump");
static_assert(offsetof(HWAbility_Push_OnActorHandleSuccessfulBump, SelfActor) == 0x000000, "Member 'HWAbility_Push_OnActorHandleSuccessfulBump::SelfActor' has a wrong offset!");
static_assert(offsetof(HWAbility_Push_OnActorHandleSuccessfulBump, OtherActor) == 0x000008, "Member 'HWAbility_Push_OnActorHandleSuccessfulBump::OtherActor' has a wrong offset!");

// Function Hemingway.HWAbility_Push.OnActorInitialBump
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Push_OnActorInitialBump final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Push_OnActorInitialBump) == 0x000008, "Wrong alignment on HWAbility_Push_OnActorInitialBump");
static_assert(sizeof(HWAbility_Push_OnActorInitialBump) == 0x000010, "Wrong size on HWAbility_Push_OnActorInitialBump");
static_assert(offsetof(HWAbility_Push_OnActorInitialBump, SelfActor) == 0x000000, "Member 'HWAbility_Push_OnActorInitialBump::SelfActor' has a wrong offset!");
static_assert(offsetof(HWAbility_Push_OnActorInitialBump, OtherActor) == 0x000008, "Member 'HWAbility_Push_OnActorInitialBump::OtherActor' has a wrong offset!");

// Function Hemingway.HWAbility_Push.OnActorOverlap
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Push_OnActorOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Push_OnActorOverlap) == 0x000008, "Wrong alignment on HWAbility_Push_OnActorOverlap");
static_assert(sizeof(HWAbility_Push_OnActorOverlap) == 0x000010, "Wrong size on HWAbility_Push_OnActorOverlap");
static_assert(offsetof(HWAbility_Push_OnActorOverlap, OverlappedActor) == 0x000000, "Member 'HWAbility_Push_OnActorOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(HWAbility_Push_OnActorOverlap, OtherActor) == 0x000008, "Member 'HWAbility_Push_OnActorOverlap::OtherActor' has a wrong offset!");

// Function Hemingway.HWAbility_Push.OnPushEnded
// 0x0018 (0x0018 - 0x0000)
struct HWAbility_Push_OnPushEnded final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Push_OnPushEnded) == 0x000008, "Wrong alignment on HWAbility_Push_OnPushEnded");
static_assert(sizeof(HWAbility_Push_OnPushEnded) == 0x000018, "Wrong size on HWAbility_Push_OnPushEnded");
static_assert(offsetof(HWAbility_Push_OnPushEnded, TweenInstance) == 0x000000, "Member 'HWAbility_Push_OnPushEnded::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbility_Push_OnPushEnded, TweenTarget) == 0x000008, "Member 'HWAbility_Push_OnPushEnded::TweenTarget' has a wrong offset!");
static_assert(offsetof(HWAbility_Push_OnPushEnded, EndTweenReason) == 0x000010, "Member 'HWAbility_Push_OnPushEnded::EndTweenReason' has a wrong offset!");

// Function Hemingway.HWAbility_Reflect.OnDamageBlocked
// 0x0050 (0x0050 - 0x0000)
struct HWAbility_Reflect_OnDamageBlocked final
{
public:
	struct FBlockDamageEventData                  BlockDamageEventData;                              // 0x0000(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Reflect_OnDamageBlocked) == 0x000008, "Wrong alignment on HWAbility_Reflect_OnDamageBlocked");
static_assert(sizeof(HWAbility_Reflect_OnDamageBlocked) == 0x000050, "Wrong size on HWAbility_Reflect_OnDamageBlocked");
static_assert(offsetof(HWAbility_Reflect_OnDamageBlocked, BlockDamageEventData) == 0x000000, "Member 'HWAbility_Reflect_OnDamageBlocked::BlockDamageEventData' has a wrong offset!");

// Function Hemingway.HWAbility_Reflect.OnDamageTaken
// 0x0070 (0x0070 - 0x0000)
struct HWAbility_Reflect_OnDamageTaken final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Reflect_OnDamageTaken) == 0x000008, "Wrong alignment on HWAbility_Reflect_OnDamageTaken");
static_assert(sizeof(HWAbility_Reflect_OnDamageTaken) == 0x000070, "Wrong size on HWAbility_Reflect_OnDamageTaken");
static_assert(offsetof(HWAbility_Reflect_OnDamageTaken, DamageEventData) == 0x000000, "Member 'HWAbility_Reflect_OnDamageTaken::DamageEventData' has a wrong offset!");

// Function Hemingway.HWAbility_Trail.BP_OnTrailActivated
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Trail_BP_OnTrailActivated final
{
public:
	class AHWDeployable_Trail*                    Trail;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Trail_BP_OnTrailActivated) == 0x000008, "Wrong alignment on HWAbility_Trail_BP_OnTrailActivated");
static_assert(sizeof(HWAbility_Trail_BP_OnTrailActivated) == 0x000008, "Wrong size on HWAbility_Trail_BP_OnTrailActivated");
static_assert(offsetof(HWAbility_Trail_BP_OnTrailActivated, Trail) == 0x000000, "Member 'HWAbility_Trail_BP_OnTrailActivated::Trail' has a wrong offset!");

// Function Hemingway.HWAbility_Trail.BP_OnTrailDeactivated
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Trail_BP_OnTrailDeactivated final
{
public:
	class AHWDeployable_Trail*                    Trail;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Trail_BP_OnTrailDeactivated) == 0x000008, "Wrong alignment on HWAbility_Trail_BP_OnTrailDeactivated");
static_assert(sizeof(HWAbility_Trail_BP_OnTrailDeactivated) == 0x000008, "Wrong size on HWAbility_Trail_BP_OnTrailDeactivated");
static_assert(offsetof(HWAbility_Trail_BP_OnTrailDeactivated, Trail) == 0x000000, "Member 'HWAbility_Trail_BP_OnTrailDeactivated::Trail' has a wrong offset!");

// Function Hemingway.HWAbility_Trail.OnTrailBeginOverlap
// 0x0068 (0x0068 - 0x0000)
struct HWAbility_Trail_OnTrailBeginOverlap final
{
public:
	class AHWDeployable_Trail*                    Trail;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OverlappedTarget;                                  // 0x0008(0x0028)(Parm, NativeAccessSpecifierPublic)
	struct FHWSplineOverlapInfo                   TrailOverlapInfo;                                  // 0x0030(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Trail_OnTrailBeginOverlap) == 0x000008, "Wrong alignment on HWAbility_Trail_OnTrailBeginOverlap");
static_assert(sizeof(HWAbility_Trail_OnTrailBeginOverlap) == 0x000068, "Wrong size on HWAbility_Trail_OnTrailBeginOverlap");
static_assert(offsetof(HWAbility_Trail_OnTrailBeginOverlap, Trail) == 0x000000, "Member 'HWAbility_Trail_OnTrailBeginOverlap::Trail' has a wrong offset!");
static_assert(offsetof(HWAbility_Trail_OnTrailBeginOverlap, OverlappedTarget) == 0x000008, "Member 'HWAbility_Trail_OnTrailBeginOverlap::OverlappedTarget' has a wrong offset!");
static_assert(offsetof(HWAbility_Trail_OnTrailBeginOverlap, TrailOverlapInfo) == 0x000030, "Member 'HWAbility_Trail_OnTrailBeginOverlap::TrailOverlapInfo' has a wrong offset!");

// Function Hemingway.HWAbility_Trail.OnTrailEndOverlap
// 0x0030 (0x0030 - 0x0000)
struct HWAbility_Trail_OnTrailEndOverlap final
{
public:
	class AHWDeployable_Trail*                    Trail;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       OverlappedTarget;                                  // 0x0008(0x0028)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Trail_OnTrailEndOverlap) == 0x000008, "Wrong alignment on HWAbility_Trail_OnTrailEndOverlap");
static_assert(sizeof(HWAbility_Trail_OnTrailEndOverlap) == 0x000030, "Wrong size on HWAbility_Trail_OnTrailEndOverlap");
static_assert(offsetof(HWAbility_Trail_OnTrailEndOverlap, Trail) == 0x000000, "Member 'HWAbility_Trail_OnTrailEndOverlap::Trail' has a wrong offset!");
static_assert(offsetof(HWAbility_Trail_OnTrailEndOverlap, OverlappedTarget) == 0x000008, "Member 'HWAbility_Trail_OnTrailEndOverlap::OverlappedTarget' has a wrong offset!");

// Function Hemingway.HWAbility_Trail.OnTrailStateChanged
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Trail_OnTrailStateChanged final
{
public:
	class AHWDeployable_Trail*                    Trail;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTrailActive;                                    // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Trail_OnTrailStateChanged) == 0x000008, "Wrong alignment on HWAbility_Trail_OnTrailStateChanged");
static_assert(sizeof(HWAbility_Trail_OnTrailStateChanged) == 0x000010, "Wrong size on HWAbility_Trail_OnTrailStateChanged");
static_assert(offsetof(HWAbility_Trail_OnTrailStateChanged, Trail) == 0x000000, "Member 'HWAbility_Trail_OnTrailStateChanged::Trail' has a wrong offset!");
static_assert(offsetof(HWAbility_Trail_OnTrailStateChanged, bIsTrailActive) == 0x000008, "Member 'HWAbility_Trail_OnTrailStateChanged::bIsTrailActive' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_Trail.GetTrail
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_Attack_Trail_GetTrail final
{
public:
	class AHWDeployable_Trail*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Attack_Trail_GetTrail) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_Trail_GetTrail");
static_assert(sizeof(HWAbilityTask_Attack_Trail_GetTrail) == 0x000008, "Wrong size on HWAbilityTask_Attack_Trail_GetTrail");
static_assert(offsetof(HWAbilityTask_Attack_Trail_GetTrail, ReturnValue) == 0x000000, "Member 'HWAbilityTask_Attack_Trail_GetTrail::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstGod.OnGodASCUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_AnimInstGod_OnGodASCUpdated final
{
public:
	class UHWAbilitySystemComponent*              UpdatedASC;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OldAbilitySystem;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstGod_OnGodASCUpdated) == 0x000008, "Wrong alignment on HWCharacter_AnimInstGod_OnGodASCUpdated");
static_assert(sizeof(HWCharacter_AnimInstGod_OnGodASCUpdated) == 0x000010, "Wrong size on HWCharacter_AnimInstGod_OnGodASCUpdated");
static_assert(offsetof(HWCharacter_AnimInstGod_OnGodASCUpdated, UpdatedASC) == 0x000000, "Member 'HWCharacter_AnimInstGod_OnGodASCUpdated::UpdatedASC' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstGod_OnGodASCUpdated, OldAbilitySystem) == 0x000008, "Member 'HWCharacter_AnimInstGod_OnGodASCUpdated::OldAbilitySystem' has a wrong offset!");

// Function Hemingway.HWCharacter_AnimInstGod.OnStatusGodTagsUpdated
// 0x000C (0x000C - 0x0000)
struct HWCharacter_AnimInstGod_OnStatusGodTagsUpdated final
{
public:
	struct FGameplayTag                           UpdatedStatusTag;                                  // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStackCount;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_AnimInstGod_OnStatusGodTagsUpdated) == 0x000004, "Wrong alignment on HWCharacter_AnimInstGod_OnStatusGodTagsUpdated");
static_assert(sizeof(HWCharacter_AnimInstGod_OnStatusGodTagsUpdated) == 0x00000C, "Wrong size on HWCharacter_AnimInstGod_OnStatusGodTagsUpdated");
static_assert(offsetof(HWCharacter_AnimInstGod_OnStatusGodTagsUpdated, UpdatedStatusTag) == 0x000000, "Member 'HWCharacter_AnimInstGod_OnStatusGodTagsUpdated::UpdatedStatusTag' has a wrong offset!");
static_assert(offsetof(HWCharacter_AnimInstGod_OnStatusGodTagsUpdated, NewStackCount) == 0x000008, "Member 'HWCharacter_AnimInstGod_OnStatusGodTagsUpdated::NewStackCount' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayGrab.PerformGameplayGrabOnTarget
// 0x0038 (0x0038 - 0x0000)
struct HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWGameplayGrab>            Grab;                                              // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      GrabSource_0;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      GrabTarget;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationOverride_0;                                // 0x0028(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_GameplayGrab*            ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget");
static_assert(sizeof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget) == 0x000038, "Wrong size on HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget, OwningAbility) == 0x000000, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget, Grab) == 0x000010, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget::Grab' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget, GrabSource_0) == 0x000018, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget::GrabSource_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget, GrabTarget) == 0x000020, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget::GrabTarget' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget, DurationOverride_0) == 0x000028, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget::DurationOverride_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget, ReturnValue) == 0x000030, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayGrab.PerformGameplayGrabOnTargets
// 0x0040 (0x0040 - 0x0000)
struct HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWGameplayGrab>            Grab;                                              // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      GrabSource_0;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AHWCharacter_Base*>              GrabTargets_0;                                     // 0x0020(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DurationOverride_0;                                // 0x0030(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_GameplayGrab*            ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets");
static_assert(sizeof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets) == 0x000040, "Wrong size on HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets, OwningAbility) == 0x000000, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets, Grab) == 0x000010, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets::Grab' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets, GrabSource_0) == 0x000018, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets::GrabSource_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets, GrabTargets_0) == 0x000020, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets::GrabTargets_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets, DurationOverride_0) == 0x000030, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets::DurationOverride_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets, ReturnValue) == 0x000038, "Member 'HWAbilityTask_GameplayGrab_PerformGameplayGrabOnTargets::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayGrab.HandleTagUpdated_CCImmunity
// 0x000C (0x000C - 0x0000)
struct HWAbilityTask_GameplayGrab_HandleTagUpdated_CCImmunity final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayGrab_HandleTagUpdated_CCImmunity) == 0x000004, "Wrong alignment on HWAbilityTask_GameplayGrab_HandleTagUpdated_CCImmunity");
static_assert(sizeof(HWAbilityTask_GameplayGrab_HandleTagUpdated_CCImmunity) == 0x00000C, "Wrong size on HWAbilityTask_GameplayGrab_HandleTagUpdated_CCImmunity");
static_assert(offsetof(HWAbilityTask_GameplayGrab_HandleTagUpdated_CCImmunity, CallbackTag) == 0x000000, "Member 'HWAbilityTask_GameplayGrab_HandleTagUpdated_CCImmunity::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_HandleTagUpdated_CCImmunity, NewCount) == 0x000008, "Member 'HWAbilityTask_GameplayGrab_HandleTagUpdated_CCImmunity::NewCount' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayGrab.OnGrabEnded
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_GameplayGrab_OnGrabEnded final
{
public:
	class UHWGameplayGrab*                        Grab;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndGrabReason                              EndGrabReason;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_GameplayGrab_OnGrabEnded) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayGrab_OnGrabEnded");
static_assert(sizeof(HWAbilityTask_GameplayGrab_OnGrabEnded) == 0x000010, "Wrong size on HWAbilityTask_GameplayGrab_OnGrabEnded");
static_assert(offsetof(HWAbilityTask_GameplayGrab_OnGrabEnded, Grab) == 0x000000, "Member 'HWAbilityTask_GameplayGrab_OnGrabEnded::Grab' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayGrab_OnGrabEnded, EndGrabReason) == 0x000008, "Member 'HWAbilityTask_GameplayGrab_OnGrabEnded::EndGrabReason' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayGrab.OnGrabStarted
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_GameplayGrab_OnGrabStarted final
{
public:
	class UHWGameplayGrab*                        Grab;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayGrab_OnGrabStarted) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayGrab_OnGrabStarted");
static_assert(sizeof(HWAbilityTask_GameplayGrab_OnGrabStarted) == 0x000008, "Wrong size on HWAbilityTask_GameplayGrab_OnGrabStarted");
static_assert(offsetof(HWAbilityTask_GameplayGrab_OnGrabStarted, Grab) == 0x000000, "Member 'HWAbilityTask_GameplayGrab_OnGrabStarted::Grab' has a wrong offset!");

// Function Hemingway.HWAbilityTask_PhasedMontage.PlayPhasedMontage
// 0x0038 (0x0038 - 0x0000)
struct HWAbilityTask_PhasedMontage_PlayPhasedMontage final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay_0;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSection;                                      // 0x001C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootMotionTranslationScale;                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartWithRootMotionDisabled;                       // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ContinueMontageOnAbilityEnd;                       // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ContinueMontageOnAbilityCancel;                    // 0x002A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_PhasedMontage*           ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_PhasedMontage_PlayPhasedMontage) == 0x000008, "Wrong alignment on HWAbilityTask_PhasedMontage_PlayPhasedMontage");
static_assert(sizeof(HWAbilityTask_PhasedMontage_PlayPhasedMontage) == 0x000038, "Wrong size on HWAbilityTask_PhasedMontage_PlayPhasedMontage");
static_assert(offsetof(HWAbilityTask_PhasedMontage_PlayPhasedMontage, OwningAbility) == 0x000000, "Member 'HWAbilityTask_PhasedMontage_PlayPhasedMontage::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_PhasedMontage_PlayPhasedMontage, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_PhasedMontage_PlayPhasedMontage::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_PhasedMontage_PlayPhasedMontage, MontageToPlay_0) == 0x000010, "Member 'HWAbilityTask_PhasedMontage_PlayPhasedMontage::MontageToPlay_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_PhasedMontage_PlayPhasedMontage, Rate) == 0x000018, "Member 'HWAbilityTask_PhasedMontage_PlayPhasedMontage::Rate' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_PhasedMontage_PlayPhasedMontage, StartSection) == 0x00001C, "Member 'HWAbilityTask_PhasedMontage_PlayPhasedMontage::StartSection' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_PhasedMontage_PlayPhasedMontage, RootMotionTranslationScale) == 0x000024, "Member 'HWAbilityTask_PhasedMontage_PlayPhasedMontage::RootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_PhasedMontage_PlayPhasedMontage, StartWithRootMotionDisabled) == 0x000028, "Member 'HWAbilityTask_PhasedMontage_PlayPhasedMontage::StartWithRootMotionDisabled' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_PhasedMontage_PlayPhasedMontage, ContinueMontageOnAbilityEnd) == 0x000029, "Member 'HWAbilityTask_PhasedMontage_PlayPhasedMontage::ContinueMontageOnAbilityEnd' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_PhasedMontage_PlayPhasedMontage, ContinueMontageOnAbilityCancel) == 0x00002A, "Member 'HWAbilityTask_PhasedMontage_PlayPhasedMontage::ContinueMontageOnAbilityCancel' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_PhasedMontage_PlayPhasedMontage, ReturnValue) == 0x000030, "Member 'HWAbilityTask_PhasedMontage_PlayPhasedMontage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_PhasedMontage.GetAnimInstance
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_PhasedMontage_GetAnimInstance final
{
public:
	class UAnimInstance*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_PhasedMontage_GetAnimInstance) == 0x000008, "Wrong alignment on HWAbilityTask_PhasedMontage_GetAnimInstance");
static_assert(sizeof(HWAbilityTask_PhasedMontage_GetAnimInstance) == 0x000008, "Wrong size on HWAbilityTask_PhasedMontage_GetAnimInstance");
static_assert(offsetof(HWAbilityTask_PhasedMontage_GetAnimInstance, ReturnValue) == 0x000000, "Member 'HWAbilityTask_PhasedMontage_GetAnimInstance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_PhasedMontage.GetMontage
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_PhasedMontage_GetMontage final
{
public:
	class UAnimMontage*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_PhasedMontage_GetMontage) == 0x000008, "Wrong alignment on HWAbilityTask_PhasedMontage_GetMontage");
static_assert(sizeof(HWAbilityTask_PhasedMontage_GetMontage) == 0x000008, "Wrong size on HWAbilityTask_PhasedMontage_GetMontage");
static_assert(offsetof(HWAbilityTask_PhasedMontage_GetMontage, ReturnValue) == 0x000000, "Member 'HWAbilityTask_PhasedMontage_GetMontage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_PhasedMontage.IsMontagePlaying
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityTask_PhasedMontage_IsMontagePlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_PhasedMontage_IsMontagePlaying) == 0x000001, "Wrong alignment on HWAbilityTask_PhasedMontage_IsMontagePlaying");
static_assert(sizeof(HWAbilityTask_PhasedMontage_IsMontagePlaying) == 0x000001, "Wrong size on HWAbilityTask_PhasedMontage_IsMontagePlaying");
static_assert(offsetof(HWAbilityTask_PhasedMontage_IsMontagePlaying, ReturnValue) == 0x000000, "Member 'HWAbilityTask_PhasedMontage_IsMontagePlaying::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_PhasedMontage.IsMontageStopped
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityTask_PhasedMontage_IsMontageStopped final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_PhasedMontage_IsMontageStopped) == 0x000001, "Wrong alignment on HWAbilityTask_PhasedMontage_IsMontageStopped");
static_assert(sizeof(HWAbilityTask_PhasedMontage_IsMontageStopped) == 0x000001, "Wrong size on HWAbilityTask_PhasedMontage_IsMontageStopped");
static_assert(offsetof(HWAbilityTask_PhasedMontage_IsMontageStopped, ReturnValue) == 0x000000, "Member 'HWAbilityTask_PhasedMontage_IsMontageStopped::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAccoladeComponent.AddPlayerAccoladeEvent
// 0x0090 (0x0090 - 0x0000)
struct HWAccoladeComponent_AddPlayerAccoladeEvent final
{
public:
	struct FGameplayTag                           AccoladeTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventContext                        AccoladeContext;                                   // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAccoladeComponent_AddPlayerAccoladeEvent) == 0x000008, "Wrong alignment on HWAccoladeComponent_AddPlayerAccoladeEvent");
static_assert(sizeof(HWAccoladeComponent_AddPlayerAccoladeEvent) == 0x000090, "Wrong size on HWAccoladeComponent_AddPlayerAccoladeEvent");
static_assert(offsetof(HWAccoladeComponent_AddPlayerAccoladeEvent, AccoladeTag) == 0x000000, "Member 'HWAccoladeComponent_AddPlayerAccoladeEvent::AccoladeTag' has a wrong offset!");
static_assert(offsetof(HWAccoladeComponent_AddPlayerAccoladeEvent, AccoladeContext) == 0x000008, "Member 'HWAccoladeComponent_AddPlayerAccoladeEvent::AccoladeContext' has a wrong offset!");

// Function Hemingway.HWAccoladeComponent.AddTeamAccoladeEvent
// 0x0090 (0x0090 - 0x0000)
struct HWAccoladeComponent_AddTeamAccoladeEvent final
{
public:
	struct FGameplayTag                           AccoladeTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventContext                        AccoladeContext;                                   // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAccoladeComponent_AddTeamAccoladeEvent) == 0x000008, "Wrong alignment on HWAccoladeComponent_AddTeamAccoladeEvent");
static_assert(sizeof(HWAccoladeComponent_AddTeamAccoladeEvent) == 0x000090, "Wrong size on HWAccoladeComponent_AddTeamAccoladeEvent");
static_assert(offsetof(HWAccoladeComponent_AddTeamAccoladeEvent, AccoladeTag) == 0x000000, "Member 'HWAccoladeComponent_AddTeamAccoladeEvent::AccoladeTag' has a wrong offset!");
static_assert(offsetof(HWAccoladeComponent_AddTeamAccoladeEvent, AccoladeContext) == 0x000008, "Member 'HWAccoladeComponent_AddTeamAccoladeEvent::AccoladeContext' has a wrong offset!");

// Function Hemingway.HWAccoladeComponent.MulticastSendPlayerAccoladeToClient
// 0x0090 (0x0090 - 0x0000)
struct HWAccoladeComponent_MulticastSendPlayerAccoladeToClient final
{
public:
	struct FGameplayTag                           AccoladeTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventContext                        AccoladeContext;                                   // 0x0008(0x0088)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAccoladeComponent_MulticastSendPlayerAccoladeToClient) == 0x000008, "Wrong alignment on HWAccoladeComponent_MulticastSendPlayerAccoladeToClient");
static_assert(sizeof(HWAccoladeComponent_MulticastSendPlayerAccoladeToClient) == 0x000090, "Wrong size on HWAccoladeComponent_MulticastSendPlayerAccoladeToClient");
static_assert(offsetof(HWAccoladeComponent_MulticastSendPlayerAccoladeToClient, AccoladeTag) == 0x000000, "Member 'HWAccoladeComponent_MulticastSendPlayerAccoladeToClient::AccoladeTag' has a wrong offset!");
static_assert(offsetof(HWAccoladeComponent_MulticastSendPlayerAccoladeToClient, AccoladeContext) == 0x000008, "Member 'HWAccoladeComponent_MulticastSendPlayerAccoladeToClient::AccoladeContext' has a wrong offset!");

// Function Hemingway.HWAccoladeComponent.MulticastSendTeamAccoladeToClient
// 0x0090 (0x0090 - 0x0000)
struct HWAccoladeComponent_MulticastSendTeamAccoladeToClient final
{
public:
	struct FGameplayTag                           AccoladeTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWEventContext                        AccoladeContext;                                   // 0x0008(0x0088)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAccoladeComponent_MulticastSendTeamAccoladeToClient) == 0x000008, "Wrong alignment on HWAccoladeComponent_MulticastSendTeamAccoladeToClient");
static_assert(sizeof(HWAccoladeComponent_MulticastSendTeamAccoladeToClient) == 0x000090, "Wrong size on HWAccoladeComponent_MulticastSendTeamAccoladeToClient");
static_assert(offsetof(HWAccoladeComponent_MulticastSendTeamAccoladeToClient, AccoladeTag) == 0x000000, "Member 'HWAccoladeComponent_MulticastSendTeamAccoladeToClient::AccoladeTag' has a wrong offset!");
static_assert(offsetof(HWAccoladeComponent_MulticastSendTeamAccoladeToClient, AccoladeContext) == 0x000008, "Member 'HWAccoladeComponent_MulticastSendTeamAccoladeToClient::AccoladeContext' has a wrong offset!");

// Function Hemingway.HWAbilityTask_SpawnSpecialFXActor.SpawnSpecialFXActorTask
// 0x00A0 (0x00A0 - 0x0000)
struct HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHWActor_SpecialFX>         SpecialFXActorClass_0;                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InSpawnTransform;                                  // 0x0020(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorLifetime;                                     // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachToOwner;                                     // 0x0084(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName_0;                                      // 0x0088(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_SpawnSpecialFXActor*     ReturnValue;                                       // 0x0090(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask) == 0x000010, "Wrong alignment on HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask");
static_assert(sizeof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask) == 0x0000A0, "Wrong size on HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask, OwningAbility) == 0x000000, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask, SpecialFXActorClass_0) == 0x000010, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask::SpecialFXActorClass_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask, InSpawnTransform) == 0x000020, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask::InSpawnTransform' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask, ActorLifetime) == 0x000080, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask::ActorLifetime' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask, AttachToOwner) == 0x000084, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask::AttachToOwner' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask, SocketName_0) == 0x000088, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask::SocketName_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask, ReturnValue) == 0x000090, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTask::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_SpawnSpecialFXActor.SpawnSpecialFXActorTaskUsingAimData
// 0x0058 (0x0058 - 0x0000)
struct HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHWActor_SpecialFX>         SpecialFXActorClass_0;                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetAimData;                                     // 0x0018(0x0028)(Parm, NativeAccessSpecifierPublic)
	float                                         ActorLifetime;                                     // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToOwner;                                    // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName_0;                                      // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_SpawnSpecialFXActor*     ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData) == 0x000008, "Wrong alignment on HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData");
static_assert(sizeof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData) == 0x000058, "Wrong size on HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData, OwningAbility) == 0x000000, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData, SpecialFXActorClass_0) == 0x000010, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData::SpecialFXActorClass_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData, TargetAimData) == 0x000018, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData::TargetAimData' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData, ActorLifetime) == 0x000040, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData::ActorLifetime' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData, bAttachToOwner) == 0x000044, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData::bAttachToOwner' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData, SocketName_0) == 0x000048, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData::SocketName_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData, ReturnValue) == 0x000050, "Member 'HWAbilityTask_SpawnSpecialFXActor_SpawnSpecialFXActorTaskUsingAimData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterInfo.GetEmoteItemForTag
// 0x000C (0x000C - 0x0000)
struct HWCharacterInfo_GetEmoteItemForTag final
{
public:
	struct FGameplayTag                           EmoteTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterInfo_GetEmoteItemForTag) == 0x000004, "Wrong alignment on HWCharacterInfo_GetEmoteItemForTag");
static_assert(sizeof(HWCharacterInfo_GetEmoteItemForTag) == 0x00000C, "Wrong size on HWCharacterInfo_GetEmoteItemForTag");
static_assert(offsetof(HWCharacterInfo_GetEmoteItemForTag, EmoteTag) == 0x000000, "Member 'HWCharacterInfo_GetEmoteItemForTag::EmoteTag' has a wrong offset!");
static_assert(offsetof(HWCharacterInfo_GetEmoteItemForTag, ReturnValue) == 0x000008, "Member 'HWCharacterInfo_GetEmoteItemForTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Tether.UpdateBeamTetherEndPoint
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayCueNotify_Tether_UpdateBeamTetherEndPoint final
{
public:
	struct FVector                                EndPoint;                                          // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Tether_UpdateBeamTetherEndPoint) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Tether_UpdateBeamTetherEndPoint");
static_assert(sizeof(HWGameplayCueNotify_Tether_UpdateBeamTetherEndPoint) == 0x000018, "Wrong size on HWGameplayCueNotify_Tether_UpdateBeamTetherEndPoint");
static_assert(offsetof(HWGameplayCueNotify_Tether_UpdateBeamTetherEndPoint, EndPoint) == 0x000000, "Member 'HWGameplayCueNotify_Tether_UpdateBeamTetherEndPoint::EndPoint' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Tether.UpdateSplineTetherPoints
// 0x0030 (0x0030 - 0x0000)
struct HWGameplayCueNotify_Tether_UpdateSplineTetherPoints final
{
public:
	struct FVector                                StartPoint;                                        // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPoint;                                          // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Tether_UpdateSplineTetherPoints) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Tether_UpdateSplineTetherPoints");
static_assert(sizeof(HWGameplayCueNotify_Tether_UpdateSplineTetherPoints) == 0x000030, "Wrong size on HWGameplayCueNotify_Tether_UpdateSplineTetherPoints");
static_assert(offsetof(HWGameplayCueNotify_Tether_UpdateSplineTetherPoints, StartPoint) == 0x000000, "Member 'HWGameplayCueNotify_Tether_UpdateSplineTetherPoints::StartPoint' has a wrong offset!");
static_assert(offsetof(HWGameplayCueNotify_Tether_UpdateSplineTetherPoints, EndPoint) == 0x000018, "Member 'HWGameplayCueNotify_Tether_UpdateSplineTetherPoints::EndPoint' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Tether.GetTetherEndPoint
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayCueNotify_Tether_GetTetherEndPoint final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Tether_GetTetherEndPoint) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Tether_GetTetherEndPoint");
static_assert(sizeof(HWGameplayCueNotify_Tether_GetTetherEndPoint) == 0x000018, "Wrong size on HWGameplayCueNotify_Tether_GetTetherEndPoint");
static_assert(offsetof(HWGameplayCueNotify_Tether_GetTetherEndPoint, ReturnValue) == 0x000000, "Member 'HWGameplayCueNotify_Tether_GetTetherEndPoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Tether.GetTetherStartPoint
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayCueNotify_Tether_GetTetherStartPoint final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Tether_GetTetherStartPoint) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Tether_GetTetherStartPoint");
static_assert(sizeof(HWGameplayCueNotify_Tether_GetTetherStartPoint) == 0x000018, "Wrong size on HWGameplayCueNotify_Tether_GetTetherStartPoint");
static_assert(offsetof(HWGameplayCueNotify_Tether_GetTetherStartPoint, ReturnValue) == 0x000000, "Member 'HWGameplayCueNotify_Tether_GetTetherStartPoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Tether.IsActorValidForTether
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayCueNotify_Tether_IsActorValidForTether final
{
public:
	const class AActor*                           Target;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayCueNotify_Tether_IsActorValidForTether) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Tether_IsActorValidForTether");
static_assert(sizeof(HWGameplayCueNotify_Tether_IsActorValidForTether) == 0x000010, "Wrong size on HWGameplayCueNotify_Tether_IsActorValidForTether");
static_assert(offsetof(HWGameplayCueNotify_Tether_IsActorValidForTether, Target) == 0x000000, "Member 'HWGameplayCueNotify_Tether_IsActorValidForTether::Target' has a wrong offset!");
static_assert(offsetof(HWGameplayCueNotify_Tether_IsActorValidForTether, ReturnValue) == 0x000008, "Member 'HWGameplayCueNotify_Tether_IsActorValidForTether::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Tether.ShouldTetherBeHidden
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayCueNotify_Tether_ShouldTetherBeHidden final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Tether_ShouldTetherBeHidden) == 0x000001, "Wrong alignment on HWGameplayCueNotify_Tether_ShouldTetherBeHidden");
static_assert(sizeof(HWGameplayCueNotify_Tether_ShouldTetherBeHidden) == 0x000001, "Wrong size on HWGameplayCueNotify_Tether_ShouldTetherBeHidden");
static_assert(offsetof(HWGameplayCueNotify_Tether_ShouldTetherBeHidden, ReturnValue) == 0x000000, "Member 'HWGameplayCueNotify_Tether_ShouldTetherBeHidden::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.AbilityInputTagPressed
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_AbilityInputTagPressed final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_AbilityInputTagPressed) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_AbilityInputTagPressed");
static_assert(sizeof(HWAbilitySystemComponent_AbilityInputTagPressed) == 0x000008, "Wrong size on HWAbilitySystemComponent_AbilityInputTagPressed");
static_assert(offsetof(HWAbilitySystemComponent_AbilityInputTagPressed, InputTag) == 0x000000, "Member 'HWAbilitySystemComponent_AbilityInputTagPressed::InputTag' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.AbilityInputTagReleased
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_AbilityInputTagReleased final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_AbilityInputTagReleased) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_AbilityInputTagReleased");
static_assert(sizeof(HWAbilitySystemComponent_AbilityInputTagReleased) == 0x000008, "Wrong size on HWAbilitySystemComponent_AbilityInputTagReleased");
static_assert(offsetof(HWAbilitySystemComponent_AbilityInputTagReleased, InputTag) == 0x000000, "Member 'HWAbilitySystemComponent_AbilityInputTagReleased::InputTag' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.AddActiveEffectDynamicIgnoreTag
// 0x0010 (0x0010 - 0x0000)
struct HWAbilitySystemComponent_AddActiveEffectDynamicIgnoreTag final
{
public:
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_AddActiveEffectDynamicIgnoreTag) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_AddActiveEffectDynamicIgnoreTag");
static_assert(sizeof(HWAbilitySystemComponent_AddActiveEffectDynamicIgnoreTag) == 0x000010, "Wrong size on HWAbilitySystemComponent_AddActiveEffectDynamicIgnoreTag");
static_assert(offsetof(HWAbilitySystemComponent_AddActiveEffectDynamicIgnoreTag, ActiveHandle) == 0x000000, "Member 'HWAbilitySystemComponent_AddActiveEffectDynamicIgnoreTag::ActiveHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_AddActiveEffectDynamicIgnoreTag, Tag) == 0x000008, "Member 'HWAbilitySystemComponent_AddActiveEffectDynamicIgnoreTag::Tag' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.AddActiveEffectDynamicRequireTag
// 0x0010 (0x0010 - 0x0000)
struct HWAbilitySystemComponent_AddActiveEffectDynamicRequireTag final
{
public:
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_AddActiveEffectDynamicRequireTag) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_AddActiveEffectDynamicRequireTag");
static_assert(sizeof(HWAbilitySystemComponent_AddActiveEffectDynamicRequireTag) == 0x000010, "Wrong size on HWAbilitySystemComponent_AddActiveEffectDynamicRequireTag");
static_assert(offsetof(HWAbilitySystemComponent_AddActiveEffectDynamicRequireTag, ActiveHandle) == 0x000000, "Member 'HWAbilitySystemComponent_AddActiveEffectDynamicRequireTag::ActiveHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_AddActiveEffectDynamicRequireTag, Tag) == 0x000008, "Member 'HWAbilitySystemComponent_AddActiveEffectDynamicRequireTag::Tag' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.AddDynamicGameplayTag
// 0x000C (0x000C - 0x0000)
struct HWAbilitySystemComponent_AddDynamicGameplayTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldReplicate;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_AddDynamicGameplayTag) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_AddDynamicGameplayTag");
static_assert(sizeof(HWAbilitySystemComponent_AddDynamicGameplayTag) == 0x00000C, "Wrong size on HWAbilitySystemComponent_AddDynamicGameplayTag");
static_assert(offsetof(HWAbilitySystemComponent_AddDynamicGameplayTag, Tag) == 0x000000, "Member 'HWAbilitySystemComponent_AddDynamicGameplayTag::Tag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_AddDynamicGameplayTag, bShouldReplicate) == 0x000008, "Member 'HWAbilitySystemComponent_AddDynamicGameplayTag::bShouldReplicate' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.AddDynamicGameplayTags
// 0x0028 (0x0028 - 0x0000)
struct HWAbilitySystemComponent_AddDynamicGameplayTags final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bShouldReplicate;                                  // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_AddDynamicGameplayTags) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_AddDynamicGameplayTags");
static_assert(sizeof(HWAbilitySystemComponent_AddDynamicGameplayTags) == 0x000028, "Wrong size on HWAbilitySystemComponent_AddDynamicGameplayTags");
static_assert(offsetof(HWAbilitySystemComponent_AddDynamicGameplayTags, Tags) == 0x000000, "Member 'HWAbilitySystemComponent_AddDynamicGameplayTags::Tags' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_AddDynamicGameplayTags, bShouldReplicate) == 0x000020, "Member 'HWAbilitySystemComponent_AddDynamicGameplayTags::bShouldReplicate' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.AddForcedFiringInfo
// 0x0020 (0x0020 - 0x0000)
struct HWAbilitySystemComponent_AddForcedFiringInfo final
{
public:
	struct FHWForcedCharacterFiringInfo           ForcedFiringInfo;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_AddForcedFiringInfo) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_AddForcedFiringInfo");
static_assert(sizeof(HWAbilitySystemComponent_AddForcedFiringInfo) == 0x000020, "Wrong size on HWAbilitySystemComponent_AddForcedFiringInfo");
static_assert(offsetof(HWAbilitySystemComponent_AddForcedFiringInfo, ForcedFiringInfo) == 0x000000, "Member 'HWAbilitySystemComponent_AddForcedFiringInfo::ForcedFiringInfo' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.AdjustSubscribedAttributeFromCombatEvent
// 0x0010 (0x0010 - 0x0000)
struct HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent final
{
public:
	EHWAdjustAttributeEventType                   EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWAttributeModifierEnum                      AttributeToAdjust;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreMultiplyAdditiveDelta;                          // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoefficientMultiplier;                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostMultiplyAdditiveDelta;                         // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent");
static_assert(sizeof(HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent) == 0x000010, "Wrong size on HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent");
static_assert(offsetof(HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent, EventType) == 0x000000, "Member 'HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent::EventType' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent, AttributeToAdjust) == 0x000001, "Member 'HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent::AttributeToAdjust' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent, PreMultiplyAdditiveDelta) == 0x000004, "Member 'HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent::PreMultiplyAdditiveDelta' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent, CoefficientMultiplier) == 0x000008, "Member 'HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent::CoefficientMultiplier' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent, PostMultiplyAdditiveDelta) == 0x00000C, "Member 'HWAbilitySystemComponent_AdjustSubscribedAttributeFromCombatEvent::PostMultiplyAdditiveDelta' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.BP_GetActiveEffectsTimeRemainingAndDuration
// 0x01D0 (0x01D0 - 0x0000)
struct HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration final
{
public:
	struct FGameplayEffectQuery                   Query;                                             // 0x0000(0x01B0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<float>                                 TimesRemaining;                                    // 0x01B0(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Durations;                                         // 0x01C0(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration");
static_assert(sizeof(HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration) == 0x0001D0, "Wrong size on HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration");
static_assert(offsetof(HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration, Query) == 0x000000, "Member 'HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration::Query' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration, TimesRemaining) == 0x0001B0, "Member 'HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration::TimesRemaining' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration, Durations) == 0x0001C0, "Member 'HWAbilitySystemComponent_BP_GetActiveEffectsTimeRemainingAndDuration::Durations' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.CalculateForcedFiring
// 0x0004 (0x0004 - 0x0000)
struct HWAbilitySystemComponent_CalculateForcedFiring final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_CalculateForcedFiring) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_CalculateForcedFiring");
static_assert(sizeof(HWAbilitySystemComponent_CalculateForcedFiring) == 0x000004, "Wrong size on HWAbilitySystemComponent_CalculateForcedFiring");
static_assert(offsetof(HWAbilitySystemComponent_CalculateForcedFiring, DeltaTime) == 0x000000, "Member 'HWAbilitySystemComponent_CalculateForcedFiring::DeltaTime' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.CancelAbilitiesBasedOnTriggerTag
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTag final
{
public:
	struct FGameplayTag                           TriggerTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTag) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTag");
static_assert(sizeof(HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTag) == 0x000008, "Wrong size on HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTag");
static_assert(offsetof(HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTag, TriggerTag) == 0x000000, "Member 'HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTag::TriggerTag' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.CancelAbilitiesBasedOnTriggerTags
// 0x0020 (0x0020 - 0x0000)
struct HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTags final
{
public:
	struct FGameplayTagContainer                  TriggerTags;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTags) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTags");
static_assert(sizeof(HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTags) == 0x000020, "Wrong size on HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTags");
static_assert(offsetof(HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTags, TriggerTags) == 0x000000, "Member 'HWAbilitySystemComponent_CancelAbilitiesBasedOnTriggerTags::TriggerTags' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.CancelAbilitiesWithTags
// 0x0048 (0x0048 - 0x0000)
struct HWAbilitySystemComponent_CancelAbilitiesWithTags final
{
public:
	struct FGameplayTagContainer                  WithTags;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  WithoutTags;                                       // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       AbilityToIngnore;                                  // 0x0040(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_CancelAbilitiesWithTags) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_CancelAbilitiesWithTags");
static_assert(sizeof(HWAbilitySystemComponent_CancelAbilitiesWithTags) == 0x000048, "Wrong size on HWAbilitySystemComponent_CancelAbilitiesWithTags");
static_assert(offsetof(HWAbilitySystemComponent_CancelAbilitiesWithTags, WithTags) == 0x000000, "Member 'HWAbilitySystemComponent_CancelAbilitiesWithTags::WithTags' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_CancelAbilitiesWithTags, WithoutTags) == 0x000020, "Member 'HWAbilitySystemComponent_CancelAbilitiesWithTags::WithoutTags' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_CancelAbilitiesWithTags, AbilityToIngnore) == 0x000040, "Member 'HWAbilitySystemComponent_CancelAbilitiesWithTags::AbilityToIngnore' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.ClientAbilityLevelChanged
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_ClientAbilityLevelChanged final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_ClientAbilityLevelChanged) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_ClientAbilityLevelChanged");
static_assert(sizeof(HWAbilitySystemComponent_ClientAbilityLevelChanged) == 0x000008, "Wrong size on HWAbilitySystemComponent_ClientAbilityLevelChanged");
static_assert(offsetof(HWAbilitySystemComponent_ClientAbilityLevelChanged, AbilityHandle) == 0x000000, "Member 'HWAbilitySystemComponent_ClientAbilityLevelChanged::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientAbilityLevelChanged, Level) == 0x000004, "Member 'HWAbilitySystemComponent_ClientAbilityLevelChanged::Level' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.ClientExecuteGameplayCuesAtLocation
// 0x0040 (0x0040 - 0x0000)
struct HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation final
{
public:
	struct FGameplayTagContainer                  InTags;                                            // 0x0000(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    InLocation;                                        // 0x0020(0x0018)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation");
static_assert(sizeof(HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation) == 0x000040, "Wrong size on HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation");
static_assert(offsetof(HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation, InTags) == 0x000000, "Member 'HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation::InTags' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation, InLocation) == 0x000020, "Member 'HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation::InLocation' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation, Magnitude) == 0x000038, "Member 'HWAbilitySystemComponent_ClientExecuteGameplayCuesAtLocation::Magnitude' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.ClientMarkAbilityBuffering
// 0x0028 (0x0028 - 0x0000)
struct HWAbilitySystemComponent_ClientMarkAbilityBuffering final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityToBuffer;                                   // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActivationInfo         ActivationInfo;                                    // 0x0008(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_ClientMarkAbilityBuffering) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_ClientMarkAbilityBuffering");
static_assert(sizeof(HWAbilitySystemComponent_ClientMarkAbilityBuffering) == 0x000028, "Wrong size on HWAbilitySystemComponent_ClientMarkAbilityBuffering");
static_assert(offsetof(HWAbilitySystemComponent_ClientMarkAbilityBuffering, AbilityToBuffer) == 0x000000, "Member 'HWAbilitySystemComponent_ClientMarkAbilityBuffering::AbilityToBuffer' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientMarkAbilityBuffering, ActivationInfo) == 0x000008, "Member 'HWAbilitySystemComponent_ClientMarkAbilityBuffering::ActivationInfo' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.ClientSendGameplayEventToAvatar
// 0x00B8 (0x00B8 - 0x0000)
struct HWAbilitySystemComponent_ClientSendGameplayEventToAvatar final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_ClientSendGameplayEventToAvatar) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_ClientSendGameplayEventToAvatar");
static_assert(sizeof(HWAbilitySystemComponent_ClientSendGameplayEventToAvatar) == 0x0000B8, "Wrong size on HWAbilitySystemComponent_ClientSendGameplayEventToAvatar");
static_assert(offsetof(HWAbilitySystemComponent_ClientSendGameplayEventToAvatar, EventTag) == 0x000000, "Member 'HWAbilitySystemComponent_ClientSendGameplayEventToAvatar::EventTag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientSendGameplayEventToAvatar, Payload) == 0x000008, "Member 'HWAbilitySystemComponent_ClientSendGameplayEventToAvatar::Payload' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.ClientSetReplicatedEventWithPayload
// 0x0060 (0x0060 - 0x0000)
struct HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload final
{
public:
	EAbilityGenericReplicatedEvent                EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0004(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         AbilityOriginalPredictionKey;                      // 0x0008(0x0018)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 VectorPayload;                                     // 0x0020(0x0018)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataPayload;                                 // 0x0038(0x0028)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload");
static_assert(sizeof(HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload) == 0x000060, "Wrong size on HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload");
static_assert(offsetof(HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload, EventType) == 0x000000, "Member 'HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload::EventType' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload, AbilityHandle) == 0x000004, "Member 'HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload, AbilityOriginalPredictionKey) == 0x000008, "Member 'HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload::AbilityOriginalPredictionKey' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload, VectorPayload) == 0x000020, "Member 'HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload::VectorPayload' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload, TargetDataPayload) == 0x000038, "Member 'HWAbilitySystemComponent_ClientSetReplicatedEventWithPayload::TargetDataPayload' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.ClientTransitionToAbilityPhase
// 0x0030 (0x0030 - 0x0000)
struct HWAbilitySystemComponent_ClientTransitionToAbilityPhase final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityToEnd;                                      // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActivationInfo         ActivationInfo;                                    // 0x0008(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EAbilityFlowPhase                             PhaseToEnter;                                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimingError;                                       // 0x002C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_ClientTransitionToAbilityPhase) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_ClientTransitionToAbilityPhase");
static_assert(sizeof(HWAbilitySystemComponent_ClientTransitionToAbilityPhase) == 0x000030, "Wrong size on HWAbilitySystemComponent_ClientTransitionToAbilityPhase");
static_assert(offsetof(HWAbilitySystemComponent_ClientTransitionToAbilityPhase, AbilityToEnd) == 0x000000, "Member 'HWAbilitySystemComponent_ClientTransitionToAbilityPhase::AbilityToEnd' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientTransitionToAbilityPhase, ActivationInfo) == 0x000008, "Member 'HWAbilitySystemComponent_ClientTransitionToAbilityPhase::ActivationInfo' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientTransitionToAbilityPhase, PhaseToEnter) == 0x000028, "Member 'HWAbilitySystemComponent_ClientTransitionToAbilityPhase::PhaseToEnter' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ClientTransitionToAbilityPhase, TimingError) == 0x00002C, "Member 'HWAbilitySystemComponent_ClientTransitionToAbilityPhase::TimingError' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.GetAbilityLevel
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_GetAbilityLevel final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_GetAbilityLevel) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_GetAbilityLevel");
static_assert(sizeof(HWAbilitySystemComponent_GetAbilityLevel) == 0x000008, "Wrong size on HWAbilitySystemComponent_GetAbilityLevel");
static_assert(offsetof(HWAbilitySystemComponent_GetAbilityLevel, AbilityHandle) == 0x000000, "Member 'HWAbilitySystemComponent_GetAbilityLevel::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_GetAbilityLevel, ReturnValue) == 0x000004, "Member 'HWAbilitySystemComponent_GetAbilityLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.HandleActiveGameplayEffectStackChange
// 0x0010 (0x0010 - 0x0000)
struct HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange final
{
public:
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStackCount;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousStackCount;                                // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange");
static_assert(sizeof(HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange) == 0x000010, "Wrong size on HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange");
static_assert(offsetof(HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange, EffectHandle) == 0x000000, "Member 'HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange::EffectHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange, NewStackCount) == 0x000008, "Member 'HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange::NewStackCount' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange, PreviousStackCount) == 0x00000C, "Member 'HWAbilitySystemComponent_HandleActiveGameplayEffectStackChange::PreviousStackCount' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.HandleAnyGameplayEffectRemoved
// 0x0400 (0x0400 - 0x0000)
struct HWAbilitySystemComponent_HandleAnyGameplayEffectRemoved final
{
public:
	struct FActiveGameplayEffect                  ActiveGameplayEffect;                              // 0x0000(0x0400)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_HandleAnyGameplayEffectRemoved) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_HandleAnyGameplayEffectRemoved");
static_assert(sizeof(HWAbilitySystemComponent_HandleAnyGameplayEffectRemoved) == 0x000400, "Wrong size on HWAbilitySystemComponent_HandleAnyGameplayEffectRemoved");
static_assert(offsetof(HWAbilitySystemComponent_HandleAnyGameplayEffectRemoved, ActiveGameplayEffect) == 0x000000, "Member 'HWAbilitySystemComponent_HandleAnyGameplayEffectRemoved::ActiveGameplayEffect' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.HandleTagUpdated_ForceUseDefaultTargetingAbility
// 0x000C (0x000C - 0x0000)
struct HWAbilitySystemComponent_HandleTagUpdated_ForceUseDefaultTargetingAbility final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_HandleTagUpdated_ForceUseDefaultTargetingAbility) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_HandleTagUpdated_ForceUseDefaultTargetingAbility");
static_assert(sizeof(HWAbilitySystemComponent_HandleTagUpdated_ForceUseDefaultTargetingAbility) == 0x00000C, "Wrong size on HWAbilitySystemComponent_HandleTagUpdated_ForceUseDefaultTargetingAbility");
static_assert(offsetof(HWAbilitySystemComponent_HandleTagUpdated_ForceUseDefaultTargetingAbility, CallbackTag) == 0x000000, "Member 'HWAbilitySystemComponent_HandleTagUpdated_ForceUseDefaultTargetingAbility::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_HandleTagUpdated_ForceUseDefaultTargetingAbility, Count) == 0x000008, "Member 'HWAbilitySystemComponent_HandleTagUpdated_ForceUseDefaultTargetingAbility::Count' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.MulticastAbilityUnlocked
// 0x0010 (0x0010 - 0x0000)
struct HWAbilitySystemComponent_MulticastAbilityUnlocked final
{
public:
	struct FHWInventorySlot                       AbilitySlot;                                       // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnlocked;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_MulticastAbilityUnlocked) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_MulticastAbilityUnlocked");
static_assert(sizeof(HWAbilitySystemComponent_MulticastAbilityUnlocked) == 0x000010, "Wrong size on HWAbilitySystemComponent_MulticastAbilityUnlocked");
static_assert(offsetof(HWAbilitySystemComponent_MulticastAbilityUnlocked, AbilitySlot) == 0x000000, "Member 'HWAbilitySystemComponent_MulticastAbilityUnlocked::AbilitySlot' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_MulticastAbilityUnlocked, IsUnlocked) == 0x00000C, "Member 'HWAbilitySystemComponent_MulticastAbilityUnlocked::IsUnlocked' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.MulticastExecuteGameplayCuesAtLocation
// 0x0040 (0x0040 - 0x0000)
struct HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation final
{
public:
	struct FGameplayTagContainer                  InTags;                                            // 0x0000(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    InLocation;                                        // 0x0020(0x0018)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation");
static_assert(sizeof(HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation) == 0x000040, "Wrong size on HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation");
static_assert(offsetof(HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation, InTags) == 0x000000, "Member 'HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation::InTags' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation, InLocation) == 0x000020, "Member 'HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation::InLocation' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation, Magnitude) == 0x000038, "Member 'HWAbilitySystemComponent_MulticastExecuteGameplayCuesAtLocation::Magnitude' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.NotifyAbilityQuestEvent
// 0x000C (0x000C - 0x0000)
struct HWAbilitySystemComponent_NotifyAbilityQuestEvent final
{
public:
	struct FGameplayTag                           QuestTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressToAward;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_NotifyAbilityQuestEvent) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_NotifyAbilityQuestEvent");
static_assert(sizeof(HWAbilitySystemComponent_NotifyAbilityQuestEvent) == 0x00000C, "Wrong size on HWAbilitySystemComponent_NotifyAbilityQuestEvent");
static_assert(offsetof(HWAbilitySystemComponent_NotifyAbilityQuestEvent, QuestTag) == 0x000000, "Member 'HWAbilitySystemComponent_NotifyAbilityQuestEvent::QuestTag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_NotifyAbilityQuestEvent, ProgressToAward) == 0x000008, "Member 'HWAbilitySystemComponent_NotifyAbilityQuestEvent::ProgressToAward' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.OnRep_DefaultTargetingAbilityHandle
// 0x0004 (0x0004 - 0x0000)
struct HWAbilitySystemComponent_OnRep_DefaultTargetingAbilityHandle final
{
public:
	struct FGameplayAbilitySpecHandle             PrevDefaultTargetingAbilityHandle;                 // 0x0000(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_OnRep_DefaultTargetingAbilityHandle) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_OnRep_DefaultTargetingAbilityHandle");
static_assert(sizeof(HWAbilitySystemComponent_OnRep_DefaultTargetingAbilityHandle) == 0x000004, "Wrong size on HWAbilitySystemComponent_OnRep_DefaultTargetingAbilityHandle");
static_assert(offsetof(HWAbilitySystemComponent_OnRep_DefaultTargetingAbilityHandle, PrevDefaultTargetingAbilityHandle) == 0x000000, "Member 'HWAbilitySystemComponent_OnRep_DefaultTargetingAbilityHandle::PrevDefaultTargetingAbilityHandle' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.QueueTargetingAbility
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_QueueTargetingAbility final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSet;                                         // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_QueueTargetingAbility) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_QueueTargetingAbility");
static_assert(sizeof(HWAbilitySystemComponent_QueueTargetingAbility) == 0x000008, "Wrong size on HWAbilitySystemComponent_QueueTargetingAbility");
static_assert(offsetof(HWAbilitySystemComponent_QueueTargetingAbility, AbilityHandle) == 0x000000, "Member 'HWAbilitySystemComponent_QueueTargetingAbility::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_QueueTargetingAbility, bForceSet) == 0x000004, "Member 'HWAbilitySystemComponent_QueueTargetingAbility::bForceSet' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.RefreshActiveGameplayEffect
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_RefreshActiveGameplayEffect final
{
public:
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_RefreshActiveGameplayEffect) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_RefreshActiveGameplayEffect");
static_assert(sizeof(HWAbilitySystemComponent_RefreshActiveGameplayEffect) == 0x000008, "Wrong size on HWAbilitySystemComponent_RefreshActiveGameplayEffect");
static_assert(offsetof(HWAbilitySystemComponent_RefreshActiveGameplayEffect, EffectHandle) == 0x000000, "Member 'HWAbilitySystemComponent_RefreshActiveGameplayEffect::EffectHandle' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.RegisterAbilityQuestListener
// 0x0018 (0x0018 - 0x0000)
struct HWAbilitySystemComponent_RegisterAbilityQuestListener final
{
public:
	struct FGameplayTag                           QuestTag;                                          // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ProgressToAward)> ReturnValue;                               // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_RegisterAbilityQuestListener) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_RegisterAbilityQuestListener");
static_assert(sizeof(HWAbilitySystemComponent_RegisterAbilityQuestListener) == 0x000018, "Wrong size on HWAbilitySystemComponent_RegisterAbilityQuestListener");
static_assert(offsetof(HWAbilitySystemComponent_RegisterAbilityQuestListener, QuestTag) == 0x000000, "Member 'HWAbilitySystemComponent_RegisterAbilityQuestListener::QuestTag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_RegisterAbilityQuestListener, ReturnValue) == 0x000008, "Member 'HWAbilitySystemComponent_RegisterAbilityQuestListener::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.RegisterOnQuestEffectAppliedDelegate
// 0x0018 (0x0018 - 0x0000)
struct HWAbilitySystemComponent_RegisterOnQuestEffectAppliedDelegate final
{
public:
	struct FGameplayTag                           EffectTag;                                         // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayEffectSpec& ActiveGameplayEffect)> ReturnValue; // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_RegisterOnQuestEffectAppliedDelegate) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_RegisterOnQuestEffectAppliedDelegate");
static_assert(sizeof(HWAbilitySystemComponent_RegisterOnQuestEffectAppliedDelegate) == 0x000018, "Wrong size on HWAbilitySystemComponent_RegisterOnQuestEffectAppliedDelegate");
static_assert(offsetof(HWAbilitySystemComponent_RegisterOnQuestEffectAppliedDelegate, EffectTag) == 0x000000, "Member 'HWAbilitySystemComponent_RegisterOnQuestEffectAppliedDelegate::EffectTag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_RegisterOnQuestEffectAppliedDelegate, ReturnValue) == 0x000008, "Member 'HWAbilitySystemComponent_RegisterOnQuestEffectAppliedDelegate::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.RegisterTagListener
// 0x001C (0x001C - 0x0000)
struct HWAbilitySystemComponent_RegisterTagListener final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayTagEventType                         EventType;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FGameplayTag& Tag, int32 TagCount, class UHWAbilitySystemComponent* AbilitySystem)> Delegate; // 0x000C(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_RegisterTagListener) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_RegisterTagListener");
static_assert(sizeof(HWAbilitySystemComponent_RegisterTagListener) == 0x00001C, "Wrong size on HWAbilitySystemComponent_RegisterTagListener");
static_assert(offsetof(HWAbilitySystemComponent_RegisterTagListener, Tag) == 0x000000, "Member 'HWAbilitySystemComponent_RegisterTagListener::Tag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_RegisterTagListener, EventType) == 0x000008, "Member 'HWAbilitySystemComponent_RegisterTagListener::EventType' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_RegisterTagListener, Delegate) == 0x00000C, "Member 'HWAbilitySystemComponent_RegisterTagListener::Delegate' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.RemoveActiveEffectDynamicIgnoreTag
// 0x0010 (0x0010 - 0x0000)
struct HWAbilitySystemComponent_RemoveActiveEffectDynamicIgnoreTag final
{
public:
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_RemoveActiveEffectDynamicIgnoreTag) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_RemoveActiveEffectDynamicIgnoreTag");
static_assert(sizeof(HWAbilitySystemComponent_RemoveActiveEffectDynamicIgnoreTag) == 0x000010, "Wrong size on HWAbilitySystemComponent_RemoveActiveEffectDynamicIgnoreTag");
static_assert(offsetof(HWAbilitySystemComponent_RemoveActiveEffectDynamicIgnoreTag, ActiveHandle) == 0x000000, "Member 'HWAbilitySystemComponent_RemoveActiveEffectDynamicIgnoreTag::ActiveHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_RemoveActiveEffectDynamicIgnoreTag, Tag) == 0x000008, "Member 'HWAbilitySystemComponent_RemoveActiveEffectDynamicIgnoreTag::Tag' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.RemoveActiveEffectDynamicRequireTag
// 0x0010 (0x0010 - 0x0000)
struct HWAbilitySystemComponent_RemoveActiveEffectDynamicRequireTag final
{
public:
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_RemoveActiveEffectDynamicRequireTag) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_RemoveActiveEffectDynamicRequireTag");
static_assert(sizeof(HWAbilitySystemComponent_RemoveActiveEffectDynamicRequireTag) == 0x000010, "Wrong size on HWAbilitySystemComponent_RemoveActiveEffectDynamicRequireTag");
static_assert(offsetof(HWAbilitySystemComponent_RemoveActiveEffectDynamicRequireTag, ActiveHandle) == 0x000000, "Member 'HWAbilitySystemComponent_RemoveActiveEffectDynamicRequireTag::ActiveHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_RemoveActiveEffectDynamicRequireTag, Tag) == 0x000008, "Member 'HWAbilitySystemComponent_RemoveActiveEffectDynamicRequireTag::Tag' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.RemoveDynamicGameplayTag
// 0x000C (0x000C - 0x0000)
struct HWAbilitySystemComponent_RemoveDynamicGameplayTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldReplicate;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_RemoveDynamicGameplayTag) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_RemoveDynamicGameplayTag");
static_assert(sizeof(HWAbilitySystemComponent_RemoveDynamicGameplayTag) == 0x00000C, "Wrong size on HWAbilitySystemComponent_RemoveDynamicGameplayTag");
static_assert(offsetof(HWAbilitySystemComponent_RemoveDynamicGameplayTag, Tag) == 0x000000, "Member 'HWAbilitySystemComponent_RemoveDynamicGameplayTag::Tag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_RemoveDynamicGameplayTag, bShouldReplicate) == 0x000008, "Member 'HWAbilitySystemComponent_RemoveDynamicGameplayTag::bShouldReplicate' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.RemoveDynamicGameplayTags
// 0x0028 (0x0028 - 0x0000)
struct HWAbilitySystemComponent_RemoveDynamicGameplayTags final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bShouldReplicate;                                  // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_RemoveDynamicGameplayTags) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_RemoveDynamicGameplayTags");
static_assert(sizeof(HWAbilitySystemComponent_RemoveDynamicGameplayTags) == 0x000028, "Wrong size on HWAbilitySystemComponent_RemoveDynamicGameplayTags");
static_assert(offsetof(HWAbilitySystemComponent_RemoveDynamicGameplayTags, Tags) == 0x000000, "Member 'HWAbilitySystemComponent_RemoveDynamicGameplayTags::Tags' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_RemoveDynamicGameplayTags, bShouldReplicate) == 0x000020, "Member 'HWAbilitySystemComponent_RemoveDynamicGameplayTags::bShouldReplicate' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.RemoveForcedFiringInfo
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_RemoveForcedFiringInfo final
{
public:
	struct FActiveGameplayEffectHandle            ForcedMovementEffectHandle;                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_RemoveForcedFiringInfo) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_RemoveForcedFiringInfo");
static_assert(sizeof(HWAbilitySystemComponent_RemoveForcedFiringInfo) == 0x000008, "Wrong size on HWAbilitySystemComponent_RemoveForcedFiringInfo");
static_assert(offsetof(HWAbilitySystemComponent_RemoveForcedFiringInfo, ForcedMovementEffectHandle) == 0x000000, "Member 'HWAbilitySystemComponent_RemoveForcedFiringInfo::ForcedMovementEffectHandle' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.ServerCancelTargetingAbility
// 0x0004 (0x0004 - 0x0000)
struct HWAbilitySystemComponent_ServerCancelTargetingAbility final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityToCancel;                                   // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_ServerCancelTargetingAbility) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_ServerCancelTargetingAbility");
static_assert(sizeof(HWAbilitySystemComponent_ServerCancelTargetingAbility) == 0x000004, "Wrong size on HWAbilitySystemComponent_ServerCancelTargetingAbility");
static_assert(offsetof(HWAbilitySystemComponent_ServerCancelTargetingAbility, AbilityToCancel) == 0x000000, "Member 'HWAbilitySystemComponent_ServerCancelTargetingAbility::AbilityToCancel' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.ServerSetAbilityLevel
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_ServerSetAbilityLevel final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_ServerSetAbilityLevel) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_ServerSetAbilityLevel");
static_assert(sizeof(HWAbilitySystemComponent_ServerSetAbilityLevel) == 0x000008, "Wrong size on HWAbilitySystemComponent_ServerSetAbilityLevel");
static_assert(offsetof(HWAbilitySystemComponent_ServerSetAbilityLevel, AbilityHandle) == 0x000000, "Member 'HWAbilitySystemComponent_ServerSetAbilityLevel::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_ServerSetAbilityLevel, Level) == 0x000004, "Member 'HWAbilitySystemComponent_ServerSetAbilityLevel::Level' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.SetAbilityLevel
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_SetAbilityLevel final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_SetAbilityLevel) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_SetAbilityLevel");
static_assert(sizeof(HWAbilitySystemComponent_SetAbilityLevel) == 0x000008, "Wrong size on HWAbilitySystemComponent_SetAbilityLevel");
static_assert(offsetof(HWAbilitySystemComponent_SetAbilityLevel, AbilityHandle) == 0x000000, "Member 'HWAbilitySystemComponent_SetAbilityLevel::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_SetAbilityLevel, Level) == 0x000004, "Member 'HWAbilitySystemComponent_SetAbilityLevel::Level' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.SetActiveEffectDuration
// 0x0010 (0x0010 - 0x0000)
struct HWAbilitySystemComponent_SetActiveEffectDuration final
{
public:
	struct FActiveGameplayEffectHandle            Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewDuration;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_SetActiveEffectDuration) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_SetActiveEffectDuration");
static_assert(sizeof(HWAbilitySystemComponent_SetActiveEffectDuration) == 0x000010, "Wrong size on HWAbilitySystemComponent_SetActiveEffectDuration");
static_assert(offsetof(HWAbilitySystemComponent_SetActiveEffectDuration, Handle) == 0x000000, "Member 'HWAbilitySystemComponent_SetActiveEffectDuration::Handle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_SetActiveEffectDuration, NewDuration) == 0x000008, "Member 'HWAbilitySystemComponent_SetActiveEffectDuration::NewDuration' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_SetActiveEffectDuration, ReturnValue) == 0x00000C, "Member 'HWAbilitySystemComponent_SetActiveEffectDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.CanActivateAbility
// 0x0030 (0x0030 - 0x0000)
struct HWAbilitySystemComponent_CanActivateAbility final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  OutFailureTags;                                    // 0x0008(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_CanActivateAbility) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_CanActivateAbility");
static_assert(sizeof(HWAbilitySystemComponent_CanActivateAbility) == 0x000030, "Wrong size on HWAbilitySystemComponent_CanActivateAbility");
static_assert(offsetof(HWAbilitySystemComponent_CanActivateAbility, AbilityHandle) == 0x000000, "Member 'HWAbilitySystemComponent_CanActivateAbility::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_CanActivateAbility, OutFailureTags) == 0x000008, "Member 'HWAbilitySystemComponent_CanActivateAbility::OutFailureTags' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_CanActivateAbility, ReturnValue) == 0x000028, "Member 'HWAbilitySystemComponent_CanActivateAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.GetAbilitySpecHandlesWithInputTag
// 0x0018 (0x0018 - 0x0000)
struct HWAbilitySystemComponent_GetAbilitySpecHandlesWithInputTag final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAbilitySpecHandle>     ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_GetAbilitySpecHandlesWithInputTag) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_GetAbilitySpecHandlesWithInputTag");
static_assert(sizeof(HWAbilitySystemComponent_GetAbilitySpecHandlesWithInputTag) == 0x000018, "Wrong size on HWAbilitySystemComponent_GetAbilitySpecHandlesWithInputTag");
static_assert(offsetof(HWAbilitySystemComponent_GetAbilitySpecHandlesWithInputTag, InputTag) == 0x000000, "Member 'HWAbilitySystemComponent_GetAbilitySpecHandlesWithInputTag::InputTag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_GetAbilitySpecHandlesWithInputTag, ReturnValue) == 0x000008, "Member 'HWAbilitySystemComponent_GetAbilitySpecHandlesWithInputTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.GetAbilitySystemActorOwner
// 0x0008 (0x0008 - 0x0000)
struct HWAbilitySystemComponent_GetAbilitySystemActorOwner final
{
public:
	class AHWCharacterAbilitySystemActor*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_GetAbilitySystemActorOwner) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_GetAbilitySystemActorOwner");
static_assert(sizeof(HWAbilitySystemComponent_GetAbilitySystemActorOwner) == 0x000008, "Wrong size on HWAbilitySystemComponent_GetAbilitySystemActorOwner");
static_assert(offsetof(HWAbilitySystemComponent_GetAbilitySystemActorOwner, ReturnValue) == 0x000000, "Member 'HWAbilitySystemComponent_GetAbilitySystemActorOwner::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.GetAbilityWithInputTag
// 0x0010 (0x0010 - 0x0000)
struct HWAbilitySystemComponent_GetAbilityWithInputTag final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWGameplayAbility*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_GetAbilityWithInputTag) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_GetAbilityWithInputTag");
static_assert(sizeof(HWAbilitySystemComponent_GetAbilityWithInputTag) == 0x000010, "Wrong size on HWAbilitySystemComponent_GetAbilityWithInputTag");
static_assert(offsetof(HWAbilitySystemComponent_GetAbilityWithInputTag, InputTag) == 0x000000, "Member 'HWAbilitySystemComponent_GetAbilityWithInputTag::InputTag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_GetAbilityWithInputTag, ReturnValue) == 0x000008, "Member 'HWAbilitySystemComponent_GetAbilityWithInputTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.GetCastStyleForAbilityWithInputTag
// 0x000C (0x000C - 0x0000)
struct HWAbilitySystemComponent_GetCastStyleForAbilityWithInputTag final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityCastStyle                             ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilitySystemComponent_GetCastStyleForAbilityWithInputTag) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_GetCastStyleForAbilityWithInputTag");
static_assert(sizeof(HWAbilitySystemComponent_GetCastStyleForAbilityWithInputTag) == 0x00000C, "Wrong size on HWAbilitySystemComponent_GetCastStyleForAbilityWithInputTag");
static_assert(offsetof(HWAbilitySystemComponent_GetCastStyleForAbilityWithInputTag, InputTag) == 0x000000, "Member 'HWAbilitySystemComponent_GetCastStyleForAbilityWithInputTag::InputTag' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_GetCastStyleForAbilityWithInputTag, ReturnValue) == 0x000008, "Member 'HWAbilitySystemComponent_GetCastStyleForAbilityWithInputTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.GetCurrentFiringInstanceIdForAbility
// 0x000C (0x000C - 0x0000)
struct HWAbilitySystemComponent_GetCurrentFiringInstanceIdForAbility final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_GetCurrentFiringInstanceIdForAbility) == 0x000004, "Wrong alignment on HWAbilitySystemComponent_GetCurrentFiringInstanceIdForAbility");
static_assert(sizeof(HWAbilitySystemComponent_GetCurrentFiringInstanceIdForAbility) == 0x00000C, "Wrong size on HWAbilitySystemComponent_GetCurrentFiringInstanceIdForAbility");
static_assert(offsetof(HWAbilitySystemComponent_GetCurrentFiringInstanceIdForAbility, AbilityHandle) == 0x000000, "Member 'HWAbilitySystemComponent_GetCurrentFiringInstanceIdForAbility::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_GetCurrentFiringInstanceIdForAbility, ReturnValue) == 0x000004, "Member 'HWAbilitySystemComponent_GetCurrentFiringInstanceIdForAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.GetEquipmentInstanceFromAbility
// 0x0010 (0x0010 - 0x0000)
struct HWAbilitySystemComponent_GetEquipmentInstanceFromAbility final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_GetEquipmentInstanceFromAbility) == 0x000008, "Wrong alignment on HWAbilitySystemComponent_GetEquipmentInstanceFromAbility");
static_assert(sizeof(HWAbilitySystemComponent_GetEquipmentInstanceFromAbility) == 0x000010, "Wrong size on HWAbilitySystemComponent_GetEquipmentInstanceFromAbility");
static_assert(offsetof(HWAbilitySystemComponent_GetEquipmentInstanceFromAbility, AbilityHandle) == 0x000000, "Member 'HWAbilitySystemComponent_GetEquipmentInstanceFromAbility::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_GetEquipmentInstanceFromAbility, ReturnValue) == 0x000008, "Member 'HWAbilitySystemComponent_GetEquipmentInstanceFromAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.HasForcedFiringEffects
// 0x0001 (0x0001 - 0x0000)
struct HWAbilitySystemComponent_HasForcedFiringEffects final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_HasForcedFiringEffects) == 0x000001, "Wrong alignment on HWAbilitySystemComponent_HasForcedFiringEffects");
static_assert(sizeof(HWAbilitySystemComponent_HasForcedFiringEffects) == 0x000001, "Wrong size on HWAbilitySystemComponent_HasForcedFiringEffects");
static_assert(offsetof(HWAbilitySystemComponent_HasForcedFiringEffects, ReturnValue) == 0x000000, "Member 'HWAbilitySystemComponent_HasForcedFiringEffects::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.IsAbilityCancelInputPressed
// 0x0002 (0x0002 - 0x0000)
struct HWAbilitySystemComponent_IsAbilityCancelInputPressed final
{
public:
	bool                                          bCheckWasPressedThisTick;                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_IsAbilityCancelInputPressed) == 0x000001, "Wrong alignment on HWAbilitySystemComponent_IsAbilityCancelInputPressed");
static_assert(sizeof(HWAbilitySystemComponent_IsAbilityCancelInputPressed) == 0x000002, "Wrong size on HWAbilitySystemComponent_IsAbilityCancelInputPressed");
static_assert(offsetof(HWAbilitySystemComponent_IsAbilityCancelInputPressed, bCheckWasPressedThisTick) == 0x000000, "Member 'HWAbilitySystemComponent_IsAbilityCancelInputPressed::bCheckWasPressedThisTick' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_IsAbilityCancelInputPressed, ReturnValue) == 0x000001, "Member 'HWAbilitySystemComponent_IsAbilityCancelInputPressed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilitySystemComponent.IsAbilityConfirmInputPressed
// 0x0002 (0x0002 - 0x0000)
struct HWAbilitySystemComponent_IsAbilityConfirmInputPressed final
{
public:
	bool                                          bCheckWasPressedThisTick;                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilitySystemComponent_IsAbilityConfirmInputPressed) == 0x000001, "Wrong alignment on HWAbilitySystemComponent_IsAbilityConfirmInputPressed");
static_assert(sizeof(HWAbilitySystemComponent_IsAbilityConfirmInputPressed) == 0x000002, "Wrong size on HWAbilitySystemComponent_IsAbilityConfirmInputPressed");
static_assert(offsetof(HWAbilitySystemComponent_IsAbilityConfirmInputPressed, bCheckWasPressedThisTick) == 0x000000, "Member 'HWAbilitySystemComponent_IsAbilityConfirmInputPressed::bCheckWasPressedThisTick' has a wrong offset!");
static_assert(offsetof(HWAbilitySystemComponent_IsAbilityConfirmInputPressed, ReturnValue) == 0x000001, "Member 'HWAbilitySystemComponent_IsAbilityConfirmInputPressed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_CloneCharacterSwap.HandleFamiliarMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged final
{
public:
	class ACharacter*                             FamiliarCharacter;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged");
static_assert(sizeof(HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged) == 0x000010, "Wrong size on HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged");
static_assert(offsetof(HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged, FamiliarCharacter) == 0x000000, "Member 'HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged::FamiliarCharacter' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'HWAbilityTask_Attack_CloneCharacterSwap_HandleFamiliarMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_CloneCharacterSwap.OnFamiliarDied
// 0x00D0 (0x00D0 - 0x0000)
struct HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied final
{
public:
	struct FHWActiveFamiliarHandle                FamiliarHandle;                                    // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWActiveFamiliarInfo                  FamiliarInfo;                                      // 0x0010(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageEventData                       DamageReceivedEvent;                               // 0x0060(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied");
static_assert(sizeof(HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied) == 0x0000D0, "Wrong size on HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied");
static_assert(offsetof(HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied, FamiliarHandle) == 0x000000, "Member 'HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied::FamiliarHandle' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied, FamiliarInfo) == 0x000010, "Member 'HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied::FamiliarInfo' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied, DamageReceivedEvent) == 0x000060, "Member 'HWAbilityTask_Attack_CloneCharacterSwap_OnFamiliarDied::DamageReceivedEvent' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_CloneCharacterSwap.OnGameplayEffectAppliedToFamiliar
// 0x02B8 (0x02B8 - 0x0000)
struct HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar final
{
public:
	class UAbilitySystemComponent*                SourceASC;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0008(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            AppliedEffectHandle;                               // 0x02B0(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar");
static_assert(sizeof(HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar) == 0x0002B8, "Wrong size on HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar");
static_assert(offsetof(HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar, SourceASC) == 0x000000, "Member 'HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar::SourceASC' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar, EffectSpec) == 0x000008, "Member 'HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar::EffectSpec' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar, AppliedEffectHandle) == 0x0002B0, "Member 'HWAbilityTask_Attack_CloneCharacterSwap_OnGameplayEffectAppliedToFamiliar::AppliedEffectHandle' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Attack_SpawnFamiliar.GetSpawnedFamiliars
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_Attack_SpawnFamiliar_GetSpawnedFamiliars final
{
public:
	TArray<struct FHWActiveFamiliarHandle>        ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Attack_SpawnFamiliar_GetSpawnedFamiliars) == 0x000008, "Wrong alignment on HWAbilityTask_Attack_SpawnFamiliar_GetSpawnedFamiliars");
static_assert(sizeof(HWAbilityTask_Attack_SpawnFamiliar_GetSpawnedFamiliars) == 0x000010, "Wrong size on HWAbilityTask_Attack_SpawnFamiliar_GetSpawnedFamiliars");
static_assert(offsetof(HWAbilityTask_Attack_SpawnFamiliar_GetSpawnedFamiliars, ReturnValue) == 0x000000, "Member 'HWAbilityTask_Attack_SpawnFamiliar_GetSpawnedFamiliars::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_AbilityPhaseTransition.SetAbilityPhaseTransitionTimer
// 0x0020 (0x0020 - 0x0000)
struct HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityFlowPhase                             PhaseTransition_0;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionTime_0;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_AbilityPhaseTransition*  ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer) == 0x000008, "Wrong alignment on HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer");
static_assert(sizeof(HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer) == 0x000020, "Wrong size on HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer");
static_assert(offsetof(HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer, OwningAbility) == 0x000000, "Member 'HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer, PhaseTransition_0) == 0x000010, "Member 'HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer::PhaseTransition_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer, TransitionTime_0) == 0x000014, "Member 'HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer::TransitionTime_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer, ReturnValue) == 0x000018, "Member 'HWAbilityTask_AbilityPhaseTransition_SetAbilityPhaseTransitionTimer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayFlight.EnterGameplayFlight
// 0x0030 (0x0030 - 0x0000)
struct HWAbilityTask_GameplayFlight_EnterGameplayFlight final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWGameplayFlight>          Flight;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      Target_0;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AscentDurationOverride_0;                          // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_GameplayFlight*          ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayFlight_EnterGameplayFlight) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayFlight_EnterGameplayFlight");
static_assert(sizeof(HWAbilityTask_GameplayFlight_EnterGameplayFlight) == 0x000030, "Wrong size on HWAbilityTask_GameplayFlight_EnterGameplayFlight");
static_assert(offsetof(HWAbilityTask_GameplayFlight_EnterGameplayFlight, OwningAbility) == 0x000000, "Member 'HWAbilityTask_GameplayFlight_EnterGameplayFlight::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_EnterGameplayFlight, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_GameplayFlight_EnterGameplayFlight::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_EnterGameplayFlight, Flight) == 0x000010, "Member 'HWAbilityTask_GameplayFlight_EnterGameplayFlight::Flight' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_EnterGameplayFlight, Target_0) == 0x000018, "Member 'HWAbilityTask_GameplayFlight_EnterGameplayFlight::Target_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_EnterGameplayFlight, AscentDurationOverride_0) == 0x000020, "Member 'HWAbilityTask_GameplayFlight_EnterGameplayFlight::AscentDurationOverride_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_EnterGameplayFlight, ReturnValue) == 0x000028, "Member 'HWAbilityTask_GameplayFlight_EnterGameplayFlight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayFlight.ActivateFlightDescentTween
// 0x0028 (0x0028 - 0x0000)
struct HWAbilityTask_GameplayFlight_ActivateFlightDescentTween final
{
public:
	struct FGameplayAbilityTargetDataHandle       AimData;                                           // 0x0000(0x0028)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayFlight_ActivateFlightDescentTween) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayFlight_ActivateFlightDescentTween");
static_assert(sizeof(HWAbilityTask_GameplayFlight_ActivateFlightDescentTween) == 0x000028, "Wrong size on HWAbilityTask_GameplayFlight_ActivateFlightDescentTween");
static_assert(offsetof(HWAbilityTask_GameplayFlight_ActivateFlightDescentTween, AimData) == 0x000000, "Member 'HWAbilityTask_GameplayFlight_ActivateFlightDescentTween::AimData' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayFlight.OnFlightEnded
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_GameplayFlight_OnFlightEnded final
{
public:
	class UHWGameplayFlight*                      Flight;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndFlightReason                            EndFlightReason;                                   // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_GameplayFlight_OnFlightEnded) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayFlight_OnFlightEnded");
static_assert(sizeof(HWAbilityTask_GameplayFlight_OnFlightEnded) == 0x000010, "Wrong size on HWAbilityTask_GameplayFlight_OnFlightEnded");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnFlightEnded, Flight) == 0x000000, "Member 'HWAbilityTask_GameplayFlight_OnFlightEnded::Flight' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnFlightEnded, EndFlightReason) == 0x000008, "Member 'HWAbilityTask_GameplayFlight_OnFlightEnded::EndFlightReason' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayFlight.OnFlightStarted
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_GameplayFlight_OnFlightStarted final
{
public:
	class UHWGameplayFlight*                      Flight;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayFlight_OnFlightStarted) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayFlight_OnFlightStarted");
static_assert(sizeof(HWAbilityTask_GameplayFlight_OnFlightStarted) == 0x000008, "Wrong size on HWAbilityTask_GameplayFlight_OnFlightStarted");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnFlightStarted, Flight) == 0x000000, "Member 'HWAbilityTask_GameplayFlight_OnFlightStarted::Flight' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayFlight.OnTweenAscentEnded
// 0x0018 (0x0018 - 0x0000)
struct HWAbilityTask_GameplayFlight_OnTweenAscentEnded final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_GameplayFlight_OnTweenAscentEnded) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayFlight_OnTweenAscentEnded");
static_assert(sizeof(HWAbilityTask_GameplayFlight_OnTweenAscentEnded) == 0x000018, "Wrong size on HWAbilityTask_GameplayFlight_OnTweenAscentEnded");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnTweenAscentEnded, TweenInstance) == 0x000000, "Member 'HWAbilityTask_GameplayFlight_OnTweenAscentEnded::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnTweenAscentEnded, TweenTarget) == 0x000008, "Member 'HWAbilityTask_GameplayFlight_OnTweenAscentEnded::TweenTarget' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnTweenAscentEnded, EndTweenReason) == 0x000010, "Member 'HWAbilityTask_GameplayFlight_OnTweenAscentEnded::EndTweenReason' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayFlight.OnTweenAscentStarted
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_GameplayFlight_OnTweenAscentStarted final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayFlight_OnTweenAscentStarted) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayFlight_OnTweenAscentStarted");
static_assert(sizeof(HWAbilityTask_GameplayFlight_OnTweenAscentStarted) == 0x000010, "Wrong size on HWAbilityTask_GameplayFlight_OnTweenAscentStarted");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnTweenAscentStarted, TweenInstance) == 0x000000, "Member 'HWAbilityTask_GameplayFlight_OnTweenAscentStarted::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnTweenAscentStarted, TweenTarget) == 0x000008, "Member 'HWAbilityTask_GameplayFlight_OnTweenAscentStarted::TweenTarget' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayFlight.OnTweenDescentEnded
// 0x0018 (0x0018 - 0x0000)
struct HWAbilityTask_GameplayFlight_OnTweenDescentEnded final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_GameplayFlight_OnTweenDescentEnded) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayFlight_OnTweenDescentEnded");
static_assert(sizeof(HWAbilityTask_GameplayFlight_OnTweenDescentEnded) == 0x000018, "Wrong size on HWAbilityTask_GameplayFlight_OnTweenDescentEnded");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnTweenDescentEnded, TweenInstance) == 0x000000, "Member 'HWAbilityTask_GameplayFlight_OnTweenDescentEnded::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnTweenDescentEnded, TweenTarget) == 0x000008, "Member 'HWAbilityTask_GameplayFlight_OnTweenDescentEnded::TweenTarget' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnTweenDescentEnded, EndTweenReason) == 0x000010, "Member 'HWAbilityTask_GameplayFlight_OnTweenDescentEnded::EndTweenReason' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayFlight.OnTweenDescentStarted
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_GameplayFlight_OnTweenDescentStarted final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      TweenTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayFlight_OnTweenDescentStarted) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayFlight_OnTweenDescentStarted");
static_assert(sizeof(HWAbilityTask_GameplayFlight_OnTweenDescentStarted) == 0x000010, "Wrong size on HWAbilityTask_GameplayFlight_OnTweenDescentStarted");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnTweenDescentStarted, TweenInstance) == 0x000000, "Member 'HWAbilityTask_GameplayFlight_OnTweenDescentStarted::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayFlight_OnTweenDescentStarted, TweenTarget) == 0x000008, "Member 'HWAbilityTask_GameplayFlight_OnTweenDescentStarted::TweenTarget' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayTween.PerformGameplayTweenOnTarget
// 0x0058 (0x0058 - 0x0000)
struct HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWGameplayTween>           Tween;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0018(0x0028)(Parm, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      Target;                                            // 0x0040(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationOverride_0;                                // 0x0048(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_GameplayTween*           ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget");
static_assert(sizeof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget) == 0x000058, "Wrong size on HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget, OwningAbility) == 0x000000, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget, Tween) == 0x000010, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget::Tween' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget, TargetData) == 0x000018, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget::TargetData' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget, Target) == 0x000040, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget::Target' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget, DurationOverride_0) == 0x000048, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget::DurationOverride_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget, ReturnValue) == 0x000050, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayTween.PerformGameplayTweenOnTargets
// 0x0060 (0x0060 - 0x0000)
struct HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHWGameplayTween>           Tween;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0018(0x0028)(Parm, NativeAccessSpecifierPublic)
	TArray<class AHWCharacter_Base*>              Targets_0;                                         // 0x0040(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DurationOverride_0;                                // 0x0050(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSameTweenLocForAllTargets;                     // 0x0054(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_GameplayTween*           ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets");
static_assert(sizeof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets) == 0x000060, "Wrong size on HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets, OwningAbility) == 0x000000, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets, Tween) == 0x000010, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets::Tween' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets, TargetData) == 0x000018, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets::TargetData' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets, Targets_0) == 0x000040, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets::Targets_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets, DurationOverride_0) == 0x000050, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets::DurationOverride_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets, bUseSameTweenLocForAllTargets) == 0x000054, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets::bUseSameTweenLocForAllTargets' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets, ReturnValue) == 0x000058, "Member 'HWAbilityTask_GameplayTween_PerformGameplayTweenOnTargets::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayTween.HandleTagUpdated_CCImmunity
// 0x000C (0x000C - 0x0000)
struct HWAbilityTask_GameplayTween_HandleTagUpdated_CCImmunity final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayTween_HandleTagUpdated_CCImmunity) == 0x000004, "Wrong alignment on HWAbilityTask_GameplayTween_HandleTagUpdated_CCImmunity");
static_assert(sizeof(HWAbilityTask_GameplayTween_HandleTagUpdated_CCImmunity) == 0x00000C, "Wrong size on HWAbilityTask_GameplayTween_HandleTagUpdated_CCImmunity");
static_assert(offsetof(HWAbilityTask_GameplayTween_HandleTagUpdated_CCImmunity, CallbackTag) == 0x000000, "Member 'HWAbilityTask_GameplayTween_HandleTagUpdated_CCImmunity::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_HandleTagUpdated_CCImmunity, NewCount) == 0x000008, "Member 'HWAbilityTask_GameplayTween_HandleTagUpdated_CCImmunity::NewCount' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayTween.OnTweenEnded
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_GameplayTween_OnTweenEnded final
{
public:
	class UHWGameplayTween*                       Tween;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbilityTask_GameplayTween_OnTweenEnded) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayTween_OnTweenEnded");
static_assert(sizeof(HWAbilityTask_GameplayTween_OnTweenEnded) == 0x000010, "Wrong size on HWAbilityTask_GameplayTween_OnTweenEnded");
static_assert(offsetof(HWAbilityTask_GameplayTween_OnTweenEnded, Tween) == 0x000000, "Member 'HWAbilityTask_GameplayTween_OnTweenEnded::Tween' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_GameplayTween_OnTweenEnded, EndTweenReason) == 0x000008, "Member 'HWAbilityTask_GameplayTween_OnTweenEnded::EndTweenReason' has a wrong offset!");

// Function Hemingway.HWAbilityTask_GameplayTween.OnTweenStarted
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_GameplayTween_OnTweenStarted final
{
public:
	class UHWGameplayTween*                       Tween;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_GameplayTween_OnTweenStarted) == 0x000008, "Wrong alignment on HWAbilityTask_GameplayTween_OnTweenStarted");
static_assert(sizeof(HWAbilityTask_GameplayTween_OnTweenStarted) == 0x000008, "Wrong size on HWAbilityTask_GameplayTween_OnTweenStarted");
static_assert(offsetof(HWAbilityTask_GameplayTween_OnTweenStarted, Tween) == 0x000000, "Member 'HWAbilityTask_GameplayTween_OnTweenStarted::Tween' has a wrong offset!");

// Function Hemingway.HWAbilityTask_MovementSpeedOverTime.ApplyMovementSpeedOverTime
// 0x0028 (0x0028 - 0x0000)
struct HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MovementSpeedOverTimeCurve_0;                      // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration_0;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProcessAsSlow_0;                                  // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientPredictive_0;                               // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStrafeBackpedalImmunity_0;                        // 0x001E(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_MovementSpeedOverTime*   ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime) == 0x000008, "Wrong alignment on HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime");
static_assert(sizeof(HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime) == 0x000028, "Wrong size on HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime");
static_assert(offsetof(HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime, OwningAbility) == 0x000000, "Member 'HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime, MovementSpeedOverTimeCurve_0) == 0x000010, "Member 'HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime::MovementSpeedOverTimeCurve_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime, Duration_0) == 0x000018, "Member 'HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime::Duration_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime, bProcessAsSlow_0) == 0x00001C, "Member 'HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime::bProcessAsSlow_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime, bClientPredictive_0) == 0x00001D, "Member 'HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime::bClientPredictive_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime, bStrafeBackpedalImmunity_0) == 0x00001E, "Member 'HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime::bStrafeBackpedalImmunity_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime, ReturnValue) == 0x000020, "Member 'HWAbilityTask_MovementSpeedOverTime_ApplyMovementSpeedOverTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_SpawnProjectile.SpawnProjectileTask
// 0x0050 (0x0050 - 0x0000)
struct HWAbilityTask_SpawnProjectile_SpawnProjectileTask final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWAbilityAttackSettings_Projectile* ProjectileAttackSettings_0;                     // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetAimData;                                     // 0x0018(0x0028)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 HomingTarget_0;                                    // 0x0040(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_SpawnProjectile*         ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_SpawnProjectile_SpawnProjectileTask) == 0x000008, "Wrong alignment on HWAbilityTask_SpawnProjectile_SpawnProjectileTask");
static_assert(sizeof(HWAbilityTask_SpawnProjectile_SpawnProjectileTask) == 0x000050, "Wrong size on HWAbilityTask_SpawnProjectile_SpawnProjectileTask");
static_assert(offsetof(HWAbilityTask_SpawnProjectile_SpawnProjectileTask, OwningAbility) == 0x000000, "Member 'HWAbilityTask_SpawnProjectile_SpawnProjectileTask::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnProjectile_SpawnProjectileTask, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_SpawnProjectile_SpawnProjectileTask::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnProjectile_SpawnProjectileTask, ProjectileAttackSettings_0) == 0x000010, "Member 'HWAbilityTask_SpawnProjectile_SpawnProjectileTask::ProjectileAttackSettings_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnProjectile_SpawnProjectileTask, TargetAimData) == 0x000018, "Member 'HWAbilityTask_SpawnProjectile_SpawnProjectileTask::TargetAimData' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnProjectile_SpawnProjectileTask, HomingTarget_0) == 0x000040, "Member 'HWAbilityTask_SpawnProjectile_SpawnProjectileTask::HomingTarget_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_SpawnProjectile_SpawnProjectileTask, ReturnValue) == 0x000048, "Member 'HWAbilityTask_SpawnProjectile_SpawnProjectileTask::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_SpawnProjectile.IsInhandProjectile
// 0x0001 (0x0001 - 0x0000)
struct HWAbilityTask_SpawnProjectile_IsInhandProjectile final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_SpawnProjectile_IsInhandProjectile) == 0x000001, "Wrong alignment on HWAbilityTask_SpawnProjectile_IsInhandProjectile");
static_assert(sizeof(HWAbilityTask_SpawnProjectile_IsInhandProjectile) == 0x000001, "Wrong size on HWAbilityTask_SpawnProjectile_IsInhandProjectile");
static_assert(offsetof(HWAbilityTask_SpawnProjectile_IsInhandProjectile, ReturnValue) == 0x000000, "Member 'HWAbilityTask_SpawnProjectile_IsInhandProjectile::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitAbilityEnd.WaitForAbilityEnd
// 0x0028 (0x0028 - 0x0000)
struct HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithTag;                                           // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithoutTag;                                        // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitAbilityEnd*          ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd) == 0x000008, "Wrong alignment on HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd");
static_assert(sizeof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd) == 0x000028, "Wrong size on HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd");
static_assert(offsetof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd, WithTag) == 0x000008, "Member 'HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd::WithTag' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd, WithoutTag) == 0x000010, "Member 'HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd::WithoutTag' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd, TriggerOnce) == 0x000018, "Member 'HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd::TriggerOnce' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd, ReturnValue) == 0x000020, "Member 'HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitAbilityEnd.WaitForAbilityEnd_Query
// 0x0060 (0x0060 - 0x0000)
struct HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      Query;                                             // 0x0008(0x0048)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_WaitAbilityEnd*          ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query) == 0x000008, "Wrong alignment on HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query");
static_assert(sizeof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query) == 0x000060, "Wrong size on HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query");
static_assert(offsetof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query, Query) == 0x000008, "Member 'HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query::Query' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query, TriggerOnce) == 0x000050, "Member 'HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query::TriggerOnce' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query, ReturnValue) == 0x000058, "Member 'HWAbilityTask_WaitAbilityEnd_WaitForAbilityEnd_Query::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitAbilityEnd.OnAbilityEnd
// 0x0010 (0x0010 - 0x0000)
struct HWAbilityTask_WaitAbilityEnd_OnAbilityEnd final
{
public:
	struct FAbilityEndedData                      AbilityEndData;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitAbilityEnd_OnAbilityEnd) == 0x000008, "Wrong alignment on HWAbilityTask_WaitAbilityEnd_OnAbilityEnd");
static_assert(sizeof(HWAbilityTask_WaitAbilityEnd_OnAbilityEnd) == 0x000010, "Wrong size on HWAbilityTask_WaitAbilityEnd_OnAbilityEnd");
static_assert(offsetof(HWAbilityTask_WaitAbilityEnd_OnAbilityEnd, AbilityEndData) == 0x000000, "Member 'HWAbilityTask_WaitAbilityEnd_OnAbilityEnd::AbilityEndData' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitForRefire.WaitForRefire
// 0x0040 (0x0040 - 0x0000)
struct HWAbilityTask_WaitForRefire_WaitForRefire final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefireWindowTime;                                  // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWAbilityRefireInfo                   RefireInfo_0;                                      // 0x0018(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	class UHWAbilityTask_WaitForRefire*           ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitForRefire_WaitForRefire) == 0x000008, "Wrong alignment on HWAbilityTask_WaitForRefire_WaitForRefire");
static_assert(sizeof(HWAbilityTask_WaitForRefire_WaitForRefire) == 0x000040, "Wrong size on HWAbilityTask_WaitForRefire_WaitForRefire");
static_assert(offsetof(HWAbilityTask_WaitForRefire_WaitForRefire, OwningAbility) == 0x000000, "Member 'HWAbilityTask_WaitForRefire_WaitForRefire::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForRefire_WaitForRefire, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_WaitForRefire_WaitForRefire::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForRefire_WaitForRefire, RefireWindowTime) == 0x000010, "Member 'HWAbilityTask_WaitForRefire_WaitForRefire::RefireWindowTime' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForRefire_WaitForRefire, RefireInfo_0) == 0x000018, "Member 'HWAbilityTask_WaitForRefire_WaitForRefire::RefireInfo_0' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_WaitForRefire_WaitForRefire, ReturnValue) == 0x000038, "Member 'HWAbilityTask_WaitForRefire_WaitForRefire::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitForRefire.GetRefireComponent
// 0x0008 (0x0008 - 0x0000)
struct HWAbilityTask_WaitForRefire_GetRefireComponent final
{
public:
	class UHWEquipmentComponent_Refireable*       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitForRefire_GetRefireComponent) == 0x000008, "Wrong alignment on HWAbilityTask_WaitForRefire_GetRefireComponent");
static_assert(sizeof(HWAbilityTask_WaitForRefire_GetRefireComponent) == 0x000008, "Wrong size on HWAbilityTask_WaitForRefire_GetRefireComponent");
static_assert(offsetof(HWAbilityTask_WaitForRefire_GetRefireComponent, ReturnValue) == 0x000000, "Member 'HWAbilityTask_WaitForRefire_GetRefireComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_WaitForRefire.OnAbilityInputPressed
// 0x0004 (0x0004 - 0x0000)
struct HWAbilityTask_WaitForRefire_OnAbilityInputPressed final
{
public:
	float                                         TimeWaited;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_WaitForRefire_OnAbilityInputPressed) == 0x000004, "Wrong alignment on HWAbilityTask_WaitForRefire_OnAbilityInputPressed");
static_assert(sizeof(HWAbilityTask_WaitForRefire_OnAbilityInputPressed) == 0x000004, "Wrong size on HWAbilityTask_WaitForRefire_OnAbilityInputPressed");
static_assert(offsetof(HWAbilityTask_WaitForRefire_OnAbilityInputPressed, TimeWaited) == 0x000000, "Member 'HWAbilityTask_WaitForRefire_OnAbilityInputPressed::TimeWaited' has a wrong offset!");

// Function Hemingway.HWDraftReplicatedActor.ServerCheatRequestRandomCharacterWithHealerTier
// 0x0004 (0x0004 - 0x0000)
struct HWDraftReplicatedActor_ServerCheatRequestRandomCharacterWithHealerTier final
{
public:
	struct FDraftTaskId                           TaskId;                                            // 0x0000(0x0002)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWDraftHealerRequirement                     HealerRequirement;                                 // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDraftReplicatedActor_ServerCheatRequestRandomCharacterWithHealerTier) == 0x000002, "Wrong alignment on HWDraftReplicatedActor_ServerCheatRequestRandomCharacterWithHealerTier");
static_assert(sizeof(HWDraftReplicatedActor_ServerCheatRequestRandomCharacterWithHealerTier) == 0x000004, "Wrong size on HWDraftReplicatedActor_ServerCheatRequestRandomCharacterWithHealerTier");
static_assert(offsetof(HWDraftReplicatedActor_ServerCheatRequestRandomCharacterWithHealerTier, TaskId) == 0x000000, "Member 'HWDraftReplicatedActor_ServerCheatRequestRandomCharacterWithHealerTier::TaskId' has a wrong offset!");
static_assert(offsetof(HWDraftReplicatedActor_ServerCheatRequestRandomCharacterWithHealerTier, HealerRequirement) == 0x000002, "Member 'HWDraftReplicatedActor_ServerCheatRequestRandomCharacterWithHealerTier::HealerRequirement' has a wrong offset!");

// Function Hemingway.HWDraftReplicatedActor.ServerRequestReroll
// 0x0002 (0x0002 - 0x0000)
struct HWDraftReplicatedActor_ServerRequestReroll final
{
public:
	struct FDraftTaskId                           TaskId;                                            // 0x0000(0x0002)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDraftReplicatedActor_ServerRequestReroll) == 0x000002, "Wrong alignment on HWDraftReplicatedActor_ServerRequestReroll");
static_assert(sizeof(HWDraftReplicatedActor_ServerRequestReroll) == 0x000002, "Wrong size on HWDraftReplicatedActor_ServerRequestReroll");
static_assert(offsetof(HWDraftReplicatedActor_ServerRequestReroll, TaskId) == 0x000000, "Member 'HWDraftReplicatedActor_ServerRequestReroll::TaskId' has a wrong offset!");

// Function Hemingway.HWDraftReplicatedActor.ServerRequestSelectWithRandomChoice
// 0x0002 (0x0002 - 0x0000)
struct HWDraftReplicatedActor_ServerRequestSelectWithRandomChoice final
{
public:
	struct FDraftTaskId                           TaskId;                                            // 0x0000(0x0002)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDraftReplicatedActor_ServerRequestSelectWithRandomChoice) == 0x000002, "Wrong alignment on HWDraftReplicatedActor_ServerRequestSelectWithRandomChoice");
static_assert(sizeof(HWDraftReplicatedActor_ServerRequestSelectWithRandomChoice) == 0x000002, "Wrong size on HWDraftReplicatedActor_ServerRequestSelectWithRandomChoice");
static_assert(offsetof(HWDraftReplicatedActor_ServerRequestSelectWithRandomChoice, TaskId) == 0x000000, "Member 'HWDraftReplicatedActor_ServerRequestSelectWithRandomChoice::TaskId' has a wrong offset!");

// Function Hemingway.HWDraftReplicatedActor.GetDraftType
// 0x0001 (0x0001 - 0x0000)
struct HWDraftReplicatedActor_GetDraftType final
{
public:
	EHWDraftType                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDraftReplicatedActor_GetDraftType) == 0x000001, "Wrong alignment on HWDraftReplicatedActor_GetDraftType");
static_assert(sizeof(HWDraftReplicatedActor_GetDraftType) == 0x000001, "Wrong size on HWDraftReplicatedActor_GetDraftType");
static_assert(offsetof(HWDraftReplicatedActor_GetDraftType, ReturnValue) == 0x000000, "Member 'HWDraftReplicatedActor_GetDraftType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDraftReplicatedActor.HasRerolled
// 0x0001 (0x0001 - 0x0000)
struct HWDraftReplicatedActor_HasRerolled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDraftReplicatedActor_HasRerolled) == 0x000001, "Wrong alignment on HWDraftReplicatedActor_HasRerolled");
static_assert(sizeof(HWDraftReplicatedActor_HasRerolled) == 0x000001, "Wrong size on HWDraftReplicatedActor_HasRerolled");
static_assert(offsetof(HWDraftReplicatedActor_HasRerolled, ReturnValue) == 0x000000, "Member 'HWDraftReplicatedActor_HasRerolled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCameraModifier_RotationOverTime.InitializeRotationOverTime
// 0x0020 (0x0020 - 0x0000)
struct HWCameraModifier_RotationOverTime_InitializeRotationOverTime final
{
public:
	struct FRotator                               InDesiredEndRotation;                              // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InDuration;                                        // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCameraModifier_RotationOverTime_InitializeRotationOverTime) == 0x000008, "Wrong alignment on HWCameraModifier_RotationOverTime_InitializeRotationOverTime");
static_assert(sizeof(HWCameraModifier_RotationOverTime_InitializeRotationOverTime) == 0x000020, "Wrong size on HWCameraModifier_RotationOverTime_InitializeRotationOverTime");
static_assert(offsetof(HWCameraModifier_RotationOverTime_InitializeRotationOverTime, InDesiredEndRotation) == 0x000000, "Member 'HWCameraModifier_RotationOverTime_InitializeRotationOverTime::InDesiredEndRotation' has a wrong offset!");
static_assert(offsetof(HWCameraModifier_RotationOverTime_InitializeRotationOverTime, InDuration) == 0x000018, "Member 'HWCameraModifier_RotationOverTime_InitializeRotationOverTime::InDuration' has a wrong offset!");

// Function Hemingway.HWAutoSkillComponent.OnInventoryManagerChanged
// 0x0010 (0x0010 - 0x0000)
struct HWAutoSkillComponent_OnInventoryManagerChanged final
{
public:
	class AHWCharacterAbilitySystemActor*         CharASA;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWInventoryManagerComponent*           InventoryManagerComp;                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoSkillComponent_OnInventoryManagerChanged) == 0x000008, "Wrong alignment on HWAutoSkillComponent_OnInventoryManagerChanged");
static_assert(sizeof(HWAutoSkillComponent_OnInventoryManagerChanged) == 0x000010, "Wrong size on HWAutoSkillComponent_OnInventoryManagerChanged");
static_assert(offsetof(HWAutoSkillComponent_OnInventoryManagerChanged, CharASA) == 0x000000, "Member 'HWAutoSkillComponent_OnInventoryManagerChanged::CharASA' has a wrong offset!");
static_assert(offsetof(HWAutoSkillComponent_OnInventoryManagerChanged, InventoryManagerComp) == 0x000008, "Member 'HWAutoSkillComponent_OnInventoryManagerChanged::InventoryManagerComp' has a wrong offset!");

// Function Hemingway.HWAutoSkillComponent.ServerSetAutoSkillState
// 0x0001 (0x0001 - 0x0000)
struct HWAutoSkillComponent_ServerSetAutoSkillState final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoSkillComponent_ServerSetAutoSkillState) == 0x000001, "Wrong alignment on HWAutoSkillComponent_ServerSetAutoSkillState");
static_assert(sizeof(HWAutoSkillComponent_ServerSetAutoSkillState) == 0x000001, "Wrong size on HWAutoSkillComponent_ServerSetAutoSkillState");
static_assert(offsetof(HWAutoSkillComponent_ServerSetAutoSkillState, bEnable) == 0x000000, "Member 'HWAutoSkillComponent_ServerSetAutoSkillState::bEnable' has a wrong offset!");

// Function Hemingway.HWAutoSkillComponent.CanUseAutoSkill
// 0x0001 (0x0001 - 0x0000)
struct HWAutoSkillComponent_CanUseAutoSkill final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoSkillComponent_CanUseAutoSkill) == 0x000001, "Wrong alignment on HWAutoSkillComponent_CanUseAutoSkill");
static_assert(sizeof(HWAutoSkillComponent_CanUseAutoSkill) == 0x000001, "Wrong size on HWAutoSkillComponent_CanUseAutoSkill");
static_assert(offsetof(HWAutoSkillComponent_CanUseAutoSkill, ReturnValue) == 0x000000, "Member 'HWAutoSkillComponent_CanUseAutoSkill::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAutoSkillComponent.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWAutoSkillComponent_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAutoSkillComponent_IsEnabled) == 0x000001, "Wrong alignment on HWAutoSkillComponent_IsEnabled");
static_assert(sizeof(HWAutoSkillComponent_IsEnabled) == 0x000001, "Wrong size on HWAutoSkillComponent_IsEnabled");
static_assert(offsetof(HWAutoSkillComponent_IsEnabled, ReturnValue) == 0x000000, "Member 'HWAutoSkillComponent_IsEnabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.AddForceMovementInfo
// 0x0050 (0x0050 - 0x0000)
struct HWCharacterMovementComponent_AddForceMovementInfo final
{
public:
	struct FHWForcedCharacterMovementInfo         ForcedMoveInfo;                                    // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_AddForceMovementInfo) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_AddForceMovementInfo");
static_assert(sizeof(HWCharacterMovementComponent_AddForceMovementInfo) == 0x000050, "Wrong size on HWCharacterMovementComponent_AddForceMovementInfo");
static_assert(offsetof(HWCharacterMovementComponent_AddForceMovementInfo, ForcedMoveInfo) == 0x000000, "Member 'HWCharacterMovementComponent_AddForceMovementInfo::ForcedMoveInfo' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.AttemptStartDash
// 0x0068 (0x0068 - 0x0000)
struct HWCharacterMovementComponent_AttemptStartDash final
{
public:
	TSubclassOf<class UHWGameplayDash>            Dash;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       InstigatingAbility;                                // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0018(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         DurationOverride;                                  // 0x0040(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DashRotation;                                      // 0x0048(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UHWGameplayDash*                        ReturnValue;                                       // 0x0060(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_AttemptStartDash) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_AttemptStartDash");
static_assert(sizeof(HWCharacterMovementComponent_AttemptStartDash) == 0x000068, "Wrong size on HWCharacterMovementComponent_AttemptStartDash");
static_assert(offsetof(HWCharacterMovementComponent_AttemptStartDash, Dash) == 0x000000, "Member 'HWCharacterMovementComponent_AttemptStartDash::Dash' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_AttemptStartDash, Instigator) == 0x000008, "Member 'HWCharacterMovementComponent_AttemptStartDash::Instigator' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_AttemptStartDash, InstigatingAbility) == 0x000010, "Member 'HWCharacterMovementComponent_AttemptStartDash::InstigatingAbility' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_AttemptStartDash, TargetDataHandle) == 0x000018, "Member 'HWCharacterMovementComponent_AttemptStartDash::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_AttemptStartDash, DurationOverride) == 0x000040, "Member 'HWCharacterMovementComponent_AttemptStartDash::DurationOverride' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_AttemptStartDash, DashRotation) == 0x000048, "Member 'HWCharacterMovementComponent_AttemptStartDash::DashRotation' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_AttemptStartDash, ReturnValue) == 0x000060, "Member 'HWCharacterMovementComponent_AttemptStartDash::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.ClientEndDashCollidedTrigger
// 0x0148 (0x0148 - 0x0000)
struct HWCharacterMovementComponent_ClientEndDashCollidedTrigger final
{
public:
	struct FHWDashEndInfo                         EndInfo;                                           // 0x0000(0x0130)(ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FPredictionKey                         PredictionKey;                                     // 0x0130(0x0018)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_ClientEndDashCollidedTrigger) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_ClientEndDashCollidedTrigger");
static_assert(sizeof(HWCharacterMovementComponent_ClientEndDashCollidedTrigger) == 0x000148, "Wrong size on HWCharacterMovementComponent_ClientEndDashCollidedTrigger");
static_assert(offsetof(HWCharacterMovementComponent_ClientEndDashCollidedTrigger, EndInfo) == 0x000000, "Member 'HWCharacterMovementComponent_ClientEndDashCollidedTrigger::EndInfo' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_ClientEndDashCollidedTrigger, PredictionKey) == 0x000130, "Member 'HWCharacterMovementComponent_ClientEndDashCollidedTrigger::PredictionKey' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.EndAllCurrentAndPendingCustomMovement
// 0x000C (0x000C - 0x0000)
struct HWCharacterMovementComponent_EndAllCurrentAndPendingCustomMovement final
{
public:
	struct FHWEndCustomMovementRules              EndCustomMovementRules;                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_EndAllCurrentAndPendingCustomMovement) == 0x000001, "Wrong alignment on HWCharacterMovementComponent_EndAllCurrentAndPendingCustomMovement");
static_assert(sizeof(HWCharacterMovementComponent_EndAllCurrentAndPendingCustomMovement) == 0x00000C, "Wrong size on HWCharacterMovementComponent_EndAllCurrentAndPendingCustomMovement");
static_assert(offsetof(HWCharacterMovementComponent_EndAllCurrentAndPendingCustomMovement, EndCustomMovementRules) == 0x000000, "Member 'HWCharacterMovementComponent_EndAllCurrentAndPendingCustomMovement::EndCustomMovementRules' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.ForceClientPendingDashUpdate
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterMovementComponent_ForceClientPendingDashUpdate final
{
public:
	class UHWGameplayDash*                        ServerCurrentPendingDash;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_ForceClientPendingDashUpdate) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_ForceClientPendingDashUpdate");
static_assert(sizeof(HWCharacterMovementComponent_ForceClientPendingDashUpdate) == 0x000008, "Wrong size on HWCharacterMovementComponent_ForceClientPendingDashUpdate");
static_assert(offsetof(HWCharacterMovementComponent_ForceClientPendingDashUpdate, ServerCurrentPendingDash) == 0x000000, "Member 'HWCharacterMovementComponent_ForceClientPendingDashUpdate::ServerCurrentPendingDash' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.OnAttributeSystemAssigned
// 0x0010 (0x0010 - 0x0000)
struct HWCharacterMovementComponent_OnAttributeSystemAssigned final
{
public:
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OldAbilitySystem;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_OnAttributeSystemAssigned) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_OnAttributeSystemAssigned");
static_assert(sizeof(HWCharacterMovementComponent_OnAttributeSystemAssigned) == 0x000010, "Wrong size on HWCharacterMovementComponent_OnAttributeSystemAssigned");
static_assert(offsetof(HWCharacterMovementComponent_OnAttributeSystemAssigned, AbilitySystem) == 0x000000, "Member 'HWCharacterMovementComponent_OnAttributeSystemAssigned::AbilitySystem' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_OnAttributeSystemAssigned, OldAbilitySystem) == 0x000008, "Member 'HWCharacterMovementComponent_OnAttributeSystemAssigned::OldAbilitySystem' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.OnInhandTagAddedOrRemoved
// 0x0018 (0x0018 - 0x0000)
struct HWCharacterMovementComponent_OnInhandTagAddedOrRemoved final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TagCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_OnInhandTagAddedOrRemoved) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_OnInhandTagAddedOrRemoved");
static_assert(sizeof(HWCharacterMovementComponent_OnInhandTagAddedOrRemoved) == 0x000018, "Wrong size on HWCharacterMovementComponent_OnInhandTagAddedOrRemoved");
static_assert(offsetof(HWCharacterMovementComponent_OnInhandTagAddedOrRemoved, Tag) == 0x000000, "Member 'HWCharacterMovementComponent_OnInhandTagAddedOrRemoved::Tag' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_OnInhandTagAddedOrRemoved, TagCount) == 0x000008, "Member 'HWCharacterMovementComponent_OnInhandTagAddedOrRemoved::TagCount' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_OnInhandTagAddedOrRemoved, AbilitySystem) == 0x000010, "Member 'HWCharacterMovementComponent_OnInhandTagAddedOrRemoved::AbilitySystem' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.RemoveForceMovementInfo
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterMovementComponent_RemoveForceMovementInfo final
{
public:
	struct FActiveGameplayEffectHandle            ForcedMovementEffectHandle;                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_RemoveForceMovementInfo) == 0x000004, "Wrong alignment on HWCharacterMovementComponent_RemoveForceMovementInfo");
static_assert(sizeof(HWCharacterMovementComponent_RemoveForceMovementInfo) == 0x000008, "Wrong size on HWCharacterMovementComponent_RemoveForceMovementInfo");
static_assert(offsetof(HWCharacterMovementComponent_RemoveForceMovementInfo, ForcedMovementEffectHandle) == 0x000000, "Member 'HWCharacterMovementComponent_RemoveForceMovementInfo::ForcedMovementEffectHandle' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.ServerEndDashCollided
// 0x0130 (0x0130 - 0x0000)
struct HWCharacterMovementComponent_ServerEndDashCollided final
{
public:
	struct FHWDashEndInfo                         DashEndInfo;                                       // 0x0000(0x0130)(ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_ServerEndDashCollided) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_ServerEndDashCollided");
static_assert(sizeof(HWCharacterMovementComponent_ServerEndDashCollided) == 0x000130, "Wrong size on HWCharacterMovementComponent_ServerEndDashCollided");
static_assert(offsetof(HWCharacterMovementComponent_ServerEndDashCollided, DashEndInfo) == 0x000000, "Member 'HWCharacterMovementComponent_ServerEndDashCollided::DashEndInfo' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.StartFlight
// 0x0028 (0x0028 - 0x0000)
struct HWCharacterMovementComponent_StartFlight final
{
public:
	TSubclassOf<class UHWGameplayFlight>          Flight;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       InstigatingAbility;                                // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AscentDurationOverride;                            // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWGameplayFlight*                      ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_StartFlight) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_StartFlight");
static_assert(sizeof(HWCharacterMovementComponent_StartFlight) == 0x000028, "Wrong size on HWCharacterMovementComponent_StartFlight");
static_assert(offsetof(HWCharacterMovementComponent_StartFlight, Flight) == 0x000000, "Member 'HWCharacterMovementComponent_StartFlight::Flight' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartFlight, Instigator) == 0x000008, "Member 'HWCharacterMovementComponent_StartFlight::Instigator' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartFlight, InstigatingAbility) == 0x000010, "Member 'HWCharacterMovementComponent_StartFlight::InstigatingAbility' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartFlight, AscentDurationOverride) == 0x000018, "Member 'HWCharacterMovementComponent_StartFlight::AscentDurationOverride' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartFlight, ReturnValue) == 0x000020, "Member 'HWCharacterMovementComponent_StartFlight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.StartGrab
// 0x0040 (0x0040 - 0x0000)
struct HWCharacterMovementComponent_StartGrab final
{
public:
	TSubclassOf<class UHWGameplayGrab>            Grab;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWGrabInfo                            GrabInfo;                                          // 0x0008(0x0028)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	class UHWAbilityTask_GameplayGrab*            GrabTask;                                          // 0x0030(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWGameplayGrab*                        ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_StartGrab) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_StartGrab");
static_assert(sizeof(HWCharacterMovementComponent_StartGrab) == 0x000040, "Wrong size on HWCharacterMovementComponent_StartGrab");
static_assert(offsetof(HWCharacterMovementComponent_StartGrab, Grab) == 0x000000, "Member 'HWCharacterMovementComponent_StartGrab::Grab' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartGrab, GrabInfo) == 0x000008, "Member 'HWCharacterMovementComponent_StartGrab::GrabInfo' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartGrab, GrabTask) == 0x000030, "Member 'HWCharacterMovementComponent_StartGrab::GrabTask' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartGrab, ReturnValue) == 0x000038, "Member 'HWCharacterMovementComponent_StartGrab::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.StartNonAbilityTween
// 0x0070 (0x0070 - 0x0000)
struct HWCharacterMovementComponent_StartNonAbilityTween final
{
public:
	TSubclassOf<class UHWGameplayTween>           Tween;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0028)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0030(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationOverride;                                  // 0x0038(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetDest;                                        // 0x0040(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FollowTarget;                                      // 0x0058(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldMaintainCharacterCollision;                 // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWGameplayTween*                       ReturnValue;                                       // 0x0068(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_StartNonAbilityTween) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_StartNonAbilityTween");
static_assert(sizeof(HWCharacterMovementComponent_StartNonAbilityTween) == 0x000070, "Wrong size on HWCharacterMovementComponent_StartNonAbilityTween");
static_assert(offsetof(HWCharacterMovementComponent_StartNonAbilityTween, Tween) == 0x000000, "Member 'HWCharacterMovementComponent_StartNonAbilityTween::Tween' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartNonAbilityTween, TargetData) == 0x000008, "Member 'HWCharacterMovementComponent_StartNonAbilityTween::TargetData' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartNonAbilityTween, Instigator) == 0x000030, "Member 'HWCharacterMovementComponent_StartNonAbilityTween::Instigator' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartNonAbilityTween, DurationOverride) == 0x000038, "Member 'HWCharacterMovementComponent_StartNonAbilityTween::DurationOverride' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartNonAbilityTween, TargetDest) == 0x000040, "Member 'HWCharacterMovementComponent_StartNonAbilityTween::TargetDest' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartNonAbilityTween, FollowTarget) == 0x000058, "Member 'HWCharacterMovementComponent_StartNonAbilityTween::FollowTarget' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartNonAbilityTween, bShouldMaintainCharacterCollision) == 0x000060, "Member 'HWCharacterMovementComponent_StartNonAbilityTween::bShouldMaintainCharacterCollision' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartNonAbilityTween, ReturnValue) == 0x000068, "Member 'HWCharacterMovementComponent_StartNonAbilityTween::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.StartTween
// 0x0058 (0x0058 - 0x0000)
struct HWCharacterMovementComponent_StartTween final
{
public:
	TSubclassOf<class UHWGameplayTween>           Tween;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0028)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0030(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       InstigatingAbility;                                // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationOverride;                                  // 0x0040(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWAbilityTask_GameplayTween*           TaskSource;                                        // 0x0048(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWGameplayTween*                       ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_StartTween) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_StartTween");
static_assert(sizeof(HWCharacterMovementComponent_StartTween) == 0x000058, "Wrong size on HWCharacterMovementComponent_StartTween");
static_assert(offsetof(HWCharacterMovementComponent_StartTween, Tween) == 0x000000, "Member 'HWCharacterMovementComponent_StartTween::Tween' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartTween, TargetData) == 0x000008, "Member 'HWCharacterMovementComponent_StartTween::TargetData' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartTween, Instigator) == 0x000030, "Member 'HWCharacterMovementComponent_StartTween::Instigator' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartTween, InstigatingAbility) == 0x000038, "Member 'HWCharacterMovementComponent_StartTween::InstigatingAbility' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartTween, DurationOverride) == 0x000040, "Member 'HWCharacterMovementComponent_StartTween::DurationOverride' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartTween, TaskSource) == 0x000048, "Member 'HWCharacterMovementComponent_StartTween::TaskSource' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_StartTween, ReturnValue) == 0x000050, "Member 'HWCharacterMovementComponent_StartTween::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetActorDashStoppedOn
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterMovementComponent_GetActorDashStoppedOn final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetActorDashStoppedOn) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_GetActorDashStoppedOn");
static_assert(sizeof(HWCharacterMovementComponent_GetActorDashStoppedOn) == 0x000008, "Wrong size on HWCharacterMovementComponent_GetActorDashStoppedOn");
static_assert(offsetof(HWCharacterMovementComponent_GetActorDashStoppedOn, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_GetActorDashStoppedOn::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetCurrentCustomMovementMode
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterMovementComponent_GetCurrentCustomMovementMode final
{
public:
	EHWCustomMovementMode                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetCurrentCustomMovementMode) == 0x000001, "Wrong alignment on HWCharacterMovementComponent_GetCurrentCustomMovementMode");
static_assert(sizeof(HWCharacterMovementComponent_GetCurrentCustomMovementMode) == 0x000001, "Wrong size on HWCharacterMovementComponent_GetCurrentCustomMovementMode");
static_assert(offsetof(HWCharacterMovementComponent_GetCurrentCustomMovementMode, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_GetCurrentCustomMovementMode::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetCurrentDash
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterMovementComponent_GetCurrentDash final
{
public:
	class UHWGameplayDash*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetCurrentDash) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_GetCurrentDash");
static_assert(sizeof(HWCharacterMovementComponent_GetCurrentDash) == 0x000008, "Wrong size on HWCharacterMovementComponent_GetCurrentDash");
static_assert(offsetof(HWCharacterMovementComponent_GetCurrentDash, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_GetCurrentDash::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetCurrentFlight
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterMovementComponent_GetCurrentFlight final
{
public:
	class UHWGameplayFlight*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetCurrentFlight) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_GetCurrentFlight");
static_assert(sizeof(HWCharacterMovementComponent_GetCurrentFlight) == 0x000008, "Wrong size on HWCharacterMovementComponent_GetCurrentFlight");
static_assert(offsetof(HWCharacterMovementComponent_GetCurrentFlight, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_GetCurrentFlight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetCurrentGrab
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterMovementComponent_GetCurrentGrab final
{
public:
	class UHWGameplayGrab*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetCurrentGrab) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_GetCurrentGrab");
static_assert(sizeof(HWCharacterMovementComponent_GetCurrentGrab) == 0x000008, "Wrong size on HWCharacterMovementComponent_GetCurrentGrab");
static_assert(offsetof(HWCharacterMovementComponent_GetCurrentGrab, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_GetCurrentGrab::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetCurrentLevitationState
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterMovementComponent_GetCurrentLevitationState final
{
public:
	EHWLevitationState                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetCurrentLevitationState) == 0x000001, "Wrong alignment on HWCharacterMovementComponent_GetCurrentLevitationState");
static_assert(sizeof(HWCharacterMovementComponent_GetCurrentLevitationState) == 0x000001, "Wrong size on HWCharacterMovementComponent_GetCurrentLevitationState");
static_assert(offsetof(HWCharacterMovementComponent_GetCurrentLevitationState, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_GetCurrentLevitationState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetCurrentTween
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterMovementComponent_GetCurrentTween final
{
public:
	class UHWGameplayTween*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetCurrentTween) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_GetCurrentTween");
static_assert(sizeof(HWCharacterMovementComponent_GetCurrentTween) == 0x000008, "Wrong size on HWCharacterMovementComponent_GetCurrentTween");
static_assert(offsetof(HWCharacterMovementComponent_GetCurrentTween, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_GetCurrentTween::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetLastValidGroundLocation
// 0x0020 (0x0020 - 0x0000)
struct HWCharacterMovementComponent_GetLastValidGroundLocation final
{
public:
	struct FGameplayTag                           PlaneOfExistence;                                  // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetLastValidGroundLocation) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_GetLastValidGroundLocation");
static_assert(sizeof(HWCharacterMovementComponent_GetLastValidGroundLocation) == 0x000020, "Wrong size on HWCharacterMovementComponent_GetLastValidGroundLocation");
static_assert(offsetof(HWCharacterMovementComponent_GetLastValidGroundLocation, PlaneOfExistence) == 0x000000, "Member 'HWCharacterMovementComponent_GetLastValidGroundLocation::PlaneOfExistence' has a wrong offset!");
static_assert(offsetof(HWCharacterMovementComponent_GetLastValidGroundLocation, ReturnValue) == 0x000008, "Member 'HWCharacterMovementComponent_GetLastValidGroundLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetMaxSpeedWithoutGroundModifier
// 0x0004 (0x0004 - 0x0000)
struct HWCharacterMovementComponent_GetMaxSpeedWithoutGroundModifier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetMaxSpeedWithoutGroundModifier) == 0x000004, "Wrong alignment on HWCharacterMovementComponent_GetMaxSpeedWithoutGroundModifier");
static_assert(sizeof(HWCharacterMovementComponent_GetMaxSpeedWithoutGroundModifier) == 0x000004, "Wrong size on HWCharacterMovementComponent_GetMaxSpeedWithoutGroundModifier");
static_assert(offsetof(HWCharacterMovementComponent_GetMaxSpeedWithoutGroundModifier, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_GetMaxSpeedWithoutGroundModifier::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetPendingGrab
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterMovementComponent_GetPendingGrab final
{
public:
	const class UHWGameplayGrab*                  ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetPendingGrab) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_GetPendingGrab");
static_assert(sizeof(HWCharacterMovementComponent_GetPendingGrab) == 0x000008, "Wrong size on HWCharacterMovementComponent_GetPendingGrab");
static_assert(offsetof(HWCharacterMovementComponent_GetPendingGrab, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_GetPendingGrab::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.GetPendingTween
// 0x0008 (0x0008 - 0x0000)
struct HWCharacterMovementComponent_GetPendingTween final
{
public:
	const class UHWGameplayTween*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_GetPendingTween) == 0x000008, "Wrong alignment on HWCharacterMovementComponent_GetPendingTween");
static_assert(sizeof(HWCharacterMovementComponent_GetPendingTween) == 0x000008, "Wrong size on HWCharacterMovementComponent_GetPendingTween");
static_assert(offsetof(HWCharacterMovementComponent_GetPendingTween, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_GetPendingTween::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacterMovementComponent.HasValidGroundLocation
// 0x0001 (0x0001 - 0x0000)
struct HWCharacterMovementComponent_HasValidGroundLocation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacterMovementComponent_HasValidGroundLocation) == 0x000001, "Wrong alignment on HWCharacterMovementComponent_HasValidGroundLocation");
static_assert(sizeof(HWCharacterMovementComponent_HasValidGroundLocation) == 0x000001, "Wrong size on HWCharacterMovementComponent_HasValidGroundLocation");
static_assert(offsetof(HWCharacterMovementComponent_HasValidGroundLocation, ReturnValue) == 0x000000, "Member 'HWCharacterMovementComponent_HasValidGroundLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWChatManagerMessageFormatter.FormatText
// 0x0038 (0x0038 - 0x0000)
struct HWChatManagerMessageFormatter_FormatText final
{
public:
	class FText                                   InUnformattedText;                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UObject*                          ContextObject;                                     // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWChatManagerMessageFormatter_FormatText) == 0x000008, "Wrong alignment on HWChatManagerMessageFormatter_FormatText");
static_assert(sizeof(HWChatManagerMessageFormatter_FormatText) == 0x000038, "Wrong size on HWChatManagerMessageFormatter_FormatText");
static_assert(offsetof(HWChatManagerMessageFormatter_FormatText, InUnformattedText) == 0x000000, "Member 'HWChatManagerMessageFormatter_FormatText::InUnformattedText' has a wrong offset!");
static_assert(offsetof(HWChatManagerMessageFormatter_FormatText, ContextObject) == 0x000018, "Member 'HWChatManagerMessageFormatter_FormatText::ContextObject' has a wrong offset!");
static_assert(offsetof(HWChatManagerMessageFormatter_FormatText, ReturnValue) == 0x000020, "Member 'HWChatManagerMessageFormatter_FormatText::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelComponent.ApplyApparelAsset
// 0x0010 (0x0010 - 0x0000)
struct HWApparelComponent_ApplyApparelAsset final
{
public:
	class UHWApparelItem*                         ApparelAsset;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWAppliedApparelKey                   OutKey;                                            // 0x0008(0x0004)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWApparelComponent_ApplyApparelAsset) == 0x000008, "Wrong alignment on HWApparelComponent_ApplyApparelAsset");
static_assert(sizeof(HWApparelComponent_ApplyApparelAsset) == 0x000010, "Wrong size on HWApparelComponent_ApplyApparelAsset");
static_assert(offsetof(HWApparelComponent_ApplyApparelAsset, ApparelAsset) == 0x000000, "Member 'HWApparelComponent_ApplyApparelAsset::ApparelAsset' has a wrong offset!");
static_assert(offsetof(HWApparelComponent_ApplyApparelAsset, OutKey) == 0x000008, "Member 'HWApparelComponent_ApplyApparelAsset::OutKey' has a wrong offset!");
static_assert(offsetof(HWApparelComponent_ApplyApparelAsset, ReturnValue) == 0x00000C, "Member 'HWApparelComponent_ApplyApparelAsset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelComponent.RemoveApparelAsset
// 0x0008 (0x0008 - 0x0000)
struct HWApparelComponent_RemoveApparelAsset final
{
public:
	struct FHWAppliedApparelKey                   InKey;                                             // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWApparelComponent_RemoveApparelAsset) == 0x000004, "Wrong alignment on HWApparelComponent_RemoveApparelAsset");
static_assert(sizeof(HWApparelComponent_RemoveApparelAsset) == 0x000008, "Wrong size on HWApparelComponent_RemoveApparelAsset");
static_assert(offsetof(HWApparelComponent_RemoveApparelAsset, InKey) == 0x000000, "Member 'HWApparelComponent_RemoveApparelAsset::InKey' has a wrong offset!");
static_assert(offsetof(HWApparelComponent_RemoveApparelAsset, ReturnValue) == 0x000004, "Member 'HWApparelComponent_RemoveApparelAsset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelComponent.GetSkinnedAudio
// 0x0028 (0x0028 - 0x0000)
struct HWApparelComponent_GetSkinnedAudio final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkinnedMetaSoundInfo                ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWApparelComponent_GetSkinnedAudio) == 0x000008, "Wrong alignment on HWApparelComponent_GetSkinnedAudio");
static_assert(sizeof(HWApparelComponent_GetSkinnedAudio) == 0x000028, "Wrong size on HWApparelComponent_GetSkinnedAudio");
static_assert(offsetof(HWApparelComponent_GetSkinnedAudio, AssetRequest) == 0x000000, "Member 'HWApparelComponent_GetSkinnedAudio::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWApparelComponent_GetSkinnedAudio, ReturnValue) == 0x000020, "Member 'HWApparelComponent_GetSkinnedAudio::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelComponent.GetSkinnedMaterial
// 0x0028 (0x0028 - 0x0000)
struct HWApparelComponent_GetSkinnedMaterial final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkinnedMaterialInfo                 ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWApparelComponent_GetSkinnedMaterial) == 0x000008, "Wrong alignment on HWApparelComponent_GetSkinnedMaterial");
static_assert(sizeof(HWApparelComponent_GetSkinnedMaterial) == 0x000028, "Wrong size on HWApparelComponent_GetSkinnedMaterial");
static_assert(offsetof(HWApparelComponent_GetSkinnedMaterial, AssetRequest) == 0x000000, "Member 'HWApparelComponent_GetSkinnedMaterial::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWApparelComponent_GetSkinnedMaterial, ReturnValue) == 0x000020, "Member 'HWApparelComponent_GetSkinnedMaterial::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelComponent.GetSkinnedMontage
// 0x0038 (0x0038 - 0x0000)
struct HWApparelComponent_GetSkinnedMontage final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWMontageInfo                         ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWApparelComponent_GetSkinnedMontage) == 0x000008, "Wrong alignment on HWApparelComponent_GetSkinnedMontage");
static_assert(sizeof(HWApparelComponent_GetSkinnedMontage) == 0x000038, "Wrong size on HWApparelComponent_GetSkinnedMontage");
static_assert(offsetof(HWApparelComponent_GetSkinnedMontage, AssetRequest) == 0x000000, "Member 'HWApparelComponent_GetSkinnedMontage::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWApparelComponent_GetSkinnedMontage, ReturnValue) == 0x000020, "Member 'HWApparelComponent_GetSkinnedMontage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelComponent.GetSkinnedNiagaraSystem
// 0x0030 (0x0030 - 0x0000)
struct HWApparelComponent_GetSkinnedNiagaraSystem final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkinnedNiagaraInfo                  ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWApparelComponent_GetSkinnedNiagaraSystem) == 0x000008, "Wrong alignment on HWApparelComponent_GetSkinnedNiagaraSystem");
static_assert(sizeof(HWApparelComponent_GetSkinnedNiagaraSystem) == 0x000030, "Wrong size on HWApparelComponent_GetSkinnedNiagaraSystem");
static_assert(offsetof(HWApparelComponent_GetSkinnedNiagaraSystem, AssetRequest) == 0x000000, "Member 'HWApparelComponent_GetSkinnedNiagaraSystem::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWApparelComponent_GetSkinnedNiagaraSystem, ReturnValue) == 0x000020, "Member 'HWApparelComponent_GetSkinnedNiagaraSystem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelComponent.GetSkinnedOptionalDataAsset
// 0x0028 (0x0028 - 0x0000)
struct HWApparelComponent_GetSkinnedOptionalDataAsset final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWDataAssetInfo                       ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWApparelComponent_GetSkinnedOptionalDataAsset) == 0x000008, "Wrong alignment on HWApparelComponent_GetSkinnedOptionalDataAsset");
static_assert(sizeof(HWApparelComponent_GetSkinnedOptionalDataAsset) == 0x000028, "Wrong size on HWApparelComponent_GetSkinnedOptionalDataAsset");
static_assert(offsetof(HWApparelComponent_GetSkinnedOptionalDataAsset, AssetRequest) == 0x000000, "Member 'HWApparelComponent_GetSkinnedOptionalDataAsset::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWApparelComponent_GetSkinnedOptionalDataAsset, ReturnValue) == 0x000020, "Member 'HWApparelComponent_GetSkinnedOptionalDataAsset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelComponent.GetSkinnedSkeletalMesh
// 0x0038 (0x0038 - 0x0000)
struct HWApparelComponent_GetSkinnedSkeletalMesh final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkinnedSkeletalMeshInfo             ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWApparelComponent_GetSkinnedSkeletalMesh) == 0x000008, "Wrong alignment on HWApparelComponent_GetSkinnedSkeletalMesh");
static_assert(sizeof(HWApparelComponent_GetSkinnedSkeletalMesh) == 0x000038, "Wrong size on HWApparelComponent_GetSkinnedSkeletalMesh");
static_assert(offsetof(HWApparelComponent_GetSkinnedSkeletalMesh, AssetRequest) == 0x000000, "Member 'HWApparelComponent_GetSkinnedSkeletalMesh::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWApparelComponent_GetSkinnedSkeletalMesh, ReturnValue) == 0x000020, "Member 'HWApparelComponent_GetSkinnedSkeletalMesh::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelComponent.GetSkinnedStaticMesh
// 0x0028 (0x0028 - 0x0000)
struct HWApparelComponent_GetSkinnedStaticMesh final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkinnedStaticMeshInfo               ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWApparelComponent_GetSkinnedStaticMesh) == 0x000008, "Wrong alignment on HWApparelComponent_GetSkinnedStaticMesh");
static_assert(sizeof(HWApparelComponent_GetSkinnedStaticMesh) == 0x000028, "Wrong size on HWApparelComponent_GetSkinnedStaticMesh");
static_assert(offsetof(HWApparelComponent_GetSkinnedStaticMesh, AssetRequest) == 0x000000, "Member 'HWApparelComponent_GetSkinnedStaticMesh::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWApparelComponent_GetSkinnedStaticMesh, ReturnValue) == 0x000020, "Member 'HWApparelComponent_GetSkinnedStaticMesh::ReturnValue' has a wrong offset!");

// Function Hemingway.HWApparelComponent.IsApparelApplicationPending
// 0x0001 (0x0001 - 0x0000)
struct HWApparelComponent_IsApparelApplicationPending final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWApparelComponent_IsApparelApplicationPending) == 0x000001, "Wrong alignment on HWApparelComponent_IsApparelApplicationPending");
static_assert(sizeof(HWApparelComponent_IsApparelApplicationPending) == 0x000001, "Wrong size on HWApparelComponent_IsApparelApplicationPending");
static_assert(offsetof(HWApparelComponent_IsApparelApplicationPending, ReturnValue) == 0x000000, "Member 'HWApparelComponent_IsApparelApplicationPending::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInWorldTextWidgetComponent.SetInWorldText
// 0x0018 (0x0018 - 0x0000)
struct HWInWorldTextWidgetComponent_SetInWorldText final
{
public:
	class FText                                   NewInWorldText;                                    // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInWorldTextWidgetComponent_SetInWorldText) == 0x000008, "Wrong alignment on HWInWorldTextWidgetComponent_SetInWorldText");
static_assert(sizeof(HWInWorldTextWidgetComponent_SetInWorldText) == 0x000018, "Wrong size on HWInWorldTextWidgetComponent_SetInWorldText");
static_assert(offsetof(HWInWorldTextWidgetComponent_SetInWorldText, NewInWorldText) == 0x000000, "Member 'HWInWorldTextWidgetComponent_SetInWorldText::NewInWorldText' has a wrong offset!");

// Function Hemingway.HWLoadoutComponent.HandleSkinningTargetChanged
// 0x0008 (0x0008 - 0x0000)
struct HWLoadoutComponent_HandleSkinningTargetChanged final
{
public:
	class AActor*                                 NewSkinningTarget;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLoadoutComponent_HandleSkinningTargetChanged) == 0x000008, "Wrong alignment on HWLoadoutComponent_HandleSkinningTargetChanged");
static_assert(sizeof(HWLoadoutComponent_HandleSkinningTargetChanged) == 0x000008, "Wrong size on HWLoadoutComponent_HandleSkinningTargetChanged");
static_assert(offsetof(HWLoadoutComponent_HandleSkinningTargetChanged, NewSkinningTarget) == 0x000000, "Member 'HWLoadoutComponent_HandleSkinningTargetChanged::NewSkinningTarget' has a wrong offset!");

// Function Hemingway.HWLoadoutComponent.ServerLoadCosmeticItems
// 0x0010 (0x0010 - 0x0000)
struct HWLoadoutComponent_ServerLoadCosmeticItems final
{
public:
	TArray<struct FHWCosmeticLoadoutInfo>         Cosmetics;                                         // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLoadoutComponent_ServerLoadCosmeticItems) == 0x000008, "Wrong alignment on HWLoadoutComponent_ServerLoadCosmeticItems");
static_assert(sizeof(HWLoadoutComponent_ServerLoadCosmeticItems) == 0x000010, "Wrong size on HWLoadoutComponent_ServerLoadCosmeticItems");
static_assert(offsetof(HWLoadoutComponent_ServerLoadCosmeticItems, Cosmetics) == 0x000000, "Member 'HWLoadoutComponent_ServerLoadCosmeticItems::Cosmetics' has a wrong offset!");

// Function Hemingway.HWLoadoutComponent.GetAssetBundleForCosmeticTypes
// 0x0020 (0x0020 - 0x0000)
struct HWLoadoutComponent_GetAssetBundleForCosmeticTypes final
{
public:
	TArray<EHWCollectionItemType>                 CosmeticTypes;                                     // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           OutBundles;                                        // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLoadoutComponent_GetAssetBundleForCosmeticTypes) == 0x000008, "Wrong alignment on HWLoadoutComponent_GetAssetBundleForCosmeticTypes");
static_assert(sizeof(HWLoadoutComponent_GetAssetBundleForCosmeticTypes) == 0x000020, "Wrong size on HWLoadoutComponent_GetAssetBundleForCosmeticTypes");
static_assert(offsetof(HWLoadoutComponent_GetAssetBundleForCosmeticTypes, CosmeticTypes) == 0x000000, "Member 'HWLoadoutComponent_GetAssetBundleForCosmeticTypes::CosmeticTypes' has a wrong offset!");
static_assert(offsetof(HWLoadoutComponent_GetAssetBundleForCosmeticTypes, OutBundles) == 0x000010, "Member 'HWLoadoutComponent_GetAssetBundleForCosmeticTypes::OutBundles' has a wrong offset!");

// Function Hemingway.HWLoadoutComponent.GetCosmeticItem
// 0x0010 (0x0010 - 0x0000)
struct HWLoadoutComponent_GetCosmeticItem final
{
public:
	EHWCollectionItemType                         CosmeticItemType;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCollectionItem*                ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLoadoutComponent_GetCosmeticItem) == 0x000008, "Wrong alignment on HWLoadoutComponent_GetCosmeticItem");
static_assert(sizeof(HWLoadoutComponent_GetCosmeticItem) == 0x000010, "Wrong size on HWLoadoutComponent_GetCosmeticItem");
static_assert(offsetof(HWLoadoutComponent_GetCosmeticItem, CosmeticItemType) == 0x000000, "Member 'HWLoadoutComponent_GetCosmeticItem::CosmeticItemType' has a wrong offset!");
static_assert(offsetof(HWLoadoutComponent_GetCosmeticItem, SlotIndex) == 0x000004, "Member 'HWLoadoutComponent_GetCosmeticItem::SlotIndex' has a wrong offset!");
static_assert(offsetof(HWLoadoutComponent_GetCosmeticItem, ReturnValue) == 0x000008, "Member 'HWLoadoutComponent_GetCosmeticItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLoadoutComponent.GetCurrentCharacterItem
// 0x0008 (0x0008 - 0x0000)
struct HWLoadoutComponent_GetCurrentCharacterItem final
{
public:
	const class UHWCharacterItem*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLoadoutComponent_GetCurrentCharacterItem) == 0x000008, "Wrong alignment on HWLoadoutComponent_GetCurrentCharacterItem");
static_assert(sizeof(HWLoadoutComponent_GetCurrentCharacterItem) == 0x000008, "Wrong size on HWLoadoutComponent_GetCurrentCharacterItem");
static_assert(offsetof(HWLoadoutComponent_GetCurrentCharacterItem, ReturnValue) == 0x000000, "Member 'HWLoadoutComponent_GetCurrentCharacterItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLoadoutComponent.GetCurrentSkinItem
// 0x0008 (0x0008 - 0x0000)
struct HWLoadoutComponent_GetCurrentSkinItem final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLoadoutComponent_GetCurrentSkinItem) == 0x000008, "Wrong alignment on HWLoadoutComponent_GetCurrentSkinItem");
static_assert(sizeof(HWLoadoutComponent_GetCurrentSkinItem) == 0x000008, "Wrong size on HWLoadoutComponent_GetCurrentSkinItem");
static_assert(offsetof(HWLoadoutComponent_GetCurrentSkinItem, ReturnValue) == 0x000000, "Member 'HWLoadoutComponent_GetCurrentSkinItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLoadoutComponent.GetCurrentVoicePackItem
// 0x0008 (0x0008 - 0x0000)
struct HWLoadoutComponent_GetCurrentVoicePackItem final
{
public:
	const class UHWVoicePackItem*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLoadoutComponent_GetCurrentVoicePackItem) == 0x000008, "Wrong alignment on HWLoadoutComponent_GetCurrentVoicePackItem");
static_assert(sizeof(HWLoadoutComponent_GetCurrentVoicePackItem) == 0x000008, "Wrong size on HWLoadoutComponent_GetCurrentVoicePackItem");
static_assert(offsetof(HWLoadoutComponent_GetCurrentVoicePackItem, ReturnValue) == 0x000000, "Member 'HWLoadoutComponent_GetCurrentVoicePackItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLoadoutComponent.IsLocalOnlyCosmetic
// 0x0002 (0x0002 - 0x0000)
struct HWLoadoutComponent_IsLocalOnlyCosmetic final
{
public:
	EHWCollectionItemType                         CosmeticType;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLoadoutComponent_IsLocalOnlyCosmetic) == 0x000001, "Wrong alignment on HWLoadoutComponent_IsLocalOnlyCosmetic");
static_assert(sizeof(HWLoadoutComponent_IsLocalOnlyCosmetic) == 0x000002, "Wrong size on HWLoadoutComponent_IsLocalOnlyCosmetic");
static_assert(offsetof(HWLoadoutComponent_IsLocalOnlyCosmetic, CosmeticType) == 0x000000, "Member 'HWLoadoutComponent_IsLocalOnlyCosmetic::CosmeticType' has a wrong offset!");
static_assert(offsetof(HWLoadoutComponent_IsLocalOnlyCosmetic, ReturnValue) == 0x000001, "Member 'HWLoadoutComponent_IsLocalOnlyCosmetic::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectileMovementComponent.SetHomingTargetLocation
// 0x0020 (0x0020 - 0x0000)
struct HWProjectileMovementComponent_SetHomingTargetLocation final
{
public:
	struct FVector                                DesiredHomingLocation;                             // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSeekToLocation_0;                           // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWProjectileMovementComponent_SetHomingTargetLocation) == 0x000008, "Wrong alignment on HWProjectileMovementComponent_SetHomingTargetLocation");
static_assert(sizeof(HWProjectileMovementComponent_SetHomingTargetLocation) == 0x000020, "Wrong size on HWProjectileMovementComponent_SetHomingTargetLocation");
static_assert(offsetof(HWProjectileMovementComponent_SetHomingTargetLocation, DesiredHomingLocation) == 0x000000, "Member 'HWProjectileMovementComponent_SetHomingTargetLocation::DesiredHomingLocation' has a wrong offset!");
static_assert(offsetof(HWProjectileMovementComponent_SetHomingTargetLocation, bShouldSeekToLocation_0) == 0x000018, "Member 'HWProjectileMovementComponent_SetHomingTargetLocation::bShouldSeekToLocation_0' has a wrong offset!");

// Function Hemingway.HWProjectileMovementComponent.GetHomingDirection
// 0x0018 (0x0018 - 0x0000)
struct HWProjectileMovementComponent_GetHomingDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectileMovementComponent_GetHomingDirection) == 0x000008, "Wrong alignment on HWProjectileMovementComponent_GetHomingDirection");
static_assert(sizeof(HWProjectileMovementComponent_GetHomingDirection) == 0x000018, "Wrong size on HWProjectileMovementComponent_GetHomingDirection");
static_assert(offsetof(HWProjectileMovementComponent_GetHomingDirection, ReturnValue) == 0x000000, "Member 'HWProjectileMovementComponent_GetHomingDirection::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectileMovementComponent.GetHomingTargetLocation
// 0x0018 (0x0018 - 0x0000)
struct HWProjectileMovementComponent_GetHomingTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectileMovementComponent_GetHomingTargetLocation) == 0x000008, "Wrong alignment on HWProjectileMovementComponent_GetHomingTargetLocation");
static_assert(sizeof(HWProjectileMovementComponent_GetHomingTargetLocation) == 0x000018, "Wrong size on HWProjectileMovementComponent_GetHomingTargetLocation");
static_assert(offsetof(HWProjectileMovementComponent_GetHomingTargetLocation, ReturnValue) == 0x000000, "Member 'HWProjectileMovementComponent_GetHomingTargetLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWProjectileMovementComponent.IsHomingToLocation
// 0x0001 (0x0001 - 0x0000)
struct HWProjectileMovementComponent_IsHomingToLocation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWProjectileMovementComponent_IsHomingToLocation) == 0x000001, "Wrong alignment on HWProjectileMovementComponent_IsHomingToLocation");
static_assert(sizeof(HWProjectileMovementComponent_IsHomingToLocation) == 0x000001, "Wrong size on HWProjectileMovementComponent_IsHomingToLocation");
static_assert(offsetof(HWProjectileMovementComponent_IsHomingToLocation, ReturnValue) == 0x000000, "Member 'HWProjectileMovementComponent_IsHomingToLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshComponent.AddOverlayMaterial
// 0x0018 (0x0018 - 0x0000)
struct HWSkeletalMeshComponent_AddOverlayMaterial final
{
public:
	class UMaterialInterface*                     NewOverlayMaterial;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PriorityTag;                                       // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PriorityModifier;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWMaterialOverlayHandle               ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkeletalMeshComponent_AddOverlayMaterial) == 0x000008, "Wrong alignment on HWSkeletalMeshComponent_AddOverlayMaterial");
static_assert(sizeof(HWSkeletalMeshComponent_AddOverlayMaterial) == 0x000018, "Wrong size on HWSkeletalMeshComponent_AddOverlayMaterial");
static_assert(offsetof(HWSkeletalMeshComponent_AddOverlayMaterial, NewOverlayMaterial) == 0x000000, "Member 'HWSkeletalMeshComponent_AddOverlayMaterial::NewOverlayMaterial' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_AddOverlayMaterial, PriorityTag) == 0x000008, "Member 'HWSkeletalMeshComponent_AddOverlayMaterial::PriorityTag' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_AddOverlayMaterial, PriorityModifier) == 0x000010, "Member 'HWSkeletalMeshComponent_AddOverlayMaterial::PriorityModifier' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_AddOverlayMaterial, ReturnValue) == 0x000014, "Member 'HWSkeletalMeshComponent_AddOverlayMaterial::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshComponent.ApplyNewMaterialWithOldMaterialsTextures
// 0x0028 (0x0028 - 0x0000)
struct HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures final
{
public:
	class UMaterialInterface*                     NewMaterialTemplate;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearOverlayMaterials;                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SwapDiffuse;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SwapNormal;                                        // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SwapP1;                                            // 0x000B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DiffuseMapParameterName;                           // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NormalMapParameterName;                            // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   P1ParameterName;                                   // 0x001C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures) == 0x000008, "Wrong alignment on HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures");
static_assert(sizeof(HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures) == 0x000028, "Wrong size on HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures");
static_assert(offsetof(HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures, NewMaterialTemplate) == 0x000000, "Member 'HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures::NewMaterialTemplate' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures, bClearOverlayMaterials) == 0x000008, "Member 'HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures::bClearOverlayMaterials' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures, SwapDiffuse) == 0x000009, "Member 'HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures::SwapDiffuse' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures, SwapNormal) == 0x00000A, "Member 'HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures::SwapNormal' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures, SwapP1) == 0x00000B, "Member 'HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures::SwapP1' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures, DiffuseMapParameterName) == 0x00000C, "Member 'HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures::DiffuseMapParameterName' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures, NormalMapParameterName) == 0x000014, "Member 'HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures::NormalMapParameterName' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures, P1ParameterName) == 0x00001C, "Member 'HWSkeletalMeshComponent_ApplyNewMaterialWithOldMaterialsTextures::P1ParameterName' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshComponent.FreezeSkeleton
// 0x0001 (0x0001 - 0x0000)
struct HWSkeletalMeshComponent_FreezeSkeleton final
{
public:
	bool                                          bFreeze;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkeletalMeshComponent_FreezeSkeleton) == 0x000001, "Wrong alignment on HWSkeletalMeshComponent_FreezeSkeleton");
static_assert(sizeof(HWSkeletalMeshComponent_FreezeSkeleton) == 0x000001, "Wrong size on HWSkeletalMeshComponent_FreezeSkeleton");
static_assert(offsetof(HWSkeletalMeshComponent_FreezeSkeleton, bFreeze) == 0x000000, "Member 'HWSkeletalMeshComponent_FreezeSkeleton::bFreeze' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshComponent.HandleOnDeath
// 0x0070 (0x0070 - 0x0000)
struct HWSkeletalMeshComponent_HandleOnDeath final
{
public:
	struct FDamageEventData                       DeathEventData;                                    // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkeletalMeshComponent_HandleOnDeath) == 0x000008, "Wrong alignment on HWSkeletalMeshComponent_HandleOnDeath");
static_assert(sizeof(HWSkeletalMeshComponent_HandleOnDeath) == 0x000070, "Wrong size on HWSkeletalMeshComponent_HandleOnDeath");
static_assert(offsetof(HWSkeletalMeshComponent_HandleOnDeath, DeathEventData) == 0x000000, "Member 'HWSkeletalMeshComponent_HandleOnDeath::DeathEventData' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshComponent.RemoveOverlayMaterial
// 0x0004 (0x0004 - 0x0000)
struct HWSkeletalMeshComponent_RemoveOverlayMaterial final
{
public:
	struct FHWMaterialOverlayHandle               Handle;                                            // 0x0000(0x0004)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkeletalMeshComponent_RemoveOverlayMaterial) == 0x000004, "Wrong alignment on HWSkeletalMeshComponent_RemoveOverlayMaterial");
static_assert(sizeof(HWSkeletalMeshComponent_RemoveOverlayMaterial) == 0x000004, "Wrong size on HWSkeletalMeshComponent_RemoveOverlayMaterial");
static_assert(offsetof(HWSkeletalMeshComponent_RemoveOverlayMaterial, Handle) == 0x000000, "Member 'HWSkeletalMeshComponent_RemoveOverlayMaterial::Handle' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshComponent.IsOverlayMaterialActive
// 0x0008 (0x0008 - 0x0000)
struct HWSkeletalMeshComponent_IsOverlayMaterialActive final
{
public:
	struct FHWMaterialOverlayHandle               Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSkeletalMeshComponent_IsOverlayMaterialActive) == 0x000004, "Wrong alignment on HWSkeletalMeshComponent_IsOverlayMaterialActive");
static_assert(sizeof(HWSkeletalMeshComponent_IsOverlayMaterialActive) == 0x000008, "Wrong size on HWSkeletalMeshComponent_IsOverlayMaterialActive");
static_assert(offsetof(HWSkeletalMeshComponent_IsOverlayMaterialActive, Handle) == 0x000000, "Member 'HWSkeletalMeshComponent_IsOverlayMaterialActive::Handle' has a wrong offset!");
static_assert(offsetof(HWSkeletalMeshComponent_IsOverlayMaterialActive, ReturnValue) == 0x000004, "Member 'HWSkeletalMeshComponent_IsOverlayMaterialActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshComponent.IsUsingTemporaryMeshOverride
// 0x0001 (0x0001 - 0x0000)
struct HWSkeletalMeshComponent_IsUsingTemporaryMeshOverride final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkeletalMeshComponent_IsUsingTemporaryMeshOverride) == 0x000001, "Wrong alignment on HWSkeletalMeshComponent_IsUsingTemporaryMeshOverride");
static_assert(sizeof(HWSkeletalMeshComponent_IsUsingTemporaryMeshOverride) == 0x000001, "Wrong size on HWSkeletalMeshComponent_IsUsingTemporaryMeshOverride");
static_assert(offsetof(HWSkeletalMeshComponent_IsUsingTemporaryMeshOverride, ReturnValue) == 0x000000, "Member 'HWSkeletalMeshComponent_IsUsingTemporaryMeshOverride::ReturnValue' has a wrong offset!");

// Function Hemingway.HWVgsComponent.HandleOnNewSkinTagAsset
// 0x0010 (0x0010 - 0x0000)
struct HWVgsComponent_HandleOnNewSkinTagAsset final
{
public:
	TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVgsComponent_HandleOnNewSkinTagAsset) == 0x000008, "Wrong alignment on HWVgsComponent_HandleOnNewSkinTagAsset");
static_assert(sizeof(HWVgsComponent_HandleOnNewSkinTagAsset) == 0x000010, "Wrong size on HWVgsComponent_HandleOnNewSkinTagAsset");
static_assert(offsetof(HWVgsComponent_HandleOnNewSkinTagAsset, NewSkinTagAsset) == 0x000000, "Member 'HWVgsComponent_HandleOnNewSkinTagAsset::NewSkinTagAsset' has a wrong offset!");

// Function Hemingway.HWVgsComponent.HandleOnSkinTagAssetRemoved
// 0x0010 (0x0010 - 0x0000)
struct HWVgsComponent_HandleOnSkinTagAssetRemoved final
{
public:
	TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove;                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVgsComponent_HandleOnSkinTagAssetRemoved) == 0x000008, "Wrong alignment on HWVgsComponent_HandleOnSkinTagAssetRemoved");
static_assert(sizeof(HWVgsComponent_HandleOnSkinTagAssetRemoved) == 0x000010, "Wrong size on HWVgsComponent_HandleOnSkinTagAssetRemoved");
static_assert(offsetof(HWVgsComponent_HandleOnSkinTagAssetRemoved, SkinTagAssetToRemove) == 0x000000, "Member 'HWVgsComponent_HandleOnSkinTagAssetRemoved::SkinTagAssetToRemove' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent_PlayableCharacter.HandleAbilitySystemUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWVisibilityComponent_PlayableCharacter_HandleAbilitySystemUpdated final
{
public:
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVisibilityComponent_PlayableCharacter_HandleAbilitySystemUpdated) == 0x000008, "Wrong alignment on HWVisibilityComponent_PlayableCharacter_HandleAbilitySystemUpdated");
static_assert(sizeof(HWVisibilityComponent_PlayableCharacter_HandleAbilitySystemUpdated) == 0x000008, "Wrong size on HWVisibilityComponent_PlayableCharacter_HandleAbilitySystemUpdated");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_HandleAbilitySystemUpdated, AbilitySystem) == 0x000000, "Member 'HWVisibilityComponent_PlayableCharacter_HandleAbilitySystemUpdated::AbilitySystem' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent_PlayableCharacter.HandleCharacterChanged
// 0x0010 (0x0010 - 0x0000)
struct HWVisibilityComponent_PlayableCharacter_HandleCharacterChanged final
{
public:
	class AHWCharacterAbilitySystemActor*         CharacterAbilitySystemActor;                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      NewCharacterOwner;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVisibilityComponent_PlayableCharacter_HandleCharacterChanged) == 0x000008, "Wrong alignment on HWVisibilityComponent_PlayableCharacter_HandleCharacterChanged");
static_assert(sizeof(HWVisibilityComponent_PlayableCharacter_HandleCharacterChanged) == 0x000010, "Wrong size on HWVisibilityComponent_PlayableCharacter_HandleCharacterChanged");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_HandleCharacterChanged, CharacterAbilitySystemActor) == 0x000000, "Member 'HWVisibilityComponent_PlayableCharacter_HandleCharacterChanged::CharacterAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_HandleCharacterChanged, NewCharacterOwner) == 0x000008, "Member 'HWVisibilityComponent_PlayableCharacter_HandleCharacterChanged::NewCharacterOwner' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent_PlayableCharacter.HandleCharacterTeamUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWVisibilityComponent_PlayableCharacter_HandleCharacterTeamUpdated final
{
public:
	class AHWCharacterAbilitySystemActor*         OwningAbilitySystemActor;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamState*                           InTeamState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVisibilityComponent_PlayableCharacter_HandleCharacterTeamUpdated) == 0x000008, "Wrong alignment on HWVisibilityComponent_PlayableCharacter_HandleCharacterTeamUpdated");
static_assert(sizeof(HWVisibilityComponent_PlayableCharacter_HandleCharacterTeamUpdated) == 0x000010, "Wrong size on HWVisibilityComponent_PlayableCharacter_HandleCharacterTeamUpdated");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_HandleCharacterTeamUpdated, OwningAbilitySystemActor) == 0x000000, "Member 'HWVisibilityComponent_PlayableCharacter_HandleCharacterTeamUpdated::OwningAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_HandleCharacterTeamUpdated, InTeamState) == 0x000008, "Member 'HWVisibilityComponent_PlayableCharacter_HandleCharacterTeamUpdated::InTeamState' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent_PlayableCharacter.HandleTagUpdated_CharacterVisibilityHide
// 0x000C (0x000C - 0x0000)
struct HWVisibilityComponent_PlayableCharacter_HandleTagUpdated_CharacterVisibilityHide final
{
public:
	struct FGameplayTag                           CallbackTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVisibilityComponent_PlayableCharacter_HandleTagUpdated_CharacterVisibilityHide) == 0x000004, "Wrong alignment on HWVisibilityComponent_PlayableCharacter_HandleTagUpdated_CharacterVisibilityHide");
static_assert(sizeof(HWVisibilityComponent_PlayableCharacter_HandleTagUpdated_CharacterVisibilityHide) == 0x00000C, "Wrong size on HWVisibilityComponent_PlayableCharacter_HandleTagUpdated_CharacterVisibilityHide");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_HandleTagUpdated_CharacterVisibilityHide, CallbackTag) == 0x000000, "Member 'HWVisibilityComponent_PlayableCharacter_HandleTagUpdated_CharacterVisibilityHide::CallbackTag' has a wrong offset!");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_HandleTagUpdated_CharacterVisibilityHide, NewCount) == 0x000008, "Member 'HWVisibilityComponent_PlayableCharacter_HandleTagUpdated_CharacterVisibilityHide::NewCount' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent_PlayableCharacter.OnLocalControllerTeamUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWVisibilityComponent_PlayableCharacter_OnLocalControllerTeamUpdated final
{
public:
	class AController*                            LocalController;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamId;                                            // 0x0008(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWVisibilityComponent_PlayableCharacter_OnLocalControllerTeamUpdated) == 0x000008, "Wrong alignment on HWVisibilityComponent_PlayableCharacter_OnLocalControllerTeamUpdated");
static_assert(sizeof(HWVisibilityComponent_PlayableCharacter_OnLocalControllerTeamUpdated) == 0x000010, "Wrong size on HWVisibilityComponent_PlayableCharacter_OnLocalControllerTeamUpdated");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_OnLocalControllerTeamUpdated, LocalController) == 0x000000, "Member 'HWVisibilityComponent_PlayableCharacter_OnLocalControllerTeamUpdated::LocalController' has a wrong offset!");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_OnLocalControllerTeamUpdated, TeamId) == 0x000008, "Member 'HWVisibilityComponent_PlayableCharacter_OnLocalControllerTeamUpdated::TeamId' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent_PlayableCharacter.OnOwnerTeamChanged
// 0x0010 (0x0010 - 0x0000)
struct HWVisibilityComponent_PlayableCharacter_OnOwnerTeamChanged final
{
public:
	class AHWCharacterAbilitySystemActor*         CharacterAbilitySystemActor;                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamState*                           TeamState;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVisibilityComponent_PlayableCharacter_OnOwnerTeamChanged) == 0x000008, "Wrong alignment on HWVisibilityComponent_PlayableCharacter_OnOwnerTeamChanged");
static_assert(sizeof(HWVisibilityComponent_PlayableCharacter_OnOwnerTeamChanged) == 0x000010, "Wrong size on HWVisibilityComponent_PlayableCharacter_OnOwnerTeamChanged");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_OnOwnerTeamChanged, CharacterAbilitySystemActor) == 0x000000, "Member 'HWVisibilityComponent_PlayableCharacter_OnOwnerTeamChanged::CharacterAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_OnOwnerTeamChanged, TeamState) == 0x000008, "Member 'HWVisibilityComponent_PlayableCharacter_OnOwnerTeamChanged::TeamState' has a wrong offset!");

// Function Hemingway.HWVisibilityComponent_PlayableCharacter.OnOwningPlayerStateChanged
// 0x0010 (0x0010 - 0x0000)
struct HWVisibilityComponent_PlayableCharacter_OnOwningPlayerStateChanged final
{
public:
	class AHWCharacterAbilitySystemActor*         CharacterAbilitySystemActor;                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         PlayerState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVisibilityComponent_PlayableCharacter_OnOwningPlayerStateChanged) == 0x000008, "Wrong alignment on HWVisibilityComponent_PlayableCharacter_OnOwningPlayerStateChanged");
static_assert(sizeof(HWVisibilityComponent_PlayableCharacter_OnOwningPlayerStateChanged) == 0x000010, "Wrong size on HWVisibilityComponent_PlayableCharacter_OnOwningPlayerStateChanged");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_OnOwningPlayerStateChanged, CharacterAbilitySystemActor) == 0x000000, "Member 'HWVisibilityComponent_PlayableCharacter_OnOwningPlayerStateChanged::CharacterAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWVisibilityComponent_PlayableCharacter_OnOwningPlayerStateChanged, PlayerState) == 0x000008, "Member 'HWVisibilityComponent_PlayableCharacter_OnOwningPlayerStateChanged::PlayerState' has a wrong offset!");

// Function Hemingway.HWDisplayInfoManager.AddDisplayInfo
// 0x0038 (0x0038 - 0x0000)
struct HWDisplayInfoManager_AddDisplayInfo final
{
public:
	struct FHWDisplayInfo                         DisplayInfo;                                       // 0x0000(0x0030)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsInstant;                                        // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0034(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoManager_AddDisplayInfo) == 0x000008, "Wrong alignment on HWDisplayInfoManager_AddDisplayInfo");
static_assert(sizeof(HWDisplayInfoManager_AddDisplayInfo) == 0x000038, "Wrong size on HWDisplayInfoManager_AddDisplayInfo");
static_assert(offsetof(HWDisplayInfoManager_AddDisplayInfo, DisplayInfo) == 0x000000, "Member 'HWDisplayInfoManager_AddDisplayInfo::DisplayInfo' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoManager_AddDisplayInfo, bIsInstant) == 0x000030, "Member 'HWDisplayInfoManager_AddDisplayInfo::bIsInstant' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoManager_AddDisplayInfo, ReturnValue) == 0x000034, "Member 'HWDisplayInfoManager_AddDisplayInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoManager.HideDisplayInfo
// 0x0004 (0x0004 - 0x0000)
struct HWDisplayInfoManager_HideDisplayInfo final
{
public:
	int32                                         DisplayInfoId;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoManager_HideDisplayInfo) == 0x000004, "Wrong alignment on HWDisplayInfoManager_HideDisplayInfo");
static_assert(sizeof(HWDisplayInfoManager_HideDisplayInfo) == 0x000004, "Wrong size on HWDisplayInfoManager_HideDisplayInfo");
static_assert(offsetof(HWDisplayInfoManager_HideDisplayInfo, DisplayInfoId) == 0x000000, "Member 'HWDisplayInfoManager_HideDisplayInfo::DisplayInfoId' has a wrong offset!");

// Function Hemingway.HWDisplayInfoManager.RemoveActorDisplayInfos
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoManager_RemoveActorDisplayInfos final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoManager_RemoveActorDisplayInfos) == 0x000008, "Wrong alignment on HWDisplayInfoManager_RemoveActorDisplayInfos");
static_assert(sizeof(HWDisplayInfoManager_RemoveActorDisplayInfos) == 0x000008, "Wrong size on HWDisplayInfoManager_RemoveActorDisplayInfos");
static_assert(offsetof(HWDisplayInfoManager_RemoveActorDisplayInfos, InActor) == 0x000000, "Member 'HWDisplayInfoManager_RemoveActorDisplayInfos::InActor' has a wrong offset!");

// Function Hemingway.HWDisplayInfoManager.RemoveDisplayInfo
// 0x0004 (0x0004 - 0x0000)
struct HWDisplayInfoManager_RemoveDisplayInfo final
{
public:
	int32                                         DisplayInfoId;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoManager_RemoveDisplayInfo) == 0x000004, "Wrong alignment on HWDisplayInfoManager_RemoveDisplayInfo");
static_assert(sizeof(HWDisplayInfoManager_RemoveDisplayInfo) == 0x000004, "Wrong size on HWDisplayInfoManager_RemoveDisplayInfo");
static_assert(offsetof(HWDisplayInfoManager_RemoveDisplayInfo, DisplayInfoId) == 0x000000, "Member 'HWDisplayInfoManager_RemoveDisplayInfo::DisplayInfoId' has a wrong offset!");

// Function Hemingway.HWDisplayInfoManager.SetDisplayInfoLifespan
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoManager_SetDisplayInfoLifespan final
{
public:
	int32                                         DisplayInfoId;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewLifespan;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoManager_SetDisplayInfoLifespan) == 0x000004, "Wrong alignment on HWDisplayInfoManager_SetDisplayInfoLifespan");
static_assert(sizeof(HWDisplayInfoManager_SetDisplayInfoLifespan) == 0x000008, "Wrong size on HWDisplayInfoManager_SetDisplayInfoLifespan");
static_assert(offsetof(HWDisplayInfoManager_SetDisplayInfoLifespan, DisplayInfoId) == 0x000000, "Member 'HWDisplayInfoManager_SetDisplayInfoLifespan::DisplayInfoId' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoManager_SetDisplayInfoLifespan, NewLifespan) == 0x000004, "Member 'HWDisplayInfoManager_SetDisplayInfoLifespan::NewLifespan' has a wrong offset!");

// Function Hemingway.HWDisplayInfoManager.ShowDisplayInfo
// 0x0004 (0x0004 - 0x0000)
struct HWDisplayInfoManager_ShowDisplayInfo final
{
public:
	int32                                         DisplayInfoId;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoManager_ShowDisplayInfo) == 0x000004, "Wrong alignment on HWDisplayInfoManager_ShowDisplayInfo");
static_assert(sizeof(HWDisplayInfoManager_ShowDisplayInfo) == 0x000004, "Wrong size on HWDisplayInfoManager_ShowDisplayInfo");
static_assert(offsetof(HWDisplayInfoManager_ShowDisplayInfo, DisplayInfoId) == 0x000000, "Member 'HWDisplayInfoManager_ShowDisplayInfo::DisplayInfoId' has a wrong offset!");

// Function Hemingway.HWDisplayInfoManager.GetDisplayInfo
// 0x0040 (0x0040 - 0x0000)
struct HWDisplayInfoManager_GetDisplayInfo final
{
public:
	int32                                         DisplayInfoId;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWDisplayInfo                         OutDisplayInfo;                                    // 0x0008(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OutRemainingTime;                                  // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDisplayInfoManager_GetDisplayInfo) == 0x000008, "Wrong alignment on HWDisplayInfoManager_GetDisplayInfo");
static_assert(sizeof(HWDisplayInfoManager_GetDisplayInfo) == 0x000040, "Wrong size on HWDisplayInfoManager_GetDisplayInfo");
static_assert(offsetof(HWDisplayInfoManager_GetDisplayInfo, DisplayInfoId) == 0x000000, "Member 'HWDisplayInfoManager_GetDisplayInfo::DisplayInfoId' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoManager_GetDisplayInfo, OutDisplayInfo) == 0x000008, "Member 'HWDisplayInfoManager_GetDisplayInfo::OutDisplayInfo' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoManager_GetDisplayInfo, OutRemainingTime) == 0x000038, "Member 'HWDisplayInfoManager_GetDisplayInfo::OutRemainingTime' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoManager_GetDisplayInfo, ReturnValue) == 0x00003C, "Member 'HWDisplayInfoManager_GetDisplayInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDisplayInfoManager.GetDisplayInfos
// 0x0010 (0x0010 - 0x0000)
struct HWDisplayInfoManager_GetDisplayInfos final
{
public:
	TArray<struct FHWDisplayInfo>                 OutDisplayInfos;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDisplayInfoManager_GetDisplayInfos) == 0x000008, "Wrong alignment on HWDisplayInfoManager_GetDisplayInfos");
static_assert(sizeof(HWDisplayInfoManager_GetDisplayInfos) == 0x000010, "Wrong size on HWDisplayInfoManager_GetDisplayInfos");
static_assert(offsetof(HWDisplayInfoManager_GetDisplayInfos, OutDisplayInfos) == 0x000000, "Member 'HWDisplayInfoManager_GetDisplayInfos::OutDisplayInfos' has a wrong offset!");

// Function Hemingway.HWDisplayInfoManager.IsDisplayInfoIdValid
// 0x0008 (0x0008 - 0x0000)
struct HWDisplayInfoManager_IsDisplayInfoIdValid final
{
public:
	int32                                         DisplayInfoId;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDisplayInfoManager_IsDisplayInfoIdValid) == 0x000004, "Wrong alignment on HWDisplayInfoManager_IsDisplayInfoIdValid");
static_assert(sizeof(HWDisplayInfoManager_IsDisplayInfoIdValid) == 0x000008, "Wrong size on HWDisplayInfoManager_IsDisplayInfoIdValid");
static_assert(offsetof(HWDisplayInfoManager_IsDisplayInfoIdValid, DisplayInfoId) == 0x000000, "Member 'HWDisplayInfoManager_IsDisplayInfoIdValid::DisplayInfoId' has a wrong offset!");
static_assert(offsetof(HWDisplayInfoManager_IsDisplayInfoIdValid, ReturnValue) == 0x000004, "Member 'HWDisplayInfoManager_IsDisplayInfoIdValid::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_AbilitySwap.AccrueAdditionalCooldownCost
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_AbilitySwap_AccrueAdditionalCooldownCost final
{
public:
	int32                                         AbilitySwapIndex;                                  // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_AbilitySwap_AccrueAdditionalCooldownCost) == 0x000004, "Wrong alignment on HWEquipmentComponent_AbilitySwap_AccrueAdditionalCooldownCost");
static_assert(sizeof(HWEquipmentComponent_AbilitySwap_AccrueAdditionalCooldownCost) == 0x000004, "Wrong size on HWEquipmentComponent_AbilitySwap_AccrueAdditionalCooldownCost");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_AccrueAdditionalCooldownCost, AbilitySwapIndex) == 0x000000, "Member 'HWEquipmentComponent_AbilitySwap_AccrueAdditionalCooldownCost::AbilitySwapIndex' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_AbilitySwap.Server_SwapAbilitySlots
// 0x0040 (0x0040 - 0x0000)
struct HWEquipmentComponent_AbilitySwap_Server_SwapAbilitySlots final
{
public:
	struct FHWAbilitySwapInfo                     SwapInfo;                                          // 0x0000(0x0040)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_AbilitySwap_Server_SwapAbilitySlots) == 0x000008, "Wrong alignment on HWEquipmentComponent_AbilitySwap_Server_SwapAbilitySlots");
static_assert(sizeof(HWEquipmentComponent_AbilitySwap_Server_SwapAbilitySlots) == 0x000040, "Wrong size on HWEquipmentComponent_AbilitySwap_Server_SwapAbilitySlots");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_Server_SwapAbilitySlots, SwapInfo) == 0x000000, "Member 'HWEquipmentComponent_AbilitySwap_Server_SwapAbilitySlots::SwapInfo' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_AbilitySwap.SwapAbilitySlots
// 0x0048 (0x0048 - 0x0000)
struct HWEquipmentComponent_AbilitySwap_SwapAbilitySlots final
{
public:
	struct FHWAbilitySwapInfo                     SwapInfo;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_AbilitySwap_SwapAbilitySlots) == 0x000008, "Wrong alignment on HWEquipmentComponent_AbilitySwap_SwapAbilitySlots");
static_assert(sizeof(HWEquipmentComponent_AbilitySwap_SwapAbilitySlots) == 0x000048, "Wrong size on HWEquipmentComponent_AbilitySwap_SwapAbilitySlots");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_SwapAbilitySlots, SwapInfo) == 0x000000, "Member 'HWEquipmentComponent_AbilitySwap_SwapAbilitySlots::SwapInfo' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_SwapAbilitySlots, ReturnValue) == 0x000040, "Member 'HWEquipmentComponent_AbilitySwap_SwapAbilitySlots::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_AbilitySwap.TriggerAbilitySwap
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap final
{
public:
	class UHWGameplayAbility*                     AbilityInstance;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilitySwapIndex;                                  // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap) == 0x000008, "Wrong alignment on HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap");
static_assert(sizeof(HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap) == 0x000010, "Wrong size on HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap, AbilityInstance) == 0x000000, "Member 'HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap::AbilityInstance' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap, AbilitySwapIndex) == 0x000008, "Member 'HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap::AbilitySwapIndex' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap, ReturnValue) == 0x00000C, "Member 'HWEquipmentComponent_AbilitySwap_TriggerAbilitySwap::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_AbilitySwap.GetAbilitySwapBehavior
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_AbilitySwap_GetAbilitySwapBehavior final
{
public:
	EHWAbilitySwapBehavior                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_AbilitySwap_GetAbilitySwapBehavior) == 0x000001, "Wrong alignment on HWEquipmentComponent_AbilitySwap_GetAbilitySwapBehavior");
static_assert(sizeof(HWEquipmentComponent_AbilitySwap_GetAbilitySwapBehavior) == 0x000001, "Wrong size on HWEquipmentComponent_AbilitySwap_GetAbilitySwapBehavior");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_GetAbilitySwapBehavior, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_AbilitySwap_GetAbilitySwapBehavior::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_AbilitySwap.GetAbilitySwapWindowDuration
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_AbilitySwap_GetAbilitySwapWindowDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_AbilitySwap_GetAbilitySwapWindowDuration) == 0x000004, "Wrong alignment on HWEquipmentComponent_AbilitySwap_GetAbilitySwapWindowDuration");
static_assert(sizeof(HWEquipmentComponent_AbilitySwap_GetAbilitySwapWindowDuration) == 0x000004, "Wrong size on HWEquipmentComponent_AbilitySwap_GetAbilitySwapWindowDuration");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_GetAbilitySwapWindowDuration, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_AbilitySwap_GetAbilitySwapWindowDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_AbilitySwap.GetElapsedAbilitySwapWindowTime
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_AbilitySwap_GetElapsedAbilitySwapWindowTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_AbilitySwap_GetElapsedAbilitySwapWindowTime) == 0x000004, "Wrong alignment on HWEquipmentComponent_AbilitySwap_GetElapsedAbilitySwapWindowTime");
static_assert(sizeof(HWEquipmentComponent_AbilitySwap_GetElapsedAbilitySwapWindowTime) == 0x000004, "Wrong size on HWEquipmentComponent_AbilitySwap_GetElapsedAbilitySwapWindowTime");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_GetElapsedAbilitySwapWindowTime, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_AbilitySwap_GetElapsedAbilitySwapWindowTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_AbilitySwap.IsAbilitySwapWindowActive
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_AbilitySwap_IsAbilitySwapWindowActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_AbilitySwap_IsAbilitySwapWindowActive) == 0x000001, "Wrong alignment on HWEquipmentComponent_AbilitySwap_IsAbilitySwapWindowActive");
static_assert(sizeof(HWEquipmentComponent_AbilitySwap_IsAbilitySwapWindowActive) == 0x000001, "Wrong size on HWEquipmentComponent_AbilitySwap_IsAbilitySwapWindowActive");
static_assert(offsetof(HWEquipmentComponent_AbilitySwap_IsAbilitySwapWindowActive, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_AbilitySwap_IsAbilitySwapWindowActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.ConsumeAllAmmo
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Ammo_ConsumeAllAmmo final
{
public:
	bool                                          bSkipCooldown;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_ConsumeAllAmmo) == 0x000001, "Wrong alignment on HWEquipmentComponent_Ammo_ConsumeAllAmmo");
static_assert(sizeof(HWEquipmentComponent_Ammo_ConsumeAllAmmo) == 0x000001, "Wrong size on HWEquipmentComponent_Ammo_ConsumeAllAmmo");
static_assert(offsetof(HWEquipmentComponent_Ammo_ConsumeAllAmmo, bSkipCooldown) == 0x000000, "Member 'HWEquipmentComponent_Ammo_ConsumeAllAmmo::bSkipCooldown' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.ConsumeAmmo
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponent_Ammo_ConsumeAmmo final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCooldown;                                     // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_Ammo_ConsumeAmmo) == 0x000004, "Wrong alignment on HWEquipmentComponent_Ammo_ConsumeAmmo");
static_assert(sizeof(HWEquipmentComponent_Ammo_ConsumeAmmo) == 0x000008, "Wrong size on HWEquipmentComponent_Ammo_ConsumeAmmo");
static_assert(offsetof(HWEquipmentComponent_Ammo_ConsumeAmmo, Amount) == 0x000000, "Member 'HWEquipmentComponent_Ammo_ConsumeAmmo::Amount' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_Ammo_ConsumeAmmo, bSkipCooldown) == 0x000004, "Member 'HWEquipmentComponent_Ammo_ConsumeAmmo::bSkipCooldown' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.DoesAmmoRegenerateOverTime
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Ammo_DoesAmmoRegenerateOverTime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_DoesAmmoRegenerateOverTime) == 0x000001, "Wrong alignment on HWEquipmentComponent_Ammo_DoesAmmoRegenerateOverTime");
static_assert(sizeof(HWEquipmentComponent_Ammo_DoesAmmoRegenerateOverTime) == 0x000001, "Wrong size on HWEquipmentComponent_Ammo_DoesAmmoRegenerateOverTime");
static_assert(offsetof(HWEquipmentComponent_Ammo_DoesAmmoRegenerateOverTime, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Ammo_DoesAmmoRegenerateOverTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.GrantAmmo
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Ammo_GrantAmmo final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_GrantAmmo) == 0x000004, "Wrong alignment on HWEquipmentComponent_Ammo_GrantAmmo");
static_assert(sizeof(HWEquipmentComponent_Ammo_GrantAmmo) == 0x000004, "Wrong size on HWEquipmentComponent_Ammo_GrantAmmo");
static_assert(offsetof(HWEquipmentComponent_Ammo_GrantAmmo, Amount) == 0x000000, "Member 'HWEquipmentComponent_Ammo_GrantAmmo::Amount' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.HandleEquipmentLevelChanged
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentComponent_Ammo_HandleEquipmentLevelChanged final
{
public:
	class UHWEquipmentInstance*                   Equipment;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousLevel;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_Ammo_HandleEquipmentLevelChanged) == 0x000008, "Wrong alignment on HWEquipmentComponent_Ammo_HandleEquipmentLevelChanged");
static_assert(sizeof(HWEquipmentComponent_Ammo_HandleEquipmentLevelChanged) == 0x000010, "Wrong size on HWEquipmentComponent_Ammo_HandleEquipmentLevelChanged");
static_assert(offsetof(HWEquipmentComponent_Ammo_HandleEquipmentLevelChanged, Equipment) == 0x000000, "Member 'HWEquipmentComponent_Ammo_HandleEquipmentLevelChanged::Equipment' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_Ammo_HandleEquipmentLevelChanged, PreviousLevel) == 0x000008, "Member 'HWEquipmentComponent_Ammo_HandleEquipmentLevelChanged::PreviousLevel' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.OnAmmoChanged
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Ammo_OnAmmoChanged final
{
public:
	int32                                         OldAmmoAmount;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_OnAmmoChanged) == 0x000004, "Wrong alignment on HWEquipmentComponent_Ammo_OnAmmoChanged");
static_assert(sizeof(HWEquipmentComponent_Ammo_OnAmmoChanged) == 0x000004, "Wrong size on HWEquipmentComponent_Ammo_OnAmmoChanged");
static_assert(offsetof(HWEquipmentComponent_Ammo_OnAmmoChanged, OldAmmoAmount) == 0x000000, "Member 'HWEquipmentComponent_Ammo_OnAmmoChanged::OldAmmoAmount' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.OnRefillTagUpdated
// 0x000C (0x000C - 0x0000)
struct HWEquipmentComponent_Ammo_OnRefillTagUpdated final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_OnRefillTagUpdated) == 0x000004, "Wrong alignment on HWEquipmentComponent_Ammo_OnRefillTagUpdated");
static_assert(sizeof(HWEquipmentComponent_Ammo_OnRefillTagUpdated) == 0x00000C, "Wrong size on HWEquipmentComponent_Ammo_OnRefillTagUpdated");
static_assert(offsetof(HWEquipmentComponent_Ammo_OnRefillTagUpdated, Tag) == 0x000000, "Member 'HWEquipmentComponent_Ammo_OnRefillTagUpdated::Tag' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_Ammo_OnRefillTagUpdated, Count) == 0x000008, "Member 'HWEquipmentComponent_Ammo_OnRefillTagUpdated::Count' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.SetAmmoCount
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Ammo_SetAmmoCount final
{
public:
	int32                                         NewAmmoCount;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_SetAmmoCount) == 0x000004, "Wrong alignment on HWEquipmentComponent_Ammo_SetAmmoCount");
static_assert(sizeof(HWEquipmentComponent_Ammo_SetAmmoCount) == 0x000004, "Wrong size on HWEquipmentComponent_Ammo_SetAmmoCount");
static_assert(offsetof(HWEquipmentComponent_Ammo_SetAmmoCount, NewAmmoCount) == 0x000000, "Member 'HWEquipmentComponent_Ammo_SetAmmoCount::NewAmmoCount' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.CanSellWholeStack
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Ammo_CanSellWholeStack final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_CanSellWholeStack) == 0x000001, "Wrong alignment on HWEquipmentComponent_Ammo_CanSellWholeStack");
static_assert(sizeof(HWEquipmentComponent_Ammo_CanSellWholeStack) == 0x000001, "Wrong size on HWEquipmentComponent_Ammo_CanSellWholeStack");
static_assert(offsetof(HWEquipmentComponent_Ammo_CanSellWholeStack, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Ammo_CanSellWholeStack::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.GetAmmoCount
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Ammo_GetAmmoCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_GetAmmoCount) == 0x000004, "Wrong alignment on HWEquipmentComponent_Ammo_GetAmmoCount");
static_assert(sizeof(HWEquipmentComponent_Ammo_GetAmmoCount) == 0x000004, "Wrong size on HWEquipmentComponent_Ammo_GetAmmoCount");
static_assert(offsetof(HWEquipmentComponent_Ammo_GetAmmoCount, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Ammo_GetAmmoCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.GetAmmoMax
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Ammo_GetAmmoMax final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_GetAmmoMax) == 0x000004, "Wrong alignment on HWEquipmentComponent_Ammo_GetAmmoMax");
static_assert(sizeof(HWEquipmentComponent_Ammo_GetAmmoMax) == 0x000004, "Wrong size on HWEquipmentComponent_Ammo_GetAmmoMax");
static_assert(offsetof(HWEquipmentComponent_Ammo_GetAmmoMax, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Ammo_GetAmmoMax::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.GetTimeRemainingWhenPaused
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Ammo_GetTimeRemainingWhenPaused final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_GetTimeRemainingWhenPaused) == 0x000004, "Wrong alignment on HWEquipmentComponent_Ammo_GetTimeRemainingWhenPaused");
static_assert(sizeof(HWEquipmentComponent_Ammo_GetTimeRemainingWhenPaused) == 0x000004, "Wrong size on HWEquipmentComponent_Ammo_GetTimeRemainingWhenPaused");
static_assert(offsetof(HWEquipmentComponent_Ammo_GetTimeRemainingWhenPaused, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Ammo_GetTimeRemainingWhenPaused::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.HasEnoughAmmo
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Ammo_HasEnoughAmmo final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_HasEnoughAmmo) == 0x000001, "Wrong alignment on HWEquipmentComponent_Ammo_HasEnoughAmmo");
static_assert(sizeof(HWEquipmentComponent_Ammo_HasEnoughAmmo) == 0x000001, "Wrong size on HWEquipmentComponent_Ammo_HasEnoughAmmo");
static_assert(offsetof(HWEquipmentComponent_Ammo_HasEnoughAmmo, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Ammo_HasEnoughAmmo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.HasMaxAmmo
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Ammo_HasMaxAmmo final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_HasMaxAmmo) == 0x000001, "Wrong alignment on HWEquipmentComponent_Ammo_HasMaxAmmo");
static_assert(sizeof(HWEquipmentComponent_Ammo_HasMaxAmmo) == 0x000001, "Wrong size on HWEquipmentComponent_Ammo_HasMaxAmmo");
static_assert(offsetof(HWEquipmentComponent_Ammo_HasMaxAmmo, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Ammo_HasMaxAmmo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.IsRegenAmmoCooldownPaused
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Ammo_IsRegenAmmoCooldownPaused final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_IsRegenAmmoCooldownPaused) == 0x000001, "Wrong alignment on HWEquipmentComponent_Ammo_IsRegenAmmoCooldownPaused");
static_assert(sizeof(HWEquipmentComponent_Ammo_IsRegenAmmoCooldownPaused) == 0x000001, "Wrong size on HWEquipmentComponent_Ammo_IsRegenAmmoCooldownPaused");
static_assert(offsetof(HWEquipmentComponent_Ammo_IsRegenAmmoCooldownPaused, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Ammo_IsRegenAmmoCooldownPaused::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Ammo.ShouldManuallyConsumeAmmo
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Ammo_ShouldManuallyConsumeAmmo final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Ammo_ShouldManuallyConsumeAmmo) == 0x000001, "Wrong alignment on HWEquipmentComponent_Ammo_ShouldManuallyConsumeAmmo");
static_assert(sizeof(HWEquipmentComponent_Ammo_ShouldManuallyConsumeAmmo) == 0x000001, "Wrong size on HWEquipmentComponent_Ammo_ShouldManuallyConsumeAmmo");
static_assert(offsetof(HWEquipmentComponent_Ammo_ShouldManuallyConsumeAmmo, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Ammo_ShouldManuallyConsumeAmmo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_FiringInstanceTracker.TrackFiringInstance
// 0x0020 (0x0020 - 0x0000)
struct HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance final
{
public:
	struct FHWAbilityFiringInstanceId             InstanceId;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	const class UAbilitySystemComponent*          TargetASC;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutCount;                                          // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance) == 0x000008, "Wrong alignment on HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance");
static_assert(sizeof(HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance) == 0x000020, "Wrong size on HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance, InstanceId) == 0x000000, "Member 'HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance::InstanceId' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance, TargetASC) == 0x000008, "Member 'HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance::TargetASC' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance, EffectClass) == 0x000010, "Member 'HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance::EffectClass' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance, OutCount) == 0x000018, "Member 'HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance::OutCount' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance, ReturnValue) == 0x00001C, "Member 'HWEquipmentComponent_FiringInstanceTracker_TrackFiringInstance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_FiringInstanceTracker.IsFiringInstanceTracked
// 0x0020 (0x0020 - 0x0000)
struct HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked final
{
public:
	struct FHWAbilityFiringInstanceId             InstanceId;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	const class UAbilitySystemComponent*          TargetASC;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked) == 0x000008, "Wrong alignment on HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked");
static_assert(sizeof(HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked) == 0x000020, "Wrong size on HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked, InstanceId) == 0x000000, "Member 'HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked::InstanceId' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked, TargetASC) == 0x000008, "Member 'HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked::TargetASC' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked, EffectClass) == 0x000010, "Member 'HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked::EffectClass' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked, ReturnValue) == 0x000018, "Member 'HWEquipmentComponent_FiringInstanceTracker_IsFiringInstanceTracked::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_FiringInstanceTracker.IsTrackedCustom
// 0x0030 (0x0030 - 0x0000)
struct HWEquipmentComponent_FiringInstanceTracker_IsTrackedCustom final
{
public:
	struct FHWFiringInstanceTracker               InstanceTracker;                                   // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentComponent_FiringInstanceTracker_IsTrackedCustom) == 0x000008, "Wrong alignment on HWEquipmentComponent_FiringInstanceTracker_IsTrackedCustom");
static_assert(sizeof(HWEquipmentComponent_FiringInstanceTracker_IsTrackedCustom) == 0x000030, "Wrong size on HWEquipmentComponent_FiringInstanceTracker_IsTrackedCustom");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_IsTrackedCustom, InstanceTracker) == 0x000000, "Member 'HWEquipmentComponent_FiringInstanceTracker_IsTrackedCustom::InstanceTracker' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_FiringInstanceTracker_IsTrackedCustom, ReturnValue) == 0x000028, "Member 'HWEquipmentComponent_FiringInstanceTracker_IsTrackedCustom::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Stacks.AddStacks
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Stacks_AddStacks final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Stacks_AddStacks) == 0x000004, "Wrong alignment on HWEquipmentComponent_Stacks_AddStacks");
static_assert(sizeof(HWEquipmentComponent_Stacks_AddStacks) == 0x000004, "Wrong size on HWEquipmentComponent_Stacks_AddStacks");
static_assert(offsetof(HWEquipmentComponent_Stacks_AddStacks, Amount) == 0x000000, "Member 'HWEquipmentComponent_Stacks_AddStacks::Amount' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Stacks.RemoveStacks
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Stacks_RemoveStacks final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Stacks_RemoveStacks) == 0x000004, "Wrong alignment on HWEquipmentComponent_Stacks_RemoveStacks");
static_assert(sizeof(HWEquipmentComponent_Stacks_RemoveStacks) == 0x000004, "Wrong size on HWEquipmentComponent_Stacks_RemoveStacks");
static_assert(offsetof(HWEquipmentComponent_Stacks_RemoveStacks, Amount) == 0x000000, "Member 'HWEquipmentComponent_Stacks_RemoveStacks::Amount' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Stacks.SetStacks
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Stacks_SetStacks final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Stacks_SetStacks) == 0x000004, "Wrong alignment on HWEquipmentComponent_Stacks_SetStacks");
static_assert(sizeof(HWEquipmentComponent_Stacks_SetStacks) == 0x000004, "Wrong size on HWEquipmentComponent_Stacks_SetStacks");
static_assert(offsetof(HWEquipmentComponent_Stacks_SetStacks, Amount) == 0x000000, "Member 'HWEquipmentComponent_Stacks_SetStacks::Amount' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Stacks.GetMaxStackCount
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Stacks_GetMaxStackCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Stacks_GetMaxStackCount) == 0x000004, "Wrong alignment on HWEquipmentComponent_Stacks_GetMaxStackCount");
static_assert(sizeof(HWEquipmentComponent_Stacks_GetMaxStackCount) == 0x000004, "Wrong size on HWEquipmentComponent_Stacks_GetMaxStackCount");
static_assert(offsetof(HWEquipmentComponent_Stacks_GetMaxStackCount, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Stacks_GetMaxStackCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Stacks.GetStackCount
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Stacks_GetStackCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Stacks_GetStackCount) == 0x000004, "Wrong alignment on HWEquipmentComponent_Stacks_GetStackCount");
static_assert(sizeof(HWEquipmentComponent_Stacks_GetStackCount) == 0x000004, "Wrong size on HWEquipmentComponent_Stacks_GetStackCount");
static_assert(offsetof(HWEquipmentComponent_Stacks_GetStackCount, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Stacks_GetStackCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Stacks.HasMaxStacks
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Stacks_HasMaxStacks final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Stacks_HasMaxStacks) == 0x000001, "Wrong alignment on HWEquipmentComponent_Stacks_HasMaxStacks");
static_assert(sizeof(HWEquipmentComponent_Stacks_HasMaxStacks) == 0x000001, "Wrong size on HWEquipmentComponent_Stacks_HasMaxStacks");
static_assert(offsetof(HWEquipmentComponent_Stacks_HasMaxStacks, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Stacks_HasMaxStacks::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInfo.GetAbilityClass
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentInfo_GetAbilityClass final
{
public:
	TSubclassOf<class UHWGameplayAbility>         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInfo_GetAbilityClass) == 0x000008, "Wrong alignment on HWEquipmentInfo_GetAbilityClass");
static_assert(sizeof(HWEquipmentInfo_GetAbilityClass) == 0x000008, "Wrong size on HWEquipmentInfo_GetAbilityClass");
static_assert(offsetof(HWEquipmentInfo_GetAbilityClass, ReturnValue) == 0x000000, "Member 'HWEquipmentInfo_GetAbilityClass::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInfo.GetEffectsToGrantInfo
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentInfo_GetEffectsToGrantInfo final
{
public:
	TArray<struct FHWEquipmentInfo_EffectInfo>    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInfo_GetEffectsToGrantInfo) == 0x000008, "Wrong alignment on HWEquipmentInfo_GetEffectsToGrantInfo");
static_assert(sizeof(HWEquipmentInfo_GetEffectsToGrantInfo) == 0x000010, "Wrong size on HWEquipmentInfo_GetEffectsToGrantInfo");
static_assert(offsetof(HWEquipmentInfo_GetEffectsToGrantInfo, ReturnValue) == 0x000000, "Member 'HWEquipmentInfo_GetEffectsToGrantInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInfo.GetMaxLevel
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentInfo_GetMaxLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentInfo_GetMaxLevel) == 0x000004, "Wrong alignment on HWEquipmentInfo_GetMaxLevel");
static_assert(sizeof(HWEquipmentInfo_GetMaxLevel) == 0x000004, "Wrong size on HWEquipmentInfo_GetMaxLevel");
static_assert(offsetof(HWEquipmentInfo_GetMaxLevel, ReturnValue) == 0x000000, "Member 'HWEquipmentInfo_GetMaxLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentInfo.UsesEquipmentComponent
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentInfo_UsesEquipmentComponent final
{
public:
	TSubclassOf<class UHWEquipmentComponent>      ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentInfo_UsesEquipmentComponent) == 0x000008, "Wrong alignment on HWEquipmentInfo_UsesEquipmentComponent");
static_assert(sizeof(HWEquipmentInfo_UsesEquipmentComponent) == 0x000010, "Wrong size on HWEquipmentInfo_UsesEquipmentComponent");
static_assert(offsetof(HWEquipmentInfo_UsesEquipmentComponent, ComponentClass) == 0x000000, "Member 'HWEquipmentInfo_UsesEquipmentComponent::ComponentClass' has a wrong offset!");
static_assert(offsetof(HWEquipmentInfo_UsesEquipmentComponent, ReturnValue) == 0x000008, "Member 'HWEquipmentInfo_UsesEquipmentComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.CanEquipmentUseSlotType
// 0x0020 (0x0020 - 0x0000)
struct HWInventoryManagerComponent_CanEquipmentUseSlotType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EquipmentType;                                     // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotType;                                          // 0x0010(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_CanEquipmentUseSlotType) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_CanEquipmentUseSlotType");
static_assert(sizeof(HWInventoryManagerComponent_CanEquipmentUseSlotType) == 0x000020, "Wrong size on HWInventoryManagerComponent_CanEquipmentUseSlotType");
static_assert(offsetof(HWInventoryManagerComponent_CanEquipmentUseSlotType, WorldContextObject) == 0x000000, "Member 'HWInventoryManagerComponent_CanEquipmentUseSlotType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CanEquipmentUseSlotType, EquipmentType) == 0x000008, "Member 'HWInventoryManagerComponent_CanEquipmentUseSlotType::EquipmentType' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CanEquipmentUseSlotType, SlotType) == 0x000010, "Member 'HWInventoryManagerComponent_CanEquipmentUseSlotType::SlotType' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CanEquipmentUseSlotType, ReturnValue) == 0x000018, "Member 'HWInventoryManagerComponent_CanEquipmentUseSlotType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.AddInventoryTransaction
// 0x0048 (0x0048 - 0x0000)
struct HWInventoryManagerComponent_AddInventoryTransaction final
{
public:
	struct FHWInventoryTransaction                InTransaction;                                     // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_AddInventoryTransaction) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_AddInventoryTransaction");
static_assert(sizeof(HWInventoryManagerComponent_AddInventoryTransaction) == 0x000048, "Wrong size on HWInventoryManagerComponent_AddInventoryTransaction");
static_assert(offsetof(HWInventoryManagerComponent_AddInventoryTransaction, InTransaction) == 0x000000, "Member 'HWInventoryManagerComponent_AddInventoryTransaction::InTransaction' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.CraftEquipment
// 0x0080 (0x0080 - 0x0000)
struct HWInventoryManagerComponent_CraftEquipment final
{
public:
	const class UHWEquipmentRecipe*               RecipeToCraft;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       DesiredInventorySlot;                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EHWCraftingFailureReason>              OutFailureReasons;                                 // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHWInventoryTransaction                OutTransaction;                                    // 0x0028(0x0048)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          bCraftMissingIngredients;                          // 0x0070(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0078(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_CraftEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_CraftEquipment");
static_assert(sizeof(HWInventoryManagerComponent_CraftEquipment) == 0x000080, "Wrong size on HWInventoryManagerComponent_CraftEquipment");
static_assert(offsetof(HWInventoryManagerComponent_CraftEquipment, RecipeToCraft) == 0x000000, "Member 'HWInventoryManagerComponent_CraftEquipment::RecipeToCraft' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CraftEquipment, DesiredInventorySlot) == 0x000008, "Member 'HWInventoryManagerComponent_CraftEquipment::DesiredInventorySlot' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CraftEquipment, OutFailureReasons) == 0x000018, "Member 'HWInventoryManagerComponent_CraftEquipment::OutFailureReasons' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CraftEquipment, OutTransaction) == 0x000028, "Member 'HWInventoryManagerComponent_CraftEquipment::OutTransaction' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CraftEquipment, bCraftMissingIngredients) == 0x000070, "Member 'HWInventoryManagerComponent_CraftEquipment::bCraftMissingIngredients' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CraftEquipment, ReturnValue) == 0x000078, "Member 'HWInventoryManagerComponent_CraftEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.CreateAndEquipEquipment
// 0x0030 (0x0030 - 0x0000)
struct HWInventoryManagerComponent_CreateAndEquipEquipment final
{
public:
	struct FHWEquipmentSpec                       EquipmentSpec;                                     // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EHWInventoryChangeReason                      InventoryChangeReason;                             // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_CreateAndEquipEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_CreateAndEquipEquipment");
static_assert(sizeof(HWInventoryManagerComponent_CreateAndEquipEquipment) == 0x000030, "Wrong size on HWInventoryManagerComponent_CreateAndEquipEquipment");
static_assert(offsetof(HWInventoryManagerComponent_CreateAndEquipEquipment, EquipmentSpec) == 0x000000, "Member 'HWInventoryManagerComponent_CreateAndEquipEquipment::EquipmentSpec' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CreateAndEquipEquipment, InventoryChangeReason) == 0x000020, "Member 'HWInventoryManagerComponent_CreateAndEquipEquipment::InventoryChangeReason' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CreateAndEquipEquipment, ReturnValue) == 0x000028, "Member 'HWInventoryManagerComponent_CreateAndEquipEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.CreateAndStoreEquipment
// 0x0030 (0x0030 - 0x0000)
struct HWInventoryManagerComponent_CreateAndStoreEquipment final
{
public:
	struct FHWEquipmentSpec                       EquipmentSpec;                                     // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EHWInventoryChangeReason                      InventoryChangeReason;                             // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_CreateAndStoreEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_CreateAndStoreEquipment");
static_assert(sizeof(HWInventoryManagerComponent_CreateAndStoreEquipment) == 0x000030, "Wrong size on HWInventoryManagerComponent_CreateAndStoreEquipment");
static_assert(offsetof(HWInventoryManagerComponent_CreateAndStoreEquipment, EquipmentSpec) == 0x000000, "Member 'HWInventoryManagerComponent_CreateAndStoreEquipment::EquipmentSpec' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CreateAndStoreEquipment, InventoryChangeReason) == 0x000020, "Member 'HWInventoryManagerComponent_CreateAndStoreEquipment::InventoryChangeReason' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CreateAndStoreEquipment, ReturnValue) == 0x000028, "Member 'HWInventoryManagerComponent_CreateAndStoreEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.DestroyEquipment
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_DestroyEquipment final
{
public:
	class UHWEquipmentInstance*                   EquipmentToDestroy;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWInventoryChangeReason                      InventoryChangeReason;                             // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_DestroyEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_DestroyEquipment");
static_assert(sizeof(HWInventoryManagerComponent_DestroyEquipment) == 0x000010, "Wrong size on HWInventoryManagerComponent_DestroyEquipment");
static_assert(offsetof(HWInventoryManagerComponent_DestroyEquipment, EquipmentToDestroy) == 0x000000, "Member 'HWInventoryManagerComponent_DestroyEquipment::EquipmentToDestroy' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_DestroyEquipment, InventoryChangeReason) == 0x000008, "Member 'HWInventoryManagerComponent_DestroyEquipment::InventoryChangeReason' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.DestroyEquipmentInSlot
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_DestroyEquipmentInSlot final
{
public:
	struct FHWInventorySlot                       Slot;                                              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWInventoryChangeReason                      InventoryChangeReason;                             // 0x000C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_DestroyEquipmentInSlot) == 0x000004, "Wrong alignment on HWInventoryManagerComponent_DestroyEquipmentInSlot");
static_assert(sizeof(HWInventoryManagerComponent_DestroyEquipmentInSlot) == 0x000010, "Wrong size on HWInventoryManagerComponent_DestroyEquipmentInSlot");
static_assert(offsetof(HWInventoryManagerComponent_DestroyEquipmentInSlot, Slot) == 0x000000, "Member 'HWInventoryManagerComponent_DestroyEquipmentInSlot::Slot' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_DestroyEquipmentInSlot, InventoryChangeReason) == 0x00000C, "Member 'HWInventoryManagerComponent_DestroyEquipmentInSlot::InventoryChangeReason' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_DestroyEquipmentInSlot, ReturnValue) == 0x00000D, "Member 'HWInventoryManagerComponent_DestroyEquipmentInSlot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.EquipEquipment
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_EquipEquipment final
{
public:
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       DesiredInventorySlot;                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWInventoryChangeReason                      InventoryChangeReason;                             // 0x0014(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_EquipEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_EquipEquipment");
static_assert(sizeof(HWInventoryManagerComponent_EquipEquipment) == 0x000018, "Wrong size on HWInventoryManagerComponent_EquipEquipment");
static_assert(offsetof(HWInventoryManagerComponent_EquipEquipment, EquipmentInstance) == 0x000000, "Member 'HWInventoryManagerComponent_EquipEquipment::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_EquipEquipment, DesiredInventorySlot) == 0x000008, "Member 'HWInventoryManagerComponent_EquipEquipment::DesiredInventorySlot' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_EquipEquipment, InventoryChangeReason) == 0x000014, "Member 'HWInventoryManagerComponent_EquipEquipment::InventoryChangeReason' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_EquipEquipment, ReturnValue) == 0x000015, "Member 'HWInventoryManagerComponent_EquipEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.OnDelayedSwapAbilityPhaseChanged
// 0x0038 (0x0038 - 0x0000)
struct HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged final
{
public:
	class UHWAbilitySystemComponent*              AbilitySystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0008(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0010(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	EAbilityFlowPhase                             PrevPhase;                                         // 0x0030(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityFlowPhase                             NextPhase;                                         // 0x0031(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged");
static_assert(sizeof(HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged) == 0x000038, "Wrong size on HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged");
static_assert(offsetof(HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged, AbilitySystem) == 0x000000, "Member 'HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged::AbilitySystem' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged, AbilityHandle) == 0x000008, "Member 'HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged, AbilityTags) == 0x000010, "Member 'HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged::AbilityTags' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged, PrevPhase) == 0x000030, "Member 'HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged::PrevPhase' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged, NextPhase) == 0x000031, "Member 'HWInventoryManagerComponent_OnDelayedSwapAbilityPhaseChanged::NextPhase' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.OnEquipmentLevelChanged
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_OnEquipmentLevelChanged final
{
public:
	class UHWEquipmentInstance*                   EquipmentChanged;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousLevel;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_OnEquipmentLevelChanged) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_OnEquipmentLevelChanged");
static_assert(sizeof(HWInventoryManagerComponent_OnEquipmentLevelChanged) == 0x000010, "Wrong size on HWInventoryManagerComponent_OnEquipmentLevelChanged");
static_assert(offsetof(HWInventoryManagerComponent_OnEquipmentLevelChanged, EquipmentChanged) == 0x000000, "Member 'HWInventoryManagerComponent_OnEquipmentLevelChanged::EquipmentChanged' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_OnEquipmentLevelChanged, PreviousLevel) == 0x000008, "Member 'HWInventoryManagerComponent_OnEquipmentLevelChanged::PreviousLevel' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.OnTransactionAbilityCooldown
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_OnTransactionAbilityCooldown final
{
public:
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWGameplayAbility_Enhanced*      AbilityOnCooldown;                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_OnTransactionAbilityCooldown) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_OnTransactionAbilityCooldown");
static_assert(sizeof(HWInventoryManagerComponent_OnTransactionAbilityCooldown) == 0x000010, "Wrong size on HWInventoryManagerComponent_OnTransactionAbilityCooldown");
static_assert(offsetof(HWInventoryManagerComponent_OnTransactionAbilityCooldown, EquipmentInstance) == 0x000000, "Member 'HWInventoryManagerComponent_OnTransactionAbilityCooldown::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_OnTransactionAbilityCooldown, AbilityOnCooldown) == 0x000008, "Member 'HWInventoryManagerComponent_OnTransactionAbilityCooldown::AbilityOnCooldown' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.OnTransactionAbilityFired
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_OnTransactionAbilityFired final
{
public:
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWGameplayAbility_Enhanced*      FiredAbility;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_OnTransactionAbilityFired) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_OnTransactionAbilityFired");
static_assert(sizeof(HWInventoryManagerComponent_OnTransactionAbilityFired) == 0x000010, "Wrong size on HWInventoryManagerComponent_OnTransactionAbilityFired");
static_assert(offsetof(HWInventoryManagerComponent_OnTransactionAbilityFired, EquipmentInstance) == 0x000000, "Member 'HWInventoryManagerComponent_OnTransactionAbilityFired::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_OnTransactionAbilityFired, FiredAbility) == 0x000008, "Member 'HWInventoryManagerComponent_OnTransactionAbilityFired::FiredAbility' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.RefundAllSkillPoints
// 0x0004 (0x0004 - 0x0000)
struct HWInventoryManagerComponent_RefundAllSkillPoints final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_RefundAllSkillPoints) == 0x000004, "Wrong alignment on HWInventoryManagerComponent_RefundAllSkillPoints");
static_assert(sizeof(HWInventoryManagerComponent_RefundAllSkillPoints) == 0x000004, "Wrong size on HWInventoryManagerComponent_RefundAllSkillPoints");
static_assert(offsetof(HWInventoryManagerComponent_RefundAllSkillPoints, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_RefundAllSkillPoints::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.RetrieveAndRemoveEquipment
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_RetrieveAndRemoveEquipment final
{
public:
	struct FHWInventorySlot                       Slot;                                              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWInventoryChangeReason                      InventoryChangeReason;                             // 0x000C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_RetrieveAndRemoveEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_RetrieveAndRemoveEquipment");
static_assert(sizeof(HWInventoryManagerComponent_RetrieveAndRemoveEquipment) == 0x000018, "Wrong size on HWInventoryManagerComponent_RetrieveAndRemoveEquipment");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveAndRemoveEquipment, Slot) == 0x000000, "Member 'HWInventoryManagerComponent_RetrieveAndRemoveEquipment::Slot' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveAndRemoveEquipment, InventoryChangeReason) == 0x00000C, "Member 'HWInventoryManagerComponent_RetrieveAndRemoveEquipment::InventoryChangeReason' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveAndRemoveEquipment, ReturnValue) == 0x000010, "Member 'HWInventoryManagerComponent_RetrieveAndRemoveEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.Server_PurchaseEquipment
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_Server_PurchaseEquipment final
{
public:
	const class UHWEquipmentRecipe*               EquipmentRecipe;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       DesiredInventorySlot;                              // 0x0008(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPurchaseMissingIngredients;                       // 0x0014(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_Server_PurchaseEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_Server_PurchaseEquipment");
static_assert(sizeof(HWInventoryManagerComponent_Server_PurchaseEquipment) == 0x000018, "Wrong size on HWInventoryManagerComponent_Server_PurchaseEquipment");
static_assert(offsetof(HWInventoryManagerComponent_Server_PurchaseEquipment, EquipmentRecipe) == 0x000000, "Member 'HWInventoryManagerComponent_Server_PurchaseEquipment::EquipmentRecipe' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_Server_PurchaseEquipment, DesiredInventorySlot) == 0x000008, "Member 'HWInventoryManagerComponent_Server_PurchaseEquipment::DesiredInventorySlot' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_Server_PurchaseEquipment, bPurchaseMissingIngredients) == 0x000014, "Member 'HWInventoryManagerComponent_Server_PurchaseEquipment::bPurchaseMissingIngredients' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.Server_SellEquipment
// 0x0008 (0x0008 - 0x0000)
struct HWInventoryManagerComponent_Server_SellEquipment final
{
public:
	class UHWEquipmentInstance*                   EquipmentToSell;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_Server_SellEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_Server_SellEquipment");
static_assert(sizeof(HWInventoryManagerComponent_Server_SellEquipment) == 0x000008, "Wrong size on HWInventoryManagerComponent_Server_SellEquipment");
static_assert(offsetof(HWInventoryManagerComponent_Server_SellEquipment, EquipmentToSell) == 0x000000, "Member 'HWInventoryManagerComponent_Server_SellEquipment::EquipmentToSell' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.Server_SwapAbilitySlots
// 0x0040 (0x0040 - 0x0000)
struct HWInventoryManagerComponent_Server_SwapAbilitySlots final
{
public:
	struct FHWAbilitySwapInfo                     SwapInfo;                                          // 0x0000(0x0040)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_Server_SwapAbilitySlots) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_Server_SwapAbilitySlots");
static_assert(sizeof(HWInventoryManagerComponent_Server_SwapAbilitySlots) == 0x000040, "Wrong size on HWInventoryManagerComponent_Server_SwapAbilitySlots");
static_assert(offsetof(HWInventoryManagerComponent_Server_SwapAbilitySlots, SwapInfo) == 0x000000, "Member 'HWInventoryManagerComponent_Server_SwapAbilitySlots::SwapInfo' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.Server_SwapActiveItemInput
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_Server_SwapActiveItemInput final
{
public:
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DesiredActiveItemInput;                            // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_Server_SwapActiveItemInput) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_Server_SwapActiveItemInput");
static_assert(sizeof(HWInventoryManagerComponent_Server_SwapActiveItemInput) == 0x000010, "Wrong size on HWInventoryManagerComponent_Server_SwapActiveItemInput");
static_assert(offsetof(HWInventoryManagerComponent_Server_SwapActiveItemInput, EquipmentInstance) == 0x000000, "Member 'HWInventoryManagerComponent_Server_SwapActiveItemInput::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_Server_SwapActiveItemInput, DesiredActiveItemInput) == 0x000008, "Member 'HWInventoryManagerComponent_Server_SwapActiveItemInput::DesiredActiveItemInput' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.Server_SwapEquipmentInSlots
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_Server_SwapEquipmentInSlots final
{
public:
	struct FHWInventorySlot                       Slot1;                                             // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       Slot2;                                             // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_Server_SwapEquipmentInSlots) == 0x000004, "Wrong alignment on HWInventoryManagerComponent_Server_SwapEquipmentInSlots");
static_assert(sizeof(HWInventoryManagerComponent_Server_SwapEquipmentInSlots) == 0x000018, "Wrong size on HWInventoryManagerComponent_Server_SwapEquipmentInSlots");
static_assert(offsetof(HWInventoryManagerComponent_Server_SwapEquipmentInSlots, Slot1) == 0x000000, "Member 'HWInventoryManagerComponent_Server_SwapEquipmentInSlots::Slot1' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_Server_SwapEquipmentInSlots, Slot2) == 0x00000C, "Member 'HWInventoryManagerComponent_Server_SwapEquipmentInSlots::Slot2' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.ServerSetAutoSort
// 0x0001 (0x0001 - 0x0000)
struct HWInventoryManagerComponent_ServerSetAutoSort final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_ServerSetAutoSort) == 0x000001, "Wrong alignment on HWInventoryManagerComponent_ServerSetAutoSort");
static_assert(sizeof(HWInventoryManagerComponent_ServerSetAutoSort) == 0x000001, "Wrong size on HWInventoryManagerComponent_ServerSetAutoSort");
static_assert(offsetof(HWInventoryManagerComponent_ServerSetAutoSort, bEnabled) == 0x000000, "Member 'HWInventoryManagerComponent_ServerSetAutoSort::bEnabled' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.ServerSetEquipmentLevel
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_ServerSetEquipmentLevel final
{
public:
	class UHWEquipmentInstance*                   Equipment;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredLevel;                                      // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_ServerSetEquipmentLevel) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_ServerSetEquipmentLevel");
static_assert(sizeof(HWInventoryManagerComponent_ServerSetEquipmentLevel) == 0x000010, "Wrong size on HWInventoryManagerComponent_ServerSetEquipmentLevel");
static_assert(offsetof(HWInventoryManagerComponent_ServerSetEquipmentLevel, Equipment) == 0x000000, "Member 'HWInventoryManagerComponent_ServerSetEquipmentLevel::Equipment' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_ServerSetEquipmentLevel, DesiredLevel) == 0x000008, "Member 'HWInventoryManagerComponent_ServerSetEquipmentLevel::DesiredLevel' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.SetDeadStatus
// 0x0001 (0x0001 - 0x0000)
struct HWInventoryManagerComponent_SetDeadStatus final
{
public:
	bool                                          bIsDead;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_SetDeadStatus) == 0x000001, "Wrong alignment on HWInventoryManagerComponent_SetDeadStatus");
static_assert(sizeof(HWInventoryManagerComponent_SetDeadStatus) == 0x000001, "Wrong size on HWInventoryManagerComponent_SetDeadStatus");
static_assert(offsetof(HWInventoryManagerComponent_SetDeadStatus, bIsDead) == 0x000000, "Member 'HWInventoryManagerComponent_SetDeadStatus::bIsDead' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.SetOverlappedShop
// 0x0008 (0x0008 - 0x0000)
struct HWInventoryManagerComponent_SetOverlappedShop final
{
public:
	const class AHWShopVendorVolume*              ShopVendor;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_SetOverlappedShop) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_SetOverlappedShop");
static_assert(sizeof(HWInventoryManagerComponent_SetOverlappedShop) == 0x000008, "Wrong size on HWInventoryManagerComponent_SetOverlappedShop");
static_assert(offsetof(HWInventoryManagerComponent_SetOverlappedShop, ShopVendor) == 0x000000, "Member 'HWInventoryManagerComponent_SetOverlappedShop::ShopVendor' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.StoreEquipment
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_StoreEquipment final
{
public:
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       DesiredInventorySlot;                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWInventoryChangeReason                      InventoryChangeReason;                             // 0x0014(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_StoreEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_StoreEquipment");
static_assert(sizeof(HWInventoryManagerComponent_StoreEquipment) == 0x000018, "Wrong size on HWInventoryManagerComponent_StoreEquipment");
static_assert(offsetof(HWInventoryManagerComponent_StoreEquipment, EquipmentInstance) == 0x000000, "Member 'HWInventoryManagerComponent_StoreEquipment::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_StoreEquipment, DesiredInventorySlot) == 0x000008, "Member 'HWInventoryManagerComponent_StoreEquipment::DesiredInventorySlot' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_StoreEquipment, InventoryChangeReason) == 0x000014, "Member 'HWInventoryManagerComponent_StoreEquipment::InventoryChangeReason' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_StoreEquipment, ReturnValue) == 0x000015, "Member 'HWInventoryManagerComponent_StoreEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.SwapAbilitySlots
// 0x0048 (0x0048 - 0x0000)
struct HWInventoryManagerComponent_SwapAbilitySlots final
{
public:
	struct FHWAbilitySwapInfo                     SwapInfo;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_SwapAbilitySlots) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_SwapAbilitySlots");
static_assert(sizeof(HWInventoryManagerComponent_SwapAbilitySlots) == 0x000048, "Wrong size on HWInventoryManagerComponent_SwapAbilitySlots");
static_assert(offsetof(HWInventoryManagerComponent_SwapAbilitySlots, SwapInfo) == 0x000000, "Member 'HWInventoryManagerComponent_SwapAbilitySlots::SwapInfo' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_SwapAbilitySlots, ReturnValue) == 0x000040, "Member 'HWInventoryManagerComponent_SwapAbilitySlots::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.SwapActiveItemInput
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_SwapActiveItemInput final
{
public:
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DesiredActiveItemInput;                            // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_SwapActiveItemInput) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_SwapActiveItemInput");
static_assert(sizeof(HWInventoryManagerComponent_SwapActiveItemInput) == 0x000010, "Wrong size on HWInventoryManagerComponent_SwapActiveItemInput");
static_assert(offsetof(HWInventoryManagerComponent_SwapActiveItemInput, EquipmentInstance) == 0x000000, "Member 'HWInventoryManagerComponent_SwapActiveItemInput::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_SwapActiveItemInput, DesiredActiveItemInput) == 0x000008, "Member 'HWInventoryManagerComponent_SwapActiveItemInput::DesiredActiveItemInput' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.SwapEquipmentAssignedInputTags
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_SwapEquipmentAssignedInputTags final
{
public:
	struct FHWInventorySlot                       Slot1;                                             // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       Slot2;                                             // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_SwapEquipmentAssignedInputTags) == 0x000004, "Wrong alignment on HWInventoryManagerComponent_SwapEquipmentAssignedInputTags");
static_assert(sizeof(HWInventoryManagerComponent_SwapEquipmentAssignedInputTags) == 0x000018, "Wrong size on HWInventoryManagerComponent_SwapEquipmentAssignedInputTags");
static_assert(offsetof(HWInventoryManagerComponent_SwapEquipmentAssignedInputTags, Slot1) == 0x000000, "Member 'HWInventoryManagerComponent_SwapEquipmentAssignedInputTags::Slot1' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_SwapEquipmentAssignedInputTags, Slot2) == 0x00000C, "Member 'HWInventoryManagerComponent_SwapEquipmentAssignedInputTags::Slot2' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.SwapEquipmentInSlots
// 0x0020 (0x0020 - 0x0000)
struct HWInventoryManagerComponent_SwapEquipmentInSlots final
{
public:
	struct FHWInventorySlot                       Slot1;                                             // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       Slot2;                                             // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DelayEquipmentSwapForPhases;                       // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_SwapEquipmentInSlots) == 0x000004, "Wrong alignment on HWInventoryManagerComponent_SwapEquipmentInSlots");
static_assert(sizeof(HWInventoryManagerComponent_SwapEquipmentInSlots) == 0x000020, "Wrong size on HWInventoryManagerComponent_SwapEquipmentInSlots");
static_assert(offsetof(HWInventoryManagerComponent_SwapEquipmentInSlots, Slot1) == 0x000000, "Member 'HWInventoryManagerComponent_SwapEquipmentInSlots::Slot1' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_SwapEquipmentInSlots, Slot2) == 0x00000C, "Member 'HWInventoryManagerComponent_SwapEquipmentInSlots::Slot2' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_SwapEquipmentInSlots, DelayEquipmentSwapForPhases) == 0x000018, "Member 'HWInventoryManagerComponent_SwapEquipmentInSlots::DelayEquipmentSwapForPhases' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_SwapEquipmentInSlots, ReturnValue) == 0x00001C, "Member 'HWInventoryManagerComponent_SwapEquipmentInSlots::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.UnEquipEquipment
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_UnEquipEquipment final
{
public:
	struct FHWInventorySlot                       Slot;                                              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWInventoryChangeReason                      InventoryChangeReason;                             // 0x000C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_UnEquipEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_UnEquipEquipment");
static_assert(sizeof(HWInventoryManagerComponent_UnEquipEquipment) == 0x000018, "Wrong size on HWInventoryManagerComponent_UnEquipEquipment");
static_assert(offsetof(HWInventoryManagerComponent_UnEquipEquipment, Slot) == 0x000000, "Member 'HWInventoryManagerComponent_UnEquipEquipment::Slot' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_UnEquipEquipment, InventoryChangeReason) == 0x00000C, "Member 'HWInventoryManagerComponent_UnEquipEquipment::InventoryChangeReason' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_UnEquipEquipment, ReturnValue) == 0x000010, "Member 'HWInventoryManagerComponent_UnEquipEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.CalculateSaleGoldValue
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_CalculateSaleGoldValue final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWGameMode*                      currentGameMode;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemCraftedInCurrentTransaction;                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_CalculateSaleGoldValue) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_CalculateSaleGoldValue");
static_assert(sizeof(HWInventoryManagerComponent_CalculateSaleGoldValue) == 0x000018, "Wrong size on HWInventoryManagerComponent_CalculateSaleGoldValue");
static_assert(offsetof(HWInventoryManagerComponent_CalculateSaleGoldValue, EquipmentItem) == 0x000000, "Member 'HWInventoryManagerComponent_CalculateSaleGoldValue::EquipmentItem' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CalculateSaleGoldValue, currentGameMode) == 0x000008, "Member 'HWInventoryManagerComponent_CalculateSaleGoldValue::currentGameMode' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CalculateSaleGoldValue, bItemCraftedInCurrentTransaction) == 0x000010, "Member 'HWInventoryManagerComponent_CalculateSaleGoldValue::bItemCraftedInCurrentTransaction' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CalculateSaleGoldValue, ReturnValue) == 0x000014, "Member 'HWInventoryManagerComponent_CalculateSaleGoldValue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.CanCraftEquipment
// 0x0098 (0x0098 - 0x0000)
struct HWInventoryManagerComponent_CanCraftEquipment final
{
public:
	const class UHWEquipmentRecipe*               RecipeToCraft;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       DesiredInventorySlot;                              // 0x0008(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWCanCraftInfo                        ReturnValue;                                       // 0x0018(0x0080)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_CanCraftEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_CanCraftEquipment");
static_assert(sizeof(HWInventoryManagerComponent_CanCraftEquipment) == 0x000098, "Wrong size on HWInventoryManagerComponent_CanCraftEquipment");
static_assert(offsetof(HWInventoryManagerComponent_CanCraftEquipment, RecipeToCraft) == 0x000000, "Member 'HWInventoryManagerComponent_CanCraftEquipment::RecipeToCraft' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CanCraftEquipment, DesiredInventorySlot) == 0x000008, "Member 'HWInventoryManagerComponent_CanCraftEquipment::DesiredInventorySlot' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CanCraftEquipment, ReturnValue) == 0x000018, "Member 'HWInventoryManagerComponent_CanCraftEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.CanEquipEquipment
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_CanEquipEquipment final
{
public:
	const class UHWEquipmentItem*                 EquipmentItemBeingEquipped;                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_CanEquipEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_CanEquipEquipment");
static_assert(sizeof(HWInventoryManagerComponent_CanEquipEquipment) == 0x000010, "Wrong size on HWInventoryManagerComponent_CanEquipEquipment");
static_assert(offsetof(HWInventoryManagerComponent_CanEquipEquipment, EquipmentItemBeingEquipped) == 0x000000, "Member 'HWInventoryManagerComponent_CanEquipEquipment::EquipmentItemBeingEquipped' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CanEquipEquipment, ReturnValue) == 0x000008, "Member 'HWInventoryManagerComponent_CanEquipEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.CanStoreEquipment
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_CanStoreEquipment final
{
public:
	const class UHWEquipmentItem*                 EquipmentItemBeingStored;                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_CanStoreEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_CanStoreEquipment");
static_assert(sizeof(HWInventoryManagerComponent_CanStoreEquipment) == 0x000010, "Wrong size on HWInventoryManagerComponent_CanStoreEquipment");
static_assert(offsetof(HWInventoryManagerComponent_CanStoreEquipment, EquipmentItemBeingStored) == 0x000000, "Member 'HWInventoryManagerComponent_CanStoreEquipment::EquipmentItemBeingStored' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_CanStoreEquipment, ReturnValue) == 0x000008, "Member 'HWInventoryManagerComponent_CanStoreEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.FindAvailableSlotBaseOnEquipmentType
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType final
{
public:
	struct FGameplayTag                           EquipmentType;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsEquipPoint;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWInventorySlot                       ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType) == 0x000004, "Wrong alignment on HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType");
static_assert(sizeof(HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType) == 0x000018, "Wrong size on HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType");
static_assert(offsetof(HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType, EquipmentType) == 0x000000, "Member 'HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType::EquipmentType' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType, bWantsEquipPoint) == 0x000008, "Member 'HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType::bWantsEquipPoint' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType, ReturnValue) == 0x00000C, "Member 'HWInventoryManagerComponent_FindAvailableSlotBaseOnEquipmentType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.GetAbilityCastStyle
// 0x000C (0x000C - 0x0000)
struct HWInventoryManagerComponent_GetAbilityCastStyle final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityCastStyle                             ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_GetAbilityCastStyle) == 0x000004, "Wrong alignment on HWInventoryManagerComponent_GetAbilityCastStyle");
static_assert(sizeof(HWInventoryManagerComponent_GetAbilityCastStyle) == 0x00000C, "Wrong size on HWInventoryManagerComponent_GetAbilityCastStyle");
static_assert(offsetof(HWInventoryManagerComponent_GetAbilityCastStyle, InputTag) == 0x000000, "Member 'HWInventoryManagerComponent_GetAbilityCastStyle::InputTag' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_GetAbilityCastStyle, ReturnValue) == 0x000008, "Member 'HWInventoryManagerComponent_GetAbilityCastStyle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.GetCurrentShop
// 0x0008 (0x0008 - 0x0000)
struct HWInventoryManagerComponent_GetCurrentShop final
{
public:
	const class AHWShopVendorVolume*              ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_GetCurrentShop) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_GetCurrentShop");
static_assert(sizeof(HWInventoryManagerComponent_GetCurrentShop) == 0x000008, "Wrong size on HWInventoryManagerComponent_GetCurrentShop");
static_assert(offsetof(HWInventoryManagerComponent_GetCurrentShop, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_GetCurrentShop::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.GetEquipmentCount
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_GetEquipmentCount final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_GetEquipmentCount) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_GetEquipmentCount");
static_assert(sizeof(HWInventoryManagerComponent_GetEquipmentCount) == 0x000010, "Wrong size on HWInventoryManagerComponent_GetEquipmentCount");
static_assert(offsetof(HWInventoryManagerComponent_GetEquipmentCount, EquipmentItem) == 0x000000, "Member 'HWInventoryManagerComponent_GetEquipmentCount::EquipmentItem' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_GetEquipmentCount, ReturnValue) == 0x000008, "Member 'HWInventoryManagerComponent_GetEquipmentCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.GetEquipmentCountBasedOnEquipPoint
// 0x000C (0x000C - 0x0000)
struct HWInventoryManagerComponent_GetEquipmentCountBasedOnEquipPoint final
{
public:
	struct FGameplayTag                           EquipPoint;                                        // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_GetEquipmentCountBasedOnEquipPoint) == 0x000004, "Wrong alignment on HWInventoryManagerComponent_GetEquipmentCountBasedOnEquipPoint");
static_assert(sizeof(HWInventoryManagerComponent_GetEquipmentCountBasedOnEquipPoint) == 0x00000C, "Wrong size on HWInventoryManagerComponent_GetEquipmentCountBasedOnEquipPoint");
static_assert(offsetof(HWInventoryManagerComponent_GetEquipmentCountBasedOnEquipPoint, EquipPoint) == 0x000000, "Member 'HWInventoryManagerComponent_GetEquipmentCountBasedOnEquipPoint::EquipPoint' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_GetEquipmentCountBasedOnEquipPoint, ReturnValue) == 0x000008, "Member 'HWInventoryManagerComponent_GetEquipmentCountBasedOnEquipPoint::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.GetEquipmentCountBasedOnType
// 0x000C (0x000C - 0x0000)
struct HWInventoryManagerComponent_GetEquipmentCountBasedOnType final
{
public:
	struct FGameplayTag                           EquipmentType;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_GetEquipmentCountBasedOnType) == 0x000004, "Wrong alignment on HWInventoryManagerComponent_GetEquipmentCountBasedOnType");
static_assert(sizeof(HWInventoryManagerComponent_GetEquipmentCountBasedOnType) == 0x00000C, "Wrong size on HWInventoryManagerComponent_GetEquipmentCountBasedOnType");
static_assert(offsetof(HWInventoryManagerComponent_GetEquipmentCountBasedOnType, EquipmentType) == 0x000000, "Member 'HWInventoryManagerComponent_GetEquipmentCountBasedOnType::EquipmentType' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_GetEquipmentCountBasedOnType, ReturnValue) == 0x000008, "Member 'HWInventoryManagerComponent_GetEquipmentCountBasedOnType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.GetEquipmentSellPrice
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_GetEquipmentSellPrice final
{
public:
	class UHWEquipmentInstance*                   EquipmentToSell;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInventoryManagerComponent_GetEquipmentSellPrice) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_GetEquipmentSellPrice");
static_assert(sizeof(HWInventoryManagerComponent_GetEquipmentSellPrice) == 0x000010, "Wrong size on HWInventoryManagerComponent_GetEquipmentSellPrice");
static_assert(offsetof(HWInventoryManagerComponent_GetEquipmentSellPrice, EquipmentToSell) == 0x000000, "Member 'HWInventoryManagerComponent_GetEquipmentSellPrice::EquipmentToSell' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_GetEquipmentSellPrice, ReturnValue) == 0x000008, "Member 'HWInventoryManagerComponent_GetEquipmentSellPrice::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.GetInputTagForInventorySlot
// 0x0014 (0x0014 - 0x0000)
struct HWInventoryManagerComponent_GetInputTagForInventorySlot final
{
public:
	struct FHWInventorySlot                       InventorySlot;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_GetInputTagForInventorySlot) == 0x000004, "Wrong alignment on HWInventoryManagerComponent_GetInputTagForInventorySlot");
static_assert(sizeof(HWInventoryManagerComponent_GetInputTagForInventorySlot) == 0x000014, "Wrong size on HWInventoryManagerComponent_GetInputTagForInventorySlot");
static_assert(offsetof(HWInventoryManagerComponent_GetInputTagForInventorySlot, InventorySlot) == 0x000000, "Member 'HWInventoryManagerComponent_GetInputTagForInventorySlot::InventorySlot' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_GetInputTagForInventorySlot, ReturnValue) == 0x00000C, "Member 'HWInventoryManagerComponent_GetInputTagForInventorySlot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.GetItemResalePercentage
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_GetItemResalePercentage final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWGameMode*                      currentGameMode;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemCraftedInCurrentTransaction;                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_GetItemResalePercentage) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_GetItemResalePercentage");
static_assert(sizeof(HWInventoryManagerComponent_GetItemResalePercentage) == 0x000018, "Wrong size on HWInventoryManagerComponent_GetItemResalePercentage");
static_assert(offsetof(HWInventoryManagerComponent_GetItemResalePercentage, EquipmentItem) == 0x000000, "Member 'HWInventoryManagerComponent_GetItemResalePercentage::EquipmentItem' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_GetItemResalePercentage, currentGameMode) == 0x000008, "Member 'HWInventoryManagerComponent_GetItemResalePercentage::currentGameMode' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_GetItemResalePercentage, bItemCraftedInCurrentTransaction) == 0x000010, "Member 'HWInventoryManagerComponent_GetItemResalePercentage::bItemCraftedInCurrentTransaction' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_GetItemResalePercentage, ReturnValue) == 0x000014, "Member 'HWInventoryManagerComponent_GetItemResalePercentage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.GetLevelingRecords
// 0x0010 (0x0010 - 0x0000)
struct HWInventoryManagerComponent_GetLevelingRecords final
{
public:
	TArray<struct FHWEquipmentLevelingRecord>     ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_GetLevelingRecords) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_GetLevelingRecords");
static_assert(sizeof(HWInventoryManagerComponent_GetLevelingRecords) == 0x000010, "Wrong size on HWInventoryManagerComponent_GetLevelingRecords");
static_assert(offsetof(HWInventoryManagerComponent_GetLevelingRecords, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_GetLevelingRecords::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.GetShoppingPreventionTags
// 0x0020 (0x0020 - 0x0000)
struct HWInventoryManagerComponent_GetShoppingPreventionTags final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_GetShoppingPreventionTags) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_GetShoppingPreventionTags");
static_assert(sizeof(HWInventoryManagerComponent_GetShoppingPreventionTags) == 0x000020, "Wrong size on HWInventoryManagerComponent_GetShoppingPreventionTags");
static_assert(offsetof(HWInventoryManagerComponent_GetShoppingPreventionTags, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_GetShoppingPreventionTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.HasTransactionsAvailable
// 0x0001 (0x0001 - 0x0000)
struct HWInventoryManagerComponent_HasTransactionsAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_HasTransactionsAvailable) == 0x000001, "Wrong alignment on HWInventoryManagerComponent_HasTransactionsAvailable");
static_assert(sizeof(HWInventoryManagerComponent_HasTransactionsAvailable) == 0x000001, "Wrong size on HWInventoryManagerComponent_HasTransactionsAvailable");
static_assert(offsetof(HWInventoryManagerComponent_HasTransactionsAvailable, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_HasTransactionsAvailable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.IsAutoSortingEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWInventoryManagerComponent_IsAutoSortingEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_IsAutoSortingEnabled) == 0x000001, "Wrong alignment on HWInventoryManagerComponent_IsAutoSortingEnabled");
static_assert(sizeof(HWInventoryManagerComponent_IsAutoSortingEnabled) == 0x000001, "Wrong size on HWInventoryManagerComponent_IsAutoSortingEnabled");
static_assert(offsetof(HWInventoryManagerComponent_IsAutoSortingEnabled, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_IsAutoSortingEnabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.IsCraftingInProgress
// 0x0001 (0x0001 - 0x0000)
struct HWInventoryManagerComponent_IsCraftingInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_IsCraftingInProgress) == 0x000001, "Wrong alignment on HWInventoryManagerComponent_IsCraftingInProgress");
static_assert(sizeof(HWInventoryManagerComponent_IsCraftingInProgress) == 0x000001, "Wrong size on HWInventoryManagerComponent_IsCraftingInProgress");
static_assert(offsetof(HWInventoryManagerComponent_IsCraftingInProgress, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_IsCraftingInProgress::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.IsInShop
// 0x0001 (0x0001 - 0x0000)
struct HWInventoryManagerComponent_IsInShop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_IsInShop) == 0x000001, "Wrong alignment on HWInventoryManagerComponent_IsInShop");
static_assert(sizeof(HWInventoryManagerComponent_IsInShop) == 0x000001, "Wrong size on HWInventoryManagerComponent_IsInShop");
static_assert(offsetof(HWInventoryManagerComponent_IsInShop, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_IsInShop::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.IsInventorySwapInProgress
// 0x0001 (0x0001 - 0x0000)
struct HWInventoryManagerComponent_IsInventorySwapInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_IsInventorySwapInProgress) == 0x000001, "Wrong alignment on HWInventoryManagerComponent_IsInventorySwapInProgress");
static_assert(sizeof(HWInventoryManagerComponent_IsInventorySwapInProgress) == 0x000001, "Wrong size on HWInventoryManagerComponent_IsInventorySwapInProgress");
static_assert(offsetof(HWInventoryManagerComponent_IsInventorySwapInProgress, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_IsInventorySwapInProgress::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.IsShoppingAllowed
// 0x0001 (0x0001 - 0x0000)
struct HWInventoryManagerComponent_IsShoppingAllowed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_IsShoppingAllowed) == 0x000001, "Wrong alignment on HWInventoryManagerComponent_IsShoppingAllowed");
static_assert(sizeof(HWInventoryManagerComponent_IsShoppingAllowed) == 0x000001, "Wrong size on HWInventoryManagerComponent_IsShoppingAllowed");
static_assert(offsetof(HWInventoryManagerComponent_IsShoppingAllowed, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_IsShoppingAllowed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.RetrieveEquipment
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_RetrieveEquipment final
{
public:
	struct FHWInventorySlot                       Slot;                                              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_RetrieveEquipment) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_RetrieveEquipment");
static_assert(sizeof(HWInventoryManagerComponent_RetrieveEquipment) == 0x000018, "Wrong size on HWInventoryManagerComponent_RetrieveEquipment");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveEquipment, Slot) == 0x000000, "Member 'HWInventoryManagerComponent_RetrieveEquipment::Slot' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveEquipment, ReturnValue) == 0x000010, "Member 'HWInventoryManagerComponent_RetrieveEquipment::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.RetrieveEquipmentByEquipmentItem
// 0x0020 (0x0020 - 0x0000)
struct HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem final
{
public:
	const class UHWEquipmentItem*                 EquipmentItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHWEquipmentInstance*>           EquipmentToIgnore;                                 // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UHWEquipmentInstance*                   ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem");
static_assert(sizeof(HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem) == 0x000020, "Wrong size on HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem, EquipmentItem) == 0x000000, "Member 'HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem::EquipmentItem' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem, EquipmentToIgnore) == 0x000008, "Member 'HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem::EquipmentToIgnore' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem, ReturnValue) == 0x000018, "Member 'HWInventoryManagerComponent_RetrieveEquipmentByEquipmentItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.RetrieveEquipmentsByEffectHandle
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_RetrieveEquipmentsByEffectHandle final
{
public:
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHWEquipmentInstance*>           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_RetrieveEquipmentsByEffectHandle) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_RetrieveEquipmentsByEffectHandle");
static_assert(sizeof(HWInventoryManagerComponent_RetrieveEquipmentsByEffectHandle) == 0x000018, "Wrong size on HWInventoryManagerComponent_RetrieveEquipmentsByEffectHandle");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveEquipmentsByEffectHandle, EffectHandle) == 0x000000, "Member 'HWInventoryManagerComponent_RetrieveEquipmentsByEffectHandle::EffectHandle' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveEquipmentsByEffectHandle, ReturnValue) == 0x000008, "Member 'HWInventoryManagerComponent_RetrieveEquipmentsByEffectHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.RetrieveEquipmentsBySlotType
// 0x0018 (0x0018 - 0x0000)
struct HWInventoryManagerComponent_RetrieveEquipmentsBySlotType final
{
public:
	struct FGameplayTag                           EquipmentType;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHWEquipmentInstance*>           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_RetrieveEquipmentsBySlotType) == 0x000008, "Wrong alignment on HWInventoryManagerComponent_RetrieveEquipmentsBySlotType");
static_assert(sizeof(HWInventoryManagerComponent_RetrieveEquipmentsBySlotType) == 0x000018, "Wrong size on HWInventoryManagerComponent_RetrieveEquipmentsBySlotType");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveEquipmentsBySlotType, EquipmentType) == 0x000000, "Member 'HWInventoryManagerComponent_RetrieveEquipmentsBySlotType::EquipmentType' has a wrong offset!");
static_assert(offsetof(HWInventoryManagerComponent_RetrieveEquipmentsBySlotType, ReturnValue) == 0x000008, "Member 'HWInventoryManagerComponent_RetrieveEquipmentsBySlotType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInventoryManagerComponent.ShouldBeInTransaction
// 0x0001 (0x0001 - 0x0000)
struct HWInventoryManagerComponent_ShouldBeInTransaction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInventoryManagerComponent_ShouldBeInTransaction) == 0x000001, "Wrong alignment on HWInventoryManagerComponent_ShouldBeInTransaction");
static_assert(sizeof(HWInventoryManagerComponent_ShouldBeInTransaction) == 0x000001, "Wrong size on HWInventoryManagerComponent_ShouldBeInTransaction");
static_assert(offsetof(HWInventoryManagerComponent_ShouldBeInTransaction, ReturnValue) == 0x000000, "Member 'HWInventoryManagerComponent_ShouldBeInTransaction::ReturnValue' has a wrong offset!");

// Function Hemingway.HWActor_SpecialFX.SetHideWhenOwnerIsHidden
// 0x0001 (0x0001 - 0x0000)
struct HWActor_SpecialFX_SetHideWhenOwnerIsHidden final
{
public:
	bool                                          bShouldHide;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWActor_SpecialFX_SetHideWhenOwnerIsHidden) == 0x000001, "Wrong alignment on HWActor_SpecialFX_SetHideWhenOwnerIsHidden");
static_assert(sizeof(HWActor_SpecialFX_SetHideWhenOwnerIsHidden) == 0x000001, "Wrong size on HWActor_SpecialFX_SetHideWhenOwnerIsHidden");
static_assert(offsetof(HWActor_SpecialFX_SetHideWhenOwnerIsHidden, bShouldHide) == 0x000000, "Member 'HWActor_SpecialFX_SetHideWhenOwnerIsHidden::bShouldHide' has a wrong offset!");

// Function Hemingway.HWDeployable_Growing.GetCurrentScaleTransform
// 0x0018 (0x0018 - 0x0000)
struct HWDeployable_Growing_GetCurrentScaleTransform final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Growing_GetCurrentScaleTransform) == 0x000008, "Wrong alignment on HWDeployable_Growing_GetCurrentScaleTransform");
static_assert(sizeof(HWDeployable_Growing_GetCurrentScaleTransform) == 0x000018, "Wrong size on HWDeployable_Growing_GetCurrentScaleTransform");
static_assert(offsetof(HWDeployable_Growing_GetCurrentScaleTransform, ReturnValue) == 0x000000, "Member 'HWDeployable_Growing_GetCurrentScaleTransform::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_WithVision.OnVisionRangeBeginOverlap
// 0x0108 (0x0108 - 0x0000)
struct HWDeployable_WithVision_OnVisionRangeBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromSweep;                                         // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_WithVision_OnVisionRangeBeginOverlap) == 0x000008, "Wrong alignment on HWDeployable_WithVision_OnVisionRangeBeginOverlap");
static_assert(sizeof(HWDeployable_WithVision_OnVisionRangeBeginOverlap) == 0x000108, "Wrong size on HWDeployable_WithVision_OnVisionRangeBeginOverlap");
static_assert(offsetof(HWDeployable_WithVision_OnVisionRangeBeginOverlap, OverlappedComp) == 0x000000, "Member 'HWDeployable_WithVision_OnVisionRangeBeginOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_WithVision_OnVisionRangeBeginOverlap, OtherActor) == 0x000008, "Member 'HWDeployable_WithVision_OnVisionRangeBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(HWDeployable_WithVision_OnVisionRangeBeginOverlap, OtherComp) == 0x000010, "Member 'HWDeployable_WithVision_OnVisionRangeBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_WithVision_OnVisionRangeBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'HWDeployable_WithVision_OnVisionRangeBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HWDeployable_WithVision_OnVisionRangeBeginOverlap, FromSweep) == 0x00001C, "Member 'HWDeployable_WithVision_OnVisionRangeBeginOverlap::FromSweep' has a wrong offset!");
static_assert(offsetof(HWDeployable_WithVision_OnVisionRangeBeginOverlap, SweepResult) == 0x000020, "Member 'HWDeployable_WithVision_OnVisionRangeBeginOverlap::SweepResult' has a wrong offset!");

// Function Hemingway.HWDeployable_WithVision.OnVisionRangeEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct HWDeployable_WithVision_OnVisionRangeEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWDeployable_WithVision_OnVisionRangeEndOverlap) == 0x000008, "Wrong alignment on HWDeployable_WithVision_OnVisionRangeEndOverlap");
static_assert(sizeof(HWDeployable_WithVision_OnVisionRangeEndOverlap) == 0x000020, "Wrong size on HWDeployable_WithVision_OnVisionRangeEndOverlap");
static_assert(offsetof(HWDeployable_WithVision_OnVisionRangeEndOverlap, OverlappedComp) == 0x000000, "Member 'HWDeployable_WithVision_OnVisionRangeEndOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_WithVision_OnVisionRangeEndOverlap, Other) == 0x000008, "Member 'HWDeployable_WithVision_OnVisionRangeEndOverlap::Other' has a wrong offset!");
static_assert(offsetof(HWDeployable_WithVision_OnVisionRangeEndOverlap, OtherComp) == 0x000010, "Member 'HWDeployable_WithVision_OnVisionRangeEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HWDeployable_WithVision_OnVisionRangeEndOverlap, OtherBodyIndex) == 0x000018, "Member 'HWDeployable_WithVision_OnVisionRangeEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function Hemingway.HWDeployable_Ward.GetWardSkin
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_Ward_GetWardSkin final
{
public:
	const class UHWCollectionItem*                ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Ward_GetWardSkin) == 0x000008, "Wrong alignment on HWDeployable_Ward_GetWardSkin");
static_assert(sizeof(HWDeployable_Ward_GetWardSkin) == 0x000008, "Wrong size on HWDeployable_Ward_GetWardSkin");
static_assert(offsetof(HWDeployable_Ward_GetWardSkin, ReturnValue) == 0x000000, "Member 'HWDeployable_Ward_GetWardSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Ward.GetWardSkinnedSound
// 0x0030 (0x0030 - 0x0000)
struct HWDeployable_Ward_GetWardSkinnedSound final
{
public:
	class FName                                   WardSoundSkinningKey;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Ward_GetWardSkinnedSound) == 0x000008, "Wrong alignment on HWDeployable_Ward_GetWardSkinnedSound");
static_assert(sizeof(HWDeployable_Ward_GetWardSkinnedSound) == 0x000030, "Wrong size on HWDeployable_Ward_GetWardSkinnedSound");
static_assert(offsetof(HWDeployable_Ward_GetWardSkinnedSound, WardSoundSkinningKey) == 0x000000, "Member 'HWDeployable_Ward_GetWardSkinnedSound::WardSoundSkinningKey' has a wrong offset!");
static_assert(offsetof(HWDeployable_Ward_GetWardSkinnedSound, ReturnValue) == 0x000008, "Member 'HWDeployable_Ward_GetWardSkinnedSound::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Ward.OnWardAcquiredNewEnemyVisibility
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_Ward_OnWardAcquiredNewEnemyVisibility final
{
public:
	class UHWVisibilityComponent*                 NewlyVisibleEnemyVisComp;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Ward_OnWardAcquiredNewEnemyVisibility) == 0x000008, "Wrong alignment on HWDeployable_Ward_OnWardAcquiredNewEnemyVisibility");
static_assert(sizeof(HWDeployable_Ward_OnWardAcquiredNewEnemyVisibility) == 0x000008, "Wrong size on HWDeployable_Ward_OnWardAcquiredNewEnemyVisibility");
static_assert(offsetof(HWDeployable_Ward_OnWardAcquiredNewEnemyVisibility, NewlyVisibleEnemyVisComp) == 0x000000, "Member 'HWDeployable_Ward_OnWardAcquiredNewEnemyVisibility::NewlyVisibleEnemyVisComp' has a wrong offset!");

// Function Hemingway.HWDeployable_Ward.SetGrassCollisionActor
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_Ward_SetGrassCollisionActor final
{
public:
	class AActor*                                 GrassCollisionActor;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Ward_SetGrassCollisionActor) == 0x000008, "Wrong alignment on HWDeployable_Ward_SetGrassCollisionActor");
static_assert(sizeof(HWDeployable_Ward_SetGrassCollisionActor) == 0x000008, "Wrong size on HWDeployable_Ward_SetGrassCollisionActor");
static_assert(offsetof(HWDeployable_Ward_SetGrassCollisionActor, GrassCollisionActor) == 0x000000, "Member 'HWDeployable_Ward_SetGrassCollisionActor::GrassCollisionActor' has a wrong offset!");

// Function Hemingway.HWDeployable_Ward.UpdateWardSkinVisuals
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_Ward_UpdateWardSkinVisuals final
{
public:
	const class UHWCollectionItem*                WardSkin;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Ward_UpdateWardSkinVisuals) == 0x000008, "Wrong alignment on HWDeployable_Ward_UpdateWardSkinVisuals");
static_assert(sizeof(HWDeployable_Ward_UpdateWardSkinVisuals) == 0x000008, "Wrong size on HWDeployable_Ward_UpdateWardSkinVisuals");
static_assert(offsetof(HWDeployable_Ward_UpdateWardSkinVisuals, WardSkin) == 0x000000, "Member 'HWDeployable_Ward_UpdateWardSkinVisuals::WardSkin' has a wrong offset!");

// Function Hemingway.HWDeployable_Ward.GetGrassCollisionActor
// 0x0008 (0x0008 - 0x0000)
struct HWDeployable_Ward_GetGrassCollisionActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Ward_GetGrassCollisionActor) == 0x000008, "Wrong alignment on HWDeployable_Ward_GetGrassCollisionActor");
static_assert(sizeof(HWDeployable_Ward_GetGrassCollisionActor) == 0x000008, "Wrong size on HWDeployable_Ward_GetGrassCollisionActor");
static_assert(offsetof(HWDeployable_Ward_GetGrassCollisionActor, ReturnValue) == 0x000000, "Member 'HWDeployable_Ward_GetGrassCollisionActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWFamiliarComponent.GetFamiliarHandle
// 0x000C (0x000C - 0x0000)
struct HWFamiliarComponent_GetFamiliarHandle final
{
public:
	struct FHWActiveFamiliarHandle                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFamiliarComponent_GetFamiliarHandle) == 0x000004, "Wrong alignment on HWFamiliarComponent_GetFamiliarHandle");
static_assert(sizeof(HWFamiliarComponent_GetFamiliarHandle) == 0x00000C, "Wrong size on HWFamiliarComponent_GetFamiliarHandle");
static_assert(offsetof(HWFamiliarComponent_GetFamiliarHandle, ReturnValue) == 0x000000, "Member 'HWFamiliarComponent_GetFamiliarHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWFamiliarComponent.GetFamiliarOwner
// 0x0008 (0x0008 - 0x0000)
struct HWFamiliarComponent_GetFamiliarOwner final
{
public:
	class AHWCharacterAbilitySystemActor*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFamiliarComponent_GetFamiliarOwner) == 0x000008, "Wrong alignment on HWFamiliarComponent_GetFamiliarOwner");
static_assert(sizeof(HWFamiliarComponent_GetFamiliarOwner) == 0x000008, "Wrong size on HWFamiliarComponent_GetFamiliarOwner");
static_assert(offsetof(HWFamiliarComponent_GetFamiliarOwner, ReturnValue) == 0x000000, "Member 'HWFamiliarComponent_GetFamiliarOwner::ReturnValue' has a wrong offset!");

// Function Hemingway.HWFamiliarManagerComponent.DestroyFamiliar
// 0x0010 (0x0010 - 0x0000)
struct HWFamiliarManagerComponent_DestroyFamiliar final
{
public:
	struct FHWActiveFamiliarHandle                FamiliarHandle;                                    // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipTimeAfterDeath;                               // 0x000C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWFamiliarManagerComponent_DestroyFamiliar) == 0x000004, "Wrong alignment on HWFamiliarManagerComponent_DestroyFamiliar");
static_assert(sizeof(HWFamiliarManagerComponent_DestroyFamiliar) == 0x000010, "Wrong size on HWFamiliarManagerComponent_DestroyFamiliar");
static_assert(offsetof(HWFamiliarManagerComponent_DestroyFamiliar, FamiliarHandle) == 0x000000, "Member 'HWFamiliarManagerComponent_DestroyFamiliar::FamiliarHandle' has a wrong offset!");
static_assert(offsetof(HWFamiliarManagerComponent_DestroyFamiliar, bSkipTimeAfterDeath) == 0x00000C, "Member 'HWFamiliarManagerComponent_DestroyFamiliar::bSkipTimeAfterDeath' has a wrong offset!");

// Function Hemingway.HWFamiliarManagerComponent.OnFamiliarLifetimeExpired
// 0x000C (0x000C - 0x0000)
struct HWFamiliarManagerComponent_OnFamiliarLifetimeExpired final
{
public:
	struct FHWActiveFamiliarHandle                FamiliarHandle;                                    // 0x0000(0x000C)(Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFamiliarManagerComponent_OnFamiliarLifetimeExpired) == 0x000004, "Wrong alignment on HWFamiliarManagerComponent_OnFamiliarLifetimeExpired");
static_assert(sizeof(HWFamiliarManagerComponent_OnFamiliarLifetimeExpired) == 0x00000C, "Wrong size on HWFamiliarManagerComponent_OnFamiliarLifetimeExpired");
static_assert(offsetof(HWFamiliarManagerComponent_OnFamiliarLifetimeExpired, FamiliarHandle) == 0x000000, "Member 'HWFamiliarManagerComponent_OnFamiliarLifetimeExpired::FamiliarHandle' has a wrong offset!");

// Function Hemingway.HWFamiliarManagerComponent.OnFamiliarPawnFinishedDestroy
// 0x0008 (0x0008 - 0x0000)
struct HWFamiliarManagerComponent_OnFamiliarPawnFinishedDestroy final
{
public:
	class AHWCharacter_Base*                      DestroyedFamiliarPawn;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFamiliarManagerComponent_OnFamiliarPawnFinishedDestroy) == 0x000008, "Wrong alignment on HWFamiliarManagerComponent_OnFamiliarPawnFinishedDestroy");
static_assert(sizeof(HWFamiliarManagerComponent_OnFamiliarPawnFinishedDestroy) == 0x000008, "Wrong size on HWFamiliarManagerComponent_OnFamiliarPawnFinishedDestroy");
static_assert(offsetof(HWFamiliarManagerComponent_OnFamiliarPawnFinishedDestroy, DestroyedFamiliarPawn) == 0x000000, "Member 'HWFamiliarManagerComponent_OnFamiliarPawnFinishedDestroy::DestroyedFamiliarPawn' has a wrong offset!");

// Function Hemingway.HWFamiliarManagerComponent.OnOwnerDied
// 0x0070 (0x0070 - 0x0000)
struct HWFamiliarManagerComponent_OnOwnerDied final
{
public:
	struct FDamageEventData                       DeathEventData;                                    // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFamiliarManagerComponent_OnOwnerDied) == 0x000008, "Wrong alignment on HWFamiliarManagerComponent_OnOwnerDied");
static_assert(sizeof(HWFamiliarManagerComponent_OnOwnerDied) == 0x000070, "Wrong size on HWFamiliarManagerComponent_OnOwnerDied");
static_assert(offsetof(HWFamiliarManagerComponent_OnOwnerDied, DeathEventData) == 0x000000, "Member 'HWFamiliarManagerComponent_OnOwnerDied::DeathEventData' has a wrong offset!");

// Function Hemingway.HWFamiliarManagerComponent.SpawnFamiliar
// 0x00A0 (0x00A0 - 0x0000)
struct HWFamiliarManagerComponent_SpawnFamiliar final
{
public:
	const class UHWFamiliarConfigSettings*        FamiliarConfig;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0060)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWFamiliarSpawnParams                 FamiliarSpawnParams;                               // 0x0070(0x0020)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0090(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWActiveFamiliarHandle                ReturnValue;                                       // 0x0094(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFamiliarManagerComponent_SpawnFamiliar) == 0x000010, "Wrong alignment on HWFamiliarManagerComponent_SpawnFamiliar");
static_assert(sizeof(HWFamiliarManagerComponent_SpawnFamiliar) == 0x0000A0, "Wrong size on HWFamiliarManagerComponent_SpawnFamiliar");
static_assert(offsetof(HWFamiliarManagerComponent_SpawnFamiliar, FamiliarConfig) == 0x000000, "Member 'HWFamiliarManagerComponent_SpawnFamiliar::FamiliarConfig' has a wrong offset!");
static_assert(offsetof(HWFamiliarManagerComponent_SpawnFamiliar, SpawnTransform) == 0x000010, "Member 'HWFamiliarManagerComponent_SpawnFamiliar::SpawnTransform' has a wrong offset!");
static_assert(offsetof(HWFamiliarManagerComponent_SpawnFamiliar, FamiliarSpawnParams) == 0x000070, "Member 'HWFamiliarManagerComponent_SpawnFamiliar::FamiliarSpawnParams' has a wrong offset!");
static_assert(offsetof(HWFamiliarManagerComponent_SpawnFamiliar, AbilityHandle) == 0x000090, "Member 'HWFamiliarManagerComponent_SpawnFamiliar::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWFamiliarManagerComponent_SpawnFamiliar, ReturnValue) == 0x000094, "Member 'HWFamiliarManagerComponent_SpawnFamiliar::ReturnValue' has a wrong offset!");

// Function Hemingway.HWFamiliarManagerComponent.BP_GetFamiliarInfo
// 0x0068 (0x0068 - 0x0000)
struct HWFamiliarManagerComponent_BP_GetFamiliarInfo final
{
public:
	struct FHWActiveFamiliarHandle                Handle;                                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWActiveFamiliarInfo                  FamiliarInfo;                                      // 0x0010(0x0050)(Parm, OutParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWFamiliarManagerComponent_BP_GetFamiliarInfo) == 0x000008, "Wrong alignment on HWFamiliarManagerComponent_BP_GetFamiliarInfo");
static_assert(sizeof(HWFamiliarManagerComponent_BP_GetFamiliarInfo) == 0x000068, "Wrong size on HWFamiliarManagerComponent_BP_GetFamiliarInfo");
static_assert(offsetof(HWFamiliarManagerComponent_BP_GetFamiliarInfo, Handle) == 0x000000, "Member 'HWFamiliarManagerComponent_BP_GetFamiliarInfo::Handle' has a wrong offset!");
static_assert(offsetof(HWFamiliarManagerComponent_BP_GetFamiliarInfo, FamiliarInfo) == 0x000010, "Member 'HWFamiliarManagerComponent_BP_GetFamiliarInfo::FamiliarInfo' has a wrong offset!");
static_assert(offsetof(HWFamiliarManagerComponent_BP_GetFamiliarInfo, ReturnValue) == 0x000060, "Member 'HWFamiliarManagerComponent_BP_GetFamiliarInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWFamiliarManagerComponent.GetActiveFamiliars
// 0x0010 (0x0010 - 0x0000)
struct HWFamiliarManagerComponent_GetActiveFamiliars final
{
public:
	TArray<struct FHWActiveFamiliarInfo>          ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWFamiliarManagerComponent_GetActiveFamiliars) == 0x000008, "Wrong alignment on HWFamiliarManagerComponent_GetActiveFamiliars");
static_assert(sizeof(HWFamiliarManagerComponent_GetActiveFamiliars) == 0x000010, "Wrong size on HWFamiliarManagerComponent_GetActiveFamiliars");
static_assert(offsetof(HWFamiliarManagerComponent_GetActiveFamiliars, ReturnValue) == 0x000000, "Member 'HWFamiliarManagerComponent_GetActiveFamiliars::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Looping.HandleLocalOwnerVisibilityComponentUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityComponentUpdated final
{
public:
	class UHWVisibilityComponent*                 VisibilityComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityComponentUpdated) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityComponentUpdated");
static_assert(sizeof(HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityComponentUpdated) == 0x000008, "Wrong size on HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityComponentUpdated");
static_assert(offsetof(HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityComponentUpdated, VisibilityComponent) == 0x000000, "Member 'HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityComponentUpdated::VisibilityComponent' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Looping.HandleLocalOwnerVisibilityUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityUpdated final
{
public:
	class UHWVisibilityComponent*                 VisibilityComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityUpdated) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityUpdated");
static_assert(sizeof(HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityUpdated) == 0x000008, "Wrong size on HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityUpdated");
static_assert(offsetof(HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityUpdated, VisibilityComponent) == 0x000000, "Member 'HWGameplayCueNotify_Looping_HandleLocalOwnerVisibilityUpdated::VisibilityComponent' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Looping.GetApparelComponent
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayCueNotify_Looping_GetApparelComponent final
{
public:
	class UHWApparelComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Looping_GetApparelComponent) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Looping_GetApparelComponent");
static_assert(sizeof(HWGameplayCueNotify_Looping_GetApparelComponent) == 0x000008, "Wrong size on HWGameplayCueNotify_Looping_GetApparelComponent");
static_assert(offsetof(HWGameplayCueNotify_Looping_GetApparelComponent, ReturnValue) == 0x000000, "Member 'HWGameplayCueNotify_Looping_GetApparelComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Looping.GetCurrentSkin
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayCueNotify_Looping_GetCurrentSkin final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Looping_GetCurrentSkin) == 0x000008, "Wrong alignment on HWGameplayCueNotify_Looping_GetCurrentSkin");
static_assert(sizeof(HWGameplayCueNotify_Looping_GetCurrentSkin) == 0x000008, "Wrong size on HWGameplayCueNotify_Looping_GetCurrentSkin");
static_assert(offsetof(HWGameplayCueNotify_Looping_GetCurrentSkin, ReturnValue) == 0x000000, "Member 'HWGameplayCueNotify_Looping_GetCurrentSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayCueNotify_Looping.IsSkinningReady
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayCueNotify_Looping_IsSkinningReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayCueNotify_Looping_IsSkinningReady) == 0x000001, "Wrong alignment on HWGameplayCueNotify_Looping_IsSkinningReady");
static_assert(sizeof(HWGameplayCueNotify_Looping_IsSkinningReady) == 0x000001, "Wrong size on HWGameplayCueNotify_Looping_IsSkinningReady");
static_assert(offsetof(HWGameplayCueNotify_Looping_IsSkinningReady, ReturnValue) == 0x000000, "Member 'HWGameplayCueNotify_Looping_IsSkinningReady::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.bIsUsingCustomProfile
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_bIsUsingCustomProfile final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_bIsUsingCustomProfile) == 0x000001, "Wrong alignment on HWGameplayFlight_bIsUsingCustomProfile");
static_assert(sizeof(HWGameplayFlight_bIsUsingCustomProfile) == 0x000001, "Wrong size on HWGameplayFlight_bIsUsingCustomProfile");
static_assert(offsetof(HWGameplayFlight_bIsUsingCustomProfile, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_bIsUsingCustomProfile::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.EndFlight
// 0x0002 (0x0002 - 0x0000)
struct HWGameplayFlight_EndFlight final
{
public:
	EHWEndFlightReason                            EndFlightReason;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndFlightBehavior                          EndFlightBehavior;                                 // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_EndFlight) == 0x000001, "Wrong alignment on HWGameplayFlight_EndFlight");
static_assert(sizeof(HWGameplayFlight_EndFlight) == 0x000002, "Wrong size on HWGameplayFlight_EndFlight");
static_assert(offsetof(HWGameplayFlight_EndFlight, EndFlightReason) == 0x000000, "Member 'HWGameplayFlight_EndFlight::EndFlightReason' has a wrong offset!");
static_assert(offsetof(HWGameplayFlight_EndFlight, EndFlightBehavior) == 0x000001, "Member 'HWGameplayFlight_EndFlight::EndFlightBehavior' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.OnFlightDescentEnded
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_OnFlightDescentEnded final
{
public:
	EHWEndFlightReason                            EndFlightReason;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_OnFlightDescentEnded) == 0x000001, "Wrong alignment on HWGameplayFlight_OnFlightDescentEnded");
static_assert(sizeof(HWGameplayFlight_OnFlightDescentEnded) == 0x000001, "Wrong size on HWGameplayFlight_OnFlightDescentEnded");
static_assert(offsetof(HWGameplayFlight_OnFlightDescentEnded, EndFlightReason) == 0x000000, "Member 'HWGameplayFlight_OnFlightDescentEnded::EndFlightReason' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.GetAscentDestinationHeight
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayFlight_GetAscentDestinationHeight final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_GetAscentDestinationHeight) == 0x000008, "Wrong alignment on HWGameplayFlight_GetAscentDestinationHeight");
static_assert(sizeof(HWGameplayFlight_GetAscentDestinationHeight) == 0x000008, "Wrong size on HWGameplayFlight_GetAscentDestinationHeight");
static_assert(offsetof(HWGameplayFlight_GetAscentDestinationHeight, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_GetAscentDestinationHeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.GetAscentHorizontalMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayFlight_GetAscentHorizontalMaxSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_GetAscentHorizontalMaxSpeed) == 0x000004, "Wrong alignment on HWGameplayFlight_GetAscentHorizontalMaxSpeed");
static_assert(sizeof(HWGameplayFlight_GetAscentHorizontalMaxSpeed) == 0x000004, "Wrong size on HWGameplayFlight_GetAscentHorizontalMaxSpeed");
static_assert(offsetof(HWGameplayFlight_GetAscentHorizontalMaxSpeed, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_GetAscentHorizontalMaxSpeed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.GetAscentSpeed
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayFlight_GetAscentSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_GetAscentSpeed) == 0x000004, "Wrong alignment on HWGameplayFlight_GetAscentSpeed");
static_assert(sizeof(HWGameplayFlight_GetAscentSpeed) == 0x000004, "Wrong size on HWGameplayFlight_GetAscentSpeed");
static_assert(offsetof(HWGameplayFlight_GetAscentSpeed, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_GetAscentSpeed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.GetFlightIdTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayFlight_GetFlightIdTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_GetFlightIdTag) == 0x000004, "Wrong alignment on HWGameplayFlight_GetFlightIdTag");
static_assert(sizeof(HWGameplayFlight_GetFlightIdTag) == 0x000008, "Wrong size on HWGameplayFlight_GetFlightIdTag");
static_assert(offsetof(HWGameplayFlight_GetFlightIdTag, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_GetFlightIdTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.GetFlightOrigin
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayFlight_GetFlightOrigin final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_GetFlightOrigin) == 0x000008, "Wrong alignment on HWGameplayFlight_GetFlightOrigin");
static_assert(sizeof(HWGameplayFlight_GetFlightOrigin) == 0x000018, "Wrong size on HWGameplayFlight_GetFlightOrigin");
static_assert(offsetof(HWGameplayFlight_GetFlightOrigin, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_GetFlightOrigin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.GetFlyingCharacter
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayFlight_GetFlyingCharacter final
{
public:
	class ACharacter*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_GetFlyingCharacter) == 0x000008, "Wrong alignment on HWGameplayFlight_GetFlyingCharacter");
static_assert(sizeof(HWGameplayFlight_GetFlyingCharacter) == 0x000008, "Wrong size on HWGameplayFlight_GetFlyingCharacter");
static_assert(offsetof(HWGameplayFlight_GetFlyingCharacter, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_GetFlyingCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.GetHorizontalMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayFlight_GetHorizontalMaxSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_GetHorizontalMaxSpeed) == 0x000004, "Wrong alignment on HWGameplayFlight_GetHorizontalMaxSpeed");
static_assert(sizeof(HWGameplayFlight_GetHorizontalMaxSpeed) == 0x000004, "Wrong size on HWGameplayFlight_GetHorizontalMaxSpeed");
static_assert(offsetof(HWGameplayFlight_GetHorizontalMaxSpeed, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_GetHorizontalMaxSpeed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.GetMidFlightHorizontalMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayFlight_GetMidFlightHorizontalMaxSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_GetMidFlightHorizontalMaxSpeed) == 0x000004, "Wrong alignment on HWGameplayFlight_GetMidFlightHorizontalMaxSpeed");
static_assert(sizeof(HWGameplayFlight_GetMidFlightHorizontalMaxSpeed) == 0x000004, "Wrong size on HWGameplayFlight_GetMidFlightHorizontalMaxSpeed");
static_assert(offsetof(HWGameplayFlight_GetMidFlightHorizontalMaxSpeed, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_GetMidFlightHorizontalMaxSpeed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.GetMoveSpeedValueBasedOnMovementDirection
// 0x0010 (0x0010 - 0x0000)
struct HWGameplayFlight_GetMoveSpeedValueBasedOnMovementDirection final
{
public:
	struct FHWFlightMoveSpeedValues               MoveSpeedValues;                                   // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_GetMoveSpeedValueBasedOnMovementDirection) == 0x000004, "Wrong alignment on HWGameplayFlight_GetMoveSpeedValueBasedOnMovementDirection");
static_assert(sizeof(HWGameplayFlight_GetMoveSpeedValueBasedOnMovementDirection) == 0x000010, "Wrong size on HWGameplayFlight_GetMoveSpeedValueBasedOnMovementDirection");
static_assert(offsetof(HWGameplayFlight_GetMoveSpeedValueBasedOnMovementDirection, MoveSpeedValues) == 0x000000, "Member 'HWGameplayFlight_GetMoveSpeedValueBasedOnMovementDirection::MoveSpeedValues' has a wrong offset!");
static_assert(offsetof(HWGameplayFlight_GetMoveSpeedValueBasedOnMovementDirection, ReturnValue) == 0x00000C, "Member 'HWGameplayFlight_GetMoveSpeedValueBasedOnMovementDirection::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.GetTurningDegreesPerSecond
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayFlight_GetTurningDegreesPerSecond final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_GetTurningDegreesPerSecond) == 0x000004, "Wrong alignment on HWGameplayFlight_GetTurningDegreesPerSecond");
static_assert(sizeof(HWGameplayFlight_GetTurningDegreesPerSecond) == 0x000004, "Wrong size on HWGameplayFlight_GetTurningDegreesPerSecond");
static_assert(offsetof(HWGameplayFlight_GetTurningDegreesPerSecond, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_GetTurningDegreesPerSecond::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.HasForcedMovement
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_HasForcedMovement final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_HasForcedMovement) == 0x000001, "Wrong alignment on HWGameplayFlight_HasForcedMovement");
static_assert(sizeof(HWGameplayFlight_HasForcedMovement) == 0x000001, "Wrong size on HWGameplayFlight_HasForcedMovement");
static_assert(offsetof(HWGameplayFlight_HasForcedMovement, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_HasForcedMovement::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.IsAscentActive
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_IsAscentActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_IsAscentActive) == 0x000001, "Wrong alignment on HWGameplayFlight_IsAscentActive");
static_assert(sizeof(HWGameplayFlight_IsAscentActive) == 0x000001, "Wrong size on HWGameplayFlight_IsAscentActive");
static_assert(offsetof(HWGameplayFlight_IsAscentActive, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_IsAscentActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.IsAscentServerComplete
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_IsAscentServerComplete final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_IsAscentServerComplete) == 0x000001, "Wrong alignment on HWGameplayFlight_IsAscentServerComplete");
static_assert(sizeof(HWGameplayFlight_IsAscentServerComplete) == 0x000001, "Wrong size on HWGameplayFlight_IsAscentServerComplete");
static_assert(offsetof(HWGameplayFlight_IsAscentServerComplete, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_IsAscentServerComplete::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.IsDescentActive
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_IsDescentActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_IsDescentActive) == 0x000001, "Wrong alignment on HWGameplayFlight_IsDescentActive");
static_assert(sizeof(HWGameplayFlight_IsDescentActive) == 0x000001, "Wrong size on HWGameplayFlight_IsDescentActive");
static_assert(offsetof(HWGameplayFlight_IsDescentActive, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_IsDescentActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.IsFlightActive
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_IsFlightActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_IsFlightActive) == 0x000001, "Wrong alignment on HWGameplayFlight_IsFlightActive");
static_assert(sizeof(HWGameplayFlight_IsFlightActive) == 0x000001, "Wrong size on HWGameplayFlight_IsFlightActive");
static_assert(offsetof(HWGameplayFlight_IsFlightActive, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_IsFlightActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.IsMidFlightActive
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_IsMidFlightActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_IsMidFlightActive) == 0x000001, "Wrong alignment on HWGameplayFlight_IsMidFlightActive");
static_assert(sizeof(HWGameplayFlight_IsMidFlightActive) == 0x000001, "Wrong size on HWGameplayFlight_IsMidFlightActive");
static_assert(offsetof(HWGameplayFlight_IsMidFlightActive, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_IsMidFlightActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.ShouldCalcRotation
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_ShouldCalcRotation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_ShouldCalcRotation) == 0x000001, "Wrong alignment on HWGameplayFlight_ShouldCalcRotation");
static_assert(sizeof(HWGameplayFlight_ShouldCalcRotation) == 0x000001, "Wrong size on HWGameplayFlight_ShouldCalcRotation");
static_assert(offsetof(HWGameplayFlight_ShouldCalcRotation, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_ShouldCalcRotation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.ShouldCalcVelocity
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_ShouldCalcVelocity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_ShouldCalcVelocity) == 0x000001, "Wrong alignment on HWGameplayFlight_ShouldCalcVelocity");
static_assert(sizeof(HWGameplayFlight_ShouldCalcVelocity) == 0x000001, "Wrong size on HWGameplayFlight_ShouldCalcVelocity");
static_assert(offsetof(HWGameplayFlight_ShouldCalcVelocity, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_ShouldCalcVelocity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.ShouldClampAscentToMaxHeight
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_ShouldClampAscentToMaxHeight final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_ShouldClampAscentToMaxHeight) == 0x000001, "Wrong alignment on HWGameplayFlight_ShouldClampAscentToMaxHeight");
static_assert(sizeof(HWGameplayFlight_ShouldClampAscentToMaxHeight) == 0x000001, "Wrong size on HWGameplayFlight_ShouldClampAscentToMaxHeight");
static_assert(offsetof(HWGameplayFlight_ShouldClampAscentToMaxHeight, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_ShouldClampAscentToMaxHeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.ShouldEndAscent
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_ShouldEndAscent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_ShouldEndAscent) == 0x000001, "Wrong alignment on HWGameplayFlight_ShouldEndAscent");
static_assert(sizeof(HWGameplayFlight_ShouldEndAscent) == 0x000001, "Wrong size on HWGameplayFlight_ShouldEndAscent");
static_assert(offsetof(HWGameplayFlight_ShouldEndAscent, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_ShouldEndAscent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.ShouldIgnoreClientCorrections
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_ShouldIgnoreClientCorrections final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_ShouldIgnoreClientCorrections) == 0x000001, "Wrong alignment on HWGameplayFlight_ShouldIgnoreClientCorrections");
static_assert(sizeof(HWGameplayFlight_ShouldIgnoreClientCorrections) == 0x000001, "Wrong size on HWGameplayFlight_ShouldIgnoreClientCorrections");
static_assert(offsetof(HWGameplayFlight_ShouldIgnoreClientCorrections, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_ShouldIgnoreClientCorrections::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.UsesCurveBasedAscent
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_UsesCurveBasedAscent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_UsesCurveBasedAscent) == 0x000001, "Wrong alignment on HWGameplayFlight_UsesCurveBasedAscent");
static_assert(sizeof(HWGameplayFlight_UsesCurveBasedAscent) == 0x000001, "Wrong size on HWGameplayFlight_UsesCurveBasedAscent");
static_assert(offsetof(HWGameplayFlight_UsesCurveBasedAscent, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_UsesCurveBasedAscent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.UsesPhysicsBasedAscent
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_UsesPhysicsBasedAscent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_UsesPhysicsBasedAscent) == 0x000001, "Wrong alignment on HWGameplayFlight_UsesPhysicsBasedAscent");
static_assert(sizeof(HWGameplayFlight_UsesPhysicsBasedAscent) == 0x000001, "Wrong size on HWGameplayFlight_UsesPhysicsBasedAscent");
static_assert(offsetof(HWGameplayFlight_UsesPhysicsBasedAscent, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_UsesPhysicsBasedAscent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayFlight.UsesTweenBasedAscent
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayFlight_UsesTweenBasedAscent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayFlight_UsesTweenBasedAscent) == 0x000001, "Wrong alignment on HWGameplayFlight_UsesTweenBasedAscent");
static_assert(sizeof(HWGameplayFlight_UsesTweenBasedAscent) == 0x000001, "Wrong size on HWGameplayFlight_UsesTweenBasedAscent");
static_assert(offsetof(HWGameplayFlight_UsesTweenBasedAscent, ReturnValue) == 0x000000, "Member 'HWGameplayFlight_UsesTweenBasedAscent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.bIsUsingCustomProfile
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_bIsUsingCustomProfile final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_bIsUsingCustomProfile) == 0x000001, "Wrong alignment on HWGameplayGrab_bIsUsingCustomProfile");
static_assert(sizeof(HWGameplayGrab_bIsUsingCustomProfile) == 0x000001, "Wrong size on HWGameplayGrab_bIsUsingCustomProfile");
static_assert(offsetof(HWGameplayGrab_bIsUsingCustomProfile, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_bIsUsingCustomProfile::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.CalcGrabVelocity
// 0x0020 (0x0020 - 0x0000)
struct HWGameplayGrab_CalcGrabVelocity final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_CalcGrabVelocity) == 0x000008, "Wrong alignment on HWGameplayGrab_CalcGrabVelocity");
static_assert(sizeof(HWGameplayGrab_CalcGrabVelocity) == 0x000020, "Wrong size on HWGameplayGrab_CalcGrabVelocity");
static_assert(offsetof(HWGameplayGrab_CalcGrabVelocity, DeltaTime) == 0x000000, "Member 'HWGameplayGrab_CalcGrabVelocity::DeltaTime' has a wrong offset!");
static_assert(offsetof(HWGameplayGrab_CalcGrabVelocity, ReturnValue) == 0x000008, "Member 'HWGameplayGrab_CalcGrabVelocity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.EndGrab
// 0x0002 (0x0002 - 0x0000)
struct HWGameplayGrab_EndGrab final
{
public:
	EHWEndGrabReason                              InEndGrabReason;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndGrabBehavior                            InEndGrabBehavior;                                 // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_EndGrab) == 0x000001, "Wrong alignment on HWGameplayGrab_EndGrab");
static_assert(sizeof(HWGameplayGrab_EndGrab) == 0x000002, "Wrong size on HWGameplayGrab_EndGrab");
static_assert(offsetof(HWGameplayGrab_EndGrab, InEndGrabReason) == 0x000000, "Member 'HWGameplayGrab_EndGrab::InEndGrabReason' has a wrong offset!");
static_assert(offsetof(HWGameplayGrab_EndGrab, InEndGrabBehavior) == 0x000001, "Member 'HWGameplayGrab_EndGrab::InEndGrabBehavior' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetInterruptExistingGrabBehavior
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_GetInterruptExistingGrabBehavior final
{
public:
	EHWEndGrabBehavior                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetInterruptExistingGrabBehavior) == 0x000001, "Wrong alignment on HWGameplayGrab_GetInterruptExistingGrabBehavior");
static_assert(sizeof(HWGameplayGrab_GetInterruptExistingGrabBehavior) == 0x000001, "Wrong size on HWGameplayGrab_GetInterruptExistingGrabBehavior");
static_assert(offsetof(HWGameplayGrab_GetInterruptExistingGrabBehavior, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetInterruptExistingGrabBehavior::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.OnGrabEnded
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_OnGrabEnded final
{
public:
	EHWEndGrabReason                              EndGrabReason;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_OnGrabEnded) == 0x000001, "Wrong alignment on HWGameplayGrab_OnGrabEnded");
static_assert(sizeof(HWGameplayGrab_OnGrabEnded) == 0x000001, "Wrong size on HWGameplayGrab_OnGrabEnded");
static_assert(offsetof(HWGameplayGrab_OnGrabEnded, EndGrabReason) == 0x000000, "Member 'HWGameplayGrab_OnGrabEnded::EndGrabReason' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.CanBeInterruptedByKnockback
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_CanBeInterruptedByKnockback final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_CanBeInterruptedByKnockback) == 0x000001, "Wrong alignment on HWGameplayGrab_CanBeInterruptedByKnockback");
static_assert(sizeof(HWGameplayGrab_CanBeInterruptedByKnockback) == 0x000001, "Wrong size on HWGameplayGrab_CanBeInterruptedByKnockback");
static_assert(offsetof(HWGameplayGrab_CanBeInterruptedByKnockback, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_CanBeInterruptedByKnockback::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.CanBeInterruptedByNewGrab
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_CanBeInterruptedByNewGrab final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_CanBeInterruptedByNewGrab) == 0x000001, "Wrong alignment on HWGameplayGrab_CanBeInterruptedByNewGrab");
static_assert(sizeof(HWGameplayGrab_CanBeInterruptedByNewGrab) == 0x000001, "Wrong size on HWGameplayGrab_CanBeInterruptedByNewGrab");
static_assert(offsetof(HWGameplayGrab_CanBeInterruptedByNewGrab, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_CanBeInterruptedByNewGrab::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.CanBeInterruptedByNewTween
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_CanBeInterruptedByNewTween final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_CanBeInterruptedByNewTween) == 0x000001, "Wrong alignment on HWGameplayGrab_CanBeInterruptedByNewTween");
static_assert(sizeof(HWGameplayGrab_CanBeInterruptedByNewTween) == 0x000001, "Wrong size on HWGameplayGrab_CanBeInterruptedByNewTween");
static_assert(offsetof(HWGameplayGrab_CanBeInterruptedByNewTween, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_CanBeInterruptedByNewTween::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.CanBePurifiedByGrabTarget
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_CanBePurifiedByGrabTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_CanBePurifiedByGrabTarget) == 0x000001, "Wrong alignment on HWGameplayGrab_CanBePurifiedByGrabTarget");
static_assert(sizeof(HWGameplayGrab_CanBePurifiedByGrabTarget) == 0x000001, "Wrong size on HWGameplayGrab_CanBePurifiedByGrabTarget");
static_assert(offsetof(HWGameplayGrab_CanBePurifiedByGrabTarget, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_CanBePurifiedByGrabTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetCurrentGrabLocation
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayGrab_GetCurrentGrabLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetCurrentGrabLocation) == 0x000008, "Wrong alignment on HWGameplayGrab_GetCurrentGrabLocation");
static_assert(sizeof(HWGameplayGrab_GetCurrentGrabLocation) == 0x000018, "Wrong size on HWGameplayGrab_GetCurrentGrabLocation");
static_assert(offsetof(HWGameplayGrab_GetCurrentGrabLocation, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetCurrentGrabLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetEndGrabBehavior
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_GetEndGrabBehavior final
{
public:
	EHWEndGrabBehavior                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetEndGrabBehavior) == 0x000001, "Wrong alignment on HWGameplayGrab_GetEndGrabBehavior");
static_assert(sizeof(HWGameplayGrab_GetEndGrabBehavior) == 0x000001, "Wrong size on HWGameplayGrab_GetEndGrabBehavior");
static_assert(offsetof(HWGameplayGrab_GetEndGrabBehavior, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetEndGrabBehavior::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetGrabCompletionPercentage
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayGrab_GetGrabCompletionPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetGrabCompletionPercentage) == 0x000004, "Wrong alignment on HWGameplayGrab_GetGrabCompletionPercentage");
static_assert(sizeof(HWGameplayGrab_GetGrabCompletionPercentage) == 0x000004, "Wrong size on HWGameplayGrab_GetGrabCompletionPercentage");
static_assert(offsetof(HWGameplayGrab_GetGrabCompletionPercentage, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetGrabCompletionPercentage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetGrabControlType
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_GetGrabControlType final
{
public:
	EGrabControlType                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetGrabControlType) == 0x000001, "Wrong alignment on HWGameplayGrab_GetGrabControlType");
static_assert(sizeof(HWGameplayGrab_GetGrabControlType) == 0x000001, "Wrong size on HWGameplayGrab_GetGrabControlType");
static_assert(offsetof(HWGameplayGrab_GetGrabControlType, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetGrabControlType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetGrabIdTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayGrab_GetGrabIdTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetGrabIdTag) == 0x000004, "Wrong alignment on HWGameplayGrab_GetGrabIdTag");
static_assert(sizeof(HWGameplayGrab_GetGrabIdTag) == 0x000008, "Wrong size on HWGameplayGrab_GetGrabIdTag");
static_assert(offsetof(HWGameplayGrab_GetGrabIdTag, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetGrabIdTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetGrabInstigator
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayGrab_GetGrabInstigator final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetGrabInstigator) == 0x000008, "Wrong alignment on HWGameplayGrab_GetGrabInstigator");
static_assert(sizeof(HWGameplayGrab_GetGrabInstigator) == 0x000008, "Wrong size on HWGameplayGrab_GetGrabInstigator");
static_assert(offsetof(HWGameplayGrab_GetGrabInstigator, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetGrabInstigator::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetGrabInterruptType
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_GetGrabInterruptType final
{
public:
	EGrabInterruptType                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetGrabInterruptType) == 0x000001, "Wrong alignment on HWGameplayGrab_GetGrabInterruptType");
static_assert(sizeof(HWGameplayGrab_GetGrabInterruptType) == 0x000001, "Wrong size on HWGameplayGrab_GetGrabInterruptType");
static_assert(offsetof(HWGameplayGrab_GetGrabInterruptType, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetGrabInterruptType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetGrabLocationOffset
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayGrab_GetGrabLocationOffset final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetGrabLocationOffset) == 0x000008, "Wrong alignment on HWGameplayGrab_GetGrabLocationOffset");
static_assert(sizeof(HWGameplayGrab_GetGrabLocationOffset) == 0x000018, "Wrong size on HWGameplayGrab_GetGrabLocationOffset");
static_assert(offsetof(HWGameplayGrab_GetGrabLocationOffset, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetGrabLocationOffset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetGrabLocationOffsetInLocalSpace
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayGrab_GetGrabLocationOffsetInLocalSpace final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetGrabLocationOffsetInLocalSpace) == 0x000008, "Wrong alignment on HWGameplayGrab_GetGrabLocationOffsetInLocalSpace");
static_assert(sizeof(HWGameplayGrab_GetGrabLocationOffsetInLocalSpace) == 0x000018, "Wrong size on HWGameplayGrab_GetGrabLocationOffsetInLocalSpace");
static_assert(offsetof(HWGameplayGrab_GetGrabLocationOffsetInLocalSpace, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetGrabLocationOffsetInLocalSpace::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetGrabSourceCharacter
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayGrab_GetGrabSourceCharacter final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetGrabSourceCharacter) == 0x000008, "Wrong alignment on HWGameplayGrab_GetGrabSourceCharacter");
static_assert(sizeof(HWGameplayGrab_GetGrabSourceCharacter) == 0x000008, "Wrong size on HWGameplayGrab_GetGrabSourceCharacter");
static_assert(offsetof(HWGameplayGrab_GetGrabSourceCharacter, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetGrabSourceCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetGrabTargetCharacter
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayGrab_GetGrabTargetCharacter final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetGrabTargetCharacter) == 0x000008, "Wrong alignment on HWGameplayGrab_GetGrabTargetCharacter");
static_assert(sizeof(HWGameplayGrab_GetGrabTargetCharacter) == 0x000008, "Wrong size on HWGameplayGrab_GetGrabTargetCharacter");
static_assert(offsetof(HWGameplayGrab_GetGrabTargetCharacter, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetGrabTargetCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.GetInstigatingAbility
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayGrab_GetInstigatingAbility final
{
public:
	class UGameplayAbility*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_GetInstigatingAbility) == 0x000008, "Wrong alignment on HWGameplayGrab_GetInstigatingAbility");
static_assert(sizeof(HWGameplayGrab_GetInstigatingAbility) == 0x000008, "Wrong size on HWGameplayGrab_GetInstigatingAbility");
static_assert(offsetof(HWGameplayGrab_GetInstigatingAbility, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_GetInstigatingAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.HasDismountVelocity
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_HasDismountVelocity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_HasDismountVelocity) == 0x000001, "Wrong alignment on HWGameplayGrab_HasDismountVelocity");
static_assert(sizeof(HWGameplayGrab_HasDismountVelocity) == 0x000001, "Wrong size on HWGameplayGrab_HasDismountVelocity");
static_assert(offsetof(HWGameplayGrab_HasDismountVelocity, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_HasDismountVelocity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.HasValidGrabMovement
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_HasValidGrabMovement final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_HasValidGrabMovement) == 0x000001, "Wrong alignment on HWGameplayGrab_HasValidGrabMovement");
static_assert(sizeof(HWGameplayGrab_HasValidGrabMovement) == 0x000001, "Wrong size on HWGameplayGrab_HasValidGrabMovement");
static_assert(offsetof(HWGameplayGrab_HasValidGrabMovement, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_HasValidGrabMovement::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.HasVerticalDismountVelocity
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_HasVerticalDismountVelocity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_HasVerticalDismountVelocity) == 0x000001, "Wrong alignment on HWGameplayGrab_HasVerticalDismountVelocity");
static_assert(sizeof(HWGameplayGrab_HasVerticalDismountVelocity) == 0x000001, "Wrong size on HWGameplayGrab_HasVerticalDismountVelocity");
static_assert(offsetof(HWGameplayGrab_HasVerticalDismountVelocity, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_HasVerticalDismountVelocity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.IsActive
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_IsActive) == 0x000001, "Wrong alignment on HWGameplayGrab_IsActive");
static_assert(sizeof(HWGameplayGrab_IsActive) == 0x000001, "Wrong size on HWGameplayGrab_IsActive");
static_assert(offsetof(HWGameplayGrab_IsActive, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_IsActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.IsPositionTypeUsingCustomAngle
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_IsPositionTypeUsingCustomAngle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_IsPositionTypeUsingCustomAngle) == 0x000001, "Wrong alignment on HWGameplayGrab_IsPositionTypeUsingCustomAngle");
static_assert(sizeof(HWGameplayGrab_IsPositionTypeUsingCustomAngle) == 0x000001, "Wrong size on HWGameplayGrab_IsPositionTypeUsingCustomAngle");
static_assert(offsetof(HWGameplayGrab_IsPositionTypeUsingCustomAngle, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_IsPositionTypeUsingCustomAngle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.ShouldEndGrab
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_ShouldEndGrab final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_ShouldEndGrab) == 0x000001, "Wrong alignment on HWGameplayGrab_ShouldEndGrab");
static_assert(sizeof(HWGameplayGrab_ShouldEndGrab) == 0x000001, "Wrong size on HWGameplayGrab_ShouldEndGrab");
static_assert(offsetof(HWGameplayGrab_ShouldEndGrab, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_ShouldEndGrab::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayGrab.ShouldLockRotation
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayGrab_ShouldLockRotation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayGrab_ShouldLockRotation) == 0x000001, "Wrong alignment on HWGameplayGrab_ShouldLockRotation");
static_assert(sizeof(HWGameplayGrab_ShouldLockRotation) == 0x000001, "Wrong size on HWGameplayGrab_ShouldLockRotation");
static_assert(offsetof(HWGameplayGrab_ShouldLockRotation, ReturnValue) == 0x000000, "Member 'HWGameplayGrab_ShouldLockRotation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.bIsUsingCustomProfile
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_bIsUsingCustomProfile final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_bIsUsingCustomProfile) == 0x000001, "Wrong alignment on HWGameplayTween_bIsUsingCustomProfile");
static_assert(sizeof(HWGameplayTween_bIsUsingCustomProfile) == 0x000001, "Wrong size on HWGameplayTween_bIsUsingCustomProfile");
static_assert(offsetof(HWGameplayTween_bIsUsingCustomProfile, ReturnValue) == 0x000000, "Member 'HWGameplayTween_bIsUsingCustomProfile::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.CanBeInterruptedByKnockback
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_CanBeInterruptedByKnockback final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_CanBeInterruptedByKnockback) == 0x000001, "Wrong alignment on HWGameplayTween_CanBeInterruptedByKnockback");
static_assert(sizeof(HWGameplayTween_CanBeInterruptedByKnockback) == 0x000001, "Wrong size on HWGameplayTween_CanBeInterruptedByKnockback");
static_assert(offsetof(HWGameplayTween_CanBeInterruptedByKnockback, ReturnValue) == 0x000000, "Member 'HWGameplayTween_CanBeInterruptedByKnockback::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.CanBeInterruptedByNewTween
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_CanBeInterruptedByNewTween final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_CanBeInterruptedByNewTween) == 0x000001, "Wrong alignment on HWGameplayTween_CanBeInterruptedByNewTween");
static_assert(sizeof(HWGameplayTween_CanBeInterruptedByNewTween) == 0x000001, "Wrong size on HWGameplayTween_CanBeInterruptedByNewTween");
static_assert(offsetof(HWGameplayTween_CanBeInterruptedByNewTween, ReturnValue) == 0x000000, "Member 'HWGameplayTween_CanBeInterruptedByNewTween::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.EndTween
// 0x0002 (0x0002 - 0x0000)
struct HWGameplayTween_EndTween final
{
public:
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenBehavior                           EndTweenBehavior;                                  // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_EndTween) == 0x000001, "Wrong alignment on HWGameplayTween_EndTween");
static_assert(sizeof(HWGameplayTween_EndTween) == 0x000002, "Wrong size on HWGameplayTween_EndTween");
static_assert(offsetof(HWGameplayTween_EndTween, EndTweenReason) == 0x000000, "Member 'HWGameplayTween_EndTween::EndTweenReason' has a wrong offset!");
static_assert(offsetof(HWGameplayTween_EndTween, EndTweenBehavior) == 0x000001, "Member 'HWGameplayTween_EndTween::EndTweenBehavior' has a wrong offset!");

// Function Hemingway.HWGameplayTween.OnCharacterBump
// 0x0110 (0x0110 - 0x0000)
struct HWGameplayTween_OnCharacterBump final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0028(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_OnCharacterBump) == 0x000008, "Wrong alignment on HWGameplayTween_OnCharacterBump");
static_assert(sizeof(HWGameplayTween_OnCharacterBump) == 0x000110, "Wrong size on HWGameplayTween_OnCharacterBump");
static_assert(offsetof(HWGameplayTween_OnCharacterBump, SelfActor) == 0x000000, "Member 'HWGameplayTween_OnCharacterBump::SelfActor' has a wrong offset!");
static_assert(offsetof(HWGameplayTween_OnCharacterBump, OtherActor) == 0x000008, "Member 'HWGameplayTween_OnCharacterBump::OtherActor' has a wrong offset!");
static_assert(offsetof(HWGameplayTween_OnCharacterBump, NormalImpulse) == 0x000010, "Member 'HWGameplayTween_OnCharacterBump::NormalImpulse' has a wrong offset!");
static_assert(offsetof(HWGameplayTween_OnCharacterBump, Hit) == 0x000028, "Member 'HWGameplayTween_OnCharacterBump::Hit' has a wrong offset!");

// Function Hemingway.HWGameplayTween.OnTweenEnded
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_OnTweenEnded final
{
public:
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_OnTweenEnded) == 0x000001, "Wrong alignment on HWGameplayTween_OnTweenEnded");
static_assert(sizeof(HWGameplayTween_OnTweenEnded) == 0x000001, "Wrong size on HWGameplayTween_OnTweenEnded");
static_assert(offsetof(HWGameplayTween_OnTweenEnded, EndTweenReason) == 0x000000, "Member 'HWGameplayTween_OnTweenEnded::EndTweenReason' has a wrong offset!");

// Function Hemingway.HWGameplayTween.SetLockPawnRotation
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_SetLockPawnRotation final
{
public:
	bool                                          bShouldLockPawnRotation;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_SetLockPawnRotation) == 0x000001, "Wrong alignment on HWGameplayTween_SetLockPawnRotation");
static_assert(sizeof(HWGameplayTween_SetLockPawnRotation) == 0x000001, "Wrong size on HWGameplayTween_SetLockPawnRotation");
static_assert(offsetof(HWGameplayTween_SetLockPawnRotation, bShouldLockPawnRotation) == 0x000000, "Member 'HWGameplayTween_SetLockPawnRotation::bShouldLockPawnRotation' has a wrong offset!");

// Function Hemingway.HWGameplayTween.CalcCharacterRotation
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayTween_CalcCharacterRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_CalcCharacterRotation) == 0x000008, "Wrong alignment on HWGameplayTween_CalcCharacterRotation");
static_assert(sizeof(HWGameplayTween_CalcCharacterRotation) == 0x000018, "Wrong size on HWGameplayTween_CalcCharacterRotation");
static_assert(offsetof(HWGameplayTween_CalcCharacterRotation, ReturnValue) == 0x000000, "Member 'HWGameplayTween_CalcCharacterRotation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.CanBePurifiedByTweenTarget
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_CanBePurifiedByTweenTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_CanBePurifiedByTweenTarget) == 0x000001, "Wrong alignment on HWGameplayTween_CanBePurifiedByTweenTarget");
static_assert(sizeof(HWGameplayTween_CanBePurifiedByTweenTarget) == 0x000001, "Wrong size on HWGameplayTween_CanBePurifiedByTweenTarget");
static_assert(offsetof(HWGameplayTween_CanBePurifiedByTweenTarget, ReturnValue) == 0x000000, "Member 'HWGameplayTween_CanBePurifiedByTweenTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.CanTweenToNewPlaneOfExistence
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_CanTweenToNewPlaneOfExistence final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_CanTweenToNewPlaneOfExistence) == 0x000001, "Wrong alignment on HWGameplayTween_CanTweenToNewPlaneOfExistence");
static_assert(sizeof(HWGameplayTween_CanTweenToNewPlaneOfExistence) == 0x000001, "Wrong size on HWGameplayTween_CanTweenToNewPlaneOfExistence");
static_assert(offsetof(HWGameplayTween_CanTweenToNewPlaneOfExistence, ReturnValue) == 0x000000, "Member 'HWGameplayTween_CanTweenToNewPlaneOfExistence::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.GetCurrentTweenLocation
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayTween_GetCurrentTweenLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_GetCurrentTweenLocation) == 0x000008, "Wrong alignment on HWGameplayTween_GetCurrentTweenLocation");
static_assert(sizeof(HWGameplayTween_GetCurrentTweenLocation) == 0x000018, "Wrong size on HWGameplayTween_GetCurrentTweenLocation");
static_assert(offsetof(HWGameplayTween_GetCurrentTweenLocation, ReturnValue) == 0x000000, "Member 'HWGameplayTween_GetCurrentTweenLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.GetFinalTweenDestination
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayTween_GetFinalTweenDestination final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_GetFinalTweenDestination) == 0x000008, "Wrong alignment on HWGameplayTween_GetFinalTweenDestination");
static_assert(sizeof(HWGameplayTween_GetFinalTweenDestination) == 0x000018, "Wrong size on HWGameplayTween_GetFinalTweenDestination");
static_assert(offsetof(HWGameplayTween_GetFinalTweenDestination, ReturnValue) == 0x000000, "Member 'HWGameplayTween_GetFinalTweenDestination::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.GetSplinePath
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayTween_GetSplinePath final
{
public:
	const class USplineComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_GetSplinePath) == 0x000008, "Wrong alignment on HWGameplayTween_GetSplinePath");
static_assert(sizeof(HWGameplayTween_GetSplinePath) == 0x000008, "Wrong size on HWGameplayTween_GetSplinePath");
static_assert(offsetof(HWGameplayTween_GetSplinePath, ReturnValue) == 0x000000, "Member 'HWGameplayTween_GetSplinePath::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.GetTweenBehaviorOnInterrupted
// 0x0002 (0x0002 - 0x0000)
struct HWGameplayTween_GetTweenBehaviorOnInterrupted final
{
public:
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenBehavior                           ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_GetTweenBehaviorOnInterrupted) == 0x000001, "Wrong alignment on HWGameplayTween_GetTweenBehaviorOnInterrupted");
static_assert(sizeof(HWGameplayTween_GetTweenBehaviorOnInterrupted) == 0x000002, "Wrong size on HWGameplayTween_GetTweenBehaviorOnInterrupted");
static_assert(offsetof(HWGameplayTween_GetTweenBehaviorOnInterrupted, EndTweenReason) == 0x000000, "Member 'HWGameplayTween_GetTweenBehaviorOnInterrupted::EndTweenReason' has a wrong offset!");
static_assert(offsetof(HWGameplayTween_GetTweenBehaviorOnInterrupted, ReturnValue) == 0x000001, "Member 'HWGameplayTween_GetTweenBehaviorOnInterrupted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.GetTweenCompletionPercentage
// 0x0004 (0x0004 - 0x0000)
struct HWGameplayTween_GetTweenCompletionPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_GetTweenCompletionPercentage) == 0x000004, "Wrong alignment on HWGameplayTween_GetTweenCompletionPercentage");
static_assert(sizeof(HWGameplayTween_GetTweenCompletionPercentage) == 0x000004, "Wrong size on HWGameplayTween_GetTweenCompletionPercentage");
static_assert(offsetof(HWGameplayTween_GetTweenCompletionPercentage, ReturnValue) == 0x000000, "Member 'HWGameplayTween_GetTweenCompletionPercentage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.GetTweenId
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayTween_GetTweenId final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_GetTweenId) == 0x000004, "Wrong alignment on HWGameplayTween_GetTweenId");
static_assert(sizeof(HWGameplayTween_GetTweenId) == 0x000008, "Wrong size on HWGameplayTween_GetTweenId");
static_assert(offsetof(HWGameplayTween_GetTweenId, ReturnValue) == 0x000000, "Member 'HWGameplayTween_GetTweenId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.GetTweeningCharacter
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayTween_GetTweeningCharacter final
{
public:
	class ACharacter*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_GetTweeningCharacter) == 0x000008, "Wrong alignment on HWGameplayTween_GetTweeningCharacter");
static_assert(sizeof(HWGameplayTween_GetTweeningCharacter) == 0x000008, "Wrong size on HWGameplayTween_GetTweeningCharacter");
static_assert(offsetof(HWGameplayTween_GetTweeningCharacter, ReturnValue) == 0x000000, "Member 'HWGameplayTween_GetTweeningCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.GetTweenOrigin
// 0x0018 (0x0018 - 0x0000)
struct HWGameplayTween_GetTweenOrigin final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_GetTweenOrigin) == 0x000008, "Wrong alignment on HWGameplayTween_GetTweenOrigin");
static_assert(sizeof(HWGameplayTween_GetTweenOrigin) == 0x000018, "Wrong size on HWGameplayTween_GetTweenOrigin");
static_assert(offsetof(HWGameplayTween_GetTweenOrigin, ReturnValue) == 0x000000, "Member 'HWGameplayTween_GetTweenOrigin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.GetTweenType
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_GetTweenType final
{
public:
	ETweenType                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_GetTweenType) == 0x000001, "Wrong alignment on HWGameplayTween_GetTweenType");
static_assert(sizeof(HWGameplayTween_GetTweenType) == 0x000001, "Wrong size on HWGameplayTween_GetTweenType");
static_assert(offsetof(HWGameplayTween_GetTweenType, ReturnValue) == 0x000000, "Member 'HWGameplayTween_GetTweenType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.GetVerticalArcHeight
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayTween_GetVerticalArcHeight final
{
public:
	float                                         TweenPercentage;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_GetVerticalArcHeight) == 0x000004, "Wrong alignment on HWGameplayTween_GetVerticalArcHeight");
static_assert(sizeof(HWGameplayTween_GetVerticalArcHeight) == 0x000008, "Wrong size on HWGameplayTween_GetVerticalArcHeight");
static_assert(offsetof(HWGameplayTween_GetVerticalArcHeight, TweenPercentage) == 0x000000, "Member 'HWGameplayTween_GetVerticalArcHeight::TweenPercentage' has a wrong offset!");
static_assert(offsetof(HWGameplayTween_GetVerticalArcHeight, ReturnValue) == 0x000004, "Member 'HWGameplayTween_GetVerticalArcHeight::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.IsActive
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_IsActive) == 0x000001, "Wrong alignment on HWGameplayTween_IsActive");
static_assert(sizeof(HWGameplayTween_IsActive) == 0x000001, "Wrong size on HWGameplayTween_IsActive");
static_assert(offsetof(HWGameplayTween_IsActive, ReturnValue) == 0x000000, "Member 'HWGameplayTween_IsActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.ShouldEndTween
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_ShouldEndTween final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_ShouldEndTween) == 0x000001, "Wrong alignment on HWGameplayTween_ShouldEndTween");
static_assert(sizeof(HWGameplayTween_ShouldEndTween) == 0x000001, "Wrong size on HWGameplayTween_ShouldEndTween");
static_assert(offsetof(HWGameplayTween_ShouldEndTween, ReturnValue) == 0x000000, "Member 'HWGameplayTween_ShouldEndTween::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayTween.ShouldGainMaxInputSpeedOnTweenEnd
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayTween_ShouldGainMaxInputSpeedOnTweenEnd final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayTween_ShouldGainMaxInputSpeedOnTweenEnd) == 0x000001, "Wrong alignment on HWGameplayTween_ShouldGainMaxInputSpeedOnTweenEnd");
static_assert(sizeof(HWGameplayTween_ShouldGainMaxInputSpeedOnTweenEnd) == 0x000001, "Wrong size on HWGameplayTween_ShouldGainMaxInputSpeedOnTweenEnd");
static_assert(offsetof(HWGameplayTween_ShouldGainMaxInputSpeedOnTweenEnd, ReturnValue) == 0x000000, "Member 'HWGameplayTween_ShouldGainMaxInputSpeedOnTweenEnd::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameUserSettings.GetAudioInputDevicesAsText
// 0x0010 (0x0010 - 0x0000)
struct HWGameUserSettings_GetAudioInputDevicesAsText final
{
public:
	TArray<class FText>                           OutAudioInputDevices;                              // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameUserSettings_GetAudioInputDevicesAsText) == 0x000008, "Wrong alignment on HWGameUserSettings_GetAudioInputDevicesAsText");
static_assert(sizeof(HWGameUserSettings_GetAudioInputDevicesAsText) == 0x000010, "Wrong size on HWGameUserSettings_GetAudioInputDevicesAsText");
static_assert(offsetof(HWGameUserSettings_GetAudioInputDevicesAsText, OutAudioInputDevices) == 0x000000, "Member 'HWGameUserSettings_GetAudioInputDevicesAsText::OutAudioInputDevices' has a wrong offset!");

// Function Hemingway.HWGameUserSettings.GetReflexModeAsInt
// 0x0004 (0x0004 - 0x0000)
struct HWGameUserSettings_GetReflexModeAsInt final
{
public:
	int32                                         OutReflexMode;                                     // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameUserSettings_GetReflexModeAsInt) == 0x000004, "Wrong alignment on HWGameUserSettings_GetReflexModeAsInt");
static_assert(sizeof(HWGameUserSettings_GetReflexModeAsInt) == 0x000004, "Wrong size on HWGameUserSettings_GetReflexModeAsInt");
static_assert(offsetof(HWGameUserSettings_GetReflexModeAsInt, OutReflexMode) == 0x000000, "Member 'HWGameUserSettings_GetReflexModeAsInt::OutReflexMode' has a wrong offset!");

// Function Hemingway.HWGameUserSettings.GetSupportedResolutionsAsText
// 0x0010 (0x0010 - 0x0000)
struct HWGameUserSettings_GetSupportedResolutionsAsText final
{
public:
	TArray<class FText>                           OutSupportedResolutions;                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameUserSettings_GetSupportedResolutionsAsText) == 0x000008, "Wrong alignment on HWGameUserSettings_GetSupportedResolutionsAsText");
static_assert(sizeof(HWGameUserSettings_GetSupportedResolutionsAsText) == 0x000010, "Wrong size on HWGameUserSettings_GetSupportedResolutionsAsText");
static_assert(offsetof(HWGameUserSettings_GetSupportedResolutionsAsText, OutSupportedResolutions) == 0x000000, "Member 'HWGameUserSettings_GetSupportedResolutionsAsText::OutSupportedResolutions' has a wrong offset!");

// Function Hemingway.HWGameUserSettings.GetCurrentAudioInputDeviceIndex
// 0x0004 (0x0004 - 0x0000)
struct HWGameUserSettings_GetCurrentAudioInputDeviceIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameUserSettings_GetCurrentAudioInputDeviceIndex) == 0x000004, "Wrong alignment on HWGameUserSettings_GetCurrentAudioInputDeviceIndex");
static_assert(sizeof(HWGameUserSettings_GetCurrentAudioInputDeviceIndex) == 0x000004, "Wrong size on HWGameUserSettings_GetCurrentAudioInputDeviceIndex");
static_assert(offsetof(HWGameUserSettings_GetCurrentAudioInputDeviceIndex, ReturnValue) == 0x000000, "Member 'HWGameUserSettings_GetCurrentAudioInputDeviceIndex::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameUserSettings.GetCurrentResolutionIndex
// 0x0004 (0x0004 - 0x0000)
struct HWGameUserSettings_GetCurrentResolutionIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameUserSettings_GetCurrentResolutionIndex) == 0x000004, "Wrong alignment on HWGameUserSettings_GetCurrentResolutionIndex");
static_assert(sizeof(HWGameUserSettings_GetCurrentResolutionIndex) == 0x000004, "Wrong size on HWGameUserSettings_GetCurrentResolutionIndex");
static_assert(offsetof(HWGameUserSettings_GetCurrentResolutionIndex, ReturnValue) == 0x000000, "Member 'HWGameUserSettings_GetCurrentResolutionIndex::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_ShieldOwner.GetShieldEffectTag
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayEffect_ShieldOwner_GetShieldEffectTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_ShieldOwner_GetShieldEffectTag) == 0x000004, "Wrong alignment on HWGameplayEffect_ShieldOwner_GetShieldEffectTag");
static_assert(sizeof(HWGameplayEffect_ShieldOwner_GetShieldEffectTag) == 0x000008, "Wrong size on HWGameplayEffect_ShieldOwner_GetShieldEffectTag");
static_assert(offsetof(HWGameplayEffect_ShieldOwner_GetShieldEffectTag, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_ShieldOwner_GetShieldEffectTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_ShieldOwner.GetShieldType
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_ShieldOwner_GetShieldType final
{
public:
	EShieldType                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_ShieldOwner_GetShieldType) == 0x000001, "Wrong alignment on HWGameplayEffect_ShieldOwner_GetShieldType");
static_assert(sizeof(HWGameplayEffect_ShieldOwner_GetShieldType) == 0x000001, "Wrong size on HWGameplayEffect_ShieldOwner_GetShieldType");
static_assert(offsetof(HWGameplayEffect_ShieldOwner_GetShieldType, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_ShieldOwner_GetShieldType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_ShieldOwner.ShouldReplaceOnReapplication
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_ShieldOwner_ShouldReplaceOnReapplication final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_ShieldOwner_ShouldReplaceOnReapplication) == 0x000001, "Wrong alignment on HWGameplayEffect_ShieldOwner_ShouldReplaceOnReapplication");
static_assert(sizeof(HWGameplayEffect_ShieldOwner_ShouldReplaceOnReapplication) == 0x000001, "Wrong size on HWGameplayEffect_ShieldOwner_ShouldReplaceOnReapplication");
static_assert(offsetof(HWGameplayEffect_ShieldOwner_ShouldReplaceOnReapplication, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_ShieldOwner_ShouldReplaceOnReapplication::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameplayEffect_ShieldOwner.ShouldSetMaxHealthEqualToInitial
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayEffect_ShieldOwner_ShouldSetMaxHealthEqualToInitial final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayEffect_ShieldOwner_ShouldSetMaxHealthEqualToInitial) == 0x000001, "Wrong alignment on HWGameplayEffect_ShieldOwner_ShouldSetMaxHealthEqualToInitial");
static_assert(sizeof(HWGameplayEffect_ShieldOwner_ShouldSetMaxHealthEqualToInitial) == 0x000001, "Wrong size on HWGameplayEffect_ShieldOwner_ShouldSetMaxHealthEqualToInitial");
static_assert(offsetof(HWGameplayEffect_ShieldOwner_ShouldSetMaxHealthEqualToInitial, ReturnValue) == 0x000000, "Member 'HWGameplayEffect_ShieldOwner_ShouldSetMaxHealthEqualToInitial::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.AddShieldHealth
// 0x0004 (0x0004 - 0x0000)
struct HWShieldInstance_AddShieldHealth final
{
public:
	float                                         ShieldHealthToAdd;                                 // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_AddShieldHealth) == 0x000004, "Wrong alignment on HWShieldInstance_AddShieldHealth");
static_assert(sizeof(HWShieldInstance_AddShieldHealth) == 0x000004, "Wrong size on HWShieldInstance_AddShieldHealth");
static_assert(offsetof(HWShieldInstance_AddShieldHealth, ShieldHealthToAdd) == 0x000000, "Member 'HWShieldInstance_AddShieldHealth::ShieldHealthToAdd' has a wrong offset!");

// Function Hemingway.HWShieldInstance.ExtendLifetime
// 0x0004 (0x0004 - 0x0000)
struct HWShieldInstance_ExtendLifetime final
{
public:
	float                                         SecondsToAdd;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_ExtendLifetime) == 0x000004, "Wrong alignment on HWShieldInstance_ExtendLifetime");
static_assert(sizeof(HWShieldInstance_ExtendLifetime) == 0x000004, "Wrong size on HWShieldInstance_ExtendLifetime");
static_assert(offsetof(HWShieldInstance_ExtendLifetime, SecondsToAdd) == 0x000000, "Member 'HWShieldInstance_ExtendLifetime::SecondsToAdd' has a wrong offset!");

// Function Hemingway.HWShieldInstance.RemoveShieldLifetimeExpired
// 0x0028 (0x0028 - 0x0000)
struct HWShieldInstance_RemoveShieldLifetimeExpired final
{
public:
	struct FGameplayEffectRemovalInfo             RemovalInfo;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_RemoveShieldLifetimeExpired) == 0x000008, "Wrong alignment on HWShieldInstance_RemoveShieldLifetimeExpired");
static_assert(sizeof(HWShieldInstance_RemoveShieldLifetimeExpired) == 0x000028, "Wrong size on HWShieldInstance_RemoveShieldLifetimeExpired");
static_assert(offsetof(HWShieldInstance_RemoveShieldLifetimeExpired, RemovalInfo) == 0x000000, "Member 'HWShieldInstance_RemoveShieldLifetimeExpired::RemovalInfo' has a wrong offset!");

// Function Hemingway.HWShieldInstance.SetLifetime
// 0x0004 (0x0004 - 0x0000)
struct HWShieldInstance_SetLifetime final
{
public:
	float                                         NewLifetime;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_SetLifetime) == 0x000004, "Wrong alignment on HWShieldInstance_SetLifetime");
static_assert(sizeof(HWShieldInstance_SetLifetime) == 0x000004, "Wrong size on HWShieldInstance_SetLifetime");
static_assert(offsetof(HWShieldInstance_SetLifetime, NewLifetime) == 0x000000, "Member 'HWShieldInstance_SetLifetime::NewLifetime' has a wrong offset!");

// Function Hemingway.HWShieldInstance.SetShieldHealth
// 0x0004 (0x0004 - 0x0000)
struct HWShieldInstance_SetShieldHealth final
{
public:
	float                                         NewShieldHealth;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_SetShieldHealth) == 0x000004, "Wrong alignment on HWShieldInstance_SetShieldHealth");
static_assert(sizeof(HWShieldInstance_SetShieldHealth) == 0x000004, "Wrong size on HWShieldInstance_SetShieldHealth");
static_assert(offsetof(HWShieldInstance_SetShieldHealth, NewShieldHealth) == 0x000000, "Member 'HWShieldInstance_SetShieldHealth::NewShieldHealth' has a wrong offset!");

// Function Hemingway.HWShieldInstance.ShortenLifetime
// 0x0004 (0x0004 - 0x0000)
struct HWShieldInstance_ShortenLifetime final
{
public:
	float                                         SecondsToSubtract;                                 // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_ShortenLifetime) == 0x000004, "Wrong alignment on HWShieldInstance_ShortenLifetime");
static_assert(sizeof(HWShieldInstance_ShortenLifetime) == 0x000004, "Wrong size on HWShieldInstance_ShortenLifetime");
static_assert(offsetof(HWShieldInstance_ShortenLifetime, SecondsToSubtract) == 0x000000, "Member 'HWShieldInstance_ShortenLifetime::SecondsToSubtract' has a wrong offset!");

// Function Hemingway.HWShieldInstance.SubtractShieldHealth
// 0x0008 (0x0008 - 0x0000)
struct HWShieldInstance_SubtractShieldHealth final
{
public:
	float                                         ShieldHealthToSubtract;                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_SubtractShieldHealth) == 0x000004, "Wrong alignment on HWShieldInstance_SubtractShieldHealth");
static_assert(sizeof(HWShieldInstance_SubtractShieldHealth) == 0x000008, "Wrong size on HWShieldInstance_SubtractShieldHealth");
static_assert(offsetof(HWShieldInstance_SubtractShieldHealth, ShieldHealthToSubtract) == 0x000000, "Member 'HWShieldInstance_SubtractShieldHealth::ShieldHealthToSubtract' has a wrong offset!");
static_assert(offsetof(HWShieldInstance_SubtractShieldHealth, ReturnValue) == 0x000004, "Member 'HWShieldInstance_SubtractShieldHealth::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.GetActiveShieldEffectHandle
// 0x0008 (0x0008 - 0x0000)
struct HWShieldInstance_GetActiveShieldEffectHandle final
{
public:
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_GetActiveShieldEffectHandle) == 0x000004, "Wrong alignment on HWShieldInstance_GetActiveShieldEffectHandle");
static_assert(sizeof(HWShieldInstance_GetActiveShieldEffectHandle) == 0x000008, "Wrong size on HWShieldInstance_GetActiveShieldEffectHandle");
static_assert(offsetof(HWShieldInstance_GetActiveShieldEffectHandle, ReturnValue) == 0x000000, "Member 'HWShieldInstance_GetActiveShieldEffectHandle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.GetCurrentLifetime
// 0x0004 (0x0004 - 0x0000)
struct HWShieldInstance_GetCurrentLifetime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_GetCurrentLifetime) == 0x000004, "Wrong alignment on HWShieldInstance_GetCurrentLifetime");
static_assert(sizeof(HWShieldInstance_GetCurrentLifetime) == 0x000004, "Wrong size on HWShieldInstance_GetCurrentLifetime");
static_assert(offsetof(HWShieldInstance_GetCurrentLifetime, ReturnValue) == 0x000000, "Member 'HWShieldInstance_GetCurrentLifetime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.GetCurrentShieldHealth
// 0x0004 (0x0004 - 0x0000)
struct HWShieldInstance_GetCurrentShieldHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_GetCurrentShieldHealth) == 0x000004, "Wrong alignment on HWShieldInstance_GetCurrentShieldHealth");
static_assert(sizeof(HWShieldInstance_GetCurrentShieldHealth) == 0x000004, "Wrong size on HWShieldInstance_GetCurrentShieldHealth");
static_assert(offsetof(HWShieldInstance_GetCurrentShieldHealth, ReturnValue) == 0x000000, "Member 'HWShieldInstance_GetCurrentShieldHealth::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.GetMaxLifetime
// 0x0004 (0x0004 - 0x0000)
struct HWShieldInstance_GetMaxLifetime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_GetMaxLifetime) == 0x000004, "Wrong alignment on HWShieldInstance_GetMaxLifetime");
static_assert(sizeof(HWShieldInstance_GetMaxLifetime) == 0x000004, "Wrong size on HWShieldInstance_GetMaxLifetime");
static_assert(offsetof(HWShieldInstance_GetMaxLifetime, ReturnValue) == 0x000000, "Member 'HWShieldInstance_GetMaxLifetime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.GetMaxShieldHealth
// 0x0004 (0x0004 - 0x0000)
struct HWShieldInstance_GetMaxShieldHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_GetMaxShieldHealth) == 0x000004, "Wrong alignment on HWShieldInstance_GetMaxShieldHealth");
static_assert(sizeof(HWShieldInstance_GetMaxShieldHealth) == 0x000004, "Wrong size on HWShieldInstance_GetMaxShieldHealth");
static_assert(offsetof(HWShieldInstance_GetMaxShieldHealth, ReturnValue) == 0x000000, "Member 'HWShieldInstance_GetMaxShieldHealth::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.GetShieldEffectTag
// 0x0008 (0x0008 - 0x0000)
struct HWShieldInstance_GetShieldEffectTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_GetShieldEffectTag) == 0x000004, "Wrong alignment on HWShieldInstance_GetShieldEffectTag");
static_assert(sizeof(HWShieldInstance_GetShieldEffectTag) == 0x000008, "Wrong size on HWShieldInstance_GetShieldEffectTag");
static_assert(offsetof(HWShieldInstance_GetShieldEffectTag, ReturnValue) == 0x000000, "Member 'HWShieldInstance_GetShieldEffectTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.GetShieldGranterASC
// 0x0008 (0x0008 - 0x0000)
struct HWShieldInstance_GetShieldGranterASC final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_GetShieldGranterASC) == 0x000008, "Wrong alignment on HWShieldInstance_GetShieldGranterASC");
static_assert(sizeof(HWShieldInstance_GetShieldGranterASC) == 0x000008, "Wrong size on HWShieldInstance_GetShieldGranterASC");
static_assert(offsetof(HWShieldInstance_GetShieldGranterASC, ReturnValue) == 0x000000, "Member 'HWShieldInstance_GetShieldGranterASC::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.GetShieldManagerComponent
// 0x0008 (0x0008 - 0x0000)
struct HWShieldInstance_GetShieldManagerComponent final
{
public:
	class UHWShieldManagerComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_GetShieldManagerComponent) == 0x000008, "Wrong alignment on HWShieldInstance_GetShieldManagerComponent");
static_assert(sizeof(HWShieldInstance_GetShieldManagerComponent) == 0x000008, "Wrong size on HWShieldInstance_GetShieldManagerComponent");
static_assert(offsetof(HWShieldInstance_GetShieldManagerComponent, ReturnValue) == 0x000000, "Member 'HWShieldInstance_GetShieldManagerComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.GetShieldType
// 0x0001 (0x0001 - 0x0000)
struct HWShieldInstance_GetShieldType final
{
public:
	EShieldType                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_GetShieldType) == 0x000001, "Wrong alignment on HWShieldInstance_GetShieldType");
static_assert(sizeof(HWShieldInstance_GetShieldType) == 0x000001, "Wrong size on HWShieldInstance_GetShieldType");
static_assert(offsetof(HWShieldInstance_GetShieldType, ReturnValue) == 0x000000, "Member 'HWShieldInstance_GetShieldType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWShieldInstance.HasLifetime
// 0x0001 (0x0001 - 0x0000)
struct HWShieldInstance_HasLifetime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWShieldInstance_HasLifetime) == 0x000001, "Wrong alignment on HWShieldInstance_HasLifetime");
static_assert(sizeof(HWShieldInstance_HasLifetime) == 0x000001, "Wrong size on HWShieldInstance_HasLifetime");
static_assert(offsetof(HWShieldInstance_HasLifetime, ReturnValue) == 0x000000, "Member 'HWShieldInstance_HasLifetime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameInstance.NetworkFailureEvent
// 0x0028 (0x0028 - 0x0000)
struct HWGameInstance_NetworkFailureEvent final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNetDriver*                             InNetDriver;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENetworkFailure                               InFailureType;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InErrorDescription;                                // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameInstance_NetworkFailureEvent) == 0x000008, "Wrong alignment on HWGameInstance_NetworkFailureEvent");
static_assert(sizeof(HWGameInstance_NetworkFailureEvent) == 0x000028, "Wrong size on HWGameInstance_NetworkFailureEvent");
static_assert(offsetof(HWGameInstance_NetworkFailureEvent, InWorld) == 0x000000, "Member 'HWGameInstance_NetworkFailureEvent::InWorld' has a wrong offset!");
static_assert(offsetof(HWGameInstance_NetworkFailureEvent, InNetDriver) == 0x000008, "Member 'HWGameInstance_NetworkFailureEvent::InNetDriver' has a wrong offset!");
static_assert(offsetof(HWGameInstance_NetworkFailureEvent, InFailureType) == 0x000010, "Member 'HWGameInstance_NetworkFailureEvent::InFailureType' has a wrong offset!");
static_assert(offsetof(HWGameInstance_NetworkFailureEvent, InErrorDescription) == 0x000018, "Member 'HWGameInstance_NetworkFailureEvent::InErrorDescription' has a wrong offset!");

// Function Hemingway.HWGameInstance.OnActiveSessionChanged
// 0x0010 (0x0010 - 0x0000)
struct HWGameInstance_OnActiveSessionChanged final
{
public:
	class URH_JoinedSession*                      OldSesion;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_JoinedSession*                      JoinedSession;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameInstance_OnActiveSessionChanged) == 0x000008, "Wrong alignment on HWGameInstance_OnActiveSessionChanged");
static_assert(sizeof(HWGameInstance_OnActiveSessionChanged) == 0x000010, "Wrong size on HWGameInstance_OnActiveSessionChanged");
static_assert(offsetof(HWGameInstance_OnActiveSessionChanged, OldSesion) == 0x000000, "Member 'HWGameInstance_OnActiveSessionChanged::OldSesion' has a wrong offset!");
static_assert(offsetof(HWGameInstance_OnActiveSessionChanged, JoinedSession) == 0x000008, "Member 'HWGameInstance_OnActiveSessionChanged::JoinedSession' has a wrong offset!");

// Function Hemingway.HWGameInstance.OnSessionUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWGameInstance_OnSessionUpdated final
{
public:
	class URH_SessionView*                        SessionView;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameInstance_OnSessionUpdated) == 0x000008, "Wrong alignment on HWGameInstance_OnSessionUpdated");
static_assert(sizeof(HWGameInstance_OnSessionUpdated) == 0x000008, "Wrong size on HWGameInstance_OnSessionUpdated");
static_assert(offsetof(HWGameInstance_OnSessionUpdated, SessionView) == 0x000000, "Member 'HWGameInstance_OnSessionUpdated::SessionView' has a wrong offset!");

// Function Hemingway.HWGameInstance.SetAllMuted
// 0x0014 (0x0014 - 0x0000)
struct HWGameInstance_SetAllMuted final
{
public:
	struct FGuid                                  PlayerUuid;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameInstance_SetAllMuted) == 0x000004, "Wrong alignment on HWGameInstance_SetAllMuted");
static_assert(sizeof(HWGameInstance_SetAllMuted) == 0x000014, "Wrong size on HWGameInstance_SetAllMuted");
static_assert(offsetof(HWGameInstance_SetAllMuted, PlayerUuid) == 0x000000, "Member 'HWGameInstance_SetAllMuted::PlayerUuid' has a wrong offset!");
static_assert(offsetof(HWGameInstance_SetAllMuted, bIsMuted) == 0x000010, "Member 'HWGameInstance_SetAllMuted::bIsMuted' has a wrong offset!");

// Function Hemingway.HWGameInstance.SetDisconnectErrorCode
// 0x0018 (0x0018 - 0x0000)
struct HWGameInstance_SetDisconnectErrorCode final
{
public:
	class FText                                   ErrorCode;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameInstance_SetDisconnectErrorCode) == 0x000008, "Wrong alignment on HWGameInstance_SetDisconnectErrorCode");
static_assert(sizeof(HWGameInstance_SetDisconnectErrorCode) == 0x000018, "Wrong size on HWGameInstance_SetDisconnectErrorCode");
static_assert(offsetof(HWGameInstance_SetDisconnectErrorCode, ErrorCode) == 0x000000, "Member 'HWGameInstance_SetDisconnectErrorCode::ErrorCode' has a wrong offset!");

// Function Hemingway.HWGameInstance.SetPingsMuted
// 0x0014 (0x0014 - 0x0000)
struct HWGameInstance_SetPingsMuted final
{
public:
	struct FGuid                                  PlayerUuid;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameInstance_SetPingsMuted) == 0x000004, "Wrong alignment on HWGameInstance_SetPingsMuted");
static_assert(sizeof(HWGameInstance_SetPingsMuted) == 0x000014, "Wrong size on HWGameInstance_SetPingsMuted");
static_assert(offsetof(HWGameInstance_SetPingsMuted, PlayerUuid) == 0x000000, "Member 'HWGameInstance_SetPingsMuted::PlayerUuid' has a wrong offset!");
static_assert(offsetof(HWGameInstance_SetPingsMuted, bIsMuted) == 0x000010, "Member 'HWGameInstance_SetPingsMuted::bIsMuted' has a wrong offset!");

// Function Hemingway.HWGameInstance.SetTextMuted
// 0x0014 (0x0014 - 0x0000)
struct HWGameInstance_SetTextMuted final
{
public:
	struct FGuid                                  PlayerUuid;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameInstance_SetTextMuted) == 0x000004, "Wrong alignment on HWGameInstance_SetTextMuted");
static_assert(sizeof(HWGameInstance_SetTextMuted) == 0x000014, "Wrong size on HWGameInstance_SetTextMuted");
static_assert(offsetof(HWGameInstance_SetTextMuted, PlayerUuid) == 0x000000, "Member 'HWGameInstance_SetTextMuted::PlayerUuid' has a wrong offset!");
static_assert(offsetof(HWGameInstance_SetTextMuted, bIsMuted) == 0x000010, "Member 'HWGameInstance_SetTextMuted::bIsMuted' has a wrong offset!");

// Function Hemingway.HWGameInstance.SetTravelErrorCode
// 0x0018 (0x0018 - 0x0000)
struct HWGameInstance_SetTravelErrorCode final
{
public:
	class FText                                   ErrorCode;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameInstance_SetTravelErrorCode) == 0x000008, "Wrong alignment on HWGameInstance_SetTravelErrorCode");
static_assert(sizeof(HWGameInstance_SetTravelErrorCode) == 0x000018, "Wrong size on HWGameInstance_SetTravelErrorCode");
static_assert(offsetof(HWGameInstance_SetTravelErrorCode, ErrorCode) == 0x000000, "Member 'HWGameInstance_SetTravelErrorCode::ErrorCode' has a wrong offset!");

// Function Hemingway.HWGameInstance.SetVGSMuted
// 0x0014 (0x0014 - 0x0000)
struct HWGameInstance_SetVGSMuted final
{
public:
	struct FGuid                                  PlayerUuid;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameInstance_SetVGSMuted) == 0x000004, "Wrong alignment on HWGameInstance_SetVGSMuted");
static_assert(sizeof(HWGameInstance_SetVGSMuted) == 0x000014, "Wrong size on HWGameInstance_SetVGSMuted");
static_assert(offsetof(HWGameInstance_SetVGSMuted, PlayerUuid) == 0x000000, "Member 'HWGameInstance_SetVGSMuted::PlayerUuid' has a wrong offset!");
static_assert(offsetof(HWGameInstance_SetVGSMuted, bIsMuted) == 0x000010, "Member 'HWGameInstance_SetVGSMuted::bIsMuted' has a wrong offset!");

// Function Hemingway.HWGameInstance.TravelFailureEvent
// 0x0020 (0x0020 - 0x0000)
struct HWGameInstance_TravelFailureEvent final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETravelFailure                                InFailureType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InErrorDescription;                                // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameInstance_TravelFailureEvent) == 0x000008, "Wrong alignment on HWGameInstance_TravelFailureEvent");
static_assert(sizeof(HWGameInstance_TravelFailureEvent) == 0x000020, "Wrong size on HWGameInstance_TravelFailureEvent");
static_assert(offsetof(HWGameInstance_TravelFailureEvent, InWorld) == 0x000000, "Member 'HWGameInstance_TravelFailureEvent::InWorld' has a wrong offset!");
static_assert(offsetof(HWGameInstance_TravelFailureEvent, InFailureType) == 0x000008, "Member 'HWGameInstance_TravelFailureEvent::InFailureType' has a wrong offset!");
static_assert(offsetof(HWGameInstance_TravelFailureEvent, InErrorDescription) == 0x000010, "Member 'HWGameInstance_TravelFailureEvent::InErrorDescription' has a wrong offset!");

// Function Hemingway.HWGameInstance.GetDisconnectErrorCode
// 0x0020 (0x0020 - 0x0000)
struct HWGameInstance_GetDisconnectErrorCode final
{
public:
	class FText                                   OutDisconnectError;                                // 0x0000(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameInstance_GetDisconnectErrorCode) == 0x000008, "Wrong alignment on HWGameInstance_GetDisconnectErrorCode");
static_assert(sizeof(HWGameInstance_GetDisconnectErrorCode) == 0x000020, "Wrong size on HWGameInstance_GetDisconnectErrorCode");
static_assert(offsetof(HWGameInstance_GetDisconnectErrorCode, OutDisconnectError) == 0x000000, "Member 'HWGameInstance_GetDisconnectErrorCode::OutDisconnectError' has a wrong offset!");
static_assert(offsetof(HWGameInstance_GetDisconnectErrorCode, ReturnValue) == 0x000018, "Member 'HWGameInstance_GetDisconnectErrorCode::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameInstance.GetNetworkFailureSessionIds
// 0x0010 (0x0010 - 0x0000)
struct HWGameInstance_GetNetworkFailureSessionIds final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameInstance_GetNetworkFailureSessionIds) == 0x000008, "Wrong alignment on HWGameInstance_GetNetworkFailureSessionIds");
static_assert(sizeof(HWGameInstance_GetNetworkFailureSessionIds) == 0x000010, "Wrong size on HWGameInstance_GetNetworkFailureSessionIds");
static_assert(offsetof(HWGameInstance_GetNetworkFailureSessionIds, ReturnValue) == 0x000000, "Member 'HWGameInstance_GetNetworkFailureSessionIds::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameInstance.GetPlayerMuteFlags
// 0x0014 (0x0014 - 0x0000)
struct HWGameInstance_GetPlayerMuteFlags final
{
public:
	struct FGuid                                  PlayerUuid;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRHPlayerMuteFlags                     ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameInstance_GetPlayerMuteFlags) == 0x000004, "Wrong alignment on HWGameInstance_GetPlayerMuteFlags");
static_assert(sizeof(HWGameInstance_GetPlayerMuteFlags) == 0x000014, "Wrong size on HWGameInstance_GetPlayerMuteFlags");
static_assert(offsetof(HWGameInstance_GetPlayerMuteFlags, PlayerUuid) == 0x000000, "Member 'HWGameInstance_GetPlayerMuteFlags::PlayerUuid' has a wrong offset!");
static_assert(offsetof(HWGameInstance_GetPlayerMuteFlags, ReturnValue) == 0x000010, "Member 'HWGameInstance_GetPlayerMuteFlags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameInstance.GetTagManager
// 0x0008 (0x0008 - 0x0000)
struct HWGameInstance_GetTagManager final
{
public:
	class UHWTagManager*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameInstance_GetTagManager) == 0x000008, "Wrong alignment on HWGameInstance_GetTagManager");
static_assert(sizeof(HWGameInstance_GetTagManager) == 0x000008, "Wrong size on HWGameInstance_GetTagManager");
static_assert(offsetof(HWGameInstance_GetTagManager, ReturnValue) == 0x000000, "Member 'HWGameInstance_GetTagManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameInstance.GetTravelErrorCode
// 0x0020 (0x0020 - 0x0000)
struct HWGameInstance_GetTravelErrorCode final
{
public:
	class FText                                   OutDisconnectError;                                // 0x0000(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameInstance_GetTravelErrorCode) == 0x000008, "Wrong alignment on HWGameInstance_GetTravelErrorCode");
static_assert(sizeof(HWGameInstance_GetTravelErrorCode) == 0x000020, "Wrong size on HWGameInstance_GetTravelErrorCode");
static_assert(offsetof(HWGameInstance_GetTravelErrorCode, OutDisconnectError) == 0x000000, "Member 'HWGameInstance_GetTravelErrorCode::OutDisconnectError' has a wrong offset!");
static_assert(offsetof(HWGameInstance_GetTravelErrorCode, ReturnValue) == 0x000018, "Member 'HWGameInstance_GetTravelErrorCode::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameInstance.IsAllMuted
// 0x0014 (0x0014 - 0x0000)
struct HWGameInstance_IsAllMuted final
{
public:
	struct FGuid                                  PlayerUuid;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameInstance_IsAllMuted) == 0x000004, "Wrong alignment on HWGameInstance_IsAllMuted");
static_assert(sizeof(HWGameInstance_IsAllMuted) == 0x000014, "Wrong size on HWGameInstance_IsAllMuted");
static_assert(offsetof(HWGameInstance_IsAllMuted, PlayerUuid) == 0x000000, "Member 'HWGameInstance_IsAllMuted::PlayerUuid' has a wrong offset!");
static_assert(offsetof(HWGameInstance_IsAllMuted, ReturnValue) == 0x000010, "Member 'HWGameInstance_IsAllMuted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameInstance.IsGm
// 0x0001 (0x0001 - 0x0000)
struct HWGameInstance_IsGm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameInstance_IsGm) == 0x000001, "Wrong alignment on HWGameInstance_IsGm");
static_assert(sizeof(HWGameInstance_IsGm) == 0x000001, "Wrong size on HWGameInstance_IsGm");
static_assert(offsetof(HWGameInstance_IsGm, ReturnValue) == 0x000000, "Member 'HWGameInstance_IsGm::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameInstance.IsPingsMuted
// 0x0014 (0x0014 - 0x0000)
struct HWGameInstance_IsPingsMuted final
{
public:
	struct FGuid                                  PlayerUuid;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameInstance_IsPingsMuted) == 0x000004, "Wrong alignment on HWGameInstance_IsPingsMuted");
static_assert(sizeof(HWGameInstance_IsPingsMuted) == 0x000014, "Wrong size on HWGameInstance_IsPingsMuted");
static_assert(offsetof(HWGameInstance_IsPingsMuted, PlayerUuid) == 0x000000, "Member 'HWGameInstance_IsPingsMuted::PlayerUuid' has a wrong offset!");
static_assert(offsetof(HWGameInstance_IsPingsMuted, ReturnValue) == 0x000010, "Member 'HWGameInstance_IsPingsMuted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameInstance.IsTextMuted
// 0x0014 (0x0014 - 0x0000)
struct HWGameInstance_IsTextMuted final
{
public:
	struct FGuid                                  PlayerUuid;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameInstance_IsTextMuted) == 0x000004, "Wrong alignment on HWGameInstance_IsTextMuted");
static_assert(sizeof(HWGameInstance_IsTextMuted) == 0x000014, "Wrong size on HWGameInstance_IsTextMuted");
static_assert(offsetof(HWGameInstance_IsTextMuted, PlayerUuid) == 0x000000, "Member 'HWGameInstance_IsTextMuted::PlayerUuid' has a wrong offset!");
static_assert(offsetof(HWGameInstance_IsTextMuted, ReturnValue) == 0x000010, "Member 'HWGameInstance_IsTextMuted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameInstance.IsVGSMuted
// 0x0014 (0x0014 - 0x0000)
struct HWGameInstance_IsVGSMuted final
{
public:
	struct FGuid                                  PlayerUuid;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameInstance_IsVGSMuted) == 0x000004, "Wrong alignment on HWGameInstance_IsVGSMuted");
static_assert(sizeof(HWGameInstance_IsVGSMuted) == 0x000014, "Wrong size on HWGameInstance_IsVGSMuted");
static_assert(offsetof(HWGameInstance_IsVGSMuted, PlayerUuid) == 0x000000, "Member 'HWGameInstance_IsVGSMuted::PlayerUuid' has a wrong offset!");
static_assert(offsetof(HWGameInstance_IsVGSMuted, ReturnValue) == 0x000010, "Member 'HWGameInstance_IsVGSMuted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRespawnManager.CanRespawnPlayer
// 0x0010 (0x0010 - 0x0000)
struct HWRespawnManager_CanRespawnPlayer final
{
public:
	class AController*                            Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWRespawnManager_CanRespawnPlayer) == 0x000008, "Wrong alignment on HWRespawnManager_CanRespawnPlayer");
static_assert(sizeof(HWRespawnManager_CanRespawnPlayer) == 0x000010, "Wrong size on HWRespawnManager_CanRespawnPlayer");
static_assert(offsetof(HWRespawnManager_CanRespawnPlayer, Player) == 0x000000, "Member 'HWRespawnManager_CanRespawnPlayer::Player' has a wrong offset!");
static_assert(offsetof(HWRespawnManager_CanRespawnPlayer, ReturnValue) == 0x000008, "Member 'HWRespawnManager_CanRespawnPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRespawnManager.ForceRespawn
// 0x0008 (0x0008 - 0x0000)
struct HWRespawnManager_ForceRespawn final
{
public:
	class AHWPlayerState*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRespawnManager_ForceRespawn) == 0x000008, "Wrong alignment on HWRespawnManager_ForceRespawn");
static_assert(sizeof(HWRespawnManager_ForceRespawn) == 0x000008, "Wrong size on HWRespawnManager_ForceRespawn");
static_assert(offsetof(HWRespawnManager_ForceRespawn, Player) == 0x000000, "Member 'HWRespawnManager_ForceRespawn::Player' has a wrong offset!");

// Function Hemingway.HWRespawnManager.PostAddPlayerToRespawnQueue
// 0x0028 (0x0028 - 0x0000)
struct HWRespawnManager_PostAddPlayerToRespawnQueue final
{
public:
	struct FHWRespawnData                         Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRespawnManager_PostAddPlayerToRespawnQueue) == 0x000008, "Wrong alignment on HWRespawnManager_PostAddPlayerToRespawnQueue");
static_assert(sizeof(HWRespawnManager_PostAddPlayerToRespawnQueue) == 0x000028, "Wrong size on HWRespawnManager_PostAddPlayerToRespawnQueue");
static_assert(offsetof(HWRespawnManager_PostAddPlayerToRespawnQueue, Data) == 0x000000, "Member 'HWRespawnManager_PostAddPlayerToRespawnQueue::Data' has a wrong offset!");

// Function Hemingway.HWRespawnManager.PostRespawnPlayer
// 0x0008 (0x0008 - 0x0000)
struct HWRespawnManager_PostRespawnPlayer final
{
public:
	class AController*                            Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRespawnManager_PostRespawnPlayer) == 0x000008, "Wrong alignment on HWRespawnManager_PostRespawnPlayer");
static_assert(sizeof(HWRespawnManager_PostRespawnPlayer) == 0x000008, "Wrong size on HWRespawnManager_PostRespawnPlayer");
static_assert(offsetof(HWRespawnManager_PostRespawnPlayer, Player) == 0x000000, "Member 'HWRespawnManager_PostRespawnPlayer::Player' has a wrong offset!");

// Function Hemingway.HWRespawnManager.PreAddPlayerToRespawnQueue
// 0x0008 (0x0008 - 0x0000)
struct HWRespawnManager_PreAddPlayerToRespawnQueue final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRespawnManager_PreAddPlayerToRespawnQueue) == 0x000008, "Wrong alignment on HWRespawnManager_PreAddPlayerToRespawnQueue");
static_assert(sizeof(HWRespawnManager_PreAddPlayerToRespawnQueue) == 0x000008, "Wrong size on HWRespawnManager_PreAddPlayerToRespawnQueue");
static_assert(offsetof(HWRespawnManager_PreAddPlayerToRespawnQueue, PlayerState) == 0x000000, "Member 'HWRespawnManager_PreAddPlayerToRespawnQueue::PlayerState' has a wrong offset!");

// Function Hemingway.HWRespawnManager.TryToAddPlayerToRespawnQueue
// 0x0010 (0x0010 - 0x0000)
struct HWRespawnManager_TryToAddPlayerToRespawnQueue final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldForce;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWRespawnManager_TryToAddPlayerToRespawnQueue) == 0x000008, "Wrong alignment on HWRespawnManager_TryToAddPlayerToRespawnQueue");
static_assert(sizeof(HWRespawnManager_TryToAddPlayerToRespawnQueue) == 0x000010, "Wrong size on HWRespawnManager_TryToAddPlayerToRespawnQueue");
static_assert(offsetof(HWRespawnManager_TryToAddPlayerToRespawnQueue, PlayerState) == 0x000000, "Member 'HWRespawnManager_TryToAddPlayerToRespawnQueue::PlayerState' has a wrong offset!");
static_assert(offsetof(HWRespawnManager_TryToAddPlayerToRespawnQueue, ShouldForce) == 0x000008, "Member 'HWRespawnManager_TryToAddPlayerToRespawnQueue::ShouldForce' has a wrong offset!");

// Function Hemingway.HWRespawnManager.CanAddPlayerToRespawnQueue
// 0x0010 (0x0010 - 0x0000)
struct HWRespawnManager_CanAddPlayerToRespawnQueue final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWRespawnManager_CanAddPlayerToRespawnQueue) == 0x000008, "Wrong alignment on HWRespawnManager_CanAddPlayerToRespawnQueue");
static_assert(sizeof(HWRespawnManager_CanAddPlayerToRespawnQueue) == 0x000010, "Wrong size on HWRespawnManager_CanAddPlayerToRespawnQueue");
static_assert(offsetof(HWRespawnManager_CanAddPlayerToRespawnQueue, PlayerState) == 0x000000, "Member 'HWRespawnManager_CanAddPlayerToRespawnQueue::PlayerState' has a wrong offset!");
static_assert(offsetof(HWRespawnManager_CanAddPlayerToRespawnQueue, bForce) == 0x000008, "Member 'HWRespawnManager_CanAddPlayerToRespawnQueue::bForce' has a wrong offset!");
static_assert(offsetof(HWRespawnManager_CanAddPlayerToRespawnQueue, ReturnValue) == 0x000009, "Member 'HWRespawnManager_CanAddPlayerToRespawnQueue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRespawnManager.GetGameMode
// 0x0008 (0x0008 - 0x0000)
struct HWRespawnManager_GetGameMode final
{
public:
	class AHWGameMode*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWRespawnManager_GetGameMode) == 0x000008, "Wrong alignment on HWRespawnManager_GetGameMode");
static_assert(sizeof(HWRespawnManager_GetGameMode) == 0x000008, "Wrong size on HWRespawnManager_GetGameMode");
static_assert(offsetof(HWRespawnManager_GetGameMode, ReturnValue) == 0x000000, "Member 'HWRespawnManager_GetGameMode::ReturnValue' has a wrong offset!");

// Function Hemingway.HWRespawnManager.IsPlayerInRespawnQueue
// 0x0010 (0x0010 - 0x0000)
struct HWRespawnManager_IsPlayerInRespawnQueue final
{
public:
	const class AHWPlayerState*                   PlayerState;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutRespawnTimeRemaining;                           // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWRespawnManager_IsPlayerInRespawnQueue) == 0x000008, "Wrong alignment on HWRespawnManager_IsPlayerInRespawnQueue");
static_assert(sizeof(HWRespawnManager_IsPlayerInRespawnQueue) == 0x000010, "Wrong size on HWRespawnManager_IsPlayerInRespawnQueue");
static_assert(offsetof(HWRespawnManager_IsPlayerInRespawnQueue, PlayerState) == 0x000000, "Member 'HWRespawnManager_IsPlayerInRespawnQueue::PlayerState' has a wrong offset!");
static_assert(offsetof(HWRespawnManager_IsPlayerInRespawnQueue, OutRespawnTimeRemaining) == 0x000008, "Member 'HWRespawnManager_IsPlayerInRespawnQueue::OutRespawnTimeRemaining' has a wrong offset!");
static_assert(offsetof(HWRespawnManager_IsPlayerInRespawnQueue, ReturnValue) == 0x00000C, "Member 'HWRespawnManager_IsPlayerInRespawnQueue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.HandleOnGamePhaseEnded
// 0x0008 (0x0008 - 0x0000)
struct HWTeamState_HandleOnGamePhaseEnded final
{
public:
	struct FGameplayTag                           CurrentPhase;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_HandleOnGamePhaseEnded) == 0x000004, "Wrong alignment on HWTeamState_HandleOnGamePhaseEnded");
static_assert(sizeof(HWTeamState_HandleOnGamePhaseEnded) == 0x000008, "Wrong size on HWTeamState_HandleOnGamePhaseEnded");
static_assert(offsetof(HWTeamState_HandleOnGamePhaseEnded, CurrentPhase) == 0x000000, "Member 'HWTeamState_HandleOnGamePhaseEnded::CurrentPhase' has a wrong offset!");

// Function Hemingway.HWTeamState.MulticastBroadcastPauseVoteResolved
// 0x0001 (0x0001 - 0x0000)
struct HWTeamState_MulticastBroadcastPauseVoteResolved final
{
public:
	EHWVoteResult                                 Result;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_MulticastBroadcastPauseVoteResolved) == 0x000001, "Wrong alignment on HWTeamState_MulticastBroadcastPauseVoteResolved");
static_assert(sizeof(HWTeamState_MulticastBroadcastPauseVoteResolved) == 0x000001, "Wrong size on HWTeamState_MulticastBroadcastPauseVoteResolved");
static_assert(offsetof(HWTeamState_MulticastBroadcastPauseVoteResolved, Result) == 0x000000, "Member 'HWTeamState_MulticastBroadcastPauseVoteResolved::Result' has a wrong offset!");

// Function Hemingway.HWTeamState.MulticastBroadcastPauseVotesUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWTeamState_MulticastBroadcastPauseVotesUpdated final
{
public:
	int32                                         NumYesVotes;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumNoVotes;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_MulticastBroadcastPauseVotesUpdated) == 0x000004, "Wrong alignment on HWTeamState_MulticastBroadcastPauseVotesUpdated");
static_assert(sizeof(HWTeamState_MulticastBroadcastPauseVotesUpdated) == 0x000008, "Wrong size on HWTeamState_MulticastBroadcastPauseVotesUpdated");
static_assert(offsetof(HWTeamState_MulticastBroadcastPauseVotesUpdated, NumYesVotes) == 0x000000, "Member 'HWTeamState_MulticastBroadcastPauseVotesUpdated::NumYesVotes' has a wrong offset!");
static_assert(offsetof(HWTeamState_MulticastBroadcastPauseVotesUpdated, NumNoVotes) == 0x000004, "Member 'HWTeamState_MulticastBroadcastPauseVotesUpdated::NumNoVotes' has a wrong offset!");

// Function Hemingway.HWTeamState.MulticastBroadcastSurrenderResolved
// 0x0001 (0x0001 - 0x0000)
struct HWTeamState_MulticastBroadcastSurrenderResolved final
{
public:
	EHWVoteResult                                 Result;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_MulticastBroadcastSurrenderResolved) == 0x000001, "Wrong alignment on HWTeamState_MulticastBroadcastSurrenderResolved");
static_assert(sizeof(HWTeamState_MulticastBroadcastSurrenderResolved) == 0x000001, "Wrong size on HWTeamState_MulticastBroadcastSurrenderResolved");
static_assert(offsetof(HWTeamState_MulticastBroadcastSurrenderResolved, Result) == 0x000000, "Member 'HWTeamState_MulticastBroadcastSurrenderResolved::Result' has a wrong offset!");

// Function Hemingway.HWTeamState.MulticastBroadcastSurrenderVotesUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWTeamState_MulticastBroadcastSurrenderVotesUpdated final
{
public:
	int32                                         NumYesVotes;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumNoVotes;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_MulticastBroadcastSurrenderVotesUpdated) == 0x000004, "Wrong alignment on HWTeamState_MulticastBroadcastSurrenderVotesUpdated");
static_assert(sizeof(HWTeamState_MulticastBroadcastSurrenderVotesUpdated) == 0x000008, "Wrong size on HWTeamState_MulticastBroadcastSurrenderVotesUpdated");
static_assert(offsetof(HWTeamState_MulticastBroadcastSurrenderVotesUpdated, NumYesVotes) == 0x000000, "Member 'HWTeamState_MulticastBroadcastSurrenderVotesUpdated::NumYesVotes' has a wrong offset!");
static_assert(offsetof(HWTeamState_MulticastBroadcastSurrenderVotesUpdated, NumNoVotes) == 0x000004, "Member 'HWTeamState_MulticastBroadcastSurrenderVotesUpdated::NumNoVotes' has a wrong offset!");

// Function Hemingway.HWTeamState.OnRep_TeamID
// 0x0001 (0x0001 - 0x0000)
struct HWTeamState_OnRep_TeamID final
{
public:
	struct FGenericTeamId                         OldTeamId;                                         // 0x0000(0x0001)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_OnRep_TeamID) == 0x000001, "Wrong alignment on HWTeamState_OnRep_TeamID");
static_assert(sizeof(HWTeamState_OnRep_TeamID) == 0x000001, "Wrong size on HWTeamState_OnRep_TeamID");
static_assert(offsetof(HWTeamState_OnRep_TeamID, OldTeamId) == 0x000000, "Member 'HWTeamState_OnRep_TeamID::OldTeamId' has a wrong offset!");

// Function Hemingway.HWTeamState.OnTeamMemberCommittedAssist
// 0x0020 (0x0020 - 0x0000)
struct HWTeamState_OnTeamMemberCommittedAssist final
{
public:
	struct FAssistEventData                       AssistEventData;                                   // 0x0000(0x0020)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_OnTeamMemberCommittedAssist) == 0x000008, "Wrong alignment on HWTeamState_OnTeamMemberCommittedAssist");
static_assert(sizeof(HWTeamState_OnTeamMemberCommittedAssist) == 0x000020, "Wrong size on HWTeamState_OnTeamMemberCommittedAssist");
static_assert(offsetof(HWTeamState_OnTeamMemberCommittedAssist, AssistEventData) == 0x000000, "Member 'HWTeamState_OnTeamMemberCommittedAssist::AssistEventData' has a wrong offset!");

// Function Hemingway.HWTeamState.OnTeamMemberCommittedKill
// 0x0070 (0x0070 - 0x0000)
struct HWTeamState_OnTeamMemberCommittedKill final
{
public:
	struct FDamageEventData                       KillEventData;                                     // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_OnTeamMemberCommittedKill) == 0x000008, "Wrong alignment on HWTeamState_OnTeamMemberCommittedKill");
static_assert(sizeof(HWTeamState_OnTeamMemberCommittedKill) == 0x000070, "Wrong size on HWTeamState_OnTeamMemberCommittedKill");
static_assert(offsetof(HWTeamState_OnTeamMemberCommittedKill, KillEventData) == 0x000000, "Member 'HWTeamState_OnTeamMemberCommittedKill::KillEventData' has a wrong offset!");

// Function Hemingway.HWTeamState.OnTeamMemberDied
// 0x0070 (0x0070 - 0x0000)
struct HWTeamState_OnTeamMemberDied final
{
public:
	struct FDamageEventData                       DeathEventData;                                    // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_OnTeamMemberDied) == 0x000008, "Wrong alignment on HWTeamState_OnTeamMemberDied");
static_assert(sizeof(HWTeamState_OnTeamMemberDied) == 0x000070, "Wrong size on HWTeamState_OnTeamMemberDied");
static_assert(offsetof(HWTeamState_OnTeamMemberDied, DeathEventData) == 0x000000, "Member 'HWTeamState_OnTeamMemberDied::DeathEventData' has a wrong offset!");

// Function Hemingway.HWTeamState.SetGenericTeamId
// 0x0001 (0x0001 - 0x0000)
struct HWTeamState_SetGenericTeamId final
{
public:
	struct FGenericTeamId                         NewTeamId;                                         // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_SetGenericTeamId) == 0x000001, "Wrong alignment on HWTeamState_SetGenericTeamId");
static_assert(sizeof(HWTeamState_SetGenericTeamId) == 0x000001, "Wrong size on HWTeamState_SetGenericTeamId");
static_assert(offsetof(HWTeamState_SetGenericTeamId, NewTeamId) == 0x000000, "Member 'HWTeamState_SetGenericTeamId::NewTeamId' has a wrong offset!");

// Function Hemingway.HWTeamState.GetAllCharacters
// 0x0010 (0x0010 - 0x0000)
struct HWTeamState_GetAllCharacters final
{
public:
	TArray<class AHWCharacter_Base*>              outCharacters;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetAllCharacters) == 0x000008, "Wrong alignment on HWTeamState_GetAllCharacters");
static_assert(sizeof(HWTeamState_GetAllCharacters) == 0x000010, "Wrong size on HWTeamState_GetAllCharacters");
static_assert(offsetof(HWTeamState_GetAllCharacters, outCharacters) == 0x000000, "Member 'HWTeamState_GetAllCharacters::outCharacters' has a wrong offset!");

// Function Hemingway.HWTeamState.GetClosestMemberWithinRange
// 0x0048 (0x0048 - 0x0000)
struct HWTeamState_GetClosestMemberWithinRange final
{
public:
	struct FVector                                SourceLocation;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetClosestMemberWithinRange) == 0x000008, "Wrong alignment on HWTeamState_GetClosestMemberWithinRange");
static_assert(sizeof(HWTeamState_GetClosestMemberWithinRange) == 0x000048, "Wrong size on HWTeamState_GetClosestMemberWithinRange");
static_assert(offsetof(HWTeamState_GetClosestMemberWithinRange, SourceLocation) == 0x000000, "Member 'HWTeamState_GetClosestMemberWithinRange::SourceLocation' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetClosestMemberWithinRange, Radius) == 0x000018, "Member 'HWTeamState_GetClosestMemberWithinRange::Radius' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetClosestMemberWithinRange, tagsToIgnore) == 0x000020, "Member 'HWTeamState_GetClosestMemberWithinRange::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetClosestMemberWithinRange, ReturnValue) == 0x000040, "Member 'HWTeamState_GetClosestMemberWithinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetClosestTeamStructure
// 0x0028 (0x0028 - 0x0000)
struct HWTeamState_GetClosestTeamStructure final
{
public:
	struct FVector                                QueryLocation;                                     // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         outDistance;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetClosestTeamStructure) == 0x000008, "Wrong alignment on HWTeamState_GetClosestTeamStructure");
static_assert(sizeof(HWTeamState_GetClosestTeamStructure) == 0x000028, "Wrong size on HWTeamState_GetClosestTeamStructure");
static_assert(offsetof(HWTeamState_GetClosestTeamStructure, QueryLocation) == 0x000000, "Member 'HWTeamState_GetClosestTeamStructure::QueryLocation' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetClosestTeamStructure, outDistance) == 0x000018, "Member 'HWTeamState_GetClosestTeamStructure::outDistance' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetClosestTeamStructure, ReturnValue) == 0x000020, "Member 'HWTeamState_GetClosestTeamStructure::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetGenericTeamId
// 0x0001 (0x0001 - 0x0000)
struct HWTeamState_GetGenericTeamId final
{
public:
	struct FGenericTeamId                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetGenericTeamId) == 0x000001, "Wrong alignment on HWTeamState_GetGenericTeamId");
static_assert(sizeof(HWTeamState_GetGenericTeamId) == 0x000001, "Wrong size on HWTeamState_GetGenericTeamId");
static_assert(offsetof(HWTeamState_GetGenericTeamId, ReturnValue) == 0x000000, "Member 'HWTeamState_GetGenericTeamId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetGodMemberAliveCount
// 0x0004 (0x0004 - 0x0000)
struct HWTeamState_GetGodMemberAliveCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetGodMemberAliveCount) == 0x000004, "Wrong alignment on HWTeamState_GetGodMemberAliveCount");
static_assert(sizeof(HWTeamState_GetGodMemberAliveCount) == 0x000004, "Wrong size on HWTeamState_GetGodMemberAliveCount");
static_assert(offsetof(HWTeamState_GetGodMemberAliveCount, ReturnValue) == 0x000000, "Member 'HWTeamState_GetGodMemberAliveCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetGodMemberAvgHealthPctWithinRange
// 0x0020 (0x0020 - 0x0000)
struct HWTeamState_GetGodMemberAvgHealthPctWithinRange final
{
public:
	struct FVector                                SourceLocation;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetGodMemberAvgHealthPctWithinRange) == 0x000008, "Wrong alignment on HWTeamState_GetGodMemberAvgHealthPctWithinRange");
static_assert(sizeof(HWTeamState_GetGodMemberAvgHealthPctWithinRange) == 0x000020, "Wrong size on HWTeamState_GetGodMemberAvgHealthPctWithinRange");
static_assert(offsetof(HWTeamState_GetGodMemberAvgHealthPctWithinRange, SourceLocation) == 0x000000, "Member 'HWTeamState_GetGodMemberAvgHealthPctWithinRange::SourceLocation' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetGodMemberAvgHealthPctWithinRange, Radius) == 0x000018, "Member 'HWTeamState_GetGodMemberAvgHealthPctWithinRange::Radius' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetGodMemberAvgHealthPctWithinRange, ReturnValue) == 0x00001C, "Member 'HWTeamState_GetGodMemberAvgHealthPctWithinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetGodMemberCountThatAreFocusedOnTarget
// 0x0018 (0x0018 - 0x0000)
struct HWTeamState_GetGodMemberCountThatAreFocusedOnTarget final
{
public:
	const class AHWCharacter_Base*                SourceCharacter;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AHWCharacter_Base*                TargetCharacter;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSource;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetGodMemberCountThatAreFocusedOnTarget) == 0x000008, "Wrong alignment on HWTeamState_GetGodMemberCountThatAreFocusedOnTarget");
static_assert(sizeof(HWTeamState_GetGodMemberCountThatAreFocusedOnTarget) == 0x000018, "Wrong size on HWTeamState_GetGodMemberCountThatAreFocusedOnTarget");
static_assert(offsetof(HWTeamState_GetGodMemberCountThatAreFocusedOnTarget, SourceCharacter) == 0x000000, "Member 'HWTeamState_GetGodMemberCountThatAreFocusedOnTarget::SourceCharacter' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetGodMemberCountThatAreFocusedOnTarget, TargetCharacter) == 0x000008, "Member 'HWTeamState_GetGodMemberCountThatAreFocusedOnTarget::TargetCharacter' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetGodMemberCountThatAreFocusedOnTarget, bIncludeSource) == 0x000010, "Member 'HWTeamState_GetGodMemberCountThatAreFocusedOnTarget::bIncludeSource' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetGodMemberCountThatAreFocusedOnTarget, ReturnValue) == 0x000014, "Member 'HWTeamState_GetGodMemberCountThatAreFocusedOnTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetGodMemberCountWithinRange
// 0x0020 (0x0020 - 0x0000)
struct HWTeamState_GetGodMemberCountWithinRange final
{
public:
	struct FVector                                SourceLocation;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetGodMemberCountWithinRange) == 0x000008, "Wrong alignment on HWTeamState_GetGodMemberCountWithinRange");
static_assert(sizeof(HWTeamState_GetGodMemberCountWithinRange) == 0x000020, "Wrong size on HWTeamState_GetGodMemberCountWithinRange");
static_assert(offsetof(HWTeamState_GetGodMemberCountWithinRange, SourceLocation) == 0x000000, "Member 'HWTeamState_GetGodMemberCountWithinRange::SourceLocation' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetGodMemberCountWithinRange, Radius) == 0x000018, "Member 'HWTeamState_GetGodMemberCountWithinRange::Radius' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetGodMemberCountWithinRange, ReturnValue) == 0x00001C, "Member 'HWTeamState_GetGodMemberCountWithinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetGodMemberTotalHealthPctWithinRange
// 0x0020 (0x0020 - 0x0000)
struct HWTeamState_GetGodMemberTotalHealthPctWithinRange final
{
public:
	struct FVector                                SourceLocation;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetGodMemberTotalHealthPctWithinRange) == 0x000008, "Wrong alignment on HWTeamState_GetGodMemberTotalHealthPctWithinRange");
static_assert(sizeof(HWTeamState_GetGodMemberTotalHealthPctWithinRange) == 0x000020, "Wrong size on HWTeamState_GetGodMemberTotalHealthPctWithinRange");
static_assert(offsetof(HWTeamState_GetGodMemberTotalHealthPctWithinRange, SourceLocation) == 0x000000, "Member 'HWTeamState_GetGodMemberTotalHealthPctWithinRange::SourceLocation' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetGodMemberTotalHealthPctWithinRange, Radius) == 0x000018, "Member 'HWTeamState_GetGodMemberTotalHealthPctWithinRange::Radius' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetGodMemberTotalHealthPctWithinRange, ReturnValue) == 0x00001C, "Member 'HWTeamState_GetGodMemberTotalHealthPctWithinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetMemberCountWithinRange
// 0x0048 (0x0048 - 0x0000)
struct HWTeamState_GetMemberCountWithinRange final
{
public:
	struct FVector                                SourceLocation;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWTeamState_GetMemberCountWithinRange) == 0x000008, "Wrong alignment on HWTeamState_GetMemberCountWithinRange");
static_assert(sizeof(HWTeamState_GetMemberCountWithinRange) == 0x000048, "Wrong size on HWTeamState_GetMemberCountWithinRange");
static_assert(offsetof(HWTeamState_GetMemberCountWithinRange, SourceLocation) == 0x000000, "Member 'HWTeamState_GetMemberCountWithinRange::SourceLocation' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMemberCountWithinRange, Radius) == 0x000018, "Member 'HWTeamState_GetMemberCountWithinRange::Radius' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMemberCountWithinRange, tagsToIgnore) == 0x000020, "Member 'HWTeamState_GetMemberCountWithinRange::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMemberCountWithinRange, ReturnValue) == 0x000040, "Member 'HWTeamState_GetMemberCountWithinRange::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetMembersWithinRange
// 0x0050 (0x0050 - 0x0000)
struct HWTeamState_GetMembersWithinRange final
{
public:
	struct FVector                                SourceLocation;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AHWCharacter_Base*>              outTargets;                                        // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetMembersWithinRange) == 0x000008, "Wrong alignment on HWTeamState_GetMembersWithinRange");
static_assert(sizeof(HWTeamState_GetMembersWithinRange) == 0x000050, "Wrong size on HWTeamState_GetMembersWithinRange");
static_assert(offsetof(HWTeamState_GetMembersWithinRange, SourceLocation) == 0x000000, "Member 'HWTeamState_GetMembersWithinRange::SourceLocation' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMembersWithinRange, Radius) == 0x000018, "Member 'HWTeamState_GetMembersWithinRange::Radius' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMembersWithinRange, tagsToIgnore) == 0x000020, "Member 'HWTeamState_GetMembersWithinRange::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMembersWithinRange, outTargets) == 0x000040, "Member 'HWTeamState_GetMembersWithinRange::outTargets' has a wrong offset!");

// Function Hemingway.HWTeamState.GetMembersWithinRangeAndViewCone
// 0x0068 (0x0068 - 0x0000)
struct HWTeamState_GetMembersWithinRangeAndViewCone final
{
public:
	struct FVector                                SourceLocation;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SourceRotation;                                    // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0030(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerceptionConeAngle;                               // 0x0034(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  tagsToIgnore;                                      // 0x0038(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AHWCharacter_Base*>              outTargets;                                        // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetMembersWithinRangeAndViewCone) == 0x000008, "Wrong alignment on HWTeamState_GetMembersWithinRangeAndViewCone");
static_assert(sizeof(HWTeamState_GetMembersWithinRangeAndViewCone) == 0x000068, "Wrong size on HWTeamState_GetMembersWithinRangeAndViewCone");
static_assert(offsetof(HWTeamState_GetMembersWithinRangeAndViewCone, SourceLocation) == 0x000000, "Member 'HWTeamState_GetMembersWithinRangeAndViewCone::SourceLocation' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMembersWithinRangeAndViewCone, SourceRotation) == 0x000018, "Member 'HWTeamState_GetMembersWithinRangeAndViewCone::SourceRotation' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMembersWithinRangeAndViewCone, Radius) == 0x000030, "Member 'HWTeamState_GetMembersWithinRangeAndViewCone::Radius' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMembersWithinRangeAndViewCone, PerceptionConeAngle) == 0x000034, "Member 'HWTeamState_GetMembersWithinRangeAndViewCone::PerceptionConeAngle' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMembersWithinRangeAndViewCone, tagsToIgnore) == 0x000038, "Member 'HWTeamState_GetMembersWithinRangeAndViewCone::tagsToIgnore' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMembersWithinRangeAndViewCone, outTargets) == 0x000058, "Member 'HWTeamState_GetMembersWithinRangeAndViewCone::outTargets' has a wrong offset!");

// Function Hemingway.HWTeamState.GetMinionAggroCount
// 0x0010 (0x0010 - 0x0000)
struct HWTeamState_GetMinionAggroCount final
{
public:
	const class AHWCharacter_Base*                Target;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWTeamState_GetMinionAggroCount) == 0x000008, "Wrong alignment on HWTeamState_GetMinionAggroCount");
static_assert(sizeof(HWTeamState_GetMinionAggroCount) == 0x000010, "Wrong size on HWTeamState_GetMinionAggroCount");
static_assert(offsetof(HWTeamState_GetMinionAggroCount, Target) == 0x000000, "Member 'HWTeamState_GetMinionAggroCount::Target' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetMinionAggroCount, ReturnValue) == 0x000008, "Member 'HWTeamState_GetMinionAggroCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetNPCFactories
// 0x0010 (0x0010 - 0x0000)
struct HWTeamState_GetNPCFactories final
{
public:
	TArray<class AHWBotFactory*>                  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetNPCFactories) == 0x000008, "Wrong alignment on HWTeamState_GetNPCFactories");
static_assert(sizeof(HWTeamState_GetNPCFactories) == 0x000010, "Wrong size on HWTeamState_GetNPCFactories");
static_assert(offsetof(HWTeamState_GetNPCFactories, ReturnValue) == 0x000000, "Member 'HWTeamState_GetNPCFactories::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetNPCFactoryForLane
// 0x0010 (0x0010 - 0x0000)
struct HWTeamState_GetNPCFactoryForLane final
{
public:
	class FName                                   LaneId;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWBotFactory*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetNPCFactoryForLane) == 0x000008, "Wrong alignment on HWTeamState_GetNPCFactoryForLane");
static_assert(sizeof(HWTeamState_GetNPCFactoryForLane) == 0x000010, "Wrong size on HWTeamState_GetNPCFactoryForLane");
static_assert(offsetof(HWTeamState_GetNPCFactoryForLane, LaneId) == 0x000000, "Member 'HWTeamState_GetNPCFactoryForLane::LaneId' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetNPCFactoryForLane, ReturnValue) == 0x000008, "Member 'HWTeamState_GetNPCFactoryForLane::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetTeamFountain
// 0x0008 (0x0008 - 0x0000)
struct HWTeamState_GetTeamFountain final
{
public:
	class AHWFountain*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetTeamFountain) == 0x000008, "Wrong alignment on HWTeamState_GetTeamFountain");
static_assert(sizeof(HWTeamState_GetTeamFountain) == 0x000008, "Wrong size on HWTeamState_GetTeamFountain");
static_assert(offsetof(HWTeamState_GetTeamFountain, ReturnValue) == 0x000000, "Member 'HWTeamState_GetTeamFountain::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetTeamMembers
// 0x0010 (0x0010 - 0x0000)
struct HWTeamState_GetTeamMembers final
{
public:
	TArray<class AHWPlayerState*>                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetTeamMembers) == 0x000008, "Wrong alignment on HWTeamState_GetTeamMembers");
static_assert(sizeof(HWTeamState_GetTeamMembers) == 0x000010, "Wrong size on HWTeamState_GetTeamMembers");
static_assert(offsetof(HWTeamState_GetTeamMembers, ReturnValue) == 0x000000, "Member 'HWTeamState_GetTeamMembers::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetTeamStatsTracker
// 0x0008 (0x0008 - 0x0000)
struct HWTeamState_GetTeamStatsTracker final
{
public:
	class AHWTeamStatsTracker*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetTeamStatsTracker) == 0x000008, "Wrong alignment on HWTeamState_GetTeamStatsTracker");
static_assert(sizeof(HWTeamState_GetTeamStatsTracker) == 0x000008, "Wrong size on HWTeamState_GetTeamStatsTracker");
static_assert(offsetof(HWTeamState_GetTeamStatsTracker, ReturnValue) == 0x000000, "Member 'HWTeamState_GetTeamStatsTracker::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetTeamStructureCountByTag
// 0x000C (0x000C - 0x0000)
struct HWTeamState_GetTeamStructureCountByTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetTeamStructureCountByTag) == 0x000004, "Wrong alignment on HWTeamState_GetTeamStructureCountByTag");
static_assert(sizeof(HWTeamState_GetTeamStructureCountByTag) == 0x00000C, "Wrong size on HWTeamState_GetTeamStructureCountByTag");
static_assert(offsetof(HWTeamState_GetTeamStructureCountByTag, Tag) == 0x000000, "Member 'HWTeamState_GetTeamStructureCountByTag::Tag' has a wrong offset!");
static_assert(offsetof(HWTeamState_GetTeamStructureCountByTag, ReturnValue) == 0x000008, "Member 'HWTeamState_GetTeamStructureCountByTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamState.GetTeamStructures
// 0x0010 (0x0010 - 0x0000)
struct HWTeamState_GetTeamStructures final
{
public:
	TArray<class AHWBotFactory*>                  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamState_GetTeamStructures) == 0x000008, "Wrong alignment on HWTeamState_GetTeamStructures");
static_assert(sizeof(HWTeamState_GetTeamStructures) == 0x000010, "Wrong size on HWTeamState_GetTeamStructures");
static_assert(offsetof(HWTeamState_GetTeamStructures, ReturnValue) == 0x000000, "Member 'HWTeamState_GetTeamStructures::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameMode_Arena.BotGoalReached
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_Arena_BotGoalReached final
{
public:
	class AActor*                                 Bot;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_Arena_BotGoalReached) == 0x000008, "Wrong alignment on HWGameMode_Arena_BotGoalReached");
static_assert(sizeof(HWGameMode_Arena_BotGoalReached) == 0x000008, "Wrong size on HWGameMode_Arena_BotGoalReached");
static_assert(offsetof(HWGameMode_Arena_BotGoalReached, Bot) == 0x000000, "Member 'HWGameMode_Arena_BotGoalReached::Bot' has a wrong offset!");

// Function Hemingway.HWGameMode_Arena.Defeat
// 0x0001 (0x0001 - 0x0000)
struct HWGameMode_Arena_Defeat final
{
public:
	struct FGenericTeamId                         Team;                                              // 0x0000(0x0001)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_Arena_Defeat) == 0x000001, "Wrong alignment on HWGameMode_Arena_Defeat");
static_assert(sizeof(HWGameMode_Arena_Defeat) == 0x000001, "Wrong size on HWGameMode_Arena_Defeat");
static_assert(offsetof(HWGameMode_Arena_Defeat, Team) == 0x000000, "Member 'HWGameMode_Arena_Defeat::Team' has a wrong offset!");

// Function Hemingway.HWGameMode_Arena.GetTugOfWarManager
// 0x0008 (0x0008 - 0x0000)
struct HWGameMode_Arena_GetTugOfWarManager final
{
public:
	class AHWAITugOfWarManager*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameMode_Arena_GetTugOfWarManager) == 0x000008, "Wrong alignment on HWGameMode_Arena_GetTugOfWarManager");
static_assert(sizeof(HWGameMode_Arena_GetTugOfWarManager) == 0x000008, "Wrong size on HWGameMode_Arena_GetTugOfWarManager");
static_assert(offsetof(HWGameMode_Arena_GetTugOfWarManager, ReturnValue) == 0x000000, "Member 'HWGameMode_Arena_GetTugOfWarManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Aladdin.SetWallRunVisualInfo
// 0x0002 (0x0002 - 0x0000)
struct HWCharacter_Aladdin_SetWallRunVisualInfo final
{
public:
	struct FHWAladdinWallRunVisualInfo            VisualInfo;                                        // 0x0000(0x0002)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Aladdin_SetWallRunVisualInfo) == 0x000001, "Wrong alignment on HWCharacter_Aladdin_SetWallRunVisualInfo");
static_assert(sizeof(HWCharacter_Aladdin_SetWallRunVisualInfo) == 0x000002, "Wrong size on HWCharacter_Aladdin_SetWallRunVisualInfo");
static_assert(offsetof(HWCharacter_Aladdin_SetWallRunVisualInfo, VisualInfo) == 0x000000, "Member 'HWCharacter_Aladdin_SetWallRunVisualInfo::VisualInfo' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Amaterasu.OnRep_StoredDamage
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Amaterasu_OnRep_StoredDamage final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Amaterasu_OnRep_StoredDamage) == 0x000008, "Wrong alignment on HWAttributeSet_Amaterasu_OnRep_StoredDamage");
static_assert(sizeof(HWAttributeSet_Amaterasu_OnRep_StoredDamage) == 0x000010, "Wrong size on HWAttributeSet_Amaterasu_OnRep_StoredDamage");
static_assert(offsetof(HWAttributeSet_Amaterasu_OnRep_StoredDamage, OldValue) == 0x000000, "Member 'HWAttributeSet_Amaterasu_OnRep_StoredDamage::OldValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Apollo.ActivateHitchHikerVisuals
// 0x0030 (0x0030 - 0x0000)
struct HWCharacter_Apollo_ActivateHitchHikerVisuals final
{
public:
	struct FHWApolloA04HitchHikerInfo             HitchHikerInfo;                                    // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Apollo_ActivateHitchHikerVisuals) == 0x000008, "Wrong alignment on HWCharacter_Apollo_ActivateHitchHikerVisuals");
static_assert(sizeof(HWCharacter_Apollo_ActivateHitchHikerVisuals) == 0x000030, "Wrong size on HWCharacter_Apollo_ActivateHitchHikerVisuals");
static_assert(offsetof(HWCharacter_Apollo_ActivateHitchHikerVisuals, HitchHikerInfo) == 0x000000, "Member 'HWCharacter_Apollo_ActivateHitchHikerVisuals::HitchHikerInfo' has a wrong offset!");

// Function Hemingway.HWCharacter_Apollo.AddHitchHiker
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Apollo_AddHitchHiker final
{
public:
	const class AHWCharacter_Base*                HitchHiker;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_GameplayGrab*            ChariotGrabTask;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Apollo_AddHitchHiker) == 0x000008, "Wrong alignment on HWCharacter_Apollo_AddHitchHiker");
static_assert(sizeof(HWCharacter_Apollo_AddHitchHiker) == 0x000010, "Wrong size on HWCharacter_Apollo_AddHitchHiker");
static_assert(offsetof(HWCharacter_Apollo_AddHitchHiker, HitchHiker) == 0x000000, "Member 'HWCharacter_Apollo_AddHitchHiker::HitchHiker' has a wrong offset!");
static_assert(offsetof(HWCharacter_Apollo_AddHitchHiker, ChariotGrabTask) == 0x000008, "Member 'HWCharacter_Apollo_AddHitchHiker::ChariotGrabTask' has a wrong offset!");

// Function Hemingway.HWCharacter_Apollo.DeactivateHitchHikerVisuals
// 0x0030 (0x0030 - 0x0000)
struct HWCharacter_Apollo_DeactivateHitchHikerVisuals final
{
public:
	struct FHWApolloA04HitchHikerInfo             HitchHikerInfo;                                    // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Apollo_DeactivateHitchHikerVisuals) == 0x000008, "Wrong alignment on HWCharacter_Apollo_DeactivateHitchHikerVisuals");
static_assert(sizeof(HWCharacter_Apollo_DeactivateHitchHikerVisuals) == 0x000030, "Wrong size on HWCharacter_Apollo_DeactivateHitchHikerVisuals");
static_assert(offsetof(HWCharacter_Apollo_DeactivateHitchHikerVisuals, HitchHikerInfo) == 0x000000, "Member 'HWCharacter_Apollo_DeactivateHitchHikerVisuals::HitchHikerInfo' has a wrong offset!");

// Function Hemingway.HWCharacter_Apollo.OnRep_HitchHikers
// 0x0010 (0x0010 - 0x0000)
struct HWCharacter_Apollo_OnRep_HitchHikers final
{
public:
	TArray<struct FHWApolloA04HitchHikerInfo>     PrevHitchHikers;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Apollo_OnRep_HitchHikers) == 0x000008, "Wrong alignment on HWCharacter_Apollo_OnRep_HitchHikers");
static_assert(sizeof(HWCharacter_Apollo_OnRep_HitchHikers) == 0x000010, "Wrong size on HWCharacter_Apollo_OnRep_HitchHikers");
static_assert(offsetof(HWCharacter_Apollo_OnRep_HitchHikers, PrevHitchHikers) == 0x000000, "Member 'HWCharacter_Apollo_OnRep_HitchHikers::PrevHitchHikers' has a wrong offset!");

// Function Hemingway.HWCharacter_Apollo.RemoveHitchHiker
// 0x0038 (0x0038 - 0x0000)
struct HWCharacter_Apollo_RemoveHitchHiker final
{
public:
	const class AHWCharacter_Base*                HitchHiker;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWApolloA04HitchHikerInfo             ReturnValue;                                       // 0x0008(0x0030)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Apollo_RemoveHitchHiker) == 0x000008, "Wrong alignment on HWCharacter_Apollo_RemoveHitchHiker");
static_assert(sizeof(HWCharacter_Apollo_RemoveHitchHiker) == 0x000038, "Wrong size on HWCharacter_Apollo_RemoveHitchHiker");
static_assert(offsetof(HWCharacter_Apollo_RemoveHitchHiker, HitchHiker) == 0x000000, "Member 'HWCharacter_Apollo_RemoveHitchHiker::HitchHiker' has a wrong offset!");
static_assert(offsetof(HWCharacter_Apollo_RemoveHitchHiker, ReturnValue) == 0x000008, "Member 'HWCharacter_Apollo_RemoveHitchHiker::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Apollo.GetMaxHitchHikers
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Apollo_GetMaxHitchHikers final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Apollo_GetMaxHitchHikers) == 0x000004, "Wrong alignment on HWCharacter_Apollo_GetMaxHitchHikers");
static_assert(sizeof(HWCharacter_Apollo_GetMaxHitchHikers) == 0x000004, "Wrong size on HWCharacter_Apollo_GetMaxHitchHikers");
static_assert(offsetof(HWCharacter_Apollo_GetMaxHitchHikers, ReturnValue) == 0x000000, "Member 'HWCharacter_Apollo_GetMaxHitchHikers::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Apollo.GetNumOfActiveHitchHikers
// 0x0004 (0x0004 - 0x0000)
struct HWCharacter_Apollo_GetNumOfActiveHitchHikers final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Apollo_GetNumOfActiveHitchHikers) == 0x000004, "Wrong alignment on HWCharacter_Apollo_GetNumOfActiveHitchHikers");
static_assert(sizeof(HWCharacter_Apollo_GetNumOfActiveHitchHikers) == 0x000004, "Wrong size on HWCharacter_Apollo_GetNumOfActiveHitchHikers");
static_assert(offsetof(HWCharacter_Apollo_GetNumOfActiveHitchHikers, ReturnValue) == 0x000000, "Member 'HWCharacter_Apollo_GetNumOfActiveHitchHikers::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Apollo.HasAvailableHitchHikerSpot
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Apollo_HasAvailableHitchHikerSpot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Apollo_HasAvailableHitchHikerSpot) == 0x000001, "Wrong alignment on HWCharacter_Apollo_HasAvailableHitchHikerSpot");
static_assert(sizeof(HWCharacter_Apollo_HasAvailableHitchHikerSpot) == 0x000001, "Wrong size on HWCharacter_Apollo_HasAvailableHitchHikerSpot");
static_assert(offsetof(HWCharacter_Apollo_HasAvailableHitchHikerSpot, ReturnValue) == 0x000000, "Member 'HWCharacter_Apollo_HasAvailableHitchHikerSpot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Awilix_B01.OnAnotherAbilityActivated
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Awilix_B01_OnAnotherAbilityActivated final
{
public:
	class UGameplayAbility*                       ActivatedAbility;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Awilix_B01_OnAnotherAbilityActivated) == 0x000008, "Wrong alignment on HWAbility_Awilix_B01_OnAnotherAbilityActivated");
static_assert(sizeof(HWAbility_Awilix_B01_OnAnotherAbilityActivated) == 0x000008, "Wrong size on HWAbility_Awilix_B01_OnAnotherAbilityActivated");
static_assert(offsetof(HWAbility_Awilix_B01_OnAnotherAbilityActivated, ActivatedAbility) == 0x000000, "Member 'HWAbility_Awilix_B01_OnAnotherAbilityActivated::ActivatedAbility' has a wrong offset!");

// Function Hemingway.HWAbility_Awilix_B01.OnAnotherAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Awilix_B01_OnAnotherAbilityEnded final
{
public:
	class UGameplayAbility*                       EndedAbility;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Awilix_B01_OnAnotherAbilityEnded) == 0x000008, "Wrong alignment on HWAbility_Awilix_B01_OnAnotherAbilityEnded");
static_assert(sizeof(HWAbility_Awilix_B01_OnAnotherAbilityEnded) == 0x000008, "Wrong size on HWAbility_Awilix_B01_OnAnotherAbilityEnded");
static_assert(offsetof(HWAbility_Awilix_B01_OnAnotherAbilityEnded, EndedAbility) == 0x000000, "Member 'HWAbility_Awilix_B01_OnAnotherAbilityEnded::EndedAbility' has a wrong offset!");

// Function Hemingway.HWAbility_Awilix_B01.OnBlockingTagsUpdated
// 0x000C (0x000C - 0x0000)
struct HWAbility_Awilix_B01_OnBlockingTagsUpdated final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Awilix_B01_OnBlockingTagsUpdated) == 0x000004, "Wrong alignment on HWAbility_Awilix_B01_OnBlockingTagsUpdated");
static_assert(sizeof(HWAbility_Awilix_B01_OnBlockingTagsUpdated) == 0x00000C, "Wrong size on HWAbility_Awilix_B01_OnBlockingTagsUpdated");
static_assert(offsetof(HWAbility_Awilix_B01_OnBlockingTagsUpdated, Tag) == 0x000000, "Member 'HWAbility_Awilix_B01_OnBlockingTagsUpdated::Tag' has a wrong offset!");
static_assert(offsetof(HWAbility_Awilix_B01_OnBlockingTagsUpdated, Count) == 0x000008, "Member 'HWAbility_Awilix_B01_OnBlockingTagsUpdated::Count' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Bacchus.OnRep_Drunkenness
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Bacchus_OnRep_Drunkenness final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Bacchus_OnRep_Drunkenness) == 0x000008, "Wrong alignment on HWAttributeSet_Bacchus_OnRep_Drunkenness");
static_assert(sizeof(HWAttributeSet_Bacchus_OnRep_Drunkenness) == 0x000010, "Wrong size on HWAttributeSet_Bacchus_OnRep_Drunkenness");
static_assert(offsetof(HWAttributeSet_Bacchus_OnRep_Drunkenness, OldValue) == 0x000000, "Member 'HWAttributeSet_Bacchus_OnRep_Drunkenness::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Bari.OnRep_MaxSpirit
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Bari_OnRep_MaxSpirit final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Bari_OnRep_MaxSpirit) == 0x000008, "Wrong alignment on HWAttributeSet_Bari_OnRep_MaxSpirit");
static_assert(sizeof(HWAttributeSet_Bari_OnRep_MaxSpirit) == 0x000010, "Wrong size on HWAttributeSet_Bari_OnRep_MaxSpirit");
static_assert(offsetof(HWAttributeSet_Bari_OnRep_MaxSpirit, OldValue) == 0x000000, "Member 'HWAttributeSet_Bari_OnRep_MaxSpirit::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Bari.OnRep_Spirit
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Bari_OnRep_Spirit final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Bari_OnRep_Spirit) == 0x000008, "Wrong alignment on HWAttributeSet_Bari_OnRep_Spirit");
static_assert(sizeof(HWAttributeSet_Bari_OnRep_Spirit) == 0x000010, "Wrong size on HWAttributeSet_Bari_OnRep_Spirit");
static_assert(offsetof(HWAttributeSet_Bari_OnRep_Spirit, OldValue) == 0x000000, "Member 'HWAttributeSet_Bari_OnRep_Spirit::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Bari.OnRep_SpiritPerTime
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Bari_OnRep_SpiritPerTime final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Bari_OnRep_SpiritPerTime) == 0x000008, "Wrong alignment on HWAttributeSet_Bari_OnRep_SpiritPerTime");
static_assert(sizeof(HWAttributeSet_Bari_OnRep_SpiritPerTime) == 0x000010, "Wrong size on HWAttributeSet_Bari_OnRep_SpiritPerTime");
static_assert(offsetof(HWAttributeSet_Bari_OnRep_SpiritPerTime, OldValue) == 0x000000, "Member 'HWAttributeSet_Bari_OnRep_SpiritPerTime::OldValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Bari_A01.OnRep_BellState
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Bari_A01_OnRep_BellState final
{
public:
	EHWBariBellState                              OldBellState;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Bari_A01_OnRep_BellState) == 0x000001, "Wrong alignment on HWDeployable_Bari_A01_OnRep_BellState");
static_assert(sizeof(HWDeployable_Bari_A01_OnRep_BellState) == 0x000001, "Wrong size on HWDeployable_Bari_A01_OnRep_BellState");
static_assert(offsetof(HWDeployable_Bari_A01_OnRep_BellState, OldBellState) == 0x000000, "Member 'HWDeployable_Bari_A01_OnRep_BellState::OldBellState' has a wrong offset!");

// Function Hemingway.HWDeployable_Bari_A01.RecallToBari
// 0x0010 (0x0010 - 0x0000)
struct HWDeployable_Bari_A01_RecallToBari final
{
public:
	struct FHWBariBellRecallInfo                  recallInfo;                                        // 0x0000(0x0010)(ConstParm, Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Bari_A01_RecallToBari) == 0x000008, "Wrong alignment on HWDeployable_Bari_A01_RecallToBari");
static_assert(sizeof(HWDeployable_Bari_A01_RecallToBari) == 0x000010, "Wrong size on HWDeployable_Bari_A01_RecallToBari");
static_assert(offsetof(HWDeployable_Bari_A01_RecallToBari, recallInfo) == 0x000000, "Member 'HWDeployable_Bari_A01_RecallToBari::recallInfo' has a wrong offset!");

// Function Hemingway.HWDeployable_Bari_A01.SetBellState
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Bari_A01_SetBellState final
{
public:
	EHWBariBellState                              State;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Bari_A01_SetBellState) == 0x000001, "Wrong alignment on HWDeployable_Bari_A01_SetBellState");
static_assert(sizeof(HWDeployable_Bari_A01_SetBellState) == 0x000001, "Wrong size on HWDeployable_Bari_A01_SetBellState");
static_assert(offsetof(HWDeployable_Bari_A01_SetBellState, State) == 0x000000, "Member 'HWDeployable_Bari_A01_SetBellState::State' has a wrong offset!");

// Function Hemingway.HWDeployable_Bari_A01.SetIsEnhanced
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Bari_A01_SetIsEnhanced final
{
public:
	bool                                          bEnableEnhancement;                                // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Bari_A01_SetIsEnhanced) == 0x000001, "Wrong alignment on HWDeployable_Bari_A01_SetIsEnhanced");
static_assert(sizeof(HWDeployable_Bari_A01_SetIsEnhanced) == 0x000001, "Wrong size on HWDeployable_Bari_A01_SetIsEnhanced");
static_assert(offsetof(HWDeployable_Bari_A01_SetIsEnhanced, bEnableEnhancement) == 0x000000, "Member 'HWDeployable_Bari_A01_SetIsEnhanced::bEnableEnhancement' has a wrong offset!");

// Function Hemingway.HWDeployable_Bari_A01.GetEnhancedCollisionRadius
// 0x0004 (0x0004 - 0x0000)
struct HWDeployable_Bari_A01_GetEnhancedCollisionRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Bari_A01_GetEnhancedCollisionRadius) == 0x000004, "Wrong alignment on HWDeployable_Bari_A01_GetEnhancedCollisionRadius");
static_assert(sizeof(HWDeployable_Bari_A01_GetEnhancedCollisionRadius) == 0x000004, "Wrong size on HWDeployable_Bari_A01_GetEnhancedCollisionRadius");
static_assert(offsetof(HWDeployable_Bari_A01_GetEnhancedCollisionRadius, ReturnValue) == 0x000000, "Member 'HWDeployable_Bari_A01_GetEnhancedCollisionRadius::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Bari_A01.GetRecallLocation
// 0x0030 (0x0030 - 0x0000)
struct HWDeployable_Bari_A01_GetRecallLocation final
{
public:
	struct FVector                                RecallOrigin;                                      // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Bari_A01_GetRecallLocation) == 0x000008, "Wrong alignment on HWDeployable_Bari_A01_GetRecallLocation");
static_assert(sizeof(HWDeployable_Bari_A01_GetRecallLocation) == 0x000030, "Wrong size on HWDeployable_Bari_A01_GetRecallLocation");
static_assert(offsetof(HWDeployable_Bari_A01_GetRecallLocation, RecallOrigin) == 0x000000, "Member 'HWDeployable_Bari_A01_GetRecallLocation::RecallOrigin' has a wrong offset!");
static_assert(offsetof(HWDeployable_Bari_A01_GetRecallLocation, ReturnValue) == 0x000018, "Member 'HWDeployable_Bari_A01_GetRecallLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Bari_A01.GetRecallVelocity
// 0x0018 (0x0018 - 0x0000)
struct HWDeployable_Bari_A01_GetRecallVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Bari_A01_GetRecallVelocity) == 0x000008, "Wrong alignment on HWDeployable_Bari_A01_GetRecallVelocity");
static_assert(sizeof(HWDeployable_Bari_A01_GetRecallVelocity) == 0x000018, "Wrong size on HWDeployable_Bari_A01_GetRecallVelocity");
static_assert(offsetof(HWDeployable_Bari_A01_GetRecallVelocity, ReturnValue) == 0x000000, "Member 'HWDeployable_Bari_A01_GetRecallVelocity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWDeployable_Bari_A01.IsEnhanced
// 0x0001 (0x0001 - 0x0000)
struct HWDeployable_Bari_A01_IsEnhanced final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWDeployable_Bari_A01_IsEnhanced) == 0x000001, "Wrong alignment on HWDeployable_Bari_A01_IsEnhanced");
static_assert(sizeof(HWDeployable_Bari_A01_IsEnhanced) == 0x000001, "Wrong size on HWDeployable_Bari_A01_IsEnhanced");
static_assert(offsetof(HWDeployable_Bari_A01_IsEnhanced, ReturnValue) == 0x000000, "Member 'HWDeployable_Bari_A01_IsEnhanced::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Danzaburou.OnRep_CloneSpawnChance
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Danzaburou_OnRep_CloneSpawnChance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Danzaburou_OnRep_CloneSpawnChance) == 0x000008, "Wrong alignment on HWAttributeSet_Danzaburou_OnRep_CloneSpawnChance");
static_assert(sizeof(HWAttributeSet_Danzaburou_OnRep_CloneSpawnChance) == 0x000010, "Wrong size on HWAttributeSet_Danzaburou_OnRep_CloneSpawnChance");
static_assert(offsetof(HWAttributeSet_Danzaburou_OnRep_CloneSpawnChance, OldValue) == 0x000000, "Member 'HWAttributeSet_Danzaburou_OnRep_CloneSpawnChance::OldValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Danzaburou.SetLeafFormEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Danzaburou_SetLeafFormEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Danzaburou_SetLeafFormEnabled) == 0x000001, "Wrong alignment on HWCharacter_Danzaburou_SetLeafFormEnabled");
static_assert(sizeof(HWCharacter_Danzaburou_SetLeafFormEnabled) == 0x000001, "Wrong size on HWCharacter_Danzaburou_SetLeafFormEnabled");
static_assert(offsetof(HWCharacter_Danzaburou_SetLeafFormEnabled, bEnable) == 0x000000, "Member 'HWCharacter_Danzaburou_SetLeafFormEnabled::bEnable' has a wrong offset!");

// Function Hemingway.HWCharacter_Danzaburou.SetRocketFormEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Danzaburou_SetRocketFormEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Danzaburou_SetRocketFormEnabled) == 0x000001, "Wrong alignment on HWCharacter_Danzaburou_SetRocketFormEnabled");
static_assert(sizeof(HWCharacter_Danzaburou_SetRocketFormEnabled) == 0x000001, "Wrong size on HWCharacter_Danzaburou_SetRocketFormEnabled");
static_assert(offsetof(HWCharacter_Danzaburou_SetRocketFormEnabled, bEnable) == 0x000000, "Member 'HWCharacter_Danzaburou_SetRocketFormEnabled::bEnable' has a wrong offset!");

// Function Hemingway.HWCharacter_Danzaburou.IsInLeafForm
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Danzaburou_IsInLeafForm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Danzaburou_IsInLeafForm) == 0x000001, "Wrong alignment on HWCharacter_Danzaburou_IsInLeafForm");
static_assert(sizeof(HWCharacter_Danzaburou_IsInLeafForm) == 0x000001, "Wrong size on HWCharacter_Danzaburou_IsInLeafForm");
static_assert(offsetof(HWCharacter_Danzaburou_IsInLeafForm, ReturnValue) == 0x000000, "Member 'HWCharacter_Danzaburou_IsInLeafForm::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_Danzaburou.IsInRocketForm
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_Danzaburou_IsInRocketForm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_Danzaburou_IsInRocketForm) == 0x000001, "Wrong alignment on HWCharacter_Danzaburou_IsInRocketForm");
static_assert(sizeof(HWCharacter_Danzaburou_IsInRocketForm) == 0x000001, "Wrong size on HWCharacter_Danzaburou_IsInRocketForm");
static_assert(offsetof(HWCharacter_Danzaburou_IsInRocketForm, ReturnValue) == 0x000000, "Member 'HWCharacter_Danzaburou_IsInRocketForm::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkeletalMeshActor_Danzaburou_Decoy.ShouldUpdateVelocity
// 0x0001 (0x0001 - 0x0000)
struct HWSkeletalMeshActor_Danzaburou_Decoy_ShouldUpdateVelocity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkeletalMeshActor_Danzaburou_Decoy_ShouldUpdateVelocity) == 0x000001, "Wrong alignment on HWSkeletalMeshActor_Danzaburou_Decoy_ShouldUpdateVelocity");
static_assert(sizeof(HWSkeletalMeshActor_Danzaburou_Decoy_ShouldUpdateVelocity) == 0x000001, "Wrong size on HWSkeletalMeshActor_Danzaburou_Decoy_ShouldUpdateVelocity");
static_assert(offsetof(HWSkeletalMeshActor_Danzaburou_Decoy_ShouldUpdateVelocity, ReturnValue) == 0x000000, "Member 'HWSkeletalMeshActor_Danzaburou_Decoy_ShouldUpdateVelocity::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Hades_A03.CreateAimDataAtCharacterLocation
// 0x0030 (0x0030 - 0x0000)
struct HWAbility_Hades_A03_CreateAimDataAtCharacterLocation final
{
public:
	class AHWCharacter_Base*                      Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hades_A03_CreateAimDataAtCharacterLocation) == 0x000008, "Wrong alignment on HWAbility_Hades_A03_CreateAimDataAtCharacterLocation");
static_assert(sizeof(HWAbility_Hades_A03_CreateAimDataAtCharacterLocation) == 0x000030, "Wrong size on HWAbility_Hades_A03_CreateAimDataAtCharacterLocation");
static_assert(offsetof(HWAbility_Hades_A03_CreateAimDataAtCharacterLocation, Character) == 0x000000, "Member 'HWAbility_Hades_A03_CreateAimDataAtCharacterLocation::Character' has a wrong offset!");
static_assert(offsetof(HWAbility_Hades_A03_CreateAimDataAtCharacterLocation, ReturnValue) == 0x000008, "Member 'HWAbility_Hades_A03_CreateAimDataAtCharacterLocation::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Hades_A03.GetBlightedEnemiesAtDetonate
// 0x0058 (0x0058 - 0x0000)
struct HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate final
{
public:
	struct FGameplayAbilityTargetDataHandle       DetonateTargetData;                                // 0x0000(0x0028)(Parm, NativeAccessSpecifierPublic)
	float                                         DetonateRadius;                                    // 0x0028(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0030(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate) == 0x000008, "Wrong alignment on HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate");
static_assert(sizeof(HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate) == 0x000058, "Wrong size on HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate");
static_assert(offsetof(HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate, DetonateTargetData) == 0x000000, "Member 'HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate::DetonateTargetData' has a wrong offset!");
static_assert(offsetof(HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate, DetonateRadius) == 0x000028, "Member 'HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate::DetonateRadius' has a wrong offset!");
static_assert(offsetof(HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate, ReturnValue) == 0x000030, "Member 'HWAbility_Hades_A03_GetBlightedEnemiesAtDetonate::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Hades_A03.GetCascadedBlightedEnemies
// 0x0018 (0x0018 - 0x0000)
struct HWAbility_Hades_A03_GetCascadedBlightedEnemies final
{
public:
	TArray<class AActor*>                         OutBlightedEnemies;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HadesDetonateRadius;                               // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyDetonateRadius;                               // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hades_A03_GetCascadedBlightedEnemies) == 0x000008, "Wrong alignment on HWAbility_Hades_A03_GetCascadedBlightedEnemies");
static_assert(sizeof(HWAbility_Hades_A03_GetCascadedBlightedEnemies) == 0x000018, "Wrong size on HWAbility_Hades_A03_GetCascadedBlightedEnemies");
static_assert(offsetof(HWAbility_Hades_A03_GetCascadedBlightedEnemies, OutBlightedEnemies) == 0x000000, "Member 'HWAbility_Hades_A03_GetCascadedBlightedEnemies::OutBlightedEnemies' has a wrong offset!");
static_assert(offsetof(HWAbility_Hades_A03_GetCascadedBlightedEnemies, HadesDetonateRadius) == 0x000010, "Member 'HWAbility_Hades_A03_GetCascadedBlightedEnemies::HadesDetonateRadius' has a wrong offset!");
static_assert(offsetof(HWAbility_Hades_A03_GetCascadedBlightedEnemies, EnemyDetonateRadius) == 0x000014, "Member 'HWAbility_Hades_A03_GetCascadedBlightedEnemies::EnemyDetonateRadius' has a wrong offset!");

// Function Hemingway.HWAbility_Hecate_PSV.OnAllyCommittedKill
// 0x0080 (0x0080 - 0x0000)
struct HWAbility_Hecate_PSV_OnAllyCommittedKill final
{
public:
	class AHWTeamState*                           Team;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageEventData                       KillEventData;                                     // 0x0010(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hecate_PSV_OnAllyCommittedKill) == 0x000008, "Wrong alignment on HWAbility_Hecate_PSV_OnAllyCommittedKill");
static_assert(sizeof(HWAbility_Hecate_PSV_OnAllyCommittedKill) == 0x000080, "Wrong size on HWAbility_Hecate_PSV_OnAllyCommittedKill");
static_assert(offsetof(HWAbility_Hecate_PSV_OnAllyCommittedKill, Team) == 0x000000, "Member 'HWAbility_Hecate_PSV_OnAllyCommittedKill::Team' has a wrong offset!");
static_assert(offsetof(HWAbility_Hecate_PSV_OnAllyCommittedKill, Player) == 0x000008, "Member 'HWAbility_Hecate_PSV_OnAllyCommittedKill::Player' has a wrong offset!");
static_assert(offsetof(HWAbility_Hecate_PSV_OnAllyCommittedKill, KillEventData) == 0x000010, "Member 'HWAbility_Hecate_PSV_OnAllyCommittedKill::KillEventData' has a wrong offset!");

// Function Hemingway.HWAbility_Hecate_PSV.OnAllyInteracted
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Hecate_PSV_OnAllyInteracted final
{
public:
	class AHWCharacter_Base*                      PlayerCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hecate_PSV_OnAllyInteracted) == 0x000008, "Wrong alignment on HWAbility_Hecate_PSV_OnAllyInteracted");
static_assert(sizeof(HWAbility_Hecate_PSV_OnAllyInteracted) == 0x000008, "Wrong size on HWAbility_Hecate_PSV_OnAllyInteracted");
static_assert(offsetof(HWAbility_Hecate_PSV_OnAllyInteracted, PlayerCharacter) == 0x000000, "Member 'HWAbility_Hecate_PSV_OnAllyInteracted::PlayerCharacter' has a wrong offset!");

// Function Hemingway.HWAbility_Hecate_PSV.OnHecateTeamUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Hecate_PSV_OnHecateTeamUpdated final
{
public:
	class AHWCharacterAbilitySystemActor*         AbilitySystemActor;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamState*                           NewTeamState;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hecate_PSV_OnHecateTeamUpdated) == 0x000008, "Wrong alignment on HWAbility_Hecate_PSV_OnHecateTeamUpdated");
static_assert(sizeof(HWAbility_Hecate_PSV_OnHecateTeamUpdated) == 0x000010, "Wrong size on HWAbility_Hecate_PSV_OnHecateTeamUpdated");
static_assert(offsetof(HWAbility_Hecate_PSV_OnHecateTeamUpdated, AbilitySystemActor) == 0x000000, "Member 'HWAbility_Hecate_PSV_OnHecateTeamUpdated::AbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWAbility_Hecate_PSV_OnHecateTeamUpdated, NewTeamState) == 0x000008, "Member 'HWAbility_Hecate_PSV_OnHecateTeamUpdated::NewTeamState' has a wrong offset!");

// Function Hemingway.HWAbility_Hecate_PSV.OnNewStructureSpawned
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Hecate_PSV_OnNewStructureSpawned final
{
public:
	class AHWBotFactory*                          factory;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      spawnedStructure;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hecate_PSV_OnNewStructureSpawned) == 0x000008, "Wrong alignment on HWAbility_Hecate_PSV_OnNewStructureSpawned");
static_assert(sizeof(HWAbility_Hecate_PSV_OnNewStructureSpawned) == 0x000010, "Wrong size on HWAbility_Hecate_PSV_OnNewStructureSpawned");
static_assert(offsetof(HWAbility_Hecate_PSV_OnNewStructureSpawned, factory) == 0x000000, "Member 'HWAbility_Hecate_PSV_OnNewStructureSpawned::factory' has a wrong offset!");
static_assert(offsetof(HWAbility_Hecate_PSV_OnNewStructureSpawned, spawnedStructure) == 0x000008, "Member 'HWAbility_Hecate_PSV_OnNewStructureSpawned::spawnedStructure' has a wrong offset!");

// Function Hemingway.HWAbility_Hecate_PSV.OnStructureDied
// 0x0018 (0x0018 - 0x0000)
struct HWAbility_Hecate_PSV_OnStructureDied final
{
public:
	class AHWBotFactory*                          BotFactory;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      Structure;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Killer;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hecate_PSV_OnStructureDied) == 0x000008, "Wrong alignment on HWAbility_Hecate_PSV_OnStructureDied");
static_assert(sizeof(HWAbility_Hecate_PSV_OnStructureDied) == 0x000018, "Wrong size on HWAbility_Hecate_PSV_OnStructureDied");
static_assert(offsetof(HWAbility_Hecate_PSV_OnStructureDied, BotFactory) == 0x000000, "Member 'HWAbility_Hecate_PSV_OnStructureDied::BotFactory' has a wrong offset!");
static_assert(offsetof(HWAbility_Hecate_PSV_OnStructureDied, Structure) == 0x000008, "Member 'HWAbility_Hecate_PSV_OnStructureDied::Structure' has a wrong offset!");
static_assert(offsetof(HWAbility_Hecate_PSV_OnStructureDied, Killer) == 0x000010, "Member 'HWAbility_Hecate_PSV_OnStructureDied::Killer' has a wrong offset!");

// Function Hemingway.HWAbility_Hecate_PSV.OnStructureInteracted
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Hecate_PSV_OnStructureInteracted final
{
public:
	class AHWCharacter_NPC*                       Structure;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWInteractable_Hecate_PSV*             Interactable;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hecate_PSV_OnStructureInteracted) == 0x000008, "Wrong alignment on HWAbility_Hecate_PSV_OnStructureInteracted");
static_assert(sizeof(HWAbility_Hecate_PSV_OnStructureInteracted) == 0x000010, "Wrong size on HWAbility_Hecate_PSV_OnStructureInteracted");
static_assert(offsetof(HWAbility_Hecate_PSV_OnStructureInteracted, Structure) == 0x000000, "Member 'HWAbility_Hecate_PSV_OnStructureInteracted::Structure' has a wrong offset!");
static_assert(offsetof(HWAbility_Hecate_PSV_OnStructureInteracted, Interactable) == 0x000008, "Member 'HWAbility_Hecate_PSV_OnStructureInteracted::Interactable' has a wrong offset!");

// Function Hemingway.HWAbility_Hecate_PSV.OnTeamStructuresUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Hecate_PSV_OnTeamStructuresUpdated final
{
public:
	class AHWTeamState*                           TeamState;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hecate_PSV_OnTeamStructuresUpdated) == 0x000008, "Wrong alignment on HWAbility_Hecate_PSV_OnTeamStructuresUpdated");
static_assert(sizeof(HWAbility_Hecate_PSV_OnTeamStructuresUpdated) == 0x000008, "Wrong size on HWAbility_Hecate_PSV_OnTeamStructuresUpdated");
static_assert(offsetof(HWAbility_Hecate_PSV_OnTeamStructuresUpdated, TeamState) == 0x000000, "Member 'HWAbility_Hecate_PSV_OnTeamStructuresUpdated::TeamState' has a wrong offset!");

// Function Hemingway.HWAbility_Hecate_PSV.RemoveTrackedStructure
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Hecate_PSV_RemoveTrackedStructure final
{
public:
	class AHWCharacter_Base*                      Structure;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Hecate_PSV_RemoveTrackedStructure) == 0x000008, "Wrong alignment on HWAbility_Hecate_PSV_RemoveTrackedStructure");
static_assert(sizeof(HWAbility_Hecate_PSV_RemoveTrackedStructure) == 0x000008, "Wrong size on HWAbility_Hecate_PSV_RemoveTrackedStructure");
static_assert(offsetof(HWAbility_Hecate_PSV_RemoveTrackedStructure, Structure) == 0x000000, "Member 'HWAbility_Hecate_PSV_RemoveTrackedStructure::Structure' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_HunBatz_Psv.AttemptToBeginConsume
// 0x00B8 (0x00B8 - 0x0000)
struct HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume final
{
public:
	struct FGameplayTagContainer                  EffectTags;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FDamageCalcInfo                        DamageCalcInfo;                                    // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bDamageImmune;                                     // 0x00B0(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume) == 0x000008, "Wrong alignment on HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume");
static_assert(sizeof(HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume) == 0x0000B8, "Wrong size on HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume");
static_assert(offsetof(HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume, EffectTags) == 0x000000, "Member 'HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume::EffectTags' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume, DamageCalcInfo) == 0x000020, "Member 'HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume::DamageCalcInfo' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume, bDamageImmune) == 0x0000B0, "Member 'HWGameplayAbility_HunBatz_Psv_AttemptToBeginConsume::bDamageImmune' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_HunBatz_Psv.AttemptToEndConsume
// 0x0158 (0x0158 - 0x0000)
struct HWGameplayAbility_HunBatz_Psv_AttemptToEndConsume final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDamageEventData                       DamageEventData;                                   // 0x00E8(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_HunBatz_Psv_AttemptToEndConsume) == 0x000008, "Wrong alignment on HWGameplayAbility_HunBatz_Psv_AttemptToEndConsume");
static_assert(sizeof(HWGameplayAbility_HunBatz_Psv_AttemptToEndConsume) == 0x000158, "Wrong size on HWGameplayAbility_HunBatz_Psv_AttemptToEndConsume");
static_assert(offsetof(HWGameplayAbility_HunBatz_Psv_AttemptToEndConsume, HitResult) == 0x000000, "Member 'HWGameplayAbility_HunBatz_Psv_AttemptToEndConsume::HitResult' has a wrong offset!");
static_assert(offsetof(HWGameplayAbility_HunBatz_Psv_AttemptToEndConsume, DamageEventData) == 0x0000E8, "Member 'HWGameplayAbility_HunBatz_Psv_AttemptToEndConsume::DamageEventData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_HunBatz_Psv.OnAbilityCommited
// 0x0008 (0x0008 - 0x0000)
struct HWGameplayAbility_HunBatz_Psv_OnAbilityCommited final
{
public:
	class UGameplayAbility*                       Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_HunBatz_Psv_OnAbilityCommited) == 0x000008, "Wrong alignment on HWGameplayAbility_HunBatz_Psv_OnAbilityCommited");
static_assert(sizeof(HWGameplayAbility_HunBatz_Psv_OnAbilityCommited) == 0x000008, "Wrong size on HWGameplayAbility_HunBatz_Psv_OnAbilityCommited");
static_assert(offsetof(HWGameplayAbility_HunBatz_Psv_OnAbilityCommited, Ability) == 0x000000, "Member 'HWGameplayAbility_HunBatz_Psv_OnAbilityCommited::Ability' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_HunBatz_Psv.OnAvatarDeath
// 0x0070 (0x0070 - 0x0000)
struct HWGameplayAbility_HunBatz_Psv_OnAvatarDeath final
{
public:
	struct FDamageEventData                       DeathEventData;                                    // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_HunBatz_Psv_OnAvatarDeath) == 0x000008, "Wrong alignment on HWGameplayAbility_HunBatz_Psv_OnAvatarDeath");
static_assert(sizeof(HWGameplayAbility_HunBatz_Psv_OnAvatarDeath) == 0x000070, "Wrong size on HWGameplayAbility_HunBatz_Psv_OnAvatarDeath");
static_assert(offsetof(HWGameplayAbility_HunBatz_Psv_OnAvatarDeath, DeathEventData) == 0x000000, "Member 'HWGameplayAbility_HunBatz_Psv_OnAvatarDeath::DeathEventData' has a wrong offset!");

// Function Hemingway.HWGameplayAbility_HunBatz_Psv.ValidTriggerSource
// 0x0001 (0x0001 - 0x0000)
struct HWGameplayAbility_HunBatz_Psv_ValidTriggerSource final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameplayAbility_HunBatz_Psv_ValidTriggerSource) == 0x000001, "Wrong alignment on HWGameplayAbility_HunBatz_Psv_ValidTriggerSource");
static_assert(sizeof(HWGameplayAbility_HunBatz_Psv_ValidTriggerSource) == 0x000001, "Wrong size on HWGameplayAbility_HunBatz_Psv_ValidTriggerSource");
static_assert(offsetof(HWGameplayAbility_HunBatz_Psv_ValidTriggerSource, ReturnValue) == 0x000000, "Member 'HWGameplayAbility_HunBatz_Psv_ValidTriggerSource::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Izanami_Passive.CalculateDeservedStackCountBasedOnCurrentHealth
// 0x0004 (0x0004 - 0x0000)
struct HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnCurrentHealth final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnCurrentHealth) == 0x000004, "Wrong alignment on HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnCurrentHealth");
static_assert(sizeof(HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnCurrentHealth) == 0x000004, "Wrong size on HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnCurrentHealth");
static_assert(offsetof(HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnCurrentHealth, ReturnValue) == 0x000000, "Member 'HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnCurrentHealth::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Izanami_Passive.CalculateDeservedStackCountBasedOnRecentDamage
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnRecentDamage final
{
public:
	float                                         TotalRecentDamage;                                 // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnRecentDamage) == 0x000004, "Wrong alignment on HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnRecentDamage");
static_assert(sizeof(HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnRecentDamage) == 0x000008, "Wrong size on HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnRecentDamage");
static_assert(offsetof(HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnRecentDamage, TotalRecentDamage) == 0x000000, "Member 'HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnRecentDamage::TotalRecentDamage' has a wrong offset!");
static_assert(offsetof(HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnRecentDamage, ReturnValue) == 0x000004, "Member 'HWAbility_Izanami_Passive_CalculateDeservedStackCountBasedOnRecentDamage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Izanami_Passive.OnDamageReceived
// 0x0070 (0x0070 - 0x0000)
struct HWAbility_Izanami_Passive_OnDamageReceived final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Izanami_Passive_OnDamageReceived) == 0x000008, "Wrong alignment on HWAbility_Izanami_Passive_OnDamageReceived");
static_assert(sizeof(HWAbility_Izanami_Passive_OnDamageReceived) == 0x000070, "Wrong size on HWAbility_Izanami_Passive_OnDamageReceived");
static_assert(offsetof(HWAbility_Izanami_Passive_OnDamageReceived, DamageEventData) == 0x000000, "Member 'HWAbility_Izanami_Passive_OnDamageReceived::DamageEventData' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Mordred.OnRep_Wrath
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Mordred_OnRep_Wrath final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Mordred_OnRep_Wrath) == 0x000008, "Wrong alignment on HWAttributeSet_Mordred_OnRep_Wrath");
static_assert(sizeof(HWAttributeSet_Mordred_OnRep_Wrath) == 0x000010, "Wrong size on HWAttributeSet_Mordred_OnRep_Wrath");
static_assert(offsetof(HWAttributeSet_Mordred_OnRep_Wrath, OldValue) == 0x000000, "Member 'HWAttributeSet_Mordred_OnRep_Wrath::OldValue' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Mordred.OnRep_WrathPerTime
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Mordred_OnRep_WrathPerTime final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Mordred_OnRep_WrathPerTime) == 0x000008, "Wrong alignment on HWAttributeSet_Mordred_OnRep_WrathPerTime");
static_assert(sizeof(HWAttributeSet_Mordred_OnRep_WrathPerTime) == 0x000010, "Wrong size on HWAttributeSet_Mordred_OnRep_WrathPerTime");
static_assert(offsetof(HWAttributeSet_Mordred_OnRep_WrathPerTime, OldValue) == 0x000000, "Member 'HWAttributeSet_Mordred_OnRep_WrathPerTime::OldValue' has a wrong offset!");

// Function Hemingway.HWAbility_Morrigan_Item_Changeling.GetChangelingTargetCharacterItem
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Morrigan_Item_Changeling_GetChangelingTargetCharacterItem final
{
public:
	const class UHWCharacterItem*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Morrigan_Item_Changeling_GetChangelingTargetCharacterItem) == 0x000008, "Wrong alignment on HWAbility_Morrigan_Item_Changeling_GetChangelingTargetCharacterItem");
static_assert(sizeof(HWAbility_Morrigan_Item_Changeling_GetChangelingTargetCharacterItem) == 0x000008, "Wrong size on HWAbility_Morrigan_Item_Changeling_GetChangelingTargetCharacterItem");
static_assert(offsetof(HWAbility_Morrigan_Item_Changeling_GetChangelingTargetCharacterItem, ReturnValue) == 0x000000, "Member 'HWAbility_Morrigan_Item_Changeling_GetChangelingTargetCharacterItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Morrigan_Item_Changeling.HasValidChangelingTarget
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Morrigan_Item_Changeling_HasValidChangelingTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Morrigan_Item_Changeling_HasValidChangelingTarget) == 0x000001, "Wrong alignment on HWAbility_Morrigan_Item_Changeling_HasValidChangelingTarget");
static_assert(sizeof(HWAbility_Morrigan_Item_Changeling_HasValidChangelingTarget) == 0x000001, "Wrong size on HWAbility_Morrigan_Item_Changeling_HasValidChangelingTarget");
static_assert(offsetof(HWAbility_Morrigan_Item_Changeling_HasValidChangelingTarget, ReturnValue) == 0x000000, "Member 'HWAbility_Morrigan_Item_Changeling_HasValidChangelingTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Mulan_A03_GrappleListener.OnGrappleTargetTweenEnded
// 0x0018 (0x0018 - 0x0000)
struct HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      GrappleTarget;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded) == 0x000008, "Wrong alignment on HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded");
static_assert(sizeof(HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded) == 0x000018, "Wrong size on HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded, TweenInstance) == 0x000000, "Member 'HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded, GrappleTarget) == 0x000008, "Member 'HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded::GrappleTarget' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded, EndTweenReason) == 0x000010, "Member 'HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenEnded::EndTweenReason' has a wrong offset!");

// Function Hemingway.HWAbility_Mulan_A03_GrappleListener.OnGrappleTargetTweenStarted
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenStarted final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      GrappleTarget;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenStarted) == 0x000008, "Wrong alignment on HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenStarted");
static_assert(sizeof(HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenStarted) == 0x000010, "Wrong size on HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenStarted");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenStarted, TweenInstance) == 0x000000, "Member 'HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenStarted::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenStarted, GrappleTarget) == 0x000008, "Member 'HWAbility_Mulan_A03_GrappleListener_OnGrappleTargetTweenStarted::GrappleTarget' has a wrong offset!");

// Function Hemingway.HWAbility_Mulan_A03_GrappleListener.OnMulanGrappleTweenEnded
// 0x0018 (0x0018 - 0x0000)
struct HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      Mulan;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWEndTweenReason                             EndTweenReason;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded) == 0x000008, "Wrong alignment on HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded");
static_assert(sizeof(HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded) == 0x000018, "Wrong size on HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded, TweenInstance) == 0x000000, "Member 'HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded, Mulan) == 0x000008, "Member 'HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded::Mulan' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded, EndTweenReason) == 0x000010, "Member 'HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenEnded::EndTweenReason' has a wrong offset!");

// Function Hemingway.HWAbility_Mulan_A03_GrappleListener.OnMulanGrappleTweenStarted
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenStarted final
{
public:
	class UHWGameplayTween*                       TweenInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacter_Base*                      Mulan;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenStarted) == 0x000008, "Wrong alignment on HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenStarted");
static_assert(sizeof(HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenStarted) == 0x000010, "Wrong size on HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenStarted");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenStarted, TweenInstance) == 0x000000, "Member 'HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenStarted::TweenInstance' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenStarted, Mulan) == 0x000008, "Member 'HWAbility_Mulan_A03_GrappleListener_OnMulanGrappleTweenStarted::Mulan' has a wrong offset!");

// Function Hemingway.HWAbility_Mulan_A03_GrappleListener.CalcGrappleDistance
// 0x0108 (0x0108 - 0x0000)
struct HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance final
{
public:
	const class AHWCharacter_Base*                Mulan;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWMulanGrappleInfo                    GrappleInfo;                                       // 0x0008(0x00F8)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0100(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance) == 0x000008, "Wrong alignment on HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance");
static_assert(sizeof(HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance) == 0x000108, "Wrong size on HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance, Mulan) == 0x000000, "Member 'HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance::Mulan' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance, GrappleInfo) == 0x000008, "Member 'HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance::GrappleInfo' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance, ReturnValue) == 0x000100, "Member 'HWAbility_Mulan_A03_GrappleListener_CalcGrappleDistance::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Mulan_A03_GrappleListener.CanGrappleToTarget
// 0x0100 (0x0100 - 0x0000)
struct HWAbility_Mulan_A03_GrappleListener_CanGrappleToTarget final
{
public:
	struct FHWMulanGrappleInfo                    Info;                                              // 0x0000(0x00F8)(ConstParm, Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Mulan_A03_GrappleListener_CanGrappleToTarget) == 0x000008, "Wrong alignment on HWAbility_Mulan_A03_GrappleListener_CanGrappleToTarget");
static_assert(sizeof(HWAbility_Mulan_A03_GrappleListener_CanGrappleToTarget) == 0x000100, "Wrong size on HWAbility_Mulan_A03_GrappleListener_CanGrappleToTarget");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_CanGrappleToTarget, Info) == 0x000000, "Member 'HWAbility_Mulan_A03_GrappleListener_CanGrappleToTarget::Info' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_CanGrappleToTarget, ReturnValue) == 0x0000F8, "Member 'HWAbility_Mulan_A03_GrappleListener_CanGrappleToTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Mulan_A03_GrappleListener.CanMulanGrapple
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Mulan_A03_GrappleListener_CanMulanGrapple final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Mulan_A03_GrappleListener_CanMulanGrapple) == 0x000001, "Wrong alignment on HWAbility_Mulan_A03_GrappleListener_CanMulanGrapple");
static_assert(sizeof(HWAbility_Mulan_A03_GrappleListener_CanMulanGrapple) == 0x000001, "Wrong size on HWAbility_Mulan_A03_GrappleListener_CanMulanGrapple");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_CanMulanGrapple, ReturnValue) == 0x000000, "Member 'HWAbility_Mulan_A03_GrappleListener_CanMulanGrapple::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Mulan_A03_GrappleListener.FindValidGrappleLoc
// 0x0078 (0x0078 - 0x0000)
struct HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc final
{
public:
	const class AHWCharacter_Base*                TweenCharacter;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLoc;                                          // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialEndLoc;                                     // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TweenDirection;                                    // 0x0038(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0050(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWallGrapple;                                    // 0x0054(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OutValidLocation;                                  // 0x0058(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc) == 0x000008, "Wrong alignment on HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc");
static_assert(sizeof(HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc) == 0x000078, "Wrong size on HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc, TweenCharacter) == 0x000000, "Member 'HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc::TweenCharacter' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc, StartLoc) == 0x000008, "Member 'HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc::StartLoc' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc, InitialEndLoc) == 0x000020, "Member 'HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc::InitialEndLoc' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc, TweenDirection) == 0x000038, "Member 'HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc::TweenDirection' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc, Range) == 0x000050, "Member 'HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc::Range' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc, bIsWallGrapple) == 0x000054, "Member 'HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc::bIsWallGrapple' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc, OutValidLocation) == 0x000058, "Member 'HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc::OutValidLocation' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc, ReturnValue) == 0x000070, "Member 'HWAbility_Mulan_A03_GrappleListener_FindValidGrappleLoc::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Mulan_A03_GrappleListener.IsMulanGrappling
// 0x0001 (0x0001 - 0x0000)
struct HWAbility_Mulan_A03_GrappleListener_IsMulanGrappling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Mulan_A03_GrappleListener_IsMulanGrappling) == 0x000001, "Wrong alignment on HWAbility_Mulan_A03_GrappleListener_IsMulanGrappling");
static_assert(sizeof(HWAbility_Mulan_A03_GrappleListener_IsMulanGrappling) == 0x000001, "Wrong size on HWAbility_Mulan_A03_GrappleListener_IsMulanGrappling");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_IsMulanGrappling, ReturnValue) == 0x000000, "Member 'HWAbility_Mulan_A03_GrappleListener_IsMulanGrappling::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Mulan_A03_GrappleListener.IsValidGrappleWall
// 0x0010 (0x0010 - 0x0000)
struct HWAbility_Mulan_A03_GrappleListener_IsValidGrappleWall final
{
public:
	const class AActor*                           HitActor;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWAbility_Mulan_A03_GrappleListener_IsValidGrappleWall) == 0x000008, "Wrong alignment on HWAbility_Mulan_A03_GrappleListener_IsValidGrappleWall");
static_assert(sizeof(HWAbility_Mulan_A03_GrappleListener_IsValidGrappleWall) == 0x000010, "Wrong size on HWAbility_Mulan_A03_GrappleListener_IsValidGrappleWall");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_IsValidGrappleWall, HitActor) == 0x000000, "Member 'HWAbility_Mulan_A03_GrappleListener_IsValidGrappleWall::HitActor' has a wrong offset!");
static_assert(offsetof(HWAbility_Mulan_A03_GrappleListener_IsValidGrappleWall, ReturnValue) == 0x000008, "Member 'HWAbility_Mulan_A03_GrappleListener_IsValidGrappleWall::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Mulan_Evolution.OnDealtDamaged
// 0x0070 (0x0070 - 0x0000)
struct HWEquipmentComponent_Mulan_Evolution_OnDealtDamaged final
{
public:
	struct FDamageEventData                       DamageEventData;                                   // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Mulan_Evolution_OnDealtDamaged) == 0x000008, "Wrong alignment on HWEquipmentComponent_Mulan_Evolution_OnDealtDamaged");
static_assert(sizeof(HWEquipmentComponent_Mulan_Evolution_OnDealtDamaged) == 0x000070, "Wrong size on HWEquipmentComponent_Mulan_Evolution_OnDealtDamaged");
static_assert(offsetof(HWEquipmentComponent_Mulan_Evolution_OnDealtDamaged, DamageEventData) == 0x000000, "Member 'HWEquipmentComponent_Mulan_Evolution_OnDealtDamaged::DamageEventData' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Mulan_Evolution.SetEvolution
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Mulan_Evolution_SetEvolution final
{
public:
	EHWMulanEvolutionState                        Evolution;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Mulan_Evolution_SetEvolution) == 0x000001, "Wrong alignment on HWEquipmentComponent_Mulan_Evolution_SetEvolution");
static_assert(sizeof(HWEquipmentComponent_Mulan_Evolution_SetEvolution) == 0x000001, "Wrong size on HWEquipmentComponent_Mulan_Evolution_SetEvolution");
static_assert(offsetof(HWEquipmentComponent_Mulan_Evolution_SetEvolution, Evolution) == 0x000000, "Member 'HWEquipmentComponent_Mulan_Evolution_SetEvolution::Evolution' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Mulan_Evolution.GetCurrentEvolutionXP
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Mulan_Evolution_GetCurrentEvolutionXP final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Mulan_Evolution_GetCurrentEvolutionXP) == 0x000004, "Wrong alignment on HWEquipmentComponent_Mulan_Evolution_GetCurrentEvolutionXP");
static_assert(sizeof(HWEquipmentComponent_Mulan_Evolution_GetCurrentEvolutionXP) == 0x000004, "Wrong size on HWEquipmentComponent_Mulan_Evolution_GetCurrentEvolutionXP");
static_assert(offsetof(HWEquipmentComponent_Mulan_Evolution_GetCurrentEvolutionXP, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Mulan_Evolution_GetCurrentEvolutionXP::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Mulan_Evolution.GetEvolutionState
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentComponent_Mulan_Evolution_GetEvolutionState final
{
public:
	EHWMulanEvolutionState                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Mulan_Evolution_GetEvolutionState) == 0x000001, "Wrong alignment on HWEquipmentComponent_Mulan_Evolution_GetEvolutionState");
static_assert(sizeof(HWEquipmentComponent_Mulan_Evolution_GetEvolutionState) == 0x000001, "Wrong size on HWEquipmentComponent_Mulan_Evolution_GetEvolutionState");
static_assert(offsetof(HWEquipmentComponent_Mulan_Evolution_GetEvolutionState, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Mulan_Evolution_GetEvolutionState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Mulan_Evolution.GetEvolutionXPThreshold
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentComponent_Mulan_Evolution_GetEvolutionXPThreshold final
{
public:
	EHWMulanEvolutionState                        EvolveState;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Mulan_Evolution_GetEvolutionXPThreshold) == 0x000004, "Wrong alignment on HWEquipmentComponent_Mulan_Evolution_GetEvolutionXPThreshold");
static_assert(sizeof(HWEquipmentComponent_Mulan_Evolution_GetEvolutionXPThreshold) == 0x000008, "Wrong size on HWEquipmentComponent_Mulan_Evolution_GetEvolutionXPThreshold");
static_assert(offsetof(HWEquipmentComponent_Mulan_Evolution_GetEvolutionXPThreshold, EvolveState) == 0x000000, "Member 'HWEquipmentComponent_Mulan_Evolution_GetEvolutionXPThreshold::EvolveState' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_Mulan_Evolution_GetEvolutionXPThreshold, ReturnValue) == 0x000004, "Member 'HWEquipmentComponent_Mulan_Evolution_GetEvolutionXPThreshold::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Mulan_Evolution.GetXPNeededForNextEvolutionThreshold
// 0x0004 (0x0004 - 0x0000)
struct HWEquipmentComponent_Mulan_Evolution_GetXPNeededForNextEvolutionThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Mulan_Evolution_GetXPNeededForNextEvolutionThreshold) == 0x000004, "Wrong alignment on HWEquipmentComponent_Mulan_Evolution_GetXPNeededForNextEvolutionThreshold");
static_assert(sizeof(HWEquipmentComponent_Mulan_Evolution_GetXPNeededForNextEvolutionThreshold) == 0x000004, "Wrong size on HWEquipmentComponent_Mulan_Evolution_GetXPNeededForNextEvolutionThreshold");
static_assert(offsetof(HWEquipmentComponent_Mulan_Evolution_GetXPNeededForNextEvolutionThreshold, ReturnValue) == 0x000000, "Member 'HWEquipmentComponent_Mulan_Evolution_GetXPNeededForNextEvolutionThreshold::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEquipmentComponent_Mulan_Evolution.IsInEvolution
// 0x0002 (0x0002 - 0x0000)
struct HWEquipmentComponent_Mulan_Evolution_IsInEvolution final
{
public:
	EHWMulanEvolutionState                        Evolution;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentComponent_Mulan_Evolution_IsInEvolution) == 0x000001, "Wrong alignment on HWEquipmentComponent_Mulan_Evolution_IsInEvolution");
static_assert(sizeof(HWEquipmentComponent_Mulan_Evolution_IsInEvolution) == 0x000002, "Wrong size on HWEquipmentComponent_Mulan_Evolution_IsInEvolution");
static_assert(offsetof(HWEquipmentComponent_Mulan_Evolution_IsInEvolution, Evolution) == 0x000000, "Member 'HWEquipmentComponent_Mulan_Evolution_IsInEvolution::Evolution' has a wrong offset!");
static_assert(offsetof(HWEquipmentComponent_Mulan_Evolution_IsInEvolution, ReturnValue) == 0x000001, "Member 'HWEquipmentComponent_Mulan_Evolution_IsInEvolution::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCharacter_NuWa_ClaySoldier.ActivateLocalTargetingVFX
// 0x0001 (0x0001 - 0x0000)
struct HWCharacter_NuWa_ClaySoldier_ActivateLocalTargetingVFX final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCharacter_NuWa_ClaySoldier_ActivateLocalTargetingVFX) == 0x000001, "Wrong alignment on HWCharacter_NuWa_ClaySoldier_ActivateLocalTargetingVFX");
static_assert(sizeof(HWCharacter_NuWa_ClaySoldier_ActivateLocalTargetingVFX) == 0x000001, "Wrong size on HWCharacter_NuWa_ClaySoldier_ActivateLocalTargetingVFX");
static_assert(offsetof(HWCharacter_NuWa_ClaySoldier_ActivateLocalTargetingVFX, bEnable) == 0x000000, "Member 'HWCharacter_NuWa_ClaySoldier_ActivateLocalTargetingVFX::bEnable' has a wrong offset!");

// Function Hemingway.HWAttributeSet_Sol.OnRep_Heat
// 0x0010 (0x0010 - 0x0000)
struct HWAttributeSet_Sol_OnRep_Heat final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAttributeSet_Sol_OnRep_Heat) == 0x000008, "Wrong alignment on HWAttributeSet_Sol_OnRep_Heat");
static_assert(sizeof(HWAttributeSet_Sol_OnRep_Heat) == 0x000010, "Wrong size on HWAttributeSet_Sol_OnRep_Heat");
static_assert(offsetof(HWAttributeSet_Sol_OnRep_Heat, OldValue) == 0x000000, "Member 'HWAttributeSet_Sol_OnRep_Heat::OldValue' has a wrong offset!");

// Function Hemingway.HWAbilityTask_Thantos_A02_MarkedMovementSpeed.MarkedMovementSpeedTask
// 0x0018 (0x0018 - 0x0000)
struct HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAbilityTask_Thantos_A02_MarkedMovementSpeed* ReturnValue;                               // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask) == 0x000008, "Wrong alignment on HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask");
static_assert(sizeof(HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask) == 0x000018, "Wrong size on HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask");
static_assert(offsetof(HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask, OwningAbility) == 0x000000, "Member 'HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask::OwningAbility' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask, TaskInstanceName) == 0x000008, "Member 'HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask, ReturnValue) == 0x000010, "Member 'HWAbilityTask_Thantos_A02_MarkedMovementSpeed_MarkedMovementSpeedTask::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Thanatos_A02_MarkedMovementSpeed.GetExecuteThresholdByAbilityLevel
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Thanatos_A02_MarkedMovementSpeed_GetExecuteThresholdByAbilityLevel final
{
public:
	int32                                         AbilityLevel;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Thanatos_A02_MarkedMovementSpeed_GetExecuteThresholdByAbilityLevel) == 0x000004, "Wrong alignment on HWAbility_Thanatos_A02_MarkedMovementSpeed_GetExecuteThresholdByAbilityLevel");
static_assert(sizeof(HWAbility_Thanatos_A02_MarkedMovementSpeed_GetExecuteThresholdByAbilityLevel) == 0x000008, "Wrong size on HWAbility_Thanatos_A02_MarkedMovementSpeed_GetExecuteThresholdByAbilityLevel");
static_assert(offsetof(HWAbility_Thanatos_A02_MarkedMovementSpeed_GetExecuteThresholdByAbilityLevel, AbilityLevel) == 0x000000, "Member 'HWAbility_Thanatos_A02_MarkedMovementSpeed_GetExecuteThresholdByAbilityLevel::AbilityLevel' has a wrong offset!");
static_assert(offsetof(HWAbility_Thanatos_A02_MarkedMovementSpeed_GetExecuteThresholdByAbilityLevel, ReturnValue) == 0x000004, "Member 'HWAbility_Thanatos_A02_MarkedMovementSpeed_GetExecuteThresholdByAbilityLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAbility_Thanatos_A02_MarkedMovementSpeed.GetMoveSpeedBonusByAbilityLevel
// 0x0008 (0x0008 - 0x0000)
struct HWAbility_Thanatos_A02_MarkedMovementSpeed_GetMoveSpeedBonusByAbilityLevel final
{
public:
	int32                                         AbilityLevel;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAbility_Thanatos_A02_MarkedMovementSpeed_GetMoveSpeedBonusByAbilityLevel) == 0x000004, "Wrong alignment on HWAbility_Thanatos_A02_MarkedMovementSpeed_GetMoveSpeedBonusByAbilityLevel");
static_assert(sizeof(HWAbility_Thanatos_A02_MarkedMovementSpeed_GetMoveSpeedBonusByAbilityLevel) == 0x000008, "Wrong size on HWAbility_Thanatos_A02_MarkedMovementSpeed_GetMoveSpeedBonusByAbilityLevel");
static_assert(offsetof(HWAbility_Thanatos_A02_MarkedMovementSpeed_GetMoveSpeedBonusByAbilityLevel, AbilityLevel) == 0x000000, "Member 'HWAbility_Thanatos_A02_MarkedMovementSpeed_GetMoveSpeedBonusByAbilityLevel::AbilityLevel' has a wrong offset!");
static_assert(offsetof(HWAbility_Thanatos_A02_MarkedMovementSpeed_GetMoveSpeedBonusByAbilityLevel, ReturnValue) == 0x000004, "Member 'HWAbility_Thanatos_A02_MarkedMovementSpeed_GetMoveSpeedBonusByAbilityLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Animation.CalculateBoundsSkelMesh
// 0x0040 (0x0040 - 0x0000)
struct HWLibrary_Animation_CalculateBoundsSkelMesh final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       ReturnValue;                                       // 0x0008(0x0038)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Animation_CalculateBoundsSkelMesh) == 0x000008, "Wrong alignment on HWLibrary_Animation_CalculateBoundsSkelMesh");
static_assert(sizeof(HWLibrary_Animation_CalculateBoundsSkelMesh) == 0x000040, "Wrong size on HWLibrary_Animation_CalculateBoundsSkelMesh");
static_assert(offsetof(HWLibrary_Animation_CalculateBoundsSkelMesh, SkeletalMeshComponent) == 0x000000, "Member 'HWLibrary_Animation_CalculateBoundsSkelMesh::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(HWLibrary_Animation_CalculateBoundsSkelMesh, ReturnValue) == 0x000008, "Member 'HWLibrary_Animation_CalculateBoundsSkelMesh::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Animation.CalculateGodActorBounds
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_Animation_CalculateGodActorBounds final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Animation_CalculateGodActorBounds) == 0x000008, "Wrong alignment on HWLibrary_Animation_CalculateGodActorBounds");
static_assert(sizeof(HWLibrary_Animation_CalculateGodActorBounds) == 0x000038, "Wrong size on HWLibrary_Animation_CalculateGodActorBounds");
static_assert(offsetof(HWLibrary_Animation_CalculateGodActorBounds, Actor) == 0x000000, "Member 'HWLibrary_Animation_CalculateGodActorBounds::Actor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Animation_CalculateGodActorBounds, Origin) == 0x000008, "Member 'HWLibrary_Animation_CalculateGodActorBounds::Origin' has a wrong offset!");
static_assert(offsetof(HWLibrary_Animation_CalculateGodActorBounds, BoxExtent) == 0x000020, "Member 'HWLibrary_Animation_CalculateGodActorBounds::BoxExtent' has a wrong offset!");

// Function Hemingway.HWLibrary_Animation.CalculateLocationBetweenActorsWithOffset
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset final
{
public:
	class AActor*                                 FiringActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalOffset;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset) == 0x000008, "Wrong alignment on HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset");
static_assert(sizeof(HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset) == 0x000030, "Wrong size on HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset");
static_assert(offsetof(HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset, FiringActor) == 0x000000, "Member 'HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset::FiringActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset, TargetActor) == 0x000008, "Member 'HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset::TargetActor' has a wrong offset!");
static_assert(offsetof(HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset, NormalOffset) == 0x000010, "Member 'HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset::NormalOffset' has a wrong offset!");
static_assert(offsetof(HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset, ZOffset) == 0x000014, "Member 'HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset::ZOffset' has a wrong offset!");
static_assert(offsetof(HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset, ReturnValue) == 0x000018, "Member 'HWLibrary_Animation_CalculateLocationBetweenActorsWithOffset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_Animation.ModifyMontageBlendSettings
// 0x0050 (0x0050 - 0x0000)
struct HWLibrary_Animation_ModifyMontageBlendSettings final
{
public:
	class UAnimMontage*                           OriginalMontage;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMontageBlendSettings                  BlendInSettings;                                   // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FMontageBlendSettings                  BlendOutSettings;                                  // 0x0028(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_Animation_ModifyMontageBlendSettings) == 0x000008, "Wrong alignment on HWLibrary_Animation_ModifyMontageBlendSettings");
static_assert(sizeof(HWLibrary_Animation_ModifyMontageBlendSettings) == 0x000050, "Wrong size on HWLibrary_Animation_ModifyMontageBlendSettings");
static_assert(offsetof(HWLibrary_Animation_ModifyMontageBlendSettings, OriginalMontage) == 0x000000, "Member 'HWLibrary_Animation_ModifyMontageBlendSettings::OriginalMontage' has a wrong offset!");
static_assert(offsetof(HWLibrary_Animation_ModifyMontageBlendSettings, BlendInSettings) == 0x000008, "Member 'HWLibrary_Animation_ModifyMontageBlendSettings::BlendInSettings' has a wrong offset!");
static_assert(offsetof(HWLibrary_Animation_ModifyMontageBlendSettings, BlendOutSettings) == 0x000028, "Member 'HWLibrary_Animation_ModifyMontageBlendSettings::BlendOutSettings' has a wrong offset!");
static_assert(offsetof(HWLibrary_Animation_ModifyMontageBlendSettings, ReturnValue) == 0x000048, "Member 'HWLibrary_Animation_ModifyMontageBlendSettings::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTagManager.GetActivatedRevealRulesForTags
// 0x0070 (0x0070 - 0x0000)
struct HWTagManager_GetActivatedRevealRulesForTags final
{
public:
	struct FGameplayTagContainer                  ApplicableRevealRuleTags;                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagTriggers;                                       // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class AActor*                           SelfActor;                                         // 0x0040(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           ObservingActor;                                    // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OutActivatedRevealRuleTags;                        // 0x0050(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTagManager_GetActivatedRevealRulesForTags) == 0x000008, "Wrong alignment on HWTagManager_GetActivatedRevealRulesForTags");
static_assert(sizeof(HWTagManager_GetActivatedRevealRulesForTags) == 0x000070, "Wrong size on HWTagManager_GetActivatedRevealRulesForTags");
static_assert(offsetof(HWTagManager_GetActivatedRevealRulesForTags, ApplicableRevealRuleTags) == 0x000000, "Member 'HWTagManager_GetActivatedRevealRulesForTags::ApplicableRevealRuleTags' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetActivatedRevealRulesForTags, TagTriggers) == 0x000020, "Member 'HWTagManager_GetActivatedRevealRulesForTags::TagTriggers' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetActivatedRevealRulesForTags, SelfActor) == 0x000040, "Member 'HWTagManager_GetActivatedRevealRulesForTags::SelfActor' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetActivatedRevealRulesForTags, ObservingActor) == 0x000048, "Member 'HWTagManager_GetActivatedRevealRulesForTags::ObservingActor' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetActivatedRevealRulesForTags, OutActivatedRevealRuleTags) == 0x000050, "Member 'HWTagManager_GetActivatedRevealRulesForTags::OutActivatedRevealRuleTags' has a wrong offset!");

// Function Hemingway.HWTagManager.GetActivationBlockedTagsBasedOnAbilityTypes
// 0x0040 (0x0040 - 0x0000)
struct HWTagManager_GetActivationBlockedTagsBasedOnAbilityTypes final
{
public:
	struct FGameplayTagContainer                  AbilityTypeTags;                                   // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OutActivationBlockedTags;                          // 0x0020(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTagManager_GetActivationBlockedTagsBasedOnAbilityTypes) == 0x000008, "Wrong alignment on HWTagManager_GetActivationBlockedTagsBasedOnAbilityTypes");
static_assert(sizeof(HWTagManager_GetActivationBlockedTagsBasedOnAbilityTypes) == 0x000040, "Wrong size on HWTagManager_GetActivationBlockedTagsBasedOnAbilityTypes");
static_assert(offsetof(HWTagManager_GetActivationBlockedTagsBasedOnAbilityTypes, AbilityTypeTags) == 0x000000, "Member 'HWTagManager_GetActivationBlockedTagsBasedOnAbilityTypes::AbilityTypeTags' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetActivationBlockedTagsBasedOnAbilityTypes, OutActivationBlockedTags) == 0x000020, "Member 'HWTagManager_GetActivationBlockedTagsBasedOnAbilityTypes::OutActivationBlockedTags' has a wrong offset!");

// Function Hemingway.HWTagManager.GetAllowedEquipmentForSlot
// 0x0028 (0x0028 - 0x0000)
struct HWTagManager_GetAllowedEquipmentForSlot final
{
public:
	struct FGameplayTag                           SlotType;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OutAllowEquipmentTypes;                            // 0x0008(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTagManager_GetAllowedEquipmentForSlot) == 0x000008, "Wrong alignment on HWTagManager_GetAllowedEquipmentForSlot");
static_assert(sizeof(HWTagManager_GetAllowedEquipmentForSlot) == 0x000028, "Wrong size on HWTagManager_GetAllowedEquipmentForSlot");
static_assert(offsetof(HWTagManager_GetAllowedEquipmentForSlot, SlotType) == 0x000000, "Member 'HWTagManager_GetAllowedEquipmentForSlot::SlotType' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetAllowedEquipmentForSlot, OutAllowEquipmentTypes) == 0x000008, "Member 'HWTagManager_GetAllowedEquipmentForSlot::OutAllowEquipmentTypes' has a wrong offset!");

// Function Hemingway.HWTagManager.GetAllowedSlotsForEquipmentType
// 0x0028 (0x0028 - 0x0000)
struct HWTagManager_GetAllowedSlotsForEquipmentType final
{
public:
	struct FGameplayTag                           EquipmentType;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OutAllowSlotTypes;                                 // 0x0008(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTagManager_GetAllowedSlotsForEquipmentType) == 0x000008, "Wrong alignment on HWTagManager_GetAllowedSlotsForEquipmentType");
static_assert(sizeof(HWTagManager_GetAllowedSlotsForEquipmentType) == 0x000028, "Wrong size on HWTagManager_GetAllowedSlotsForEquipmentType");
static_assert(offsetof(HWTagManager_GetAllowedSlotsForEquipmentType, EquipmentType) == 0x000000, "Member 'HWTagManager_GetAllowedSlotsForEquipmentType::EquipmentType' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetAllowedSlotsForEquipmentType, OutAllowSlotTypes) == 0x000008, "Member 'HWTagManager_GetAllowedSlotsForEquipmentType::OutAllowSlotTypes' has a wrong offset!");

// Function Hemingway.HWTagManager.GetAllRevealRuleTriggerTags
// 0x0020 (0x0020 - 0x0000)
struct HWTagManager_GetAllRevealRuleTriggerTags final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTagManager_GetAllRevealRuleTriggerTags) == 0x000008, "Wrong alignment on HWTagManager_GetAllRevealRuleTriggerTags");
static_assert(sizeof(HWTagManager_GetAllRevealRuleTriggerTags) == 0x000020, "Wrong size on HWTagManager_GetAllRevealRuleTriggerTags");
static_assert(offsetof(HWTagManager_GetAllRevealRuleTriggerTags, ReturnValue) == 0x000000, "Member 'HWTagManager_GetAllRevealRuleTriggerTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTagManager.GetAllTriggerTags
// 0x0010 (0x0010 - 0x0000)
struct HWTagManager_GetAllTriggerTags final
{
public:
	TArray<struct FGameplayTag>                   ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTagManager_GetAllTriggerTags) == 0x000008, "Wrong alignment on HWTagManager_GetAllTriggerTags");
static_assert(sizeof(HWTagManager_GetAllTriggerTags) == 0x000010, "Wrong size on HWTagManager_GetAllTriggerTags");
static_assert(offsetof(HWTagManager_GetAllTriggerTags, ReturnValue) == 0x000000, "Member 'HWTagManager_GetAllTriggerTags::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTagManager.GetBlockTagsBasedOnAbilityTypes
// 0x0048 (0x0048 - 0x0000)
struct HWTagManager_GetBlockTagsBasedOnAbilityTypes final
{
public:
	struct FGameplayTagContainer                  AbilityTypeTags;                                   // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OutBlockTags;                                      // 0x0020(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
	class UHWAbilitySystemComponent*              OwningAbilitySystem;                               // 0x0040(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTagManager_GetBlockTagsBasedOnAbilityTypes) == 0x000008, "Wrong alignment on HWTagManager_GetBlockTagsBasedOnAbilityTypes");
static_assert(sizeof(HWTagManager_GetBlockTagsBasedOnAbilityTypes) == 0x000048, "Wrong size on HWTagManager_GetBlockTagsBasedOnAbilityTypes");
static_assert(offsetof(HWTagManager_GetBlockTagsBasedOnAbilityTypes, AbilityTypeTags) == 0x000000, "Member 'HWTagManager_GetBlockTagsBasedOnAbilityTypes::AbilityTypeTags' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetBlockTagsBasedOnAbilityTypes, OutBlockTags) == 0x000020, "Member 'HWTagManager_GetBlockTagsBasedOnAbilityTypes::OutBlockTags' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetBlockTagsBasedOnAbilityTypes, OwningAbilitySystem) == 0x000040, "Member 'HWTagManager_GetBlockTagsBasedOnAbilityTypes::OwningAbilitySystem' has a wrong offset!");

// Function Hemingway.HWTagManager.GetBlockTagsBasedOnTriggerTags
// 0x0040 (0x0040 - 0x0000)
struct HWTagManager_GetBlockTagsBasedOnTriggerTags final
{
public:
	struct FGameplayTagContainer                  TagTriggers;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OutBlockTags;                                      // 0x0020(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTagManager_GetBlockTagsBasedOnTriggerTags) == 0x000008, "Wrong alignment on HWTagManager_GetBlockTagsBasedOnTriggerTags");
static_assert(sizeof(HWTagManager_GetBlockTagsBasedOnTriggerTags) == 0x000040, "Wrong size on HWTagManager_GetBlockTagsBasedOnTriggerTags");
static_assert(offsetof(HWTagManager_GetBlockTagsBasedOnTriggerTags, TagTriggers) == 0x000000, "Member 'HWTagManager_GetBlockTagsBasedOnTriggerTags::TagTriggers' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetBlockTagsBasedOnTriggerTags, OutBlockTags) == 0x000020, "Member 'HWTagManager_GetBlockTagsBasedOnTriggerTags::OutBlockTags' has a wrong offset!");

// Function Hemingway.HWTagManager.GetCancelTagsBasedOnAbilityTypes
// 0x0040 (0x0040 - 0x0000)
struct HWTagManager_GetCancelTagsBasedOnAbilityTypes final
{
public:
	struct FGameplayTagContainer                  AbilityTypeTags;                                   // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OutCancelTags;                                     // 0x0020(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTagManager_GetCancelTagsBasedOnAbilityTypes) == 0x000008, "Wrong alignment on HWTagManager_GetCancelTagsBasedOnAbilityTypes");
static_assert(sizeof(HWTagManager_GetCancelTagsBasedOnAbilityTypes) == 0x000040, "Wrong size on HWTagManager_GetCancelTagsBasedOnAbilityTypes");
static_assert(offsetof(HWTagManager_GetCancelTagsBasedOnAbilityTypes, AbilityTypeTags) == 0x000000, "Member 'HWTagManager_GetCancelTagsBasedOnAbilityTypes::AbilityTypeTags' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetCancelTagsBasedOnAbilityTypes, OutCancelTags) == 0x000020, "Member 'HWTagManager_GetCancelTagsBasedOnAbilityTypes::OutCancelTags' has a wrong offset!");

// Function Hemingway.HWTagManager.GetCancelTagsBasedOnTriggerTags
// 0x0060 (0x0060 - 0x0000)
struct HWTagManager_GetCancelTagsBasedOnTriggerTags final
{
public:
	struct FGameplayTagContainer                  TagTriggers;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHWAbilityCancelTagRequirement         OutCancelTags;                                     // 0x0020(0x0040)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTagManager_GetCancelTagsBasedOnTriggerTags) == 0x000008, "Wrong alignment on HWTagManager_GetCancelTagsBasedOnTriggerTags");
static_assert(sizeof(HWTagManager_GetCancelTagsBasedOnTriggerTags) == 0x000060, "Wrong size on HWTagManager_GetCancelTagsBasedOnTriggerTags");
static_assert(offsetof(HWTagManager_GetCancelTagsBasedOnTriggerTags, TagTriggers) == 0x000000, "Member 'HWTagManager_GetCancelTagsBasedOnTriggerTags::TagTriggers' has a wrong offset!");
static_assert(offsetof(HWTagManager_GetCancelTagsBasedOnTriggerTags, OutCancelTags) == 0x000020, "Member 'HWTagManager_GetCancelTagsBasedOnTriggerTags::OutCancelTags' has a wrong offset!");

// Function Hemingway.HWEnhancedPlayerInput.Input_SwapActionStateChange
// 0x0008 (0x0008 - 0x0000)
struct HWEnhancedPlayerInput_Input_SwapActionStateChange final
{
public:
	int32                                         InActionId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEnhancedPlayerInput_Input_SwapActionStateChange) == 0x000004, "Wrong alignment on HWEnhancedPlayerInput_Input_SwapActionStateChange");
static_assert(sizeof(HWEnhancedPlayerInput_Input_SwapActionStateChange) == 0x000008, "Wrong size on HWEnhancedPlayerInput_Input_SwapActionStateChange");
static_assert(offsetof(HWEnhancedPlayerInput_Input_SwapActionStateChange, InActionId) == 0x000000, "Member 'HWEnhancedPlayerInput_Input_SwapActionStateChange::InActionId' has a wrong offset!");
static_assert(offsetof(HWEnhancedPlayerInput_Input_SwapActionStateChange, bIsActive) == 0x000004, "Member 'HWEnhancedPlayerInput_Input_SwapActionStateChange::bIsActive' has a wrong offset!");

// Function Hemingway.HWEnhancedPlayerInput.Input_TriggerOff
// 0x0004 (0x0004 - 0x0000)
struct HWEnhancedPlayerInput_Input_TriggerOff final
{
public:
	int32                                         InActionId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEnhancedPlayerInput_Input_TriggerOff) == 0x000004, "Wrong alignment on HWEnhancedPlayerInput_Input_TriggerOff");
static_assert(sizeof(HWEnhancedPlayerInput_Input_TriggerOff) == 0x000004, "Wrong size on HWEnhancedPlayerInput_Input_TriggerOff");
static_assert(offsetof(HWEnhancedPlayerInput_Input_TriggerOff, InActionId) == 0x000000, "Member 'HWEnhancedPlayerInput_Input_TriggerOff::InActionId' has a wrong offset!");

// Function Hemingway.HWEnhancedPlayerInput.GetCurrentInputHardwareType
// 0x0001 (0x0001 - 0x0000)
struct HWEnhancedPlayerInput_GetCurrentInputHardwareType final
{
public:
	EHWInputHardwareType                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEnhancedPlayerInput_GetCurrentInputHardwareType) == 0x000001, "Wrong alignment on HWEnhancedPlayerInput_GetCurrentInputHardwareType");
static_assert(sizeof(HWEnhancedPlayerInput_GetCurrentInputHardwareType) == 0x000001, "Wrong size on HWEnhancedPlayerInput_GetCurrentInputHardwareType");
static_assert(offsetof(HWEnhancedPlayerInput_GetCurrentInputHardwareType, ReturnValue) == 0x000000, "Member 'HWEnhancedPlayerInput_GetCurrentInputHardwareType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEnhancedPlayerInput.GetInputTagKeys
// 0x0028 (0x0028 - 0x0000)
struct HWEnhancedPlayerInput_GetInputTagKeys final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           OutMouseKeyboardKeys;                              // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           OutGamepadKeys;                                    // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEnhancedPlayerInput_GetInputTagKeys) == 0x000008, "Wrong alignment on HWEnhancedPlayerInput_GetInputTagKeys");
static_assert(sizeof(HWEnhancedPlayerInput_GetInputTagKeys) == 0x000028, "Wrong size on HWEnhancedPlayerInput_GetInputTagKeys");
static_assert(offsetof(HWEnhancedPlayerInput_GetInputTagKeys, InputTag) == 0x000000, "Member 'HWEnhancedPlayerInput_GetInputTagKeys::InputTag' has a wrong offset!");
static_assert(offsetof(HWEnhancedPlayerInput_GetInputTagKeys, OutMouseKeyboardKeys) == 0x000008, "Member 'HWEnhancedPlayerInput_GetInputTagKeys::OutMouseKeyboardKeys' has a wrong offset!");
static_assert(offsetof(HWEnhancedPlayerInput_GetInputTagKeys, OutGamepadKeys) == 0x000018, "Member 'HWEnhancedPlayerInput_GetInputTagKeys::OutGamepadKeys' has a wrong offset!");

// Function Hemingway.HWEnhancedPlayerInput.GetInputTagKeysOfState
// 0x0020 (0x0020 - 0x0000)
struct HWEnhancedPlayerInput_GetInputTagKeysOfState final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERH_INPUT_STATE                               InputState;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEnhancedPlayerInput_GetInputTagKeysOfState) == 0x000008, "Wrong alignment on HWEnhancedPlayerInput_GetInputTagKeysOfState");
static_assert(sizeof(HWEnhancedPlayerInput_GetInputTagKeysOfState) == 0x000020, "Wrong size on HWEnhancedPlayerInput_GetInputTagKeysOfState");
static_assert(offsetof(HWEnhancedPlayerInput_GetInputTagKeysOfState, InputTag) == 0x000000, "Member 'HWEnhancedPlayerInput_GetInputTagKeysOfState::InputTag' has a wrong offset!");
static_assert(offsetof(HWEnhancedPlayerInput_GetInputTagKeysOfState, InputState) == 0x000008, "Member 'HWEnhancedPlayerInput_GetInputTagKeysOfState::InputState' has a wrong offset!");
static_assert(offsetof(HWEnhancedPlayerInput_GetInputTagKeysOfState, ReturnValue) == 0x000010, "Member 'HWEnhancedPlayerInput_GetInputTagKeysOfState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEnhancedPlayerInput.GetLastKnownControllerHardware
// 0x0001 (0x0001 - 0x0000)
struct HWEnhancedPlayerInput_GetLastKnownControllerHardware final
{
public:
	EHWInputHardwareType                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEnhancedPlayerInput_GetLastKnownControllerHardware) == 0x000001, "Wrong alignment on HWEnhancedPlayerInput_GetLastKnownControllerHardware");
static_assert(sizeof(HWEnhancedPlayerInput_GetLastKnownControllerHardware) == 0x000001, "Wrong size on HWEnhancedPlayerInput_GetLastKnownControllerHardware");
static_assert(offsetof(HWEnhancedPlayerInput_GetLastKnownControllerHardware, ReturnValue) == 0x000000, "Member 'HWEnhancedPlayerInput_GetLastKnownControllerHardware::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEnhancedPlayerInput.IsSwapActiveForKey
// 0x0020 (0x0020 - 0x0000)
struct HWEnhancedPlayerInput_IsSwapActiveForKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEnhancedPlayerInput_IsSwapActiveForKey) == 0x000008, "Wrong alignment on HWEnhancedPlayerInput_IsSwapActiveForKey");
static_assert(sizeof(HWEnhancedPlayerInput_IsSwapActiveForKey) == 0x000020, "Wrong size on HWEnhancedPlayerInput_IsSwapActiveForKey");
static_assert(offsetof(HWEnhancedPlayerInput_IsSwapActiveForKey, Key) == 0x000000, "Member 'HWEnhancedPlayerInput_IsSwapActiveForKey::Key' has a wrong offset!");
static_assert(offsetof(HWEnhancedPlayerInput_IsSwapActiveForKey, ReturnValue) == 0x000018, "Member 'HWEnhancedPlayerInput_IsSwapActiveForKey::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEnhancedPlayerInput.IsSwapKey
// 0x0020 (0x0020 - 0x0000)
struct HWEnhancedPlayerInput_IsSwapKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEnhancedPlayerInput_IsSwapKey) == 0x000008, "Wrong alignment on HWEnhancedPlayerInput_IsSwapKey");
static_assert(sizeof(HWEnhancedPlayerInput_IsSwapKey) == 0x000020, "Wrong size on HWEnhancedPlayerInput_IsSwapKey");
static_assert(offsetof(HWEnhancedPlayerInput_IsSwapKey, Key) == 0x000000, "Member 'HWEnhancedPlayerInput_IsSwapKey::Key' has a wrong offset!");
static_assert(offsetof(HWEnhancedPlayerInput_IsSwapKey, ReturnValue) == 0x000018, "Member 'HWEnhancedPlayerInput_IsSwapKey::ReturnValue' has a wrong offset!");

// Function Hemingway.HWEnhancedPlayerInput.UsesSOCDPolicy
// 0x0002 (0x0002 - 0x0000)
struct HWEnhancedPlayerInput_UsesSOCDPolicy final
{
public:
	EHWSOCDPolicy                                 InSOCDPolicty;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEnhancedPlayerInput_UsesSOCDPolicy) == 0x000001, "Wrong alignment on HWEnhancedPlayerInput_UsesSOCDPolicy");
static_assert(sizeof(HWEnhancedPlayerInput_UsesSOCDPolicy) == 0x000002, "Wrong size on HWEnhancedPlayerInput_UsesSOCDPolicy");
static_assert(offsetof(HWEnhancedPlayerInput_UsesSOCDPolicy, InSOCDPolicty) == 0x000000, "Member 'HWEnhancedPlayerInput_UsesSOCDPolicy::InSOCDPolicty' has a wrong offset!");
static_assert(offsetof(HWEnhancedPlayerInput_UsesSOCDPolicy, ReturnValue) == 0x000001, "Member 'HWEnhancedPlayerInput_UsesSOCDPolicy::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInputComponent.AddInputMappings
// 0x0010 (0x0010 - 0x0000)
struct HWInputComponent_AddInputMappings final
{
public:
	const class UHWInputConfig*                   InputConfig;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnhancedInputLocalPlayerSubsystem*     InputSubsystem;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInputComponent_AddInputMappings) == 0x000008, "Wrong alignment on HWInputComponent_AddInputMappings");
static_assert(sizeof(HWInputComponent_AddInputMappings) == 0x000010, "Wrong size on HWInputComponent_AddInputMappings");
static_assert(offsetof(HWInputComponent_AddInputMappings, InputConfig) == 0x000000, "Member 'HWInputComponent_AddInputMappings::InputConfig' has a wrong offset!");
static_assert(offsetof(HWInputComponent_AddInputMappings, InputSubsystem) == 0x000008, "Member 'HWInputComponent_AddInputMappings::InputSubsystem' has a wrong offset!");

// Function Hemingway.HWInputComponent.GetKeyMappedToTag
// 0x0028 (0x0028 - 0x0000)
struct HWInputComponent_GetKeyMappedToTag final
{
public:
	const class UHWInputConfig*                   InputConfig;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInputComponent_GetKeyMappedToTag) == 0x000008, "Wrong alignment on HWInputComponent_GetKeyMappedToTag");
static_assert(sizeof(HWInputComponent_GetKeyMappedToTag) == 0x000028, "Wrong size on HWInputComponent_GetKeyMappedToTag");
static_assert(offsetof(HWInputComponent_GetKeyMappedToTag, InputConfig) == 0x000000, "Member 'HWInputComponent_GetKeyMappedToTag::InputConfig' has a wrong offset!");
static_assert(offsetof(HWInputComponent_GetKeyMappedToTag, InputTag) == 0x000008, "Member 'HWInputComponent_GetKeyMappedToTag::InputTag' has a wrong offset!");
static_assert(offsetof(HWInputComponent_GetKeyMappedToTag, ReturnValue) == 0x000010, "Member 'HWInputComponent_GetKeyMappedToTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInputComponent.RemoveInputMappings
// 0x0010 (0x0010 - 0x0000)
struct HWInputComponent_RemoveInputMappings final
{
public:
	const class UHWInputConfig*                   InputConfig;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnhancedInputLocalPlayerSubsystem*     InputSubsystem;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInputComponent_RemoveInputMappings) == 0x000008, "Wrong alignment on HWInputComponent_RemoveInputMappings");
static_assert(sizeof(HWInputComponent_RemoveInputMappings) == 0x000010, "Wrong size on HWInputComponent_RemoveInputMappings");
static_assert(offsetof(HWInputComponent_RemoveInputMappings, InputConfig) == 0x000000, "Member 'HWInputComponent_RemoveInputMappings::InputConfig' has a wrong offset!");
static_assert(offsetof(HWInputComponent_RemoveInputMappings, InputSubsystem) == 0x000008, "Member 'HWInputComponent_RemoveInputMappings::InputSubsystem' has a wrong offset!");

// Function Hemingway.HWInputConfig.FindAbilityInputActionForTag
// 0x0018 (0x0018 - 0x0000)
struct HWInputConfig_FindAbilityInputActionForTag final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogNotFound;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UInputAction*                     ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInputConfig_FindAbilityInputActionForTag) == 0x000008, "Wrong alignment on HWInputConfig_FindAbilityInputActionForTag");
static_assert(sizeof(HWInputConfig_FindAbilityInputActionForTag) == 0x000018, "Wrong size on HWInputConfig_FindAbilityInputActionForTag");
static_assert(offsetof(HWInputConfig_FindAbilityInputActionForTag, InputTag) == 0x000000, "Member 'HWInputConfig_FindAbilityInputActionForTag::InputTag' has a wrong offset!");
static_assert(offsetof(HWInputConfig_FindAbilityInputActionForTag, bLogNotFound) == 0x000008, "Member 'HWInputConfig_FindAbilityInputActionForTag::bLogNotFound' has a wrong offset!");
static_assert(offsetof(HWInputConfig_FindAbilityInputActionForTag, ReturnValue) == 0x000010, "Member 'HWInputConfig_FindAbilityInputActionForTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInputConfig.FindNativeInputActionForTag
// 0x0018 (0x0018 - 0x0000)
struct HWInputConfig_FindNativeInputActionForTag final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogNotFound;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UInputAction*                     ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInputConfig_FindNativeInputActionForTag) == 0x000008, "Wrong alignment on HWInputConfig_FindNativeInputActionForTag");
static_assert(sizeof(HWInputConfig_FindNativeInputActionForTag) == 0x000018, "Wrong size on HWInputConfig_FindNativeInputActionForTag");
static_assert(offsetof(HWInputConfig_FindNativeInputActionForTag, InputTag) == 0x000000, "Member 'HWInputConfig_FindNativeInputActionForTag::InputTag' has a wrong offset!");
static_assert(offsetof(HWInputConfig_FindNativeInputActionForTag, bLogNotFound) == 0x000008, "Member 'HWInputConfig_FindNativeInputActionForTag::bLogNotFound' has a wrong offset!");
static_assert(offsetof(HWInputConfig_FindNativeInputActionForTag, ReturnValue) == 0x000010, "Member 'HWInputConfig_FindNativeInputActionForTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInputConfig.FindUIInputActionForTag
// 0x0018 (0x0018 - 0x0000)
struct HWInputConfig_FindUIInputActionForTag final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogNotFound;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UInputAction*                     ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInputConfig_FindUIInputActionForTag) == 0x000008, "Wrong alignment on HWInputConfig_FindUIInputActionForTag");
static_assert(sizeof(HWInputConfig_FindUIInputActionForTag) == 0x000018, "Wrong size on HWInputConfig_FindUIInputActionForTag");
static_assert(offsetof(HWInputConfig_FindUIInputActionForTag, InputTag) == 0x000000, "Member 'HWInputConfig_FindUIInputActionForTag::InputTag' has a wrong offset!");
static_assert(offsetof(HWInputConfig_FindUIInputActionForTag, bLogNotFound) == 0x000008, "Member 'HWInputConfig_FindUIInputActionForTag::bLogNotFound' has a wrong offset!");
static_assert(offsetof(HWInputConfig_FindUIInputActionForTag, ReturnValue) == 0x000010, "Member 'HWInputConfig_FindUIInputActionForTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInputConfig.FindVGSInputActionForTag
// 0x0018 (0x0018 - 0x0000)
struct HWInputConfig_FindVGSInputActionForTag final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogNotFound;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UInputAction*                     ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInputConfig_FindVGSInputActionForTag) == 0x000008, "Wrong alignment on HWInputConfig_FindVGSInputActionForTag");
static_assert(sizeof(HWInputConfig_FindVGSInputActionForTag) == 0x000018, "Wrong size on HWInputConfig_FindVGSInputActionForTag");
static_assert(offsetof(HWInputConfig_FindVGSInputActionForTag, InputTag) == 0x000000, "Member 'HWInputConfig_FindVGSInputActionForTag::InputTag' has a wrong offset!");
static_assert(offsetof(HWInputConfig_FindVGSInputActionForTag, bLogNotFound) == 0x000008, "Member 'HWInputConfig_FindVGSInputActionForTag::bLogNotFound' has a wrong offset!");
static_assert(offsetof(HWInputConfig_FindVGSInputActionForTag, ReturnValue) == 0x000010, "Member 'HWInputConfig_FindVGSInputActionForTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInputConfig.IsAbilityInputAction
// 0x0010 (0x0010 - 0x0000)
struct HWInputConfig_IsAbilityInputAction final
{
public:
	const class UInputAction*                     InputAction;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInputConfig_IsAbilityInputAction) == 0x000008, "Wrong alignment on HWInputConfig_IsAbilityInputAction");
static_assert(sizeof(HWInputConfig_IsAbilityInputAction) == 0x000010, "Wrong size on HWInputConfig_IsAbilityInputAction");
static_assert(offsetof(HWInputConfig_IsAbilityInputAction, InputAction) == 0x000000, "Member 'HWInputConfig_IsAbilityInputAction::InputAction' has a wrong offset!");
static_assert(offsetof(HWInputConfig_IsAbilityInputAction, ReturnValue) == 0x000008, "Member 'HWInputConfig_IsAbilityInputAction::ReturnValue' has a wrong offset!");

// Function Hemingway.HWMappingContextComponent.LoadKeybindSettings
// 0x0001 (0x0001 - 0x0000)
struct HWMappingContextComponent_LoadKeybindSettings final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMappingContextComponent_LoadKeybindSettings) == 0x000001, "Wrong alignment on HWMappingContextComponent_LoadKeybindSettings");
static_assert(sizeof(HWMappingContextComponent_LoadKeybindSettings) == 0x000001, "Wrong size on HWMappingContextComponent_LoadKeybindSettings");
static_assert(offsetof(HWMappingContextComponent_LoadKeybindSettings, ReturnValue) == 0x000000, "Member 'HWMappingContextComponent_LoadKeybindSettings::ReturnValue' has a wrong offset!");

// Function Hemingway.HWMappingContextComponent.HasDirtyRebinds
// 0x0001 (0x0001 - 0x0000)
struct HWMappingContextComponent_HasDirtyRebinds final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMappingContextComponent_HasDirtyRebinds) == 0x000001, "Wrong alignment on HWMappingContextComponent_HasDirtyRebinds");
static_assert(sizeof(HWMappingContextComponent_HasDirtyRebinds) == 0x000001, "Wrong size on HWMappingContextComponent_HasDirtyRebinds");
static_assert(offsetof(HWMappingContextComponent_HasDirtyRebinds, ReturnValue) == 0x000000, "Member 'HWMappingContextComponent_HasDirtyRebinds::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Controller.ClientSetControllerRotation
// 0x0020 (0x0020 - 0x0000)
struct HWInterface_Controller_ClientSetControllerRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bResetCamera;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWInterface_Controller_ClientSetControllerRotation) == 0x000008, "Wrong alignment on HWInterface_Controller_ClientSetControllerRotation");
static_assert(sizeof(HWInterface_Controller_ClientSetControllerRotation) == 0x000020, "Wrong size on HWInterface_Controller_ClientSetControllerRotation");
static_assert(offsetof(HWInterface_Controller_ClientSetControllerRotation, NewRotation) == 0x000000, "Member 'HWInterface_Controller_ClientSetControllerRotation::NewRotation' has a wrong offset!");
static_assert(offsetof(HWInterface_Controller_ClientSetControllerRotation, bResetCamera) == 0x000018, "Member 'HWInterface_Controller_ClientSetControllerRotation::bResetCamera' has a wrong offset!");

// Function Hemingway.HWInterface_Controller.GetAbilitySystemActor
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_Controller_GetAbilitySystemActor final
{
public:
	class AHWCharacterAbilitySystemActor*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Controller_GetAbilitySystemActor) == 0x000008, "Wrong alignment on HWInterface_Controller_GetAbilitySystemActor");
static_assert(sizeof(HWInterface_Controller_GetAbilitySystemActor) == 0x000008, "Wrong size on HWInterface_Controller_GetAbilitySystemActor");
static_assert(offsetof(HWInterface_Controller_GetAbilitySystemActor, ReturnValue) == 0x000000, "Member 'HWInterface_Controller_GetAbilitySystemActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Controller.GetAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_Controller_GetAbilitySystemComponent final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Controller_GetAbilitySystemComponent) == 0x000008, "Wrong alignment on HWInterface_Controller_GetAbilitySystemComponent");
static_assert(sizeof(HWInterface_Controller_GetAbilitySystemComponent) == 0x000008, "Wrong size on HWInterface_Controller_GetAbilitySystemComponent");
static_assert(offsetof(HWInterface_Controller_GetAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWInterface_Controller_GetAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Controller.GetStartSpot
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_Controller_GetStartSpot final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Controller_GetStartSpot) == 0x000008, "Wrong alignment on HWInterface_Controller_GetStartSpot");
static_assert(sizeof(HWInterface_Controller_GetStartSpot) == 0x000008, "Wrong size on HWInterface_Controller_GetStartSpot");
static_assert(offsetof(HWInterface_Controller_GetStartSpot, ReturnValue) == 0x000000, "Member 'HWInterface_Controller_GetStartSpot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_LoadoutManagement.GetLoadoutComponent
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_LoadoutManagement_GetLoadoutComponent final
{
public:
	class UHWLoadoutComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_LoadoutManagement_GetLoadoutComponent) == 0x000008, "Wrong alignment on HWInterface_LoadoutManagement_GetLoadoutComponent");
static_assert(sizeof(HWInterface_LoadoutManagement_GetLoadoutComponent) == 0x000008, "Wrong size on HWInterface_LoadoutManagement_GetLoadoutComponent");
static_assert(offsetof(HWInterface_LoadoutManagement_GetLoadoutComponent, ReturnValue) == 0x000000, "Member 'HWInterface_LoadoutManagement_GetLoadoutComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAnnouncerPackItem.GetAnnouncerCue
// 0x0048 (0x0048 - 0x0000)
struct HWAnnouncerPackItem_GetAnnouncerCue final
{
public:
	struct FAssetRequestKey                       AssetKey;                                          // 0x0000(0x001C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMetaSoundSource>        ReturnValue;                                       // 0x0020(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAnnouncerPackItem_GetAnnouncerCue) == 0x000008, "Wrong alignment on HWAnnouncerPackItem_GetAnnouncerCue");
static_assert(sizeof(HWAnnouncerPackItem_GetAnnouncerCue) == 0x000048, "Wrong size on HWAnnouncerPackItem_GetAnnouncerCue");
static_assert(offsetof(HWAnnouncerPackItem_GetAnnouncerCue, AssetKey) == 0x000000, "Member 'HWAnnouncerPackItem_GetAnnouncerCue::AssetKey' has a wrong offset!");
static_assert(offsetof(HWAnnouncerPackItem_GetAnnouncerCue, ReturnValue) == 0x000020, "Member 'HWAnnouncerPackItem_GetAnnouncerCue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWAnnouncerPackItem.GetSkinnedAnnouncerCues
// 0x0050 (0x0050 - 0x0000)
struct HWAnnouncerPackItem_GetSkinnedAnnouncerCues final
{
public:
	TMap<struct FAssetRequestKey, TSoftObjectPtr<class UMetaSoundSource>> ReturnValue;               // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWAnnouncerPackItem_GetSkinnedAnnouncerCues) == 0x000008, "Wrong alignment on HWAnnouncerPackItem_GetSkinnedAnnouncerCues");
static_assert(sizeof(HWAnnouncerPackItem_GetSkinnedAnnouncerCues) == 0x000050, "Wrong size on HWAnnouncerPackItem_GetSkinnedAnnouncerCues");
static_assert(offsetof(HWAnnouncerPackItem_GetSkinnedAnnouncerCues, ReturnValue) == 0x000000, "Member 'HWAnnouncerPackItem_GetSkinnedAnnouncerCues::ReturnValue' has a wrong offset!");

// Function Hemingway.HWMusicPackItem.GetSoundCue
// 0x0048 (0x0048 - 0x0000)
struct HWMusicPackItem_GetSoundCue final
{
public:
	struct FAssetRequestKey                       AssetKey;                                          // 0x0000(0x001C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMetaSoundSource>        ReturnValue;                                       // 0x0020(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMusicPackItem_GetSoundCue) == 0x000008, "Wrong alignment on HWMusicPackItem_GetSoundCue");
static_assert(sizeof(HWMusicPackItem_GetSoundCue) == 0x000048, "Wrong size on HWMusicPackItem_GetSoundCue");
static_assert(offsetof(HWMusicPackItem_GetSoundCue, AssetKey) == 0x000000, "Member 'HWMusicPackItem_GetSoundCue::AssetKey' has a wrong offset!");
static_assert(offsetof(HWMusicPackItem_GetSoundCue, ReturnValue) == 0x000020, "Member 'HWMusicPackItem_GetSoundCue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSeasonItem.GetPointsRequiredForPage
// 0x0010 (0x0010 - 0x0000)
struct HWSeasonItem_GetPointsRequiredForPage final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PageIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSeasonItem_GetPointsRequiredForPage) == 0x000008, "Wrong alignment on HWSeasonItem_GetPointsRequiredForPage");
static_assert(sizeof(HWSeasonItem_GetPointsRequiredForPage) == 0x000010, "Wrong size on HWSeasonItem_GetPointsRequiredForPage");
static_assert(offsetof(HWSeasonItem_GetPointsRequiredForPage, WorldContextObject) == 0x000000, "Member 'HWSeasonItem_GetPointsRequiredForPage::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWSeasonItem_GetPointsRequiredForPage, PageIndex) == 0x000008, "Member 'HWSeasonItem_GetPointsRequiredForPage::PageIndex' has a wrong offset!");
static_assert(offsetof(HWSeasonItem_GetPointsRequiredForPage, ReturnValue) == 0x00000C, "Member 'HWSeasonItem_GetPointsRequiredForPage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSeasonItem.GetSeasonItemCount
// 0x0010 (0x0010 - 0x0000)
struct HWSeasonItem_GetSeasonItemCount final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSeasonItem_GetSeasonItemCount) == 0x000008, "Wrong alignment on HWSeasonItem_GetSeasonItemCount");
static_assert(sizeof(HWSeasonItem_GetSeasonItemCount) == 0x000010, "Wrong size on HWSeasonItem_GetSeasonItemCount");
static_assert(offsetof(HWSeasonItem_GetSeasonItemCount, WorldContextObject) == 0x000000, "Member 'HWSeasonItem_GetSeasonItemCount::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWSeasonItem_GetSeasonItemCount, ReturnValue) == 0x000008, "Member 'HWSeasonItem_GetSeasonItemCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSeasonItem.GetSeasonItemOwned
// 0x0010 (0x0010 - 0x0000)
struct HWSeasonItem_GetSeasonItemOwned final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSeasonItem_GetSeasonItemOwned) == 0x000008, "Wrong alignment on HWSeasonItem_GetSeasonItemOwned");
static_assert(sizeof(HWSeasonItem_GetSeasonItemOwned) == 0x000010, "Wrong size on HWSeasonItem_GetSeasonItemOwned");
static_assert(offsetof(HWSeasonItem_GetSeasonItemOwned, WorldContextObject) == 0x000000, "Member 'HWSeasonItem_GetSeasonItemOwned::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWSeasonItem_GetSeasonItemOwned, ReturnValue) == 0x000008, "Member 'HWSeasonItem_GetSeasonItemOwned::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSeasonItem.GetSecondsRemainingInSeason
// 0x0010 (0x0010 - 0x0000)
struct HWSeasonItem_GetSecondsRemainingInSeason final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSeasonItem_GetSecondsRemainingInSeason) == 0x000008, "Wrong alignment on HWSeasonItem_GetSecondsRemainingInSeason");
static_assert(sizeof(HWSeasonItem_GetSecondsRemainingInSeason) == 0x000010, "Wrong size on HWSeasonItem_GetSecondsRemainingInSeason");
static_assert(offsetof(HWSeasonItem_GetSecondsRemainingInSeason, WorldContextObject) == 0x000000, "Member 'HWSeasonItem_GetSecondsRemainingInSeason::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWSeasonItem_GetSecondsRemainingInSeason, ReturnValue) == 0x000008, "Member 'HWSeasonItem_GetSecondsRemainingInSeason::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSeasonItem.GetSpentTokensTrackerItemId
// 0x0014 (0x0014 - 0x0000)
struct HWSeasonItem_GetSpentTokensTrackerItemId final
{
public:
	struct FRH_ItemId                             ReturnValue;                                       // 0x0000(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSeasonItem_GetSpentTokensTrackerItemId) == 0x000004, "Wrong alignment on HWSeasonItem_GetSpentTokensTrackerItemId");
static_assert(sizeof(HWSeasonItem_GetSpentTokensTrackerItemId) == 0x000014, "Wrong size on HWSeasonItem_GetSpentTokensTrackerItemId");
static_assert(offsetof(HWSeasonItem_GetSpentTokensTrackerItemId, ReturnValue) == 0x000000, "Member 'HWSeasonItem_GetSpentTokensTrackerItemId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSeasonItem.GetTotalPagesCount
// 0x0010 (0x0010 - 0x0000)
struct HWSeasonItem_GetTotalPagesCount final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSeasonItem_GetTotalPagesCount) == 0x000008, "Wrong alignment on HWSeasonItem_GetTotalPagesCount");
static_assert(sizeof(HWSeasonItem_GetTotalPagesCount) == 0x000010, "Wrong size on HWSeasonItem_GetTotalPagesCount");
static_assert(offsetof(HWSeasonItem_GetTotalPagesCount, WorldContextObject) == 0x000000, "Member 'HWSeasonItem_GetTotalPagesCount::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWSeasonItem_GetTotalPagesCount, ReturnValue) == 0x000008, "Member 'HWSeasonItem_GetTotalPagesCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSeasonItem.GetUnlockedPagesCount
// 0x0010 (0x0010 - 0x0000)
struct HWSeasonItem_GetUnlockedPagesCount final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSeasonItem_GetUnlockedPagesCount) == 0x000008, "Wrong alignment on HWSeasonItem_GetUnlockedPagesCount");
static_assert(sizeof(HWSeasonItem_GetUnlockedPagesCount) == 0x000010, "Wrong size on HWSeasonItem_GetUnlockedPagesCount");
static_assert(offsetof(HWSeasonItem_GetUnlockedPagesCount, WorldContextObject) == 0x000000, "Member 'HWSeasonItem_GetUnlockedPagesCount::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWSeasonItem_GetUnlockedPagesCount, ReturnValue) == 0x000008, "Member 'HWSeasonItem_GetUnlockedPagesCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSeasonItem.IsSeasonFullyCompleted
// 0x0010 (0x0010 - 0x0000)
struct HWSeasonItem_IsSeasonFullyCompleted final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSeasonItem_IsSeasonFullyCompleted) == 0x000008, "Wrong alignment on HWSeasonItem_IsSeasonFullyCompleted");
static_assert(sizeof(HWSeasonItem_IsSeasonFullyCompleted) == 0x000010, "Wrong size on HWSeasonItem_IsSeasonFullyCompleted");
static_assert(offsetof(HWSeasonItem_IsSeasonFullyCompleted, WorldContextObject) == 0x000000, "Member 'HWSeasonItem_IsSeasonFullyCompleted::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWSeasonItem_IsSeasonFullyCompleted, ReturnValue) == 0x000008, "Member 'HWSeasonItem_IsSeasonFullyCompleted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.SortSkinListByDisplayName
// 0x0010 (0x0010 - 0x0000)
struct HWSkinItem_SortSkinListByDisplayName final
{
public:
	TArray<TSoftObjectPtr<class UHWSkinItem>>     SkinList;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_SortSkinListByDisplayName) == 0x000008, "Wrong alignment on HWSkinItem_SortSkinListByDisplayName");
static_assert(sizeof(HWSkinItem_SortSkinListByDisplayName) == 0x000010, "Wrong size on HWSkinItem_SortSkinListByDisplayName");
static_assert(offsetof(HWSkinItem_SortSkinListByDisplayName, SkinList) == 0x000000, "Member 'HWSkinItem_SortSkinListByDisplayName::SkinList' has a wrong offset!");

// Function Hemingway.HWSkinItem.SortSkinListByFriendlyName
// 0x0010 (0x0010 - 0x0000)
struct HWSkinItem_SortSkinListByFriendlyName final
{
public:
	TArray<TSoftObjectPtr<class UHWSkinItem>>     SkinList;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_SortSkinListByFriendlyName) == 0x000008, "Wrong alignment on HWSkinItem_SortSkinListByFriendlyName");
static_assert(sizeof(HWSkinItem_SortSkinListByFriendlyName) == 0x000010, "Wrong size on HWSkinItem_SortSkinListByFriendlyName");
static_assert(offsetof(HWSkinItem_SortSkinListByFriendlyName, SkinList) == 0x000000, "Member 'HWSkinItem_SortSkinListByFriendlyName::SkinList' has a wrong offset!");

// Function Hemingway.HWSkinItem.StaticGetAssociatedCharacter
// 0x0050 (0x0050 - 0x0000)
struct HWSkinItem_StaticGetAssociatedCharacter final
{
public:
	TSoftObjectPtr<class UHWSkinItem>             Skin;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHWCharacterItem>        ReturnValue;                                       // 0x0028(0x0028)(ConstParm, Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_StaticGetAssociatedCharacter) == 0x000008, "Wrong alignment on HWSkinItem_StaticGetAssociatedCharacter");
static_assert(sizeof(HWSkinItem_StaticGetAssociatedCharacter) == 0x000050, "Wrong size on HWSkinItem_StaticGetAssociatedCharacter");
static_assert(offsetof(HWSkinItem_StaticGetAssociatedCharacter, Skin) == 0x000000, "Member 'HWSkinItem_StaticGetAssociatedCharacter::Skin' has a wrong offset!");
static_assert(offsetof(HWSkinItem_StaticGetAssociatedCharacter, ReturnValue) == 0x000028, "Member 'HWSkinItem_StaticGetAssociatedCharacter::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.GetApparelAssets
// 0x0010 (0x0010 - 0x0000)
struct HWSkinItem_GetApparelAssets final
{
public:
	TArray<TSoftObjectPtr<class UHWApparelItem>>  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_GetApparelAssets) == 0x000008, "Wrong alignment on HWSkinItem_GetApparelAssets");
static_assert(sizeof(HWSkinItem_GetApparelAssets) == 0x000010, "Wrong size on HWSkinItem_GetApparelAssets");
static_assert(offsetof(HWSkinItem_GetApparelAssets, ReturnValue) == 0x000000, "Member 'HWSkinItem_GetApparelAssets::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.GetAssociatedBaseSkin
// 0x0028 (0x0028 - 0x0000)
struct HWSkinItem_GetAssociatedBaseSkin final
{
public:
	TSoftObjectPtr<class UHWSkinItem>             ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_GetAssociatedBaseSkin) == 0x000008, "Wrong alignment on HWSkinItem_GetAssociatedBaseSkin");
static_assert(sizeof(HWSkinItem_GetAssociatedBaseSkin) == 0x000028, "Wrong size on HWSkinItem_GetAssociatedBaseSkin");
static_assert(offsetof(HWSkinItem_GetAssociatedBaseSkin, ReturnValue) == 0x000000, "Member 'HWSkinItem_GetAssociatedBaseSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.GetNextEvolutionSkin
// 0x0028 (0x0028 - 0x0000)
struct HWSkinItem_GetNextEvolutionSkin final
{
public:
	TSoftObjectPtr<class UHWSkinItem>             ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_GetNextEvolutionSkin) == 0x000008, "Wrong alignment on HWSkinItem_GetNextEvolutionSkin");
static_assert(sizeof(HWSkinItem_GetNextEvolutionSkin) == 0x000028, "Wrong size on HWSkinItem_GetNextEvolutionSkin");
static_assert(offsetof(HWSkinItem_GetNextEvolutionSkin, ReturnValue) == 0x000000, "Member 'HWSkinItem_GetNextEvolutionSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.GetOtherCompatibleAssociatedCharacterItems
// 0x0010 (0x0010 - 0x0000)
struct HWSkinItem_GetOtherCompatibleAssociatedCharacterItems final
{
public:
	TArray<TSoftObjectPtr<class UHWCharacterItem>> ReturnValue;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_GetOtherCompatibleAssociatedCharacterItems) == 0x000008, "Wrong alignment on HWSkinItem_GetOtherCompatibleAssociatedCharacterItems");
static_assert(sizeof(HWSkinItem_GetOtherCompatibleAssociatedCharacterItems) == 0x000010, "Wrong size on HWSkinItem_GetOtherCompatibleAssociatedCharacterItems");
static_assert(offsetof(HWSkinItem_GetOtherCompatibleAssociatedCharacterItems, ReturnValue) == 0x000000, "Member 'HWSkinItem_GetOtherCompatibleAssociatedCharacterItems::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.GetPreviewActor
// 0x0028 (0x0028 - 0x0000)
struct HWSkinItem_GetPreviewActor final
{
public:
	TSoftClassPtr<class UClass>                   ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_GetPreviewActor) == 0x000008, "Wrong alignment on HWSkinItem_GetPreviewActor");
static_assert(sizeof(HWSkinItem_GetPreviewActor) == 0x000028, "Wrong size on HWSkinItem_GetPreviewActor");
static_assert(offsetof(HWSkinItem_GetPreviewActor, ReturnValue) == 0x000000, "Member 'HWSkinItem_GetPreviewActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.GetPreviousEvolutionSkin
// 0x0028 (0x0028 - 0x0000)
struct HWSkinItem_GetPreviousEvolutionSkin final
{
public:
	TSoftObjectPtr<class UHWSkinItem>             ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_GetPreviousEvolutionSkin) == 0x000008, "Wrong alignment on HWSkinItem_GetPreviousEvolutionSkin");
static_assert(sizeof(HWSkinItem_GetPreviousEvolutionSkin) == 0x000028, "Wrong size on HWSkinItem_GetPreviousEvolutionSkin");
static_assert(offsetof(HWSkinItem_GetPreviousEvolutionSkin, ReturnValue) == 0x000000, "Member 'HWSkinItem_GetPreviousEvolutionSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.GetVoicePackItem
// 0x0028 (0x0028 - 0x0000)
struct HWSkinItem_GetVoicePackItem final
{
public:
	TSoftObjectPtr<class UHWVoicePackItem>        ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_GetVoicePackItem) == 0x000008, "Wrong alignment on HWSkinItem_GetVoicePackItem");
static_assert(sizeof(HWSkinItem_GetVoicePackItem) == 0x000028, "Wrong size on HWSkinItem_GetVoicePackItem");
static_assert(offsetof(HWSkinItem_GetVoicePackItem, ReturnValue) == 0x000000, "Member 'HWSkinItem_GetVoicePackItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.HasSkinVariants
// 0x0010 (0x0010 - 0x0000)
struct HWSkinItem_HasSkinVariants final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayableOnly;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSkinItem_HasSkinVariants) == 0x000008, "Wrong alignment on HWSkinItem_HasSkinVariants");
static_assert(sizeof(HWSkinItem_HasSkinVariants) == 0x000010, "Wrong size on HWSkinItem_HasSkinVariants");
static_assert(offsetof(HWSkinItem_HasSkinVariants, WorldContext) == 0x000000, "Member 'HWSkinItem_HasSkinVariants::WorldContext' has a wrong offset!");
static_assert(offsetof(HWSkinItem_HasSkinVariants, bPlayableOnly) == 0x000008, "Member 'HWSkinItem_HasSkinVariants::bPlayableOnly' has a wrong offset!");
static_assert(offsetof(HWSkinItem_HasSkinVariants, ReturnValue) == 0x000009, "Member 'HWSkinItem_HasSkinVariants::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.IsBaseSkinOfVariant
// 0x0010 (0x0010 - 0x0000)
struct HWSkinItem_IsBaseSkinOfVariant final
{
public:
	const class UHWSkinItem*                      VariantSkin;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSkinItem_IsBaseSkinOfVariant) == 0x000008, "Wrong alignment on HWSkinItem_IsBaseSkinOfVariant");
static_assert(sizeof(HWSkinItem_IsBaseSkinOfVariant) == 0x000010, "Wrong size on HWSkinItem_IsBaseSkinOfVariant");
static_assert(offsetof(HWSkinItem_IsBaseSkinOfVariant, VariantSkin) == 0x000000, "Member 'HWSkinItem_IsBaseSkinOfVariant::VariantSkin' has a wrong offset!");
static_assert(offsetof(HWSkinItem_IsBaseSkinOfVariant, ReturnValue) == 0x000008, "Member 'HWSkinItem_IsBaseSkinOfVariant::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.IsDefaultSkin
// 0x0001 (0x0001 - 0x0000)
struct HWSkinItem_IsDefaultSkin final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_IsDefaultSkin) == 0x000001, "Wrong alignment on HWSkinItem_IsDefaultSkin");
static_assert(sizeof(HWSkinItem_IsDefaultSkin) == 0x000001, "Wrong size on HWSkinItem_IsDefaultSkin");
static_assert(offsetof(HWSkinItem_IsDefaultSkin, ReturnValue) == 0x000000, "Member 'HWSkinItem_IsDefaultSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.IsMasterySkin
// 0x0001 (0x0001 - 0x0000)
struct HWSkinItem_IsMasterySkin final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_IsMasterySkin) == 0x000001, "Wrong alignment on HWSkinItem_IsMasterySkin");
static_assert(sizeof(HWSkinItem_IsMasterySkin) == 0x000001, "Wrong size on HWSkinItem_IsMasterySkin");
static_assert(offsetof(HWSkinItem_IsMasterySkin, ReturnValue) == 0x000000, "Member 'HWSkinItem_IsMasterySkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.IsOwnedCachedOrDefault
// 0x0010 (0x0010 - 0x0000)
struct HWSkinItem_IsOwnedCachedOrDefault final
{
public:
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSkinItem_IsOwnedCachedOrDefault) == 0x000008, "Wrong alignment on HWSkinItem_IsOwnedCachedOrDefault");
static_assert(sizeof(HWSkinItem_IsOwnedCachedOrDefault) == 0x000010, "Wrong size on HWSkinItem_IsOwnedCachedOrDefault");
static_assert(offsetof(HWSkinItem_IsOwnedCachedOrDefault, PlayerInfo) == 0x000000, "Member 'HWSkinItem_IsOwnedCachedOrDefault::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWSkinItem_IsOwnedCachedOrDefault, ReturnValue) == 0x000008, "Member 'HWSkinItem_IsOwnedCachedOrDefault::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.IsVariantOfBaseSkin
// 0x0010 (0x0010 - 0x0000)
struct HWSkinItem_IsVariantOfBaseSkin final
{
public:
	const class UHWSkinItem*                      BaseSkin;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSkinItem_IsVariantOfBaseSkin) == 0x000008, "Wrong alignment on HWSkinItem_IsVariantOfBaseSkin");
static_assert(sizeof(HWSkinItem_IsVariantOfBaseSkin) == 0x000010, "Wrong size on HWSkinItem_IsVariantOfBaseSkin");
static_assert(offsetof(HWSkinItem_IsVariantOfBaseSkin, BaseSkin) == 0x000000, "Member 'HWSkinItem_IsVariantOfBaseSkin::BaseSkin' has a wrong offset!");
static_assert(offsetof(HWSkinItem_IsVariantOfBaseSkin, ReturnValue) == 0x000008, "Member 'HWSkinItem_IsVariantOfBaseSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.IsVariantSkin
// 0x0001 (0x0001 - 0x0000)
struct HWSkinItem_IsVariantSkin final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_IsVariantSkin) == 0x000001, "Wrong alignment on HWSkinItem_IsVariantSkin");
static_assert(sizeof(HWSkinItem_IsVariantSkin) == 0x000001, "Wrong size on HWSkinItem_IsVariantSkin");
static_assert(offsetof(HWSkinItem_IsVariantSkin, ReturnValue) == 0x000000, "Member 'HWSkinItem_IsVariantSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinItem.ShouldUseLegacyMeshRotationOffset
// 0x0001 (0x0001 - 0x0000)
struct HWSkinItem_ShouldUseLegacyMeshRotationOffset final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinItem_ShouldUseLegacyMeshRotationOffset) == 0x000001, "Wrong alignment on HWSkinItem_ShouldUseLegacyMeshRotationOffset");
static_assert(sizeof(HWSkinItem_ShouldUseLegacyMeshRotationOffset) == 0x000001, "Wrong size on HWSkinItem_ShouldUseLegacyMeshRotationOffset");
static_assert(offsetof(HWSkinItem_ShouldUseLegacyMeshRotationOffset, ReturnValue) == 0x000000, "Member 'HWSkinItem_ShouldUseLegacyMeshRotationOffset::ReturnValue' has a wrong offset!");

// Function Hemingway.HWVoicePackItem.SortSkinListByDisplayName
// 0x0010 (0x0010 - 0x0000)
struct HWVoicePackItem_SortSkinListByDisplayName final
{
public:
	TArray<TSoftObjectPtr<class UHWVoicePackItem>> VoicePackList;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVoicePackItem_SortSkinListByDisplayName) == 0x000008, "Wrong alignment on HWVoicePackItem_SortSkinListByDisplayName");
static_assert(sizeof(HWVoicePackItem_SortSkinListByDisplayName) == 0x000010, "Wrong size on HWVoicePackItem_SortSkinListByDisplayName");
static_assert(offsetof(HWVoicePackItem_SortSkinListByDisplayName, VoicePackList) == 0x000000, "Member 'HWVoicePackItem_SortSkinListByDisplayName::VoicePackList' has a wrong offset!");

// Function Hemingway.HWVoicePackItem.SortSkinListByFriendlyName
// 0x0010 (0x0010 - 0x0000)
struct HWVoicePackItem_SortSkinListByFriendlyName final
{
public:
	TArray<TSoftObjectPtr<class UHWVoicePackItem>> VoicePackList;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWVoicePackItem_SortSkinListByFriendlyName) == 0x000008, "Wrong alignment on HWVoicePackItem_SortSkinListByFriendlyName");
static_assert(sizeof(HWVoicePackItem_SortSkinListByFriendlyName) == 0x000010, "Wrong size on HWVoicePackItem_SortSkinListByFriendlyName");
static_assert(offsetof(HWVoicePackItem_SortSkinListByFriendlyName, VoicePackList) == 0x000000, "Member 'HWVoicePackItem_SortSkinListByFriendlyName::VoicePackList' has a wrong offset!");

// Function Hemingway.HWPingWorldActor.SetPingDuration
// 0x0004 (0x0004 - 0x0000)
struct HWPingWorldActor_SetPingDuration final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPingWorldActor_SetPingDuration) == 0x000004, "Wrong alignment on HWPingWorldActor_SetPingDuration");
static_assert(sizeof(HWPingWorldActor_SetPingDuration) == 0x000004, "Wrong size on HWPingWorldActor_SetPingDuration");
static_assert(offsetof(HWPingWorldActor_SetPingDuration, Duration) == 0x000000, "Member 'HWPingWorldActor_SetPingDuration::Duration' has a wrong offset!");

// Function Hemingway.HWPingWorldActor.GetDisplayInfoComponent
// 0x0008 (0x0008 - 0x0000)
struct HWPingWorldActor_GetDisplayInfoComponent final
{
public:
	class UHWDisplayInfoComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPingWorldActor_GetDisplayInfoComponent) == 0x000008, "Wrong alignment on HWPingWorldActor_GetDisplayInfoComponent");
static_assert(sizeof(HWPingWorldActor_GetDisplayInfoComponent) == 0x000008, "Wrong size on HWPingWorldActor_GetDisplayInfoComponent");
static_assert(offsetof(HWPingWorldActor_GetDisplayInfoComponent, ReturnValue) == 0x000000, "Member 'HWPingWorldActor_GetDisplayInfoComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPingWorldActor.GetPingTag
// 0x0008 (0x0008 - 0x0000)
struct HWPingWorldActor_GetPingTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPingWorldActor_GetPingTag) == 0x000004, "Wrong alignment on HWPingWorldActor_GetPingTag");
static_assert(sizeof(HWPingWorldActor_GetPingTag) == 0x000008, "Wrong size on HWPingWorldActor_GetPingTag");
static_assert(offsetof(HWPingWorldActor_GetPingTag, ReturnValue) == 0x000000, "Member 'HWPingWorldActor_GetPingTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.IsLocalPlayerOnlyASpectator
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_IsLocalPlayerOnlyASpectator final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerController_IsLocalPlayerOnlyASpectator) == 0x000008, "Wrong alignment on HWPlayerController_IsLocalPlayerOnlyASpectator");
static_assert(sizeof(HWPlayerController_IsLocalPlayerOnlyASpectator) == 0x000010, "Wrong size on HWPlayerController_IsLocalPlayerOnlyASpectator");
static_assert(offsetof(HWPlayerController_IsLocalPlayerOnlyASpectator, WorldContextObject) == 0x000000, "Member 'HWPlayerController_IsLocalPlayerOnlyASpectator::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWPlayerController_IsLocalPlayerOnlyASpectator, ReturnValue) == 0x000008, "Member 'HWPlayerController_IsLocalPlayerOnlyASpectator::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.IsOnlyASpectator
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_IsOnlyASpectator final
{
public:
	const class APlayerController*                PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerController_IsOnlyASpectator) == 0x000008, "Wrong alignment on HWPlayerController_IsOnlyASpectator");
static_assert(sizeof(HWPlayerController_IsOnlyASpectator) == 0x000010, "Wrong size on HWPlayerController_IsOnlyASpectator");
static_assert(offsetof(HWPlayerController_IsOnlyASpectator, PlayerController) == 0x000000, "Member 'HWPlayerController_IsOnlyASpectator::PlayerController' has a wrong offset!");
static_assert(offsetof(HWPlayerController_IsOnlyASpectator, ReturnValue) == 0x000008, "Member 'HWPlayerController_IsOnlyASpectator::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.ActivateBooster
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_ActivateBooster final
{
public:
	struct FGameplayTag                           BoosterTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ActivateBooster) == 0x000004, "Wrong alignment on HWPlayerController_ActivateBooster");
static_assert(sizeof(HWPlayerController_ActivateBooster) == 0x000008, "Wrong size on HWPlayerController_ActivateBooster");
static_assert(offsetof(HWPlayerController_ActivateBooster, BoosterTag) == 0x000000, "Member 'HWPlayerController_ActivateBooster::BoosterTag' has a wrong offset!");

// Function Hemingway.HWPlayerController.AddLogMarker
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_AddLogMarker final
{
public:
	class FString                                 MarkerText;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_AddLogMarker) == 0x000008, "Wrong alignment on HWPlayerController_AddLogMarker");
static_assert(sizeof(HWPlayerController_AddLogMarker) == 0x000010, "Wrong size on HWPlayerController_AddLogMarker");
static_assert(offsetof(HWPlayerController_AddLogMarker, MarkerText) == 0x000000, "Member 'HWPlayerController_AddLogMarker::MarkerText' has a wrong offset!");

// Function Hemingway.HWPlayerController.AntiCheatClientMessageToServer
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_AntiCheatClientMessageToServer final
{
public:
	TArray<uint8>                                 Data;                                              // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_AntiCheatClientMessageToServer) == 0x000008, "Wrong alignment on HWPlayerController_AntiCheatClientMessageToServer");
static_assert(sizeof(HWPlayerController_AntiCheatClientMessageToServer) == 0x000010, "Wrong size on HWPlayerController_AntiCheatClientMessageToServer");
static_assert(offsetof(HWPlayerController_AntiCheatClientMessageToServer, Data) == 0x000000, "Member 'HWPlayerController_AntiCheatClientMessageToServer::Data' has a wrong offset!");

// Function Hemingway.HWPlayerController.AntiCheatServerMessageToClient
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_AntiCheatServerMessageToClient final
{
public:
	TArray<uint8>                                 Data;                                              // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_AntiCheatServerMessageToClient) == 0x000008, "Wrong alignment on HWPlayerController_AntiCheatServerMessageToClient");
static_assert(sizeof(HWPlayerController_AntiCheatServerMessageToClient) == 0x000010, "Wrong size on HWPlayerController_AntiCheatServerMessageToClient");
static_assert(offsetof(HWPlayerController_AntiCheatServerMessageToClient, Data) == 0x000000, "Member 'HWPlayerController_AntiCheatServerMessageToClient::Data' has a wrong offset!");

// Function Hemingway.HWPlayerController.BroadcastClientCombatEvent
// 0x0070 (0x0070 - 0x0000)
struct HWPlayerController_BroadcastClientCombatEvent final
{
public:
	struct FHWCombatEvent                         CombatEvent;                                       // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_BroadcastClientCombatEvent) == 0x000008, "Wrong alignment on HWPlayerController_BroadcastClientCombatEvent");
static_assert(sizeof(HWPlayerController_BroadcastClientCombatEvent) == 0x000070, "Wrong size on HWPlayerController_BroadcastClientCombatEvent");
static_assert(offsetof(HWPlayerController_BroadcastClientCombatEvent, CombatEvent) == 0x000000, "Member 'HWPlayerController_BroadcastClientCombatEvent::CombatEvent' has a wrong offset!");

// Function Hemingway.HWPlayerController.CancelCharacterSelection
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_CancelCharacterSelection final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_CancelCharacterSelection) == 0x000001, "Wrong alignment on HWPlayerController_CancelCharacterSelection");
static_assert(sizeof(HWPlayerController_CancelCharacterSelection) == 0x000001, "Wrong size on HWPlayerController_CancelCharacterSelection");
static_assert(offsetof(HWPlayerController_CancelCharacterSelection, ReturnValue) == 0x000000, "Member 'HWPlayerController_CancelCharacterSelection::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.ClientNotifyBackfillStateUpdated
// 0x0014 (0x0014 - 0x0000)
struct HWPlayerController_ClientNotifyBackfillStateUpdated final
{
public:
	struct FHWBackfillQueueInfo                   BackfillQueueInfo;                                 // 0x0000(0x0014)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ClientNotifyBackfillStateUpdated) == 0x000004, "Wrong alignment on HWPlayerController_ClientNotifyBackfillStateUpdated");
static_assert(sizeof(HWPlayerController_ClientNotifyBackfillStateUpdated) == 0x000014, "Wrong size on HWPlayerController_ClientNotifyBackfillStateUpdated");
static_assert(offsetof(HWPlayerController_ClientNotifyBackfillStateUpdated, BackfillQueueInfo) == 0x000000, "Member 'HWPlayerController_ClientNotifyBackfillStateUpdated::BackfillQueueInfo' has a wrong offset!");

// Function Hemingway.HWPlayerController.HandleABSActorTeamUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_HandleABSActorTeamUpdated final
{
public:
	class AHWCharacterAbilitySystemActor*         CharacterAbilitySystemActor;                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWTeamState*                           TeamState;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_HandleABSActorTeamUpdated) == 0x000008, "Wrong alignment on HWPlayerController_HandleABSActorTeamUpdated");
static_assert(sizeof(HWPlayerController_HandleABSActorTeamUpdated) == 0x000010, "Wrong size on HWPlayerController_HandleABSActorTeamUpdated");
static_assert(offsetof(HWPlayerController_HandleABSActorTeamUpdated, CharacterAbilitySystemActor) == 0x000000, "Member 'HWPlayerController_HandleABSActorTeamUpdated::CharacterAbilitySystemActor' has a wrong offset!");
static_assert(offsetof(HWPlayerController_HandleABSActorTeamUpdated, TeamState) == 0x000008, "Member 'HWPlayerController_HandleABSActorTeamUpdated::TeamState' has a wrong offset!");

// Function Hemingway.HWPlayerController.HandleCurrentVGSMenuIdUpdated
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_HandleCurrentVGSMenuIdUpdated final
{
public:
	struct FGameplayTag                           MenuId;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_HandleCurrentVGSMenuIdUpdated) == 0x000004, "Wrong alignment on HWPlayerController_HandleCurrentVGSMenuIdUpdated");
static_assert(sizeof(HWPlayerController_HandleCurrentVGSMenuIdUpdated) == 0x000008, "Wrong size on HWPlayerController_HandleCurrentVGSMenuIdUpdated");
static_assert(offsetof(HWPlayerController_HandleCurrentVGSMenuIdUpdated, MenuId) == 0x000000, "Member 'HWPlayerController_HandleCurrentVGSMenuIdUpdated::MenuId' has a wrong offset!");

// Function Hemingway.HWPlayerController.HandleInvokeVGSAction
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_HandleInvokeVGSAction final
{
public:
	struct FGameplayTag                           ActionId;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_HandleInvokeVGSAction) == 0x000004, "Wrong alignment on HWPlayerController_HandleInvokeVGSAction");
static_assert(sizeof(HWPlayerController_HandleInvokeVGSAction) == 0x000008, "Wrong size on HWPlayerController_HandleInvokeVGSAction");
static_assert(offsetof(HWPlayerController_HandleInvokeVGSAction, ActionId) == 0x000000, "Member 'HWPlayerController_HandleInvokeVGSAction::ActionId' has a wrong offset!");

// Function Hemingway.HWPlayerController.HandleOnTeamPauseVoteResolved
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_HandleOnTeamPauseVoteResolved final
{
public:
	class AHWTeamState*                           TeamState;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWVoteResult                                 Result;                                            // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerController_HandleOnTeamPauseVoteResolved) == 0x000008, "Wrong alignment on HWPlayerController_HandleOnTeamPauseVoteResolved");
static_assert(sizeof(HWPlayerController_HandleOnTeamPauseVoteResolved) == 0x000010, "Wrong size on HWPlayerController_HandleOnTeamPauseVoteResolved");
static_assert(offsetof(HWPlayerController_HandleOnTeamPauseVoteResolved, TeamState) == 0x000000, "Member 'HWPlayerController_HandleOnTeamPauseVoteResolved::TeamState' has a wrong offset!");
static_assert(offsetof(HWPlayerController_HandleOnTeamPauseVoteResolved, Result) == 0x000008, "Member 'HWPlayerController_HandleOnTeamPauseVoteResolved::Result' has a wrong offset!");

// Function Hemingway.HWPlayerController.HandleOnTeamSurrenderResolved
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_HandleOnTeamSurrenderResolved final
{
public:
	class AHWTeamState*                           TeamState;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWVoteResult                                 Result;                                            // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerController_HandleOnTeamSurrenderResolved) == 0x000008, "Wrong alignment on HWPlayerController_HandleOnTeamSurrenderResolved");
static_assert(sizeof(HWPlayerController_HandleOnTeamSurrenderResolved) == 0x000010, "Wrong size on HWPlayerController_HandleOnTeamSurrenderResolved");
static_assert(offsetof(HWPlayerController_HandleOnTeamSurrenderResolved, TeamState) == 0x000000, "Member 'HWPlayerController_HandleOnTeamSurrenderResolved::TeamState' has a wrong offset!");
static_assert(offsetof(HWPlayerController_HandleOnTeamSurrenderResolved, Result) == 0x000008, "Member 'HWPlayerController_HandleOnTeamSurrenderResolved::Result' has a wrong offset!");

// Function Hemingway.HWPlayerController.HandleVGSManagerReplicated
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_HandleVGSManagerReplicated final
{
public:
	class AHWVGSManager*                          VGSManager;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_HandleVGSManagerReplicated) == 0x000008, "Wrong alignment on HWPlayerController_HandleVGSManagerReplicated");
static_assert(sizeof(HWPlayerController_HandleVGSManagerReplicated) == 0x000008, "Wrong size on HWPlayerController_HandleVGSManagerReplicated");
static_assert(offsetof(HWPlayerController_HandleVGSManagerReplicated, VGSManager) == 0x000000, "Member 'HWPlayerController_HandleVGSManagerReplicated::VGSManager' has a wrong offset!");

// Function Hemingway.HWPlayerController.InitAFKDetection
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_InitAFKDetection final
{
public:
	float                                         KickAfterDuration;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarnAfterDuration;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_InitAFKDetection) == 0x000004, "Wrong alignment on HWPlayerController_InitAFKDetection");
static_assert(sizeof(HWPlayerController_InitAFKDetection) == 0x000008, "Wrong size on HWPlayerController_InitAFKDetection");
static_assert(offsetof(HWPlayerController_InitAFKDetection, KickAfterDuration) == 0x000000, "Member 'HWPlayerController_InitAFKDetection::KickAfterDuration' has a wrong offset!");
static_assert(offsetof(HWPlayerController_InitAFKDetection, WarnAfterDuration) == 0x000004, "Member 'HWPlayerController_InitAFKDetection::WarnAfterDuration' has a wrong offset!");

// Function Hemingway.HWPlayerController.Input_UIInputTagHeld
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Input_UIInputTagHeld final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Input_UIInputTagHeld) == 0x000004, "Wrong alignment on HWPlayerController_Input_UIInputTagHeld");
static_assert(sizeof(HWPlayerController_Input_UIInputTagHeld) == 0x000008, "Wrong size on HWPlayerController_Input_UIInputTagHeld");
static_assert(offsetof(HWPlayerController_Input_UIInputTagHeld, InputTag) == 0x000000, "Member 'HWPlayerController_Input_UIInputTagHeld::InputTag' has a wrong offset!");

// Function Hemingway.HWPlayerController.Input_UIInputTagPressed
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Input_UIInputTagPressed final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Input_UIInputTagPressed) == 0x000004, "Wrong alignment on HWPlayerController_Input_UIInputTagPressed");
static_assert(sizeof(HWPlayerController_Input_UIInputTagPressed) == 0x000008, "Wrong size on HWPlayerController_Input_UIInputTagPressed");
static_assert(offsetof(HWPlayerController_Input_UIInputTagPressed, InputTag) == 0x000000, "Member 'HWPlayerController_Input_UIInputTagPressed::InputTag' has a wrong offset!");

// Function Hemingway.HWPlayerController.Input_UIInputTagReleased
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Input_UIInputTagReleased final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Input_UIInputTagReleased) == 0x000004, "Wrong alignment on HWPlayerController_Input_UIInputTagReleased");
static_assert(sizeof(HWPlayerController_Input_UIInputTagReleased) == 0x000008, "Wrong size on HWPlayerController_Input_UIInputTagReleased");
static_assert(offsetof(HWPlayerController_Input_UIInputTagReleased, InputTag) == 0x000000, "Member 'HWPlayerController_Input_UIInputTagReleased::InputTag' has a wrong offset!");

// Function Hemingway.HWPlayerController.Input_VGSInputTagHeld
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Input_VGSInputTagHeld final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Input_VGSInputTagHeld) == 0x000004, "Wrong alignment on HWPlayerController_Input_VGSInputTagHeld");
static_assert(sizeof(HWPlayerController_Input_VGSInputTagHeld) == 0x000008, "Wrong size on HWPlayerController_Input_VGSInputTagHeld");
static_assert(offsetof(HWPlayerController_Input_VGSInputTagHeld, InputTag) == 0x000000, "Member 'HWPlayerController_Input_VGSInputTagHeld::InputTag' has a wrong offset!");

// Function Hemingway.HWPlayerController.Input_VGSInputTagPressed
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Input_VGSInputTagPressed final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Input_VGSInputTagPressed) == 0x000004, "Wrong alignment on HWPlayerController_Input_VGSInputTagPressed");
static_assert(sizeof(HWPlayerController_Input_VGSInputTagPressed) == 0x000008, "Wrong size on HWPlayerController_Input_VGSInputTagPressed");
static_assert(offsetof(HWPlayerController_Input_VGSInputTagPressed, InputTag) == 0x000000, "Member 'HWPlayerController_Input_VGSInputTagPressed::InputTag' has a wrong offset!");

// Function Hemingway.HWPlayerController.Input_VGSInputTagReleased
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Input_VGSInputTagReleased final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Input_VGSInputTagReleased) == 0x000004, "Wrong alignment on HWPlayerController_Input_VGSInputTagReleased");
static_assert(sizeof(HWPlayerController_Input_VGSInputTagReleased) == 0x000008, "Wrong size on HWPlayerController_Input_VGSInputTagReleased");
static_assert(offsetof(HWPlayerController_Input_VGSInputTagReleased, InputTag) == 0x000000, "Member 'HWPlayerController_Input_VGSInputTagReleased::InputTag' has a wrong offset!");

// Function Hemingway.HWPlayerController.IsInputBound
// 0x000C (0x000C - 0x0000)
struct HWPlayerController_IsInputBound final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERH_INPUT_STATE                               InputState;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerController_IsInputBound) == 0x000004, "Wrong alignment on HWPlayerController_IsInputBound");
static_assert(sizeof(HWPlayerController_IsInputBound) == 0x00000C, "Wrong size on HWPlayerController_IsInputBound");
static_assert(offsetof(HWPlayerController_IsInputBound, InputTag) == 0x000000, "Member 'HWPlayerController_IsInputBound::InputTag' has a wrong offset!");
static_assert(offsetof(HWPlayerController_IsInputBound, InputState) == 0x000008, "Member 'HWPlayerController_IsInputBound::InputState' has a wrong offset!");
static_assert(offsetof(HWPlayerController_IsInputBound, ReturnValue) == 0x000009, "Member 'HWPlayerController_IsInputBound::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.LocalPlayerSpectate
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_LocalPlayerSpectate final
{
public:
	bool                                          bWillSpectate;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_LocalPlayerSpectate) == 0x000001, "Wrong alignment on HWPlayerController_LocalPlayerSpectate");
static_assert(sizeof(HWPlayerController_LocalPlayerSpectate) == 0x000001, "Wrong size on HWPlayerController_LocalPlayerSpectate");
static_assert(offsetof(HWPlayerController_LocalPlayerSpectate, bWillSpectate) == 0x000000, "Member 'HWPlayerController_LocalPlayerSpectate::bWillSpectate' has a wrong offset!");

// Function Hemingway.HWPlayerController.NotifyBackfillStateUpdated
// 0x0014 (0x0014 - 0x0000)
struct HWPlayerController_NotifyBackfillStateUpdated final
{
public:
	struct FHWBackfillQueueInfo                   BackfillQueueInfo;                                 // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_NotifyBackfillStateUpdated) == 0x000004, "Wrong alignment on HWPlayerController_NotifyBackfillStateUpdated");
static_assert(sizeof(HWPlayerController_NotifyBackfillStateUpdated) == 0x000014, "Wrong size on HWPlayerController_NotifyBackfillStateUpdated");
static_assert(offsetof(HWPlayerController_NotifyBackfillStateUpdated, BackfillQueueInfo) == 0x000000, "Member 'HWPlayerController_NotifyBackfillStateUpdated::BackfillQueueInfo' has a wrong offset!");

// Function Hemingway.HWPlayerController.OnCurrentlyPossessedPawnChanged
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_OnCurrentlyPossessedPawnChanged final
{
public:
	class APawn*                                  PreviousPossessedPawn;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  CurrentPossessedPawn;                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_OnCurrentlyPossessedPawnChanged) == 0x000008, "Wrong alignment on HWPlayerController_OnCurrentlyPossessedPawnChanged");
static_assert(sizeof(HWPlayerController_OnCurrentlyPossessedPawnChanged) == 0x000010, "Wrong size on HWPlayerController_OnCurrentlyPossessedPawnChanged");
static_assert(offsetof(HWPlayerController_OnCurrentlyPossessedPawnChanged, PreviousPossessedPawn) == 0x000000, "Member 'HWPlayerController_OnCurrentlyPossessedPawnChanged::PreviousPossessedPawn' has a wrong offset!");
static_assert(offsetof(HWPlayerController_OnCurrentlyPossessedPawnChanged, CurrentPossessedPawn) == 0x000008, "Member 'HWPlayerController_OnCurrentlyPossessedPawnChanged::CurrentPossessedPawn' has a wrong offset!");

// Function Hemingway.HWPlayerController.OnDraftActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_OnDraftActorDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_OnDraftActorDestroyed) == 0x000008, "Wrong alignment on HWPlayerController_OnDraftActorDestroyed");
static_assert(sizeof(HWPlayerController_OnDraftActorDestroyed) == 0x000008, "Wrong size on HWPlayerController_OnDraftActorDestroyed");
static_assert(offsetof(HWPlayerController_OnDraftActorDestroyed, DestroyedActor) == 0x000000, "Member 'HWPlayerController_OnDraftActorDestroyed::DestroyedActor' has a wrong offset!");

// Function Hemingway.HWPlayerController.OnQuestProgressWritten
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_OnQuestProgressWritten final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_OnQuestProgressWritten) == 0x000001, "Wrong alignment on HWPlayerController_OnQuestProgressWritten");
static_assert(sizeof(HWPlayerController_OnQuestProgressWritten) == 0x000001, "Wrong size on HWPlayerController_OnQuestProgressWritten");
static_assert(offsetof(HWPlayerController_OnQuestProgressWritten, bSuccess) == 0x000000, "Member 'HWPlayerController_OnQuestProgressWritten::bSuccess' has a wrong offset!");

// Function Hemingway.HWPlayerController.OnRep_AbilitySystemActor
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_OnRep_AbilitySystemActor final
{
public:
	class AHWCharacterAbilitySystemActor*         OldAbilitySystemActor;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_OnRep_AbilitySystemActor) == 0x000008, "Wrong alignment on HWPlayerController_OnRep_AbilitySystemActor");
static_assert(sizeof(HWPlayerController_OnRep_AbilitySystemActor) == 0x000008, "Wrong size on HWPlayerController_OnRep_AbilitySystemActor");
static_assert(offsetof(HWPlayerController_OnRep_AbilitySystemActor, OldAbilitySystemActor) == 0x000000, "Member 'HWPlayerController_OnRep_AbilitySystemActor::OldAbilitySystemActor' has a wrong offset!");

// Function Hemingway.HWPlayerController.RequestCharacterReselect
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_RequestCharacterReselect final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_RequestCharacterReselect) == 0x000001, "Wrong alignment on HWPlayerController_RequestCharacterReselect");
static_assert(sizeof(HWPlayerController_RequestCharacterReselect) == 0x000001, "Wrong size on HWPlayerController_RequestCharacterReselect");
static_assert(offsetof(HWPlayerController_RequestCharacterReselect, ReturnValue) == 0x000000, "Member 'HWPlayerController_RequestCharacterReselect::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.Server_ActivateBooster
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Server_ActivateBooster final
{
public:
	struct FGameplayTag                           BoosterTag;                                        // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Server_ActivateBooster) == 0x000004, "Wrong alignment on HWPlayerController_Server_ActivateBooster");
static_assert(sizeof(HWPlayerController_Server_ActivateBooster) == 0x000008, "Wrong size on HWPlayerController_Server_ActivateBooster");
static_assert(offsetof(HWPlayerController_Server_ActivateBooster, BoosterTag) == 0x000000, "Member 'HWPlayerController_Server_ActivateBooster::BoosterTag' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerAddTeamPing
// 0x0028 (0x0028 - 0x0000)
struct HWPlayerController_ServerAddTeamPing final
{
public:
	struct FGameplayTag                           PingTag;                                           // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PingLocation;                                      // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWPingSource                                 PingSource;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendChatNotification;                             // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerController_ServerAddTeamPing) == 0x000008, "Wrong alignment on HWPlayerController_ServerAddTeamPing");
static_assert(sizeof(HWPlayerController_ServerAddTeamPing) == 0x000028, "Wrong size on HWPlayerController_ServerAddTeamPing");
static_assert(offsetof(HWPlayerController_ServerAddTeamPing, PingTag) == 0x000000, "Member 'HWPlayerController_ServerAddTeamPing::PingTag' has a wrong offset!");
static_assert(offsetof(HWPlayerController_ServerAddTeamPing, PingLocation) == 0x000008, "Member 'HWPlayerController_ServerAddTeamPing::PingLocation' has a wrong offset!");
static_assert(offsetof(HWPlayerController_ServerAddTeamPing, PingSource) == 0x000020, "Member 'HWPlayerController_ServerAddTeamPing::PingSource' has a wrong offset!");
static_assert(offsetof(HWPlayerController_ServerAddTeamPing, bSendChatNotification) == 0x000021, "Member 'HWPlayerController_ServerAddTeamPing::bSendChatNotification' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerDebugChangeCameraMode
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_ServerDebugChangeCameraMode final
{
public:
	EHWCameraMode                                 CameraMode;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ServerDebugChangeCameraMode) == 0x000001, "Wrong alignment on HWPlayerController_ServerDebugChangeCameraMode");
static_assert(sizeof(HWPlayerController_ServerDebugChangeCameraMode) == 0x000001, "Wrong size on HWPlayerController_ServerDebugChangeCameraMode");
static_assert(offsetof(HWPlayerController_ServerDebugChangeCameraMode, CameraMode) == 0x000000, "Member 'HWPlayerController_ServerDebugChangeCameraMode::CameraMode' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerSetActiveAspect
// 0x0014 (0x0014 - 0x0000)
struct HWPlayerController_ServerSetActiveAspect final
{
public:
	struct FRH_ItemId                             AspectItemId;                                      // 0x0000(0x0014)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ServerSetActiveAspect) == 0x000004, "Wrong alignment on HWPlayerController_ServerSetActiveAspect");
static_assert(sizeof(HWPlayerController_ServerSetActiveAspect) == 0x000014, "Wrong size on HWPlayerController_ServerSetActiveAspect");
static_assert(offsetof(HWPlayerController_ServerSetActiveAspect, AspectItemId) == 0x000000, "Member 'HWPlayerController_ServerSetActiveAspect::AspectItemId' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerSetInputType
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_ServerSetInputType final
{
public:
	ECommonInputType                              InputType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ServerSetInputType) == 0x000001, "Wrong alignment on HWPlayerController_ServerSetInputType");
static_assert(sizeof(HWPlayerController_ServerSetInputType) == 0x000001, "Wrong size on HWPlayerController_ServerSetInputType");
static_assert(offsetof(HWPlayerController_ServerSetInputType, InputType) == 0x000000, "Member 'HWPlayerController_ServerSetInputType::InputType' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerSetSRValue
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerController_ServerSetSRValue final
{
public:
	int32                                         InSRValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ServerSetSRValue) == 0x000004, "Wrong alignment on HWPlayerController_ServerSetSRValue");
static_assert(sizeof(HWPlayerController_ServerSetSRValue) == 0x000004, "Wrong size on HWPlayerController_ServerSetSRValue");
static_assert(offsetof(HWPlayerController_ServerSetSRValue, InSRValue) == 0x000000, "Member 'HWPlayerController_ServerSetSRValue::InSRValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerSubmitPauseVote
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_ServerSubmitPauseVote final
{
public:
	EHWVoteState                                  PauseVote;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ServerSubmitPauseVote) == 0x000001, "Wrong alignment on HWPlayerController_ServerSubmitPauseVote");
static_assert(sizeof(HWPlayerController_ServerSubmitPauseVote) == 0x000001, "Wrong size on HWPlayerController_ServerSubmitPauseVote");
static_assert(offsetof(HWPlayerController_ServerSubmitPauseVote, PauseVote) == 0x000000, "Member 'HWPlayerController_ServerSubmitPauseVote::PauseVote' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerSubmitSurrenderVote
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_ServerSubmitSurrenderVote final
{
public:
	EHWVoteState                                  SurrenderVote;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ServerSubmitSurrenderVote) == 0x000001, "Wrong alignment on HWPlayerController_ServerSubmitSurrenderVote");
static_assert(sizeof(HWPlayerController_ServerSubmitSurrenderVote) == 0x000001, "Wrong size on HWPlayerController_ServerSubmitSurrenderVote");
static_assert(offsetof(HWPlayerController_ServerSubmitSurrenderVote, SurrenderVote) == 0x000000, "Member 'HWPlayerController_ServerSubmitSurrenderVote::SurrenderVote' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerTogglePlayCallSuggestion
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_ServerTogglePlayCallSuggestion final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ServerTogglePlayCallSuggestion) == 0x000001, "Wrong alignment on HWPlayerController_ServerTogglePlayCallSuggestion");
static_assert(sizeof(HWPlayerController_ServerTogglePlayCallSuggestion) == 0x000001, "Wrong size on HWPlayerController_ServerTogglePlayCallSuggestion");
static_assert(offsetof(HWPlayerController_ServerTogglePlayCallSuggestion, bEnabled) == 0x000000, "Member 'HWPlayerController_ServerTogglePlayCallSuggestion::bEnabled' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerUpdateEquipmentCastMode
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_ServerUpdateEquipmentCastMode final
{
public:
	struct FHWInventorySlot                       InventorySlot;                                     // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityCastStyle                             CastMode;                                          // 0x000C(0x0001)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerController_ServerUpdateEquipmentCastMode) == 0x000004, "Wrong alignment on HWPlayerController_ServerUpdateEquipmentCastMode");
static_assert(sizeof(HWPlayerController_ServerUpdateEquipmentCastMode) == 0x000010, "Wrong size on HWPlayerController_ServerUpdateEquipmentCastMode");
static_assert(offsetof(HWPlayerController_ServerUpdateEquipmentCastMode, InventorySlot) == 0x000000, "Member 'HWPlayerController_ServerUpdateEquipmentCastMode::InventorySlot' has a wrong offset!");
static_assert(offsetof(HWPlayerController_ServerUpdateEquipmentCastMode, CastMode) == 0x00000C, "Member 'HWPlayerController_ServerUpdateEquipmentCastMode::CastMode' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerValidateIdToken
// 0x0020 (0x0020 - 0x0000)
struct HWPlayerController_ServerValidateIdToken final
{
public:
	class FString                                 ProductUserId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JsonWebToken;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ServerValidateIdToken) == 0x000008, "Wrong alignment on HWPlayerController_ServerValidateIdToken");
static_assert(sizeof(HWPlayerController_ServerValidateIdToken) == 0x000020, "Wrong size on HWPlayerController_ServerValidateIdToken");
static_assert(offsetof(HWPlayerController_ServerValidateIdToken, ProductUserId) == 0x000000, "Member 'HWPlayerController_ServerValidateIdToken::ProductUserId' has a wrong offset!");
static_assert(offsetof(HWPlayerController_ServerValidateIdToken, JsonWebToken) == 0x000010, "Member 'HWPlayerController_ServerValidateIdToken::JsonWebToken' has a wrong offset!");

// Function Hemingway.HWPlayerController.ServerVGSTriggerAction
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_ServerVGSTriggerAction final
{
public:
	struct FGameplayTag                           VGSTag;                                            // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ServerVGSTriggerAction) == 0x000004, "Wrong alignment on HWPlayerController_ServerVGSTriggerAction");
static_assert(sizeof(HWPlayerController_ServerVGSTriggerAction) == 0x000008, "Wrong size on HWPlayerController_ServerVGSTriggerAction");
static_assert(offsetof(HWPlayerController_ServerVGSTriggerAction, VGSTag) == 0x000000, "Member 'HWPlayerController_ServerVGSTriggerAction::VGSTag' has a wrong offset!");

// Function Hemingway.HWPlayerController.SetActiveControlModule
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_SetActiveControlModule final
{
public:
	TSubclassOf<class UHWControlModule>           ControlModClass;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_SetActiveControlModule) == 0x000008, "Wrong alignment on HWPlayerController_SetActiveControlModule");
static_assert(sizeof(HWPlayerController_SetActiveControlModule) == 0x000008, "Wrong size on HWPlayerController_SetActiveControlModule");
static_assert(offsetof(HWPlayerController_SetActiveControlModule, ControlModClass) == 0x000000, "Member 'HWPlayerController_SetActiveControlModule::ControlModClass' has a wrong offset!");

// Function Hemingway.HWPlayerController.SetAllowedInputCategories
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_SetAllowedInputCategories final
{
public:
	EHWAllowedInputCategory                       AllowedCategories;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_SetAllowedInputCategories) == 0x000001, "Wrong alignment on HWPlayerController_SetAllowedInputCategories");
static_assert(sizeof(HWPlayerController_SetAllowedInputCategories) == 0x000001, "Wrong size on HWPlayerController_SetAllowedInputCategories");
static_assert(offsetof(HWPlayerController_SetAllowedInputCategories, AllowedCategories) == 0x000000, "Member 'HWPlayerController_SetAllowedInputCategories::AllowedCategories' has a wrong offset!");

// Function Hemingway.HWPlayerController.SubmitPauseVote
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_SubmitPauseVote final
{
public:
	EHWVoteState                                  PauseVote;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_SubmitPauseVote) == 0x000001, "Wrong alignment on HWPlayerController_SubmitPauseVote");
static_assert(sizeof(HWPlayerController_SubmitPauseVote) == 0x000001, "Wrong size on HWPlayerController_SubmitPauseVote");
static_assert(offsetof(HWPlayerController_SubmitPauseVote, PauseVote) == 0x000000, "Member 'HWPlayerController_SubmitPauseVote::PauseVote' has a wrong offset!");

// Function Hemingway.HWPlayerController.SubmitSurrenderVote
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_SubmitSurrenderVote final
{
public:
	EHWVoteState                                  SurrenderVote;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_SubmitSurrenderVote) == 0x000001, "Wrong alignment on HWPlayerController_SubmitSurrenderVote");
static_assert(sizeof(HWPlayerController_SubmitSurrenderVote) == 0x000001, "Wrong size on HWPlayerController_SubmitSurrenderVote");
static_assert(offsetof(HWPlayerController_SubmitSurrenderVote, SurrenderVote) == 0x000000, "Member 'HWPlayerController_SubmitSurrenderVote::SurrenderVote' has a wrong offset!");

// Function Hemingway.HWPlayerController.ToggleCinematicCameraMode
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_ToggleCinematicCameraMode final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_ToggleCinematicCameraMode) == 0x000001, "Wrong alignment on HWPlayerController_ToggleCinematicCameraMode");
static_assert(sizeof(HWPlayerController_ToggleCinematicCameraMode) == 0x000001, "Wrong size on HWPlayerController_ToggleCinematicCameraMode");
static_assert(offsetof(HWPlayerController_ToggleCinematicCameraMode, bActive) == 0x000000, "Member 'HWPlayerController_ToggleCinematicCameraMode::bActive' has a wrong offset!");

// Function Hemingway.HWPlayerController.TogglePlayCallSuggestion
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_TogglePlayCallSuggestion final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_TogglePlayCallSuggestion) == 0x000001, "Wrong alignment on HWPlayerController_TogglePlayCallSuggestion");
static_assert(sizeof(HWPlayerController_TogglePlayCallSuggestion) == 0x000001, "Wrong size on HWPlayerController_TogglePlayCallSuggestion");
static_assert(offsetof(HWPlayerController_TogglePlayCallSuggestion, bEnabled) == 0x000000, "Member 'HWPlayerController_TogglePlayCallSuggestion::bEnabled' has a wrong offset!");

// Function Hemingway.HWPlayerController.TrackSingleStat
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_TrackSingleStat final
{
public:
	class FName                                   StatName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_TrackSingleStat) == 0x000004, "Wrong alignment on HWPlayerController_TrackSingleStat");
static_assert(sizeof(HWPlayerController_TrackSingleStat) == 0x000008, "Wrong size on HWPlayerController_TrackSingleStat");
static_assert(offsetof(HWPlayerController_TrackSingleStat, StatName) == 0x000000, "Member 'HWPlayerController_TrackSingleStat::StatName' has a wrong offset!");

// Function Hemingway.HWPlayerController.UpdateEquipmentCastMode
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_UpdateEquipmentCastMode final
{
public:
	struct FHWInventorySlot                       InventorySlot;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityCastStyle                             CastMode;                                          // 0x000C(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerController_UpdateEquipmentCastMode) == 0x000004, "Wrong alignment on HWPlayerController_UpdateEquipmentCastMode");
static_assert(sizeof(HWPlayerController_UpdateEquipmentCastMode) == 0x000010, "Wrong size on HWPlayerController_UpdateEquipmentCastMode");
static_assert(offsetof(HWPlayerController_UpdateEquipmentCastMode, InventorySlot) == 0x000000, "Member 'HWPlayerController_UpdateEquipmentCastMode::InventorySlot' has a wrong offset!");
static_assert(offsetof(HWPlayerController_UpdateEquipmentCastMode, CastMode) == 0x00000C, "Member 'HWPlayerController_UpdateEquipmentCastMode::CastMode' has a wrong offset!");

// Function Hemingway.HWPlayerController.CanCancelCharacterSelection
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_CanCancelCharacterSelection final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_CanCancelCharacterSelection) == 0x000001, "Wrong alignment on HWPlayerController_CanCancelCharacterSelection");
static_assert(sizeof(HWPlayerController_CanCancelCharacterSelection) == 0x000001, "Wrong size on HWPlayerController_CanCancelCharacterSelection");
static_assert(offsetof(HWPlayerController_CanCancelCharacterSelection, ReturnValue) == 0x000000, "Member 'HWPlayerController_CanCancelCharacterSelection::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.CanReselectCharacterNow
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_CanReselectCharacterNow final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_CanReselectCharacterNow) == 0x000001, "Wrong alignment on HWPlayerController_CanReselectCharacterNow");
static_assert(sizeof(HWPlayerController_CanReselectCharacterNow) == 0x000001, "Wrong size on HWPlayerController_CanReselectCharacterNow");
static_assert(offsetof(HWPlayerController_CanReselectCharacterNow, ReturnValue) == 0x000000, "Member 'HWPlayerController_CanReselectCharacterNow::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.GetAbilitySystemActor
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_GetAbilitySystemActor final
{
public:
	class AHWCharacterAbilitySystemActor*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_GetAbilitySystemActor) == 0x000008, "Wrong alignment on HWPlayerController_GetAbilitySystemActor");
static_assert(sizeof(HWPlayerController_GetAbilitySystemActor) == 0x000008, "Wrong size on HWPlayerController_GetAbilitySystemActor");
static_assert(offsetof(HWPlayerController_GetAbilitySystemActor, ReturnValue) == 0x000000, "Member 'HWPlayerController_GetAbilitySystemActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.GetActiveControlModule
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_GetActiveControlModule final
{
public:
	class UHWControlModule*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_GetActiveControlModule) == 0x000008, "Wrong alignment on HWPlayerController_GetActiveControlModule");
static_assert(sizeof(HWPlayerController_GetActiveControlModule) == 0x000008, "Wrong size on HWPlayerController_GetActiveControlModule");
static_assert(offsetof(HWPlayerController_GetActiveControlModule, ReturnValue) == 0x000000, "Member 'HWPlayerController_GetActiveControlModule::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.GetCurrentInputType
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_GetCurrentInputType final
{
public:
	ECommonInputType                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_GetCurrentInputType) == 0x000001, "Wrong alignment on HWPlayerController_GetCurrentInputType");
static_assert(sizeof(HWPlayerController_GetCurrentInputType) == 0x000001, "Wrong size on HWPlayerController_GetCurrentInputType");
static_assert(offsetof(HWPlayerController_GetCurrentInputType, ReturnValue) == 0x000000, "Member 'HWPlayerController_GetCurrentInputType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.GetHasPauseVoted
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_GetHasPauseVoted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_GetHasPauseVoted) == 0x000001, "Wrong alignment on HWPlayerController_GetHasPauseVoted");
static_assert(sizeof(HWPlayerController_GetHasPauseVoted) == 0x000001, "Wrong size on HWPlayerController_GetHasPauseVoted");
static_assert(offsetof(HWPlayerController_GetHasPauseVoted, ReturnValue) == 0x000000, "Member 'HWPlayerController_GetHasPauseVoted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.GetHasSurrenderVoted
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_GetHasSurrenderVoted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_GetHasSurrenderVoted) == 0x000001, "Wrong alignment on HWPlayerController_GetHasSurrenderVoted");
static_assert(sizeof(HWPlayerController_GetHasSurrenderVoted) == 0x000001, "Wrong size on HWPlayerController_GetHasSurrenderVoted");
static_assert(offsetof(HWPlayerController_GetHasSurrenderVoted, ReturnValue) == 0x000000, "Member 'HWPlayerController_GetHasSurrenderVoted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.GetHWEnhancedPlayerInput
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_GetHWEnhancedPlayerInput final
{
public:
	class UHWEnhancedPlayerInput*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_GetHWEnhancedPlayerInput) == 0x000008, "Wrong alignment on HWPlayerController_GetHWEnhancedPlayerInput");
static_assert(sizeof(HWPlayerController_GetHWEnhancedPlayerInput) == 0x000008, "Wrong size on HWPlayerController_GetHWEnhancedPlayerInput");
static_assert(offsetof(HWPlayerController_GetHWEnhancedPlayerInput, ReturnValue) == 0x000000, "Member 'HWPlayerController_GetHWEnhancedPlayerInput::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.GetItemStoreManagerComponent
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_GetItemStoreManagerComponent final
{
public:
	class UHWItemStoreManagerComponent*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_GetItemStoreManagerComponent) == 0x000008, "Wrong alignment on HWPlayerController_GetItemStoreManagerComponent");
static_assert(sizeof(HWPlayerController_GetItemStoreManagerComponent) == 0x000008, "Wrong size on HWPlayerController_GetItemStoreManagerComponent");
static_assert(offsetof(HWPlayerController_GetItemStoreManagerComponent, ReturnValue) == 0x000000, "Member 'HWPlayerController_GetItemStoreManagerComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.GetPlayCallSuggestionManager
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_GetPlayCallSuggestionManager final
{
public:
	class AHWPlayCallSuggestionManager*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_GetPlayCallSuggestionManager) == 0x000008, "Wrong alignment on HWPlayerController_GetPlayCallSuggestionManager");
static_assert(sizeof(HWPlayerController_GetPlayCallSuggestionManager) == 0x000008, "Wrong size on HWPlayerController_GetPlayCallSuggestionManager");
static_assert(offsetof(HWPlayerController_GetPlayCallSuggestionManager, ReturnValue) == 0x000000, "Member 'HWPlayerController_GetPlayCallSuggestionManager::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.IsCinematicCameraModeActive
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_IsCinematicCameraModeActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_IsCinematicCameraModeActive) == 0x000001, "Wrong alignment on HWPlayerController_IsCinematicCameraModeActive");
static_assert(sizeof(HWPlayerController_IsCinematicCameraModeActive) == 0x000001, "Wrong size on HWPlayerController_IsCinematicCameraModeActive");
static_assert(offsetof(HWPlayerController_IsCinematicCameraModeActive, ReturnValue) == 0x000000, "Member 'HWPlayerController_IsCinematicCameraModeActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.IsGm
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_IsGm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_IsGm) == 0x000001, "Wrong alignment on HWPlayerController_IsGm");
static_assert(sizeof(HWPlayerController_IsGm) == 0x000001, "Wrong size on HWPlayerController_IsGm");
static_assert(offsetof(HWPlayerController_IsGm, ReturnValue) == 0x000000, "Member 'HWPlayerController_IsGm::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.IsInputCategoryAllowed
// 0x0002 (0x0002 - 0x0000)
struct HWPlayerController_IsInputCategoryAllowed final
{
public:
	EHWAllowedInputCategory                       Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_IsInputCategoryAllowed) == 0x000001, "Wrong alignment on HWPlayerController_IsInputCategoryAllowed");
static_assert(sizeof(HWPlayerController_IsInputCategoryAllowed) == 0x000002, "Wrong size on HWPlayerController_IsInputCategoryAllowed");
static_assert(offsetof(HWPlayerController_IsInputCategoryAllowed, Category) == 0x000000, "Member 'HWPlayerController_IsInputCategoryAllowed::Category' has a wrong offset!");
static_assert(offsetof(HWPlayerController_IsInputCategoryAllowed, ReturnValue) == 0x000001, "Member 'HWPlayerController_IsInputCategoryAllowed::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.IsUIRelevant
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_IsUIRelevant final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_IsUIRelevant) == 0x000001, "Wrong alignment on HWPlayerController_IsUIRelevant");
static_assert(sizeof(HWPlayerController_IsUIRelevant) == 0x000001, "Wrong size on HWPlayerController_IsUIRelevant");
static_assert(offsetof(HWPlayerController_IsUIRelevant, ReturnValue) == 0x000000, "Member 'HWPlayerController_IsUIRelevant::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController.IsUIRelevantOrSpectator
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_IsUIRelevantOrSpectator final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_IsUIRelevantOrSpectator) == 0x000001, "Wrong alignment on HWPlayerController_IsUIRelevantOrSpectator");
static_assert(sizeof(HWPlayerController_IsUIRelevantOrSpectator) == 0x000001, "Wrong size on HWPlayerController_IsUIRelevantOrSpectator");
static_assert(offsetof(HWPlayerController_IsUIRelevantOrSpectator, ReturnValue) == 0x000000, "Member 'HWPlayerController_IsUIRelevantOrSpectator::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.Input_DeathSpecatorLook
// 0x0020 (0x0020 - 0x0000)
struct HWPlayerController_Smite_Input_DeathSpecatorLook final
{
public:
	struct FInputActionValue                      InputActionValue;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_Input_DeathSpecatorLook) == 0x000008, "Wrong alignment on HWPlayerController_Smite_Input_DeathSpecatorLook");
static_assert(sizeof(HWPlayerController_Smite_Input_DeathSpecatorLook) == 0x000020, "Wrong size on HWPlayerController_Smite_Input_DeathSpecatorLook");
static_assert(offsetof(HWPlayerController_Smite_Input_DeathSpecatorLook, InputActionValue) == 0x000000, "Member 'HWPlayerController_Smite_Input_DeathSpecatorLook::InputActionValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.OnDeathSpectatorStatusChange
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_Smite_OnDeathSpectatorStatusChange final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_OnDeathSpectatorStatusChange) == 0x000001, "Wrong alignment on HWPlayerController_Smite_OnDeathSpectatorStatusChange");
static_assert(sizeof(HWPlayerController_Smite_OnDeathSpectatorStatusChange) == 0x000001, "Wrong size on HWPlayerController_Smite_OnDeathSpectatorStatusChange");
static_assert(offsetof(HWPlayerController_Smite_OnDeathSpectatorStatusChange, bEnabled) == 0x000000, "Member 'HWPlayerController_Smite_OnDeathSpectatorStatusChange::bEnabled' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.ServerSetUseRestrictedCameraPitch
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_Smite_ServerSetUseRestrictedCameraPitch final
{
public:
	bool                                          bRestrictCamera;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_ServerSetUseRestrictedCameraPitch) == 0x000001, "Wrong alignment on HWPlayerController_Smite_ServerSetUseRestrictedCameraPitch");
static_assert(sizeof(HWPlayerController_Smite_ServerSetUseRestrictedCameraPitch) == 0x000001, "Wrong size on HWPlayerController_Smite_ServerSetUseRestrictedCameraPitch");
static_assert(offsetof(HWPlayerController_Smite_ServerSetUseRestrictedCameraPitch, bRestrictCamera) == 0x000000, "Member 'HWPlayerController_Smite_ServerSetUseRestrictedCameraPitch::bRestrictCamera' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.SetMaxZoom
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerController_Smite_SetMaxZoom final
{
public:
	float                                         NewMaxZoom;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_SetMaxZoom) == 0x000004, "Wrong alignment on HWPlayerController_Smite_SetMaxZoom");
static_assert(sizeof(HWPlayerController_Smite_SetMaxZoom) == 0x000004, "Wrong size on HWPlayerController_Smite_SetMaxZoom");
static_assert(offsetof(HWPlayerController_Smite_SetMaxZoom, NewMaxZoom) == 0x000000, "Member 'HWPlayerController_Smite_SetMaxZoom::NewMaxZoom' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.SetMinZoom
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerController_Smite_SetMinZoom final
{
public:
	float                                         NewMinZoom;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_SetMinZoom) == 0x000004, "Wrong alignment on HWPlayerController_Smite_SetMinZoom");
static_assert(sizeof(HWPlayerController_Smite_SetMinZoom) == 0x000004, "Wrong size on HWPlayerController_Smite_SetMinZoom");
static_assert(offsetof(HWPlayerController_Smite_SetMinZoom, NewMinZoom) == 0x000000, "Member 'HWPlayerController_Smite_SetMinZoom::NewMinZoom' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.SetRestrictedCameraPitchInterpSpeedOverride
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Smite_SetRestrictedCameraPitchInterpSpeedOverride final
{
public:
	float                                         NewInterpSpeedOverride;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_SetRestrictedCameraPitchInterpSpeedOverride) == 0x000004, "Wrong alignment on HWPlayerController_Smite_SetRestrictedCameraPitchInterpSpeedOverride");
static_assert(sizeof(HWPlayerController_Smite_SetRestrictedCameraPitchInterpSpeedOverride) == 0x000008, "Wrong size on HWPlayerController_Smite_SetRestrictedCameraPitchInterpSpeedOverride");
static_assert(offsetof(HWPlayerController_Smite_SetRestrictedCameraPitchInterpSpeedOverride, NewInterpSpeedOverride) == 0x000000, "Member 'HWPlayerController_Smite_SetRestrictedCameraPitchInterpSpeedOverride::NewInterpSpeedOverride' has a wrong offset!");
static_assert(offsetof(HWPlayerController_Smite_SetRestrictedCameraPitchInterpSpeedOverride, Time) == 0x000004, "Member 'HWPlayerController_Smite_SetRestrictedCameraPitchInterpSpeedOverride::Time' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.SetZoomPercent
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerController_Smite_SetZoomPercent final
{
public:
	float                                         NewZoomPercent;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_SetZoomPercent) == 0x000004, "Wrong alignment on HWPlayerController_Smite_SetZoomPercent");
static_assert(sizeof(HWPlayerController_Smite_SetZoomPercent) == 0x000004, "Wrong size on HWPlayerController_Smite_SetZoomPercent");
static_assert(offsetof(HWPlayerController_Smite_SetZoomPercent, NewZoomPercent) == 0x000000, "Member 'HWPlayerController_Smite_SetZoomPercent::NewZoomPercent' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.GetMaxZoom
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerController_Smite_GetMaxZoom final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_GetMaxZoom) == 0x000004, "Wrong alignment on HWPlayerController_Smite_GetMaxZoom");
static_assert(sizeof(HWPlayerController_Smite_GetMaxZoom) == 0x000004, "Wrong size on HWPlayerController_Smite_GetMaxZoom");
static_assert(offsetof(HWPlayerController_Smite_GetMaxZoom, ReturnValue) == 0x000000, "Member 'HWPlayerController_Smite_GetMaxZoom::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.GetMinZoom
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerController_Smite_GetMinZoom final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_GetMinZoom) == 0x000004, "Wrong alignment on HWPlayerController_Smite_GetMinZoom");
static_assert(sizeof(HWPlayerController_Smite_GetMinZoom) == 0x000004, "Wrong size on HWPlayerController_Smite_GetMinZoom");
static_assert(offsetof(HWPlayerController_Smite_GetMinZoom, ReturnValue) == 0x000000, "Member 'HWPlayerController_Smite_GetMinZoom::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.GetPlayerSettingsSubsystem
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Smite_GetPlayerSettingsSubsystem final
{
public:
	class UHWPlayerSettingsSubsystem*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_GetPlayerSettingsSubsystem) == 0x000008, "Wrong alignment on HWPlayerController_Smite_GetPlayerSettingsSubsystem");
static_assert(sizeof(HWPlayerController_Smite_GetPlayerSettingsSubsystem) == 0x000008, "Wrong size on HWPlayerController_Smite_GetPlayerSettingsSubsystem");
static_assert(offsetof(HWPlayerController_Smite_GetPlayerSettingsSubsystem, ReturnValue) == 0x000000, "Member 'HWPlayerController_Smite_GetPlayerSettingsSubsystem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.GetSystemSettingsSubsystem
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Smite_GetSystemSettingsSubsystem final
{
public:
	class UHWSystemSettingsSubsystem*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_GetSystemSettingsSubsystem) == 0x000008, "Wrong alignment on HWPlayerController_Smite_GetSystemSettingsSubsystem");
static_assert(sizeof(HWPlayerController_Smite_GetSystemSettingsSubsystem) == 0x000008, "Wrong size on HWPlayerController_Smite_GetSystemSettingsSubsystem");
static_assert(offsetof(HWPlayerController_Smite_GetSystemSettingsSubsystem, ReturnValue) == 0x000000, "Member 'HWPlayerController_Smite_GetSystemSettingsSubsystem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.GetZoomPercent
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerController_Smite_GetZoomPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_GetZoomPercent) == 0x000004, "Wrong alignment on HWPlayerController_Smite_GetZoomPercent");
static_assert(sizeof(HWPlayerController_Smite_GetZoomPercent) == 0x000004, "Wrong size on HWPlayerController_Smite_GetZoomPercent");
static_assert(offsetof(HWPlayerController_Smite_GetZoomPercent, ReturnValue) == 0x000000, "Member 'HWPlayerController_Smite_GetZoomPercent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.IsCharacterForcedToAimDown
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_Smite_IsCharacterForcedToAimDown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_IsCharacterForcedToAimDown) == 0x000001, "Wrong alignment on HWPlayerController_Smite_IsCharacterForcedToAimDown");
static_assert(sizeof(HWPlayerController_Smite_IsCharacterForcedToAimDown) == 0x000001, "Wrong size on HWPlayerController_Smite_IsCharacterForcedToAimDown");
static_assert(offsetof(HWPlayerController_Smite_IsCharacterForcedToAimDown, ReturnValue) == 0x000000, "Member 'HWPlayerController_Smite_IsCharacterForcedToAimDown::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Smite.IsInRestrictedCamPitch
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_Smite_IsInRestrictedCamPitch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Smite_IsInRestrictedCamPitch) == 0x000001, "Wrong alignment on HWPlayerController_Smite_IsInRestrictedCamPitch");
static_assert(sizeof(HWPlayerController_Smite_IsInRestrictedCamPitch) == 0x000001, "Wrong size on HWPlayerController_Smite_IsInRestrictedCamPitch");
static_assert(offsetof(HWPlayerController_Smite_IsInRestrictedCamPitch, ReturnValue) == 0x000000, "Member 'HWPlayerController_Smite_IsInRestrictedCamPitch::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.OnSpectateTargetCanSpectateStatusChanged
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerController_Spectator_OnSpectateTargetCanSpectateStatusChanged final
{
public:
	class AHWCharacter_Base*                      TargetCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSpectate;                                      // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerController_Spectator_OnSpectateTargetCanSpectateStatusChanged) == 0x000008, "Wrong alignment on HWPlayerController_Spectator_OnSpectateTargetCanSpectateStatusChanged");
static_assert(sizeof(HWPlayerController_Spectator_OnSpectateTargetCanSpectateStatusChanged) == 0x000010, "Wrong size on HWPlayerController_Spectator_OnSpectateTargetCanSpectateStatusChanged");
static_assert(offsetof(HWPlayerController_Spectator_OnSpectateTargetCanSpectateStatusChanged, TargetCharacter) == 0x000000, "Member 'HWPlayerController_Spectator_OnSpectateTargetCanSpectateStatusChanged::TargetCharacter' has a wrong offset!");
static_assert(offsetof(HWPlayerController_Spectator_OnSpectateTargetCanSpectateStatusChanged, bCanSpectate) == 0x000008, "Member 'HWPlayerController_Spectator_OnSpectateTargetCanSpectateStatusChanged::bCanSpectate' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.SelectViewTargetByIndex
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerController_Spectator_SelectViewTargetByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Spectator_SelectViewTargetByIndex) == 0x000004, "Wrong alignment on HWPlayerController_Spectator_SelectViewTargetByIndex");
static_assert(sizeof(HWPlayerController_Spectator_SelectViewTargetByIndex) == 0x000004, "Wrong size on HWPlayerController_Spectator_SelectViewTargetByIndex");
static_assert(offsetof(HWPlayerController_Spectator_SelectViewTargetByIndex, Index_0) == 0x000000, "Member 'HWPlayerController_Spectator_SelectViewTargetByIndex::Index_0' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.SelectViewTargetByPlayerState
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Spectator_SelectViewTargetByPlayerState final
{
public:
	class AHWPlayerState*                         Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Spectator_SelectViewTargetByPlayerState) == 0x000008, "Wrong alignment on HWPlayerController_Spectator_SelectViewTargetByPlayerState");
static_assert(sizeof(HWPlayerController_Spectator_SelectViewTargetByPlayerState) == 0x000008, "Wrong size on HWPlayerController_Spectator_SelectViewTargetByPlayerState");
static_assert(offsetof(HWPlayerController_Spectator_SelectViewTargetByPlayerState, Target) == 0x000000, "Member 'HWPlayerController_Spectator_SelectViewTargetByPlayerState::Target' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.ServerCycleNextSpectatorTarget
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_Spectator_ServerCycleNextSpectatorTarget final
{
public:
	bool                                          Reverse;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Spectator_ServerCycleNextSpectatorTarget) == 0x000001, "Wrong alignment on HWPlayerController_Spectator_ServerCycleNextSpectatorTarget");
static_assert(sizeof(HWPlayerController_Spectator_ServerCycleNextSpectatorTarget) == 0x000001, "Wrong size on HWPlayerController_Spectator_ServerCycleNextSpectatorTarget");
static_assert(offsetof(HWPlayerController_Spectator_ServerCycleNextSpectatorTarget, Reverse) == 0x000000, "Member 'HWPlayerController_Spectator_ServerCycleNextSpectatorTarget::Reverse' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.ServerRequestSpectatorTarget
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerController_Spectator_ServerRequestSpectatorTarget final
{
public:
	int32                                         DesiredSpectateIndex;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Spectator_ServerRequestSpectatorTarget) == 0x000004, "Wrong alignment on HWPlayerController_Spectator_ServerRequestSpectatorTarget");
static_assert(sizeof(HWPlayerController_Spectator_ServerRequestSpectatorTarget) == 0x000004, "Wrong size on HWPlayerController_Spectator_ServerRequestSpectatorTarget");
static_assert(offsetof(HWPlayerController_Spectator_ServerRequestSpectatorTarget, DesiredSpectateIndex) == 0x000000, "Member 'HWPlayerController_Spectator_ServerRequestSpectatorTarget::DesiredSpectateIndex' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.ServerRequestSpectatorTargetByPlayerState
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Spectator_ServerRequestSpectatorTargetByPlayerState final
{
public:
	class AHWPlayerState*                         Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Spectator_ServerRequestSpectatorTargetByPlayerState) == 0x000008, "Wrong alignment on HWPlayerController_Spectator_ServerRequestSpectatorTargetByPlayerState");
static_assert(sizeof(HWPlayerController_Spectator_ServerRequestSpectatorTargetByPlayerState) == 0x000008, "Wrong size on HWPlayerController_Spectator_ServerRequestSpectatorTargetByPlayerState");
static_assert(offsetof(HWPlayerController_Spectator_ServerRequestSpectatorTargetByPlayerState, Target) == 0x000000, "Member 'HWPlayerController_Spectator_ServerRequestSpectatorTargetByPlayerState::Target' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.ServerSetCameraFocused
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_Spectator_ServerSetCameraFocused final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Spectator_ServerSetCameraFocused) == 0x000001, "Wrong alignment on HWPlayerController_Spectator_ServerSetCameraFocused");
static_assert(sizeof(HWPlayerController_Spectator_ServerSetCameraFocused) == 0x000001, "Wrong size on HWPlayerController_Spectator_ServerSetCameraFocused");
static_assert(offsetof(HWPlayerController_Spectator_ServerSetCameraFocused, Enabled) == 0x000000, "Member 'HWPlayerController_Spectator_ServerSetCameraFocused::Enabled' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.GetCurrentCameraZoom
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerController_Spectator_GetCurrentCameraZoom final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Spectator_GetCurrentCameraZoom) == 0x000004, "Wrong alignment on HWPlayerController_Spectator_GetCurrentCameraZoom");
static_assert(sizeof(HWPlayerController_Spectator_GetCurrentCameraZoom) == 0x000004, "Wrong size on HWPlayerController_Spectator_GetCurrentCameraZoom");
static_assert(offsetof(HWPlayerController_Spectator_GetCurrentCameraZoom, ReturnValue) == 0x000000, "Member 'HWPlayerController_Spectator_GetCurrentCameraZoom::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.GetTargetPlayerState
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerController_Spectator_GetTargetPlayerState final
{
public:
	class AHWPlayerState*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Spectator_GetTargetPlayerState) == 0x000008, "Wrong alignment on HWPlayerController_Spectator_GetTargetPlayerState");
static_assert(sizeof(HWPlayerController_Spectator_GetTargetPlayerState) == 0x000008, "Wrong size on HWPlayerController_Spectator_GetTargetPlayerState");
static_assert(offsetof(HWPlayerController_Spectator_GetTargetPlayerState, ReturnValue) == 0x000000, "Member 'HWPlayerController_Spectator_GetTargetPlayerState::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.IsCameraFocused
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_Spectator_IsCameraFocused final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Spectator_IsCameraFocused) == 0x000001, "Wrong alignment on HWPlayerController_Spectator_IsCameraFocused");
static_assert(sizeof(HWPlayerController_Spectator_IsCameraFocused) == 0x000001, "Wrong size on HWPlayerController_Spectator_IsCameraFocused");
static_assert(offsetof(HWPlayerController_Spectator_IsCameraFocused, ReturnValue) == 0x000000, "Member 'HWPlayerController_Spectator_IsCameraFocused::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerController_Spectator.IsSpectatingPlayerView
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerController_Spectator_IsSpectatingPlayerView final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerController_Spectator_IsSpectatingPlayerView) == 0x000001, "Wrong alignment on HWPlayerController_Spectator_IsSpectatingPlayerView");
static_assert(sizeof(HWPlayerController_Spectator_IsSpectatingPlayerView) == 0x000001, "Wrong size on HWPlayerController_Spectator_IsSpectatingPlayerView");
static_assert(offsetof(HWPlayerController_Spectator_IsSpectatingPlayerView, ReturnValue) == 0x000000, "Member 'HWPlayerController_Spectator_IsSpectatingPlayerView::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.Multicast_ForceUpdateCharacterPawn
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_Multicast_ForceUpdateCharacterPawn final
{
public:
	class APawn*                                  NewPawn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_Multicast_ForceUpdateCharacterPawn) == 0x000008, "Wrong alignment on HWPlayerState_Multicast_ForceUpdateCharacterPawn");
static_assert(sizeof(HWPlayerState_Multicast_ForceUpdateCharacterPawn) == 0x000008, "Wrong size on HWPlayerState_Multicast_ForceUpdateCharacterPawn");
static_assert(offsetof(HWPlayerState_Multicast_ForceUpdateCharacterPawn, NewPawn) == 0x000000, "Member 'HWPlayerState_Multicast_ForceUpdateCharacterPawn::NewPawn' has a wrong offset!");

// Function Hemingway.HWPlayerState.MulticastReceiveTradeRequestResult
// 0x0018 (0x0018 - 0x0000)
struct HWPlayerState_MulticastReceiveTradeRequestResult final
{
public:
	class AHWPlayerState*                         RequestingPlayerState;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         TargetPlayerState;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWTradeRequestType                           TradeType;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWTradeRequestResult                         TradeResult;                                       // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPGame_ReplicatedTimerId               TimerId;                                           // 0x0012(0x0001)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerState_MulticastReceiveTradeRequestResult) == 0x000008, "Wrong alignment on HWPlayerState_MulticastReceiveTradeRequestResult");
static_assert(sizeof(HWPlayerState_MulticastReceiveTradeRequestResult) == 0x000018, "Wrong size on HWPlayerState_MulticastReceiveTradeRequestResult");
static_assert(offsetof(HWPlayerState_MulticastReceiveTradeRequestResult, RequestingPlayerState) == 0x000000, "Member 'HWPlayerState_MulticastReceiveTradeRequestResult::RequestingPlayerState' has a wrong offset!");
static_assert(offsetof(HWPlayerState_MulticastReceiveTradeRequestResult, TargetPlayerState) == 0x000008, "Member 'HWPlayerState_MulticastReceiveTradeRequestResult::TargetPlayerState' has a wrong offset!");
static_assert(offsetof(HWPlayerState_MulticastReceiveTradeRequestResult, TradeType) == 0x000010, "Member 'HWPlayerState_MulticastReceiveTradeRequestResult::TradeType' has a wrong offset!");
static_assert(offsetof(HWPlayerState_MulticastReceiveTradeRequestResult, TradeResult) == 0x000011, "Member 'HWPlayerState_MulticastReceiveTradeRequestResult::TradeResult' has a wrong offset!");
static_assert(offsetof(HWPlayerState_MulticastReceiveTradeRequestResult, TimerId) == 0x000012, "Member 'HWPlayerState_MulticastReceiveTradeRequestResult::TimerId' has a wrong offset!");

// Function Hemingway.HWPlayerState.OnAutoSkillComponentUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerState_OnAutoSkillComponentUpdated final
{
public:
	class AHWCharacterAbilitySystemActor*         CharAbilitySysActor;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHWAutoSkillComponent*                  AutoSkillComponent;                                // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_OnAutoSkillComponentUpdated) == 0x000008, "Wrong alignment on HWPlayerState_OnAutoSkillComponentUpdated");
static_assert(sizeof(HWPlayerState_OnAutoSkillComponentUpdated) == 0x000010, "Wrong size on HWPlayerState_OnAutoSkillComponentUpdated");
static_assert(offsetof(HWPlayerState_OnAutoSkillComponentUpdated, CharAbilitySysActor) == 0x000000, "Member 'HWPlayerState_OnAutoSkillComponentUpdated::CharAbilitySysActor' has a wrong offset!");
static_assert(offsetof(HWPlayerState_OnAutoSkillComponentUpdated, AutoSkillComponent) == 0x000008, "Member 'HWPlayerState_OnAutoSkillComponentUpdated::AutoSkillComponent' has a wrong offset!");

// Function Hemingway.HWPlayerState.OnGodBuildLoaded
// 0x01A0 (0x01A0 - 0x0000)
struct HWPlayerState_OnGodBuildLoaded final
{
public:
	bool                                          bSuccessfullyRetrieved;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWGodBuild                            GodBuild;                                          // 0x0008(0x0190)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoBuy;                                    // 0x0198(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoSkill;                                  // 0x0199(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A[0x6];                                      // 0x019A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerState_OnGodBuildLoaded) == 0x000008, "Wrong alignment on HWPlayerState_OnGodBuildLoaded");
static_assert(sizeof(HWPlayerState_OnGodBuildLoaded) == 0x0001A0, "Wrong size on HWPlayerState_OnGodBuildLoaded");
static_assert(offsetof(HWPlayerState_OnGodBuildLoaded, bSuccessfullyRetrieved) == 0x000000, "Member 'HWPlayerState_OnGodBuildLoaded::bSuccessfullyRetrieved' has a wrong offset!");
static_assert(offsetof(HWPlayerState_OnGodBuildLoaded, GodBuild) == 0x000008, "Member 'HWPlayerState_OnGodBuildLoaded::GodBuild' has a wrong offset!");
static_assert(offsetof(HWPlayerState_OnGodBuildLoaded, bEnableAutoBuy) == 0x000198, "Member 'HWPlayerState_OnGodBuildLoaded::bEnableAutoBuy' has a wrong offset!");
static_assert(offsetof(HWPlayerState_OnGodBuildLoaded, bEnableAutoSkill) == 0x000199, "Member 'HWPlayerState_OnGodBuildLoaded::bEnableAutoSkill' has a wrong offset!");

// Function Hemingway.HWPlayerState.OnSeamlessTravelStart
// 0x0018 (0x0018 - 0x0000)
struct HWPlayerState_OnSeamlessTravelStart final
{
public:
	class UWorld*                                 CurrentWorld;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_OnSeamlessTravelStart) == 0x000008, "Wrong alignment on HWPlayerState_OnSeamlessTravelStart");
static_assert(sizeof(HWPlayerState_OnSeamlessTravelStart) == 0x000018, "Wrong size on HWPlayerState_OnSeamlessTravelStart");
static_assert(offsetof(HWPlayerState_OnSeamlessTravelStart, CurrentWorld) == 0x000000, "Member 'HWPlayerState_OnSeamlessTravelStart::CurrentWorld' has a wrong offset!");
static_assert(offsetof(HWPlayerState_OnSeamlessTravelStart, LevelName) == 0x000008, "Member 'HWPlayerState_OnSeamlessTravelStart::LevelName' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerAutoUpgradeSystemBuildSelected
// 0x0014 (0x0014 - 0x0000)
struct HWPlayerState_ServerAutoUpgradeSystemBuildSelected final
{
public:
	struct FGuid                                  SelectedBuildId;                                   // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoBuy;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoSkill;                                  // 0x0011(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerState_ServerAutoUpgradeSystemBuildSelected) == 0x000004, "Wrong alignment on HWPlayerState_ServerAutoUpgradeSystemBuildSelected");
static_assert(sizeof(HWPlayerState_ServerAutoUpgradeSystemBuildSelected) == 0x000014, "Wrong size on HWPlayerState_ServerAutoUpgradeSystemBuildSelected");
static_assert(offsetof(HWPlayerState_ServerAutoUpgradeSystemBuildSelected, SelectedBuildId) == 0x000000, "Member 'HWPlayerState_ServerAutoUpgradeSystemBuildSelected::SelectedBuildId' has a wrong offset!");
static_assert(offsetof(HWPlayerState_ServerAutoUpgradeSystemBuildSelected, bEnableAutoBuy) == 0x000010, "Member 'HWPlayerState_ServerAutoUpgradeSystemBuildSelected::bEnableAutoBuy' has a wrong offset!");
static_assert(offsetof(HWPlayerState_ServerAutoUpgradeSystemBuildSelected, bEnableAutoSkill) == 0x000011, "Member 'HWPlayerState_ServerAutoUpgradeSystemBuildSelected::bEnableAutoSkill' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerDeclineCharacterSwap
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_ServerDeclineCharacterSwap final
{
public:
	class AHWPlayerState*                         TargetPlayerState;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerDeclineCharacterSwap) == 0x000008, "Wrong alignment on HWPlayerState_ServerDeclineCharacterSwap");
static_assert(sizeof(HWPlayerState_ServerDeclineCharacterSwap) == 0x000008, "Wrong size on HWPlayerState_ServerDeclineCharacterSwap");
static_assert(offsetof(HWPlayerState_ServerDeclineCharacterSwap, TargetPlayerState) == 0x000000, "Member 'HWPlayerState_ServerDeclineCharacterSwap::TargetPlayerState' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerDeclineRoleSwap
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_ServerDeclineRoleSwap final
{
public:
	class AHWPlayerState*                         TargetPlayerState;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerDeclineRoleSwap) == 0x000008, "Wrong alignment on HWPlayerState_ServerDeclineRoleSwap");
static_assert(sizeof(HWPlayerState_ServerDeclineRoleSwap) == 0x000008, "Wrong size on HWPlayerState_ServerDeclineRoleSwap");
static_assert(offsetof(HWPlayerState_ServerDeclineRoleSwap, TargetPlayerState) == 0x000000, "Member 'HWPlayerState_ServerDeclineRoleSwap::TargetPlayerState' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerRequestCharacterRole
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerState_ServerRequestCharacterRole final
{
public:
	ECharacterRole                                CharacterRole;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerRequestCharacterRole) == 0x000001, "Wrong alignment on HWPlayerState_ServerRequestCharacterRole");
static_assert(sizeof(HWPlayerState_ServerRequestCharacterRole) == 0x000001, "Wrong size on HWPlayerState_ServerRequestCharacterRole");
static_assert(offsetof(HWPlayerState_ServerRequestCharacterRole, CharacterRole) == 0x000000, "Member 'HWPlayerState_ServerRequestCharacterRole::CharacterRole' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerRequestCharacterSwap
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_ServerRequestCharacterSwap final
{
public:
	class AHWPlayerState*                         TargetPlayerState;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerRequestCharacterSwap) == 0x000008, "Wrong alignment on HWPlayerState_ServerRequestCharacterSwap");
static_assert(sizeof(HWPlayerState_ServerRequestCharacterSwap) == 0x000008, "Wrong size on HWPlayerState_ServerRequestCharacterSwap");
static_assert(offsetof(HWPlayerState_ServerRequestCharacterSwap, TargetPlayerState) == 0x000000, "Member 'HWPlayerState_ServerRequestCharacterSwap::TargetPlayerState' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerRequestDraftCharacterChoice
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_ServerRequestDraftCharacterChoice final
{
public:
	const class UHWCharacterItem*                 Choice;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerRequestDraftCharacterChoice) == 0x000008, "Wrong alignment on HWPlayerState_ServerRequestDraftCharacterChoice");
static_assert(sizeof(HWPlayerState_ServerRequestDraftCharacterChoice) == 0x000008, "Wrong size on HWPlayerState_ServerRequestDraftCharacterChoice");
static_assert(offsetof(HWPlayerState_ServerRequestDraftCharacterChoice, Choice) == 0x000000, "Member 'HWPlayerState_ServerRequestDraftCharacterChoice::Choice' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerRequestDraftSkinChoice
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_ServerRequestDraftSkinChoice final
{
public:
	const class UHWSkinItem*                      Choice;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerRequestDraftSkinChoice) == 0x000008, "Wrong alignment on HWPlayerState_ServerRequestDraftSkinChoice");
static_assert(sizeof(HWPlayerState_ServerRequestDraftSkinChoice) == 0x000008, "Wrong size on HWPlayerState_ServerRequestDraftSkinChoice");
static_assert(offsetof(HWPlayerState_ServerRequestDraftSkinChoice, Choice) == 0x000000, "Member 'HWPlayerState_ServerRequestDraftSkinChoice::Choice' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerRequestRoleSwap
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_ServerRequestRoleSwap final
{
public:
	class AHWPlayerState*                         TargetPlayerState;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerRequestRoleSwap) == 0x000008, "Wrong alignment on HWPlayerState_ServerRequestRoleSwap");
static_assert(sizeof(HWPlayerState_ServerRequestRoleSwap) == 0x000008, "Wrong size on HWPlayerState_ServerRequestRoleSwap");
static_assert(offsetof(HWPlayerState_ServerRequestRoleSwap, TargetPlayerState) == 0x000000, "Member 'HWPlayerState_ServerRequestRoleSwap::TargetPlayerState' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerSetAbilityCastStyle
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerState_ServerSetAbilityCastStyle final
{
public:
	EAbilityCastStyle                             DesiredCastStyle;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerSetAbilityCastStyle) == 0x000001, "Wrong alignment on HWPlayerState_ServerSetAbilityCastStyle");
static_assert(sizeof(HWPlayerState_ServerSetAbilityCastStyle) == 0x000001, "Wrong size on HWPlayerState_ServerSetAbilityCastStyle");
static_assert(offsetof(HWPlayerState_ServerSetAbilityCastStyle, DesiredCastStyle) == 0x000000, "Member 'HWPlayerState_ServerSetAbilityCastStyle::DesiredCastStyle' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerSetClientLoadedStatus
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerState_ServerSetClientLoadedStatus final
{
public:
	EHWClientLoadState                            ClientLoadState;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerSetClientLoadedStatus) == 0x000001, "Wrong alignment on HWPlayerState_ServerSetClientLoadedStatus");
static_assert(sizeof(HWPlayerState_ServerSetClientLoadedStatus) == 0x000001, "Wrong size on HWPlayerState_ServerSetClientLoadedStatus");
static_assert(offsetof(HWPlayerState_ServerSetClientLoadedStatus, ClientLoadState) == 0x000000, "Member 'HWPlayerState_ServerSetClientLoadedStatus::ClientLoadState' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerSetDoubleTapToFireSetting
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerState_ServerSetDoubleTapToFireSetting final
{
public:
	int32                                         DesiredDoubleTapToFireSettingValue;                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerSetDoubleTapToFireSetting) == 0x000004, "Wrong alignment on HWPlayerState_ServerSetDoubleTapToFireSetting");
static_assert(sizeof(HWPlayerState_ServerSetDoubleTapToFireSetting) == 0x000004, "Wrong size on HWPlayerState_ServerSetDoubleTapToFireSetting");
static_assert(offsetof(HWPlayerState_ServerSetDoubleTapToFireSetting, DesiredDoubleTapToFireSettingValue) == 0x000000, "Member 'HWPlayerState_ServerSetDoubleTapToFireSetting::DesiredDoubleTapToFireSettingValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerSetupManualBuild
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerState_ServerSetupManualBuild final
{
public:
	bool                                          bEnableAutoSkill;                                  // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerSetupManualBuild) == 0x000001, "Wrong alignment on HWPlayerState_ServerSetupManualBuild");
static_assert(sizeof(HWPlayerState_ServerSetupManualBuild) == 0x000001, "Wrong size on HWPlayerState_ServerSetupManualBuild");
static_assert(offsetof(HWPlayerState_ServerSetupManualBuild, bEnableAutoSkill) == 0x000000, "Member 'HWPlayerState_ServerSetupManualBuild::bEnableAutoSkill' has a wrong offset!");

// Function Hemingway.HWPlayerState.SetAbilitySystemActor
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_SetAbilitySystemActor final
{
public:
	class AHWCharacterAbilitySystemActor*         NewActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_SetAbilitySystemActor) == 0x000008, "Wrong alignment on HWPlayerState_SetAbilitySystemActor");
static_assert(sizeof(HWPlayerState_SetAbilitySystemActor) == 0x000008, "Wrong size on HWPlayerState_SetAbilitySystemActor");
static_assert(offsetof(HWPlayerState_SetAbilitySystemActor, NewActor) == 0x000000, "Member 'HWPlayerState_SetAbilitySystemActor::NewActor' has a wrong offset!");

// Function Hemingway.HWPlayerState.SetDraftCharacterChoice
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_SetDraftCharacterChoice final
{
public:
	const class UHWCharacterItem*                 NewChoice;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_SetDraftCharacterChoice) == 0x000008, "Wrong alignment on HWPlayerState_SetDraftCharacterChoice");
static_assert(sizeof(HWPlayerState_SetDraftCharacterChoice) == 0x000008, "Wrong size on HWPlayerState_SetDraftCharacterChoice");
static_assert(offsetof(HWPlayerState_SetDraftCharacterChoice, NewChoice) == 0x000000, "Member 'HWPlayerState_SetDraftCharacterChoice::NewChoice' has a wrong offset!");

// Function Hemingway.HWPlayerState.SetSkillRatingDelta
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerState_SetSkillRatingDelta final
{
public:
	int32                                         InSkillRatingDelta;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_SetSkillRatingDelta) == 0x000004, "Wrong alignment on HWPlayerState_SetSkillRatingDelta");
static_assert(sizeof(HWPlayerState_SetSkillRatingDelta) == 0x000004, "Wrong size on HWPlayerState_SetSkillRatingDelta");
static_assert(offsetof(HWPlayerState_SetSkillRatingDelta, InSkillRatingDelta) == 0x000000, "Member 'HWPlayerState_SetSkillRatingDelta::InSkillRatingDelta' has a wrong offset!");

// Function Hemingway.HWPlayerState.SetStartingSkillRating
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerState_SetStartingSkillRating final
{
public:
	int32                                         InStartingSkillRating;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_SetStartingSkillRating) == 0x000004, "Wrong alignment on HWPlayerState_SetStartingSkillRating");
static_assert(sizeof(HWPlayerState_SetStartingSkillRating) == 0x000004, "Wrong size on HWPlayerState_SetStartingSkillRating");
static_assert(offsetof(HWPlayerState_SetStartingSkillRating, InStartingSkillRating) == 0x000000, "Member 'HWPlayerState_SetStartingSkillRating::InStartingSkillRating' has a wrong offset!");

// Function Hemingway.HWPlayerState.CanRequestTradeWith
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerState_CanRequestTradeWith final
{
public:
	const class AHWPlayerState*                   TradeTarget;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerState_CanRequestTradeWith) == 0x000008, "Wrong alignment on HWPlayerState_CanRequestTradeWith");
static_assert(sizeof(HWPlayerState_CanRequestTradeWith) == 0x000010, "Wrong size on HWPlayerState_CanRequestTradeWith");
static_assert(offsetof(HWPlayerState_CanRequestTradeWith, TradeTarget) == 0x000000, "Member 'HWPlayerState_CanRequestTradeWith::TradeTarget' has a wrong offset!");
static_assert(offsetof(HWPlayerState_CanRequestTradeWith, ReturnValue) == 0x000008, "Member 'HWPlayerState_CanRequestTradeWith::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetAbilityCastStyle
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerState_GetAbilityCastStyle final
{
public:
	EAbilityCastStyle                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetAbilityCastStyle) == 0x000001, "Wrong alignment on HWPlayerState_GetAbilityCastStyle");
static_assert(sizeof(HWPlayerState_GetAbilityCastStyle) == 0x000001, "Wrong size on HWPlayerState_GetAbilityCastStyle");
static_assert(offsetof(HWPlayerState_GetAbilityCastStyle, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetAbilityCastStyle::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_GetAbilitySystemComponent final
{
public:
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetAbilitySystemComponent) == 0x000008, "Wrong alignment on HWPlayerState_GetAbilitySystemComponent");
static_assert(sizeof(HWPlayerState_GetAbilitySystemComponent) == 0x000008, "Wrong size on HWPlayerState_GetAbilitySystemComponent");
static_assert(offsetof(HWPlayerState_GetAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetActorBase
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_GetActorBase final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetActorBase) == 0x000008, "Wrong alignment on HWPlayerState_GetActorBase");
static_assert(sizeof(HWPlayerState_GetActorBase) == 0x000008, "Wrong size on HWPlayerState_GetActorBase");
static_assert(offsetof(HWPlayerState_GetActorBase, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetActorBase::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetAllPlayedRoles
// 0x0020 (0x0020 - 0x0000)
struct HWPlayerState_GetAllPlayedRoles final
{
public:
	struct FHWAssignedRolesMapWrapper             ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetAllPlayedRoles) == 0x000008, "Wrong alignment on HWPlayerState_GetAllPlayedRoles");
static_assert(sizeof(HWPlayerState_GetAllPlayedRoles) == 0x000020, "Wrong size on HWPlayerState_GetAllPlayedRoles");
static_assert(offsetof(HWPlayerState_GetAllPlayedRoles, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetAllPlayedRoles::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetAssignedRole
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerState_GetAssignedRole final
{
public:
	ECharacterRole                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetAssignedRole) == 0x000001, "Wrong alignment on HWPlayerState_GetAssignedRole");
static_assert(sizeof(HWPlayerState_GetAssignedRole) == 0x000001, "Wrong size on HWPlayerState_GetAssignedRole");
static_assert(offsetof(HWPlayerState_GetAssignedRole, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetAssignedRole::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetCharacterAbilitySystemActor
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_GetCharacterAbilitySystemActor final
{
public:
	class AHWCharacterAbilitySystemActor*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetCharacterAbilitySystemActor) == 0x000008, "Wrong alignment on HWPlayerState_GetCharacterAbilitySystemActor");
static_assert(sizeof(HWPlayerState_GetCharacterAbilitySystemActor) == 0x000008, "Wrong size on HWPlayerState_GetCharacterAbilitySystemActor");
static_assert(offsetof(HWPlayerState_GetCharacterAbilitySystemActor, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetCharacterAbilitySystemActor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetCharacterBase
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_GetCharacterBase final
{
public:
	class AHWCharacter_Base*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetCharacterBase) == 0x000008, "Wrong alignment on HWPlayerState_GetCharacterBase");
static_assert(sizeof(HWPlayerState_GetCharacterBase) == 0x000008, "Wrong size on HWPlayerState_GetCharacterBase");
static_assert(offsetof(HWPlayerState_GetCharacterBase, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetCharacterBase::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetDraftCharacterChoice
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_GetDraftCharacterChoice final
{
public:
	const class UHWCharacterItem*                 ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetDraftCharacterChoice) == 0x000008, "Wrong alignment on HWPlayerState_GetDraftCharacterChoice");
static_assert(sizeof(HWPlayerState_GetDraftCharacterChoice) == 0x000008, "Wrong size on HWPlayerState_GetDraftCharacterChoice");
static_assert(offsetof(HWPlayerState_GetDraftCharacterChoice, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetDraftCharacterChoice::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetHWAbilitySystemComponent
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_GetHWAbilitySystemComponent final
{
public:
	class UHWAbilitySystemComponent*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetHWAbilitySystemComponent) == 0x000008, "Wrong alignment on HWPlayerState_GetHWAbilitySystemComponent");
static_assert(sizeof(HWPlayerState_GetHWAbilitySystemComponent) == 0x000008, "Wrong size on HWPlayerState_GetHWAbilitySystemComponent");
static_assert(offsetof(HWPlayerState_GetHWAbilitySystemComponent, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetHWAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetIsOvertakenByAI
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerState_GetIsOvertakenByAI final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetIsOvertakenByAI) == 0x000001, "Wrong alignment on HWPlayerState_GetIsOvertakenByAI");
static_assert(sizeof(HWPlayerState_GetIsOvertakenByAI) == 0x000001, "Wrong size on HWPlayerState_GetIsOvertakenByAI");
static_assert(offsetof(HWPlayerState_GetIsOvertakenByAI, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetIsOvertakenByAI::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetLastTradeResultReceived
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerState_GetLastTradeResultReceived final
{
public:
	EHWTradeRequestResult                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetLastTradeResultReceived) == 0x000001, "Wrong alignment on HWPlayerState_GetLastTradeResultReceived");
static_assert(sizeof(HWPlayerState_GetLastTradeResultReceived) == 0x000001, "Wrong size on HWPlayerState_GetLastTradeResultReceived");
static_assert(offsetof(HWPlayerState_GetLastTradeResultReceived, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetLastTradeResultReceived::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetPersistentPlayerId
// 0x0020 (0x0020 - 0x0000)
struct HWPlayerState_GetPersistentPlayerId final
{
public:
	struct FHWPersistentPlayerId                  ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetPersistentPlayerId) == 0x000004, "Wrong alignment on HWPlayerState_GetPersistentPlayerId");
static_assert(sizeof(HWPlayerState_GetPersistentPlayerId) == 0x000020, "Wrong size on HWPlayerState_GetPersistentPlayerId");
static_assert(offsetof(HWPlayerState_GetPersistentPlayerId, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetPersistentPlayerId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetPlayerStatsTracker
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_GetPlayerStatsTracker final
{
public:
	class AHWPlayerStatsTracker*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetPlayerStatsTracker) == 0x000008, "Wrong alignment on HWPlayerState_GetPlayerStatsTracker");
static_assert(sizeof(HWPlayerState_GetPlayerStatsTracker) == 0x000008, "Wrong size on HWPlayerState_GetPlayerStatsTracker");
static_assert(offsetof(HWPlayerState_GetPlayerStatsTracker, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetPlayerStatsTracker::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetRankData
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_GetRankData final
{
public:
	struct FHWRankData                            ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetRankData) == 0x000004, "Wrong alignment on HWPlayerState_GetRankData");
static_assert(sizeof(HWPlayerState_GetRankData) == 0x000008, "Wrong size on HWPlayerState_GetRankData");
static_assert(offsetof(HWPlayerState_GetRankData, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetRankData::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetSkillRatingDelta
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerState_GetSkillRatingDelta final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetSkillRatingDelta) == 0x000004, "Wrong alignment on HWPlayerState_GetSkillRatingDelta");
static_assert(sizeof(HWPlayerState_GetSkillRatingDelta) == 0x000004, "Wrong size on HWPlayerState_GetSkillRatingDelta");
static_assert(offsetof(HWPlayerState_GetSkillRatingDelta, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetSkillRatingDelta::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetStartingSkillRating
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerState_GetStartingSkillRating final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetStartingSkillRating) == 0x000004, "Wrong alignment on HWPlayerState_GetStartingSkillRating");
static_assert(sizeof(HWPlayerState_GetStartingSkillRating) == 0x000004, "Wrong size on HWPlayerState_GetStartingSkillRating");
static_assert(offsetof(HWPlayerState_GetStartingSkillRating, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetStartingSkillRating::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.GetTeam
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerState_GetTeam final
{
public:
	class AHWTeamState*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_GetTeam) == 0x000008, "Wrong alignment on HWPlayerState_GetTeam");
static_assert(sizeof(HWPlayerState_GetTeam) == 0x000008, "Wrong size on HWPlayerState_GetTeam");
static_assert(offsetof(HWPlayerState_GetTeam, ReturnValue) == 0x000000, "Member 'HWPlayerState_GetTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.IsJumpDisabled
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerState_IsJumpDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_IsJumpDisabled) == 0x000001, "Wrong alignment on HWPlayerState_IsJumpDisabled");
static_assert(sizeof(HWPlayerState_IsJumpDisabled) == 0x000001, "Wrong size on HWPlayerState_IsJumpDisabled");
static_assert(offsetof(HWPlayerState_IsJumpDisabled, ReturnValue) == 0x000000, "Member 'HWPlayerState_IsJumpDisabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.IsUIRelevant
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerState_IsUIRelevant final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_IsUIRelevant) == 0x000001, "Wrong alignment on HWPlayerState_IsUIRelevant");
static_assert(sizeof(HWPlayerState_IsUIRelevant) == 0x000001, "Wrong size on HWPlayerState_IsUIRelevant");
static_assert(offsetof(HWPlayerState_IsUIRelevant, ReturnValue) == 0x000000, "Member 'HWPlayerState_IsUIRelevant::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.MatchesPersistentPlayerId
// 0x0024 (0x0024 - 0x0000)
struct HWPlayerState_MatchesPersistentPlayerId final
{
public:
	struct FHWPersistentPlayerId                  ComparisonId;                                      // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerState_MatchesPersistentPlayerId) == 0x000004, "Wrong alignment on HWPlayerState_MatchesPersistentPlayerId");
static_assert(sizeof(HWPlayerState_MatchesPersistentPlayerId) == 0x000024, "Wrong size on HWPlayerState_MatchesPersistentPlayerId");
static_assert(offsetof(HWPlayerState_MatchesPersistentPlayerId, ComparisonId) == 0x000000, "Member 'HWPlayerState_MatchesPersistentPlayerId::ComparisonId' has a wrong offset!");
static_assert(offsetof(HWPlayerState_MatchesPersistentPlayerId, ReturnValue) == 0x000020, "Member 'HWPlayerState_MatchesPersistentPlayerId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerState.ServerSendChatEntry
// 0x0060 (0x0060 - 0x0000)
struct HWPlayerState_ServerSendChatEntry final
{
public:
	struct FHWChatEntry                           ChatEntry;                                         // 0x0000(0x0060)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerState_ServerSendChatEntry) == 0x000008, "Wrong alignment on HWPlayerState_ServerSendChatEntry");
static_assert(sizeof(HWPlayerState_ServerSendChatEntry) == 0x000060, "Wrong size on HWPlayerState_ServerSendChatEntry");
static_assert(offsetof(HWPlayerState_ServerSendChatEntry, ChatEntry) == 0x000000, "Member 'HWPlayerState_ServerSendChatEntry::ChatEntry' has a wrong offset!");

// Function Hemingway.HWQuestSubsystem.GetQuestTierByCount
// 0x0018 (0x0018 - 0x0000)
struct HWQuestSubsystem_GetQuestTierByCount final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWQuest*                         QuestItem;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressCount;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuestSubsystem_GetQuestTierByCount) == 0x000008, "Wrong alignment on HWQuestSubsystem_GetQuestTierByCount");
static_assert(sizeof(HWQuestSubsystem_GetQuestTierByCount) == 0x000018, "Wrong size on HWQuestSubsystem_GetQuestTierByCount");
static_assert(offsetof(HWQuestSubsystem_GetQuestTierByCount, WorldContextObject) == 0x000000, "Member 'HWQuestSubsystem_GetQuestTierByCount::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_GetQuestTierByCount, QuestItem) == 0x000008, "Member 'HWQuestSubsystem_GetQuestTierByCount::QuestItem' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_GetQuestTierByCount, ProgressCount) == 0x000010, "Member 'HWQuestSubsystem_GetQuestTierByCount::ProgressCount' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_GetQuestTierByCount, ReturnValue) == 0x000014, "Member 'HWQuestSubsystem_GetQuestTierByCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQuestSubsystem.InitializeQuestsForPlayer
// 0x0008 (0x0008 - 0x0000)
struct HWQuestSubsystem_InitializeQuestsForPlayer final
{
public:
	class AHWPlayerState*                         Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuestSubsystem_InitializeQuestsForPlayer) == 0x000008, "Wrong alignment on HWQuestSubsystem_InitializeQuestsForPlayer");
static_assert(sizeof(HWQuestSubsystem_InitializeQuestsForPlayer) == 0x000008, "Wrong size on HWQuestSubsystem_InitializeQuestsForPlayer");
static_assert(offsetof(HWQuestSubsystem_InitializeQuestsForPlayer, Player) == 0x000000, "Member 'HWQuestSubsystem_InitializeQuestsForPlayer::Player' has a wrong offset!");

// Function Hemingway.HWQuestSubsystem.OnInventoryCachedForPlayer
// 0x0001 (0x0001 - 0x0000)
struct HWQuestSubsystem_OnInventoryCachedForPlayer final
{
public:
	bool                                          bSuccessfullyLoaded;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuestSubsystem_OnInventoryCachedForPlayer) == 0x000001, "Wrong alignment on HWQuestSubsystem_OnInventoryCachedForPlayer");
static_assert(sizeof(HWQuestSubsystem_OnInventoryCachedForPlayer) == 0x000001, "Wrong size on HWQuestSubsystem_OnInventoryCachedForPlayer");
static_assert(offsetof(HWQuestSubsystem_OnInventoryCachedForPlayer, bSuccessfullyLoaded) == 0x000000, "Member 'HWQuestSubsystem_OnInventoryCachedForPlayer::bSuccessfullyLoaded' has a wrong offset!");

// Function Hemingway.HWQuestSubsystem.OnRHSessionChanged
// 0x0010 (0x0010 - 0x0000)
struct HWQuestSubsystem_OnRHSessionChanged final
{
public:
	class URH_JoinedSession*                      OldSession;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_JoinedSession*                      ActiveSession;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuestSubsystem_OnRHSessionChanged) == 0x000008, "Wrong alignment on HWQuestSubsystem_OnRHSessionChanged");
static_assert(sizeof(HWQuestSubsystem_OnRHSessionChanged) == 0x000010, "Wrong size on HWQuestSubsystem_OnRHSessionChanged");
static_assert(offsetof(HWQuestSubsystem_OnRHSessionChanged, OldSession) == 0x000000, "Member 'HWQuestSubsystem_OnRHSessionChanged::OldSession' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_OnRHSessionChanged, ActiveSession) == 0x000008, "Member 'HWQuestSubsystem_OnRHSessionChanged::ActiveSession' has a wrong offset!");

// Function Hemingway.HWQuestSubsystem.QueueNewQuestInventoryRequest
// 0x0018 (0x0018 - 0x0000)
struct HWQuestSubsystem_QueueNewQuestInventoryRequest final
{
public:
	struct FGuid                                  RHPlayerId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_PlayerOrderEntry*                   RHPlayerOrder;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuestSubsystem_QueueNewQuestInventoryRequest) == 0x000008, "Wrong alignment on HWQuestSubsystem_QueueNewQuestInventoryRequest");
static_assert(sizeof(HWQuestSubsystem_QueueNewQuestInventoryRequest) == 0x000018, "Wrong size on HWQuestSubsystem_QueueNewQuestInventoryRequest");
static_assert(offsetof(HWQuestSubsystem_QueueNewQuestInventoryRequest, RHPlayerId) == 0x000000, "Member 'HWQuestSubsystem_QueueNewQuestInventoryRequest::RHPlayerId' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_QueueNewQuestInventoryRequest, RHPlayerOrder) == 0x000010, "Member 'HWQuestSubsystem_QueueNewQuestInventoryRequest::RHPlayerOrder' has a wrong offset!");

// Function Hemingway.HWQuestSubsystem.QueueNewQuestInventoryRequests
// 0x0020 (0x0020 - 0x0000)
struct HWQuestSubsystem_QueueNewQuestInventoryRequests final
{
public:
	struct FGuid                                  RHPlayerId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URH_PlayerOrderEntry*>           RHPlayerOrders;                                    // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuestSubsystem_QueueNewQuestInventoryRequests) == 0x000008, "Wrong alignment on HWQuestSubsystem_QueueNewQuestInventoryRequests");
static_assert(sizeof(HWQuestSubsystem_QueueNewQuestInventoryRequests) == 0x000020, "Wrong size on HWQuestSubsystem_QueueNewQuestInventoryRequests");
static_assert(offsetof(HWQuestSubsystem_QueueNewQuestInventoryRequests, RHPlayerId) == 0x000000, "Member 'HWQuestSubsystem_QueueNewQuestInventoryRequests::RHPlayerId' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_QueueNewQuestInventoryRequests, RHPlayerOrders) == 0x000010, "Member 'HWQuestSubsystem_QueueNewQuestInventoryRequests::RHPlayerOrders' has a wrong offset!");

// Function Hemingway.HWQuestSubsystem.FindGodQuestEntry
// 0x00C8 (0x00C8 - 0x0000)
struct HWQuestSubsystem_FindGodQuestEntry final
{
public:
	struct FGodQuestEntry                         OutGodQuestEntry;                                  // 0x0000(0x00B0)(Parm, OutParm, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 CharacterItem;                                     // 0x00B0(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWQuest*                         QuestItem;                                         // 0x00B8(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQuestSubsystem_FindGodQuestEntry) == 0x000008, "Wrong alignment on HWQuestSubsystem_FindGodQuestEntry");
static_assert(sizeof(HWQuestSubsystem_FindGodQuestEntry) == 0x0000C8, "Wrong size on HWQuestSubsystem_FindGodQuestEntry");
static_assert(offsetof(HWQuestSubsystem_FindGodQuestEntry, OutGodQuestEntry) == 0x000000, "Member 'HWQuestSubsystem_FindGodQuestEntry::OutGodQuestEntry' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_FindGodQuestEntry, CharacterItem) == 0x0000B0, "Member 'HWQuestSubsystem_FindGodQuestEntry::CharacterItem' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_FindGodQuestEntry, QuestItem) == 0x0000B8, "Member 'HWQuestSubsystem_FindGodQuestEntry::QuestItem' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_FindGodQuestEntry, ReturnValue) == 0x0000C0, "Member 'HWQuestSubsystem_FindGodQuestEntry::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQuestSubsystem.GetQuest
// 0x0028 (0x0028 - 0x0000)
struct HWQuestSubsystem_GetQuest final
{
public:
	struct FRH_ItemId                             QuestItemId;                                       // 0x0000(0x0014)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWCharacterItem*                 CharacterItem;                                     // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWQuest*                         ReturnValue;                                       // 0x0020(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuestSubsystem_GetQuest) == 0x000008, "Wrong alignment on HWQuestSubsystem_GetQuest");
static_assert(sizeof(HWQuestSubsystem_GetQuest) == 0x000028, "Wrong size on HWQuestSubsystem_GetQuest");
static_assert(offsetof(HWQuestSubsystem_GetQuest, QuestItemId) == 0x000000, "Member 'HWQuestSubsystem_GetQuest::QuestItemId' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_GetQuest, CharacterItem) == 0x000018, "Member 'HWQuestSubsystem_GetQuest::CharacterItem' has a wrong offset!");
static_assert(offsetof(HWQuestSubsystem_GetQuest, ReturnValue) == 0x000020, "Member 'HWQuestSubsystem_GetQuest::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQuest_BotProficiency.GamePhaseEnded
// 0x0008 (0x0008 - 0x0000)
struct HWQuest_BotProficiency_GamePhaseEnded final
{
public:
	struct FGameplayTag                           EndingPhaseTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_BotProficiency_GamePhaseEnded) == 0x000004, "Wrong alignment on HWQuest_BotProficiency_GamePhaseEnded");
static_assert(sizeof(HWQuest_BotProficiency_GamePhaseEnded) == 0x000008, "Wrong size on HWQuest_BotProficiency_GamePhaseEnded");
static_assert(offsetof(HWQuest_BotProficiency_GamePhaseEnded, EndingPhaseTag) == 0x000000, "Member 'HWQuest_BotProficiency_GamePhaseEnded::EndingPhaseTag' has a wrong offset!");

// Function Hemingway.HWQuest_BotProficiency.GetBotProficiencyFor
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_BotProficiency_GetBotProficiencyFor final
{
public:
	const class AHWPlayerController*              TrackedPlayer;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQuest_BotProficiency_GetBotProficiencyFor) == 0x000008, "Wrong alignment on HWQuest_BotProficiency_GetBotProficiencyFor");
static_assert(sizeof(HWQuest_BotProficiency_GetBotProficiencyFor) == 0x000010, "Wrong size on HWQuest_BotProficiency_GetBotProficiencyFor");
static_assert(offsetof(HWQuest_BotProficiency_GetBotProficiencyFor, TrackedPlayer) == 0x000000, "Member 'HWQuest_BotProficiency_GetBotProficiencyFor::TrackedPlayer' has a wrong offset!");
static_assert(offsetof(HWQuest_BotProficiency_GetBotProficiencyFor, ReturnValue) == 0x000008, "Member 'HWQuest_BotProficiency_GetBotProficiencyFor::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQuest_BotProficiency.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_BotProficiency_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_BotProficiency_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_BotProficiency_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_BotProficiency_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_BotProficiency_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_BotProficiency_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_BotProficiency_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_BotProficiency_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_BotProficiency_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWQuest_KillsByType.OnPlayerAssistGranted
// 0x0020 (0x0020 - 0x0000)
struct HWQuest_KillsByType_OnPlayerAssistGranted final
{
public:
	struct FAssistEventData                       AssistEventData;                                   // 0x0000(0x0020)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_KillsByType_OnPlayerAssistGranted) == 0x000008, "Wrong alignment on HWQuest_KillsByType_OnPlayerAssistGranted");
static_assert(sizeof(HWQuest_KillsByType_OnPlayerAssistGranted) == 0x000020, "Wrong size on HWQuest_KillsByType_OnPlayerAssistGranted");
static_assert(offsetof(HWQuest_KillsByType_OnPlayerAssistGranted, AssistEventData) == 0x000000, "Member 'HWQuest_KillsByType_OnPlayerAssistGranted::AssistEventData' has a wrong offset!");

// Function Hemingway.HWQuest_KillsByType.OnPlayerKillGranted
// 0x0070 (0x0070 - 0x0000)
struct HWQuest_KillsByType_OnPlayerKillGranted final
{
public:
	struct FDamageEventData                       KillEventData;                                     // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_KillsByType_OnPlayerKillGranted) == 0x000008, "Wrong alignment on HWQuest_KillsByType_OnPlayerKillGranted");
static_assert(sizeof(HWQuest_KillsByType_OnPlayerKillGranted) == 0x000070, "Wrong size on HWQuest_KillsByType_OnPlayerKillGranted");
static_assert(offsetof(HWQuest_KillsByType_OnPlayerKillGranted, KillEventData) == 0x000000, "Member 'HWQuest_KillsByType_OnPlayerKillGranted::KillEventData' has a wrong offset!");

// Function Hemingway.HWQuest_KillsByType.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_KillsByType_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_KillsByType_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_KillsByType_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_KillsByType_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_KillsByType_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_KillsByType_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_KillsByType_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_KillsByType_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_KillsByType_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWQuest_LastPlayerAlive.OnPlayerDied
// 0x0070 (0x0070 - 0x0000)
struct HWQuest_LastPlayerAlive_OnPlayerDied final
{
public:
	struct FDamageEventData                       KillEventData;                                     // 0x0000(0x0070)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_LastPlayerAlive_OnPlayerDied) == 0x000008, "Wrong alignment on HWQuest_LastPlayerAlive_OnPlayerDied");
static_assert(sizeof(HWQuest_LastPlayerAlive_OnPlayerDied) == 0x000070, "Wrong size on HWQuest_LastPlayerAlive_OnPlayerDied");
static_assert(offsetof(HWQuest_LastPlayerAlive_OnPlayerDied, KillEventData) == 0x000000, "Member 'HWQuest_LastPlayerAlive_OnPlayerDied::KillEventData' has a wrong offset!");

// Function Hemingway.HWQuest_LastPlayerAlive.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_LastPlayerAlive_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_LastPlayerAlive_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_LastPlayerAlive_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_LastPlayerAlive_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_LastPlayerAlive_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_LastPlayerAlive_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_LastPlayerAlive_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_LastPlayerAlive_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_LastPlayerAlive_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWQuest_MatchesCompleteMinLevel.GamePhaseEnded
// 0x0008 (0x0008 - 0x0000)
struct HWQuest_MatchesCompleteMinLevel_GamePhaseEnded final
{
public:
	struct FGameplayTag                           EndingPhaseTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_MatchesCompleteMinLevel_GamePhaseEnded) == 0x000004, "Wrong alignment on HWQuest_MatchesCompleteMinLevel_GamePhaseEnded");
static_assert(sizeof(HWQuest_MatchesCompleteMinLevel_GamePhaseEnded) == 0x000008, "Wrong size on HWQuest_MatchesCompleteMinLevel_GamePhaseEnded");
static_assert(offsetof(HWQuest_MatchesCompleteMinLevel_GamePhaseEnded, EndingPhaseTag) == 0x000000, "Member 'HWQuest_MatchesCompleteMinLevel_GamePhaseEnded::EndingPhaseTag' has a wrong offset!");

// Function Hemingway.HWQuest_MatchesCompleteMinLevel.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_MatchesCompleteMinLevel_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_MatchesCompleteMinLevel_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_MatchesCompleteMinLevel_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_MatchesCompleteMinLevel_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_MatchesCompleteMinLevel_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_MatchesCompleteMinLevel_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_MatchesCompleteMinLevel_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_MatchesCompleteMinLevel_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_MatchesCompleteMinLevel_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWQuest_MatchesPlayedInRole.GamePhaseEnded
// 0x0008 (0x0008 - 0x0000)
struct HWQuest_MatchesPlayedInRole_GamePhaseEnded final
{
public:
	struct FGameplayTag                           EndingPhaseTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_MatchesPlayedInRole_GamePhaseEnded) == 0x000004, "Wrong alignment on HWQuest_MatchesPlayedInRole_GamePhaseEnded");
static_assert(sizeof(HWQuest_MatchesPlayedInRole_GamePhaseEnded) == 0x000008, "Wrong size on HWQuest_MatchesPlayedInRole_GamePhaseEnded");
static_assert(offsetof(HWQuest_MatchesPlayedInRole_GamePhaseEnded, EndingPhaseTag) == 0x000000, "Member 'HWQuest_MatchesPlayedInRole_GamePhaseEnded::EndingPhaseTag' has a wrong offset!");

// Function Hemingway.HWQuest_MatchesPlayedInRole.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_MatchesPlayedInRole_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_MatchesPlayedInRole_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_MatchesPlayedInRole_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_MatchesPlayedInRole_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_MatchesPlayedInRole_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_MatchesPlayedInRole_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_MatchesPlayedInRole_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_MatchesPlayedInRole_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_MatchesPlayedInRole_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWQuest_TimeInMatch.CalculateNumberOfPointsToAward
// 0x000C (0x000C - 0x0000)
struct HWQuest_TimeInMatch_CalculateNumberOfPointsToAward final
{
public:
	float                                         TimeInMatch;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWon;                                              // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TimeInMatch_CalculateNumberOfPointsToAward) == 0x000004, "Wrong alignment on HWQuest_TimeInMatch_CalculateNumberOfPointsToAward");
static_assert(sizeof(HWQuest_TimeInMatch_CalculateNumberOfPointsToAward) == 0x00000C, "Wrong size on HWQuest_TimeInMatch_CalculateNumberOfPointsToAward");
static_assert(offsetof(HWQuest_TimeInMatch_CalculateNumberOfPointsToAward, TimeInMatch) == 0x000000, "Member 'HWQuest_TimeInMatch_CalculateNumberOfPointsToAward::TimeInMatch' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeInMatch_CalculateNumberOfPointsToAward, bWon) == 0x000004, "Member 'HWQuest_TimeInMatch_CalculateNumberOfPointsToAward::bWon' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeInMatch_CalculateNumberOfPointsToAward, ReturnValue) == 0x000008, "Member 'HWQuest_TimeInMatch_CalculateNumberOfPointsToAward::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQuest_TimeInMatch.GamePhaseEnded
// 0x0008 (0x0008 - 0x0000)
struct HWQuest_TimeInMatch_GamePhaseEnded final
{
public:
	struct FGameplayTag                           EndingPhaseTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TimeInMatch_GamePhaseEnded) == 0x000004, "Wrong alignment on HWQuest_TimeInMatch_GamePhaseEnded");
static_assert(sizeof(HWQuest_TimeInMatch_GamePhaseEnded) == 0x000008, "Wrong size on HWQuest_TimeInMatch_GamePhaseEnded");
static_assert(offsetof(HWQuest_TimeInMatch_GamePhaseEnded, EndingPhaseTag) == 0x000000, "Member 'HWQuest_TimeInMatch_GamePhaseEnded::EndingPhaseTag' has a wrong offset!");

// Function Hemingway.HWQuest_TimeInMatch.TrackQuestForPlayer_Implementation
// 0x0010 (0x0010 - 0x0000)
struct HWQuest_TimeInMatch_TrackQuestForPlayer_Implementation final
{
public:
	const class UHWQuest*                         TrackedQuest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWCharacterAbilitySystemActor*         CharAbSysActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQuest_TimeInMatch_TrackQuestForPlayer_Implementation) == 0x000008, "Wrong alignment on HWQuest_TimeInMatch_TrackQuestForPlayer_Implementation");
static_assert(sizeof(HWQuest_TimeInMatch_TrackQuestForPlayer_Implementation) == 0x000010, "Wrong size on HWQuest_TimeInMatch_TrackQuestForPlayer_Implementation");
static_assert(offsetof(HWQuest_TimeInMatch_TrackQuestForPlayer_Implementation, TrackedQuest) == 0x000000, "Member 'HWQuest_TimeInMatch_TrackQuestForPlayer_Implementation::TrackedQuest' has a wrong offset!");
static_assert(offsetof(HWQuest_TimeInMatch_TrackQuestForPlayer_Implementation, CharAbSysActor) == 0x000008, "Member 'HWQuest_TimeInMatch_TrackQuestForPlayer_Implementation::CharAbSysActor' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.AddCustomBot
// 0x001C (0x001C - 0x0000)
struct HWQueueDataFactory_AddCustomBot final
{
public:
	int32                                         TeamNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             CharacterItemId;                                   // 0x0004(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWBotDifficulty                              Difficulty;                                        // 0x0018(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_AddCustomBot) == 0x000004, "Wrong alignment on HWQueueDataFactory_AddCustomBot");
static_assert(sizeof(HWQueueDataFactory_AddCustomBot) == 0x00001C, "Wrong size on HWQueueDataFactory_AddCustomBot");
static_assert(offsetof(HWQueueDataFactory_AddCustomBot, TeamNum) == 0x000000, "Member 'HWQueueDataFactory_AddCustomBot::TeamNum' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_AddCustomBot, CharacterItemId) == 0x000004, "Member 'HWQueueDataFactory_AddCustomBot::CharacterItemId' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_AddCustomBot, Difficulty) == 0x000018, "Member 'HWQueueDataFactory_AddCustomBot::Difficulty' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.AssessQueueItemOwnershipRequirement
// 0x0028 (0x0028 - 0x0000)
struct HWQueueDataFactory_AssessQueueItemOwnershipRequirement final
{
public:
	class FString                                 InQueuId;                                          // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& QueueId, const bool bItemOwned)> Delegate;                   // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_AssessQueueItemOwnershipRequirement) == 0x000008, "Wrong alignment on HWQueueDataFactory_AssessQueueItemOwnershipRequirement");
static_assert(sizeof(HWQueueDataFactory_AssessQueueItemOwnershipRequirement) == 0x000028, "Wrong size on HWQueueDataFactory_AssessQueueItemOwnershipRequirement");
static_assert(offsetof(HWQueueDataFactory_AssessQueueItemOwnershipRequirement, InQueuId) == 0x000000, "Member 'HWQueueDataFactory_AssessQueueItemOwnershipRequirement::InQueuId' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_AssessQueueItemOwnershipRequirement, Delegate) == 0x000010, "Member 'HWQueueDataFactory_AssessQueueItemOwnershipRequirement::Delegate' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_AssessQueueItemOwnershipRequirement, ReturnValue) == 0x000020, "Member 'HWQueueDataFactory_AssessQueueItemOwnershipRequirement::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.FillTeamWithRandomBots
// 0x0008 (0x0008 - 0x0000)
struct HWQueueDataFactory_FillTeamWithRandomBots final
{
public:
	int32                                         TeamNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWBotDifficulty                              Difficulty;                                        // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_FillTeamWithRandomBots) == 0x000004, "Wrong alignment on HWQueueDataFactory_FillTeamWithRandomBots");
static_assert(sizeof(HWQueueDataFactory_FillTeamWithRandomBots) == 0x000008, "Wrong size on HWQueueDataFactory_FillTeamWithRandomBots");
static_assert(offsetof(HWQueueDataFactory_FillTeamWithRandomBots, TeamNum) == 0x000000, "Member 'HWQueueDataFactory_FillTeamWithRandomBots::TeamNum' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_FillTeamWithRandomBots, Difficulty) == 0x000004, "Member 'HWQueueDataFactory_FillTeamWithRandomBots::Difficulty' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.HandlePartyUpdatedWithPartyMemberData
// 0x0030 (0x0030 - 0x0000)
struct HWQueueDataFactory_HandlePartyUpdatedWithPartyMemberData final
{
public:
	struct FRH_PartyMemberData                    PartyMemberData;                                   // 0x0000(0x0030)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQueueDataFactory_HandlePartyUpdatedWithPartyMemberData) == 0x000008, "Wrong alignment on HWQueueDataFactory_HandlePartyUpdatedWithPartyMemberData");
static_assert(sizeof(HWQueueDataFactory_HandlePartyUpdatedWithPartyMemberData) == 0x000030, "Wrong size on HWQueueDataFactory_HandlePartyUpdatedWithPartyMemberData");
static_assert(offsetof(HWQueueDataFactory_HandlePartyUpdatedWithPartyMemberData, PartyMemberData) == 0x000000, "Member 'HWQueueDataFactory_HandlePartyUpdatedWithPartyMemberData::PartyMemberData' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.HandlePartyUpdatedWithUUID
// 0x0010 (0x0010 - 0x0000)
struct HWQueueDataFactory_HandlePartyUpdatedWithUUID final
{
public:
	struct FGuid                                  PlayerId;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQueueDataFactory_HandlePartyUpdatedWithUUID) == 0x000004, "Wrong alignment on HWQueueDataFactory_HandlePartyUpdatedWithUUID");
static_assert(sizeof(HWQueueDataFactory_HandlePartyUpdatedWithUUID) == 0x000010, "Wrong size on HWQueueDataFactory_HandlePartyUpdatedWithUUID");
static_assert(offsetof(HWQueueDataFactory_HandlePartyUpdatedWithUUID, PlayerId) == 0x000000, "Member 'HWQueueDataFactory_HandlePartyUpdatedWithUUID::PlayerId' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.HandleSelectedQueueItemOwnershipCheckCompleted
// 0x0018 (0x0018 - 0x0000)
struct HWQueueDataFactory_HandleSelectedQueueItemOwnershipCheckCompleted final
{
public:
	class FString                                 QueueId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemOwned;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_HandleSelectedQueueItemOwnershipCheckCompleted) == 0x000008, "Wrong alignment on HWQueueDataFactory_HandleSelectedQueueItemOwnershipCheckCompleted");
static_assert(sizeof(HWQueueDataFactory_HandleSelectedQueueItemOwnershipCheckCompleted) == 0x000018, "Wrong size on HWQueueDataFactory_HandleSelectedQueueItemOwnershipCheckCompleted");
static_assert(offsetof(HWQueueDataFactory_HandleSelectedQueueItemOwnershipCheckCompleted, QueueId) == 0x000000, "Member 'HWQueueDataFactory_HandleSelectedQueueItemOwnershipCheckCompleted::QueueId' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_HandleSelectedQueueItemOwnershipCheckCompleted, bItemOwned) == 0x000010, "Member 'HWQueueDataFactory_HandleSelectedQueueItemOwnershipCheckCompleted::bItemOwned' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.RemoveCustomBot
// 0x001C (0x001C - 0x0000)
struct HWQueueDataFactory_RemoveCustomBot final
{
public:
	int32                                         TeamNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             CharacterItemId;                                   // 0x0004(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWBotDifficulty                              Difficulty;                                        // 0x0018(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_RemoveCustomBot) == 0x000004, "Wrong alignment on HWQueueDataFactory_RemoveCustomBot");
static_assert(sizeof(HWQueueDataFactory_RemoveCustomBot) == 0x00001C, "Wrong size on HWQueueDataFactory_RemoveCustomBot");
static_assert(offsetof(HWQueueDataFactory_RemoveCustomBot, TeamNum) == 0x000000, "Member 'HWQueueDataFactory_RemoveCustomBot::TeamNum' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_RemoveCustomBot, CharacterItemId) == 0x000004, "Member 'HWQueueDataFactory_RemoveCustomBot::CharacterItemId' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_RemoveCustomBot, Difficulty) == 0x000018, "Member 'HWQueueDataFactory_RemoveCustomBot::Difficulty' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.SwapTeamCustomBot
// 0x0020 (0x0020 - 0x0000)
struct HWQueueDataFactory_SwapTeamCustomBot final
{
public:
	int32                                         TeamNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemId                             CharacterItemId;                                   // 0x0004(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHWBotDifficulty                              Difficulty;                                        // 0x0018(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamToSwapTo;                                      // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQueueDataFactory_SwapTeamCustomBot) == 0x000004, "Wrong alignment on HWQueueDataFactory_SwapTeamCustomBot");
static_assert(sizeof(HWQueueDataFactory_SwapTeamCustomBot) == 0x000020, "Wrong size on HWQueueDataFactory_SwapTeamCustomBot");
static_assert(offsetof(HWQueueDataFactory_SwapTeamCustomBot, TeamNum) == 0x000000, "Member 'HWQueueDataFactory_SwapTeamCustomBot::TeamNum' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_SwapTeamCustomBot, CharacterItemId) == 0x000004, "Member 'HWQueueDataFactory_SwapTeamCustomBot::CharacterItemId' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_SwapTeamCustomBot, Difficulty) == 0x000018, "Member 'HWQueueDataFactory_SwapTeamCustomBot::Difficulty' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_SwapTeamCustomBot, TeamToSwapTo) == 0x00001C, "Member 'HWQueueDataFactory_SwapTeamCustomBot::TeamToSwapTo' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.AssessPartySizeForRankedQueue
// 0x0010 (0x0010 - 0x0000)
struct HWQueueDataFactory_AssessPartySizeForRankedQueue final
{
public:
	class URH_MatchmakingQueueInfo*               InQueueInfo;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERHQueueDisplayState                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_AssessPartySizeForRankedQueue) == 0x000008, "Wrong alignment on HWQueueDataFactory_AssessPartySizeForRankedQueue");
static_assert(sizeof(HWQueueDataFactory_AssessPartySizeForRankedQueue) == 0x000010, "Wrong size on HWQueueDataFactory_AssessPartySizeForRankedQueue");
static_assert(offsetof(HWQueueDataFactory_AssessPartySizeForRankedQueue, InQueueInfo) == 0x000000, "Member 'HWQueueDataFactory_AssessPartySizeForRankedQueue::InQueueInfo' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_AssessPartySizeForRankedQueue, ReturnValue) == 0x000008, "Member 'HWQueueDataFactory_AssessPartySizeForRankedQueue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.GetCurrentCustomLobbyBotConfig
// 0x0058 (0x0058 - 0x0000)
struct HWQueueDataFactory_GetCurrentCustomLobbyBotConfig final
{
public:
	struct FHWCustomBotConfig_Game                OutCustomBotConfig;                                // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_GetCurrentCustomLobbyBotConfig) == 0x000008, "Wrong alignment on HWQueueDataFactory_GetCurrentCustomLobbyBotConfig");
static_assert(sizeof(HWQueueDataFactory_GetCurrentCustomLobbyBotConfig) == 0x000058, "Wrong size on HWQueueDataFactory_GetCurrentCustomLobbyBotConfig");
static_assert(offsetof(HWQueueDataFactory_GetCurrentCustomLobbyBotConfig, OutCustomBotConfig) == 0x000000, "Member 'HWQueueDataFactory_GetCurrentCustomLobbyBotConfig::OutCustomBotConfig' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_GetCurrentCustomLobbyBotConfig, ReturnValue) == 0x000050, "Member 'HWQueueDataFactory_GetCurrentCustomLobbyBotConfig::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.GetCustomLobbyGameModeInfos
// 0x0010 (0x0010 - 0x0000)
struct HWQueueDataFactory_GetCustomLobbyGameModeInfos final
{
public:
	TArray<struct FHWGameModeInfo>                OutGameModeInfos;                                  // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQueueDataFactory_GetCustomLobbyGameModeInfos) == 0x000008, "Wrong alignment on HWQueueDataFactory_GetCustomLobbyGameModeInfos");
static_assert(sizeof(HWQueueDataFactory_GetCustomLobbyGameModeInfos) == 0x000010, "Wrong size on HWQueueDataFactory_GetCustomLobbyGameModeInfos");
static_assert(offsetof(HWQueueDataFactory_GetCustomLobbyGameModeInfos, OutGameModeInfos) == 0x000000, "Member 'HWQueueDataFactory_GetCustomLobbyGameModeInfos::OutGameModeInfos' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.GetCustomSessionGameModeInfo
// 0x0108 (0x0108 - 0x0000)
struct HWQueueDataFactory_GetCustomSessionGameModeInfo final
{
public:
	class URH_SessionView*                        InSession;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWGameModeInfo                        OutGameModeInfo;                                   // 0x0008(0x00F8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_GetCustomSessionGameModeInfo) == 0x000008, "Wrong alignment on HWQueueDataFactory_GetCustomSessionGameModeInfo");
static_assert(sizeof(HWQueueDataFactory_GetCustomSessionGameModeInfo) == 0x000108, "Wrong size on HWQueueDataFactory_GetCustomSessionGameModeInfo");
static_assert(offsetof(HWQueueDataFactory_GetCustomSessionGameModeInfo, InSession) == 0x000000, "Member 'HWQueueDataFactory_GetCustomSessionGameModeInfo::InSession' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_GetCustomSessionGameModeInfo, OutGameModeInfo) == 0x000008, "Member 'HWQueueDataFactory_GetCustomSessionGameModeInfo::OutGameModeInfo' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_GetCustomSessionGameModeInfo, ReturnValue) == 0x000100, "Member 'HWQueueDataFactory_GetCustomSessionGameModeInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.GetSavedSelectedQueue
// 0x0010 (0x0010 - 0x0000)
struct HWQueueDataFactory_GetSavedSelectedQueue final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQueueDataFactory_GetSavedSelectedQueue) == 0x000008, "Wrong alignment on HWQueueDataFactory_GetSavedSelectedQueue");
static_assert(sizeof(HWQueueDataFactory_GetSavedSelectedQueue) == 0x000010, "Wrong size on HWQueueDataFactory_GetSavedSelectedQueue");
static_assert(offsetof(HWQueueDataFactory_GetSavedSelectedQueue, ReturnValue) == 0x000000, "Member 'HWQueueDataFactory_GetSavedSelectedQueue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.GetSortedQueues
// 0x0010 (0x0010 - 0x0000)
struct HWQueueDataFactory_GetSortedQueues final
{
public:
	TArray<class URH_MatchmakingQueueInfo*>       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQueueDataFactory_GetSortedQueues) == 0x000008, "Wrong alignment on HWQueueDataFactory_GetSortedQueues");
static_assert(sizeof(HWQueueDataFactory_GetSortedQueues) == 0x000010, "Wrong size on HWQueueDataFactory_GetSortedQueues");
static_assert(offsetof(HWQueueDataFactory_GetSortedQueues, ReturnValue) == 0x000000, "Member 'HWQueueDataFactory_GetSortedQueues::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.IsCustomBotEnabled
// 0x0001 (0x0001 - 0x0000)
struct HWQueueDataFactory_IsCustomBotEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWQueueDataFactory_IsCustomBotEnabled) == 0x000001, "Wrong alignment on HWQueueDataFactory_IsCustomBotEnabled");
static_assert(sizeof(HWQueueDataFactory_IsCustomBotEnabled) == 0x000001, "Wrong size on HWQueueDataFactory_IsCustomBotEnabled");
static_assert(offsetof(HWQueueDataFactory_IsCustomBotEnabled, ReturnValue) == 0x000000, "Member 'HWQueueDataFactory_IsCustomBotEnabled::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.IsQueueIdValid
// 0x0018 (0x0018 - 0x0000)
struct HWQueueDataFactory_IsQueueIdValid final
{
public:
	class FString                                 InQueueId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_IsQueueIdValid) == 0x000008, "Wrong alignment on HWQueueDataFactory_IsQueueIdValid");
static_assert(sizeof(HWQueueDataFactory_IsQueueIdValid) == 0x000018, "Wrong size on HWQueueDataFactory_IsQueueIdValid");
static_assert(offsetof(HWQueueDataFactory_IsQueueIdValid, InQueueId) == 0x000000, "Member 'HWQueueDataFactory_IsQueueIdValid::InQueueId' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_IsQueueIdValid, ReturnValue) == 0x000010, "Member 'HWQueueDataFactory_IsQueueIdValid::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.IsRankedQueue
// 0x0010 (0x0010 - 0x0000)
struct HWQueueDataFactory_IsRankedQueue final
{
public:
	class URH_MatchmakingQueueInfo*               InQueueInfo;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_IsRankedQueue) == 0x000008, "Wrong alignment on HWQueueDataFactory_IsRankedQueue");
static_assert(sizeof(HWQueueDataFactory_IsRankedQueue) == 0x000010, "Wrong size on HWQueueDataFactory_IsRankedQueue");
static_assert(offsetof(HWQueueDataFactory_IsRankedQueue, InQueueInfo) == 0x000000, "Member 'HWQueueDataFactory_IsRankedQueue::InQueueInfo' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_IsRankedQueue, ReturnValue) == 0x000008, "Member 'HWQueueDataFactory_IsRankedQueue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWQueueDataFactory.IsRankedQueueById
// 0x0018 (0x0018 - 0x0000)
struct HWQueueDataFactory_IsRankedQueueById final
{
public:
	class FString                                 InQueueId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWQueueDataFactory_IsRankedQueueById) == 0x000008, "Wrong alignment on HWQueueDataFactory_IsRankedQueueById");
static_assert(sizeof(HWQueueDataFactory_IsRankedQueueById) == 0x000018, "Wrong size on HWQueueDataFactory_IsRankedQueueById");
static_assert(offsetof(HWQueueDataFactory_IsRankedQueueById, InQueueId) == 0x000000, "Member 'HWQueueDataFactory_IsRankedQueueById::InQueueId' has a wrong offset!");
static_assert(offsetof(HWQueueDataFactory_IsRankedQueueById, ReturnValue) == 0x000010, "Member 'HWQueueDataFactory_IsRankedQueueById::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.BLUEPRINT_ClientFillLoot
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LootId                             LootId;                                            // 0x0008(0x0014)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerOrderEntry*>& OrderEntries, const struct FRHAPI_PlayerOrder& OrderResult)> Delegate; // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRollbackOnFailure;                                // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot");
static_assert(sizeof(HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot) == 0x000038, "Wrong size on HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot, WorldContextObject) == 0x000000, "Member 'HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot, LootId) == 0x000008, "Member 'HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot::LootId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot, Quantity) == 0x00001C, "Member 'HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot::Quantity' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot, Delegate) == 0x000020, "Member 'HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot::Delegate' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot, bRollbackOnFailure) == 0x000030, "Member 'HWLibrary_RallyHere_BLUEPRINT_ClientFillLoot::bRollbackOnFailure' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.BLUEPRINT_CreateAndRequestPlayerOrder
// 0x0048 (0x0048 - 0x0000)
struct HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder final
{
public:
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERHAPI_PlayerOrderEntryType                   OrderType;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_LootId                             LootId;                                            // 0x000C(0x0014)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TransactionId;                                     // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerOrderEntry*>& OrderEntries, const struct FRHAPI_PlayerOrder& OrderResult)> Delegate; // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder");
static_assert(sizeof(HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder) == 0x000048, "Wrong size on HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder, PlayerInfo) == 0x000000, "Member 'HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder, OrderType) == 0x000008, "Member 'HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder::OrderType' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder, LootId) == 0x00000C, "Member 'HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder::LootId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder, Quantity) == 0x000020, "Member 'HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder::Quantity' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder, TransactionId) == 0x000028, "Member 'HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder::TransactionId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder, Delegate) == 0x000038, "Member 'HWLibrary_RallyHere_BLUEPRINT_CreateAndRequestPlayerOrder::Delegate' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.BLUEPRINT_GetExpirationDateForItem
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FDateTime& ExpirationDate)> Delegate;                                // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem");
static_assert(sizeof(HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem) == 0x000030, "Wrong size on HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem, ItemId) == 0x000000, "Member 'HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem::ItemId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem, PlayerInfo) == 0x000018, "Member 'HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem, Delegate) == 0x000020, "Member 'HWLibrary_RallyHere_BLUEPRINT_GetExpirationDateForItem::Delegate' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.BLUEPRINT_GetOwnedAmountForItem
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(int32 InstanceCount)>          Delegate;                                          // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem");
static_assert(sizeof(HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem) == 0x000030, "Wrong size on HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem, ItemId) == 0x000000, "Member 'HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem::ItemId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem, PlayerInfo) == 0x000018, "Member 'HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem, Delegate) == 0x000020, "Member 'HWLibrary_RallyHere_BLUEPRINT_GetOwnedAmountForItem::Delegate' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.BLUEPRINT_RequestPlayerOrder
// 0x0020 (0x0020 - 0x0000)
struct HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder final
{
public:
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_PlayerOrderEntry*                   PlayerOrder;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerOrderEntry*>& OrderEntries, const struct FRHAPI_PlayerOrder& OrderResult)> Delegate; // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder");
static_assert(sizeof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder) == 0x000020, "Wrong size on HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder, PlayerInfo) == 0x000000, "Member 'HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder, PlayerOrder) == 0x000008, "Member 'HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder::PlayerOrder' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder, Delegate) == 0x000010, "Member 'HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrder::Delegate' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.BLUEPRINT_RequestPlayerOrders
// 0x0030 (0x0030 - 0x0000)
struct HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders final
{
public:
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URH_PlayerOrderEntry*>           PlayerOrders;                                      // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(const class URH_PlayerInfo* PlayerInfo, const TArray<class URH_PlayerOrderEntry*>& OrderEntries, const struct FRHAPI_PlayerOrder& OrderResult)> Delegate; // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRollbackOnFailure;                                // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders");
static_assert(sizeof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders) == 0x000030, "Wrong size on HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders, PlayerInfo) == 0x000000, "Member 'HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders, PlayerOrders) == 0x000008, "Member 'HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders::PlayerOrders' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders, Delegate) == 0x000018, "Member 'HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders::Delegate' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders, bRollbackOnFailure) == 0x000028, "Member 'HWLibrary_RallyHere_BLUEPRINT_RequestPlayerOrders::bRollbackOnFailure' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.CreatePlayerOrder
// 0x0038 (0x0038 - 0x0000)
struct HWLibrary_RallyHere_CreatePlayerOrder final
{
public:
	ERHAPI_PlayerOrderEntryType                   OrderType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRH_LootId                             LootId;                                            // 0x0004(0x0014)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TransactionId;                                     // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_PlayerOrderEntry*                   ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_RallyHere_CreatePlayerOrder) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_CreatePlayerOrder");
static_assert(sizeof(HWLibrary_RallyHere_CreatePlayerOrder) == 0x000038, "Wrong size on HWLibrary_RallyHere_CreatePlayerOrder");
static_assert(offsetof(HWLibrary_RallyHere_CreatePlayerOrder, OrderType) == 0x000000, "Member 'HWLibrary_RallyHere_CreatePlayerOrder::OrderType' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_CreatePlayerOrder, LootId) == 0x000004, "Member 'HWLibrary_RallyHere_CreatePlayerOrder::LootId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_CreatePlayerOrder, Quantity) == 0x000018, "Member 'HWLibrary_RallyHere_CreatePlayerOrder::Quantity' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_CreatePlayerOrder, TransactionId) == 0x000020, "Member 'HWLibrary_RallyHere_CreatePlayerOrder::TransactionId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_CreatePlayerOrder, ReturnValue) == 0x000030, "Member 'HWLibrary_RallyHere_CreatePlayerOrder::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.EmitErrorEvent
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_RallyHere_EmitErrorEvent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventName;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHWEventParameterPair>          EventParameters;                                   // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_RallyHere_EmitErrorEvent) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_EmitErrorEvent");
static_assert(sizeof(HWLibrary_RallyHere_EmitErrorEvent) == 0x000028, "Wrong size on HWLibrary_RallyHere_EmitErrorEvent");
static_assert(offsetof(HWLibrary_RallyHere_EmitErrorEvent, WorldContextObject) == 0x000000, "Member 'HWLibrary_RallyHere_EmitErrorEvent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_EmitErrorEvent, EventName) == 0x000008, "Member 'HWLibrary_RallyHere_EmitErrorEvent::EventName' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_EmitErrorEvent, EventParameters) == 0x000018, "Member 'HWLibrary_RallyHere_EmitErrorEvent::EventParameters' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetActiveSession
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_RallyHere_GetActiveSession final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_JoinedSession*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_RallyHere_GetActiveSession) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetActiveSession");
static_assert(sizeof(HWLibrary_RallyHere_GetActiveSession) == 0x000010, "Wrong size on HWLibrary_RallyHere_GetActiveSession");
static_assert(offsetof(HWLibrary_RallyHere_GetActiveSession, WorldContextObject) == 0x000000, "Member 'HWLibrary_RallyHere_GetActiveSession::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetActiveSession, ReturnValue) == 0x000008, "Member 'HWLibrary_RallyHere_GetActiveSession::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetActiveSessionTeam
// 0x00B0 (0x00B0 - 0x0000)
struct HWLibrary_RallyHere_GetActiveSessionTeam final
{
public:
	const class URH_JoinedSession*                ActiveSession;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamNum;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRHAPI_SessionTeam                     OutTeam;                                           // 0x0010(0x0098)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_RallyHere_GetActiveSessionTeam) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetActiveSessionTeam");
static_assert(sizeof(HWLibrary_RallyHere_GetActiveSessionTeam) == 0x0000B0, "Wrong size on HWLibrary_RallyHere_GetActiveSessionTeam");
static_assert(offsetof(HWLibrary_RallyHere_GetActiveSessionTeam, ActiveSession) == 0x000000, "Member 'HWLibrary_RallyHere_GetActiveSessionTeam::ActiveSession' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetActiveSessionTeam, TeamNum) == 0x000008, "Member 'HWLibrary_RallyHere_GetActiveSessionTeam::TeamNum' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetActiveSessionTeam, OutTeam) == 0x000010, "Member 'HWLibrary_RallyHere_GetActiveSessionTeam::OutTeam' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetActiveSessionTeam, ReturnValue) == 0x0000A8, "Member 'HWLibrary_RallyHere_GetActiveSessionTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetCachedExpirationDateForItem
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_RallyHere_GetCachedExpirationDateForItem final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_RallyHere_GetCachedExpirationDateForItem) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetCachedExpirationDateForItem");
static_assert(sizeof(HWLibrary_RallyHere_GetCachedExpirationDateForItem) == 0x000028, "Wrong size on HWLibrary_RallyHere_GetCachedExpirationDateForItem");
static_assert(offsetof(HWLibrary_RallyHere_GetCachedExpirationDateForItem, ItemId) == 0x000000, "Member 'HWLibrary_RallyHere_GetCachedExpirationDateForItem::ItemId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetCachedExpirationDateForItem, PlayerInfo) == 0x000018, "Member 'HWLibrary_RallyHere_GetCachedExpirationDateForItem::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetCachedExpirationDateForItem, ReturnValue) == 0x000020, "Member 'HWLibrary_RallyHere_GetCachedExpirationDateForItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetCachedOwnedAmountForItem
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_RallyHere_GetCachedOwnedAmountForItem final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class URH_PlayerInfo*                   PlayerInfo;                                        // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_RallyHere_GetCachedOwnedAmountForItem) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetCachedOwnedAmountForItem");
static_assert(sizeof(HWLibrary_RallyHere_GetCachedOwnedAmountForItem) == 0x000028, "Wrong size on HWLibrary_RallyHere_GetCachedOwnedAmountForItem");
static_assert(offsetof(HWLibrary_RallyHere_GetCachedOwnedAmountForItem, ItemId) == 0x000000, "Member 'HWLibrary_RallyHere_GetCachedOwnedAmountForItem::ItemId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetCachedOwnedAmountForItem, PlayerInfo) == 0x000018, "Member 'HWLibrary_RallyHere_GetCachedOwnedAmountForItem::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetCachedOwnedAmountForItem, ReturnValue) == 0x000020, "Member 'HWLibrary_RallyHere_GetCachedOwnedAmountForItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetJoinedSessionAsDedicatedServer
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_RallyHere_GetJoinedSessionAsDedicatedServer final
{
public:
	const class UGameInstance*                    GameInstance;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_JoinedSession*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_RallyHere_GetJoinedSessionAsDedicatedServer) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetJoinedSessionAsDedicatedServer");
static_assert(sizeof(HWLibrary_RallyHere_GetJoinedSessionAsDedicatedServer) == 0x000010, "Wrong size on HWLibrary_RallyHere_GetJoinedSessionAsDedicatedServer");
static_assert(offsetof(HWLibrary_RallyHere_GetJoinedSessionAsDedicatedServer, GameInstance) == 0x000000, "Member 'HWLibrary_RallyHere_GetJoinedSessionAsDedicatedServer::GameInstance' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetJoinedSessionAsDedicatedServer, ReturnValue) == 0x000008, "Member 'HWLibrary_RallyHere_GetJoinedSessionAsDedicatedServer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetJoinedSessionAsLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_RallyHere_GetJoinedSessionAsLocalPlayer final
{
public:
	const class APlayerController*                LocalPlayerController;                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_JoinedSession*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLibrary_RallyHere_GetJoinedSessionAsLocalPlayer) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetJoinedSessionAsLocalPlayer");
static_assert(sizeof(HWLibrary_RallyHere_GetJoinedSessionAsLocalPlayer) == 0x000010, "Wrong size on HWLibrary_RallyHere_GetJoinedSessionAsLocalPlayer");
static_assert(offsetof(HWLibrary_RallyHere_GetJoinedSessionAsLocalPlayer, LocalPlayerController) == 0x000000, "Member 'HWLibrary_RallyHere_GetJoinedSessionAsLocalPlayer::LocalPlayerController' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetJoinedSessionAsLocalPlayer, ReturnValue) == 0x000008, "Member 'HWLibrary_RallyHere_GetJoinedSessionAsLocalPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetLevelInfo
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_RallyHere_GetLevelInfo final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TableId;                                           // 0x0008(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpPoints;                                          // 0x000C(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWLevelInfo                           OutLevelInfo;                                      // 0x0010(0x0014)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_RallyHere_GetLevelInfo) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetLevelInfo");
static_assert(sizeof(HWLibrary_RallyHere_GetLevelInfo) == 0x000028, "Wrong size on HWLibrary_RallyHere_GetLevelInfo");
static_assert(offsetof(HWLibrary_RallyHere_GetLevelInfo, WorldContextObject) == 0x000000, "Member 'HWLibrary_RallyHere_GetLevelInfo::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetLevelInfo, TableId) == 0x000008, "Member 'HWLibrary_RallyHere_GetLevelInfo::TableId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetLevelInfo, XpPoints) == 0x00000C, "Member 'HWLibrary_RallyHere_GetLevelInfo::XpPoints' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetLevelInfo, OutLevelInfo) == 0x000010, "Member 'HWLibrary_RallyHere_GetLevelInfo::OutLevelInfo' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetLevelInfo, ReturnValue) == 0x000024, "Member 'HWLibrary_RallyHere_GetLevelInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetXpPoints
// 0x0018 (0x0018 - 0x0000)
struct HWLibrary_RallyHere_GetXpPoints final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemId;                                            // 0x0008(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpPoints;                                          // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_RallyHere_GetXpPoints) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetXpPoints");
static_assert(sizeof(HWLibrary_RallyHere_GetXpPoints) == 0x000018, "Wrong size on HWLibrary_RallyHere_GetXpPoints");
static_assert(offsetof(HWLibrary_RallyHere_GetXpPoints, WorldContextObject) == 0x000000, "Member 'HWLibrary_RallyHere_GetXpPoints::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpPoints, ItemId) == 0x000008, "Member 'HWLibrary_RallyHere_GetXpPoints::ItemId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpPoints, XpPoints) == 0x00000C, "Member 'HWLibrary_RallyHere_GetXpPoints::XpPoints' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpPoints, ReturnValue) == 0x000010, "Member 'HWLibrary_RallyHere_GetXpPoints::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetXpTable
// 0x0100 (0x0100 - 0x0000)
struct HWLibrary_RallyHere_GetXpTable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpTableId;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRHAPI_XpTable                         OutXpTable;                                        // 0x0010(0x00E8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_RallyHere_GetXpTable) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetXpTable");
static_assert(sizeof(HWLibrary_RallyHere_GetXpTable) == 0x000100, "Wrong size on HWLibrary_RallyHere_GetXpTable");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTable, WorldContextObject) == 0x000000, "Member 'HWLibrary_RallyHere_GetXpTable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTable, XpTableId) == 0x000008, "Member 'HWLibrary_RallyHere_GetXpTable::XpTableId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTable, OutXpTable) == 0x000010, "Member 'HWLibrary_RallyHere_GetXpTable::OutXpTable' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTable, ReturnValue) == 0x0000F8, "Member 'HWLibrary_RallyHere_GetXpTable::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetXpTableBreakpoints
// 0x0028 (0x0028 - 0x0000)
struct HWLibrary_RallyHere_GetXpTableBreakpoints final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TableId;                                           // 0x0008(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OutTierBreakpoints;                                // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_RallyHere_GetXpTableBreakpoints) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetXpTableBreakpoints");
static_assert(sizeof(HWLibrary_RallyHere_GetXpTableBreakpoints) == 0x000028, "Wrong size on HWLibrary_RallyHere_GetXpTableBreakpoints");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTableBreakpoints, WorldContextObject) == 0x000000, "Member 'HWLibrary_RallyHere_GetXpTableBreakpoints::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTableBreakpoints, TableId) == 0x000008, "Member 'HWLibrary_RallyHere_GetXpTableBreakpoints::TableId' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTableBreakpoints, OutTierBreakpoints) == 0x000010, "Member 'HWLibrary_RallyHere_GetXpTableBreakpoints::OutTierBreakpoints' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTableBreakpoints, ReturnValue) == 0x000020, "Member 'HWLibrary_RallyHere_GetXpTableBreakpoints::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.GetXpTableFromItem
// 0x0100 (0x0100 - 0x0000)
struct HWLibrary_RallyHere_GetXpTableFromItem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URHStoreItem*                           ProgressStoreItem;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRHAPI_XpTable                         OutXpTable;                                        // 0x0010(0x00E8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_RallyHere_GetXpTableFromItem) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_GetXpTableFromItem");
static_assert(sizeof(HWLibrary_RallyHere_GetXpTableFromItem) == 0x000100, "Wrong size on HWLibrary_RallyHere_GetXpTableFromItem");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTableFromItem, WorldContextObject) == 0x000000, "Member 'HWLibrary_RallyHere_GetXpTableFromItem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTableFromItem, ProgressStoreItem) == 0x000008, "Member 'HWLibrary_RallyHere_GetXpTableFromItem::ProgressStoreItem' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTableFromItem, OutXpTable) == 0x000010, "Member 'HWLibrary_RallyHere_GetXpTableFromItem::OutXpTable' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_GetXpTableFromItem, ReturnValue) == 0x0000F8, "Member 'HWLibrary_RallyHere_GetXpTableFromItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLibrary_RallyHere.IsInMatchmakeSession
// 0x0010 (0x0010 - 0x0000)
struct HWLibrary_RallyHere_IsInMatchmakeSession final
{
public:
	const class URH_JoinedSession*                JoinedSession;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLibrary_RallyHere_IsInMatchmakeSession) == 0x000008, "Wrong alignment on HWLibrary_RallyHere_IsInMatchmakeSession");
static_assert(sizeof(HWLibrary_RallyHere_IsInMatchmakeSession) == 0x000010, "Wrong size on HWLibrary_RallyHere_IsInMatchmakeSession");
static_assert(offsetof(HWLibrary_RallyHere_IsInMatchmakeSession, JoinedSession) == 0x000000, "Member 'HWLibrary_RallyHere_IsInMatchmakeSession::JoinedSession' has a wrong offset!");
static_assert(offsetof(HWLibrary_RallyHere_IsInMatchmakeSession, ReturnValue) == 0x000008, "Member 'HWLibrary_RallyHere_IsInMatchmakeSession::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerInfo.UpdateCachedPlayerSkillRating
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerInfo_UpdateCachedPlayerSkillRating final
{
public:
	bool                                          bForceRefresh;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerInfo_UpdateCachedPlayerSkillRating) == 0x000001, "Wrong alignment on HWPlayerInfo_UpdateCachedPlayerSkillRating");
static_assert(sizeof(HWPlayerInfo_UpdateCachedPlayerSkillRating) == 0x000001, "Wrong size on HWPlayerInfo_UpdateCachedPlayerSkillRating");
static_assert(offsetof(HWPlayerInfo_UpdateCachedPlayerSkillRating, bForceRefresh) == 0x000000, "Member 'HWPlayerInfo_UpdateCachedPlayerSkillRating::bForceRefresh' has a wrong offset!");

// Function Hemingway.HWPlayerInfo.GetCachedPlayerLevel
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerInfo_GetCachedPlayerLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerInfo_GetCachedPlayerLevel) == 0x000004, "Wrong alignment on HWPlayerInfo_GetCachedPlayerLevel");
static_assert(sizeof(HWPlayerInfo_GetCachedPlayerLevel) == 0x000004, "Wrong size on HWPlayerInfo_GetCachedPlayerLevel");
static_assert(offsetof(HWPlayerInfo_GetCachedPlayerLevel, ReturnValue) == 0x000000, "Member 'HWPlayerInfo_GetCachedPlayerLevel::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerInfo.GetCurrentQueueCachedPlayerSkillRating
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerInfo_GetCurrentQueueCachedPlayerSkillRating final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerInfo_GetCurrentQueueCachedPlayerSkillRating) == 0x000004, "Wrong alignment on HWPlayerInfo_GetCurrentQueueCachedPlayerSkillRating");
static_assert(sizeof(HWPlayerInfo_GetCurrentQueueCachedPlayerSkillRating) == 0x000004, "Wrong size on HWPlayerInfo_GetCurrentQueueCachedPlayerSkillRating");
static_assert(offsetof(HWPlayerInfo_GetCurrentQueueCachedPlayerSkillRating, ReturnValue) == 0x000000, "Member 'HWPlayerInfo_GetCurrentQueueCachedPlayerSkillRating::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerInfo.HasReceivedInventory
// 0x0001 (0x0001 - 0x0000)
struct HWPlayerInfo_HasReceivedInventory final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerInfo_HasReceivedInventory) == 0x000001, "Wrong alignment on HWPlayerInfo_HasReceivedInventory");
static_assert(sizeof(HWPlayerInfo_HasReceivedInventory) == 0x000001, "Wrong size on HWPlayerInfo_HasReceivedInventory");
static_assert(offsetof(HWPlayerInfo_HasReceivedInventory, ReturnValue) == 0x000000, "Member 'HWPlayerInfo_HasReceivedInventory::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Skinnable.GetApparelComponent
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_Skinnable_GetApparelComponent final
{
public:
	class UHWApparelComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Skinnable_GetApparelComponent) == 0x000008, "Wrong alignment on HWInterface_Skinnable_GetApparelComponent");
static_assert(sizeof(HWInterface_Skinnable_GetApparelComponent) == 0x000008, "Wrong size on HWInterface_Skinnable_GetApparelComponent");
static_assert(offsetof(HWInterface_Skinnable_GetApparelComponent, ReturnValue) == 0x000000, "Member 'HWInterface_Skinnable_GetApparelComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Skinnable.GetCurrentSkin
// 0x0008 (0x0008 - 0x0000)
struct HWInterface_Skinnable_GetCurrentSkin final
{
public:
	const class UHWSkinItem*                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Skinnable_GetCurrentSkin) == 0x000008, "Wrong alignment on HWInterface_Skinnable_GetCurrentSkin");
static_assert(sizeof(HWInterface_Skinnable_GetCurrentSkin) == 0x000008, "Wrong size on HWInterface_Skinnable_GetCurrentSkin");
static_assert(offsetof(HWInterface_Skinnable_GetCurrentSkin, ReturnValue) == 0x000000, "Member 'HWInterface_Skinnable_GetCurrentSkin::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Skinnable.GetSkinnedAudioInfo
// 0x0028 (0x0028 - 0x0000)
struct HWInterface_Skinnable_GetSkinnedAudioInfo final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkinnedMetaSoundInfo                ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Skinnable_GetSkinnedAudioInfo) == 0x000008, "Wrong alignment on HWInterface_Skinnable_GetSkinnedAudioInfo");
static_assert(sizeof(HWInterface_Skinnable_GetSkinnedAudioInfo) == 0x000028, "Wrong size on HWInterface_Skinnable_GetSkinnedAudioInfo");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedAudioInfo, AssetRequest) == 0x000000, "Member 'HWInterface_Skinnable_GetSkinnedAudioInfo::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedAudioInfo, ReturnValue) == 0x000020, "Member 'HWInterface_Skinnable_GetSkinnedAudioInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Skinnable.GetSkinnedMaterialInfo
// 0x0028 (0x0028 - 0x0000)
struct HWInterface_Skinnable_GetSkinnedMaterialInfo final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkinnedMaterialInfo                 ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Skinnable_GetSkinnedMaterialInfo) == 0x000008, "Wrong alignment on HWInterface_Skinnable_GetSkinnedMaterialInfo");
static_assert(sizeof(HWInterface_Skinnable_GetSkinnedMaterialInfo) == 0x000028, "Wrong size on HWInterface_Skinnable_GetSkinnedMaterialInfo");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedMaterialInfo, AssetRequest) == 0x000000, "Member 'HWInterface_Skinnable_GetSkinnedMaterialInfo::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedMaterialInfo, ReturnValue) == 0x000020, "Member 'HWInterface_Skinnable_GetSkinnedMaterialInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Skinnable.GetSkinnedMontage
// 0x0038 (0x0038 - 0x0000)
struct HWInterface_Skinnable_GetSkinnedMontage final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWMontageInfo                         ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Skinnable_GetSkinnedMontage) == 0x000008, "Wrong alignment on HWInterface_Skinnable_GetSkinnedMontage");
static_assert(sizeof(HWInterface_Skinnable_GetSkinnedMontage) == 0x000038, "Wrong size on HWInterface_Skinnable_GetSkinnedMontage");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedMontage, AssetRequest) == 0x000000, "Member 'HWInterface_Skinnable_GetSkinnedMontage::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedMontage, ReturnValue) == 0x000020, "Member 'HWInterface_Skinnable_GetSkinnedMontage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Skinnable.GetSkinnedNiagaraInfo
// 0x0030 (0x0030 - 0x0000)
struct HWInterface_Skinnable_GetSkinnedNiagaraInfo final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkinnedNiagaraInfo                  ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Skinnable_GetSkinnedNiagaraInfo) == 0x000008, "Wrong alignment on HWInterface_Skinnable_GetSkinnedNiagaraInfo");
static_assert(sizeof(HWInterface_Skinnable_GetSkinnedNiagaraInfo) == 0x000030, "Wrong size on HWInterface_Skinnable_GetSkinnedNiagaraInfo");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedNiagaraInfo, AssetRequest) == 0x000000, "Member 'HWInterface_Skinnable_GetSkinnedNiagaraInfo::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedNiagaraInfo, ReturnValue) == 0x000020, "Member 'HWInterface_Skinnable_GetSkinnedNiagaraInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Skinnable.GetSkinnedSkeletalMeshInfo
// 0x0038 (0x0038 - 0x0000)
struct HWInterface_Skinnable_GetSkinnedSkeletalMeshInfo final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkinnedSkeletalMeshInfo             ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Skinnable_GetSkinnedSkeletalMeshInfo) == 0x000008, "Wrong alignment on HWInterface_Skinnable_GetSkinnedSkeletalMeshInfo");
static_assert(sizeof(HWInterface_Skinnable_GetSkinnedSkeletalMeshInfo) == 0x000038, "Wrong size on HWInterface_Skinnable_GetSkinnedSkeletalMeshInfo");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedSkeletalMeshInfo, AssetRequest) == 0x000000, "Member 'HWInterface_Skinnable_GetSkinnedSkeletalMeshInfo::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedSkeletalMeshInfo, ReturnValue) == 0x000020, "Member 'HWInterface_Skinnable_GetSkinnedSkeletalMeshInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Skinnable.GetSkinnedStaticMeshInfo
// 0x0028 (0x0028 - 0x0000)
struct HWInterface_Skinnable_GetSkinnedStaticMeshInfo final
{
public:
	struct FAssetRequestKey                       AssetRequest;                                      // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkinnedStaticMeshInfo               ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Skinnable_GetSkinnedStaticMeshInfo) == 0x000008, "Wrong alignment on HWInterface_Skinnable_GetSkinnedStaticMeshInfo");
static_assert(sizeof(HWInterface_Skinnable_GetSkinnedStaticMeshInfo) == 0x000028, "Wrong size on HWInterface_Skinnable_GetSkinnedStaticMeshInfo");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedStaticMeshInfo, AssetRequest) == 0x000000, "Member 'HWInterface_Skinnable_GetSkinnedStaticMeshInfo::AssetRequest' has a wrong offset!");
static_assert(offsetof(HWInterface_Skinnable_GetSkinnedStaticMeshInfo, ReturnValue) == 0x000020, "Member 'HWInterface_Skinnable_GetSkinnedStaticMeshInfo::ReturnValue' has a wrong offset!");

// Function Hemingway.HWInterface_Skinnable.IsSkinningReady
// 0x0001 (0x0001 - 0x0000)
struct HWInterface_Skinnable_IsSkinningReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWInterface_Skinnable_IsSkinningReady) == 0x000001, "Wrong alignment on HWInterface_Skinnable_IsSkinningReady");
static_assert(sizeof(HWInterface_Skinnable_IsSkinningReady) == 0x000001, "Wrong size on HWInterface_Skinnable_IsSkinningReady");
static_assert(offsetof(HWInterface_Skinnable_IsSkinningReady, ReturnValue) == 0x000000, "Member 'HWInterface_Skinnable_IsSkinningReady::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.ApplyCharacterItemToLoadout
// 0x0008 (0x0008 - 0x0000)
struct HWSkinnablePreviewActor_ApplyCharacterItemToLoadout final
{
public:
	const class UHWCharacterItem*                 CharacterItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_ApplyCharacterItemToLoadout) == 0x000008, "Wrong alignment on HWSkinnablePreviewActor_ApplyCharacterItemToLoadout");
static_assert(sizeof(HWSkinnablePreviewActor_ApplyCharacterItemToLoadout) == 0x000008, "Wrong size on HWSkinnablePreviewActor_ApplyCharacterItemToLoadout");
static_assert(offsetof(HWSkinnablePreviewActor_ApplyCharacterItemToLoadout, CharacterItem) == 0x000000, "Member 'HWSkinnablePreviewActor_ApplyCharacterItemToLoadout::CharacterItem' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.ApplySkinItemToLoadout
// 0x0008 (0x0008 - 0x0000)
struct HWSkinnablePreviewActor_ApplySkinItemToLoadout final
{
public:
	const class UHWSkinItem*                      SkinItem;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_ApplySkinItemToLoadout) == 0x000008, "Wrong alignment on HWSkinnablePreviewActor_ApplySkinItemToLoadout");
static_assert(sizeof(HWSkinnablePreviewActor_ApplySkinItemToLoadout) == 0x000008, "Wrong size on HWSkinnablePreviewActor_ApplySkinItemToLoadout");
static_assert(offsetof(HWSkinnablePreviewActor_ApplySkinItemToLoadout, SkinItem) == 0x000000, "Member 'HWSkinnablePreviewActor_ApplySkinItemToLoadout::SkinItem' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.HandleOnNewSkinTagAsset
// 0x0010 (0x0010 - 0x0000)
struct HWSkinnablePreviewActor_HandleOnNewSkinTagAsset final
{
public:
	TScriptInterface<class ISkinTagAssetInterface> NewSkinTagAsset;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_HandleOnNewSkinTagAsset) == 0x000008, "Wrong alignment on HWSkinnablePreviewActor_HandleOnNewSkinTagAsset");
static_assert(sizeof(HWSkinnablePreviewActor_HandleOnNewSkinTagAsset) == 0x000010, "Wrong size on HWSkinnablePreviewActor_HandleOnNewSkinTagAsset");
static_assert(offsetof(HWSkinnablePreviewActor_HandleOnNewSkinTagAsset, NewSkinTagAsset) == 0x000000, "Member 'HWSkinnablePreviewActor_HandleOnNewSkinTagAsset::NewSkinTagAsset' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.HandleOnSkinTagAssetRemoved
// 0x0010 (0x0010 - 0x0000)
struct HWSkinnablePreviewActor_HandleOnSkinTagAssetRemoved final
{
public:
	TScriptInterface<class ISkinTagAssetInterface> SkinTagAssetToRemove;                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_HandleOnSkinTagAssetRemoved) == 0x000008, "Wrong alignment on HWSkinnablePreviewActor_HandleOnSkinTagAssetRemoved");
static_assert(sizeof(HWSkinnablePreviewActor_HandleOnSkinTagAssetRemoved) == 0x000010, "Wrong size on HWSkinnablePreviewActor_HandleOnSkinTagAssetRemoved");
static_assert(offsetof(HWSkinnablePreviewActor_HandleOnSkinTagAssetRemoved, SkinTagAssetToRemove) == 0x000000, "Member 'HWSkinnablePreviewActor_HandleOnSkinTagAssetRemoved::SkinTagAssetToRemove' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.SetIntroPresentationType
// 0x0001 (0x0001 - 0x0000)
struct HWSkinnablePreviewActor_SetIntroPresentationType final
{
public:
	EIntroPresentationType                        Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_SetIntroPresentationType) == 0x000001, "Wrong alignment on HWSkinnablePreviewActor_SetIntroPresentationType");
static_assert(sizeof(HWSkinnablePreviewActor_SetIntroPresentationType) == 0x000001, "Wrong size on HWSkinnablePreviewActor_SetIntroPresentationType");
static_assert(offsetof(HWSkinnablePreviewActor_SetIntroPresentationType, Type) == 0x000000, "Member 'HWSkinnablePreviewActor_SetIntroPresentationType::Type' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.SetShowOnApparelApplication
// 0x0001 (0x0001 - 0x0000)
struct HWSkinnablePreviewActor_SetShowOnApparelApplication final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_SetShowOnApparelApplication) == 0x000001, "Wrong alignment on HWSkinnablePreviewActor_SetShowOnApparelApplication");
static_assert(sizeof(HWSkinnablePreviewActor_SetShowOnApparelApplication) == 0x000001, "Wrong size on HWSkinnablePreviewActor_SetShowOnApparelApplication");
static_assert(offsetof(HWSkinnablePreviewActor_SetShowOnApparelApplication, bValue) == 0x000000, "Member 'HWSkinnablePreviewActor_SetShowOnApparelApplication::bValue' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.SwapSkinTags
// 0x0010 (0x0010 - 0x0000)
struct HWSkinnablePreviewActor_SwapSkinTags final
{
public:
	struct FGameplayTag                           NewSkinTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OldSkinTag;                                        // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_SwapSkinTags) == 0x000004, "Wrong alignment on HWSkinnablePreviewActor_SwapSkinTags");
static_assert(sizeof(HWSkinnablePreviewActor_SwapSkinTags) == 0x000010, "Wrong size on HWSkinnablePreviewActor_SwapSkinTags");
static_assert(offsetof(HWSkinnablePreviewActor_SwapSkinTags, NewSkinTag) == 0x000000, "Member 'HWSkinnablePreviewActor_SwapSkinTags::NewSkinTag' has a wrong offset!");
static_assert(offsetof(HWSkinnablePreviewActor_SwapSkinTags, OldSkinTag) == 0x000008, "Member 'HWSkinnablePreviewActor_SwapSkinTags::OldSkinTag' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.TriggerLocalVoiceEvent
// 0x0008 (0x0008 - 0x0000)
struct HWSkinnablePreviewActor_TriggerLocalVoiceEvent final
{
public:
	struct FGameplayTag                           VoiceEvent;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_TriggerLocalVoiceEvent) == 0x000004, "Wrong alignment on HWSkinnablePreviewActor_TriggerLocalVoiceEvent");
static_assert(sizeof(HWSkinnablePreviewActor_TriggerLocalVoiceEvent) == 0x000008, "Wrong size on HWSkinnablePreviewActor_TriggerLocalVoiceEvent");
static_assert(offsetof(HWSkinnablePreviewActor_TriggerLocalVoiceEvent, VoiceEvent) == 0x000000, "Member 'HWSkinnablePreviewActor_TriggerLocalVoiceEvent::VoiceEvent' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.TriggerVoiceEvent
// 0x0010 (0x0010 - 0x0000)
struct HWSkinnablePreviewActor_TriggerVoiceEvent final
{
public:
	struct FGameplayTag                           VoiceEvent;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AudienceOverride;                                  // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_TriggerVoiceEvent) == 0x000004, "Wrong alignment on HWSkinnablePreviewActor_TriggerVoiceEvent");
static_assert(sizeof(HWSkinnablePreviewActor_TriggerVoiceEvent) == 0x000010, "Wrong size on HWSkinnablePreviewActor_TriggerVoiceEvent");
static_assert(offsetof(HWSkinnablePreviewActor_TriggerVoiceEvent, VoiceEvent) == 0x000000, "Member 'HWSkinnablePreviewActor_TriggerVoiceEvent::VoiceEvent' has a wrong offset!");
static_assert(offsetof(HWSkinnablePreviewActor_TriggerVoiceEvent, AudienceOverride) == 0x000008, "Member 'HWSkinnablePreviewActor_TriggerVoiceEvent::AudienceOverride' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.GetVoiceComponent
// 0x0008 (0x0008 - 0x0000)
struct HWSkinnablePreviewActor_GetVoiceComponent final
{
public:
	class UHWVoiceComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_GetVoiceComponent) == 0x000008, "Wrong alignment on HWSkinnablePreviewActor_GetVoiceComponent");
static_assert(sizeof(HWSkinnablePreviewActor_GetVoiceComponent) == 0x000008, "Wrong size on HWSkinnablePreviewActor_GetVoiceComponent");
static_assert(offsetof(HWSkinnablePreviewActor_GetVoiceComponent, ReturnValue) == 0x000000, "Member 'HWSkinnablePreviewActor_GetVoiceComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinnablePreviewActor.IsSkinningReady
// 0x0001 (0x0001 - 0x0000)
struct HWSkinnablePreviewActor_IsSkinningReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinnablePreviewActor_IsSkinningReady) == 0x000001, "Wrong alignment on HWSkinnablePreviewActor_IsSkinningReady");
static_assert(sizeof(HWSkinnablePreviewActor_IsSkinningReady) == 0x000001, "Wrong size on HWSkinnablePreviewActor_IsSkinningReady");
static_assert(offsetof(HWSkinnablePreviewActor_IsSkinningReady, ReturnValue) == 0x000000, "Member 'HWSkinnablePreviewActor_IsSkinningReady::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSkinEvoEvalComponent_Abilities.HandleAbilityFired
// 0x0030 (0x0030 - 0x0000)
struct HWSkinEvoEvalComponent_Abilities_HandleAbilityFired final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0008(0x0020)(ConstParm, Parm, NativeAccessSpecifierPublic)
	struct FHWAbilityFiringInstanceId             FiringInstanceId;                                  // 0x0028(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinEvoEvalComponent_Abilities_HandleAbilityFired) == 0x000008, "Wrong alignment on HWSkinEvoEvalComponent_Abilities_HandleAbilityFired");
static_assert(sizeof(HWSkinEvoEvalComponent_Abilities_HandleAbilityFired) == 0x000030, "Wrong size on HWSkinEvoEvalComponent_Abilities_HandleAbilityFired");
static_assert(offsetof(HWSkinEvoEvalComponent_Abilities_HandleAbilityFired, AbilityHandle) == 0x000000, "Member 'HWSkinEvoEvalComponent_Abilities_HandleAbilityFired::AbilityHandle' has a wrong offset!");
static_assert(offsetof(HWSkinEvoEvalComponent_Abilities_HandleAbilityFired, AbilityTags) == 0x000008, "Member 'HWSkinEvoEvalComponent_Abilities_HandleAbilityFired::AbilityTags' has a wrong offset!");
static_assert(offsetof(HWSkinEvoEvalComponent_Abilities_HandleAbilityFired, FiringInstanceId) == 0x000028, "Member 'HWSkinEvoEvalComponent_Abilities_HandleAbilityFired::FiringInstanceId' has a wrong offset!");

// Function Hemingway.HWSkinEvoEvalComponent_CharacterLevel.HandleCharacterLevelChanged
// 0x0008 (0x0008 - 0x0000)
struct HWSkinEvoEvalComponent_CharacterLevel_HandleCharacterLevelChanged final
{
public:
	int32                                         PreviousCharacterLevel;                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCharacterLevel;                                 // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSkinEvoEvalComponent_CharacterLevel_HandleCharacterLevelChanged) == 0x000004, "Wrong alignment on HWSkinEvoEvalComponent_CharacterLevel_HandleCharacterLevelChanged");
static_assert(sizeof(HWSkinEvoEvalComponent_CharacterLevel_HandleCharacterLevelChanged) == 0x000008, "Wrong size on HWSkinEvoEvalComponent_CharacterLevel_HandleCharacterLevelChanged");
static_assert(offsetof(HWSkinEvoEvalComponent_CharacterLevel_HandleCharacterLevelChanged, PreviousCharacterLevel) == 0x000000, "Member 'HWSkinEvoEvalComponent_CharacterLevel_HandleCharacterLevelChanged::PreviousCharacterLevel' has a wrong offset!");
static_assert(offsetof(HWSkinEvoEvalComponent_CharacterLevel_HandleCharacterLevelChanged, NewCharacterLevel) == 0x000004, "Member 'HWSkinEvoEvalComponent_CharacterLevel_HandleCharacterLevelChanged::NewCharacterLevel' has a wrong offset!");

// Function Hemingway.HWGameStatsTracker.GetAnnouncementComponent
// 0x0008 (0x0008 - 0x0000)
struct HWGameStatsTracker_GetAnnouncementComponent final
{
public:
	class UHWAnnouncementComponent*               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGameStatsTracker_GetAnnouncementComponent) == 0x000008, "Wrong alignment on HWGameStatsTracker_GetAnnouncementComponent");
static_assert(sizeof(HWGameStatsTracker_GetAnnouncementComponent) == 0x000008, "Wrong size on HWGameStatsTracker_GetAnnouncementComponent");
static_assert(offsetof(HWGameStatsTracker_GetAnnouncementComponent, ReturnValue) == 0x000000, "Member 'HWGameStatsTracker_GetAnnouncementComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddAllyHealingGrantedForAbility
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_AddAllyHealingGrantedForAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealingGranted;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddAllyHealingGrantedForAbility) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddAllyHealingGrantedForAbility");
static_assert(sizeof(HWPlayerStatsTracker_AddAllyHealingGrantedForAbility) == 0x00000C, "Wrong size on HWPlayerStatsTracker_AddAllyHealingGrantedForAbility");
static_assert(offsetof(HWPlayerStatsTracker_AddAllyHealingGrantedForAbility, AbilityTag) == 0x000000, "Member 'HWPlayerStatsTracker_AddAllyHealingGrantedForAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_AddAllyHealingGrantedForAbility, HealingGranted) == 0x000008, "Member 'HWPlayerStatsTracker_AddAllyHealingGrantedForAbility::HealingGranted' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddAssists
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddAssists final
{
public:
	int32                                         AssistsToAdd;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddAssists) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddAssists");
static_assert(sizeof(HWPlayerStatsTracker_AddAssists) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddAssists");
static_assert(offsetof(HWPlayerStatsTracker_AddAssists, AssistsToAdd) == 0x000000, "Member 'HWPlayerStatsTracker_AddAssists::AssistsToAdd' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddDamageDealtForAbility
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_AddDamageDealtForAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDealt;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddDamageDealtForAbility) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddDamageDealtForAbility");
static_assert(sizeof(HWPlayerStatsTracker_AddDamageDealtForAbility) == 0x00000C, "Wrong size on HWPlayerStatsTracker_AddDamageDealtForAbility");
static_assert(offsetof(HWPlayerStatsTracker_AddDamageDealtForAbility, AbilityTag) == 0x000000, "Member 'HWPlayerStatsTracker_AddDamageDealtForAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_AddDamageDealtForAbility, DamageDealt) == 0x000008, "Member 'HWPlayerStatsTracker_AddDamageDealtForAbility::DamageDealt' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddDamageMitigated
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddDamageMitigated final
{
public:
	float                                         MitigatedDamage;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddDamageMitigated) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddDamageMitigated");
static_assert(sizeof(HWPlayerStatsTracker_AddDamageMitigated) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddDamageMitigated");
static_assert(offsetof(HWPlayerStatsTracker_AddDamageMitigated, MitigatedDamage) == 0x000000, "Member 'HWPlayerStatsTracker_AddDamageMitigated::MitigatedDamage' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddDamageTaken
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddDamageTaken final
{
public:
	float                                         IncomingDamage;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddDamageTaken) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddDamageTaken");
static_assert(sizeof(HWPlayerStatsTracker_AddDamageTaken) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddDamageTaken");
static_assert(offsetof(HWPlayerStatsTracker_AddDamageTaken, IncomingDamage) == 0x000000, "Member 'HWPlayerStatsTracker_AddDamageTaken::IncomingDamage' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddDeaths
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddDeaths final
{
public:
	int32                                         DeathsToAdd;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddDeaths) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddDeaths");
static_assert(sizeof(HWPlayerStatsTracker_AddDeaths) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddDeaths");
static_assert(offsetof(HWPlayerStatsTracker_AddDeaths, DeathsToAdd) == 0x000000, "Member 'HWPlayerStatsTracker_AddDeaths::DeathsToAdd' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddHealingReceived
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddHealingReceived final
{
public:
	float                                         ReceivedHealing;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddHealingReceived) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddHealingReceived");
static_assert(sizeof(HWPlayerStatsTracker_AddHealingReceived) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddHealingReceived");
static_assert(offsetof(HWPlayerStatsTracker_AddHealingReceived, ReceivedHealing) == 0x000000, "Member 'HWPlayerStatsTracker_AddHealingReceived::ReceivedHealing' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddKills
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddKills final
{
public:
	int32                                         KillsToAdd;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddKills) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddKills");
static_assert(sizeof(HWPlayerStatsTracker_AddKills) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddKills");
static_assert(offsetof(HWPlayerStatsTracker_AddKills, KillsToAdd) == 0x000000, "Member 'HWPlayerStatsTracker_AddKills::KillsToAdd' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddMinionDamageForAbility
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_AddMinionDamageForAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDealt;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddMinionDamageForAbility) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddMinionDamageForAbility");
static_assert(sizeof(HWPlayerStatsTracker_AddMinionDamageForAbility) == 0x00000C, "Wrong size on HWPlayerStatsTracker_AddMinionDamageForAbility");
static_assert(offsetof(HWPlayerStatsTracker_AddMinionDamageForAbility, AbilityTag) == 0x000000, "Member 'HWPlayerStatsTracker_AddMinionDamageForAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_AddMinionDamageForAbility, DamageDealt) == 0x000008, "Member 'HWPlayerStatsTracker_AddMinionDamageForAbility::DamageDealt' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddNPCDamageForAbility
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_AddNPCDamageForAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDealt;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddNPCDamageForAbility) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddNPCDamageForAbility");
static_assert(sizeof(HWPlayerStatsTracker_AddNPCDamageForAbility) == 0x00000C, "Wrong size on HWPlayerStatsTracker_AddNPCDamageForAbility");
static_assert(offsetof(HWPlayerStatsTracker_AddNPCDamageForAbility, AbilityTag) == 0x000000, "Member 'HWPlayerStatsTracker_AddNPCDamageForAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_AddNPCDamageForAbility, DamageDealt) == 0x000008, "Member 'HWPlayerStatsTracker_AddNPCDamageForAbility::DamageDealt' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddSelfHealingGrantedForAbility
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_AddSelfHealingGrantedForAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealingGranted;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddSelfHealingGrantedForAbility) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddSelfHealingGrantedForAbility");
static_assert(sizeof(HWPlayerStatsTracker_AddSelfHealingGrantedForAbility) == 0x00000C, "Wrong size on HWPlayerStatsTracker_AddSelfHealingGrantedForAbility");
static_assert(offsetof(HWPlayerStatsTracker_AddSelfHealingGrantedForAbility, AbilityTag) == 0x000000, "Member 'HWPlayerStatsTracker_AddSelfHealingGrantedForAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_AddSelfHealingGrantedForAbility, HealingGranted) == 0x000008, "Member 'HWPlayerStatsTracker_AddSelfHealingGrantedForAbility::HealingGranted' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddStatusDuration
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_AddStatusDuration final
{
public:
	struct FGameplayTag                           StatusToTrack;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncrementalValue;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddStatusDuration) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddStatusDuration");
static_assert(sizeof(HWPlayerStatsTracker_AddStatusDuration) == 0x00000C, "Wrong size on HWPlayerStatsTracker_AddStatusDuration");
static_assert(offsetof(HWPlayerStatsTracker_AddStatusDuration, StatusToTrack) == 0x000000, "Member 'HWPlayerStatsTracker_AddStatusDuration::StatusToTrack' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_AddStatusDuration, IncrementalValue) == 0x000008, "Member 'HWPlayerStatsTracker_AddStatusDuration::IncrementalValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddStructureDamage
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddStructureDamage final
{
public:
	float                                         DamageToStructure;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddStructureDamage) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddStructureDamage");
static_assert(sizeof(HWPlayerStatsTracker_AddStructureDamage) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddStructureDamage");
static_assert(offsetof(HWPlayerStatsTracker_AddStructureDamage, DamageToStructure) == 0x000000, "Member 'HWPlayerStatsTracker_AddStructureDamage::DamageToStructure' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddTimeSpentDead
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddTimeSpentDead final
{
public:
	float                                         TimeDead;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddTimeSpentDead) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddTimeSpentDead");
static_assert(sizeof(HWPlayerStatsTracker_AddTimeSpentDead) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddTimeSpentDead");
static_assert(offsetof(HWPlayerStatsTracker_AddTimeSpentDead, TimeDead) == 0x000000, "Member 'HWPlayerStatsTracker_AddTimeSpentDead::TimeDead' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddToDeathStreak
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddToDeathStreak final
{
public:
	int32                                         DeathsToAdd;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddToDeathStreak) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddToDeathStreak");
static_assert(sizeof(HWPlayerStatsTracker_AddToDeathStreak) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddToDeathStreak");
static_assert(offsetof(HWPlayerStatsTracker_AddToDeathStreak, DeathsToAdd) == 0x000000, "Member 'HWPlayerStatsTracker_AddToDeathStreak::DeathsToAdd' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddToKillStreak
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddToKillStreak final
{
public:
	int32                                         KillsToAdd;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddToKillStreak) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddToKillStreak");
static_assert(sizeof(HWPlayerStatsTracker_AddToKillStreak) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddToKillStreak");
static_assert(offsetof(HWPlayerStatsTracker_AddToKillStreak, KillsToAdd) == 0x000000, "Member 'HWPlayerStatsTracker_AddToKillStreak::KillsToAdd' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.AddWardCount
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_AddWardCount final
{
public:
	int32                                         NumWardsToAdd;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_AddWardCount) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_AddWardCount");
static_assert(sizeof(HWPlayerStatsTracker_AddWardCount) == 0x000004, "Wrong size on HWPlayerStatsTracker_AddWardCount");
static_assert(offsetof(HWPlayerStatsTracker_AddWardCount, NumWardsToAdd) == 0x000000, "Member 'HWPlayerStatsTracker_AddWardCount::NumWardsToAdd' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetAllyHealingAbilities
// 0x0020 (0x0020 - 0x0000)
struct HWPlayerStatsTracker_GetAllyHealingAbilities final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetAllyHealingAbilities) == 0x000008, "Wrong alignment on HWPlayerStatsTracker_GetAllyHealingAbilities");
static_assert(sizeof(HWPlayerStatsTracker_GetAllyHealingAbilities) == 0x000020, "Wrong size on HWPlayerStatsTracker_GetAllyHealingAbilities");
static_assert(offsetof(HWPlayerStatsTracker_GetAllyHealingAbilities, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetAllyHealingAbilities::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetCombatStatusTagList
// 0x0020 (0x0020 - 0x0000)
struct HWPlayerStatsTracker_GetCombatStatusTagList final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetCombatStatusTagList) == 0x000008, "Wrong alignment on HWPlayerStatsTracker_GetCombatStatusTagList");
static_assert(sizeof(HWPlayerStatsTracker_GetCombatStatusTagList) == 0x000020, "Wrong size on HWPlayerStatsTracker_GetCombatStatusTagList");
static_assert(offsetof(HWPlayerStatsTracker_GetCombatStatusTagList, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetCombatStatusTagList::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetDamageDealtAbilities
// 0x0020 (0x0020 - 0x0000)
struct HWPlayerStatsTracker_GetDamageDealtAbilities final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetDamageDealtAbilities) == 0x000008, "Wrong alignment on HWPlayerStatsTracker_GetDamageDealtAbilities");
static_assert(sizeof(HWPlayerStatsTracker_GetDamageDealtAbilities) == 0x000020, "Wrong size on HWPlayerStatsTracker_GetDamageDealtAbilities");
static_assert(offsetof(HWPlayerStatsTracker_GetDamageDealtAbilities, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetDamageDealtAbilities::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetMinionDamageAbilities
// 0x0020 (0x0020 - 0x0000)
struct HWPlayerStatsTracker_GetMinionDamageAbilities final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetMinionDamageAbilities) == 0x000008, "Wrong alignment on HWPlayerStatsTracker_GetMinionDamageAbilities");
static_assert(sizeof(HWPlayerStatsTracker_GetMinionDamageAbilities) == 0x000020, "Wrong size on HWPlayerStatsTracker_GetMinionDamageAbilities");
static_assert(offsetof(HWPlayerStatsTracker_GetMinionDamageAbilities, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetMinionDamageAbilities::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetNPCDamageAbilities
// 0x0020 (0x0020 - 0x0000)
struct HWPlayerStatsTracker_GetNPCDamageAbilities final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetNPCDamageAbilities) == 0x000008, "Wrong alignment on HWPlayerStatsTracker_GetNPCDamageAbilities");
static_assert(sizeof(HWPlayerStatsTracker_GetNPCDamageAbilities) == 0x000020, "Wrong size on HWPlayerStatsTracker_GetNPCDamageAbilities");
static_assert(offsetof(HWPlayerStatsTracker_GetNPCDamageAbilities, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetNPCDamageAbilities::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetSelfHealingAbilities
// 0x0020 (0x0020 - 0x0000)
struct HWPlayerStatsTracker_GetSelfHealingAbilities final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetSelfHealingAbilities) == 0x000008, "Wrong alignment on HWPlayerStatsTracker_GetSelfHealingAbilities");
static_assert(sizeof(HWPlayerStatsTracker_GetSelfHealingAbilities) == 0x000020, "Wrong size on HWPlayerStatsTracker_GetSelfHealingAbilities");
static_assert(offsetof(HWPlayerStatsTracker_GetSelfHealingAbilities, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetSelfHealingAbilities::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalHealingReceived
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalHealingReceived final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalHealingReceived) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalHealingReceived");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalHealingReceived) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalHealingReceived");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalHealingReceived, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalHealingReceived::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.IncrementBackendStat
// 0x0018 (0x0018 - 0x0000)
struct HWPlayerStatsTracker_IncrementBackendStat final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerStatsTracker_IncrementBackendStat) == 0x000008, "Wrong alignment on HWPlayerStatsTracker_IncrementBackendStat");
static_assert(sizeof(HWPlayerStatsTracker_IncrementBackendStat) == 0x000018, "Wrong size on HWPlayerStatsTracker_IncrementBackendStat");
static_assert(offsetof(HWPlayerStatsTracker_IncrementBackendStat, Key) == 0x000000, "Member 'HWPlayerStatsTracker_IncrementBackendStat::Key' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_IncrementBackendStat, Value) == 0x000010, "Member 'HWPlayerStatsTracker_IncrementBackendStat::Value' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_Assists
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_Assists final
{
public:
	int32                                         OldAssists;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_Assists) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_Assists");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_Assists) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_Assists");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_Assists, OldAssists) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_Assists::OldAssists' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_DamageMitigated
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_DamageMitigated final
{
public:
	float                                         OldDamageMitigated;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_DamageMitigated) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_DamageMitigated");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_DamageMitigated) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_DamageMitigated");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_DamageMitigated, OldDamageMitigated) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_DamageMitigated::OldDamageMitigated' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_DamageTaken
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_DamageTaken final
{
public:
	float                                         OldDamageTaken;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_DamageTaken) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_DamageTaken");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_DamageTaken) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_DamageTaken");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_DamageTaken, OldDamageTaken) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_DamageTaken::OldDamageTaken' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_Deaths
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_Deaths final
{
public:
	int32                                         OldDeaths;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_Deaths) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_Deaths");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_Deaths) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_Deaths");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_Deaths, OldDeaths) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_Deaths::OldDeaths' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_DeathStreak
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_DeathStreak final
{
public:
	int32                                         OldDeathStreak;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_DeathStreak) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_DeathStreak");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_DeathStreak) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_DeathStreak");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_DeathStreak, OldDeathStreak) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_DeathStreak::OldDeathStreak' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_FireGiantsKilled
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_FireGiantsKilled final
{
public:
	int32                                         OldFireGiantsKilled;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_FireGiantsKilled) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_FireGiantsKilled");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_FireGiantsKilled) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_FireGiantsKilled");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_FireGiantsKilled, OldFireGiantsKilled) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_FireGiantsKilled::OldFireGiantsKilled' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_GoldFuriesKilled
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_GoldFuriesKilled final
{
public:
	int32                                         OldGoldFuriesKilled;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_GoldFuriesKilled) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_GoldFuriesKilled");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_GoldFuriesKilled) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_GoldFuriesKilled");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_GoldFuriesKilled, OldGoldFuriesKilled) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_GoldFuriesKilled::OldGoldFuriesKilled' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_Kills
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_Kills final
{
public:
	int32                                         OldKills;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_Kills) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_Kills");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_Kills) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_Kills");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_Kills, OldKills) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_Kills::OldKills' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_KillStreak
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_KillStreak final
{
public:
	int32                                         OldKillStreak;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_KillStreak) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_KillStreak");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_KillStreak) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_KillStreak");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_KillStreak, OldKillStreak) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_KillStreak::OldKillStreak' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_MinionsKilled
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_MinionsKilled final
{
public:
	int32                                         OldMinionsKilled;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_MinionsKilled) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_MinionsKilled");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_MinionsKilled) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_MinionsKilled");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_MinionsKilled, OldMinionsKilled) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_MinionsKilled::OldMinionsKilled' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_PhoenixesKilled
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_PhoenixesKilled final
{
public:
	int32                                         OldPhoenixesKilled;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_PhoenixesKilled) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_PhoenixesKilled");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_PhoenixesKilled) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_PhoenixesKilled");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_PhoenixesKilled, OldPhoenixesKilled) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_PhoenixesKilled::OldPhoenixesKilled' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_StructureDamage
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_StructureDamage final
{
public:
	float                                         OldStructureDamage;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_StructureDamage) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_StructureDamage");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_StructureDamage) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_StructureDamage");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_StructureDamage, OldStructureDamage) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_StructureDamage::OldStructureDamage' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_TitansKilled
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_TitansKilled final
{
public:
	int32                                         OldTitansKilled;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_TitansKilled) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_TitansKilled");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_TitansKilled) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_TitansKilled");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_TitansKilled, OldTitansKilled) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_TitansKilled::OldTitansKilled' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_TotalAllyHealing
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_TotalAllyHealing final
{
public:
	float                                         OldTotalAllyHealing;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_TotalAllyHealing) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_TotalAllyHealing");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_TotalAllyHealing) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_TotalAllyHealing");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_TotalAllyHealing, OldTotalAllyHealing) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_TotalAllyHealing::OldTotalAllyHealing' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_TotalDamage
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_TotalDamage final
{
public:
	float                                         OldTotalDamage;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_TotalDamage) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_TotalDamage");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_TotalDamage) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_TotalDamage");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_TotalDamage, OldTotalDamage) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_TotalDamage::OldTotalDamage' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_TotalGoldEarned
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_TotalGoldEarned final
{
public:
	float                                         OldTotalGoldEarned;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_TotalGoldEarned) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_TotalGoldEarned");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_TotalGoldEarned) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_TotalGoldEarned");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_TotalGoldEarned, OldTotalGoldEarned) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_TotalGoldEarned::OldTotalGoldEarned' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_TotalMinionDamage
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_TotalMinionDamage final
{
public:
	float                                         OldTotalMinionDamage;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_TotalMinionDamage) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_TotalMinionDamage");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_TotalMinionDamage) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_TotalMinionDamage");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_TotalMinionDamage, OldTotalMinionDamage) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_TotalMinionDamage::OldTotalMinionDamage' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_TotalNPCDamage
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_TotalNPCDamage final
{
public:
	float                                         OldTotalNPCDamage;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_TotalNPCDamage) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_TotalNPCDamage");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_TotalNPCDamage) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_TotalNPCDamage");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_TotalNPCDamage, OldTotalNPCDamage) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_TotalNPCDamage::OldTotalNPCDamage' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_TotalSelfHealing
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_TotalSelfHealing final
{
public:
	float                                         OldTotalSelfHealing;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_TotalSelfHealing) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_TotalSelfHealing");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_TotalSelfHealing) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_TotalSelfHealing");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_TotalSelfHealing, OldTotalSelfHealing) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_TotalSelfHealing::OldTotalSelfHealing' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_TotalXPEarned
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_TotalXPEarned final
{
public:
	float                                         OldTotalXPEarned;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_TotalXPEarned) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_TotalXPEarned");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_TotalXPEarned) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_TotalXPEarned");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_TotalXPEarned, OldTotalXPEarned) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_TotalXPEarned::OldTotalXPEarned' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.OnRep_TowersKilled
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_OnRep_TowersKilled final
{
public:
	int32                                         OldTowersKilled;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_OnRep_TowersKilled) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_OnRep_TowersKilled");
static_assert(sizeof(HWPlayerStatsTracker_OnRep_TowersKilled) == 0x000004, "Wrong size on HWPlayerStatsTracker_OnRep_TowersKilled");
static_assert(offsetof(HWPlayerStatsTracker_OnRep_TowersKilled, OldTowersKilled) == 0x000000, "Member 'HWPlayerStatsTracker_OnRep_TowersKilled::OldTowersKilled' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.ResetBackendStat
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerStatsTracker_ResetBackendStat final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_ResetBackendStat) == 0x000008, "Wrong alignment on HWPlayerStatsTracker_ResetBackendStat");
static_assert(sizeof(HWPlayerStatsTracker_ResetBackendStat) == 0x000010, "Wrong size on HWPlayerStatsTracker_ResetBackendStat");
static_assert(offsetof(HWPlayerStatsTracker_ResetBackendStat, Key) == 0x000000, "Member 'HWPlayerStatsTracker_ResetBackendStat::Key' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.SetAssists
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_SetAssists final
{
public:
	int32                                         NewAssists;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_SetAssists) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_SetAssists");
static_assert(sizeof(HWPlayerStatsTracker_SetAssists) == 0x000004, "Wrong size on HWPlayerStatsTracker_SetAssists");
static_assert(offsetof(HWPlayerStatsTracker_SetAssists, NewAssists) == 0x000000, "Member 'HWPlayerStatsTracker_SetAssists::NewAssists' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.SetDeaths
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_SetDeaths final
{
public:
	int32                                         NewDeaths;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_SetDeaths) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_SetDeaths");
static_assert(sizeof(HWPlayerStatsTracker_SetDeaths) == 0x000004, "Wrong size on HWPlayerStatsTracker_SetDeaths");
static_assert(offsetof(HWPlayerStatsTracker_SetDeaths, NewDeaths) == 0x000000, "Member 'HWPlayerStatsTracker_SetDeaths::NewDeaths' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.SetDeathStreak
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_SetDeathStreak final
{
public:
	int32                                         NewDeathStreak;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_SetDeathStreak) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_SetDeathStreak");
static_assert(sizeof(HWPlayerStatsTracker_SetDeathStreak) == 0x000004, "Wrong size on HWPlayerStatsTracker_SetDeathStreak");
static_assert(offsetof(HWPlayerStatsTracker_SetDeathStreak, NewDeathStreak) == 0x000000, "Member 'HWPlayerStatsTracker_SetDeathStreak::NewDeathStreak' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.SetKills
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_SetKills final
{
public:
	int32                                         NewKills;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_SetKills) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_SetKills");
static_assert(sizeof(HWPlayerStatsTracker_SetKills) == 0x000004, "Wrong size on HWPlayerStatsTracker_SetKills");
static_assert(offsetof(HWPlayerStatsTracker_SetKills, NewKills) == 0x000000, "Member 'HWPlayerStatsTracker_SetKills::NewKills' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.SetKillStreak
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_SetKillStreak final
{
public:
	int32                                         NewKillStreak;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_SetKillStreak) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_SetKillStreak");
static_assert(sizeof(HWPlayerStatsTracker_SetKillStreak) == 0x000004, "Wrong size on HWPlayerStatsTracker_SetKillStreak");
static_assert(offsetof(HWPlayerStatsTracker_SetKillStreak, NewKillStreak) == 0x000000, "Member 'HWPlayerStatsTracker_SetKillStreak::NewKillStreak' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.SetStreakModifier
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_SetStreakModifier final
{
public:
	int32                                         InStreakModifier;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_SetStreakModifier) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_SetStreakModifier");
static_assert(sizeof(HWPlayerStatsTracker_SetStreakModifier) == 0x000004, "Wrong size on HWPlayerStatsTracker_SetStreakModifier");
static_assert(offsetof(HWPlayerStatsTracker_SetStreakModifier, InStreakModifier) == 0x000000, "Member 'HWPlayerStatsTracker_SetStreakModifier::InStreakModifier' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.UpdateTotalGoldEarned
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_UpdateTotalGoldEarned final
{
public:
	float                                         GoldToAdd;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_UpdateTotalGoldEarned) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_UpdateTotalGoldEarned");
static_assert(sizeof(HWPlayerStatsTracker_UpdateTotalGoldEarned) == 0x000004, "Wrong size on HWPlayerStatsTracker_UpdateTotalGoldEarned");
static_assert(offsetof(HWPlayerStatsTracker_UpdateTotalGoldEarned, GoldToAdd) == 0x000000, "Member 'HWPlayerStatsTracker_UpdateTotalGoldEarned::GoldToAdd' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.UpdateTotalXPEarned
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_UpdateTotalXPEarned final
{
public:
	float                                         XPToAdd;                                           // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_UpdateTotalXPEarned) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_UpdateTotalXPEarned");
static_assert(sizeof(HWPlayerStatsTracker_UpdateTotalXPEarned) == 0x000004, "Wrong size on HWPlayerStatsTracker_UpdateTotalXPEarned");
static_assert(offsetof(HWPlayerStatsTracker_UpdateTotalXPEarned, XPToAdd) == 0x000000, "Member 'HWPlayerStatsTracker_UpdateTotalXPEarned::XPToAdd' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetAccoladeComponent
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerStatsTracker_GetAccoladeComponent final
{
public:
	class UHWAccoladeComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetAccoladeComponent) == 0x000008, "Wrong alignment on HWPlayerStatsTracker_GetAccoladeComponent");
static_assert(sizeof(HWPlayerStatsTracker_GetAccoladeComponent) == 0x000008, "Wrong size on HWPlayerStatsTracker_GetAccoladeComponent");
static_assert(offsetof(HWPlayerStatsTracker_GetAccoladeComponent, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetAccoladeComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetAssists
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetAssists final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetAssists) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetAssists");
static_assert(sizeof(HWPlayerStatsTracker_GetAssists) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetAssists");
static_assert(offsetof(HWPlayerStatsTracker_GetAssists, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetAssists::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetBackendStatValue
// 0x0018 (0x0018 - 0x0000)
struct HWPlayerStatsTracker_GetBackendStatValue final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWPlayerStatsTracker_GetBackendStatValue) == 0x000008, "Wrong alignment on HWPlayerStatsTracker_GetBackendStatValue");
static_assert(sizeof(HWPlayerStatsTracker_GetBackendStatValue) == 0x000018, "Wrong size on HWPlayerStatsTracker_GetBackendStatValue");
static_assert(offsetof(HWPlayerStatsTracker_GetBackendStatValue, Key) == 0x000000, "Member 'HWPlayerStatsTracker_GetBackendStatValue::Key' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_GetBackendStatValue, ReturnValue) == 0x000010, "Member 'HWPlayerStatsTracker_GetBackendStatValue::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetDeaths
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetDeaths final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetDeaths) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetDeaths");
static_assert(sizeof(HWPlayerStatsTracker_GetDeaths) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetDeaths");
static_assert(offsetof(HWPlayerStatsTracker_GetDeaths, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetDeaths::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetDeathStreak
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetDeathStreak final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetDeathStreak) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetDeathStreak");
static_assert(sizeof(HWPlayerStatsTracker_GetDeathStreak) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetDeathStreak");
static_assert(offsetof(HWPlayerStatsTracker_GetDeathStreak, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetDeathStreak::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetKills
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetKills) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetKills");
static_assert(sizeof(HWPlayerStatsTracker_GetKills) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetKills");
static_assert(offsetof(HWPlayerStatsTracker_GetKills, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetKills::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetKillStreak
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetKillStreak final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetKillStreak) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetKillStreak");
static_assert(sizeof(HWPlayerStatsTracker_GetKillStreak) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetKillStreak");
static_assert(offsetof(HWPlayerStatsTracker_GetKillStreak, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetKillStreak::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetStreakModifier
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetStreakModifier final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetStreakModifier) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetStreakModifier");
static_assert(sizeof(HWPlayerStatsTracker_GetStreakModifier) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetStreakModifier");
static_assert(offsetof(HWPlayerStatsTracker_GetStreakModifier, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetStreakModifier::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTimeSpentDead
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTimeSpentDead final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTimeSpentDead) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTimeSpentDead");
static_assert(sizeof(HWPlayerStatsTracker_GetTimeSpentDead) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTimeSpentDead");
static_assert(offsetof(HWPlayerStatsTracker_GetTimeSpentDead, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTimeSpentDead::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalAllyHealingGranted
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalAllyHealingGranted final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalAllyHealingGranted) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalAllyHealingGranted");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalAllyHealingGranted) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalAllyHealingGranted");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalAllyHealingGranted, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalAllyHealingGranted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalALlyHealingGrantedForAbility
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_GetTotalALlyHealingGrantedForAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalALlyHealingGrantedForAbility) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalALlyHealingGrantedForAbility");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalALlyHealingGrantedForAbility) == 0x00000C, "Wrong size on HWPlayerStatsTracker_GetTotalALlyHealingGrantedForAbility");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalALlyHealingGrantedForAbility, AbilityTag) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalALlyHealingGrantedForAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalALlyHealingGrantedForAbility, ReturnValue) == 0x000008, "Member 'HWPlayerStatsTracker_GetTotalALlyHealingGrantedForAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalDamageDealt
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalDamageDealt final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalDamageDealt) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalDamageDealt");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalDamageDealt) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalDamageDealt");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalDamageDealt, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalDamageDealt::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalDamageDealtForAbility
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_GetTotalDamageDealtForAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalDamageDealtForAbility) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalDamageDealtForAbility");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalDamageDealtForAbility) == 0x00000C, "Wrong size on HWPlayerStatsTracker_GetTotalDamageDealtForAbility");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalDamageDealtForAbility, AbilityTag) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalDamageDealtForAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalDamageDealtForAbility, ReturnValue) == 0x000008, "Member 'HWPlayerStatsTracker_GetTotalDamageDealtForAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalDamageMitigated
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalDamageMitigated final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalDamageMitigated) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalDamageMitigated");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalDamageMitigated) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalDamageMitigated");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalDamageMitigated, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalDamageMitigated::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalDamageTaken
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalDamageTaken final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalDamageTaken) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalDamageTaken");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalDamageTaken) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalDamageTaken");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalDamageTaken, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalDamageTaken::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalGoldEarned
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalGoldEarned final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalGoldEarned) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalGoldEarned");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalGoldEarned) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalGoldEarned");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalGoldEarned, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalGoldEarned::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalMinionDamage
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalMinionDamage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalMinionDamage) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalMinionDamage");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalMinionDamage) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalMinionDamage");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalMinionDamage, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalMinionDamage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalMinionDamageForAbility
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_GetTotalMinionDamageForAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalMinionDamageForAbility) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalMinionDamageForAbility");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalMinionDamageForAbility) == 0x00000C, "Wrong size on HWPlayerStatsTracker_GetTotalMinionDamageForAbility");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalMinionDamageForAbility, AbilityTag) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalMinionDamageForAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalMinionDamageForAbility, ReturnValue) == 0x000008, "Member 'HWPlayerStatsTracker_GetTotalMinionDamageForAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalNPCDamage
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalNPCDamage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalNPCDamage) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalNPCDamage");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalNPCDamage) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalNPCDamage");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalNPCDamage, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalNPCDamage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalNPCDamageForAbility
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_GetTotalNPCDamageForAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalNPCDamageForAbility) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalNPCDamageForAbility");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalNPCDamageForAbility) == 0x00000C, "Wrong size on HWPlayerStatsTracker_GetTotalNPCDamageForAbility");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalNPCDamageForAbility, AbilityTag) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalNPCDamageForAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalNPCDamageForAbility, ReturnValue) == 0x000008, "Member 'HWPlayerStatsTracker_GetTotalNPCDamageForAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalSelfHealingGranted
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalSelfHealingGranted final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalSelfHealingGranted) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalSelfHealingGranted");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalSelfHealingGranted) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalSelfHealingGranted");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalSelfHealingGranted, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalSelfHealingGranted::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalSelfHealingGrantedForAbility
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_GetTotalSelfHealingGrantedForAbility final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalSelfHealingGrantedForAbility) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalSelfHealingGrantedForAbility");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalSelfHealingGrantedForAbility) == 0x00000C, "Wrong size on HWPlayerStatsTracker_GetTotalSelfHealingGrantedForAbility");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalSelfHealingGrantedForAbility, AbilityTag) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalSelfHealingGrantedForAbility::AbilityTag' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalSelfHealingGrantedForAbility, ReturnValue) == 0x000008, "Member 'HWPlayerStatsTracker_GetTotalSelfHealingGrantedForAbility::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalStatusDuration
// 0x000C (0x000C - 0x0000)
struct HWPlayerStatsTracker_GetTotalStatusDuration final
{
public:
	struct FGameplayTag                           RelevantStat;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalStatusDuration) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalStatusDuration");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalStatusDuration) == 0x00000C, "Wrong size on HWPlayerStatsTracker_GetTotalStatusDuration");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalStatusDuration, RelevantStat) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalStatusDuration::RelevantStat' has a wrong offset!");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalStatusDuration, ReturnValue) == 0x000008, "Member 'HWPlayerStatsTracker_GetTotalStatusDuration::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalStructureDamage
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalStructureDamage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalStructureDamage) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalStructureDamage");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalStructureDamage) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalStructureDamage");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalStructureDamage, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalStructureDamage::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalWardsPlaced
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalWardsPlaced final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalWardsPlaced) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalWardsPlaced");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalWardsPlaced) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalWardsPlaced");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalWardsPlaced, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalWardsPlaced::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerStatsTracker.GetTotalXPEarned
// 0x0004 (0x0004 - 0x0000)
struct HWPlayerStatsTracker_GetTotalXPEarned final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerStatsTracker_GetTotalXPEarned) == 0x000004, "Wrong alignment on HWPlayerStatsTracker_GetTotalXPEarned");
static_assert(sizeof(HWPlayerStatsTracker_GetTotalXPEarned) == 0x000004, "Wrong size on HWPlayerStatsTracker_GetTotalXPEarned");
static_assert(offsetof(HWPlayerStatsTracker_GetTotalXPEarned, ReturnValue) == 0x000000, "Member 'HWPlayerStatsTracker_GetTotalXPEarned::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.AddFireGiantKills
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_AddFireGiantKills final
{
public:
	int32                                         KillsToAdd;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_AddFireGiantKills) == 0x000004, "Wrong alignment on HWTeamStatsTracker_AddFireGiantKills");
static_assert(sizeof(HWTeamStatsTracker_AddFireGiantKills) == 0x000004, "Wrong size on HWTeamStatsTracker_AddFireGiantKills");
static_assert(offsetof(HWTeamStatsTracker_AddFireGiantKills, KillsToAdd) == 0x000000, "Member 'HWTeamStatsTracker_AddFireGiantKills::KillsToAdd' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.AddGoldFuryKills
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_AddGoldFuryKills final
{
public:
	int32                                         KillsToAdd;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_AddGoldFuryKills) == 0x000004, "Wrong alignment on HWTeamStatsTracker_AddGoldFuryKills");
static_assert(sizeof(HWTeamStatsTracker_AddGoldFuryKills) == 0x000004, "Wrong size on HWTeamStatsTracker_AddGoldFuryKills");
static_assert(offsetof(HWTeamStatsTracker_AddGoldFuryKills, KillsToAdd) == 0x000000, "Member 'HWTeamStatsTracker_AddGoldFuryKills::KillsToAdd' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.AddPyromancerKills
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_AddPyromancerKills final
{
public:
	int32                                         KillsToAdd;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_AddPyromancerKills) == 0x000004, "Wrong alignment on HWTeamStatsTracker_AddPyromancerKills");
static_assert(sizeof(HWTeamStatsTracker_AddPyromancerKills) == 0x000004, "Wrong size on HWTeamStatsTracker_AddPyromancerKills");
static_assert(offsetof(HWTeamStatsTracker_AddPyromancerKills, KillsToAdd) == 0x000000, "Member 'HWTeamStatsTracker_AddPyromancerKills::KillsToAdd' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.HandleDamageMitigatedUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWTeamStatsTracker_HandleDamageMitigatedUpdated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldDamageMitigated;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewDamageMitigated;                                // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_HandleDamageMitigatedUpdated) == 0x000008, "Wrong alignment on HWTeamStatsTracker_HandleDamageMitigatedUpdated");
static_assert(sizeof(HWTeamStatsTracker_HandleDamageMitigatedUpdated) == 0x000010, "Wrong size on HWTeamStatsTracker_HandleDamageMitigatedUpdated");
static_assert(offsetof(HWTeamStatsTracker_HandleDamageMitigatedUpdated, PlayerState) == 0x000000, "Member 'HWTeamStatsTracker_HandleDamageMitigatedUpdated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandleDamageMitigatedUpdated, OldDamageMitigated) == 0x000008, "Member 'HWTeamStatsTracker_HandleDamageMitigatedUpdated::OldDamageMitigated' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandleDamageMitigatedUpdated, NewDamageMitigated) == 0x00000C, "Member 'HWTeamStatsTracker_HandleDamageMitigatedUpdated::NewDamageMitigated' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.HandlePlayerAssistsUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWTeamStatsTracker_HandlePlayerAssistsUpdated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldAssists;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewAssists;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_HandlePlayerAssistsUpdated) == 0x000008, "Wrong alignment on HWTeamStatsTracker_HandlePlayerAssistsUpdated");
static_assert(sizeof(HWTeamStatsTracker_HandlePlayerAssistsUpdated) == 0x000010, "Wrong size on HWTeamStatsTracker_HandlePlayerAssistsUpdated");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerAssistsUpdated, PlayerState) == 0x000000, "Member 'HWTeamStatsTracker_HandlePlayerAssistsUpdated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerAssistsUpdated, OldAssists) == 0x000008, "Member 'HWTeamStatsTracker_HandlePlayerAssistsUpdated::OldAssists' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerAssistsUpdated, NewAssists) == 0x00000C, "Member 'HWTeamStatsTracker_HandlePlayerAssistsUpdated::NewAssists' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.HandlePlayerDeathsUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWTeamStatsTracker_HandlePlayerDeathsUpdated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldDeaths;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewDeaths;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_HandlePlayerDeathsUpdated) == 0x000008, "Wrong alignment on HWTeamStatsTracker_HandlePlayerDeathsUpdated");
static_assert(sizeof(HWTeamStatsTracker_HandlePlayerDeathsUpdated) == 0x000010, "Wrong size on HWTeamStatsTracker_HandlePlayerDeathsUpdated");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerDeathsUpdated, PlayerState) == 0x000000, "Member 'HWTeamStatsTracker_HandlePlayerDeathsUpdated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerDeathsUpdated, OldDeaths) == 0x000008, "Member 'HWTeamStatsTracker_HandlePlayerDeathsUpdated::OldDeaths' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerDeathsUpdated, NewDeaths) == 0x00000C, "Member 'HWTeamStatsTracker_HandlePlayerDeathsUpdated::NewDeaths' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.HandlePlayerKillsUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWTeamStatsTracker_HandlePlayerKillsUpdated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldKills;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewKills;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_HandlePlayerKillsUpdated) == 0x000008, "Wrong alignment on HWTeamStatsTracker_HandlePlayerKillsUpdated");
static_assert(sizeof(HWTeamStatsTracker_HandlePlayerKillsUpdated) == 0x000010, "Wrong size on HWTeamStatsTracker_HandlePlayerKillsUpdated");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerKillsUpdated, PlayerState) == 0x000000, "Member 'HWTeamStatsTracker_HandlePlayerKillsUpdated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerKillsUpdated, OldKills) == 0x000008, "Member 'HWTeamStatsTracker_HandlePlayerKillsUpdated::OldKills' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerKillsUpdated, NewKills) == 0x00000C, "Member 'HWTeamStatsTracker_HandlePlayerKillsUpdated::NewKills' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.HandlePlayerStatsReplicated
// 0x0010 (0x0010 - 0x0000)
struct HWTeamStatsTracker_HandlePlayerStatsReplicated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWPlayerStatsTracker*                  PlayerStats;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_HandlePlayerStatsReplicated) == 0x000008, "Wrong alignment on HWTeamStatsTracker_HandlePlayerStatsReplicated");
static_assert(sizeof(HWTeamStatsTracker_HandlePlayerStatsReplicated) == 0x000010, "Wrong size on HWTeamStatsTracker_HandlePlayerStatsReplicated");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerStatsReplicated, PlayerState) == 0x000000, "Member 'HWTeamStatsTracker_HandlePlayerStatsReplicated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandlePlayerStatsReplicated, PlayerStats) == 0x000008, "Member 'HWTeamStatsTracker_HandlePlayerStatsReplicated::PlayerStats' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.HandleTotalDamageDealtUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWTeamStatsTracker_HandleTotalDamageDealtUpdated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldTotalDamageDealt;                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewTotalDamageDealt;                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_HandleTotalDamageDealtUpdated) == 0x000008, "Wrong alignment on HWTeamStatsTracker_HandleTotalDamageDealtUpdated");
static_assert(sizeof(HWTeamStatsTracker_HandleTotalDamageDealtUpdated) == 0x000010, "Wrong size on HWTeamStatsTracker_HandleTotalDamageDealtUpdated");
static_assert(offsetof(HWTeamStatsTracker_HandleTotalDamageDealtUpdated, PlayerState) == 0x000000, "Member 'HWTeamStatsTracker_HandleTotalDamageDealtUpdated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandleTotalDamageDealtUpdated, OldTotalDamageDealt) == 0x000008, "Member 'HWTeamStatsTracker_HandleTotalDamageDealtUpdated::OldTotalDamageDealt' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandleTotalDamageDealtUpdated, NewTotalDamageDealt) == 0x00000C, "Member 'HWTeamStatsTracker_HandleTotalDamageDealtUpdated::NewTotalDamageDealt' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.HandleTotalGoldEarnedUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWTeamStatsTracker_HandleTotalGoldEarnedUpdated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldTotalGoldEarned;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewTotalGoldEarned;                                // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_HandleTotalGoldEarnedUpdated) == 0x000008, "Wrong alignment on HWTeamStatsTracker_HandleTotalGoldEarnedUpdated");
static_assert(sizeof(HWTeamStatsTracker_HandleTotalGoldEarnedUpdated) == 0x000010, "Wrong size on HWTeamStatsTracker_HandleTotalGoldEarnedUpdated");
static_assert(offsetof(HWTeamStatsTracker_HandleTotalGoldEarnedUpdated, PlayerState) == 0x000000, "Member 'HWTeamStatsTracker_HandleTotalGoldEarnedUpdated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandleTotalGoldEarnedUpdated, OldTotalGoldEarned) == 0x000008, "Member 'HWTeamStatsTracker_HandleTotalGoldEarnedUpdated::OldTotalGoldEarned' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandleTotalGoldEarnedUpdated, NewTotalGoldEarned) == 0x00000C, "Member 'HWTeamStatsTracker_HandleTotalGoldEarnedUpdated::NewTotalGoldEarned' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.HandleTotalXPEarnedUpdated
// 0x0010 (0x0010 - 0x0000)
struct HWTeamStatsTracker_HandleTotalXPEarnedUpdated final
{
public:
	class AHWPlayerState*                         PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldTotalGoldEarned;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewTotalGoldEarned;                                // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_HandleTotalXPEarnedUpdated) == 0x000008, "Wrong alignment on HWTeamStatsTracker_HandleTotalXPEarnedUpdated");
static_assert(sizeof(HWTeamStatsTracker_HandleTotalXPEarnedUpdated) == 0x000010, "Wrong size on HWTeamStatsTracker_HandleTotalXPEarnedUpdated");
static_assert(offsetof(HWTeamStatsTracker_HandleTotalXPEarnedUpdated, PlayerState) == 0x000000, "Member 'HWTeamStatsTracker_HandleTotalXPEarnedUpdated::PlayerState' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandleTotalXPEarnedUpdated, OldTotalGoldEarned) == 0x000008, "Member 'HWTeamStatsTracker_HandleTotalXPEarnedUpdated::OldTotalGoldEarned' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_HandleTotalXPEarnedUpdated, NewTotalGoldEarned) == 0x00000C, "Member 'HWTeamStatsTracker_HandleTotalXPEarnedUpdated::NewTotalGoldEarned' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.SetFireGiantKills
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_SetFireGiantKills final
{
public:
	int32                                         NewKillNum;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_SetFireGiantKills) == 0x000004, "Wrong alignment on HWTeamStatsTracker_SetFireGiantKills");
static_assert(sizeof(HWTeamStatsTracker_SetFireGiantKills) == 0x000004, "Wrong size on HWTeamStatsTracker_SetFireGiantKills");
static_assert(offsetof(HWTeamStatsTracker_SetFireGiantKills, NewKillNum) == 0x000000, "Member 'HWTeamStatsTracker_SetFireGiantKills::NewKillNum' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.SetGoldFuryKills
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_SetGoldFuryKills final
{
public:
	int32                                         NewKillNum;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_SetGoldFuryKills) == 0x000004, "Wrong alignment on HWTeamStatsTracker_SetGoldFuryKills");
static_assert(sizeof(HWTeamStatsTracker_SetGoldFuryKills) == 0x000004, "Wrong size on HWTeamStatsTracker_SetGoldFuryKills");
static_assert(offsetof(HWTeamStatsTracker_SetGoldFuryKills, NewKillNum) == 0x000000, "Member 'HWTeamStatsTracker_SetGoldFuryKills::NewKillNum' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.SetPyromancerKills
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_SetPyromancerKills final
{
public:
	int32                                         NewKillNum;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_SetPyromancerKills) == 0x000004, "Wrong alignment on HWTeamStatsTracker_SetPyromancerKills");
static_assert(sizeof(HWTeamStatsTracker_SetPyromancerKills) == 0x000004, "Wrong size on HWTeamStatsTracker_SetPyromancerKills");
static_assert(offsetof(HWTeamStatsTracker_SetPyromancerKills, NewKillNum) == 0x000000, "Member 'HWTeamStatsTracker_SetPyromancerKills::NewKillNum' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.GetAccoladeComponent
// 0x0008 (0x0008 - 0x0000)
struct HWTeamStatsTracker_GetAccoladeComponent final
{
public:
	class UHWAccoladeComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_GetAccoladeComponent) == 0x000008, "Wrong alignment on HWTeamStatsTracker_GetAccoladeComponent");
static_assert(sizeof(HWTeamStatsTracker_GetAccoladeComponent) == 0x000008, "Wrong size on HWTeamStatsTracker_GetAccoladeComponent");
static_assert(offsetof(HWTeamStatsTracker_GetAccoladeComponent, ReturnValue) == 0x000000, "Member 'HWTeamStatsTracker_GetAccoladeComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.GetFireGiantKills
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_GetFireGiantKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_GetFireGiantKills) == 0x000004, "Wrong alignment on HWTeamStatsTracker_GetFireGiantKills");
static_assert(sizeof(HWTeamStatsTracker_GetFireGiantKills) == 0x000004, "Wrong size on HWTeamStatsTracker_GetFireGiantKills");
static_assert(offsetof(HWTeamStatsTracker_GetFireGiantKills, ReturnValue) == 0x000000, "Member 'HWTeamStatsTracker_GetFireGiantKills::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.GetGoldFuryKills
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_GetGoldFuryKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_GetGoldFuryKills) == 0x000004, "Wrong alignment on HWTeamStatsTracker_GetGoldFuryKills");
static_assert(sizeof(HWTeamStatsTracker_GetGoldFuryKills) == 0x000004, "Wrong size on HWTeamStatsTracker_GetGoldFuryKills");
static_assert(offsetof(HWTeamStatsTracker_GetGoldFuryKills, ReturnValue) == 0x000000, "Member 'HWTeamStatsTracker_GetGoldFuryKills::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.GetPyromancerKills
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_GetPyromancerKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_GetPyromancerKills) == 0x000004, "Wrong alignment on HWTeamStatsTracker_GetPyromancerKills");
static_assert(sizeof(HWTeamStatsTracker_GetPyromancerKills) == 0x000004, "Wrong size on HWTeamStatsTracker_GetPyromancerKills");
static_assert(offsetof(HWTeamStatsTracker_GetPyromancerKills, ReturnValue) == 0x000000, "Member 'HWTeamStatsTracker_GetPyromancerKills::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.GetTeamAssists
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_GetTeamAssists final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_GetTeamAssists) == 0x000004, "Wrong alignment on HWTeamStatsTracker_GetTeamAssists");
static_assert(sizeof(HWTeamStatsTracker_GetTeamAssists) == 0x000004, "Wrong size on HWTeamStatsTracker_GetTeamAssists");
static_assert(offsetof(HWTeamStatsTracker_GetTeamAssists, ReturnValue) == 0x000000, "Member 'HWTeamStatsTracker_GetTeamAssists::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.GetTeamDeaths
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_GetTeamDeaths final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_GetTeamDeaths) == 0x000004, "Wrong alignment on HWTeamStatsTracker_GetTeamDeaths");
static_assert(sizeof(HWTeamStatsTracker_GetTeamDeaths) == 0x000004, "Wrong size on HWTeamStatsTracker_GetTeamDeaths");
static_assert(offsetof(HWTeamStatsTracker_GetTeamDeaths, ReturnValue) == 0x000000, "Member 'HWTeamStatsTracker_GetTeamDeaths::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.GetTeamEarnedGold
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_GetTeamEarnedGold final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_GetTeamEarnedGold) == 0x000004, "Wrong alignment on HWTeamStatsTracker_GetTeamEarnedGold");
static_assert(sizeof(HWTeamStatsTracker_GetTeamEarnedGold) == 0x000004, "Wrong size on HWTeamStatsTracker_GetTeamEarnedGold");
static_assert(offsetof(HWTeamStatsTracker_GetTeamEarnedGold, ReturnValue) == 0x000000, "Member 'HWTeamStatsTracker_GetTeamEarnedGold::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.GetTeamEarnedXP
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_GetTeamEarnedXP final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_GetTeamEarnedXP) == 0x000004, "Wrong alignment on HWTeamStatsTracker_GetTeamEarnedXP");
static_assert(sizeof(HWTeamStatsTracker_GetTeamEarnedXP) == 0x000004, "Wrong size on HWTeamStatsTracker_GetTeamEarnedXP");
static_assert(offsetof(HWTeamStatsTracker_GetTeamEarnedXP, ReturnValue) == 0x000000, "Member 'HWTeamStatsTracker_GetTeamEarnedXP::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.GetTeamKills
// 0x0004 (0x0004 - 0x0000)
struct HWTeamStatsTracker_GetTeamKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_GetTeamKills) == 0x000004, "Wrong alignment on HWTeamStatsTracker_GetTeamKills");
static_assert(sizeof(HWTeamStatsTracker_GetTeamKills) == 0x000004, "Wrong size on HWTeamStatsTracker_GetTeamKills");
static_assert(offsetof(HWTeamStatsTracker_GetTeamKills, ReturnValue) == 0x000000, "Member 'HWTeamStatsTracker_GetTeamKills::ReturnValue' has a wrong offset!");

// Function Hemingway.HWTeamStatsTracker.GetTopStatsPlayer
// 0x0010 (0x0010 - 0x0000)
struct HWTeamStatsTracker_GetTopStatsPlayer final
{
public:
	struct FGameplayTag                           StatToCheck;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHWPlayerState*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWTeamStatsTracker_GetTopStatsPlayer) == 0x000008, "Wrong alignment on HWTeamStatsTracker_GetTopStatsPlayer");
static_assert(sizeof(HWTeamStatsTracker_GetTopStatsPlayer) == 0x000010, "Wrong size on HWTeamStatsTracker_GetTopStatsPlayer");
static_assert(offsetof(HWTeamStatsTracker_GetTopStatsPlayer, StatToCheck) == 0x000000, "Member 'HWTeamStatsTracker_GetTopStatsPlayer::StatToCheck' has a wrong offset!");
static_assert(offsetof(HWTeamStatsTracker_GetTopStatsPlayer, ReturnValue) == 0x000008, "Member 'HWTeamStatsTracker_GetTopStatsPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionItemHandler.GetCTAPath
// 0x00A8 (0x00A8 - 0x0000)
struct HWCallToActionItemHandler_GetCTAPath final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemInventory                      Item;                                              // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReturnValue;                                       // 0x0098(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCallToActionItemHandler_GetCTAPath) == 0x000008, "Wrong alignment on HWCallToActionItemHandler_GetCTAPath");
static_assert(sizeof(HWCallToActionItemHandler_GetCTAPath) == 0x0000A8, "Wrong size on HWCallToActionItemHandler_GetCTAPath");
static_assert(offsetof(HWCallToActionItemHandler_GetCTAPath, WorldContext) == 0x000000, "Member 'HWCallToActionItemHandler_GetCTAPath::WorldContext' has a wrong offset!");
static_assert(offsetof(HWCallToActionItemHandler_GetCTAPath, Item) == 0x000008, "Member 'HWCallToActionItemHandler_GetCTAPath::Item' has a wrong offset!");
static_assert(offsetof(HWCallToActionItemHandler_GetCTAPath, ReturnValue) == 0x000098, "Member 'HWCallToActionItemHandler_GetCTAPath::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionItemHandler.ShouldShowCTA
// 0x00A0 (0x00A0 - 0x0000)
struct HWCallToActionItemHandler_ShouldShowCTA final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_ItemInventory                      Item;                                              // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0098(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionItemHandler_ShouldShowCTA) == 0x000008, "Wrong alignment on HWCallToActionItemHandler_ShouldShowCTA");
static_assert(sizeof(HWCallToActionItemHandler_ShouldShowCTA) == 0x0000A0, "Wrong size on HWCallToActionItemHandler_ShouldShowCTA");
static_assert(offsetof(HWCallToActionItemHandler_ShouldShowCTA, WorldContext) == 0x000000, "Member 'HWCallToActionItemHandler_ShouldShowCTA::WorldContext' has a wrong offset!");
static_assert(offsetof(HWCallToActionItemHandler_ShouldShowCTA, Item) == 0x000008, "Member 'HWCallToActionItemHandler_ShouldShowCTA::Item' has a wrong offset!");
static_assert(offsetof(HWCallToActionItemHandler_ShouldShowCTA, ReturnValue) == 0x000098, "Member 'HWCallToActionItemHandler_ShouldShowCTA::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.PathToString
// 0x0020 (0x0020 - 0x0000)
struct HWCallToActionSubsystem_PathToString final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCallToActionSubsystem_PathToString) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_PathToString");
static_assert(sizeof(HWCallToActionSubsystem_PathToString) == 0x000020, "Wrong size on HWCallToActionSubsystem_PathToString");
static_assert(offsetof(HWCallToActionSubsystem_PathToString, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_PathToString::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_PathToString, ReturnValue) == 0x000010, "Member 'HWCallToActionSubsystem_PathToString::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.HandleInventoryLoaded
// 0x0001 (0x0001 - 0x0000)
struct HWCallToActionSubsystem_HandleInventoryLoaded final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCallToActionSubsystem_HandleInventoryLoaded) == 0x000001, "Wrong alignment on HWCallToActionSubsystem_HandleInventoryLoaded");
static_assert(sizeof(HWCallToActionSubsystem_HandleInventoryLoaded) == 0x000001, "Wrong size on HWCallToActionSubsystem_HandleInventoryLoaded");
static_assert(offsetof(HWCallToActionSubsystem_HandleInventoryLoaded, bSuccess) == 0x000000, "Member 'HWCallToActionSubsystem_HandleInventoryLoaded::bSuccess' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.HandleInventoryUpdated
// 0x0018 (0x0018 - 0x0000)
struct HWCallToActionSubsystem_HandleInventoryUpdated final
{
public:
	TArray<int32>                                 UpdatedInventoryIds;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCallToActionSubsystem_HandleInventoryUpdated) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_HandleInventoryUpdated");
static_assert(sizeof(HWCallToActionSubsystem_HandleInventoryUpdated) == 0x000018, "Wrong size on HWCallToActionSubsystem_HandleInventoryUpdated");
static_assert(offsetof(HWCallToActionSubsystem_HandleInventoryUpdated, UpdatedInventoryIds) == 0x000000, "Member 'HWCallToActionSubsystem_HandleInventoryUpdated::UpdatedInventoryIds' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_HandleInventoryUpdated, PlayerInfo) == 0x000010, "Member 'HWCallToActionSubsystem_HandleInventoryUpdated::PlayerInfo' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.RegisterCTAActiveChildrenCountChanged
// 0x0028 (0x0028 - 0x0000)
struct HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(int32 ActiveChildrenCount)>    Callback;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged");
static_assert(sizeof(HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged) == 0x000028, "Wrong size on HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged");
static_assert(offsetof(HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged, Callback) == 0x000010, "Member 'HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged::Callback' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged, ReturnValue) == 0x000020, "Member 'HWCallToActionSubsystem_RegisterCTAActiveChildrenCountChanged::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.RegisterCTASeenAmountChanged
// 0x0028 (0x0028 - 0x0000)
struct HWCallToActionSubsystem_RegisterCTASeenAmountChanged final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(int32 InventoryAmount, int32 SeenAmount)> Callback;                               // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionSubsystem_RegisterCTASeenAmountChanged) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_RegisterCTASeenAmountChanged");
static_assert(sizeof(HWCallToActionSubsystem_RegisterCTASeenAmountChanged) == 0x000028, "Wrong size on HWCallToActionSubsystem_RegisterCTASeenAmountChanged");
static_assert(offsetof(HWCallToActionSubsystem_RegisterCTASeenAmountChanged, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_RegisterCTASeenAmountChanged::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_RegisterCTASeenAmountChanged, Callback) == 0x000010, "Member 'HWCallToActionSubsystem_RegisterCTASeenAmountChanged::Callback' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_RegisterCTASeenAmountChanged, ReturnValue) == 0x000020, "Member 'HWCallToActionSubsystem_RegisterCTASeenAmountChanged::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.RegisterCTAStateChanged
// 0x0028 (0x0028 - 0x0000)
struct HWCallToActionSubsystem_RegisterCTAStateChanged final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(bool bIsCTAActive)>            Callback;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionSubsystem_RegisterCTAStateChanged) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_RegisterCTAStateChanged");
static_assert(sizeof(HWCallToActionSubsystem_RegisterCTAStateChanged) == 0x000028, "Wrong size on HWCallToActionSubsystem_RegisterCTAStateChanged");
static_assert(offsetof(HWCallToActionSubsystem_RegisterCTAStateChanged, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_RegisterCTAStateChanged::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_RegisterCTAStateChanged, Callback) == 0x000010, "Member 'HWCallToActionSubsystem_RegisterCTAStateChanged::Callback' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_RegisterCTAStateChanged, ReturnValue) == 0x000020, "Member 'HWCallToActionSubsystem_RegisterCTAStateChanged::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.SetCTASeen
// 0x0018 (0x0018 - 0x0000)
struct HWCallToActionSubsystem_SetCTASeen final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bSetChildrenSeen;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionSubsystem_SetCTASeen) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_SetCTASeen");
static_assert(sizeof(HWCallToActionSubsystem_SetCTASeen) == 0x000018, "Wrong size on HWCallToActionSubsystem_SetCTASeen");
static_assert(offsetof(HWCallToActionSubsystem_SetCTASeen, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_SetCTASeen::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_SetCTASeen, bSetChildrenSeen) == 0x000010, "Member 'HWCallToActionSubsystem_SetCTASeen::bSetChildrenSeen' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_SetCTASeen, ReturnValue) == 0x000011, "Member 'HWCallToActionSubsystem_SetCTASeen::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.SetCTASeenAmount
// 0x0018 (0x0018 - 0x0000)
struct HWCallToActionSubsystem_SetCTASeenAmount final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         SeenAmount;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCallToActionSubsystem_SetCTASeenAmount) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_SetCTASeenAmount");
static_assert(sizeof(HWCallToActionSubsystem_SetCTASeenAmount) == 0x000018, "Wrong size on HWCallToActionSubsystem_SetCTASeenAmount");
static_assert(offsetof(HWCallToActionSubsystem_SetCTASeenAmount, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_SetCTASeenAmount::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_SetCTASeenAmount, SeenAmount) == 0x000010, "Member 'HWCallToActionSubsystem_SetCTASeenAmount::SeenAmount' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_SetCTASeenAmount, ReturnValue) == 0x000014, "Member 'HWCallToActionSubsystem_SetCTASeenAmount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.UnregisterCTAActiveChildrenCountChanged
// 0x0020 (0x0020 - 0x0000)
struct HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	const class UObject*                          CallbackObj;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged");
static_assert(sizeof(HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged) == 0x000020, "Wrong size on HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged");
static_assert(offsetof(HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged, CallbackObj) == 0x000010, "Member 'HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged::CallbackObj' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged, ReturnValue) == 0x000018, "Member 'HWCallToActionSubsystem_UnregisterCTAActiveChildrenCountChanged::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.UnregisterCTASeenAmountChanged
// 0x0020 (0x0020 - 0x0000)
struct HWCallToActionSubsystem_UnregisterCTASeenAmountChanged final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	const class UObject*                          CallbackObj;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionSubsystem_UnregisterCTASeenAmountChanged) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_UnregisterCTASeenAmountChanged");
static_assert(sizeof(HWCallToActionSubsystem_UnregisterCTASeenAmountChanged) == 0x000020, "Wrong size on HWCallToActionSubsystem_UnregisterCTASeenAmountChanged");
static_assert(offsetof(HWCallToActionSubsystem_UnregisterCTASeenAmountChanged, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_UnregisterCTASeenAmountChanged::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_UnregisterCTASeenAmountChanged, CallbackObj) == 0x000010, "Member 'HWCallToActionSubsystem_UnregisterCTASeenAmountChanged::CallbackObj' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_UnregisterCTASeenAmountChanged, ReturnValue) == 0x000018, "Member 'HWCallToActionSubsystem_UnregisterCTASeenAmountChanged::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.UnregisterCTAStateChanged
// 0x0020 (0x0020 - 0x0000)
struct HWCallToActionSubsystem_UnregisterCTAStateChanged final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	const class UObject*                          CallbackObj;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionSubsystem_UnregisterCTAStateChanged) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_UnregisterCTAStateChanged");
static_assert(sizeof(HWCallToActionSubsystem_UnregisterCTAStateChanged) == 0x000020, "Wrong size on HWCallToActionSubsystem_UnregisterCTAStateChanged");
static_assert(offsetof(HWCallToActionSubsystem_UnregisterCTAStateChanged, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_UnregisterCTAStateChanged::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_UnregisterCTAStateChanged, CallbackObj) == 0x000010, "Member 'HWCallToActionSubsystem_UnregisterCTAStateChanged::CallbackObj' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_UnregisterCTAStateChanged, ReturnValue) == 0x000018, "Member 'HWCallToActionSubsystem_UnregisterCTAStateChanged::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.GetCTAActiveChildrenCount
// 0x0018 (0x0018 - 0x0000)
struct HWCallToActionSubsystem_GetCTAActiveChildrenCount final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionSubsystem_GetCTAActiveChildrenCount) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_GetCTAActiveChildrenCount");
static_assert(sizeof(HWCallToActionSubsystem_GetCTAActiveChildrenCount) == 0x000018, "Wrong size on HWCallToActionSubsystem_GetCTAActiveChildrenCount");
static_assert(offsetof(HWCallToActionSubsystem_GetCTAActiveChildrenCount, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_GetCTAActiveChildrenCount::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_GetCTAActiveChildrenCount, ReturnValue) == 0x000010, "Member 'HWCallToActionSubsystem_GetCTAActiveChildrenCount::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.GetCTAStateAndAmounts
// 0x0020 (0x0020 - 0x0000)
struct HWCallToActionSubsystem_GetCTAStateAndAmounts final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         OutInventoryAmount;                                // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutSeenAmount;                                     // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutActiveChildrenCount;                            // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionSubsystem_GetCTAStateAndAmounts) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_GetCTAStateAndAmounts");
static_assert(sizeof(HWCallToActionSubsystem_GetCTAStateAndAmounts) == 0x000020, "Wrong size on HWCallToActionSubsystem_GetCTAStateAndAmounts");
static_assert(offsetof(HWCallToActionSubsystem_GetCTAStateAndAmounts, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_GetCTAStateAndAmounts::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_GetCTAStateAndAmounts, OutInventoryAmount) == 0x000010, "Member 'HWCallToActionSubsystem_GetCTAStateAndAmounts::OutInventoryAmount' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_GetCTAStateAndAmounts, OutSeenAmount) == 0x000014, "Member 'HWCallToActionSubsystem_GetCTAStateAndAmounts::OutSeenAmount' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_GetCTAStateAndAmounts, OutActiveChildrenCount) == 0x000018, "Member 'HWCallToActionSubsystem_GetCTAStateAndAmounts::OutActiveChildrenCount' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_GetCTAStateAndAmounts, ReturnValue) == 0x00001C, "Member 'HWCallToActionSubsystem_GetCTAStateAndAmounts::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCallToActionSubsystem.IsCTAActive
// 0x0018 (0x0018 - 0x0000)
struct HWCallToActionSubsystem_IsCTAActive final
{
public:
	TArray<class FName>                           CTAPath;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWCallToActionSubsystem_IsCTAActive) == 0x000008, "Wrong alignment on HWCallToActionSubsystem_IsCTAActive");
static_assert(sizeof(HWCallToActionSubsystem_IsCTAActive) == 0x000018, "Wrong size on HWCallToActionSubsystem_IsCTAActive");
static_assert(offsetof(HWCallToActionSubsystem_IsCTAActive, CTAPath) == 0x000000, "Member 'HWCallToActionSubsystem_IsCTAActive::CTAPath' has a wrong offset!");
static_assert(offsetof(HWCallToActionSubsystem_IsCTAActive, ReturnValue) == 0x000010, "Member 'HWCallToActionSubsystem_IsCTAActive::ReturnValue' has a wrong offset!");

// Function Hemingway.HWCrashSubsystem.OnAbilitySystemActorReplicated
// 0x0008 (0x0008 - 0x0000)
struct HWCrashSubsystem_OnAbilitySystemActorReplicated final
{
public:
	class AHWCharacterAbilitySystemActor*         NewASActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCrashSubsystem_OnAbilitySystemActorReplicated) == 0x000008, "Wrong alignment on HWCrashSubsystem_OnAbilitySystemActorReplicated");
static_assert(sizeof(HWCrashSubsystem_OnAbilitySystemActorReplicated) == 0x000008, "Wrong size on HWCrashSubsystem_OnAbilitySystemActorReplicated");
static_assert(offsetof(HWCrashSubsystem_OnAbilitySystemActorReplicated, NewASActor) == 0x000000, "Member 'HWCrashSubsystem_OnAbilitySystemActorReplicated::NewASActor' has a wrong offset!");

// Function Hemingway.HWCrashSubsystem.OnCharacterItemUpdated
// 0x0018 (0x0018 - 0x0000)
struct HWCrashSubsystem_OnCharacterItemUpdated final
{
public:
	TScriptInterface<class IHWInterface_LoadoutManagement> LoadoutOwner;                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 NewCharacterItem;                                  // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCrashSubsystem_OnCharacterItemUpdated) == 0x000008, "Wrong alignment on HWCrashSubsystem_OnCharacterItemUpdated");
static_assert(sizeof(HWCrashSubsystem_OnCharacterItemUpdated) == 0x000018, "Wrong size on HWCrashSubsystem_OnCharacterItemUpdated");
static_assert(offsetof(HWCrashSubsystem_OnCharacterItemUpdated, LoadoutOwner) == 0x000000, "Member 'HWCrashSubsystem_OnCharacterItemUpdated::LoadoutOwner' has a wrong offset!");
static_assert(offsetof(HWCrashSubsystem_OnCharacterItemUpdated, NewCharacterItem) == 0x000010, "Member 'HWCrashSubsystem_OnCharacterItemUpdated::NewCharacterItem' has a wrong offset!");

// Function Hemingway.HWCrashSubsystem.OnGameStateUpdate
// 0x0008 (0x0008 - 0x0000)
struct HWCrashSubsystem_OnGameStateUpdate final
{
public:
	const class AHWGameState*                     GameState;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCrashSubsystem_OnGameStateUpdate) == 0x000008, "Wrong alignment on HWCrashSubsystem_OnGameStateUpdate");
static_assert(sizeof(HWCrashSubsystem_OnGameStateUpdate) == 0x000008, "Wrong size on HWCrashSubsystem_OnGameStateUpdate");
static_assert(offsetof(HWCrashSubsystem_OnGameStateUpdate, GameState) == 0x000000, "Member 'HWCrashSubsystem_OnGameStateUpdate::GameState' has a wrong offset!");

// Function Hemingway.HWCrashSubsystem.OnSkinItemUpdated
// 0x0018 (0x0018 - 0x0000)
struct HWCrashSubsystem_OnSkinItemUpdated final
{
public:
	TScriptInterface<class IHWInterface_LoadoutManagement> LoadoutOwner;                             // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWSkinItem*                      NewSkinItem;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWCrashSubsystem_OnSkinItemUpdated) == 0x000008, "Wrong alignment on HWCrashSubsystem_OnSkinItemUpdated");
static_assert(sizeof(HWCrashSubsystem_OnSkinItemUpdated) == 0x000018, "Wrong size on HWCrashSubsystem_OnSkinItemUpdated");
static_assert(offsetof(HWCrashSubsystem_OnSkinItemUpdated, LoadoutOwner) == 0x000000, "Member 'HWCrashSubsystem_OnSkinItemUpdated::LoadoutOwner' has a wrong offset!");
static_assert(offsetof(HWCrashSubsystem_OnSkinItemUpdated, NewSkinItem) == 0x000010, "Member 'HWCrashSubsystem_OnSkinItemUpdated::NewSkinItem' has a wrong offset!");

// Function Hemingway.HWEquipmentItemSubsystem.OnItemsVendorReceived
// 0x0001 (0x0001 - 0x0000)
struct HWEquipmentItemSubsystem_OnItemsVendorReceived final
{
public:
	bool                                          bSuccessfullyLoaded;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentItemSubsystem_OnItemsVendorReceived) == 0x000001, "Wrong alignment on HWEquipmentItemSubsystem_OnItemsVendorReceived");
static_assert(sizeof(HWEquipmentItemSubsystem_OnItemsVendorReceived) == 0x000001, "Wrong size on HWEquipmentItemSubsystem_OnItemsVendorReceived");
static_assert(offsetof(HWEquipmentItemSubsystem_OnItemsVendorReceived, bSuccessfullyLoaded) == 0x000000, "Member 'HWEquipmentItemSubsystem_OnItemsVendorReceived::bSuccessfullyLoaded' has a wrong offset!");

// Function Hemingway.HWEquipmentItemSubsystem.OnRHSessionChanged
// 0x0010 (0x0010 - 0x0000)
struct HWEquipmentItemSubsystem_OnRHSessionChanged final
{
public:
	class URH_JoinedSession*                      OldSession;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_JoinedSession*                      ActiveSession;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentItemSubsystem_OnRHSessionChanged) == 0x000008, "Wrong alignment on HWEquipmentItemSubsystem_OnRHSessionChanged");
static_assert(sizeof(HWEquipmentItemSubsystem_OnRHSessionChanged) == 0x000010, "Wrong size on HWEquipmentItemSubsystem_OnRHSessionChanged");
static_assert(offsetof(HWEquipmentItemSubsystem_OnRHSessionChanged, OldSession) == 0x000000, "Member 'HWEquipmentItemSubsystem_OnRHSessionChanged::OldSession' has a wrong offset!");
static_assert(offsetof(HWEquipmentItemSubsystem_OnRHSessionChanged, ActiveSession) == 0x000008, "Member 'HWEquipmentItemSubsystem_OnRHSessionChanged::ActiveSession' has a wrong offset!");

// Function Hemingway.HWEquipmentItemSubsystem.OnSettingsChanged
// 0x0008 (0x0008 - 0x0000)
struct HWEquipmentItemSubsystem_OnSettingsChanged final
{
public:
	class URH_ConfigSubsystem*                    ConfigSubsytem;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWEquipmentItemSubsystem_OnSettingsChanged) == 0x000008, "Wrong alignment on HWEquipmentItemSubsystem_OnSettingsChanged");
static_assert(sizeof(HWEquipmentItemSubsystem_OnSettingsChanged) == 0x000008, "Wrong size on HWEquipmentItemSubsystem_OnSettingsChanged");
static_assert(offsetof(HWEquipmentItemSubsystem_OnSettingsChanged, ConfigSubsytem) == 0x000000, "Member 'HWEquipmentItemSubsystem_OnSettingsChanged::ConfigSubsytem' has a wrong offset!");

// Function Hemingway.HWEquipmentItemSubsystem.IsGodSpecificItem
// 0x0018 (0x0018 - 0x0000)
struct HWEquipmentItemSubsystem_IsGodSpecificItem final
{
public:
	struct FRH_ItemId                             ItemId;                                            // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWEquipmentItemSubsystem_IsGodSpecificItem) == 0x000004, "Wrong alignment on HWEquipmentItemSubsystem_IsGodSpecificItem");
static_assert(sizeof(HWEquipmentItemSubsystem_IsGodSpecificItem) == 0x000018, "Wrong size on HWEquipmentItemSubsystem_IsGodSpecificItem");
static_assert(offsetof(HWEquipmentItemSubsystem_IsGodSpecificItem, ItemId) == 0x000000, "Member 'HWEquipmentItemSubsystem_IsGodSpecificItem::ItemId' has a wrong offset!");
static_assert(offsetof(HWEquipmentItemSubsystem_IsGodSpecificItem, ReturnValue) == 0x000014, "Member 'HWEquipmentItemSubsystem_IsGodSpecificItem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameModeInfoSubsystem.GetGameModeInfoByTag
// 0x0108 (0x0108 - 0x0000)
struct HWGameModeInfoSubsystem_GetGameModeInfoByTag final
{
public:
	struct FGameplayTag                           InfoTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWGameModeInfo                        OutInfo;                                           // 0x0008(0x00F8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameModeInfoSubsystem_GetGameModeInfoByTag) == 0x000008, "Wrong alignment on HWGameModeInfoSubsystem_GetGameModeInfoByTag");
static_assert(sizeof(HWGameModeInfoSubsystem_GetGameModeInfoByTag) == 0x000108, "Wrong size on HWGameModeInfoSubsystem_GetGameModeInfoByTag");
static_assert(offsetof(HWGameModeInfoSubsystem_GetGameModeInfoByTag, InfoTag) == 0x000000, "Member 'HWGameModeInfoSubsystem_GetGameModeInfoByTag::InfoTag' has a wrong offset!");
static_assert(offsetof(HWGameModeInfoSubsystem_GetGameModeInfoByTag, OutInfo) == 0x000008, "Member 'HWGameModeInfoSubsystem_GetGameModeInfoByTag::OutInfo' has a wrong offset!");
static_assert(offsetof(HWGameModeInfoSubsystem_GetGameModeInfoByTag, ReturnValue) == 0x000100, "Member 'HWGameModeInfoSubsystem_GetGameModeInfoByTag::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGameModeInfoSubsystem.GetGameModeInfoFromActiveSession
// 0x0100 (0x0100 - 0x0000)
struct HWGameModeInfoSubsystem_GetGameModeInfoFromActiveSession final
{
public:
	struct FHWGameModeInfo                        OutGameModeInfo;                                   // 0x0000(0x00F8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGameModeInfoSubsystem_GetGameModeInfoFromActiveSession) == 0x000008, "Wrong alignment on HWGameModeInfoSubsystem_GetGameModeInfoFromActiveSession");
static_assert(sizeof(HWGameModeInfoSubsystem_GetGameModeInfoFromActiveSession) == 0x000100, "Wrong size on HWGameModeInfoSubsystem_GetGameModeInfoFromActiveSession");
static_assert(offsetof(HWGameModeInfoSubsystem_GetGameModeInfoFromActiveSession, OutGameModeInfo) == 0x000000, "Member 'HWGameModeInfoSubsystem_GetGameModeInfoFromActiveSession::OutGameModeInfo' has a wrong offset!");
static_assert(offsetof(HWGameModeInfoSubsystem_GetGameModeInfoFromActiveSession, ReturnValue) == 0x0000F8, "Member 'HWGameModeInfoSubsystem_GetGameModeInfoFromActiveSession::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGodBuilderSubsystem.GetCachedPrimaryBuild
// 0x0198 (0x0198 - 0x0000)
struct HWGodBuilderSubsystem_GetCachedPrimaryBuild final
{
public:
	struct FHWGodBuild                            OutGodBuild;                                       // 0x0000(0x0190)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0190(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWGodBuilderSubsystem_GetCachedPrimaryBuild) == 0x000008, "Wrong alignment on HWGodBuilderSubsystem_GetCachedPrimaryBuild");
static_assert(sizeof(HWGodBuilderSubsystem_GetCachedPrimaryBuild) == 0x000198, "Wrong size on HWGodBuilderSubsystem_GetCachedPrimaryBuild");
static_assert(offsetof(HWGodBuilderSubsystem_GetCachedPrimaryBuild, OutGodBuild) == 0x000000, "Member 'HWGodBuilderSubsystem_GetCachedPrimaryBuild::OutGodBuild' has a wrong offset!");
static_assert(offsetof(HWGodBuilderSubsystem_GetCachedPrimaryBuild, ReturnValue) == 0x000190, "Member 'HWGodBuilderSubsystem_GetCachedPrimaryBuild::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGodBuilderSubsystem.OnLocalPlayerPinnedBuildUpdated
// 0x0018 (0x0018 - 0x0000)
struct HWGodBuilderSubsystem_OnLocalPlayerPinnedBuildUpdated final
{
public:
	const class UHWCharacterItem*                 CharacterItem;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  BuildGuid;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodBuilderSubsystem_OnLocalPlayerPinnedBuildUpdated) == 0x000008, "Wrong alignment on HWGodBuilderSubsystem_OnLocalPlayerPinnedBuildUpdated");
static_assert(sizeof(HWGodBuilderSubsystem_OnLocalPlayerPinnedBuildUpdated) == 0x000018, "Wrong size on HWGodBuilderSubsystem_OnLocalPlayerPinnedBuildUpdated");
static_assert(offsetof(HWGodBuilderSubsystem_OnLocalPlayerPinnedBuildUpdated, CharacterItem) == 0x000000, "Member 'HWGodBuilderSubsystem_OnLocalPlayerPinnedBuildUpdated::CharacterItem' has a wrong offset!");
static_assert(offsetof(HWGodBuilderSubsystem_OnLocalPlayerPinnedBuildUpdated, BuildGuid) == 0x000008, "Member 'HWGodBuilderSubsystem_OnLocalPlayerPinnedBuildUpdated::BuildGuid' has a wrong offset!");

// Function Hemingway.HWGodBuilderSubsystem.ShouldUseGodBuilder
// 0x0001 (0x0001 - 0x0000)
struct HWGodBuilderSubsystem_ShouldUseGodBuilder final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodBuilderSubsystem_ShouldUseGodBuilder) == 0x000001, "Wrong alignment on HWGodBuilderSubsystem_ShouldUseGodBuilder");
static_assert(sizeof(HWGodBuilderSubsystem_ShouldUseGodBuilder) == 0x000001, "Wrong size on HWGodBuilderSubsystem_ShouldUseGodBuilder");
static_assert(offsetof(HWGodBuilderSubsystem_ShouldUseGodBuilder, ReturnValue) == 0x000000, "Member 'HWGodBuilderSubsystem_ShouldUseGodBuilder::ReturnValue' has a wrong offset!");

// Function Hemingway.HWGodBuilderSubsystem.GetCachedBuildType
// 0x0001 (0x0001 - 0x0000)
struct HWGodBuilderSubsystem_GetCachedBuildType final
{
public:
	EHWCachedBuildType                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWGodBuilderSubsystem_GetCachedBuildType) == 0x000001, "Wrong alignment on HWGodBuilderSubsystem_GetCachedBuildType");
static_assert(sizeof(HWGodBuilderSubsystem_GetCachedBuildType) == 0x000001, "Wrong size on HWGodBuilderSubsystem_GetCachedBuildType");
static_assert(offsetof(HWGodBuilderSubsystem_GetCachedBuildType, ReturnValue) == 0x000000, "Member 'HWGodBuilderSubsystem_GetCachedBuildType::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.CreateLeaderboardDataContainer
// 0x00A8 (0x00A8 - 0x0000)
struct HWLeaderboardSubsystem_CreateLeaderboardDataContainer final
{
public:
	class FString                                 LeaderboardId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRH_LeaderboardResults                 Results;                                           // 0x0010(0x0088)(Parm, OutParm, NativeAccessSpecifierPublic)
	struct FHWLeaderboardDataContainer            ReturnValue;                                       // 0x0098(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLeaderboardSubsystem_CreateLeaderboardDataContainer) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_CreateLeaderboardDataContainer");
static_assert(sizeof(HWLeaderboardSubsystem_CreateLeaderboardDataContainer) == 0x0000A8, "Wrong size on HWLeaderboardSubsystem_CreateLeaderboardDataContainer");
static_assert(offsetof(HWLeaderboardSubsystem_CreateLeaderboardDataContainer, LeaderboardId) == 0x000000, "Member 'HWLeaderboardSubsystem_CreateLeaderboardDataContainer::LeaderboardId' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_CreateLeaderboardDataContainer, Results) == 0x000010, "Member 'HWLeaderboardSubsystem_CreateLeaderboardDataContainer::Results' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_CreateLeaderboardDataContainer, ReturnValue) == 0x000098, "Member 'HWLeaderboardSubsystem_CreateLeaderboardDataContainer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.ExecuteAllDelegates
// 0x0028 (0x0028 - 0x0000)
struct HWLeaderboardSubsystem_ExecuteAllDelegates final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LeaderboardId;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWLeaderboardDataContainer            Container;                                         // 0x0018(0x0010)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLeaderboardSubsystem_ExecuteAllDelegates) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_ExecuteAllDelegates");
static_assert(sizeof(HWLeaderboardSubsystem_ExecuteAllDelegates) == 0x000028, "Wrong size on HWLeaderboardSubsystem_ExecuteAllDelegates");
static_assert(offsetof(HWLeaderboardSubsystem_ExecuteAllDelegates, bSuccess) == 0x000000, "Member 'HWLeaderboardSubsystem_ExecuteAllDelegates::bSuccess' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_ExecuteAllDelegates, LeaderboardId) == 0x000008, "Member 'HWLeaderboardSubsystem_ExecuteAllDelegates::LeaderboardId' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_ExecuteAllDelegates, Container) == 0x000018, "Member 'HWLeaderboardSubsystem_ExecuteAllDelegates::Container' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.FindDivision
// 0x0078 (0x0078 - 0x0000)
struct HWLeaderboardSubsystem_FindDivision final
{
public:
	struct FHWLeaderboardDataContainer            LeaderboardDataContainer;                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FHWSkillRatingRank>             Ranks;                                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         StatValue;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkillRatingDivision                 OutSkillRatingDivision;                            // 0x0028(0x0048)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLeaderboardSubsystem_FindDivision) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_FindDivision");
static_assert(sizeof(HWLeaderboardSubsystem_FindDivision) == 0x000078, "Wrong size on HWLeaderboardSubsystem_FindDivision");
static_assert(offsetof(HWLeaderboardSubsystem_FindDivision, LeaderboardDataContainer) == 0x000000, "Member 'HWLeaderboardSubsystem_FindDivision::LeaderboardDataContainer' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindDivision, Ranks) == 0x000010, "Member 'HWLeaderboardSubsystem_FindDivision::Ranks' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindDivision, StatValue) == 0x000020, "Member 'HWLeaderboardSubsystem_FindDivision::StatValue' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindDivision, OutSkillRatingDivision) == 0x000028, "Member 'HWLeaderboardSubsystem_FindDivision::OutSkillRatingDivision' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindDivision, ReturnValue) == 0x000070, "Member 'HWLeaderboardSubsystem_FindDivision::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.FindDivisionFromCache
// 0x0068 (0x0068 - 0x0000)
struct HWLeaderboardSubsystem_FindDivisionFromCache final
{
public:
	class FString                                 LeaderboardId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatValue;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkillRatingDivision                 OutSkillRatingDivision;                            // 0x0018(0x0048)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLeaderboardSubsystem_FindDivisionFromCache) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_FindDivisionFromCache");
static_assert(sizeof(HWLeaderboardSubsystem_FindDivisionFromCache) == 0x000068, "Wrong size on HWLeaderboardSubsystem_FindDivisionFromCache");
static_assert(offsetof(HWLeaderboardSubsystem_FindDivisionFromCache, LeaderboardId) == 0x000000, "Member 'HWLeaderboardSubsystem_FindDivisionFromCache::LeaderboardId' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindDivisionFromCache, StatValue) == 0x000010, "Member 'HWLeaderboardSubsystem_FindDivisionFromCache::StatValue' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindDivisionFromCache, OutSkillRatingDivision) == 0x000018, "Member 'HWLeaderboardSubsystem_FindDivisionFromCache::OutSkillRatingDivision' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindDivisionFromCache, ReturnValue) == 0x000060, "Member 'HWLeaderboardSubsystem_FindDivisionFromCache::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.FindRank
// 0x0090 (0x0090 - 0x0000)
struct HWLeaderboardSubsystem_FindRank final
{
public:
	struct FHWLeaderboardDataContainer            LeaderboardDataContainer;                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FHWSkillRatingRank>             Ranks;                                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         StatValue;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkillRatingRank                     OutSkillRatingRank;                                // 0x0028(0x0060)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLeaderboardSubsystem_FindRank) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_FindRank");
static_assert(sizeof(HWLeaderboardSubsystem_FindRank) == 0x000090, "Wrong size on HWLeaderboardSubsystem_FindRank");
static_assert(offsetof(HWLeaderboardSubsystem_FindRank, LeaderboardDataContainer) == 0x000000, "Member 'HWLeaderboardSubsystem_FindRank::LeaderboardDataContainer' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindRank, Ranks) == 0x000010, "Member 'HWLeaderboardSubsystem_FindRank::Ranks' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindRank, StatValue) == 0x000020, "Member 'HWLeaderboardSubsystem_FindRank::StatValue' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindRank, OutSkillRatingRank) == 0x000028, "Member 'HWLeaderboardSubsystem_FindRank::OutSkillRatingRank' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindRank, ReturnValue) == 0x000088, "Member 'HWLeaderboardSubsystem_FindRank::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.FindRankFromCache
// 0x0080 (0x0080 - 0x0000)
struct HWLeaderboardSubsystem_FindRankFromCache final
{
public:
	class FString                                 LeaderboardId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatValue;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWSkillRatingRank                     OutSkillRatingRank;                                // 0x0018(0x0060)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLeaderboardSubsystem_FindRankFromCache) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_FindRankFromCache");
static_assert(sizeof(HWLeaderboardSubsystem_FindRankFromCache) == 0x000080, "Wrong size on HWLeaderboardSubsystem_FindRankFromCache");
static_assert(offsetof(HWLeaderboardSubsystem_FindRankFromCache, LeaderboardId) == 0x000000, "Member 'HWLeaderboardSubsystem_FindRankFromCache::LeaderboardId' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindRankFromCache, StatValue) == 0x000010, "Member 'HWLeaderboardSubsystem_FindRankFromCache::StatValue' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindRankFromCache, OutSkillRatingRank) == 0x000018, "Member 'HWLeaderboardSubsystem_FindRankFromCache::OutSkillRatingRank' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindRankFromCache, ReturnValue) == 0x000078, "Member 'HWLeaderboardSubsystem_FindRankFromCache::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.FindRankIndex
// 0x0028 (0x0028 - 0x0000)
struct HWLeaderboardSubsystem_FindRankIndex final
{
public:
	struct FHWLeaderboardDataContainer            LeaderboardDataContainer;                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FHWSkillRatingRank>             Ranks;                                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         StatValue;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLeaderboardSubsystem_FindRankIndex) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_FindRankIndex");
static_assert(sizeof(HWLeaderboardSubsystem_FindRankIndex) == 0x000028, "Wrong size on HWLeaderboardSubsystem_FindRankIndex");
static_assert(offsetof(HWLeaderboardSubsystem_FindRankIndex, LeaderboardDataContainer) == 0x000000, "Member 'HWLeaderboardSubsystem_FindRankIndex::LeaderboardDataContainer' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindRankIndex, Ranks) == 0x000010, "Member 'HWLeaderboardSubsystem_FindRankIndex::Ranks' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindRankIndex, StatValue) == 0x000020, "Member 'HWLeaderboardSubsystem_FindRankIndex::StatValue' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_FindRankIndex, ReturnValue) == 0x000024, "Member 'HWLeaderboardSubsystem_FindRankIndex::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.GetCachedLeaderboard
// 0x0028 (0x0028 - 0x0000)
struct HWLeaderboardSubsystem_GetCachedLeaderboard final
{
public:
	class FString                                 LeaderboardId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWLeaderboardDataContainer            OutLeaderboardDataContainer;                       // 0x0010(0x0010)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLeaderboardSubsystem_GetCachedLeaderboard) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_GetCachedLeaderboard");
static_assert(sizeof(HWLeaderboardSubsystem_GetCachedLeaderboard) == 0x000028, "Wrong size on HWLeaderboardSubsystem_GetCachedLeaderboard");
static_assert(offsetof(HWLeaderboardSubsystem_GetCachedLeaderboard, LeaderboardId) == 0x000000, "Member 'HWLeaderboardSubsystem_GetCachedLeaderboard::LeaderboardId' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_GetCachedLeaderboard, OutLeaderboardDataContainer) == 0x000010, "Member 'HWLeaderboardSubsystem_GetCachedLeaderboard::OutLeaderboardDataContainer' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_GetCachedLeaderboard, ReturnValue) == 0x000020, "Member 'HWLeaderboardSubsystem_GetCachedLeaderboard::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.GetLastReceivedLeaderboardId
// 0x0010 (0x0010 - 0x0000)
struct HWLeaderboardSubsystem_GetLastReceivedLeaderboardId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLeaderboardSubsystem_GetLastReceivedLeaderboardId) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_GetLastReceivedLeaderboardId");
static_assert(sizeof(HWLeaderboardSubsystem_GetLastReceivedLeaderboardId) == 0x000010, "Wrong size on HWLeaderboardSubsystem_GetLastReceivedLeaderboardId");
static_assert(offsetof(HWLeaderboardSubsystem_GetLastReceivedLeaderboardId, ReturnValue) == 0x000000, "Member 'HWLeaderboardSubsystem_GetLastReceivedLeaderboardId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.GetLeaderboardDataConfig
// 0x00A0 (0x00A0 - 0x0000)
struct HWLeaderboardSubsystem_GetLeaderboardDataConfig final
{
public:
	class FString                                 LeaderboardId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWLeaderboardDataConfig               OutLeaderboardDataConfig;                          // 0x0010(0x0088)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0098(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWLeaderboardSubsystem_GetLeaderboardDataConfig) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_GetLeaderboardDataConfig");
static_assert(sizeof(HWLeaderboardSubsystem_GetLeaderboardDataConfig) == 0x0000A0, "Wrong size on HWLeaderboardSubsystem_GetLeaderboardDataConfig");
static_assert(offsetof(HWLeaderboardSubsystem_GetLeaderboardDataConfig, LeaderboardId) == 0x000000, "Member 'HWLeaderboardSubsystem_GetLeaderboardDataConfig::LeaderboardId' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_GetLeaderboardDataConfig, OutLeaderboardDataConfig) == 0x000010, "Member 'HWLeaderboardSubsystem_GetLeaderboardDataConfig::OutLeaderboardDataConfig' has a wrong offset!");
static_assert(offsetof(HWLeaderboardSubsystem_GetLeaderboardDataConfig, ReturnValue) == 0x000098, "Member 'HWLeaderboardSubsystem_GetLeaderboardDataConfig::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.GetLeaderboardIds
// 0x0010 (0x0010 - 0x0000)
struct HWLeaderboardSubsystem_GetLeaderboardIds final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLeaderboardSubsystem_GetLeaderboardIds) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_GetLeaderboardIds");
static_assert(sizeof(HWLeaderboardSubsystem_GetLeaderboardIds) == 0x000010, "Wrong size on HWLeaderboardSubsystem_GetLeaderboardIds");
static_assert(offsetof(HWLeaderboardSubsystem_GetLeaderboardIds, ReturnValue) == 0x000000, "Member 'HWLeaderboardSubsystem_GetLeaderboardIds::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.RequestAsyncLeaderboard
// 0x0010 (0x0010 - 0x0000)
struct HWLeaderboardSubsystem_RequestAsyncLeaderboard final
{
public:
	class FString                                 LeaderboardId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLeaderboardSubsystem_RequestAsyncLeaderboard) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_RequestAsyncLeaderboard");
static_assert(sizeof(HWLeaderboardSubsystem_RequestAsyncLeaderboard) == 0x000010, "Wrong size on HWLeaderboardSubsystem_RequestAsyncLeaderboard");
static_assert(offsetof(HWLeaderboardSubsystem_RequestAsyncLeaderboard, LeaderboardId) == 0x000000, "Member 'HWLeaderboardSubsystem_RequestAsyncLeaderboard::LeaderboardId' has a wrong offset!");

// Function Hemingway.HWLeaderboardSubsystem.GetRHLeaderboardSubsystem
// 0x0008 (0x0008 - 0x0000)
struct HWLeaderboardSubsystem_GetRHLeaderboardSubsystem final
{
public:
	class URH_LeaderboardSubsystem*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLeaderboardSubsystem_GetRHLeaderboardSubsystem) == 0x000008, "Wrong alignment on HWLeaderboardSubsystem_GetRHLeaderboardSubsystem");
static_assert(sizeof(HWLeaderboardSubsystem_GetRHLeaderboardSubsystem) == 0x000008, "Wrong size on HWLeaderboardSubsystem_GetRHLeaderboardSubsystem");
static_assert(offsetof(HWLeaderboardSubsystem_GetRHLeaderboardSubsystem, ReturnValue) == 0x000000, "Member 'HWLeaderboardSubsystem_GetRHLeaderboardSubsystem::ReturnValue' has a wrong offset!");

// Function Hemingway.HWLocalPlayerInventorySubsystem.HandleOnLinkedPlatformsLoaded
// 0x0010 (0x0010 - 0x0000)
struct HWLocalPlayerInventorySubsystem_HandleOnLinkedPlatformsLoaded final
{
public:
	TArray<class URH_PlayerPlatformInfo*>         Platforms;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerInventorySubsystem_HandleOnLinkedPlatformsLoaded) == 0x000008, "Wrong alignment on HWLocalPlayerInventorySubsystem_HandleOnLinkedPlatformsLoaded");
static_assert(sizeof(HWLocalPlayerInventorySubsystem_HandleOnLinkedPlatformsLoaded) == 0x000010, "Wrong size on HWLocalPlayerInventorySubsystem_HandleOnLinkedPlatformsLoaded");
static_assert(offsetof(HWLocalPlayerInventorySubsystem_HandleOnLinkedPlatformsLoaded, Platforms) == 0x000000, "Member 'HWLocalPlayerInventorySubsystem_HandleOnLinkedPlatformsLoaded::Platforms' has a wrong offset!");

// Function Hemingway.HWLocalPlayerInventorySubsystem.HandleOnLocalPlayerInventoryLoaded
// 0x0018 (0x0018 - 0x0000)
struct HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryLoaded final
{
public:
	TArray<int32>                                 UpdatedInventoryIds;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryLoaded) == 0x000008, "Wrong alignment on HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryLoaded");
static_assert(sizeof(HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryLoaded) == 0x000018, "Wrong size on HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryLoaded");
static_assert(offsetof(HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryLoaded, UpdatedInventoryIds) == 0x000000, "Member 'HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryLoaded::UpdatedInventoryIds' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryLoaded, PlayerInfo) == 0x000010, "Member 'HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryLoaded::PlayerInfo' has a wrong offset!");

// Function Hemingway.HWLocalPlayerInventorySubsystem.HandleOnLocalPlayerInventoryUpdated
// 0x0018 (0x0018 - 0x0000)
struct HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryUpdated final
{
public:
	TArray<int32>                                 UpdatedInventoryIds;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryUpdated) == 0x000008, "Wrong alignment on HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryUpdated");
static_assert(sizeof(HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryUpdated) == 0x000018, "Wrong size on HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryUpdated");
static_assert(offsetof(HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryUpdated, UpdatedInventoryIds) == 0x000000, "Member 'HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryUpdated::UpdatedInventoryIds' has a wrong offset!");
static_assert(offsetof(HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryUpdated, PlayerInfo) == 0x000010, "Member 'HWLocalPlayerInventorySubsystem_HandleOnLocalPlayerInventoryUpdated::PlayerInfo' has a wrong offset!");

// Function Hemingway.HWLocalPlayerInventorySubsystem.HandleOnLoginComplete
// 0x0060 (0x0060 - 0x0000)
struct HWLocalPlayerInventorySubsystem_HandleOnLoginComplete final
{
public:
	struct FRH_LoginResult                        LoginResult;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWLocalPlayerInventorySubsystem_HandleOnLoginComplete) == 0x000008, "Wrong alignment on HWLocalPlayerInventorySubsystem_HandleOnLoginComplete");
static_assert(sizeof(HWLocalPlayerInventorySubsystem_HandleOnLoginComplete) == 0x000060, "Wrong size on HWLocalPlayerInventorySubsystem_HandleOnLoginComplete");
static_assert(offsetof(HWLocalPlayerInventorySubsystem_HandleOnLoginComplete, LoginResult) == 0x000000, "Member 'HWLocalPlayerInventorySubsystem_HandleOnLoginComplete::LoginResult' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.CombatLogLobbyEvent
// 0x0038 (0x0038 - 0x0000)
struct HWMatchDataSubsystem_CombatLogLobbyEvent final
{
public:
	EPlayerEventType                              LobbyEventType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  PlayerGuid;                                        // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UHWCharacterItem*                 LobbyChar;                                         // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0020(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemNameOverride;                                  // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMatchDataSubsystem_CombatLogLobbyEvent) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_CombatLogLobbyEvent");
static_assert(sizeof(HWMatchDataSubsystem_CombatLogLobbyEvent) == 0x000038, "Wrong size on HWMatchDataSubsystem_CombatLogLobbyEvent");
static_assert(offsetof(HWMatchDataSubsystem_CombatLogLobbyEvent, LobbyEventType) == 0x000000, "Member 'HWMatchDataSubsystem_CombatLogLobbyEvent::LobbyEventType' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_CombatLogLobbyEvent, PlayerGuid) == 0x000004, "Member 'HWMatchDataSubsystem_CombatLogLobbyEvent::PlayerGuid' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_CombatLogLobbyEvent, LobbyChar) == 0x000018, "Member 'HWMatchDataSubsystem_CombatLogLobbyEvent::LobbyChar' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_CombatLogLobbyEvent, TeamId) == 0x000020, "Member 'HWMatchDataSubsystem_CombatLogLobbyEvent::TeamId' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_CombatLogLobbyEvent, ItemNameOverride) == 0x000028, "Member 'HWMatchDataSubsystem_CombatLogLobbyEvent::ItemNameOverride' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.DoesMatchSupportBotFill
// 0x0001 (0x0001 - 0x0000)
struct HWMatchDataSubsystem_DoesMatchSupportBotFill final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMatchDataSubsystem_DoesMatchSupportBotFill) == 0x000001, "Wrong alignment on HWMatchDataSubsystem_DoesMatchSupportBotFill");
static_assert(sizeof(HWMatchDataSubsystem_DoesMatchSupportBotFill) == 0x000001, "Wrong size on HWMatchDataSubsystem_DoesMatchSupportBotFill");
static_assert(offsetof(HWMatchDataSubsystem_DoesMatchSupportBotFill, ReturnValue) == 0x000000, "Member 'HWMatchDataSubsystem_DoesMatchSupportBotFill::ReturnValue' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.GetMatchComposition
// 0x00A0 (0x00A0 - 0x0000)
struct HWMatchDataSubsystem_GetMatchComposition final
{
public:
	struct FHWInstanceInfo_PlayerDataList         ReturnValue;                                       // 0x0000(0x00A0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMatchDataSubsystem_GetMatchComposition) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_GetMatchComposition");
static_assert(sizeof(HWMatchDataSubsystem_GetMatchComposition) == 0x0000A0, "Wrong size on HWMatchDataSubsystem_GetMatchComposition");
static_assert(offsetof(HWMatchDataSubsystem_GetMatchComposition, ReturnValue) == 0x000000, "Member 'HWMatchDataSubsystem_GetMatchComposition::ReturnValue' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.HandleDemoStoppedRecording
// 0x0008 (0x0008 - 0x0000)
struct HWMatchDataSubsystem_HandleDemoStoppedRecording final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMatchDataSubsystem_HandleDemoStoppedRecording) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_HandleDemoStoppedRecording");
static_assert(sizeof(HWMatchDataSubsystem_HandleDemoStoppedRecording) == 0x000008, "Wrong size on HWMatchDataSubsystem_HandleDemoStoppedRecording");
static_assert(offsetof(HWMatchDataSubsystem_HandleDemoStoppedRecording, World) == 0x000000, "Member 'HWMatchDataSubsystem_HandleDemoStoppedRecording::World' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.OnCheckedPlayerLevelForDemo
// 0x0018 (0x0018 - 0x0000)
struct HWMatchDataSubsystem_OnCheckedPlayerLevelForDemo final
{
public:
	class URH_PlayerInfo*                         PlayerInfo;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRHAPI_InventoryLevel>          InventoryLevels;                                   // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMatchDataSubsystem_OnCheckedPlayerLevelForDemo) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_OnCheckedPlayerLevelForDemo");
static_assert(sizeof(HWMatchDataSubsystem_OnCheckedPlayerLevelForDemo) == 0x000018, "Wrong size on HWMatchDataSubsystem_OnCheckedPlayerLevelForDemo");
static_assert(offsetof(HWMatchDataSubsystem_OnCheckedPlayerLevelForDemo, PlayerInfo) == 0x000000, "Member 'HWMatchDataSubsystem_OnCheckedPlayerLevelForDemo::PlayerInfo' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_OnCheckedPlayerLevelForDemo, InventoryLevels) == 0x000008, "Member 'HWMatchDataSubsystem_OnCheckedPlayerLevelForDemo::InventoryLevels' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.OnDemoFlagOwnershipChecked
// 0x0010 (0x0010 - 0x0000)
struct HWMatchDataSubsystem_OnDemoFlagOwnershipChecked final
{
public:
	bool                                          bIsOwned;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URHStoreItem*                           CatalogItem;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMatchDataSubsystem_OnDemoFlagOwnershipChecked) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_OnDemoFlagOwnershipChecked");
static_assert(sizeof(HWMatchDataSubsystem_OnDemoFlagOwnershipChecked) == 0x000010, "Wrong size on HWMatchDataSubsystem_OnDemoFlagOwnershipChecked");
static_assert(offsetof(HWMatchDataSubsystem_OnDemoFlagOwnershipChecked, bIsOwned) == 0x000000, "Member 'HWMatchDataSubsystem_OnDemoFlagOwnershipChecked::bIsOwned' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_OnDemoFlagOwnershipChecked, CatalogItem) == 0x000008, "Member 'HWMatchDataSubsystem_OnDemoFlagOwnershipChecked::CatalogItem' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.OnEquipmentPurchased
// 0x0018 (0x0018 - 0x0000)
struct HWMatchDataSubsystem_OnEquipmentPurchased final
{
public:
	class UHWEquipmentInstance*                   EquipmentInstance;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWInventorySlot                       Slot;                                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWMatchDataSubsystem_OnEquipmentPurchased) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_OnEquipmentPurchased");
static_assert(sizeof(HWMatchDataSubsystem_OnEquipmentPurchased) == 0x000018, "Wrong size on HWMatchDataSubsystem_OnEquipmentPurchased");
static_assert(offsetof(HWMatchDataSubsystem_OnEquipmentPurchased, EquipmentInstance) == 0x000000, "Member 'HWMatchDataSubsystem_OnEquipmentPurchased::EquipmentInstance' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_OnEquipmentPurchased, Slot) == 0x000008, "Member 'HWMatchDataSubsystem_OnEquipmentPurchased::Slot' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.OnPlayerHoveredLobbyPick
// 0x0030 (0x0030 - 0x0000)
struct HWMatchDataSubsystem_OnPlayerHoveredLobbyPick final
{
public:
	struct FHWPersistentPlayerId                  PlayerGuid;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UHWCharacterItem*                 HoveredPick;                                       // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0028(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWMatchDataSubsystem_OnPlayerHoveredLobbyPick) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_OnPlayerHoveredLobbyPick");
static_assert(sizeof(HWMatchDataSubsystem_OnPlayerHoveredLobbyPick) == 0x000030, "Wrong size on HWMatchDataSubsystem_OnPlayerHoveredLobbyPick");
static_assert(offsetof(HWMatchDataSubsystem_OnPlayerHoveredLobbyPick, PlayerGuid) == 0x000000, "Member 'HWMatchDataSubsystem_OnPlayerHoveredLobbyPick::PlayerGuid' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_OnPlayerHoveredLobbyPick, HoveredPick) == 0x000020, "Member 'HWMatchDataSubsystem_OnPlayerHoveredLobbyPick::HoveredPick' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_OnPlayerHoveredLobbyPick, TeamId) == 0x000028, "Member 'HWMatchDataSubsystem_OnPlayerHoveredLobbyPick::TeamId' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.OnRHSessionChanged
// 0x0010 (0x0010 - 0x0000)
struct HWMatchDataSubsystem_OnRHSessionChanged final
{
public:
	class URH_JoinedSession*                      OldSession;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URH_JoinedSession*                      ActiveSession;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMatchDataSubsystem_OnRHSessionChanged) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_OnRHSessionChanged");
static_assert(sizeof(HWMatchDataSubsystem_OnRHSessionChanged) == 0x000010, "Wrong size on HWMatchDataSubsystem_OnRHSessionChanged");
static_assert(offsetof(HWMatchDataSubsystem_OnRHSessionChanged, OldSession) == 0x000000, "Member 'HWMatchDataSubsystem_OnRHSessionChanged::OldSession' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_OnRHSessionChanged, ActiveSession) == 0x000008, "Member 'HWMatchDataSubsystem_OnRHSessionChanged::ActiveSession' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.UpdateMatchComposition
// 0x00A0 (0x00A0 - 0x0000)
struct HWMatchDataSubsystem_UpdateMatchComposition final
{
public:
	struct FHWInstanceInfo_PlayerDataList         InPlayerData;                                      // 0x0000(0x00A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMatchDataSubsystem_UpdateMatchComposition) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_UpdateMatchComposition");
static_assert(sizeof(HWMatchDataSubsystem_UpdateMatchComposition) == 0x0000A0, "Wrong size on HWMatchDataSubsystem_UpdateMatchComposition");
static_assert(offsetof(HWMatchDataSubsystem_UpdateMatchComposition, InPlayerData) == 0x000000, "Member 'HWMatchDataSubsystem_UpdateMatchComposition::InPlayerData' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.UpdateTeamPlayer
// 0x00A8 (0x00A8 - 0x0000)
struct HWMatchDataSubsystem_UpdateTeamPlayer final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWTeamPlayer                          InTeamPlayer;                                      // 0x0008(0x00A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMatchDataSubsystem_UpdateTeamPlayer) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_UpdateTeamPlayer");
static_assert(sizeof(HWMatchDataSubsystem_UpdateTeamPlayer) == 0x0000A8, "Wrong size on HWMatchDataSubsystem_UpdateTeamPlayer");
static_assert(offsetof(HWMatchDataSubsystem_UpdateTeamPlayer, TeamId) == 0x000000, "Member 'HWMatchDataSubsystem_UpdateTeamPlayer::TeamId' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_UpdateTeamPlayer, InTeamPlayer) == 0x000008, "Member 'HWMatchDataSubsystem_UpdateTeamPlayer::InTeamPlayer' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.GetCachedTeamPlayer
// 0x00B0 (0x00B0 - 0x0000)
struct HWMatchDataSubsystem_GetCachedTeamPlayer final
{
public:
	const class AHWPlayerState*                   PlayerState;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWTeamPlayer                          OutTeamPlayer;                                     // 0x0008(0x00A0)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWMatchDataSubsystem_GetCachedTeamPlayer) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_GetCachedTeamPlayer");
static_assert(sizeof(HWMatchDataSubsystem_GetCachedTeamPlayer) == 0x0000B0, "Wrong size on HWMatchDataSubsystem_GetCachedTeamPlayer");
static_assert(offsetof(HWMatchDataSubsystem_GetCachedTeamPlayer, PlayerState) == 0x000000, "Member 'HWMatchDataSubsystem_GetCachedTeamPlayer::PlayerState' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_GetCachedTeamPlayer, OutTeamPlayer) == 0x000008, "Member 'HWMatchDataSubsystem_GetCachedTeamPlayer::OutTeamPlayer' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_GetCachedTeamPlayer, ReturnValue) == 0x0000A8, "Member 'HWMatchDataSubsystem_GetCachedTeamPlayer::ReturnValue' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.GetCachedTeamPlayersSnapshot
// 0x0010 (0x0010 - 0x0000)
struct HWMatchDataSubsystem_GetCachedTeamPlayersSnapshot final
{
public:
	TArray<struct FHWTeamPlayersSnapshot>         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWMatchDataSubsystem_GetCachedTeamPlayersSnapshot) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_GetCachedTeamPlayersSnapshot");
static_assert(sizeof(HWMatchDataSubsystem_GetCachedTeamPlayersSnapshot) == 0x000010, "Wrong size on HWMatchDataSubsystem_GetCachedTeamPlayersSnapshot");
static_assert(offsetof(HWMatchDataSubsystem_GetCachedTeamPlayersSnapshot, ReturnValue) == 0x000000, "Member 'HWMatchDataSubsystem_GetCachedTeamPlayersSnapshot::ReturnValue' has a wrong offset!");

// Function Hemingway.HWMatchDataSubsystem.GetCachedTeamPlayersSnapshotForTeam
// 0x0068 (0x0068 - 0x0000)
struct HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam final
{
public:
	struct FGenericTeamId                         TeamId;                                            // 0x0000(0x0001)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHWTeamPlayersSnapshot                 OutTeamPlayersSnapshot;                            // 0x0008(0x0058)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam) == 0x000008, "Wrong alignment on HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam");
static_assert(sizeof(HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam) == 0x000068, "Wrong size on HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam");
static_assert(offsetof(HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam, TeamId) == 0x000000, "Member 'HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam::TeamId' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam, OutTeamPlayersSnapshot) == 0x000008, "Member 'HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam::OutTeamPlayersSnapshot' has a wrong offset!");
static_assert(offsetof(HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam, ReturnValue) == 0x000060, "Member 'HWMatchDataSubsystem_GetCachedTeamPlayersSnapshotForTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerSettingsSubsystem.CreatePlayerSettingUpdatedCallback
// 0x0028 (0x0028 - 0x0000)
struct HWPlayerSettingsSubsystem_CreatePlayerSettingUpdatedCallback final
{
public:
	class FName                                   SettingName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWSettingDelegateStruct               Delegate;                                          // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerSettingsSubsystem_CreatePlayerSettingUpdatedCallback) == 0x000004, "Wrong alignment on HWPlayerSettingsSubsystem_CreatePlayerSettingUpdatedCallback");
static_assert(sizeof(HWPlayerSettingsSubsystem_CreatePlayerSettingUpdatedCallback) == 0x000028, "Wrong size on HWPlayerSettingsSubsystem_CreatePlayerSettingUpdatedCallback");
static_assert(offsetof(HWPlayerSettingsSubsystem_CreatePlayerSettingUpdatedCallback, SettingName) == 0x000000, "Member 'HWPlayerSettingsSubsystem_CreatePlayerSettingUpdatedCallback::SettingName' has a wrong offset!");
static_assert(offsetof(HWPlayerSettingsSubsystem_CreatePlayerSettingUpdatedCallback, Delegate) == 0x000008, "Member 'HWPlayerSettingsSubsystem_CreatePlayerSettingUpdatedCallback::Delegate' has a wrong offset!");

// Function Hemingway.HWPlayerSettingsSubsystem.RemovePlayerSettingUpdatedCallback
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerSettingsSubsystem_RemovePlayerSettingUpdatedCallback final
{
public:
	class FName                                   SettingName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          CallbackOwner;                                     // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerSettingsSubsystem_RemovePlayerSettingUpdatedCallback) == 0x000008, "Wrong alignment on HWPlayerSettingsSubsystem_RemovePlayerSettingUpdatedCallback");
static_assert(sizeof(HWPlayerSettingsSubsystem_RemovePlayerSettingUpdatedCallback) == 0x000010, "Wrong size on HWPlayerSettingsSubsystem_RemovePlayerSettingUpdatedCallback");
static_assert(offsetof(HWPlayerSettingsSubsystem_RemovePlayerSettingUpdatedCallback, SettingName) == 0x000000, "Member 'HWPlayerSettingsSubsystem_RemovePlayerSettingUpdatedCallback::SettingName' has a wrong offset!");
static_assert(offsetof(HWPlayerSettingsSubsystem_RemovePlayerSettingUpdatedCallback, CallbackOwner) == 0x000008, "Member 'HWPlayerSettingsSubsystem_RemovePlayerSettingUpdatedCallback::CallbackOwner' has a wrong offset!");

// Function Hemingway.HWPlayerSettingsSubsystem.GetFavoriteGodItemIds
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerSettingsSubsystem_GetFavoriteGodItemIds final
{
public:
	TArray<struct FRH_ItemId>                     ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerSettingsSubsystem_GetFavoriteGodItemIds) == 0x000008, "Wrong alignment on HWPlayerSettingsSubsystem_GetFavoriteGodItemIds");
static_assert(sizeof(HWPlayerSettingsSubsystem_GetFavoriteGodItemIds) == 0x000010, "Wrong size on HWPlayerSettingsSubsystem_GetFavoriteGodItemIds");
static_assert(offsetof(HWPlayerSettingsSubsystem_GetFavoriteGodItemIds, ReturnValue) == 0x000000, "Member 'HWPlayerSettingsSubsystem_GetFavoriteGodItemIds::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerSettingsSubsystem.GetLastSeenOrderTime
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerSettingsSubsystem_GetLastSeenOrderTime final
{
public:
	struct FDateTime                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerSettingsSubsystem_GetLastSeenOrderTime) == 0x000008, "Wrong alignment on HWPlayerSettingsSubsystem_GetLastSeenOrderTime");
static_assert(sizeof(HWPlayerSettingsSubsystem_GetLastSeenOrderTime) == 0x000008, "Wrong size on HWPlayerSettingsSubsystem_GetLastSeenOrderTime");
static_assert(offsetof(HWPlayerSettingsSubsystem_GetLastSeenOrderTime, ReturnValue) == 0x000000, "Member 'HWPlayerSettingsSubsystem_GetLastSeenOrderTime::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerSettingsSubsystem.GetMappingContextComponent
// 0x0008 (0x0008 - 0x0000)
struct HWPlayerSettingsSubsystem_GetMappingContextComponent final
{
public:
	class UHWMappingContextComponent*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerSettingsSubsystem_GetMappingContextComponent) == 0x000008, "Wrong alignment on HWPlayerSettingsSubsystem_GetMappingContextComponent");
static_assert(sizeof(HWPlayerSettingsSubsystem_GetMappingContextComponent) == 0x000008, "Wrong size on HWPlayerSettingsSubsystem_GetMappingContextComponent");
static_assert(offsetof(HWPlayerSettingsSubsystem_GetMappingContextComponent, ReturnValue) == 0x000000, "Member 'HWPlayerSettingsSubsystem_GetMappingContextComponent::ReturnValue' has a wrong offset!");

// Function Hemingway.HWPlayerSettingsSubsystem.GetSelectedQueueId
// 0x0010 (0x0010 - 0x0000)
struct HWPlayerSettingsSubsystem_GetSelectedQueueId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWPlayerSettingsSubsystem_GetSelectedQueueId) == 0x000008, "Wrong alignment on HWPlayerSettingsSubsystem_GetSelectedQueueId");
static_assert(sizeof(HWPlayerSettingsSubsystem_GetSelectedQueueId) == 0x000010, "Wrong size on HWPlayerSettingsSubsystem_GetSelectedQueueId");
static_assert(offsetof(HWPlayerSettingsSubsystem_GetSelectedQueueId, ReturnValue) == 0x000000, "Member 'HWPlayerSettingsSubsystem_GetSelectedQueueId::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSettingsSubsystemInterface.GetSettingAsBool
// 0x000C (0x000C - 0x0000)
struct HWSettingsSubsystemInterface_GetSettingAsBool final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutBool;                                           // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSettingsSubsystemInterface_GetSettingAsBool) == 0x000004, "Wrong alignment on HWSettingsSubsystemInterface_GetSettingAsBool");
static_assert(sizeof(HWSettingsSubsystemInterface_GetSettingAsBool) == 0x00000C, "Wrong size on HWSettingsSubsystemInterface_GetSettingAsBool");
static_assert(offsetof(HWSettingsSubsystemInterface_GetSettingAsBool, Name_0) == 0x000000, "Member 'HWSettingsSubsystemInterface_GetSettingAsBool::Name_0' has a wrong offset!");
static_assert(offsetof(HWSettingsSubsystemInterface_GetSettingAsBool, OutBool) == 0x000008, "Member 'HWSettingsSubsystemInterface_GetSettingAsBool::OutBool' has a wrong offset!");
static_assert(offsetof(HWSettingsSubsystemInterface_GetSettingAsBool, ReturnValue) == 0x000009, "Member 'HWSettingsSubsystemInterface_GetSettingAsBool::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSettingsSubsystemInterface.GetSettingAsFloat
// 0x0010 (0x0010 - 0x0000)
struct HWSettingsSubsystemInterface_GetSettingAsFloat final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutFloat;                                          // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSettingsSubsystemInterface_GetSettingAsFloat) == 0x000004, "Wrong alignment on HWSettingsSubsystemInterface_GetSettingAsFloat");
static_assert(sizeof(HWSettingsSubsystemInterface_GetSettingAsFloat) == 0x000010, "Wrong size on HWSettingsSubsystemInterface_GetSettingAsFloat");
static_assert(offsetof(HWSettingsSubsystemInterface_GetSettingAsFloat, Name_0) == 0x000000, "Member 'HWSettingsSubsystemInterface_GetSettingAsFloat::Name_0' has a wrong offset!");
static_assert(offsetof(HWSettingsSubsystemInterface_GetSettingAsFloat, OutFloat) == 0x000008, "Member 'HWSettingsSubsystemInterface_GetSettingAsFloat::OutFloat' has a wrong offset!");
static_assert(offsetof(HWSettingsSubsystemInterface_GetSettingAsFloat, ReturnValue) == 0x00000C, "Member 'HWSettingsSubsystemInterface_GetSettingAsFloat::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSettingsSubsystemInterface.GetSettingAsInt
// 0x0010 (0x0010 - 0x0000)
struct HWSettingsSubsystemInterface_GetSettingAsInt final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutInt;                                            // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWSettingsSubsystemInterface_GetSettingAsInt) == 0x000004, "Wrong alignment on HWSettingsSubsystemInterface_GetSettingAsInt");
static_assert(sizeof(HWSettingsSubsystemInterface_GetSettingAsInt) == 0x000010, "Wrong size on HWSettingsSubsystemInterface_GetSettingAsInt");
static_assert(offsetof(HWSettingsSubsystemInterface_GetSettingAsInt, Name_0) == 0x000000, "Member 'HWSettingsSubsystemInterface_GetSettingAsInt::Name_0' has a wrong offset!");
static_assert(offsetof(HWSettingsSubsystemInterface_GetSettingAsInt, OutInt) == 0x000008, "Member 'HWSettingsSubsystemInterface_GetSettingAsInt::OutInt' has a wrong offset!");
static_assert(offsetof(HWSettingsSubsystemInterface_GetSettingAsInt, ReturnValue) == 0x00000C, "Member 'HWSettingsSubsystemInterface_GetSettingAsInt::ReturnValue' has a wrong offset!");

// Function Hemingway.HWSystemSettingsSubsystem.CreateSystemSettingUpdatedCallback
// 0x0028 (0x0028 - 0x0000)
struct HWSystemSettingsSubsystem_CreateSystemSettingUpdatedCallback final
{
public:
	class FName                                   SettingName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHWSettingDelegateStruct               Delegate;                                          // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSystemSettingsSubsystem_CreateSystemSettingUpdatedCallback) == 0x000004, "Wrong alignment on HWSystemSettingsSubsystem_CreateSystemSettingUpdatedCallback");
static_assert(sizeof(HWSystemSettingsSubsystem_CreateSystemSettingUpdatedCallback) == 0x000028, "Wrong size on HWSystemSettingsSubsystem_CreateSystemSettingUpdatedCallback");
static_assert(offsetof(HWSystemSettingsSubsystem_CreateSystemSettingUpdatedCallback, SettingName) == 0x000000, "Member 'HWSystemSettingsSubsystem_CreateSystemSettingUpdatedCallback::SettingName' has a wrong offset!");
static_assert(offsetof(HWSystemSettingsSubsystem_CreateSystemSettingUpdatedCallback, Delegate) == 0x000008, "Member 'HWSystemSettingsSubsystem_CreateSystemSettingUpdatedCallback::Delegate' has a wrong offset!");

// Function Hemingway.HWSystemSettingsSubsystem.HandleSettingApplied
// 0x0008 (0x0008 - 0x0000)
struct HWSystemSettingsSubsystem_HandleSettingApplied final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSystemSettingsSubsystem_HandleSettingApplied) == 0x000004, "Wrong alignment on HWSystemSettingsSubsystem_HandleSettingApplied");
static_assert(sizeof(HWSystemSettingsSubsystem_HandleSettingApplied) == 0x000008, "Wrong size on HWSystemSettingsSubsystem_HandleSettingApplied");
static_assert(offsetof(HWSystemSettingsSubsystem_HandleSettingApplied, Name_0) == 0x000000, "Member 'HWSystemSettingsSubsystem_HandleSettingApplied::Name_0' has a wrong offset!");

// Function Hemingway.HWSystemSettingsSubsystem.RemoveSystemSettingUpdatedCallback
// 0x0010 (0x0010 - 0x0000)
struct HWSystemSettingsSubsystem_RemoveSystemSettingUpdatedCallback final
{
public:
	class FName                                   SettingName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          CallbackOwner;                                     // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HWSystemSettingsSubsystem_RemoveSystemSettingUpdatedCallback) == 0x000008, "Wrong alignment on HWSystemSettingsSubsystem_RemoveSystemSettingUpdatedCallback");
static_assert(sizeof(HWSystemSettingsSubsystem_RemoveSystemSettingUpdatedCallback) == 0x000010, "Wrong size on HWSystemSettingsSubsystem_RemoveSystemSettingUpdatedCallback");
static_assert(offsetof(HWSystemSettingsSubsystem_RemoveSystemSettingUpdatedCallback, SettingName) == 0x000000, "Member 'HWSystemSettingsSubsystem_RemoveSystemSettingUpdatedCallback::SettingName' has a wrong offset!");
static_assert(offsetof(HWSystemSettingsSubsystem_RemoveSystemSettingUpdatedCallback, CallbackOwner) == 0x000008, "Member 'HWSystemSettingsSubsystem_RemoveSystemSettingUpdatedCallback::CallbackOwner' has a wrong offset!");

// Function Hemingway.HWUpscalerSubsystem.HandleUpscalersKVChanged
// 0x000C (0x000C - 0x0000)
struct HWUpscalerSubsystem_HandleUpscalersKVChanged final
{
public:
	struct FGameplayTag                           AppSettingTag;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValue;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HWUpscalerSubsystem_HandleUpscalersKVChanged) == 0x000004, "Wrong alignment on HWUpscalerSubsystem_HandleUpscalersKVChanged");
static_assert(sizeof(HWUpscalerSubsystem_HandleUpscalersKVChanged) == 0x00000C, "Wrong size on HWUpscalerSubsystem_HandleUpscalersKVChanged");
static_assert(offsetof(HWUpscalerSubsystem_HandleUpscalersKVChanged, AppSettingTag) == 0x000000, "Member 'HWUpscalerSubsystem_HandleUpscalersKVChanged::AppSettingTag' has a wrong offset!");
static_assert(offsetof(HWUpscalerSubsystem_HandleUpscalersKVChanged, bValue) == 0x000008, "Member 'HWUpscalerSubsystem_HandleUpscalersKVChanged::bValue' has a wrong offset!");

// Function Hemingway.VisibilityData.HandleActiveGameplayEffectAdded
// 0x02B8 (0x02B8 - 0x0000)
struct VisibilityData_HandleActiveGameplayEffectAdded final
{
public:
	class UAbilitySystemComponent*                ASC;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0008(0x02A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x02B0(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisibilityData_HandleActiveGameplayEffectAdded) == 0x000008, "Wrong alignment on VisibilityData_HandleActiveGameplayEffectAdded");
static_assert(sizeof(VisibilityData_HandleActiveGameplayEffectAdded) == 0x0002B8, "Wrong size on VisibilityData_HandleActiveGameplayEffectAdded");
static_assert(offsetof(VisibilityData_HandleActiveGameplayEffectAdded, ASC) == 0x000000, "Member 'VisibilityData_HandleActiveGameplayEffectAdded::ASC' has a wrong offset!");
static_assert(offsetof(VisibilityData_HandleActiveGameplayEffectAdded, EffectSpec) == 0x000008, "Member 'VisibilityData_HandleActiveGameplayEffectAdded::EffectSpec' has a wrong offset!");
static_assert(offsetof(VisibilityData_HandleActiveGameplayEffectAdded, EffectHandle) == 0x0002B0, "Member 'VisibilityData_HandleActiveGameplayEffectAdded::EffectHandle' has a wrong offset!");

// Function Hemingway.VisibilityData.HandleAnyGameplayEffectRemoved
// 0x0400 (0x0400 - 0x0000)
struct VisibilityData_HandleAnyGameplayEffectRemoved final
{
public:
	struct FActiveGameplayEffect                  ActiveGameplayEffect;                              // 0x0000(0x0400)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisibilityData_HandleAnyGameplayEffectRemoved) == 0x000008, "Wrong alignment on VisibilityData_HandleAnyGameplayEffectRemoved");
static_assert(sizeof(VisibilityData_HandleAnyGameplayEffectRemoved) == 0x000400, "Wrong size on VisibilityData_HandleAnyGameplayEffectRemoved");
static_assert(offsetof(VisibilityData_HandleAnyGameplayEffectRemoved, ActiveGameplayEffect) == 0x000000, "Member 'VisibilityData_HandleAnyGameplayEffectRemoved::ActiveGameplayEffect' has a wrong offset!");

// Function Hemingway.VisibilityData.GetStealthStatusToTarget
// 0x0010 (0x0010 - 0x0000)
struct VisibilityData_GetStealthStatusToTarget final
{
public:
	const class AActor*                           ObservingActor;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VisibilityData_GetStealthStatusToTarget) == 0x000008, "Wrong alignment on VisibilityData_GetStealthStatusToTarget");
static_assert(sizeof(VisibilityData_GetStealthStatusToTarget) == 0x000010, "Wrong size on VisibilityData_GetStealthStatusToTarget");
static_assert(offsetof(VisibilityData_GetStealthStatusToTarget, ObservingActor) == 0x000000, "Member 'VisibilityData_GetStealthStatusToTarget::ObservingActor' has a wrong offset!");
static_assert(offsetof(VisibilityData_GetStealthStatusToTarget, ReturnValue) == 0x000008, "Member 'VisibilityData_GetStealthStatusToTarget::ReturnValue' has a wrong offset!");

// Function Hemingway.VisibilityData.IsTargetTypeVisibleToEntireTeam
// 0x0010 (0x0010 - 0x0000)
struct VisibilityData_IsTargetTypeVisibleToEntireTeam final
{
public:
	const class AHWTeamState*                     ObservingTeamState;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VisibilityData_IsTargetTypeVisibleToEntireTeam) == 0x000008, "Wrong alignment on VisibilityData_IsTargetTypeVisibleToEntireTeam");
static_assert(sizeof(VisibilityData_IsTargetTypeVisibleToEntireTeam) == 0x000010, "Wrong size on VisibilityData_IsTargetTypeVisibleToEntireTeam");
static_assert(offsetof(VisibilityData_IsTargetTypeVisibleToEntireTeam, ObservingTeamState) == 0x000000, "Member 'VisibilityData_IsTargetTypeVisibleToEntireTeam::ObservingTeamState' has a wrong offset!");
static_assert(offsetof(VisibilityData_IsTargetTypeVisibleToEntireTeam, ReturnValue) == 0x000008, "Member 'VisibilityData_IsTargetTypeVisibleToEntireTeam::ReturnValue' has a wrong offset!");

// Function Hemingway.VisibilityData.ShouldIgnoreTeamVisibilitySharing
// 0x0001 (0x0001 - 0x0000)
struct VisibilityData_ShouldIgnoreTeamVisibilitySharing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisibilityData_ShouldIgnoreTeamVisibilitySharing) == 0x000001, "Wrong alignment on VisibilityData_ShouldIgnoreTeamVisibilitySharing");
static_assert(sizeof(VisibilityData_ShouldIgnoreTeamVisibilitySharing) == 0x000001, "Wrong size on VisibilityData_ShouldIgnoreTeamVisibilitySharing");
static_assert(offsetof(VisibilityData_ShouldIgnoreTeamVisibilitySharing, ReturnValue) == 0x000000, "Member 'VisibilityData_ShouldIgnoreTeamVisibilitySharing::ReturnValue' has a wrong offset!");

}

