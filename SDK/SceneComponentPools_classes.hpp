#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SceneComponentPools

#include "Basic.hpp"

#include "SceneComponentPools_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class SceneComponentPools.BasePoolComponent
// 0x0020 (0x00C0 - 0x00A0)
class UBasePoolComponent : public UActorComponent
{
public:
	int32                                         MaxPoolSize;                                       // 0x00A0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingPoolSize;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ComponentClassName;                                // 0x00A8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPoolOverflowHandling                         OverflowType;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePoolComponent">();
	}
	static class UBasePoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePoolComponent>();
	}
};
static_assert(alignof(UBasePoolComponent) == 0x000008, "Wrong alignment on UBasePoolComponent");
static_assert(sizeof(UBasePoolComponent) == 0x0000C0, "Wrong size on UBasePoolComponent");
static_assert(offsetof(UBasePoolComponent, MaxPoolSize) == 0x0000A0, "Member 'UBasePoolComponent::MaxPoolSize' has a wrong offset!");
static_assert(offsetof(UBasePoolComponent, StartingPoolSize) == 0x0000A4, "Member 'UBasePoolComponent::StartingPoolSize' has a wrong offset!");
static_assert(offsetof(UBasePoolComponent, ComponentClassName) == 0x0000A8, "Member 'UBasePoolComponent::ComponentClassName' has a wrong offset!");
static_assert(offsetof(UBasePoolComponent, OverflowType) == 0x0000B8, "Member 'UBasePoolComponent::OverflowType' has a wrong offset!");

// Class SceneComponentPools.DecalPoolComponent
// 0x0078 (0x0138 - 0x00C0)
class UDecalPoolComponent : public UBasePoolComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPoolableDecalComponent>    PooledDecalComponentClass;                         // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPoolableDecalComponent*>        UnusedComponentsArray;                             // 0x00D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class UPoolableDecalComponent*>          UsedComponentsSet;                                 // 0x00E0(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UPoolableDecalComponent*                PeekedDecalComponent;                              // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalPoolComponent">();
	}
	static class UDecalPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalPoolComponent>();
	}
};
static_assert(alignof(UDecalPoolComponent) == 0x000008, "Wrong alignment on UDecalPoolComponent");
static_assert(sizeof(UDecalPoolComponent) == 0x000138, "Wrong size on UDecalPoolComponent");
static_assert(offsetof(UDecalPoolComponent, PooledDecalComponentClass) == 0x0000C8, "Member 'UDecalPoolComponent::PooledDecalComponentClass' has a wrong offset!");
static_assert(offsetof(UDecalPoolComponent, UnusedComponentsArray) == 0x0000D0, "Member 'UDecalPoolComponent::UnusedComponentsArray' has a wrong offset!");
static_assert(offsetof(UDecalPoolComponent, UsedComponentsSet) == 0x0000E0, "Member 'UDecalPoolComponent::UsedComponentsSet' has a wrong offset!");
static_assert(offsetof(UDecalPoolComponent, PeekedDecalComponent) == 0x000130, "Member 'UDecalPoolComponent::PeekedDecalComponent' has a wrong offset!");

// Class SceneComponentPools.FootprintDecalPoolComponent
// 0x0000 (0x0138 - 0x0138)
class UFootprintDecalPoolComponent final : public UDecalPoolComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootprintDecalPoolComponent">();
	}
	static class UFootprintDecalPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootprintDecalPoolComponent>();
	}
};
static_assert(alignof(UFootprintDecalPoolComponent) == 0x000008, "Wrong alignment on UFootprintDecalPoolComponent");
static_assert(sizeof(UFootprintDecalPoolComponent) == 0x000138, "Wrong size on UFootprintDecalPoolComponent");

// Class SceneComponentPools.GunshotDecalPoolComponent
// 0x0000 (0x0138 - 0x0138)
class UGunshotDecalPoolComponent final : public UDecalPoolComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunshotDecalPoolComponent">();
	}
	static class UGunshotDecalPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunshotDecalPoolComponent>();
	}
};
static_assert(alignof(UGunshotDecalPoolComponent) == 0x000008, "Wrong alignment on UGunshotDecalPoolComponent");
static_assert(sizeof(UGunshotDecalPoolComponent) == 0x000138, "Wrong size on UGunshotDecalPoolComponent");

// Class SceneComponentPools.ParticleSystemPoolComponentBase
// 0x0080 (0x0140 - 0x00C0)
class UParticleSystemPoolComponentBase : public UBasePoolComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UParticleSystemComponent>   PooledParticleSystemComponentClass;                // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UParticleSystemComponent*>       UnusedComponentsArray;                             // 0x00D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class UParticleSystemComponent*>         UsedComponentsSet;                                 // 0x00E0(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               PeekedParticleSystemComponent;                     // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClearTemplateWhenReturnedToPool;                  // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPSCFinished(class UParticleSystemComponent* InPSC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystemPoolComponentBase">();
	}
	static class UParticleSystemPoolComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSystemPoolComponentBase>();
	}
};
static_assert(alignof(UParticleSystemPoolComponentBase) == 0x000008, "Wrong alignment on UParticleSystemPoolComponentBase");
static_assert(sizeof(UParticleSystemPoolComponentBase) == 0x000140, "Wrong size on UParticleSystemPoolComponentBase");
static_assert(offsetof(UParticleSystemPoolComponentBase, PooledParticleSystemComponentClass) == 0x0000C8, "Member 'UParticleSystemPoolComponentBase::PooledParticleSystemComponentClass' has a wrong offset!");
static_assert(offsetof(UParticleSystemPoolComponentBase, UnusedComponentsArray) == 0x0000D0, "Member 'UParticleSystemPoolComponentBase::UnusedComponentsArray' has a wrong offset!");
static_assert(offsetof(UParticleSystemPoolComponentBase, UsedComponentsSet) == 0x0000E0, "Member 'UParticleSystemPoolComponentBase::UsedComponentsSet' has a wrong offset!");
static_assert(offsetof(UParticleSystemPoolComponentBase, PeekedParticleSystemComponent) == 0x000130, "Member 'UParticleSystemPoolComponentBase::PeekedParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(UParticleSystemPoolComponentBase, bClearTemplateWhenReturnedToPool) == 0x000138, "Member 'UParticleSystemPoolComponentBase::bClearTemplateWhenReturnedToPool' has a wrong offset!");

// Class SceneComponentPools.ParticleSystemPoolComponent
// 0x0000 (0x0140 - 0x0140)
class UParticleSystemPoolComponent final : public UParticleSystemPoolComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystemPoolComponent">();
	}
	static class UParticleSystemPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSystemPoolComponent>();
	}
};
static_assert(alignof(UParticleSystemPoolComponent) == 0x000008, "Wrong alignment on UParticleSystemPoolComponent");
static_assert(sizeof(UParticleSystemPoolComponent) == 0x000140, "Wrong size on UParticleSystemPoolComponent");

// Class SceneComponentPools.PoolableDecalComponent
// 0x0030 (0x0330 - 0x0300)
class UPoolableDecalComponent final : public UDecalComponent
{
public:
	uint8                                         Pad_300[0x18];                                     // 0x0300(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UPoolableDecalComponent* FinishedDecalComponent)> OnDecalReturnedToPoolDelegate; // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bInUse;                                            // 0x0328(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceReturnToPool();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableDecalComponent">();
	}
	static class UPoolableDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoolableDecalComponent>();
	}
};
static_assert(alignof(UPoolableDecalComponent) == 0x000010, "Wrong alignment on UPoolableDecalComponent");
static_assert(sizeof(UPoolableDecalComponent) == 0x000330, "Wrong size on UPoolableDecalComponent");
static_assert(offsetof(UPoolableDecalComponent, OnDecalReturnedToPoolDelegate) == 0x000318, "Member 'UPoolableDecalComponent::OnDecalReturnedToPoolDelegate' has a wrong offset!");
static_assert(offsetof(UPoolableDecalComponent, bInUse) == 0x000328, "Member 'UPoolableDecalComponent::bInUse' has a wrong offset!");

// Class SceneComponentPools.SceneComponentPoolStatics
// 0x0000 (0x0028 - 0x0028)
class USceneComponentPoolStatics final : public UBlueprintFunctionLibrary
{
public:
	static class USkeletalMeshComponent* GetComponentForSkeletalMesh(const class UObject* WorldContextObject, class USkeletalMesh* Mesh, class USceneComponent* AttachToComponent, const class FName& AttachSocketName);
	static class UStaticMeshComponent* GetComponentForStaticMesh(const class UObject* WorldContextObject, class UStaticMesh* Mesh, class USceneComponent* AttachToComponent, const class FName& AttachSocketName);
	static void ReleaseSpawnedDecals(const class UObject* WorldContextObject);
	static void ReleaseSpawnedEmitters(const class UObject* WorldContextObject);
	static void ReleaseSpawnedSkeletalMesh(class USkeletalMesh* SkeletalMesh, TSubclassOf<class UAnimInstance> AnimClass, class USceneComponent* AttachToComponent, const struct FPoolAttachmentInfo& AttachInfo);
	static void ReleaseSpawnedSkeletalMeshComponent(class USkeletalMeshComponent* SkeletalMeshComponent);
	static void ReleaseSpawnedSkeletalMeshes(const class UObject* WorldContextObject);
	static void ReleaseSpawnedStaticMesh(class UStaticMesh* StaticMeshComponent, class USceneComponent* AttachToComponent, const struct FPoolAttachmentInfo& AttachInfo);
	static void ReleaseSpawnedStaticMeshComponent(class UStaticMeshComponent* StaticMeshComponent);
	static void ReleaseSpawnedStaticMeshes(const class UObject* WorldContextObject);
	static class UPoolableDecalComponent* SpawnDecalAtLocation(const class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan, EDecalComponentType DecalComponentType);
	static class UPoolableDecalComponent* SpawnDecalAttached(class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, float LifeSpan, EDecalComponentType DecalComponentType);
	static class UParticleSystemComponent* SpawnEmitterAtLocation(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale);
	static class UParticleSystemComponent* SpawnEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType);
	static class USkeletalMeshComponent* SpawnSkeletalMeshAttached(class USkeletalMesh* Mesh, TSubclassOf<class UAnimInstance> AnimClass, class USceneComponent* AttachToComponent, const struct FPoolAttachmentInfo& AttachInfo);
	static class UStaticMeshComponent* SpawnStaticMeshAttached(class UStaticMesh* Mesh, class USceneComponent* AttachToComponent, const struct FPoolAttachmentInfo& AttachInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneComponentPoolStatics">();
	}
	static class USceneComponentPoolStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneComponentPoolStatics>();
	}
};
static_assert(alignof(USceneComponentPoolStatics) == 0x000008, "Wrong alignment on USceneComponentPoolStatics");
static_assert(sizeof(USceneComponentPoolStatics) == 0x000028, "Wrong size on USceneComponentPoolStatics");

// Class SceneComponentPools.SkeletalMeshPoolComponent
// 0x0078 (0x0138 - 0x00C0)
class USkeletalMeshPoolComponent final : public UBasePoolComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkeletalMeshComponent*>         UnusedComponentsArray;                             // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class USkeletalMeshComponent*>           UsedComponentsSet;                                 // 0x00D8(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PeekedSkeletalMeshComponent;                       // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USkeletalMeshComponent>     PooledSkeletalMeshComponentClass;                  // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMeshPoolComponent">();
	}
	static class USkeletalMeshPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletalMeshPoolComponent>();
	}
};
static_assert(alignof(USkeletalMeshPoolComponent) == 0x000008, "Wrong alignment on USkeletalMeshPoolComponent");
static_assert(sizeof(USkeletalMeshPoolComponent) == 0x000138, "Wrong size on USkeletalMeshPoolComponent");
static_assert(offsetof(USkeletalMeshPoolComponent, UnusedComponentsArray) == 0x0000C8, "Member 'USkeletalMeshPoolComponent::UnusedComponentsArray' has a wrong offset!");
static_assert(offsetof(USkeletalMeshPoolComponent, UsedComponentsSet) == 0x0000D8, "Member 'USkeletalMeshPoolComponent::UsedComponentsSet' has a wrong offset!");
static_assert(offsetof(USkeletalMeshPoolComponent, PeekedSkeletalMeshComponent) == 0x000128, "Member 'USkeletalMeshPoolComponent::PeekedSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(USkeletalMeshPoolComponent, PooledSkeletalMeshComponentClass) == 0x000130, "Member 'USkeletalMeshPoolComponent::PooledSkeletalMeshComponentClass' has a wrong offset!");

// Class SceneComponentPools.StaticMeshPoolComponent
// 0x0078 (0x0138 - 0x00C0)
class UStaticMeshPoolComponent final : public UBasePoolComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           UnusedComponentsArray;                             // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class UStaticMeshComponent*>             UsedComponentsSet;                                 // 0x00D8(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PeekedStaticMeshComponent;                         // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStaticMeshComponent>       PooledStaticMeshComponentClass;                    // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshPoolComponent">();
	}
	static class UStaticMeshPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticMeshPoolComponent>();
	}
};
static_assert(alignof(UStaticMeshPoolComponent) == 0x000008, "Wrong alignment on UStaticMeshPoolComponent");
static_assert(sizeof(UStaticMeshPoolComponent) == 0x000138, "Wrong size on UStaticMeshPoolComponent");
static_assert(offsetof(UStaticMeshPoolComponent, UnusedComponentsArray) == 0x0000C8, "Member 'UStaticMeshPoolComponent::UnusedComponentsArray' has a wrong offset!");
static_assert(offsetof(UStaticMeshPoolComponent, UsedComponentsSet) == 0x0000D8, "Member 'UStaticMeshPoolComponent::UsedComponentsSet' has a wrong offset!");
static_assert(offsetof(UStaticMeshPoolComponent, PeekedStaticMeshComponent) == 0x000128, "Member 'UStaticMeshPoolComponent::PeekedStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(UStaticMeshPoolComponent, PooledStaticMeshComponentClass) == 0x000130, "Member 'UStaticMeshPoolComponent::PooledStaticMeshComponentClass' has a wrong offset!");

}

