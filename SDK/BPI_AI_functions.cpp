#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPI_AI

#include "Basic.hpp"

#include "BPI_AI_classes.hpp"
#include "BPI_AI_parameters.hpp"


namespace SDK
{

// Function BPI_AI.BPI_AI_C.ApplyAncientFuryDebuff
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_AI_C::ApplyAncientFuryDebuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "ApplyAncientFuryDebuff");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_AI.BPI_AI_C.EndAbilityCalled
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_AI_C::EndAbilityCalled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "EndAbilityCalled");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_AI.BPI_AI_C.GetLeashCapsule
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent**             LeashComponent                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void IBPI_AI_C::GetLeashCapsule(class UPrimitiveComponent** LeashComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "GetLeashCapsule");

	Params::BPI_AI_C_GetLeashCapsule Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (LeashComponent != nullptr)
		*LeashComponent = Parms.LeashComponent;
}


// Function BPI_AI.BPI_AI_C.GetLeashRadius
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 LeashRadius                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_AI_C::GetLeashRadius(double* LeashRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "GetLeashRadius");

	Params::BPI_AI_C_GetLeashRadius Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (LeashRadius != nullptr)
		*LeashRadius = Parms.LeashRadius;
}


// Function BPI_AI.BPI_AI_C.GetLeashVolume
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class ATriggerVolume>*   LeashVolume                                            (Parm, OutParm, HasGetValueTypeHash)

void IBPI_AI_C::GetLeashVolume(TSoftObjectPtr<class ATriggerVolume>* LeashVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "GetLeashVolume");

	Params::BPI_AI_C_GetLeashVolume Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (LeashVolume != nullptr)
		*LeashVolume = Parms.LeashVolume;
}


// Function BPI_AI.BPI_AI_C.GetNearbyMinionCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  MinionCount                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_AI_C::GetNearbyMinionCount(int32* MinionCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "GetNearbyMinionCount");

	Params::BPI_AI_C_GetNearbyMinionCount Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (MinionCount != nullptr)
		*MinionCount = Parms.MinionCount;
}


// Function BPI_AI.BPI_AI_C.GetStartingWaypoints
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<TSoftObjectPtr<class AWaypoint_C>>*Waypoints                                              (Parm, OutParm)

void IBPI_AI_C::GetStartingWaypoints(TArray<TSoftObjectPtr<class AWaypoint_C>>* Waypoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "GetStartingWaypoints");

	Params::BPI_AI_C_GetStartingWaypoints Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Waypoints != nullptr)
		*Waypoints = std::move(Parms.Waypoints);
}


// Function BPI_AI.BPI_AI_C.RemoveAncientFuryDebuff
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_AI_C::RemoveAncientFuryDebuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "RemoveAncientFuryDebuff");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_AI.BPI_AI_C.RetrieveTargetActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor**                          CurrentTargetActor                                     (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IBPI_AI_C::RetrieveTargetActor(class AActor** CurrentTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "RetrieveTargetActor");

	Params::BPI_AI_C_RetrieveTargetActor Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (CurrentTargetActor != nullptr)
		*CurrentTargetActor = Parms.CurrentTargetActor;
}


// Function BPI_AI.BPI_AI_C.UpdateNearbyMinionCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  NewMinionCount                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_AI_C::UpdateNearbyMinionCount(int32 NewCount, int32* NewMinionCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "UpdateNearbyMinionCount");

	Params::BPI_AI_C_UpdateNearbyMinionCount Parms{};

	Parms.NewCount = NewCount;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (NewMinionCount != nullptr)
		*NewMinionCount = Parms.NewMinionCount;
}


// Function BPI_AI.BPI_AI_C.UpdateTargetActor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           NewTargetActor                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IBPI_AI_C::UpdateTargetActor(class AActor* NewTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_AI_C", "UpdateTargetActor");

	Params::BPI_AI_C_UpdateTargetActor Parms{};

	Parms.NewTargetActor = NewTargetActor;

	AsUObject()->ProcessEvent(Func, &Parms);
}

}

