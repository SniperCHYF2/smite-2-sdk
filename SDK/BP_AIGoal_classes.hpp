#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AIGoal

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Hemingway_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_AIGoal.BP_AIGoal_C
// 0x0180 (0x0268 - 0x00E8)
class UBP_AIGoal_C : public UHWAIGoal
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00E8(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	double                                        Disposition;                                       // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<struct FGameplayTag, double>             RoleWeightMultiplier;                              // 0x00F8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<struct FGameplayTag, double>             DifficultyWeightMulitplier;                        // 0x0148(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          EnableDisposition;                                 // 0x0198(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DispositionMin;                                    // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        DispositionMax;                                    // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          EnableJitter;                                      // 0x01B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        JitterMin;                                         // 0x01B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        JitterMax;                                         // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        RoleWeight;                                        // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        DifficultyWeight;                                  // 0x01D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        DebugVariance;                                     // 0x01D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<class FName, double>                     TrackedContributions;                              // 0x01E0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          bDebugWeight;                                      // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DebugName;                                         // 0x0234(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        BonusAdditiveScore;                                // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDebugVerbose;                                     // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MinScore;                                          // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FString                                 DebugCharacteFilter;                               // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)

public:
	void AddBonus(double AdditiveBonus);
	void ApplyBonus(double Score, double* FinalScore);
	void ApplyCompensation();
	double ApplyCompensationFactor(double RawWeight, int32 NumWeights);
	void BonusClosestTargetIsEnemyGod(class AHWAIController* InController, double ClosestEnemyIsGodBonus);
	void BonusIsInProgress(double InProgressBonus);
	void BonusRecentDamage(class AHWAIController* InController, double RecentDamageBonus, double PctMaxHealthDmgThreshold);
	void BonusTargetTag(class AHWAIController* InController, double TagBonus, const struct FGameplayTag& TagToCheck);
	void BonusUltimateReady(class AHWAIController* InController, double UltimateReadyBonus);
	float CalculateWeight(class AHWAIController* InController);
	bool CheckPreconditionsBP(class AHWAIController* InController);
	void ConstructDebugWeightString(class FString* String);
	void ExecuteUbergraph_BP_AIGoal(int32 EntryPoint);
	void GetDifficultyWeight(class AHWAIController* InController, double* RoleWeight_0);
	void GetDispositionWeight(double* DispositionWeight);
	void GetJitterAdd(double* JitterWeight);
	void GetRoleWeight(class AHWAIController* InController, double* RoleWeight_0);
	void MultiplyFinalModfierWeights(class AHWAIController* InController, double Score, double* WeightedScore);
	void Print_Weight(double Weight, class AHWAIController* InController);
	void TrackAbilities(class AHWAIController* InController, class UCurveFloat* CurveFunction, double AbilitiesReadyMin, double AbilitiesReadyMax);
	void TrackAllyGodCount(class AHWAIController* InController, class UCurveFloat* CurveFunction, double MaxRange, double GodCountMin, double GodCountMax);
	void TrackAllyVsEnemyGodDelta(class AHWAIController* InController, class UCurveFloat* CurveFunction, double Range, double DeltaMin, double DeltaMax);
	void TrackAllyVsEnemyMinionDelta(class AHWAIController* InController, class UCurveFloat* CurveFunction, double Range, double DeltaMin, double DeltaMax);
	void TrackAvgEnemyGodHealth(class AHWAIController* InController, class UCurveFloat* CurveFunction, double Range, double HealthPctMin, double HealthPctMax);
	void TrackContribution(class FName Key, double Score);
	void TrackContributionEnhanced(class FName Key, class UCurveFloat* CurveFunction, double Input, double Min, double Max);
	void TrackEnemyGodCount(class AHWAIController* InController, class UCurveFloat* CurveFunction, double Range, double GodCountMin, double GodCountMax);
	void TrackGold(class AHWAIController* InController, class UCurveFloat* CurveFunction, double GoldMin, double GoldMax);
	void TrackLevel(class AHWAIController* InController, class UCurveFloat* CurveFunction, double MinLevel, double MaxLevel);
	void TrackNearestEnemyGodDistance(class AHWAIController* InController, class UCurveFloat* CurveFunction, double DistanceMin, double DistanceMax);
	void TrackSelfHealth(class AHWAIController* InController, class UCurveFloat* CurveFunction, double HealthPctMin, double HealthPctMax);
	void TrackSelfMana(class AHWAIController* InController, class UCurveFloat* CurveFunction, double ManaPctMin, double ManaPctMax);
	void TrackSelfVsTargetHealthDelta(class AHWAIController* InController, class UCurveFloat* CurveFunction, double DeltaPctMin, double DeltaPctMax);
	void TrackTargetDistance(class AHWAIController* InController, class UCurveFloat* CurveFunction, double DistanceMin, double DistanceMax);
	void TrackTargetHealth(class AHWAIController* InController, class UCurveFloat* CurveFunction);
	void UpdateDebugText();

	void MultiplyContributions(TMap<class FName, double>& Contributions, double* Score) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_AIGoal_C">();
	}
	static class UBP_AIGoal_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_AIGoal_C>();
	}
};
static_assert(alignof(UBP_AIGoal_C) == 0x000008, "Wrong alignment on UBP_AIGoal_C");
static_assert(sizeof(UBP_AIGoal_C) == 0x000268, "Wrong size on UBP_AIGoal_C");
static_assert(offsetof(UBP_AIGoal_C, UberGraphFrame) == 0x0000E8, "Member 'UBP_AIGoal_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, Disposition) == 0x0000F0, "Member 'UBP_AIGoal_C::Disposition' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, RoleWeightMultiplier) == 0x0000F8, "Member 'UBP_AIGoal_C::RoleWeightMultiplier' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, DifficultyWeightMulitplier) == 0x000148, "Member 'UBP_AIGoal_C::DifficultyWeightMulitplier' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, EnableDisposition) == 0x000198, "Member 'UBP_AIGoal_C::EnableDisposition' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, DispositionMin) == 0x0001A0, "Member 'UBP_AIGoal_C::DispositionMin' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, DispositionMax) == 0x0001A8, "Member 'UBP_AIGoal_C::DispositionMax' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, EnableJitter) == 0x0001B0, "Member 'UBP_AIGoal_C::EnableJitter' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, JitterMin) == 0x0001B8, "Member 'UBP_AIGoal_C::JitterMin' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, JitterMax) == 0x0001C0, "Member 'UBP_AIGoal_C::JitterMax' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, RoleWeight) == 0x0001C8, "Member 'UBP_AIGoal_C::RoleWeight' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, DifficultyWeight) == 0x0001D0, "Member 'UBP_AIGoal_C::DifficultyWeight' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, DebugVariance) == 0x0001D8, "Member 'UBP_AIGoal_C::DebugVariance' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, TrackedContributions) == 0x0001E0, "Member 'UBP_AIGoal_C::TrackedContributions' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, bDebugWeight) == 0x000230, "Member 'UBP_AIGoal_C::bDebugWeight' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, DebugName) == 0x000234, "Member 'UBP_AIGoal_C::DebugName' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, BonusAdditiveScore) == 0x000240, "Member 'UBP_AIGoal_C::BonusAdditiveScore' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, bDebugVerbose) == 0x000248, "Member 'UBP_AIGoal_C::bDebugVerbose' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, MinScore) == 0x000250, "Member 'UBP_AIGoal_C::MinScore' has a wrong offset!");
static_assert(offsetof(UBP_AIGoal_C, DebugCharacteFilter) == 0x000258, "Member 'UBP_AIGoal_C::DebugCharacteFilter' has a wrong offset!");

}

